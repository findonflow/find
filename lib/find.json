{
   "networks": {
      "emulator": {
         "scripts": {
            "getCatalog": {
               "code": "import NFTCatalog from 0xf8d6e0586b0a20c7\nimport FINDNFTCatalog from 0xf8d6e0586b0a20c7\n\npub fun main() : {String : NFTCatalog.NFTCatalogMetadata} {\n    return FINDNFTCatalog.getCatalog() \n}",
               "spec": {
                  "order": [],
                  "parameters": {}
               }
            },
            "getCatalogCollectionDisplay": {
               "code": "import MetadataViews from 0xf8d6e0586b0a20c7\nimport NFTCatalog from 0xf8d6e0586b0a20c7\nimport FINDNFTCatalog from 0xf8d6e0586b0a20c7\n\npub fun main(collectionIdentifier : String) : NFTCatalogMetadata? {\n    if let catalog = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier) {\n        return NFTCatalogMetadata(\n            contractName : catalog.contractName, \n            contractAddress : catalog.contractAddress, \n            nftType: catalog.nftType, \n            collectionDisplay : catalog.collectionDisplay\n        )\n    }\n    return nil\n}\n\npub struct NFTCatalogMetadata {\n    pub let contractName : String\n    pub let contractAddress : Address\n    pub let nftType: String\n    pub let collectionDisplay: MetadataViews.NFTCollectionDisplay\n\n    init (contractName : String, contractAddress : Address, nftType: Type, collectionDisplay : MetadataViews.NFTCollectionDisplay) {\n        self.contractName = contractName\n        self.contractAddress = contractAddress\n        self.nftType = nftType.identifier\n        self.collectionDisplay = collectionDisplay\n    }\n}",
               "spec": {
                  "order": [
                     "collectionIdentifier"
                  ],
                  "parameters": {
                     "collectionIdentifier": "String"
                  }
               }
            },
            "getCatalogEntry": {
               "code": "import NFTCatalog from 0xf8d6e0586b0a20c7\nimport FINDNFTCatalog from 0xf8d6e0586b0a20c7\n\npub fun main(collectionIdentifier : String) : NFTCatalog.NFTCatalogMetadata? {\n    return FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier) \n}",
               "spec": {
                  "order": [
                     "collectionIdentifier"
                  ],
                  "parameters": {
                     "collectionIdentifier": "String"
                  }
               }
            },
            "getCatalogTypeData": {
               "code": "import NFTCatalog from 0xf8d6e0586b0a20c7\nimport FINDNFTCatalog from 0xf8d6e0586b0a20c7\n\npub fun main() : {String : {String : Bool}} {\n    return FINDNFTCatalog.getCatalogTypeData() \n}",
               "spec": {
                  "order": [],
                  "parameters": {}
               }
            },
            "getCheckRoyalty": {
               "code": "import MetadataViews from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\nimport FINDNFTCatalog from 0xf8d6e0586b0a20c7\n\npub fun main(name: String, id: UInt64, nftAliasOrIdentifier: String, viewIdentifier: String) : AnyStruct? {\n\n    let address =FIND.resolve(name)!\n\n    // Get collection public path from NFT Registry\n    let collectionPublicPath = getPublicPath(nftAliasOrIdentifier)\n    let collection= getAuthAccount(address).borrow\u003c\u0026{MetadataViews.ResolverCollection}\u003e(from: collectionPublicPath)!\n\n    // let nft=collection.borrowViewResolver(id: id)\n    let nft=collection.borrowViewResolver(id: collection.getIDs()[0])\n    for v in nft.getViews() {\n        if v.identifier== viewIdentifier {\n            return nft.resolveView(v)\n        }\n    }\n    return nil\n}\n\npub fun getPublicPath(_ nftIdentifier: String) : StoragePath {\n    let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier)) \n    let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n    return collection.collectionData.storagePath\n}",
               "spec": {
                  "order": [
                     "name",
                     "id",
                     "nftAliasOrIdentifier",
                     "viewIdentifier"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "name": "String",
                     "nftAliasOrIdentifier": "String",
                     "viewIdentifier": "String"
                  }
               }
            },
            "getCollectionForType": {
               "code": "import NFTCatalog from 0xf8d6e0586b0a20c7\nimport FINDNFTCatalog from 0xf8d6e0586b0a20c7\n\npub fun main(nftTypeIdentifier : String) : {String : Bool}? {\n    return FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftTypeIdentifier)\n}",
               "spec": {
                  "order": [
                     "nftTypeIdentifier"
                  ],
                  "parameters": {
                     "nftTypeIdentifier": "String"
                  }
               }
            },
            "getCollectionIndex": {
               "code": "import MetadataViews from 0xf8d6e0586b0a20c7\nimport FINDNFTCatalog from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\n\npub fun main(user: String) : {String : [UInt64]} {\n\n    if let address = FIND.resolve(user) {\n        var resultMap : {String : [UInt64]} = {}\n        let account = getAccount(address)\n        for nftInfo in FINDNFTCatalog.getCatalog().values {\n            let publicPath = nftInfo.collectionData.publicPath\n\n            if let subCollections = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftInfo.nftType.identifier) {\n                if subCollections.length \u003c 1 {\n                    continue\n                } else if subCollections.length == 1 {\n                    let collection = nftInfo.nftType.identifier\n                    let resolverCollectionCap= account.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(publicPath)\n                    if resolverCollectionCap.check() {\n                        let collection = resolverCollectionCap.borrow()!\n                        resultMap[nftInfo.collectionDisplay.name] = collection.getIDs()\n                    }\n                } else {\n                    let collection = nftInfo.nftType.identifier\n                    let resolverCollectionCap= account.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(publicPath)\n\n                    let array : [UInt64] = []\n                    if resolverCollectionCap.check() {\n                        let collection = resolverCollectionCap.borrow()!\n                        for id in collection.getIDs() {\n                            let vr = collection.borrowViewResolver(id: id)\n                            if let sc = vr.resolveView(Type\u003cMetadataViews.NFTCollectionDisplay\u003e()) {\n                                let scv = sc as! MetadataViews.NFTCollectionDisplay\n                                if scv.name == nftInfo.collectionDisplay.name {\n                                    array.append(id)\n                                }\n                            }\n                        }\n                    }\n                    resultMap[nftInfo.collectionDisplay.name] = array\n                }\n            } \n\n        }\n\n        return resultMap\n    }\n    return {}\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "getCuratedCollections": {
               "code": "pub fun main(address: Address) : \u0026{String: [String]}? {\n    let account=getAccount(address)\n\n    if account.balance == 0.0 {\n        return nil\n    }\n\n    let publicPath=/public/FindCuratedCollections\n    let link = account.getCapability\u003c\u0026{String: [String]}\u003e(publicPath)\n    if link.check() {\n        return link.borrow()\n    }\n    return nil\n}",
               "spec": {
                  "order": [
                     "address"
                  ],
                  "parameters": {
                     "address": "Address"
                  }
               }
            },
            "getDandiesIDsFor": {
               "code": "import Dandy from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\n\npub fun main(user: String, minter: String) : [UInt64] {\n    let address = FIND.resolve(user)\n    if address == nil {\n        return []\n    }\n    let account = getAccount(address!)\n    if account.balance == 0.0 {\n        return []\n    }\n    let cap = account.getCapability\u003c\u0026Dandy.Collection{Dandy.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n    let ref = cap.borrow() ?? panic(\"Cannot borrow reference to Dandy Collection. Account address : \".concat(address!.toString()))\n\n    return ref.getIDsFor(minter: minter)\n}",
               "spec": {
                  "order": [
                     "user",
                     "minter"
                  ],
                  "parameters": {
                     "minter": "String",
                     "user": "String"
                  }
               }
            },
            "getDandiesMinters": {
               "code": "import Dandy from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\n\npub fun main(user: String) : [String] {\n    let address = FIND.resolve(user)\n    if address == nil {\n        return []\n    }\n    let account = getAccount(address!)\n    if account.balance == 0.0 {\n        return []\n    }\n    let cap = account.getCapability\u003c\u0026Dandy.Collection{Dandy.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n    let ref = cap.borrow() ?? panic(\"Cannot borrow reference to Dandy Collection. Account address : \".concat(address!.toString()))\n\n    return ref.getMinters()\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "getFTInfo": {
               "code": "import FTRegistry from 0xf8d6e0586b0a20c7\n\npub fun main(aliasOrIdentifier: String) : FTRegistry.FTInfo?{\n\n    return FTRegistry.getFTInfo(aliasOrIdentifier)\n\n}",
               "spec": {
                  "order": [
                     "aliasOrIdentifier"
                  ],
                  "parameters": {
                     "aliasOrIdentifier": "String"
                  }
               }
            },
            "getFTInfoAll": {
               "code": "import FTRegistry from 0xf8d6e0586b0a20c7\n\npub fun main() : {String: FTRegistry.FTInfo}{\n\n    return FTRegistry.getFTInfoAll()\n\n}",
               "spec": {
                  "order": [],
                  "parameters": {}
               }
            },
            "getItem": {
               "code": "import MetadataViews from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\nimport FINDNFTCatalog from 0xf8d6e0586b0a20c7\n\npub struct MetadataCollectionItem {\n    pub let id:UInt64\n    pub let uuid:UInt64\n    pub let name: String\n    pub let description: String?\n    pub let image: String\n    pub let url: String\n    pub let contentType:String\n    pub let rarity:String\n    pub let minter:String?\n    pub let type:Type\n\n\n    init(id:UInt64, uuid:UInt64, name:String, description:String?, image:String, url:String, contentType: String, rarity: String, minter:String?, type:Type) {\n        self.id=id\n        self.uuid=uuid\n        self.name=name\n        self.description=description\n        self.minter=minter\n        self.url=url\n        self.type=type\n        self.image=image\n        self.contentType=contentType\n        self.rarity=rarity\n    }\n}\n\n\npub fun main(user: String, aliasOrIdentifier: String, id:UInt64) : MetadataCollectionItem?{\n\n    let publicPath = getPublicPath(aliasOrIdentifier)\n\n    let resolveAddress = FIND.resolve(user) \n    if resolveAddress == nil {return nil}\n    let address = resolveAddress!\n    let account=getAccount(address)\n    if account.balance == 0.0 {\n        return nil\n    }\n    let resolverCollectionCap= account.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(publicPath)\n    if !resolverCollectionCap.check() {\n        return nil\n    }\n\n    let collection = resolverCollectionCap.borrow()!\n    let nft = collection.borrowViewResolver(id: id)!\n\n    if let displayView = nft.resolveView(Type\u003cMetadataViews.Display\u003e()) {\n        let display = displayView as! MetadataViews.Display\n\n        var externalUrl=\"\"\n        if let externalUrlView = nft.resolveView(Type\u003cMetadataViews.ExternalURL\u003e()) {\n            let edvu= externalUrlView as! MetadataViews.ExternalURL\n            externalUrl=edvu.url\n        }\n        let item = MetadataCollectionItem(\n            id: id,\n            uuid: nft.uuid,\n            name: display.name,\n            description:display.description,\n            image: display.thumbnail.uri(),\n            url: externalUrl,\n            contentType: \"image\",\n            rarity: \"\",\n            minter: \"\",\n            type: nft.getType()\n        )\n        return item\n    }\n    return nil\n}\n\npub fun getPublicPath(_ nftIdentifier: String) : PublicPath {\n    let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier)) \n    let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n    return collection.collectionData.publicPath\n}",
               "spec": {
                  "order": [
                     "user",
                     "aliasOrIdentifier",
                     "id"
                  ],
                  "parameters": {
                     "aliasOrIdentifier": "String",
                     "id": "UInt64",
                     "user": "String"
                  }
               }
            },
            "getLeases": {
               "code": "import FIND from 0xf8d6e0586b0a20c7\n\npub fun main() : [FIND.NetworkLease] {\n    return FIND.getLeases()\n}",
               "spec": {
                  "order": [],
                  "parameters": {}
               }
            },
            "getListings": {
               "code": "import FindMarket from 0xf8d6e0586b0a20c7 \nimport FIND from 0xf8d6e0586b0a20c7 \n\npub fun main(marketplace:Address, user: String) : {String : FindMarket.SaleItemCollectionReport} {\n    let resolveAddress = FIND.resolve(user)\n    if resolveAddress == nil { return {}}\n    let address = resolveAddress!\n        return FindMarket.getSaleItemReport(tenant:marketplace, address: address, getNFTInfo:false)\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "user"
                  ],
                  "parameters": {
                     "marketplace": "Address",
                     "user": "String"
                  }
               }
            },
            "getLostAndFoundNFTs": {
               "code": "import LostAndFoundHelper from 0xf8d6e0586b0a20c7\nimport FindLostAndFoundWrapper from 0xf8d6e0586b0a20c7\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\nimport FINDNFTCatalog from 0xf8d6e0586b0a20c7\n\npub fun main(user: String) : Report {\n\n    if let address = FIND.resolve(user) {\n        let runTimeType = Type\u003c@NonFungibleToken.NFT\u003e()\n\n        let ticketsInfo = FindLostAndFoundWrapper.getTickets(user: address, specificType: runTimeType)\n\n        let ticketIds : {String : [UInt64]} = {}\n        let NFTCatalogTicketInfo : {String : [LostAndFoundHelper.Ticket]} = {}\n        for type in ticketsInfo.keys {\n            // check if this type is in NFTCatalog\n            let nftCatalog = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: type)\n            var inNFTCatalog : Bool = true \n            if nftCatalog == nil {\n                inNFTCatalog = false\n            }\n\n            // append id in array\n            let id : [UInt64] = []\n            for ticket in ticketsInfo[type]! {\n                if ticket.ticketID != nil {\n                    id.append(ticket.ticketID!)\n                }\n            }\n            ticketIds[type] = id\n\n            // If it is in NFT Catalog, add it in NFTCatalogTicketInfo\n            if inNFTCatalog {\n                NFTCatalogTicketInfo[type] = ticketsInfo.remove(key: type)\n            }\n        }\n\n        return Report(nftCatalogTicketInfo : NFTCatalogTicketInfo, ticketInfo : ticketsInfo, ticketIds : ticketIds, error: nil)\n    }\n    return logErr(\"Cannot resolve user. User : \".concat(user))\n}\n\n\npub struct Report {\n\n    pub let nftCatalogTicketInfo : {String : [LostAndFoundHelper.Ticket]}\n    pub let ticketInfo : {String : [LostAndFoundHelper.Ticket]}\n    pub let ticketIds : {String : [UInt64]}\n    pub let error : String?\n\n    init(nftCatalogTicketInfo : {String : [LostAndFoundHelper.Ticket]}, ticketInfo : {String : [LostAndFoundHelper.Ticket]}, ticketIds : {String : [UInt64]}, error: String?) {\n        self.nftCatalogTicketInfo = nftCatalogTicketInfo\n        self.ticketInfo = ticketInfo\n        self.ticketIds = ticketIds\n        self.error = error\n    }\n}\n\npub fun logErr(_ err: String) : Report {\n    return Report(nftCatalogTicketInfo: {}, ticketInfo : {}, ticketIds : {} , error: err)\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "getLostAndFoundRedeemableNFTTypes": {
               "code": "import FindLostAndFoundWrapper from 0xf8d6e0586b0a20c7\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\n\npub fun main(user: String) : Report {\n\n    if let address = FIND.resolve(user){\n        let type : Type = Type\u003c@NonFungibleToken.NFT\u003e()\n        return Report(nftTypes: typeToStringArray(FindLostAndFoundWrapper.getSpecificRedeemableTypes(user: address, specificType: type)), err: nil)\n    }\n    return logErr(\"cannot resolve user\")\n\n}\n\npub fun typeToStringArray(_ array: [Type]) : [String] {\n    let res : [String] = []\n    for type in array {\n        res.append(type.identifier)\n    }\n    return res\n}\n\npub struct Report {\n    pub let nftTypes : [String]\n    pub let err : String? \n\n    init(nftTypes : [String] , err : String? ) {\n        self.nftTypes = nftTypes\n        self.err = err\n    }\n}\n\npub fun logErr(_ err: String) : Report{\n    return Report(nftTypes: [], err: err)\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "getLostAndFoundRequiredStorageType": {
               "code": "import FindLostAndFoundWrapper from 0xf8d6e0586b0a20c7\nimport FINDNFTCatalog from 0xf8d6e0586b0a20c7\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\n\npub fun main(user: String) : Report {\n\n    if let address = FIND.resolve(user){\n        let runTimeType : Type = Type\u003c@NonFungibleToken.NFT\u003e()\n\n        let types = FindLostAndFoundWrapper.getSpecificRedeemableTypes(user: address, specificType: runTimeType)\n\n        let account = getAuthAccount(address)\n\n        let initiableStorage : [String] = []\n        let relinkableStorage : [String] = []\n        let initiatedStorage : [String] = []\n        let problematicStorage : [String] = []\n        let notSupportedType : [String] = []\n        for type in types {\n\n            let nftInfo = FINDNFTCatalog.getCollectionDataForType(nftTypeIdentifier: type.identifier)\n\n            if nftInfo == nil {\n                initiableStorage.append(type.identifier)\n                continue\n            }\n\n            let storageType = account.type(at: nftInfo!.storagePath)\n            if storageType == nil {\n                initiableStorage.append(type.identifier)\n                continue\n            } \n            \n            let storageTypeIdentifier = storageType!.identifier.slice(from: 0 , upTo: storageType!.identifier.length - \".Collection\".length)\n            let typeIdentifier = type.identifier.slice(from: 0 , upTo: type.identifier.length - \".NFT\".length)\n            if storageTypeIdentifier != typeIdentifier {\n                problematicStorage.append(type.identifier)\n            } else {\n\n                // check if relink needed\n                if account.getCapability\u003c\u0026{NonFungibleToken.Receiver, NonFungibleToken.CollectionPublic, MetadataViews.ResolverCollection}\u003e(nftInfo!.publicPath).check() {\n                    initiatedStorage.append(type.identifier)\n                } else {\n                    relinkableStorage.append(type.identifier)\n                }\n\n            }\n        }\n        return Report(initiableStorage: initiableStorage, relinkableStorage: relinkableStorage ,initiatedStorage: initiatedStorage, problematicStorage: problematicStorage, notSupportedType: notSupportedType, err: nil)\n    }\n    return logErr(\"cannot resolve user\")\n\n}\n\npub struct Report {\n\n    pub let initiableStorage : [String] \n    pub let relinkableStorage : [String]\n    pub let initiatedStorage : [String] \n    pub let problematicStorage : [String] \n    pub let notSupportedType : [String] \n\n    pub let err : String? \n\n    init(initiableStorage : [String] , relinkableStorage : [String] , initiatedStorage : [String], problematicStorage : [String] , notSupportedType : [String] , err : String? ) {\n        self.initiableStorage = initiableStorage\n        self.relinkableStorage = relinkableStorage\n        self.initiatedStorage = initiatedStorage\n        self.problematicStorage = problematicStorage\n        self.notSupportedType = notSupportedType\n        self.err = err\n    }\n\n}\n\npub fun logErr(_ err: String) : Report {\n    return Report(initiableStorage: [] , relinkableStorage : [] , initiatedStorage : [] , problematicStorage: [], notSupportedType: [], err: err)\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "getMarketBlockedNFT": {
               "code": "import FindMarket from 0xf8d6e0586b0a20c7 \n\npub fun main() : {String : [String] } {\n    let mapping : {String : [String] } = {}\n\n    let findAddress=FindMarket.getFindTenantAddress()\n    let tenantCap = FindMarket.getTenantCapability(findAddress)!\n    let tenantRef = tenantCap.borrow() ?? panic(\"This tenant is not set up. Tenant : \".concat(tenantCap.address.toString()))\n    let marketTypes = FindMarket.getSaleItemTypes()\n    for marketType in marketTypes {\n        let list : [String] = []\n        for type in tenantRef.getBlockedNFT(marketType: marketType) {\n            list.append(type.identifier)\n        }\n        mapping[FindMarket.getMarketOptionFromType(marketType)] = list\n    }\n\nreturn mapping\n}",
               "spec": {
                  "order": [],
                  "parameters": {}
               }
            },
            "getMetadataForSaleItem": {
               "code": "import FindMarketSale from 0xf8d6e0586b0a20c7\nimport FindMarket from 0xf8d6e0586b0a20c7\n\npub struct PurchaseData {\n    pub let id: UInt64\n    pub let name: String\n    pub let amount: UFix64\n    pub let description: String\n    pub let imageURL: String\n\n    init(id: UInt64, name: String, amount: UFix64, description: String, imageURL: String) {\n        self.id = id\n        self.name = name\n        self.amount = amount\n        self.description = description\n        self.imageURL = imageURL\n    }\n}\npub fun main(merchantAddress: Address, marketplace:Address, address: Address, id: UInt64, amount: UFix64) : PurchaseData{\n    let saleItemsCap= FindMarketSale.getSaleItemCapability(marketplace: marketplace, user:address) ?? panic(\"cannot find sale item cap\")\n    let saleItemCollection = saleItemsCap.borrow()!\n    let item = saleItemCollection.borrowSaleItem(id)\n\n    let display = item.getDisplay()\n\n    var thumbnail = replacePrefix(display.thumbnail.uri(), prefix: \"ipfs://\", replace:\"https://nftstorage.link/ipfs/\")\n    return PurchaseData(\n        id: id, \n        name: display.name, \n        amount: amount,\n        description: display.description, \n        imageURL: thumbnail\n    )\n}\n\npub fun replacePrefix(_ original: String, prefix:String, replace:String) : String {\n    if original.length \u003c prefix.length  {\n        return original\n    }\n    let oprefix = original.slice(from:0, upTo:prefix.length)\n    if oprefix != prefix {\n        return original\n    }\n    let rest = original.slice(from:prefix.length, upTo: original.length)\n    return replace.concat(rest)\n}",
               "spec": {
                  "order": [
                     "merchantAddress",
                     "marketplace",
                     "address",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "address": "Address",
                     "amount": "UFix64",
                     "id": "UInt64",
                     "marketplace": "Address",
                     "merchantAddress": "Address"
                  }
               }
            },
            "getNFTCatalogIDs": {
               "code": "import MetadataViews from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\nimport FINDNFTCatalog from 0xf8d6e0586b0a20c7\n\npub fun main(user: String, collections: [String]) : {String : ItemReport} {\n    return fetchNFTCatalog(user: user, targetCollections:collections)\n}\n\npub struct ItemReport {\n    pub let length : Int // mapping of collection to no. of ids \n    pub let extraIDs : [UInt64]\n    pub let shard : String \n    pub let extraIDsIdentifier : String \n\n    init(length : Int, extraIDs :[UInt64] , shard: String, extraIDsIdentifier: String) {\n        self.length=length \n        self.extraIDs=extraIDs\n        self.shard=shard\n        self.extraIDsIdentifier=extraIDsIdentifier\n    }\n}\n\n    pub struct NFTView {\n        pub let id: UInt64\n        pub let display: MetadataViews.Display?\n        pub let editions: MetadataViews.Editions?\n        pub let collectionDisplay: MetadataViews.NFTCollectionDisplay?\n        pub let nftType: Type\n\n        init(\n            id : UInt64,\n            display : MetadataViews.Display?,\n            editions : MetadataViews.Editions?,\n            collectionDisplay: MetadataViews.NFTCollectionDisplay?,\n            nftType: Type\n        ) {\n            self.id = id\n            self.display = display\n            self.editions = editions\n            self.collectionDisplay = collectionDisplay\n            self.nftType = nftType\n        }\n    }\n\n// Helper function \n\npub fun resolveAddress(user: String) : Address? {\n    return FIND.resolve(user)\n}\n\npub fun getNFTIDs(ownerAddress: Address) : {String:[UInt64]} {\n\n    let account = getAuthAccount(ownerAddress)\n\n    if account.balance == 0.0 {\n        return {}\n    }\n\n    let inventory : {String:[UInt64]}={}\n    let types = FINDNFTCatalog.getCatalogTypeData()\n    for nftType in types.keys {\n\n        let typeData=types[nftType]!\n        let collectionKey=typeData.keys[0]\n        let catalogEntry = FINDNFTCatalog.getCatalogEntry(collectionIdentifier:collectionKey)!\n        let storagePath = catalogEntry.collectionData.storagePath\n        let ref= account.borrow\u003c\u0026{MetadataViews.ResolverCollection}\u003e(from: storagePath)\n        if ref != nil {\n            inventory[collectionKey] = ref!.getIDs()\n        }\n\n    }\n    return inventory\n}\n\npub fun fetchNFTCatalog(user: String, targetCollections: [String]) : {String : ItemReport} {\n    let source = \"NFTCatalog\"\n    let account = resolveAddress(user: user)\n    if account == nil { return {} }\n\n\n    let extraIDs = getNFTIDs(ownerAddress: account!)\n    let inventory : {String : ItemReport} = {}\n    var fetchedCount : Int = 0\n\n    for project in extraIDs.keys {\n\n        let catalogEntry = FINDNFTCatalog.getCatalogEntry(collectionIdentifier:project)!\n        let projectName = catalogEntry.contractName\n\n        if extraIDs[project]! == nil || extraIDs[project]!.length \u003c 1{\n            extraIDs.remove(key: project)\n            continue\n        }\n        \n        let collectionLength = extraIDs[project]!.length\n\n        // by pass if this is not the target collection\n        if targetCollections.length \u003e 0 \u0026\u0026 !targetCollections.contains(project) {\n            // inventory[project] = ItemReport(length : collectionLength, extraIDs :extraIDs[project]! , shard: source)\n            continue\n        }\n\n        inventory[catalogEntry.contractName] = ItemReport(length : collectionLength, extraIDs :extraIDs[project] ?? [] , shard: source, extraIDsIdentifier: project)\n\n    }\n\n    return inventory\n\n}",
               "spec": {
                  "order": [
                     "user",
                     "collections"
                  ],
                  "parameters": {
                     "collections": "[String]",
                     "user": "String"
                  }
               }
            },
            "getNFTCatalogItems": {
               "code": "import MetadataViews from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\n\nimport FINDNFTCatalog from 0xf8d6e0586b0a20c7\n\npub fun main(user: String, collectionIDs: {String : [UInt64]}) : {String : [MetadataCollectionItem]} {\n    return fetchNFTCatalog(user: user, collectionIDs: collectionIDs)\n}\n\npub struct NFTView {\n    pub let id: UInt64\n    pub let display: MetadataViews.Display?\n    pub let editions: MetadataViews.Editions?\n    pub let collectionDisplay: MetadataViews.NFTCollectionDisplay?\n    pub let nftType: Type\n\n    init(\n        id : UInt64,\n        display : MetadataViews.Display?,\n        editions : MetadataViews.Editions?,\n        collectionDisplay: MetadataViews.NFTCollectionDisplay?,\n        nftType: Type\n    ) {\n        self.id = id\n        self.display = display\n        self.editions = editions\n        self.collectionDisplay = collectionDisplay\n        self.nftType = nftType\n    }\n}\n\npub fun getNFTs(ownerAddress: Address, ids: {String : [UInt64]}) : [NFTView] {\n\n    let account = getAuthAccount(ownerAddress)\n\n    if account.balance == 0.0 {\n        return []\n    }\n\n    let results : [NFTView] = []\n    for collectionKey in ids.keys {\n        let catalogEntry = FINDNFTCatalog.getCatalogEntry(collectionIdentifier:collectionKey)!\n        let storagePath = catalogEntry.collectionData.storagePath\n        let ref= account.borrow\u003c\u0026{MetadataViews.ResolverCollection}\u003e(from: storagePath)\n        if ref != nil{\n            for id in ids[collectionKey]! {\n                // results.append(MetadataViews.getNFTView(id:id, viewResolver: ref!.borrowViewResolver(id:id)!))\n                let viewResolver = ref!.borrowViewResolver(id:id)!\n                results.append(\n                    NFTView(\n                        id : id,\n                        display: MetadataViews.getDisplay(viewResolver),\n                        editions : MetadataViews.getEditions(viewResolver),\n                        collectionDisplay : MetadataViews.getNFTCollectionDisplay(viewResolver),\n                        nftType : viewResolver.getType()\n                    )\n                )\n            }\n        }\n    }\n    return results\n}\n\npub struct CollectionReport {\n    pub let items : {String : [MetadataCollectionItem]} \n    pub let collections : {String : Int} // mapping of collection to no. of ids \n    pub let extraIDs : {String : [UInt64]} \n\n    init(items: {String : [MetadataCollectionItem]},  collections : {String : Int}, extraIDs : {String : [UInt64]} ) {\n        self.items=items \n        self.collections=collections \n        self.extraIDs=extraIDs\n    }\n}\n\npub struct MetadataCollectionItem {\n    pub let id:UInt64\n    pub let name: String\n    pub let collection: String // \u003c- This will be Alias unless they want something else\n    pub let subCollection: String? // \u003c- This will be Alias unless they want something else\n    pub let nftDetailIdentifier: String\n\n    pub let media  : String\n    pub let mediaType : String \n    pub let source : String \n\n    init(id:UInt64, name: String, collection: String, subCollection: String?, media  : String, mediaType : String, source : String, nftDetailIdentifier: String) {\n        self.id=id\n        self.name=name \n        self.collection=collection \n        self.subCollection=subCollection \n        self.media=media \n        self.mediaType=mediaType \n        self.source=source\n        self.nftDetailIdentifier=nftDetailIdentifier\n    }\n}\n\n// Helper function \n\npub fun resolveAddress(user: String) : PublicAccount? {\n    let address = FIND.resolve(user)\n    if address == nil {\n        return nil\n    }\n    return getAccount(address!)\n}\n\n\n//////////////////////////////////////////////////////////////\n// Fetch Specific Collections in Shard 1\n//////////////////////////////////////////////////////////////\npub fun fetchNFTCatalog(user: String, collectionIDs: {String : [UInt64]}) : {String : [MetadataCollectionItem]} {\n    let source = \"NFTCatalog\"\n    let account = resolveAddress(user: user)\n    if account == nil { return {} }\n\n    let items : {String : [MetadataCollectionItem]} = {}\n\n    let fetchingIDs = collectionIDs\n\n\n    for project in fetchingIDs.keys {\n\n        let catalogEntry = FINDNFTCatalog.getCatalogEntry(collectionIdentifier:project)!\n        let projectName = catalogEntry.contractName\n\n        let returnedNFTs = getNFTs(ownerAddress: account!.address, ids: {project : fetchingIDs[project]!})\n\n        var collectionItems : [MetadataCollectionItem] = []\n        for nft in returnedNFTs {\n            if nft == nil {\n                continue\n            }\n\n            var subCollection = \"\"\n            if project != nft!.collectionDisplay!.name {\n             subCollection = nft!.collectionDisplay!.name\n            }\n\n            var name = nft!.display!.name \n            if name == \"\" {\n                name = projectName\n            }\n\n            if nft.editions != nil \u0026\u0026 nft.editions!.infoList.length \u003e 0 {\n                let edition = nft.editions!.infoList[0].number.toString()\n                // check if the name ends with \"editionNumber\"\n                // If the name ends with \"editionNumber\", we do not concat the edition\n                if name.length \u003e edition.length \u0026\u0026 name.slice(from: name.length - edition.length, upTo: name.length) != edition {\n                    name = name.concat(\"#\").concat(nft.editions!.infoList[0].number.toString())\n                }\n            }\n            \n            let item = MetadataCollectionItem(\n                id: nft!.id,\n                name: name,\n                collection: project,\n                subCollection: subCollection, \n                media: nft!.display!.thumbnail.uri(),\n                mediaType: \"image/png\",\n                source: source, \n                nftDetailIdentifier: nft!.nftType.identifier\n            )\n            collectionItems.append(item)\n        }\n\n        if collectionItems.length \u003e 0 {\n            items[project] = collectionItems\n        }\n    }\n    return items\n}",
               "spec": {
                  "order": [
                     "user",
                     "collectionIDs"
                  ],
                  "parameters": {
                     "collectionIDs": "{String: [UInt64]}",
                     "user": "String"
                  }
               }
            },
            "getNFTCatalogItemsWithMetadata": {
               "code": "import MetadataViews from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\n\nimport FINDNFTCatalog from 0xf8d6e0586b0a20c7\n\npub fun main(user: String, collectionIDs: {String : [UInt64]}) : {String : [MetadataCollectionItem]} {\n    return fetchNFTCatalog(user: user, collectionIDs: collectionIDs)\n}\n\npub struct NFTView {\n    pub let id: UInt64\n    pub let display: MetadataViews.Display?\n    pub let collectionDisplay: MetadataViews.NFTCollectionDisplay?\n    pub var rarity:MetadataViews.Rarity?\n    pub var editions: MetadataViews.Editions?\n    pub var serial: UInt64?\n    pub var traits: MetadataViews.Traits?\n    pub let nftType: Type\n\n    init(\n        id : UInt64,\n        display : MetadataViews.Display?,\n        editions : MetadataViews.Editions?,\n        rarity:MetadataViews.Rarity?,\n        serial: UInt64?,\n        traits: MetadataViews.Traits?,\n        collectionDisplay: MetadataViews.NFTCollectionDisplay?,\n        nftType: Type\n    ) {\n        self.id = id\n        self.display = display\n        self.editions = editions\n        self.rarity = rarity\n        self.serial = serial\n        self.traits = traits\n        self.collectionDisplay = collectionDisplay\n        self.nftType = nftType\n    }\n}\n\npub fun getNFTs(ownerAddress: Address, ids: {String : [UInt64]}) : [NFTView] {\n\n    let account = getAuthAccount(ownerAddress)\n\n    if account.balance == 0.0 {\n        return []\n    }\n\n    let results : [NFTView] = []\n    for collectionKey in ids.keys {\n        let catalogEntry = FINDNFTCatalog.getCatalogEntry(collectionIdentifier:collectionKey)!\n        let storagePath = catalogEntry.collectionData.storagePath\n        let ref= account.borrow\u003c\u0026{MetadataViews.ResolverCollection}\u003e(from: storagePath)\n        if ref != nil{\n            for id in ids[collectionKey]! {\n                // results.append(MetadataViews.getNFTView(id:id, viewResolver: ref!.borrowViewResolver(id:id)!))\n                let viewResolver = ref!.borrowViewResolver(id:id)!\n\n                var traitsStruct : MetadataViews.Traits? = nil \n\n                if let traits = MetadataViews.getTraits(viewResolver) {\n                    if let trait = getTrait(viewResolver) {\n                        var check = false \n                        for item in traits.traits {\n                            if item.name == trait.name {\n                                check = true \n                                break\n                            }\n                            if !check {\n                                let array = traits.traits\n                                array.append(trait)\n\n                                traitsStruct = cleanUpTraits(array)\n                            }\n                        }\n                    } else {\n                        traitsStruct = cleanUpTraits(traits.traits)\n                    }\n                } else {\n                    if let trait = getTrait(viewResolver) {\n                        traitsStruct = cleanUpTraits([trait])\n                    }\n                }\n\n                var editionStruct : MetadataViews.Editions? = nil \n\n                if let editions = MetadataViews.getEditions(viewResolver) {\n                    if let edition = getEdition(viewResolver) {\n                        var check = false\n                        for item in editions.infoList {\n                            if item.name == edition.name \u0026\u0026 item.number == edition.number \u0026\u0026 item.max == edition.max {\n                                check = true\n                                break\n                            }\n                        }\n                        // If the edition does not exist in editions, add it in\n                        if !check {\n                            let array = editions.infoList \n                            array.append(edition)\n                            editionStruct = MetadataViews.Editions(array)\n                        }\n                    } else {\n                    // If edition does not exist OR edition is already in editions , append it to views and continue\n                        editionStruct = editions\n                    }\n                } else if let edition = getEdition(viewResolver) {\n                        editionStruct = MetadataViews.Editions([edition])\n                }\n\n                results.append(\n                    NFTView(\n                        id : id,\n                        display: MetadataViews.getDisplay(viewResolver),\n                        editions : editionStruct,\n                        rarity : MetadataViews.getRarity(viewResolver),\n                        serial :  MetadataViews.getSerial(viewResolver)?.number,\n                        traits : traitsStruct,\n                        collectionDisplay : MetadataViews.getNFTCollectionDisplay(viewResolver),\n                        nftType : viewResolver.getType()\n                    )\n                )\n            }\n        }\n    }\n    return results\n}\n\npub struct CollectionReport {\n    pub let items : {String : [MetadataCollectionItem]} \n    pub let collections : {String : Int} // mapping of collection to no. of ids \n    pub let extraIDs : {String : [UInt64]} \n\n    init(items: {String : [MetadataCollectionItem]},  collections : {String : Int}, extraIDs : {String : [UInt64]} ) {\n        self.items=items \n        self.collections=collections \n        self.extraIDs=extraIDs\n    }\n}\n\npub struct MetadataCollectionItem {\n    pub let id:UInt64\n    pub let name: String\n    pub let collection: String // \u003c- This will be Alias unless they want something else\n    pub let subCollection: String? // \u003c- This will be Alias unless they want something else\n    pub let nftDetailIdentifier: String\n\n    pub let media  : String\n    pub let mediaType : String \n    pub let source : String \n\n    pub var rarity:MetadataViews.Rarity?\n    pub var editions: MetadataViews.Editions?\n    pub var serial: UInt64?\n    pub var traits: MetadataViews.Traits?\n\n    init(id:UInt64, \n         name: String, \n         collection: String, \n         subCollection: String?, \n         media  : String, \n         mediaType : String, \n         source : String, \n         nftDetailIdentifier: String, \n         editions : MetadataViews.Editions?,\n         rarity:MetadataViews.Rarity?,\n         serial: UInt64?,\n         traits: MetadataViews.Traits?,\n         ) {\n        self.id=id\n        self.name=name \n        self.collection=collection \n        self.subCollection=subCollection \n        self.media=media \n        self.mediaType=mediaType \n        self.source=source\n        self.nftDetailIdentifier=nftDetailIdentifier\n        self.editions=editions\n        self.rarity=rarity\n        self.serial=serial\n        self.traits=traits\n    }\n}\n\n// Helper function \n\npub fun resolveAddress(user: String) : PublicAccount? {\n    let address = FIND.resolve(user)\n    if address == nil {\n        return nil\n    }\n    return getAccount(address!)\n}\n\n\n//////////////////////////////////////////////////////////////\n// Fetch Specific Collections in Shard 1\n//////////////////////////////////////////////////////////////\npub fun fetchNFTCatalog(user: String, collectionIDs: {String : [UInt64]}) : {String : [MetadataCollectionItem]} {\n    let source = \"NFTCatalog\"\n    let account = resolveAddress(user: user)\n    if account == nil { return {} }\n\n    let items : {String : [MetadataCollectionItem]} = {}\n\n    let fetchingIDs = collectionIDs\n\n\n    for project in fetchingIDs.keys {\n\n        let catalogEntry = FINDNFTCatalog.getCatalogEntry(collectionIdentifier:project)!\n        let projectName = catalogEntry.contractName\n\n        let returnedNFTs = getNFTs(ownerAddress: account!.address, ids: {project : fetchingIDs[project]!})\n\n        var collectionItems : [MetadataCollectionItem] = []\n        for nft in returnedNFTs {\n            if nft == nil {\n                continue\n            }\n\n            var subCollection = \"\"\n            if project != nft!.collectionDisplay!.name {\n             subCollection = nft!.collectionDisplay!.name\n            }\n\n            var name = nft!.display!.name \n            if name == \"\" {\n                name = projectName\n            }\n\n            if nft.editions != nil \u0026\u0026 nft.editions!.infoList.length \u003e 0 {\n                let edition = nft.editions!.infoList[0].number.toString()\n                // check if the name ends with \"editionNumber\"\n                // If the name ends with \"editionNumber\", we do not concat the edition\n                if name.length \u003e edition.length \u0026\u0026 name.slice(from: name.length - edition.length, upTo: name.length) != edition {\n                    name = name.concat(\"#\").concat(nft.editions!.infoList[0].number.toString())\n                }\n            }\n            \n            let item = MetadataCollectionItem(\n                id: nft!.id,\n                name: name,\n                collection: project,\n                subCollection: subCollection, \n                media: nft!.display!.thumbnail.uri(),\n                mediaType: \"image/png\",\n                source: source, \n                nftDetailIdentifier: nft!.nftType.identifier, \n                editions : nft!.editions,\n                rarity: nft!.rarity,\n                serial: nft!.serial,\n                traits: nft!.traits,\n            )\n            collectionItems.append(item)\n        }\n\n        if collectionItems.length \u003e 0 {\n            items[project] = collectionItems\n        }\n    }\n    return items\n}\n\npub fun cleanUpTraits(_ traits: [MetadataViews.Trait]) : MetadataViews.Traits {\n    let dateValues  = {\"Date\" : true, \"Numeric\":false, \"Number\":false, \"date\":true, \"numeric\":false, \"number\":false}\n\n    let array : [MetadataViews.Trait] = []\n\n    for i , trait in traits {\n        let displayType = trait.displayType ?? \"string\"\n        if let isDate = dateValues[displayType] {\n            if isDate {\n                array.append(MetadataViews.Trait(name: trait.name, value: trait.value, displayType: \"Date\", rarity: trait.rarity))\n            } else {\n                array.append(MetadataViews.Trait(name: trait.name, value: trait.value, displayType: \"Numeric\", rarity: trait.rarity))\n            }\n        } else {\n            if let value = trait.value as? Bool {\n                if value {\n                    array.append(MetadataViews.Trait(name: trait.name, value: trait.value, displayType: \"Bool\", rarity: trait.rarity))\n                }else {\n                    array.append(MetadataViews.Trait(name: trait.name, value: trait.value, displayType: \"Bool\", rarity: trait.rarity))\n                }\n            } else if let value = trait.value as? String {\n                array.append(MetadataViews.Trait(name: trait.name, value: trait.value, displayType: \"String\", rarity: trait.rarity))\n            } else {\n                array.append(MetadataViews.Trait(name: trait.name, value: trait.value, displayType: \"String\", rarity: trait.rarity))\n            }\n        }\n    }\n    return MetadataViews.Traits(array)\n}\n\npub fun getTrait(_ viewResolver: \u0026{MetadataViews.Resolver}) : MetadataViews.Trait? {\n    if let view = viewResolver.resolveView(Type\u003cMetadataViews.Trait\u003e()) {\n        if let v = view as? MetadataViews.Trait {\n            return v\n        }\n    }\n    return nil\n}\n\npub fun getEdition(_ viewResolver: \u0026{MetadataViews.Resolver}) : MetadataViews.Edition? {\n    if let view = viewResolver.resolveView(Type\u003cMetadataViews.Edition\u003e()) {\n        if let v = view as? MetadataViews.Edition {\n            return v\n        }\n    }\n    return nil\n}",
               "spec": {
                  "order": [
                     "user",
                     "collectionIDs"
                  ],
                  "parameters": {
                     "collectionIDs": "{String: [UInt64]}",
                     "user": "String"
                  }
               }
            },
            "getNFTDetailsNFTCatalog": {
               "code": "import FindMarket from 0xf8d6e0586b0a20c7 \nimport FindViews from 0xf8d6e0586b0a20c7 \nimport FIND from 0xf8d6e0586b0a20c7 \nimport MetadataViews from 0xf8d6e0586b0a20c7\n//import NFTStorefront from \"../contracts/standard/NFTStorefront.cdc\"\nimport FINDNFTCatalog from 0xf8d6e0586b0a20c7\nimport FTRegistry from 0xf8d6e0586b0a20c7\n\npub struct NFTDetailReport {\n    pub let findMarket: {String : FindMarket.SaleItemInformation}\n    pub let storefront: StorefrontListing?\n    pub let nftDetail: NFTDetail?\n    pub let allowedListingActions: {String : ListingTypeReport}\n    pub let linkedForMarket : Bool?\n\n    init(findMarket:{String : FindMarket.SaleItemInformation}, storefront: StorefrontListing?, nftDetail: NFTDetail?, allowedListingActions: {String : ListingTypeReport}, linkedForMarket : Bool?) {\n        self.findMarket=findMarket\n        self.storefront=storefront\n        self.nftDetail=nftDetail\n        self.allowedListingActions=allowedListingActions\n        self.linkedForMarket = linkedForMarket\n    }\n}\n\n\npub struct ListingTypeReport {\n    pub let ftAlias: [String] \n    pub let ftIdentifiers: [String]\n    pub let listingType: String \n    pub let status: String \n    pub let ListingDetails: [ListingRoyalties]\n\n    init(listingType: String, ftAlias: [String], ftIdentifiers: [String],  status: String , ListingDetails: [ListingRoyalties]) {\n        self.listingType=listingType \n        self.status=status\n        self.ListingDetails=ListingDetails\n        self.ftAlias=ftAlias \n        self.ftIdentifiers=ftIdentifiers\n    }\n}\n\npub struct NFTDetail {\n    pub let id: UInt64 \n    pub let uuid: UInt64 \n    pub let name:String\n    pub let description:String\n    pub let thumbnail:String\n    pub let type: String\n    pub var externalViewURL: String?\n    pub var rarity:MetadataViews.Rarity?\n    pub var editions: [MetadataViews.Edition]\n    pub var serial: UInt64?\n    pub var traits: [MetadataViews.Trait]\n    pub var media : {String: String} //url to mediaType\n    pub var collection : NFTCollectionDisplay?\n    pub var license : String? \n    pub var data: {String : AnyStruct?}\n    pub var views :[String]\n\n    init(_ pointer: FindViews.ViewReadPointer, views: {String : AnyStruct}, resolvedViews: [Type]){\n\n        self.type=pointer.itemType.identifier\n        self.id=pointer.id\n        self.uuid=pointer.getUUID()\n\n        // Display \n        let display = views[\"Display\"] ?? panic(\"Could not find display\")\n        let d = display as! MetadataViews.Display\n        self.name=d.name\n        self.description=d.description\n        self.thumbnail=d.thumbnail.uri()\n        views.remove(key: \"Display\")\n\n        // External URL \n        self.externalViewURL = nil \n        if let externalURL = views[\"ExternalURL\"] {\n            if let e = externalURL as? MetadataViews.ExternalURL {\n                self.externalViewURL = e.url\n            }\n        }\n        views.remove(key: \"ExternalURL\")\n\n        // Edition\n        self.editions=[] \n        if let editions = views[\"Editions\"] {\n            if let e = editions as? MetadataViews.Editions {\n                if e.infoList.length \u003e 0 {\n                    self.editions=e.infoList\n                }\n            }\n        }\n        views.remove(key: \"Editions\")\n\n        // Serial\n        self.serial=nil\n        if let serial = views[\"Serial\"] {\n            if let s = serial as? MetadataViews.Serial {\n                self.serial=s.number\n            }\n        }\n        views.remove(key: \"Serial\")\n\n        // subCollection\n        self.collection=nil\n        if let grouping = views[\"NFTCollectionDisplay\"] {\n            if let sc = grouping as? MetadataViews.NFTCollectionDisplay {\n                self.collection=NFTCollectionDisplay(sc)\n            }\n        }\n        views.remove(key: \"NFTCollectionDisplay\")\n\n        // Medias \n        self.media={}\n        if let medias= views[\"Medias\"] {\n            if let ms = medias as? MetadataViews.Medias {\n                for m in ms.items {\n                    let url = m.file.uri() \n                    let type = m.mediaType\n                    self.media[url] = type\n                }\n            }\n        }\n        views.remove(key: \"Medias\")\n\n        // Rarity \n        self.rarity=nil\n        if let rarity= views[\"Rarity\"] {\n            if let r = rarity as? MetadataViews.Rarity {\n                self.rarity = r\n            }\n        }\n        views.remove(key: \"Rarity\")\n\n        // Traits\n        self.traits=[] \n        if let traits = views[\"Traits\"] {\n            if let t = traits as? MetadataViews.Traits {\n                if t.traits.length \u003e 0 {\n                    self.traits=t.traits\n                }\n            }\n        }\n        views.remove(key: \"Traits\")\n\n        // License \n        self.license= nil \n        if let license= views[\"License\"] {\n            if let l = license as? MetadataViews.License {\n                self.license = l.spdxIdentifier\n            }\n        }\n        views.remove(key: \"License\")\n\n        self.views=[]\n\n        for view in pointer.getViews() {\n            if defaultViews().contains(view) {\n                continue\n            }\n            if resolvedViews.contains(view) {\n                continue\n            }\n            self.views.append(view.identifier)\n        }\n        self.data=views\n\n    }\n}\n\n\npub struct StoreFrontCut {\n\n    pub let amount:UFix64\n    pub let address: Address\n    pub let findName:String?\n\n    init(amount:UFix64, address:Address){\n        self.amount=amount\n        self.address=address\n        self.findName= reverseLookup(address)\n    }\n}\n\npub struct ListingRoyalties {\n\n    pub let ftAlias: String?\n    pub let ftIdentifier: String\n    pub let royalties: [Royalties]\n\n    init(ftAlias: String?, ftIdentifier: String, royalties: [Royalties]) {\n        self.ftAlias=ftAlias \n        self.ftIdentifier=ftIdentifier\n        self.royalties=royalties \n    }\n}\n\npub struct Royalties {\n\n    pub let royaltyName: String \n    pub let address: Address \n    pub let findName: String? \n    pub let cut: UFix64 \n\n    init(royaltyName: String , address: Address, findName: String?, cut: UFix64) {\n        self.royaltyName=royaltyName \n        self.address=address \n        self.findName=findName \n        self.cut=cut\n    }\n}\n\n\npub struct StorefrontListing {\n    pub let foo:String\n\n    init() {\n\n        self.foo =\"bar\"\n    }\n}\n\npub struct NFTCollectionDisplay {\n    // Name that should be used when displaying this NFT collection.\n    pub let name: String\n\n    // Description that should be used to give an overview of this collection.\n    pub let description: String\n\n    // External link to a URL to view more information about this collection.\n    pub let externalURL: String\n\n    // Square-sized image to represent this collection.\n    pub let squareImage: {String : String}\n\n    // Banner-sized image for this collection, recommended to have a size near 1200x630.\n    pub let bannerImage: {String : String}\n\n    // Social links to reach this collection's social homepages.\n    // Possible keys may be \"instagram\", \"twitter\", \"discord\", etc.\n    pub let socials: {String: String}\n\n    init(\n        _ nftCD : MetadataViews.NFTCollectionDisplay\n    ) {\n        self.name = nftCD.name\n        self.description = nftCD.description\n        self.externalURL = nftCD.externalURL.url\n\n        let squareImage = {nftCD.squareImage.file.uri() : nftCD.squareImage.mediaType}\n        self.squareImage = squareImage\n\n        let bannerImage = {nftCD.bannerImage.file.uri() : nftCD.bannerImage.mediaType}\n        self.bannerImage = bannerImage\n\n        let socials : {String : String} = {}\n        for key in nftCD.socials.keys{\n            socials[key] = nftCD.socials[key]!.url\n        }\n        self.socials = socials\n    }\n}\n\n/*\npub struct StorefrontListing {\n    pub let nftID:UInt64\n    pub let nftIdentifier: String\n    pub let saleCut: [StoreFrontCut]\n    pub let amount:UFix64\n    pub let ftTypeIdentifier:String\n    pub let storefront:UInt64\n    pub let listingID:UInt64\n\n    init(listingId:UInt64, details: NFTStorefront.ListingDetails) {\n\n        self.saleCut=[]\n        self.nftID=details.nftID\n        self.nftIdentifier=details.nftType.identifier\n        for cutDetails in details.saleCuts {\n            self.saleCut.append(StoreFrontCut(amount:cutDetails.amount, address:cutDetails.receiver.address))\n        }\n        self.amount=details.salePrice\n        self.ftTypeIdentifier=details.salePaymentVaultType.identifier\n        self.storefront=details.storefrontID\n        self.listingID=listingId\n    }\n}\n*/\n\npub var counter = 0\n\npub fun main(user: String, project:String, id: UInt64, views: [String]) : NFTDetailReport?{\n    let resolveAddress = FIND.resolve(user) \n    if resolveAddress == nil {\n        return nil\n    }\n    let address = resolveAddress!\n\n    let account = getAuthAccount(address) \n\n    if account.balance \u003e 0.0 {\n        // check link for market\n        let linkedForMarket = account.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(getPublicPath(project)).check()\n\n        let storagePath = getStoragePath(project)\n        let publicPath = PublicPath(identifier: \"find_temp_path_\".concat(counter.toString()))!\n        counter = counter + 1\n        account.link\u003c\u0026{MetadataViews.ResolverCollection}\u003e(publicPath, target: storagePath)\n        let cap = account.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(publicPath)\n        if !cap.check() {\n            panic(\"The user does not set up collection correctly.\")\n        }\n        let pointer = FindViews.ViewReadPointer(cap: cap, id: id)\n\n        let nftDetail = getNFTDetail(pointer:pointer, views: views)\n        if nftDetail == nil {\n            return nil\n        }\n\n\n        let findAddress=FindMarket.getFindTenantAddress()\n        let findMarket=FindMarket.getNFTListing(tenant:findAddress, address: address, id: nftDetail!.uuid, getNFTInfo:false)\n\n        /*\n        var listings : StorefrontListing? = nil\n        let storefrontCap = account.getCapability\u003c\u0026NFTStorefront.Storefront{NFTStorefront.StorefrontPublic}\u003e(NFTStorefront.StorefrontPublicPath)\n\n        if storefrontCap.check() {\n            let storefrontRef=storefrontCap.borrow()!\n            for listingId in storefrontRef.getListingIDs() {\n                let listing = storefrontRef.borrowListing(listingResourceID: listingId)!\n                let nft=listing.borrowNFT()\n                if nft.id==id \u0026\u0026 !listing.getDetails().purchased {\n                    listings = StorefrontListing(listingId: listingId, details: listing.getDetails())\n                }\n            }\n        }\n        */\n\n        var report : {String : ListingTypeReport} = {}\n\n        // check if that's soulBound, if yes, the report will be nil\n        if !pointer.checkSoulBound() {\n            let tenantCap = FindMarket.getTenantCapability(findAddress)!\n            let tenantRef = tenantCap.borrow() ?? panic(\"This tenant is not set up. Tenant : \".concat(tenantCap.address.toString()))\n\n            let marketTypes = FindMarket.getSaleItemTypes()\n\n            for marketType in marketTypes {\n                if let allowedListing = tenantRef.getAllowedListings(nftType: pointer.getItemType(), marketType: marketType) {\n                    report[FindMarket.getMarketOptionFromType(marketType)] = createListingTypeReport(allowedListing, pointer: pointer, tenantRef: tenantRef)\n                }\n            }\n        }\n        return NFTDetailReport(findMarket:findMarket, storefront:nil, nftDetail: nftDetail, allowedListingActions: report, linkedForMarket : linkedForMarket)\n    }\n    return nil\n\n}\n\npub let resolvedAddresses : {Address : String} = {}\n\npub var nftRoyalties : [Royalties]? = nil\n\npub fun reverseLookup(_ addr: Address) : String? {\n\n    if let name = resolvedAddresses[addr] {\n        if name == \"\" {\n            return nil\n        } else {\n            return name\n        }\n    }\n    let name = FIND.reverseLookup(addr) \n    if name == nil {\n        resolvedAddresses[addr] = \"\"\n    } else {\n        resolvedAddresses[addr] = name\n    }\n    return name\n\n}\n\npub fun getNFTDetail(pointer: FindViews.ViewReadPointer, views: [String]) : NFTDetail? {\n\n    if !pointer.valid() {\n        return nil\n    }\n\n    var nftViews: {String : AnyStruct} = {}\n    var resolvedViews: [Type] = []\n    let viewResolver = pointer.getViewResolver()\n\n    let defaultViews = defaultViews()\n    for view in views {\n        if let runTimeType = CompositeType(view) {\n            if !defaultViews.contains(runTimeType) {\n                defaultViews.append(runTimeType)\n            }\n        }\n    }\n\n\n    for runTimeType in defaultViews {\n        // Resolve arrayed views to ensure we didn't miss any stuff \n        if runTimeType == Type\u003cMetadataViews.Editions\u003e() {\n            if let editions = MetadataViews.getEditions(viewResolver) {\n                if let edition = getEdition(viewResolver) {\n                    var check = false\n                    for item in editions.infoList {\n                        if item.name == edition.name \u0026\u0026 item.number == edition.number \u0026\u0026 item.max == edition.max {\n                            check = true\n                            break\n                        }\n                    }\n                    // If the edition does not exist in editions, add it in\n                    if !check {\n                        let array = editions.infoList \n                        array.append(edition)\n                        nftViews[\"Editions\"] = MetadataViews.Editions(array)\n                        resolvedViews.append(runTimeType)\n                        continue\n                    }\n                } \n                // If edition does not exist OR edition is already in editions , append it to views and continue\n                nftViews[\"Editions\"] = editions\n                resolvedViews.append(runTimeType)\n                continue\n            }\n        }\n\n        if runTimeType == Type\u003cMetadataViews.Edition\u003e() {\n            // If the editions does not exist, check if there is edition, if there is, add it in as editions\n            if nftViews[\"Editions\"] == nil {\n                if let edition = getEdition(viewResolver) {\n                    nftViews[\"Editions\"] = MetadataViews.Editions([edition])\n                    resolvedViews.append(runTimeType)\n                }\n            } \n            continue\n        }\n\n        if runTimeType == Type\u003cMetadataViews.Medias\u003e() {\n            if let medias = MetadataViews.getMedias(viewResolver) {\n                if let media = getMedia(viewResolver) {\n                    var check = false \n                    let uri = media.file.uri()\n                    for item in medias.items {\n                        if item.file.uri() == uri {\n                            check = true \n                            break\n                        }\n                        if !check {\n                            let array = medias.items\n                            array.append(media)\n                            nftViews[\"Medias\"] = MetadataViews.Medias(array)\n                            resolvedViews.append(runTimeType)\n                            continue\n                        }\n                    }\n                } \n                nftViews[\"Medias\"] = medias\n                resolvedViews.append(runTimeType)\n                continue\n            }\n        }\n\n        if runTimeType == Type\u003cMetadataViews.Media\u003e() {\n            if nftViews[\"Medias\"] == nil {\n                if let media = getMedia(viewResolver) {\n                    nftViews[\"Medias\"] = MetadataViews.Medias([media])\n                    resolvedViews.append(runTimeType)\n                }\n            }\n            continue\n        }\n\n        if runTimeType == Type\u003cMetadataViews.Traits\u003e() {\n            if let traits = MetadataViews.getTraits(viewResolver) {\n                if let trait = getTrait(viewResolver) {\n                    var check = false \n                    for item in traits.traits {\n                        if item.name == trait.name {\n                            check = true \n                            break\n                        }\n                        if !check {\n                            let array = traits.traits\n                            array.append(trait)\n\n                            nftViews[\"Traits\"] = cleanUpTraits(array)\n                            resolvedViews.append(runTimeType)\n                            continue\n                        }\n                    }\n                } \n                nftViews[\"Traits\"] = cleanUpTraits(traits.traits)\n                resolvedViews.append(runTimeType)\n                continue\n            }\n        }\n\n        if runTimeType == Type\u003cMetadataViews.Trait\u003e() {\n            if nftViews[\"Traits\"] == nil {\n                if let trait = getTrait(viewResolver) {\n                    nftViews[\"Traits\"] = MetadataViews.Traits([trait])\n                    resolvedViews.append(runTimeType)\n                }\n            } \n            continue\n        }\n\n        if let view = pointer.resolveView(runTimeType) {\n            nftViews[runTimeType.identifier.slice(from: \"A.1d7e57aa55817448.MetadataViews.\".length, upTo: runTimeType.identifier.length)] = view\n            resolvedViews.append(runTimeType)\n        }\n    }\n    \n    return NFTDetail(pointer, views: nftViews, resolvedViews: resolvedViews)\n\n\n}\n\npub fun getEdition(_ viewResolver: \u0026{MetadataViews.Resolver}) : MetadataViews.Edition? {\n    if let view = viewResolver.resolveView(Type\u003cMetadataViews.Edition\u003e()) {\n        if let v = view as? MetadataViews.Edition {\n            return v\n        }\n    }\n    return nil\n}\n\npub fun getMedia(_ viewResolver: \u0026{MetadataViews.Resolver}) : MetadataViews.Media? {\n    if let view = viewResolver.resolveView(Type\u003cMetadataViews.Media\u003e()) {\n        if let v = view as? MetadataViews.Media {\n            return v\n        }\n    }\n    return nil\n}\n\npub fun getTrait(_ viewResolver: \u0026{MetadataViews.Resolver}) : MetadataViews.Trait? {\n    if let view = viewResolver.resolveView(Type\u003cMetadataViews.Trait\u003e()) {\n        if let v = view as? MetadataViews.Trait {\n            return v\n        }\n    }\n    return nil\n}\n\n/* Helper Function */\npub fun resolveRoyalties(_ pointer: FindViews.ViewReadPointer) : [Royalties] {\n    let array : [Royalties] = []\n    for royalty in pointer.getRoyalty().getRoyalties() {\n        let address = royalty.receiver.address\n        array.append(Royalties(royaltyName: royalty.description, address: address, findName: reverseLookup(address), cut: royalty.cut))\n    }\n\n    return array\n}\n\npub fun resolveFindRoyalties(tenantRef: \u0026FindMarket.Tenant{FindMarket.TenantPublic}, listing: Type, nft: Type, ft: Type) : [Royalties] {\n\n    let cuts = tenantRef.getTenantCut(name:\"\", listingType: listing, nftType:nft, ftType:ft)\n\n    let royalties :[Royalties] = []\n    if cuts.findCut != nil {\n        royalties.append(Royalties(royaltyName: cuts.findCut!.description, address: cuts.findCut!.receiver.address, findName: reverseLookup(cuts.findCut!.receiver.address), cut: cuts.findCut!.cut))\n    }\n\n    if cuts.tenantCut != nil {\n        royalties.append(Royalties(royaltyName: cuts.tenantCut!.description, address: cuts.tenantCut!.receiver.address, findName: reverseLookup(cuts.tenantCut!.receiver.address), cut: cuts.tenantCut!.cut))\n    }\n    \n    return royalties\n}\n\npub fun createListingTypeReport(_ allowedListing: FindMarket.AllowedListing, pointer: FindViews.ViewReadPointer, tenantRef: \u0026FindMarket.Tenant{FindMarket.TenantPublic}) : ListingTypeReport {\n    let listingType = allowedListing.listingType.identifier\n    var ftAlias : [String] = []\n    var ftIdentifier : [String] = []\n    var listingDetails : [ListingRoyalties] = []\n    for ft in allowedListing.ftTypes {\n        ftIdentifier.append(ft.identifier)\n        var alias : String? = nil\n        if let ftInfo = FTRegistry.getFTInfo(ft.identifier) {\n            alias = ftInfo.alias\n            ftAlias.append(ftInfo.alias)\n        }\n\n        // getRoyalties \n        var nftR = nftRoyalties \n        if nftR == nil {\n            nftRoyalties = resolveRoyalties(pointer)\n            nftR = nftRoyalties\n        }\n\n        let findR = resolveFindRoyalties(tenantRef: tenantRef, listing: allowedListing.listingType , nft: pointer.getItemType(), ft: ft)\n        findR.appendAll(nftR!)\n\n        listingDetails.append(ListingRoyalties(ftAlias: alias, ftIdentifier: ft.identifier, royalties: findR))\n    }\n    \n    return ListingTypeReport(listingType: listingType, ftAlias: ftAlias, ftIdentifiers: ftIdentifier,  status: allowedListing.status , ListingDetails: listingDetails)\n}\n\npub fun defaultViews() : [Type] {\n    return [\n    Type\u003cMetadataViews.Display\u003e() ,\n    Type\u003cMetadataViews.Editions\u003e() , \n    Type\u003cMetadataViews.Edition\u003e() ,\n    Type\u003cMetadataViews.Serial\u003e() , \n    Type\u003cMetadataViews.Medias\u003e() ,\n    Type\u003cMetadataViews.Media\u003e() ,\n    Type\u003cMetadataViews.License\u003e() , \n    Type\u003cMetadataViews.ExternalURL\u003e() , \n    Type\u003cMetadataViews.NFTCollectionDisplay\u003e() , \n    Type\u003cMetadataViews.Traits\u003e() , \n    Type\u003cMetadataViews.Trait\u003e() ,\n    Type\u003cMetadataViews.Rarity\u003e() \n    ]\n}\n\npub fun getStoragePath(_ nftIdentifier: String) : StoragePath {\n    if let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys {\n        let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n        return collection.collectionData.storagePath\n    }\n\n    if let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier :nftIdentifier) {\n        return collection.collectionData.storagePath\n    }\n    panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier)) \n}\n\npub fun getPublicPath(_ nftIdentifier: String) : PublicPath {\n    if let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys {\n        let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n        return collection.collectionData.publicPath\n    }\n\n    if let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier :nftIdentifier) {\n        return collection.collectionData.publicPath\n    }\n    panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier)) \n}\n\npub fun cleanUpTraits(_ traits: [MetadataViews.Trait]) : MetadataViews.Traits {\n    let dateValues  = {\"Date\" : true, \"Numeric\":false, \"Number\":false, \"date\":true, \"numeric\":false, \"number\":false}\n\n    let array : [MetadataViews.Trait] = []\n\n    for i , trait in traits {\n        let displayType = trait.displayType ?? \"string\"\n        if let isDate = dateValues[displayType] {\n            if isDate {\n                array.append(MetadataViews.Trait(name: trait.name, value: trait.value, displayType: \"Date\", rarity: trait.rarity))\n            } else {\n                array.append(MetadataViews.Trait(name: trait.name, value: trait.value, displayType: \"Numeric\", rarity: trait.rarity))\n            }\n        } else {\n            if let value = trait.value as? Bool {\n                if value {\n                    array.append(MetadataViews.Trait(name: trait.name, value: trait.value, displayType: \"Bool\", rarity: trait.rarity))\n                }else {\n                    array.append(MetadataViews.Trait(name: trait.name, value: trait.value, displayType: \"Bool\", rarity: trait.rarity))\n                }\n            } else if let value = trait.value as? String {\n                array.append(MetadataViews.Trait(name: trait.name, value: trait.value, displayType: \"String\", rarity: trait.rarity))\n            } else {\n                array.append(MetadataViews.Trait(name: trait.name, value: trait.value, displayType: \"String\", rarity: trait.rarity))\n            }\n        }\n    }\n    return MetadataViews.Traits(array)\n}",
               "spec": {
                  "order": [
                     "user",
                     "project",
                     "id",
                     "views"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "project": "String",
                     "user": "String",
                     "views": "[String]"
                  }
               }
            },
            "getNFTView": {
               "code": "import MetadataViews from 0xf8d6e0586b0a20c7\nimport FINDNFTCatalog from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\n\n//Fetch a single view from a nft on a given path\npub fun main(user: String, aliasOrIdentifier:String, id: UInt64, identifier: String) : AnyStruct? {\n\n    let publicPath = getPublicPath(aliasOrIdentifier)\n    let resolveAddress = FIND.resolve(user) \n    if resolveAddress == nil {return []}\n    let address = resolveAddress!\n\n    let pp = publicPath\n    let account = getAccount(address)\n    if account.balance == 0.0 {\n        return nil\n    }\n    let collection= account.getCapability(pp).borrow\u003c\u0026{MetadataViews.ResolverCollection}\u003e()!\n\n    let nft=collection.borrowViewResolver(id: id)\n    for v in nft.getViews() {\n        if v.identifier== identifier {\n            return nft.resolveView(v)\n        }\n    }\n    return nil\n}\n\npub fun getPublicPath(_ nftIdentifier: String) : PublicPath {\n    let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier)) \n    let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n    return collection.collectionData.publicPath\n}",
               "spec": {
                  "order": [
                     "user",
                     "aliasOrIdentifier",
                     "id",
                     "identifier"
                  ],
                  "parameters": {
                     "aliasOrIdentifier": "String",
                     "id": "UInt64",
                     "identifier": "String",
                     "user": "String"
                  }
               }
            },
            "getNFTViews": {
               "code": "import MetadataViews from 0xf8d6e0586b0a20c7\nimport NFTCatalog from 0xf8d6e0586b0a20c7\nimport FINDNFTCatalog from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\n\n//get all the views for an nft and address/path/id\npub fun main(user: String, aliasOrIdentifier:String, id: UInt64) : [String] {\n    let nftInfo = getCollectionData(aliasOrIdentifier) \n\n    let resolveAddress = FIND.resolve(user) \n    if resolveAddress == nil {return []}\n    let address = resolveAddress!\n    let pp = nftInfo.publicPath\n    let collection= getAccount(address).getCapability(pp).borrow\u003c\u0026{MetadataViews.ResolverCollection}\u003e()!\n    let nft=collection.borrowViewResolver(id: id)\n    let views:[String]=[]\n    for v in nft.getViews() {\n        views.append(v.identifier)\n    }\n    return views\n}\n\npub fun getCollectionData(_ nftIdentifier: String) : NFTCatalog.NFTCollectionData {\n    let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier)) \n    let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n    return collection.collectionData\n}",
               "spec": {
                  "order": [
                     "user",
                     "aliasOrIdentifier",
                     "id"
                  ],
                  "parameters": {
                     "aliasOrIdentifier": "String",
                     "id": "UInt64",
                     "user": "String"
                  }
               }
            },
            "getName": {
               "code": "import FIND from 0xf8d6e0586b0a20c7\n\npub fun main(address: Address) : String?{\n    return FIND.reverseLookup(address)\n}",
               "spec": {
                  "order": [
                     "address"
                  ],
                  "parameters": {
                     "address": "Address"
                  }
               }
            },
            "getNameDetails": {
               "code": "import FIND from 0xf8d6e0586b0a20c7\nimport Profile from 0xf8d6e0586b0a20c7\nimport RelatedAccounts from 0xf8d6e0586b0a20c7\n\npub struct FINDReport {\n    pub let profile:Profile.UserReport?\n    pub let bids: [FIND.BidInfo]\n    pub let relatedAccounts: { String: Address}\n    pub let leases: [FIND.LeaseInformation]\n    pub let privateMode: Bool\n    pub let activatedAccount: Bool \n\n\n    init(profile: Profile.UserReport?, relatedAccounts: {String: Address}, bids: [FIND.BidInfo], leases : [FIND.LeaseInformation], privateMode: Bool, activatedAccount: Bool ) {\n        self.profile=profile\n        self.bids=bids\n        self.leases=leases\n        self.relatedAccounts=relatedAccounts\n        self.privateMode=privateMode\n        self.activatedAccount=activatedAccount\n    }\n}\n\npub struct NameReport {\n    pub let status: String\n    pub let cost: UFix64 \n    pub let leaseStatus: FIND.LeaseInformation?\n    pub let userReport: FINDReport? \n\n    init(status: String, cost: UFix64, leaseStatus: FIND.LeaseInformation?, userReport: FINDReport? ) {\n        self.status=status \n        self.cost=cost \n        self.leaseStatus=leaseStatus\n        self.userReport=userReport\n    }\n}\n\npub fun main(user: String) : NameReport? {\n\n    var findReport: FINDReport? = nil\n    var nameLease: FIND.LeaseInformation? = nil\n    if let address=FIND.resolve(user) {\n        let account=getAccount(address)\n        if account.balance != 0.0 {\n            let bidCap = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n            let leaseCap = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n            let profile=account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath).borrow()\n\n            var profileReport = profile?.asReport() \n            if profileReport != nil \u0026\u0026 profileReport!.findName != FIND.reverseLookup(address) {\n                profileReport = Profile.UserReport(\n                    findName: \"\",\n                    address: profileReport!.address,\n                    name: profileReport!.name,\n                    gender: profileReport!.gender,\n                    description: profileReport!.description,\n                    tags: profileReport!.tags,\n                    avatar: profileReport!.avatar,\n                    links: profileReport!.links,\n                    wallets: profileReport!.wallets, \n                    following: profileReport!.following,\n                    followers: profileReport!.followers,\n                    allowStoringFollowers: profileReport!.allowStoringFollowers,\n                    createdAt: profileReport!.createdAt\n                )\n            }\n\n            findReport = FINDReport(\n                profile: profileReport,\n                relatedAccounts: RelatedAccounts.findRelatedFlowAccounts(address:address),\n                bids: bidCap.borrow()?.getBids() ?? [],\n                leases: leaseCap.borrow()?.getLeaseInformation() ?? [],\n                privateMode: profile?.isPrivateModeEnabled() ?? false, \n                activatedAccount: true\n            )\n            if FIND.validateFindName(user) \u0026\u0026 findReport != nil {\n                for lease in findReport!.leases {\n                    if lease.name == user {\n                        nameLease = lease\n                        break\n                    }\n                }\n            }\n        } else {\n            findReport = FINDReport(\n                profile: nil,\n                relatedAccounts: {},\n                bids: [],\n                leases: [],\n                privateMode: false, \n                activatedAccount: false\n            )\n        }\n        \n    }\n\n    var nameReport : NameReport? = nil \n    if FIND.validateFindName(user) {\n        let status = FIND.status(user)\n        let cost=FIND.calculateCost(user)\n        var s=\"TAKEN\"    \n        if status.status == FIND.LeaseStatus.FREE {\n            s=\"FREE\"\n        } else if status.status == FIND.LeaseStatus.LOCKED {\n            s=\"LOCKED\"\n        }\n        nameReport = NameReport(status: s, cost: cost, leaseStatus: nameLease, userReport: findReport)\n    }\n    \n\n    return nameReport\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "getNameStatus": {
               "code": "import FIND from 0xf8d6e0586b0a20c7\nimport Profile from 0xf8d6e0586b0a20c7\n\npub fun main(name: String) :  \u0026{Profile.Public}? {\n    return FIND.lookup(name)\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "getNames": {
               "code": "import FIND from 0xf8d6e0586b0a20c7\n\npub fun main(address: [Address]) : { Address:String}{\n\n    let items : {Address:String} = {}\n    for a in address {\n        if let name= FIND.reverseLookup(a) {\n            items[a]=name\n        }\n    }\n    return items\n}",
               "spec": {
                  "order": [
                     "address"
                  ],
                  "parameters": {
                     "address": "[Address]"
                  }
               }
            },
            "getNamesWithBids": {
               "code": "import FIND from 0xf8d6e0586b0a20c7\n\npub fun main(user: String) : [FIND.LeaseInformation] {\n\n    let resolveAddress = FIND.resolve(user) \n    if resolveAddress == nil {return []}\n    let address = resolveAddress!\n    let account=getAccount(address)\n\n    if account.balance == 0.0 {\n        return []\n    }\n\n    let leaseCap = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\n    let leases=leaseCap.borrow()?.getLeaseInformation() ?? []\n\n    var leasesWithBids :[FIND.LeaseInformation] =[]\n    for lease in leases {\n        if lease.latestBidBy != nil {\n            leasesWithBids.append(lease)\n        }\n    }\n\n    return leasesWithBids\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "getNamesWithoutBids": {
               "code": "import FIND from 0xf8d6e0586b0a20c7\n\n\npub fun main(user: String) : [String] {\n\n    let resolveAddress = FIND.resolve(user) \n    if resolveAddress == nil {return []}\n    let address = resolveAddress!\n    let account=getAccount(address)\n\n    if account.balance == 0.0 {\n        return []\n    }\n\n    let leaseCap = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\n    let leases=leaseCap.borrow()?.getLeaseInformation() ?? []\n\n    var leasesWithBids :[String] =[]\n    for lease in leases {\n        if lease.latestBidBy == nil {\n            leasesWithBids.append(lease.name)\n        }\n    }\n\n    return leasesWithBids\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "getProfile": {
               "code": "import Profile from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\n\npub fun main(user: String) :  Profile.UserReport? {\n    let resolveAddress = FIND.resolve(user) \n    if resolveAddress == nil {return nil}\n    let address = resolveAddress!\n    let account = getAccount(address)\n    if account.balance == 0.0 {\n        return nil\n    }\n\n    var profileReport = account\n        .getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        .borrow()?.asReport()\n\n    if profileReport != nil \u0026\u0026 profileReport!.findName != FIND.reverseLookup(address) {\n        profileReport = Profile.UserReport(\n            findName: \"\",\n            address: profileReport!.address,\n            name: profileReport!.name,\n            gender: profileReport!.gender,\n            description: profileReport!.description,\n            tags: profileReport!.tags,\n            avatar: profileReport!.avatar,\n            links: profileReport!.links,\n            wallets: profileReport!.wallets, \n            following: profileReport!.following,\n            followers: profileReport!.followers,\n            allowStoringFollowers: profileReport!.allowStoringFollowers,\n            createdAt: profileReport!.createdAt\n        )\n    }\n\n    return profileReport\n\n\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "getRoyaltyChangedIds": {
               "code": "import FindMarket from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\n\npub fun main(marketplace: Address, user: String) : {String : [UInt64]} {\n    if let address = FIND.resolve(user){\n        return FindMarket.getRoyaltiesChangedIds(tenant:marketplace, address: address)\n    }\n    return {}\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "user"
                  ],
                  "parameters": {
                     "marketplace": "Address",
                     "user": "String"
                  }
               }
            },
            "getRoyaltyChangedItems": {
               "code": "import FindMarket from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\n\npub fun main(marketplace: Address, user: String) : {String : FindMarket.SaleItemCollectionReport} {\n    if let address = FIND.resolve(user){\n        return FindMarket.getRoyaltiesChangedItems(tenant:marketplace, address: address)\n    }\n    return {}\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "user"
                  ],
                  "parameters": {
                     "marketplace": "Address",
                     "user": "String"
                  }
               }
            },
            "getShardCollectionsNFTCatalog": {
               "code": "import NonFungibleToken from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\nimport FINDNFTCatalog from 0xf8d6e0586b0a20c7\n\npub fun main(user: String) : {String : CollectionLength} {\n\n    if let address = FIND.resolve(user) {\n\n        return getNFTIDs_Catalog(ownerAddress: address, cacheCollections: {})\n\n    }\n    return {}\n\n}\n\npub struct CollectionLength {\n    pub let shard : String \n    pub let length : Int \n    init(shard : String, length : Int ) {\n        self.shard=shard \n        self.length=length\n    }\n}\n\n// Helper function \n\npub fun resolveAddress(user: String) : Address? {\n    return FIND.resolve(user)\n}\n\npub fun getNFTIDs_Catalog(ownerAddress: Address, cacheCollections: {String:CollectionLength}) : {String:CollectionLength} {\n\n    let account = getAuthAccount(ownerAddress)\n\n    let types = FINDNFTCatalog.getCatalogTypeData()\n    for nftType in types.keys {\n\n        let typeData=types[nftType]!\n        let collectionKey=typeData.keys[0]\n        let catalogEntry = FINDNFTCatalog.getCatalogEntry(collectionIdentifier:collectionKey)!\n        let tempPathStr = \"catalog\".concat(collectionKey)\n        let tempPublicPath = PublicPath(identifier: tempPathStr)!\n        account.link\u003c\u0026NonFungibleToken.Collection\u003e(tempPublicPath, target: catalogEntry.collectionData.storagePath)\n        let cap= account.getCapability\u003c\u0026NonFungibleToken.Collection\u003e(tempPublicPath)\n        if cap.check(){\n            let collection = cap.borrow()!\n            let length = collection.ownedNFTs.length\n            if length == 0 {\n                continue\n            }\n            cacheCollections[collectionKey] = CollectionLength(shard: \"NFTCatalog\", length: length)\n        }\n    }\n    return cacheCollections\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "getStatus": {
               "code": "import FIND from 0xf8d6e0586b0a20c7\nimport Profile from 0xf8d6e0586b0a20c7\nimport RelatedAccounts from 0xf8d6e0586b0a20c7\nimport FindMarket from 0xf8d6e0586b0a20c7\nimport FindLeaseMarket from 0xf8d6e0586b0a20c7\nimport FINDNFTCatalog from 0xf8d6e0586b0a20c7\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport FindLostAndFoundWrapper from 0xf8d6e0586b0a20c7\nimport NFTCatalog from 0xf8d6e0586b0a20c7\nimport EmeraldIdentity from 0xf8d6e0586b0a20c7\nimport EmeraldIdentityDapper from 0xf8d6e0586b0a20c7\nimport EmeraldIdentityLilico from 0xf8d6e0586b0a20c7\n\npub struct FINDReport{\n    pub let profile:Profile.UserReport?\n    pub let bids: [FIND.BidInfo]\n    pub let relatedAccounts: { String: Address}\n    pub let leases: [FIND.LeaseInformation]\n    pub let privateMode: Bool\n    pub let leasesForSale: {String : FindLeaseMarket.SaleItemCollectionReport}\n    pub let leasesBids: {String : FindLeaseMarket.BidItemCollectionReport}\n    pub let itemsForSale: {String : FindMarket.SaleItemCollectionReport}\n    pub let marketBids: {String : FindMarket.BidItemCollectionReport}\n    pub let activatedAccount: Bool \n\n    // NFT Catalog outputs\n    pub let lostAndFoundTypes: {String : NFTCatalog.NFTCollectionData}\n\n    // EmeraldID Account Linkage \n    pub let emeraldIDAccounts : {String : Address}\n\n\n    init(profile: Profile.UserReport?, \n         relatedAccounts: {String: Address}, \n         bids: [FIND.BidInfo], \n         leases : [FIND.LeaseInformation], \n         privateMode: Bool, \n         leasesForSale: {String : FindLeaseMarket.SaleItemCollectionReport}, \n         leasesBids: {String : FindLeaseMarket.BidItemCollectionReport}, \n         itemsForSale: {String : FindMarket.SaleItemCollectionReport}, \n         marketBids: {String : FindMarket.BidItemCollectionReport}, \n         activatedAccount: Bool, \n         lostAndFoundTypes: {String : NFTCatalog.NFTCollectionData}, \n         emeraldIDAccounts : {String : Address}\n         ) {\n\n        self.profile=profile\n        self.bids=bids\n        self.leases=leases\n        self.relatedAccounts=relatedAccounts\n        self.privateMode=privateMode\n        self.leasesForSale=leasesForSale\n        self.leasesBids=leasesBids\n        self.itemsForSale=itemsForSale\n        self.marketBids=marketBids\n        self.activatedAccount=activatedAccount\n        self.lostAndFoundTypes=lostAndFoundTypes\n        self.emeraldIDAccounts=emeraldIDAccounts\n    }\n}\n\npub struct NameReport {\n    pub let status: String \n    pub let cost: UFix64 \n\n    init(status: String, cost: UFix64) {\n        self.status=status \n        self.cost=cost\n    }\n}\n\npub struct Report {\n    pub let FINDReport: FINDReport?\n    pub let NameReport: NameReport?\n\n    init(FINDReport: FINDReport?, NameReport: NameReport?) {\n        self.FINDReport=FINDReport \n        self.NameReport=NameReport\n    }\n}\n\npub fun main(user: String) : Report? {\n\n    var findReport: FINDReport? = nil\n    if let address=FIND.resolve(user) {\n        let account=getAccount(address)\n        if account.balance \u003e 0.0 {\n            let bidCap = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n            let leaseCap = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n            let profile=account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath).borrow()\n\n            let find= FindMarket.getFindTenantAddress()\n            let findLease= FindMarket.getTenantAddress(\"findLease\")!\n            let items : {String : FindMarket.SaleItemCollectionReport} = FindMarket.getSaleItemReport(tenant:find, address: address, getNFTInfo:true)\n\n            let marketBids : {String : FindMarket.BidItemCollectionReport} = FindMarket.getBidsReport(tenant:find, address: address, getNFTInfo:true)\n\n            let leasesSale : {String : FindLeaseMarket.SaleItemCollectionReport} = FindLeaseMarket.getSaleItemReport(tenant:findLease, address: address, getLeaseInfo:true)\n\n            let leasesBids : {String : FindLeaseMarket.BidItemCollectionReport} = FindLeaseMarket.getBidsReport(tenant:findLease, address: address, getLeaseInfo:true)\n\n            var profileReport = profile?.asReport() \n            if profileReport != nil \u0026\u0026 profileReport!.findName != FIND.reverseLookup(address) {\n                profileReport = Profile.UserReport(\n                    findName: \"\",\n                    address: profileReport!.address,\n                    name: profileReport!.name,\n                    gender: profileReport!.gender,\n                    description: profileReport!.description,\n                    tags: profileReport!.tags,\n                    avatar: profileReport!.avatar,\n                    links: profileReport!.links,\n                    wallets: profileReport!.wallets, \n                    following: profileReport!.following,\n                    followers: profileReport!.followers,\n                    allowStoringFollowers: profileReport!.allowStoringFollowers,\n                    createdAt: profileReport!.createdAt\n                )\n            }\n\n            // NFTCatalog Output \n            let nftCatalogTypes = FINDNFTCatalog.getCatalogTypeData()\n            let types : {String : NFTCatalog.NFTCollectionData} = {}\n            for type in FindLostAndFoundWrapper.getSpecificRedeemableTypes(user: address, specificType: Type\u003c@NonFungibleToken.NFT\u003e()) {\n                types[type.identifier] = FINDNFTCatalog.getCollectionDataForType(nftTypeIdentifier: type.identifier)\n            }\n\n            let discordID = EmeraldIdentity.getDiscordFromAccount(account: address) \n                                    ?? EmeraldIdentityDapper.getDiscordFromAccount(account: address) \n                                    ?? EmeraldIdentityLilico.getDiscordFromAccount(account: address)\n                                    ?? \"\"\n\n            let emeraldIDAccounts : {String : Address} = {}\n            emeraldIDAccounts[\"blocto\"] = EmeraldIdentity.getAccountFromDiscord(discordID: discordID)\n            emeraldIDAccounts[\"lilico\"] = EmeraldIdentityLilico.getAccountFromDiscord(discordID: discordID)\n            emeraldIDAccounts[\"dapper\"] = EmeraldIdentityDapper.getAccountFromDiscord(discordID: discordID)\n            \n            findReport = FINDReport(\n                profile: profileReport,\n                relatedAccounts: RelatedAccounts.findRelatedFlowAccounts(address:address),\n                bids: bidCap.borrow()?.getBids() ?? [],\n                leases: leaseCap.borrow()?.getLeaseInformation() ?? [],\n                privateMode: profile?.isPrivateModeEnabled() ?? false,\n                leasesForSale: leasesSale, \n                leasesBids: leasesBids,\n                itemsForSale: items,\n                marketBids: marketBids,\n                activatedAccount: true, \n                lostAndFoundTypes: types, \n                emeraldIDAccounts: emeraldIDAccounts\n            )\n        } else {\n            findReport = FINDReport(\n                profile: nil,\n                relatedAccounts: {},\n                bids: [],\n                leases: [],\n                privateMode: false,\n                leasesForSale: {}, \n                leasesBids: {},\n                itemsForSale: {},\n                marketBids: {},\n                activatedAccount: false, \n                lostAndFoundTypes: {}, \n                emeraldIDAccounts: {}\n            )\n        }\n    }\n\n    var nameReport : NameReport? = nil \n    if FIND.validateFindName(user) {\n        let status = FIND.status(user)\n        let cost=FIND.calculateCost(user)\n        var s=\"TAKEN\"    \n        if status.status == FIND.LeaseStatus.FREE {\n            s=\"FREE\"\n        } else if status.status == FIND.LeaseStatus.LOCKED {\n            s=\"LOCKED\"\n        }\n        nameReport = NameReport(status: s, cost: cost)\n    }\n    \n\n    return Report(FINDReport: findReport, NameReport: nameReport)\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "getTenantSaleItem": {
               "code": "import FindMarket from 0xf8d6e0586b0a20c7\n\npub fun main(tenant: Address) : TenantSaleItems {\n    let tenantCap = FindMarket.getTenantCapability(tenant) ?? panic(\"No tenant capability is set up. Tenant Address : \".concat(tenant.toString()))\n    let tenantRef = tenantCap.borrow() ?? panic(\"Cannot borrow tenant reference. Tenant Address : \".concat(tenant.toString()))\n    let saleItems = tenantRef.getSaleItems()\n    return TenantSaleItems(findSaleItems: saleItems[\"findSaleItems\"]! ,\n                           tenantSaleItems: saleItems[\"tenantSaleItems\"]! ,\n                           findCuts: saleItems[\"findCuts\"]! )\n\n}\n\npub struct TenantSaleItems {\n    pub let findSaleItems : {String : FindMarket.TenantSaleItem}\n    pub let tenantSaleItems : {String : FindMarket.TenantSaleItem}\n    pub let findCuts : {String : FindMarket.TenantSaleItem} \n\n    init(findSaleItems : {String : FindMarket.TenantSaleItem}, \n         tenantSaleItems : {String : FindMarket.TenantSaleItem},\n         findCuts : {String : FindMarket.TenantSaleItem}) {\n             self.findSaleItems = findSaleItems\n             self.tenantSaleItems = tenantSaleItems \n             self.findCuts = findCuts \n         }\n}",
               "spec": {
                  "order": [
                     "tenant"
                  ],
                  "parameters": {
                     "tenant": "Address"
                  }
               }
            },
            "hasCharity": {
               "code": "import CharityNFT from 0xf8d6e0586b0a20c7\n\npub fun main(user: Address) : Bool {\n    let account=getAccount(user)\n    if account.balance == 0.0 {\n        return false\n    }\n    let charityCap = account.getCapability\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection)\n    return charityCap.check()\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "Address"
                  }
               }
            },
            "isFindUser": {
               "code": "import Profile from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\n\npub fun main(user: Address) : Bool {\n\n    let account=getAccount(user)\n    if account.balance == 0.0 {\n        return false\n    }\n    let leaseCap=account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n    let profileCap=account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\n    return leaseCap.check() \u0026\u0026 profileCap.check()\n\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "Address"
                  }
               }
            },
            "resolve": {
               "code": "import FIND from 0xf8d6e0586b0a20c7\n\npub fun main(input:String) : Address?{\n    return FIND.resolve(input)\n}",
               "spec": {
                  "order": [
                     "input"
                  ],
                  "parameters": {
                     "input": "String"
                  }
               }
            }
         },
         "transactions": {
            "acceptDirectOfferSoft": {
               "code": "import FindMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FindViews from 0xf8d6e0586b0a20c7\nimport FINDNFTCatalog from 0xf8d6e0586b0a20c7\nimport FindMarket from 0xf8d6e0586b0a20c7\n\ntransaction(marketplace:Address, id: UInt64) {\n\n    let market : \u0026FindMarketDirectOfferSoft.SaleItemCollection\n    let pointer : FindViews.AuthNFTPointer\n\n    prepare(account: AuthAccount) {\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e())\n        self.market = account.borrow\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection\u003e(from: storagePath)!\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e())\n        let item = FindMarket.assertOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: id)\n        let nftIdentifier = item.getItemType().identifier\n\n        //If this is nil, there must be something wrong with FIND setup\n        // let privatePath = getPrivatePath(nftIdentifier)\n\n        let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier)) \n        let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n        let privatePath = collection.collectionData.privatePath\n\n\n        let providerCap=account.getCapability\u003c\u0026{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e(privatePath)\n        self.pointer= FindViews.AuthNFTPointer(cap: providerCap, id: item.getItemID())\n    }\n\n    execute {\n        self.market.acceptOffer(self.pointer)\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "acceptDirectOfferSoftDUC": {
               "code": "import FindMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FindViews from 0xf8d6e0586b0a20c7\nimport NFTCatalog from 0xf8d6e0586b0a20c7\nimport FINDNFTCatalog from 0xf8d6e0586b0a20c7\nimport FindMarket from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport TokenForwarding from 0xf8d6e0586b0a20c7\nimport DapperUtilityCoin from 0xf8d6e0586b0a20c7\nimport Profile from 0xf8d6e0586b0a20c7\n\ntransaction(dapperAddress: Address, marketplace:Address, id: UInt64) {\n\n    let market : \u0026FindMarketDirectOfferSoft.SaleItemCollection\n    let pointer : FindViews.AuthNFTPointer\n\n    prepare(account: AuthAccount) {\n\n        let ducReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver)\n        if !ducReceiver.check() {\n            let dapper = getAccount(dapperAddress)\n            // Create a new Forwarder resource for DUC and store it in the new account's storage\n            let ducForwarder \u003c- TokenForwarding.createNewForwarder(recipient: dapper.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver))\n            account.save(\u003c-ducForwarder, to: /storage/dapperUtilityCoinReceiver)\n            // Publish a Receiver capability for the new account, which is linked to the DUC Forwarder\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver,target: /storage/dapperUtilityCoinReceiver)\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n        if !profile.hasWallet(\"DUC\") {\n            profile.addWallet(Profile.Wallet( name:\"DUC\", receiver:ducReceiver, balance:getAccount(dapperAddress).getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/dapperUtilityCoinBalance), accept: Type\u003c@DapperUtilityCoin.Vault\u003e(), tags: [\"duc\", \"dapperUtilityCoin\",\"dapper\"]))\n            profile.emitUpdatedEvent()\n        }\n\n\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e())\n        self.market = account.borrow\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection\u003e(from: storagePath)!\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e())\n        let item = FindMarket.assertOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: id)\n        let nftIdentifier = item.getItemType().identifier\n\n        //If this is nil, there must be something wrong with FIND setup\n        // let nft = getCollectionData(nftIdentifier)\n        let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier)) \n        let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n        let nft = collection.collectionData\n\n        let providerCap=account.getCapability\u003c\u0026{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e(nft.privatePath)\n        self.pointer= FindViews.AuthNFTPointer(cap: providerCap, id: item.getItemID())\n\n    }\n\n    execute {\n        self.market.acceptOffer(self.pointer)\n    }\n    \n}",
               "spec": {
                  "order": [
                     "dapperAddress",
                     "marketplace",
                     "id"
                  ],
                  "parameters": {
                     "dapperAddress": "Address",
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "acceptLeaseDirectOfferSoft": {
               "code": "import FindLeaseMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FindViews from 0xf8d6e0586b0a20c7\nimport FindMarket from 0xf8d6e0586b0a20c7\nimport FindLeaseMarket from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\n\ntransaction(leaseName: String) {\n\n    let market : \u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection\n    let pointer : FindLeaseMarket.AuthLeasePointer\n\n    prepare(account: AuthAccount) {\n        let marketplace = FindMarket.getTenantAddress(\"findLease\")!\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e())\n        self.market = account.borrow\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(from: storagePath)!\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e())\n        let item = FindLeaseMarket.assertOperationValid(tenant: marketplace, name: leaseName, marketOption: marketOption)\n        let ref = account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from: FIND.LeaseStoragePath) ?? panic(\"Cannot borrow reference to find lease collection. Account : \".concat(account.address.toString()))\n        self.pointer= FindLeaseMarket.AuthLeasePointer(ref: ref, name: leaseName)\n    }\n\n    execute {\n        self.market.acceptOffer(self.pointer)\n    }\n}",
               "spec": {
                  "order": [
                     "leaseName"
                  ],
                  "parameters": {
                     "leaseName": "String"
                  }
               }
            },
            "acceptLeaseDirectOfferSoftDUC": {
               "code": "import FindLeaseMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FindViews from 0xf8d6e0586b0a20c7\nimport FindMarket from 0xf8d6e0586b0a20c7\nimport FindLeaseMarket from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport TokenForwarding from 0xf8d6e0586b0a20c7\nimport DapperUtilityCoin from 0xf8d6e0586b0a20c7\nimport Profile from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\n\ntransaction(dapperAddress: Address, leaseName: String) {\n\n    let market : \u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection\n    let pointer : FindLeaseMarket.AuthLeasePointer\n\n    prepare(account: AuthAccount) {\n\n        let ducReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver)\n        if !ducReceiver.check() {\n            let dapper = getAccount(dapperAddress)\n            // Create a new Forwarder resource for DUC and store it in the new account's storage\n            let ducForwarder \u003c- TokenForwarding.createNewForwarder(recipient: dapper.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver))\n            account.save(\u003c-ducForwarder, to: /storage/dapperUtilityCoinReceiver)\n            // Publish a Receiver capability for the new account, which is linked to the DUC Forwarder\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver,target: /storage/dapperUtilityCoinReceiver)\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n        if !profile.hasWallet(\"DUC\") {\n            profile.addWallet(Profile.Wallet( name:\"DUC\", receiver:ducReceiver, balance:getAccount(dapperAddress).getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/dapperUtilityCoinBalance), accept: Type\u003c@DapperUtilityCoin.Vault\u003e(), tags: [\"duc\", \"dapperUtilityCoin\",\"dapper\"]))\n            profile.emitUpdatedEvent()\n        }\n\n        let marketplace = FindMarket.getTenantAddress(\"findLease\")!\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e())\n        self.market = account.borrow\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(from: storagePath)!\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e())\n        let item = FindLeaseMarket.assertOperationValid(tenant: marketplace, name: leaseName, marketOption: marketOption)\n\n        let ref = account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from: FIND.LeaseStoragePath) ?? panic(\"Cannot borrow reference to Find lease collection. Account : \".concat(account.address.toString()))\n        self.pointer= FindLeaseMarket.AuthLeasePointer(ref: ref, name: leaseName)\n\n    }\n\n    execute {\n        self.market.acceptOffer(self.pointer)\n    }\n    \n}",
               "spec": {
                  "order": [
                     "dapperAddress",
                     "leaseName"
                  ],
                  "parameters": {
                     "dapperAddress": "Address",
                     "leaseName": "String"
                  }
               }
            },
            "acceptMultipleDirectOfferSoft": {
               "code": "import FindMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FindViews from 0xf8d6e0586b0a20c7\nimport NFTCatalog from 0xf8d6e0586b0a20c7\nimport FINDNFTCatalog from 0xf8d6e0586b0a20c7\nimport FindMarket from 0xf8d6e0586b0a20c7\n\ntransaction(marketplace:Address, ids: [UInt64]) {\n\n    let market : \u0026FindMarketDirectOfferSoft.SaleItemCollection\n    let pointer : [FindViews.AuthNFTPointer]\n\n    prepare(account: AuthAccount) {\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e())\n        self.market = account.borrow\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection\u003e(from: storagePath)!\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e())\n\n        var counter = 0\n        self.pointer = []\n        let nfts : {String : NFTCatalog.NFTCollectionData} = {}\n\n        while counter \u003c ids.length {\n            let item = FindMarket.assertOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: ids[counter])\n            var nft : NFTCatalog.NFTCollectionData? = nil\n            let nftIdentifier = item.getItemType().identifier\n\n            if nfts[nftIdentifier] != nil {\n                nft = nfts[nftIdentifier]\n            } else {\n                // nft = getCollectionData(nftIdentifier) \n                let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier)) \n                let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n                nft = collection.collectionData\n                nfts[nftIdentifier] = nft\n            }\n\n            let providerCap=account.getCapability\u003c\u0026{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e(nft!.privatePath)\n            let pointer= FindViews.AuthNFTPointer(cap: providerCap, id: item.getItemID())\n            self.pointer.append(pointer)\n            counter = counter + 1\n        }\n    }\n\n    execute {\n        var counter = 0\n        while counter \u003c ids.length {\n            self.market.acceptOffer(self.pointer[counter])\n            counter = counter + 1\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "ids"
                  ],
                  "parameters": {
                     "ids": "[UInt64]",
                     "marketplace": "Address"
                  }
               }
            },
            "acceptMultipleDirectOfferSoftDUC": {
               "code": "import FindMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FindViews from 0xf8d6e0586b0a20c7\nimport NFTCatalog from 0xf8d6e0586b0a20c7\nimport FINDNFTCatalog from 0xf8d6e0586b0a20c7\nimport FindMarket from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport TokenForwarding from 0xf8d6e0586b0a20c7\nimport DapperUtilityCoin from 0xf8d6e0586b0a20c7\nimport Profile from 0xf8d6e0586b0a20c7\n\ntransaction(dapperAddress: Address, marketplace:Address, ids: [UInt64]) {\n\n    let market : \u0026FindMarketDirectOfferSoft.SaleItemCollection\n    let pointer : [FindViews.AuthNFTPointer]\n\n    prepare(account: AuthAccount) {\n\n        let ducReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver)\n        if !ducReceiver.check() {\n            let dapper = getAccount(dapperAddress)\n            // Create a new Forwarder resource for DUC and store it in the new account's storage\n            let ducForwarder \u003c- TokenForwarding.createNewForwarder(recipient: dapper.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver))\n            account.save(\u003c-ducForwarder, to: /storage/dapperUtilityCoinReceiver)\n            // Publish a Receiver capability for the new account, which is linked to the DUC Forwarder\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver,target: /storage/dapperUtilityCoinReceiver)\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n        if !profile.hasWallet(\"DUC\") {\n            profile.addWallet(Profile.Wallet( name:\"DUC\", receiver:ducReceiver, balance:getAccount(dapperAddress).getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/dapperUtilityCoinBalance), accept: Type\u003c@DapperUtilityCoin.Vault\u003e(), tags: [\"duc\", \"dapperUtilityCoin\",\"dapper\"]))\n            profile.emitUpdatedEvent()\n        }\n\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e())\n        self.market = account.borrow\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection\u003e(from: storagePath)!\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e())\n\n        var counter = 0\n        self.pointer = []\n        let nfts : {String : NFTCatalog.NFTCollectionData} = {}\n\n        while counter \u003c ids.length {\n            let item = FindMarket.assertOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: ids[counter])\n            var nft : NFTCatalog.NFTCollectionData? = nil\n            let nftIdentifier = item.getItemType().identifier\n            let ftType = item.getFtType()\n\n            if nfts[nftIdentifier] != nil {\n                nft = nfts[nftIdentifier]\n            } else {\n                // nft = getCollectionData(nftIdentifier) \n                let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier)) \n                let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n                nft = collection.collectionData\n                nfts[nftIdentifier] = nft\n            }\n\n            let providerCap=account.getCapability\u003c\u0026{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e(nft!.privatePath)\n            let pointer= FindViews.AuthNFTPointer(cap: providerCap, id: item.getItemID())\n            self.pointer.append(pointer)\n            counter = counter + 1\n        }\n\n    }\n\n    execute {\n        var counter = 0\n        while counter \u003c ids.length {\n            self.market.acceptOffer(self.pointer[counter])\n            counter = counter + 1\n        }\n    }\n    \n}",
               "spec": {
                  "order": [
                     "dapperAddress",
                     "marketplace",
                     "ids"
                  ],
                  "parameters": {
                     "dapperAddress": "Address",
                     "ids": "[UInt64]",
                     "marketplace": "Address"
                  }
               }
            },
            "addCuratedCollection": {
               "code": "transaction(name: String, items: [String]) {\n    prepare(account: AuthAccount) {\n\n        let path=/storage/FindCuratedCollections\n        let publicPath=/public/FindCuratedCollections\n\n        var collections : {String: [String]} = {}\n        if account.borrow\u003c\u0026{String: [String]}\u003e(from:path) != nil {\n             collections=account.load\u003c{String: [String]}\u003e(from:path)!\n        }\n        collections[name] = items\n        account.save(collections, to: path)\n        let link = account.getCapability\u003c\u0026{String: [String]}\u003e(publicPath)\n        if !link.check() {\n            account.link\u003c\u0026{String: [String]}\u003e( publicPath, target: path)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "items"
                  ],
                  "parameters": {
                     "items": "[String]",
                     "name": "String"
                  }
               }
            },
            "adminAddForge": {
               "code": "import Admin from 0xf8d6e0586b0a20c7\n\ntransaction(name: String, type: String) {\n\n    prepare(admin:AuthAccount) {\n\n        let client= admin.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath)!\n\n        client.addPrivateForgeType(name: name, forgeType: CompositeType(type)!)\n\n    }\n\n}",
               "spec": {
                  "order": [
                     "name",
                     "type"
                  ],
                  "parameters": {
                     "name": "String",
                     "type": "String"
                  }
               }
            },
            "adminAddNFTCatalog": {
               "code": "import MetadataViews from 0xf8d6e0586b0a20c7\nimport FINDNFTCatalog from 0xf8d6e0586b0a20c7\nimport NFTCatalog from 0xf8d6e0586b0a20c7\nimport FINDNFTCatalogAdmin from 0xf8d6e0586b0a20c7\n\ntransaction(\n    collectionIdentifier : String,\n    contractName: String,\n    contractAddress: Address,\n    addressWithNFT: Address,\n    nftID: UInt64,\n    publicPathIdentifier: String\n) {\n    \n    let adminResource: \u0026FINDNFTCatalogAdmin.Admin\n    \n    prepare(acct: AuthAccount) {\n        self.adminResource = acct.borrow\u003c\u0026FINDNFTCatalogAdmin.Admin\u003e(from: FINDNFTCatalogAdmin.AdminStoragePath)!\n    }\n    \n    execute {\n        let nftAccount = getAccount(addressWithNFT)\n        let pubPath = PublicPath(identifier: publicPathIdentifier)!\n        let collectionCap = nftAccount.getCapability\u003c\u0026AnyResource{MetadataViews.ResolverCollection}\u003e(pubPath)\n        assert(collectionCap.check(), message: \"MetadataViews Collection is not set up properly, ensure the Capability was created/linked correctly.\")\n        let collectionRef = collectionCap.borrow()!\n        assert(collectionRef.getIDs().length \u003e 0, message: \"No NFTs exist in this collection.\")\n        let nftResolver = collectionRef.borrowViewResolver(id: nftID)\n        \n        let metadataCollectionData = MetadataViews.getNFTCollectionData(nftResolver)!\n        \n        let collectionData = NFTCatalog.NFTCollectionData(\n            storagePath: metadataCollectionData.storagePath,\n            publicPath: metadataCollectionData.publicPath,\n            privatePath: metadataCollectionData.providerPath,\n            publicLinkedType : metadataCollectionData.publicLinkedType,\n            privateLinkedType : metadataCollectionData.providerLinkedType\n        )\n\n        let collectionDisplay = MetadataViews.getNFTCollectionDisplay(nftResolver)!\n\n        let catalogData = NFTCatalog.NFTCatalogMetadata(\n            contractName: contractName,\n            contractAddress: contractAddress,\n            nftType: nftResolver.getType(),\n            collectionData: collectionData,\n            collectionDisplay : collectionDisplay\n        )\n\n        self.adminResource.addCatalogEntry(collectionIdentifier : collectionIdentifier, metadata : catalogData)\n    }\n}",
               "spec": {
                  "order": [
                     "collectionIdentifier",
                     "contractName",
                     "contractAddress",
                     "addressWithNFT",
                     "nftID",
                     "publicPathIdentifier"
                  ],
                  "parameters": {
                     "addressWithNFT": "Address",
                     "collectionIdentifier": "String",
                     "contractAddress": "Address",
                     "contractName": "String",
                     "nftID": "UInt64",
                     "publicPathIdentifier": "String"
                  }
               }
            },
            "adminAddNFTCatalogDirect": {
               "code": "import MetadataViews from 0xf8d6e0586b0a20c7\nimport FINDNFTCatalog from 0xf8d6e0586b0a20c7\nimport NFTCatalog from 0xf8d6e0586b0a20c7\nimport FINDNFTCatalogAdmin from 0xf8d6e0586b0a20c7\n\ntransaction(\n    collectionIdentifier : String,\n    contractName: String,\n    contractAddress: Address,\n    nftTypeIdentifer: String,\n    storagePathIdentifier: String,\n    publicPathIdentifier: String,\n    privatePathIdentifier: String,\n    publicLinkedTypeIdentifier : String,\n    publicLinkedTypeRestrictions : [String],\n    privateLinkedTypeIdentifier : String,\n    privateLinkedTypeRestrictions : [String],\n    collectionName : String,\n    collectionDescription: String,\n    externalURL : String,\n    squareImageMediaURL : String,\n    squareImageMediaType : String,\n    bannerImageMediaURL : String,\n    bannerImageMediaType : String,\n    socials: {String : String},\n) {\n    \n    let adminResource: \u0026FINDNFTCatalogAdmin.Admin\n    \n    prepare(acct: AuthAccount) {\n        self.adminResource = acct.borrow\u003c\u0026FINDNFTCatalogAdmin.Admin\u003e(from: FINDNFTCatalogAdmin.AdminStoragePath)!\n    }\n    \n    execute {\n        let collectionData = NFTCatalog.NFTCollectionData(\n            storagePath: StoragePath(identifier: storagePathIdentifier)!,\n            publicPath: PublicPath(identifier : publicPathIdentifier)!,\n            privatePath: PrivatePath(identifier: privatePathIdentifier)!,\n            publicLinkedType : RestrictedType(identifier : publicLinkedTypeIdentifier, restrictions: publicLinkedTypeRestrictions)!,\n            privateLinkedType : RestrictedType(identifier : privateLinkedTypeIdentifier, restrictions: privateLinkedTypeRestrictions)!\n        )\n\n        let squareMedia = MetadataViews.Media(\n                        file: MetadataViews.HTTPFile(\n                            url: squareImageMediaURL\n                        ),\n                        mediaType: squareImageMediaURL\n                    )\n        \n        let bannerMedia = MetadataViews.Media(\n                        file: MetadataViews.HTTPFile(\n                            url: bannerImageMediaURL\n                        ),\n                        mediaType: bannerImageMediaURL\n                    )\n\n        let socialsStruct : {String : MetadataViews.ExternalURL} = {}\n        for key in socials.keys {\n            socialsStruct[key] =  MetadataViews.ExternalURL(socials[key]!)\n        }\n        \n        let collectionDisplay = MetadataViews.NFTCollectionDisplay(\n            name: collectionName,\n            description: collectionDescription,\n            externalURL: MetadataViews.ExternalURL(externalURL),\n            squareImage: squareMedia,\n            bannerImage: bannerMedia,\n            socials: socialsStruct\n        )\n\n        let catalogData = NFTCatalog.NFTCatalogMetadata(\n            contractName: contractName,\n            contractAddress: contractAddress,\n            nftType: CompositeType(nftTypeIdentifer)!,\n            collectionData: collectionData,\n            collectionDisplay : collectionDisplay\n        )\n\n        self.adminResource.addCatalogEntry(collectionIdentifier : collectionIdentifier, metadata : catalogData)\n    }\n}",
               "spec": {
                  "order": [
                     "collectionIdentifier",
                     "contractName",
                     "contractAddress",
                     "nftTypeIdentifer",
                     "storagePathIdentifier",
                     "publicPathIdentifier",
                     "privatePathIdentifier",
                     "publicLinkedTypeIdentifier",
                     "publicLinkedTypeRestrictions",
                     "privateLinkedTypeIdentifier",
                     "privateLinkedTypeRestrictions",
                     "collectionName",
                     "collectionDescription",
                     "externalURL",
                     "squareImageMediaURL",
                     "squareImageMediaType",
                     "bannerImageMediaURL",
                     "bannerImageMediaType",
                     "socials"
                  ],
                  "parameters": {
                     "bannerImageMediaType": "String",
                     "bannerImageMediaURL": "String",
                     "collectionDescription": "String",
                     "collectionIdentifier": "String",
                     "collectionName": "String",
                     "contractAddress": "Address",
                     "contractName": "String",
                     "externalURL": "String",
                     "nftTypeIdentifer": "String",
                     "privateLinkedTypeIdentifier": "String",
                     "privateLinkedTypeRestrictions": "[String]",
                     "privatePathIdentifier": "String",
                     "publicLinkedTypeIdentifier": "String",
                     "publicLinkedTypeRestrictions": "[String]",
                     "publicPathIdentifier": "String",
                     "socials": "{String: String}",
                     "squareImageMediaType": "String",
                     "squareImageMediaURL": "String",
                     "storagePathIdentifier": "String"
                  }
               }
            },
            "adminInitDUC": {
               "code": "import FungibleToken from 0xee82856bf20e2aa6\nimport DapperUtilityCoin from 0xf8d6e0586b0a20c7\nimport TokenForwarding from 0xf8d6e0586b0a20c7\n\n\ntransaction(dapperAddress:Address) {\n\n    prepare(acct: AuthAccount) {\n        // Get a Receiver reference for the Dapper account that will be the recipient of the forwarded DUC\n        let dapper = getAccount(dapperAddress)\n      let dapperDUCReceiver = dapper.getCapability(/public/dapperUtilityCoinReceiver)\n\n      // Create a new Forwarder resource for DUC and store it in the new account's storage\n      let ducForwarder \u003c- TokenForwarding.createNewForwarder(recipient: dapperDUCReceiver)\n      acct.save(\u003c-ducForwarder, to: /storage/dapperUtilityCoinReceiver)\n\n      // Publish a Receiver capability for the new account, which is linked to the DUC Forwarder\n      acct.link\u003c\u0026{FungibleToken.Receiver}\u003e(\n      /public/dapperUtilityCoinReceiver,\n      target: /storage/dapperUtilityCoinReceiver\n      )\n    }\n}",
               "spec": {
                  "order": [
                     "dapperAddress"
                  ],
                  "parameters": {
                     "dapperAddress": "Address"
                  }
               }
            },
            "adminMainnetAddItem": {
               "code": "import Admin from 0xf8d6e0586b0a20c7\nimport FindMarket from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\n\ntransaction(tenant: Address, ftName: String, ftTypes: [String] , nftName: String, nftTypes: [String], listingName: String, listingTypes: [String]) {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n        \n    }\n    execute{\n\n        let ft : [Type] = []\n        for type in ftTypes {\n            ft.append(CompositeType(type)!)\n        }\n\n        let nft : [Type] = []\n        for type in nftTypes {\n            nft.append(CompositeType(type)!)\n        }\n\n        let listing : [Type] = []\n        for type in listingTypes {\n            listing.append(CompositeType(type)!)\n        }\n\n        let rules : [FindMarket.TenantRule] = []\n        if listing.length \u003e 0 {\n            rules.append(FindMarket.TenantRule(name:listingName, types:listing, ruleType: \"listing\", allow: true))\n        }\n\n        if ft.length \u003e 0 {\n            rules.append(FindMarket.TenantRule(name:ftName, types:ft, ruleType: \"ft\", allow: true))\n        }\n\n        if nft.length \u003e 0 {\n            rules.append(FindMarket.TenantRule(name:nftName, types:nft, ruleType: \"nft\", allow: true))\n        }\n        \n\n        let tenantSaleItem = FindMarket.TenantSaleItem(\n            name: listingName.concat(ftName).concat(nftName), \n            cut: nil, \n            rules: rules, \n            status:\"active\"\n        )\n\n        self.adminRef.setMarketOption(tenant: tenant, saleItem: tenantSaleItem)\n        \n    }\n}",
               "spec": {
                  "order": [
                     "tenant",
                     "ftName",
                     "ftTypes",
                     "nftName",
                     "nftTypes",
                     "listingName",
                     "listingTypes"
                  ],
                  "parameters": {
                     "ftName": "String",
                     "ftTypes": "[String]",
                     "listingName": "String",
                     "listingTypes": "[String]",
                     "nftName": "String",
                     "nftTypes": "[String]",
                     "tenant": "Address"
                  }
               }
            },
            "adminMintCharity": {
               "code": "import NonFungibleToken from 0xf8d6e0586b0a20c7\nimport CharityNFT from 0xf8d6e0586b0a20c7\nimport Admin from 0xf8d6e0586b0a20c7\n\n//mint an art and add it to a users collection\ntransaction(\n    name: String,\n    image: String,\n    thumbnail: String,\n    originUrl: String,\n    description: String,\n    recipient: Address\n) {\n    let receiverCap: Capability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e\n    let client: \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount) {\n        self.client= account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath)!\n        self.receiverCap= getAccount(recipient).getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath)\n    }\n\n    execute {\n        let metadata = {\"name\" : name, \"image\" : image, \"thumbnail\": thumbnail, \"originUrl\": originUrl, \"description\":description}\n        self.client.mintCharity(metadata: metadata, recipient: self.receiverCap)\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "image",
                     "thumbnail",
                     "originUrl",
                     "description",
                     "recipient"
                  ],
                  "parameters": {
                     "description": "String",
                     "image": "String",
                     "name": "String",
                     "originUrl": "String",
                     "recipient": "Address",
                     "thumbnail": "String"
                  }
               }
            },
            "adminMintFindDandy": {
               "code": "import FIND from 0xf8d6e0586b0a20c7\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport Dandy from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FindForge from 0xf8d6e0586b0a20c7\n\ntransaction(name: String, maxEdition:UInt64, nftName:String, nftDescription:String, folderHash:String) {\n    prepare(account: AuthAccount) {\n\n        let finLeases= account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n        let lease=finLeases.borrow(name)\n        let forgeType = Dandy.getForgeType()\n\n        let dandyCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        let thumbNail=MetadataViews.IPFSFile(cid:folderHash, path: \"thumbnail.webp\")\n        let fullsize=MetadataViews.IPFSFile(cid:folderHash, path: \"fullsize.webp\")\n        let mediaFullsize=MetadataViews.Media(file: fullsize, mediaType: \"image/webp\")\n        let mediaThumbnail=MetadataViews.Media(file: thumbNail, mediaType: \"image/webp\")\n\n        let nftReceiver=account.getCapability\u003c\u0026{NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(Dandy.CollectionPublicPath).borrow() ?? panic(\"Cannot borrow reference to Dandy collection.\")\n\n        let traits = MetadataViews.Traits([])\n        traits.addTrait(MetadataViews.Trait(name: \"Creator\", value: \".find\", displayType:\"Author\", rarity:nil))\n\n        let collection=dandyCap.borrow()!\n        var i:UInt64=1\n\n        while i \u003c= maxEdition {\n\n            let editioned= MetadataViews.Edition(name: nil, number:i, max:maxEdition)\n            let set= MetadataViews.Edition(name: \"set\", number:i, max:maxEdition)\n            let editions = MetadataViews.Editions([editioned, set])\n\n            let schemas: [AnyStruct] = [ editions, MetadataViews.Medias([mediaFullsize, mediaThumbnail]), traits ]\n            \n            let mintData = Dandy.DandyInfo(name: nftName, \n                                                description: nftDescription, \n                                                thumbnail: mediaThumbnail, \n                                                schemas: schemas, \n                                                externalUrlPrefix:\"https://find.xyz/\".concat(name).concat(\"/collection/Dandy\"))\n            \n            FindForge.mint(lease: lease, forgeType: forgeType, data: mintData, receiver: nftReceiver)\n        \n            i=i+1\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "maxEdition",
                     "nftName",
                     "nftDescription",
                     "folderHash"
                  ],
                  "parameters": {
                     "folderHash": "String",
                     "maxEdition": "UInt64",
                     "name": "String",
                     "nftDescription": "String",
                     "nftName": "String"
                  }
               }
            },
            "adminRecreateDandy": {
               "code": "import NonFungibleToken from 0xf8d6e0586b0a20c7\nimport Dandy from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\n\ntransaction {\n    prepare(account: AuthAccount) {\n        account.unlink(Dandy.CollectionPrivatePath)\n        account.unlink(Dandy.CollectionPublicPath)\n        destroy \u003c- account.load\u003c@NonFungibleToken.Collection\u003e(from:Dandy.CollectionStoragePath)\n\n        let dandyCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n    }\n}",
               "spec": {
                  "order": [],
                  "parameters": {}
               }
            },
            "adminRegisterName": {
               "code": "import FIND from 0xf8d6e0586b0a20c7\nimport Admin from 0xf8d6e0586b0a20c7\nimport Profile from 0xf8d6e0586b0a20c7\n\ntransaction(names: [String], user: Address) {\n\n    prepare(account: AuthAccount) {\n\n        let userAccount=getAccount(user)\n        let profileCap = userAccount.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        let leaseCollectionCap=userAccount.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        let adminClient=account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath)!\n\n        for name in names {\n            adminClient.register(name: name,  profile: profileCap, leases: leaseCollectionCap)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "names",
                     "user"
                  ],
                  "parameters": {
                     "names": "[String]",
                     "user": "Address"
                  }
               }
            },
            "adminRemoveFTInfoByAlias": {
               "code": "import Admin from 0xf8d6e0586b0a20c7\n\ntransaction(alias: String) {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n        \n    }\n\n    execute{\n\n        self.adminRef.removeFTInfoByAlias(alias)\n\n    }\n}",
               "spec": {
                  "order": [
                     "alias"
                  ],
                  "parameters": {
                     "alias": "String"
                  }
               }
            },
            "adminRemoveFTInfoByTypeIdentifier": {
               "code": "import Admin from 0xf8d6e0586b0a20c7\n\ntransaction(typeIdentifier: String) {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n        \n    }\n\n    execute{\n\n        self.adminRef.removeFTInfoByTypeIdentifier(typeIdentifier) \n       \n    }\n}",
               "spec": {
                  "order": [
                     "typeIdentifier"
                  ],
                  "parameters": {
                     "typeIdentifier": "String"
                  }
               }
            },
            "adminRemoveForge": {
               "code": "import Admin from 0xf8d6e0586b0a20c7\n\ntransaction(type: String) {\n\n    prepare(admin:AuthAccount) {\n\n        let client= admin.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath)!\n\n        client.removeForgeType(CompositeType(type)!)\n\n    }\n\n}",
               "spec": {
                  "order": [
                     "type"
                  ],
                  "parameters": {
                     "type": "String"
                  }
               }
            },
            "adminRemoveNFTCatalog": {
               "code": "import MetadataViews from 0xf8d6e0586b0a20c7\nimport FINDNFTCatalog from 0xf8d6e0586b0a20c7\nimport FINDNFTCatalogAdmin from 0xf8d6e0586b0a20c7\n\ntransaction(\n    collectionIdentifier : String\n) {\n    let adminProxyResource : \u0026FINDNFTCatalogAdmin.Admin\n\n    prepare(acct: AuthAccount) { \n        self.adminProxyResource = acct.borrow\u003c\u0026FINDNFTCatalogAdmin.Admin\u003e(from : FINDNFTCatalogAdmin.AdminStoragePath)!\n    }\n\n    execute {     \n        self.adminProxyResource.removeCatalogEntry(collectionIdentifier : collectionIdentifier)\n    }\n}",
               "spec": {
                  "order": [
                     "collectionIdentifier"
                  ],
                  "parameters": {
                     "collectionIdentifier": "String"
                  }
               }
            },
            "adminRemoveNFTInfoByAlias": {
               "code": "import Admin from 0xf8d6e0586b0a20c7\n\ntransaction(alias: String) {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n        \n    }\n\n    execute{\n\n        self.adminRef.removeNFTInfoByAlias(alias)\n        \n    }\n}",
               "spec": {
                  "order": [
                     "alias"
                  ],
                  "parameters": {
                     "alias": "String"
                  }
               }
            },
            "adminRemoveNFTInfoByTypeIdentifier": {
               "code": "import Admin from 0xf8d6e0586b0a20c7\n\ntransaction(typeIdentifier: String) {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n        \n    }\n\n    execute{\n\n        self.adminRef.removeNFTInfoByTypeIdentifier(typeIdentifier) \n       \n    }\n}",
               "spec": {
                  "order": [
                     "typeIdentifier"
                  ],
                  "parameters": {
                     "typeIdentifier": "String"
                  }
               }
            },
            "adminRemoveProfileBan": {
               "code": "import Profile from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\n\ntransaction(user: String) {\n    prepare(acct: AuthAccount) {\n        let profile =acct.borrow\u003c\u0026Profile.User\u003e(from:Profile.storagePath)!\n        let address =FIND.resolve(user) ?? panic(\"Not a registered name or valid address.\")\n        profile.removeBan(address)\n    }\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "adminSendFUSD": {
               "code": "import FungibleToken from 0xee82856bf20e2aa6\nimport FUSD from 0xf8d6e0586b0a20c7\n\ntransaction(receiver: Address, amount:UFix64) {\n    prepare(acct: AuthAccount) {\n        let receiver = getAccount(receiver).getCapability\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e(/public/fusdReceiver).borrow() ?? panic(\"Cannot borrow FUSD receiver\")\n\n        let sender = acct.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault)\n            ?? panic(\"Cannot borrow FUSD vault from authAcct storage\")\n\n        receiver.deposit(from: \u003c- sender.withdraw(amount:amount))\n    }\n}",
               "spec": {
                  "order": [
                     "receiver",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "receiver": "Address"
                  }
               }
            },
            "adminSetAddonPrice": {
               "code": "import Admin from 0xf8d6e0586b0a20c7\n\ntransaction(addon:String, price:UFix64) {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n        \n    }\n    execute{\n        self.adminRef.setAddonPrice(name: addon, price: price)\n    }\n}",
               "spec": {
                  "order": [
                     "addon",
                     "price"
                  ],
                  "parameters": {
                     "addon": "String",
                     "price": "UFix64"
                  }
               }
            },
            "adminSetFTInfo_duc": {
               "code": "import Admin from 0xf8d6e0586b0a20c7\nimport DapperUtilityCoin from 0xf8d6e0586b0a20c7\n\ntransaction() {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n    }\n\n    execute{\n        let type: Type = Type\u003c@DapperUtilityCoin.Vault\u003e()\n        self.adminRef.setFTInfo(alias: \"DUC\", type: type, tag:[\"dapper utility coin\"] , icon: \"https://assets.website-files.com/5bf4437b68f8b29e67b7ebdc/61a159f8899a41507bc46bcb_feature%20image%20dapper%20post.png\", receiverPath: /public/dapperUtilityCoinReceiver, balancePath: /public/dapperUtilityCoinBalance, vaultPath: /storage/dapperUtilityCoinVault)\n    }\n}",
               "spec": {
                  "order": [],
                  "parameters": {}
               }
            },
            "adminSetFTInfo_flow": {
               "code": "import Admin from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\n\ntransaction() {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n    }\n\n    execute{\n        let type: Type = Type\u003c@FlowToken.Vault\u003e()\n        self.adminRef.setFTInfo(alias: \"Flow\", type: type, tag:[\"utility coin\"] , icon: \"https://static.flowscan.org/mainnet/icons/A.1654653399040a61.FlowToken.png\", receiverPath: /public/flowTokenReceiver, balancePath: /public/flowTokenBalance, vaultPath: /storage/flowTokenVault)\n    }\n}",
               "spec": {
                  "order": [],
                  "parameters": {}
               }
            },
            "adminSetFTInfo_fusd": {
               "code": "import Admin from 0xf8d6e0586b0a20c7\nimport FUSD from 0xf8d6e0586b0a20c7\n\ntransaction() {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n    }\n\n    execute{\n        let type: Type = Type\u003c@FUSD.Vault\u003e()\n        self.adminRef.setFTInfo(alias: \"FUSD\", type: type, tag:[\"stablecoin\"], icon: \"https://static.flowscan.org/mainnet/icons/A.3c5959b568896393.FUSD.png\", receiverPath: /public/fusdReceiver, balancePath: /public/fusdBalance, vaultPath: /storage/fusdVault)\n    }\n}",
               "spec": {
                  "order": [],
                  "parameters": {}
               }
            },
            "adminSetFTInfo_usdc": {
               "code": "import Admin from 0xf8d6e0586b0a20c7\nimport FiatToken from 0xf8d6e0586b0a20c7\n\ntransaction() {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n    }\n\n    execute{\n        let type: Type = Type\u003c@FiatToken.Vault\u003e()\n        self.adminRef.setFTInfo(alias: \"USDC\", type: type, tag:[\"stablecoin\"] , icon: \"https://static.flowscan.org/mainnet/icons/A.b19436aae4d94622.FiatToken.png\", receiverPath: FiatToken.VaultReceiverPubPath, balancePath: FiatToken.VaultBalancePubPath, vaultPath: FiatToken.VaultStoragePath)\n    }\n}",
               "spec": {
                  "order": [],
                  "parameters": {}
               }
            },
            "adminSetFindCut": {
               "code": "import Admin from 0xf8d6e0586b0a20c7\n\ntransaction(tenant: Address, cut: UFix64){\n    prepare(account: AuthAccount){\n        let adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n\n        adminRef.setFindCut(tenant: tenant, saleItemName:\"findRoyalty\", cut: cut, rules: nil, status: \"active\")\n    }\n}",
               "spec": {
                  "order": [
                     "tenant",
                     "cut"
                  ],
                  "parameters": {
                     "cut": "UFix64",
                     "tenant": "Address"
                  }
               }
            },
            "adminSetNFTInfo_Dandy": {
               "code": "import Admin from 0xf8d6e0586b0a20c7\nimport Dandy from 0xf8d6e0586b0a20c7\n\ntransaction() {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n        \n    }\n    execute{\n        let type: Type = Type\u003c@Dandy.NFT\u003e()\n        self.adminRef.setNFTInfo(alias: \"Dandy\", type: type, icon: nil, providerPath: Dandy.CollectionPrivatePath, publicPath: Dandy.CollectionPublicPath, storagePath: Dandy.CollectionStoragePath, allowedFTTypes: nil, address: 0xf8d6e0586b0a20c7, externalFixedUrl: \"find.xyz\")\n\n    }\n}",
               "spec": {
                  "order": [],
                  "parameters": {}
               }
            },
            "adminSetNFTInfo_ExampleNFT": {
               "code": "import Admin from 0xf8d6e0586b0a20c7\nimport ExampleNFT from 0xf8d6e0586b0a20c7\n\ntransaction() {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n        \n    }\n    execute{\n        let type: Type = Type\u003c@ExampleNFT.NFT\u003e()\n        self.adminRef.setNFTInfo(alias: \"ExampleNFT\", type: type, icon: nil, providerPath: ExampleNFT.CollectionPrivatePath, publicPath: ExampleNFT.CollectionPublicPath, storagePath: ExampleNFT.CollectionStoragePath, allowedFTTypes: nil, address: 0xf8d6e0586b0a20c7, externalFixedUrl: \"example.nft\")\n\n    }\n}",
               "spec": {
                  "order": [],
                  "parameters": {}
               }
            },
            "adminSetNFTInfo_FLOAT": {
               "code": "import Admin from 0xf8d6e0586b0a20c7\n\ntransaction() {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n\n    }\n    execute{\n        if let type = CompositeType(\"A.0afe396ebc8eee65.FLOAT.NFT\") { // Testnet Address \n            self.adminRef.setNFTInfo(alias: \"FLOAT\", type: type, icon: \"https://testnet.floats.city/floatlogowebpage.png\", providerPath: /private/FLOATCollectionPublicPath, publicPath: /public/FLOATCollectionPublicPath, storagePath: /storage/FLOATCollectionStoragePath, allowedFTTypes: nil, address: 0x0afe396ebc8eee65, externalFixedUrl: \"testnet.floats.city\")\n            \n        } else if let type = CompositeType(\"A.2d4c3caffbeab845.FLOAT.NFT\") {\n            self.adminRef.setNFTInfo(alias: \"FLOAT\", type: type, icon: \"https://floats.city/floatlogowebpage.png\", providerPath: /private/FLOATCollectionPublicPath, publicPath: /public/FLOATCollectionPublicPath, storagePath: /storage/FLOATCollectionStoragePath, allowedFTTypes: nil, address: 0x2d4c3caffbeab845, externalFixedUrl: \"floats.city\")\n        }\n\n    }\n}",
               "spec": {
                  "order": [],
                  "parameters": {}
               }
            },
            "adminSetNFTInfo_Neo": {
               "code": "import Admin from 0xf8d6e0586b0a20c7\nimport NeoVoucher from 0xd6b39e5b5b367aad\n\ntransaction() {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n        \n    }\n    execute{\n\n        self.adminRef.setNFTInfo(alias: \"NeoVoucher\", type: Type\u003c@NeoVoucher.NFT\u003e(), icon: \"https://test.neocollectibles.xyz/pages/images/neo-collectibles-logo.webp\", providerPath: /private/neoVoucherCollection, publicPath: NeoVoucher.CollectionPublicPath, storagePath: NeoVoucher.CollectionStoragePath, allowedFTTypes: nil, address: 0xd6b39e5b5b367aad, externalFixedUrl: \"test.neocollectibles.xyx\")\n\n    }\n}",
               "spec": {
                  "order": [],
                  "parameters": {}
               }
            },
            "adminSetProfileBan": {
               "code": "import Profile from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\n\ntransaction(user: String) {\n    prepare(acct: AuthAccount) {\n        let profile =acct.borrow\u003c\u0026Profile.User\u003e(from:Profile.storagePath)!\n        let address =FIND.resolve(user) ?? panic(\"Not a registered name or valid address.\")\n        profile.addBan(address)\n    }\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "adminSetSellDUCLeaseRules": {
               "code": "import FindMarket from 0xf8d6e0586b0a20c7\nimport Admin from 0xf8d6e0586b0a20c7\nimport DapperUtilityCoin from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FIND from 0xf8d6e0586b0a20c7\n\ntransaction(tenant: Address) {\n    prepare(account: AuthAccount){\n        let adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n\n        let rules = [\n            FindMarket.TenantRule(name:\"DUC\", types:[Type\u003c@DapperUtilityCoin.Vault\u003e()], ruleType: \"ft\", allow: true),\n            FindMarket.TenantRule(name:\"Lease\", types:[ Type\u003c@FIND.Lease\u003e()], ruleType: \"nft\", allow: true)\n            ]\n\n        let ducExample = FindMarket.TenantSaleItem(name:\"DUCLease\", cut: nil, rules:rules, status: \"active\" )\n\n        adminRef.setMarketOption(tenant: tenant, saleItem: ducExample)\n\n        let cap = getAccount(account.address).getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver)\n        adminRef.addFindCut(tenant: tenant, FindCutName: \"findDapperRoyalty\", rayalty: MetadataViews.Royalty(receiver: cap, cut: 0.02, description: \"find\"), rules: rules, status: \"active\")\n\n    }\n}",
               "spec": {
                  "order": [
                     "tenant"
                  ],
                  "parameters": {
                     "tenant": "Address"
                  }
               }
            },
            "adminSetSellDandyForFUSD": {
               "code": "import FindMarket from 0xf8d6e0586b0a20c7\nimport Admin from 0xf8d6e0586b0a20c7\nimport FUSD from 0xf8d6e0586b0a20c7\nimport Dandy from 0xf8d6e0586b0a20c7\nimport FindMarketSale from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionSoft from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\n\n\ntransaction(tenant: Address, market: String){\n    prepare(account: AuthAccount){\n        let adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n\n        var marketType : [Type] = [Type\u003c@FindMarketSale.SaleItem\u003e()]\n        switch market {\n            case \"AuctionEscrow\" :\n                marketType = [Type\u003c@FindMarketAuctionEscrow.SaleItem\u003e()]\n\n            case \"AuctionSoft\" :\n                marketType = [Type\u003c@FindMarketAuctionSoft.SaleItem\u003e()]\n\n            case \"DirectOfferEscrow\" :\n                marketType = [Type\u003c@FindMarketDirectOfferEscrow.SaleItem\u003e()]\n\n            case \"DirectOfferSoft\" :\n                marketType = [Type\u003c@FindMarketDirectOfferSoft.SaleItem\u003e()]\n\n        }\n\n        let saleItem = FindMarket.TenantSaleItem(name:\"FlowDandy\".concat(market), cut: nil, rules:[\n            FindMarket.TenantRule(name:\"Flow\", types:[Type\u003c@FUSD.Vault\u003e()], ruleType: \"ft\", allow: true),\n            FindMarket.TenantRule(name:\"Dandy\", types:[Type\u003c@Dandy.NFT\u003e()], ruleType: \"nft\", allow: true),\n            FindMarket.TenantRule(name: market, types:marketType, ruleType: \"listing\", allow: true)\n            ], \n            status: \"active\"\n        )\n\n        adminRef.setMarketOption(tenant: tenant, saleItem: saleItem)\n    }\n}",
               "spec": {
                  "order": [
                     "tenant",
                     "market"
                  ],
                  "parameters": {
                     "market": "String",
                     "tenant": "Address"
                  }
               }
            },
            "adminSetSellDandyForFlow": {
               "code": "import FindMarket from 0xf8d6e0586b0a20c7\nimport Admin from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport Dandy from 0xf8d6e0586b0a20c7\nimport FindMarketSale from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionSoft from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\n\n\ntransaction(tenant: Address, market: String){\n    prepare(account: AuthAccount){\n        let adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n\n        var marketType : [Type] = [Type\u003c@FindMarketSale.SaleItem\u003e()]\n        switch market {\n            case \"AuctionEscrow\" :\n                marketType = [Type\u003c@FindMarketAuctionEscrow.SaleItem\u003e()]\n\n            case \"AuctionSoft\" :\n                marketType = [Type\u003c@FindMarketAuctionSoft.SaleItem\u003e()]\n\n            case \"DirectOfferEscrow\" :\n                marketType = [Type\u003c@FindMarketDirectOfferEscrow.SaleItem\u003e()]\n\n            case \"DirectOfferSoft\" :\n                marketType = [Type\u003c@FindMarketDirectOfferSoft.SaleItem\u003e()]\n\n        }\n\n        let saleItem = FindMarket.TenantSaleItem(name:\"FlowDandy\".concat(market), cut: nil, rules:[\n            FindMarket.TenantRule(name:\"Flow\", types:[Type\u003c@FlowToken.Vault\u003e()], ruleType: \"ft\", allow: true),\n            FindMarket.TenantRule(name:\"Dandy\", types:[Type\u003c@Dandy.NFT\u003e()], ruleType: \"nft\", allow: true),\n            FindMarket.TenantRule(name: market, types:marketType, ruleType: \"listing\", allow: true)\n            ], \n            status: \"active\"\n        )\n\n        adminRef.setMarketOption(tenant: tenant, saleItem: saleItem)\n    }\n}",
               "spec": {
                  "order": [
                     "tenant",
                     "market"
                  ],
                  "parameters": {
                     "market": "String",
                     "tenant": "Address"
                  }
               }
            },
            "adminSetSellDandyRules": {
               "code": "import FindMarket from 0xf8d6e0586b0a20c7\nimport Admin from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport FUSD from 0xf8d6e0586b0a20c7\nimport Dandy from 0xf8d6e0586b0a20c7\n\ntransaction(tenant: Address) {\n    prepare(account: AuthAccount){\n        let adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n\n        let fusdDandy = FindMarket.TenantSaleItem(name:\"FUSDDandy\", cut: nil, rules:[\n            FindMarket.TenantRule(name:\"FUSD\", types:[Type\u003c@FUSD.Vault\u003e()], ruleType: \"ft\", allow: true),\n            FindMarket.TenantRule(name:\"Dandy\", types:[ Type\u003c@Dandy.NFT\u003e()], ruleType: \"nft\", allow: true)\n            ], \n            status: \"active\"\n        )\n\n        let flowDandy = FindMarket.TenantSaleItem(name:\"FlowDandy\", cut: nil, rules:[\n            FindMarket.TenantRule(name:\"Flow\", types:[Type\u003c@FlowToken.Vault\u003e()], ruleType: \"ft\", allow: true),\n            FindMarket.TenantRule(name:\"Dandy\", types:[ Type\u003c@Dandy.NFT\u003e()], ruleType: \"nft\", allow: true)\n            ], \n            status: \"active\"\n        )\n\n        adminRef.setMarketOption(tenant: tenant, saleItem: fusdDandy)\n        adminRef.setMarketOption(tenant: tenant, saleItem: flowDandy)\n\n    }\n}",
               "spec": {
                  "order": [
                     "tenant"
                  ],
                  "parameters": {
                     "tenant": "Address"
                  }
               }
            },
            "adminSetSellExampleNFTForFlow": {
               "code": "import FindMarket from 0xf8d6e0586b0a20c7\nimport Admin from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport FUSD from 0xf8d6e0586b0a20c7\nimport ExampleNFT from 0xf8d6e0586b0a20c7\n\ntransaction(tenant: Address) {\n    prepare(account: AuthAccount){\n        let adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n\n        let flowExample = FindMarket.TenantSaleItem(name:\"FlowExampleNFT\", cut: nil, rules:[\n            FindMarket.TenantRule(name:\"Flow\", types:[Type\u003c@FlowToken.Vault\u003e()], ruleType: \"ft\", allow: true),\n            FindMarket.TenantRule(name:\"ExampleNFT\", types:[ Type\u003c@ExampleNFT.NFT\u003e()], ruleType: \"nft\", allow: true)\n            ], \n            status: \"active\"\n        )\n\n        adminRef.setMarketOption(tenant: tenant, saleItem: flowExample)\n\n    }\n}",
               "spec": {
                  "order": [
                     "tenant"
                  ],
                  "parameters": {
                     "tenant": "Address"
                  }
               }
            },
            "adminSetSellExampleNFTRules": {
               "code": "import FindMarket from 0xf8d6e0586b0a20c7\nimport Admin from 0xf8d6e0586b0a20c7\nimport DapperUtilityCoin from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport ExampleNFT from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\n\ntransaction(tenant: Address) {\n    prepare(account: AuthAccount){\n        let adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n\n        let rules = [\n            FindMarket.TenantRule(name:\"DUC\", types:[Type\u003c@DapperUtilityCoin.Vault\u003e()], ruleType: \"ft\", allow: true),\n            FindMarket.TenantRule(name:\"ExampleNFT\", types:[ Type\u003c@ExampleNFT.NFT\u003e()], ruleType: \"nft\", allow: true)\n            ]\n\n        let ducExample = FindMarket.TenantSaleItem(name:\"DUCExampleNFT\", cut: nil, rules:rules, status: \"active\" )\n\n        adminRef.setMarketOption(tenant: tenant, saleItem: ducExample)\n\n        let exampleNFTRules = [\n            FindMarket.TenantRule(name:\"Flow\", types:[Type\u003c@FlowToken.Vault\u003e()], ruleType: \"ft\", allow: true),\n            FindMarket.TenantRule(name:\"ExampleNFT\", types:[ Type\u003c@ExampleNFT.NFT\u003e()], ruleType: \"nft\", allow: true)\n            ]\n\n        let flowExample = FindMarket.TenantSaleItem(name:\"FlowExampleNFT\", cut: nil, rules:exampleNFTRules, status: \"active\" )\n\n        adminRef.setMarketOption(tenant: tenant, saleItem: flowExample)\n\n        let cap = getAccount(account.address).getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver)\n        adminRef.addFindCut(tenant: tenant, FindCutName: \"findDapperRoyalty\", rayalty: MetadataViews.Royalty(receiver: cap, cut: 0.02, description: \"find\"), rules: rules, status: \"active\")\n\n    }\n}",
               "spec": {
                  "order": [
                     "tenant"
                  ],
                  "parameters": {
                     "tenant": "Address"
                  }
               }
            },
            "adminSetSellLeaseForFlow": {
               "code": "import FindMarket from 0xf8d6e0586b0a20c7\nimport Admin from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport FIND from 0xf8d6e0586b0a20c7\nimport FindLeaseMarketSale from 0xf8d6e0586b0a20c7\nimport FindLeaseMarketAuctionSoft from 0xf8d6e0586b0a20c7\nimport FindLeaseMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\n\ntransaction(tenant: Address, market: String){\n    prepare(account: AuthAccount){\n        let adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n\n        var marketType : [Type] = [Type\u003c@FindLeaseMarketSale.SaleItem\u003e()]\n        switch market {\n            // case \"AuctionEscrow\" :\n            //     marketType = [Type\u003c@FindLeaseMarketAuctionEscrow.SaleItem\u003e()]\n\n            case \"AuctionSoft\" :\n                marketType = [Type\u003c@FindLeaseMarketAuctionSoft.SaleItem\u003e()]\n\n            // case \"DirectOfferEscrow\" :\n            //     marketType = [Type\u003c@FindLeaseMarketDirectOfferEscrow.SaleItem\u003e()]\n\n            case \"DirectOfferSoft\" :\n                marketType = [Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItem\u003e()]\n\n        }\n\n        let saleItem = FindMarket.TenantSaleItem(name:\"FlowLease\".concat(market), cut: nil, rules:[\n            FindMarket.TenantRule(name:\"Flow\", types:[Type\u003c@FlowToken.Vault\u003e()], ruleType: \"ft\", allow: true),\n            FindMarket.TenantRule(name:\"Lease\", types:[Type\u003c@FIND.Lease\u003e()], ruleType: \"nft\", allow: true),\n            FindMarket.TenantRule(name: market, types:marketType, ruleType: \"listing\", allow: true)\n            ], \n            status: \"active\"\n        )\n\n        adminRef.setMarketOption(tenant: tenant, saleItem: saleItem)\n    }\n}",
               "spec": {
                  "order": [
                     "tenant",
                     "market"
                  ],
                  "parameters": {
                     "market": "String",
                     "tenant": "Address"
                  }
               }
            },
            "adminTestnetAddBeam": {
               "code": "import Admin from 0xf8d6e0586b0a20c7\n// import Beam from 0x6085ae87e78e1433\nimport FindMarket from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\n\ntransaction(tenant:Address) {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n        \n    }\n    execute{\n        let nftType = CompositeType(\"A.6085ae87e78e1433.Beam.NFT\")!\n        self.adminRef.setNFTInfo(alias: \"Beam\", type: nftType, icon: \"https://frightclub.niftory.com/fc_black_logo_round.svg\", providerPath: /private/BeamCollection001, publicPath: /public/BeamCollection001, storagePath: /storage/BeamCollection001, allowedFTTypes: nil, address: 0x6085ae87e78e1433, externalFixedUrl: \"frightclub.niftory.com\")\n\n        let rules = [\n            FindMarket.TenantRule(name:\"Flow\", types:[Type\u003c@FlowToken.Vault\u003e()], ruleType: \"ft\", allow: true),\n            FindMarket.TenantRule(name:\"Beam\", types:[nftType], ruleType: \"nft\", allow: true)\n        ]\n\n        let tenantSaleItem = FindMarket.TenantSaleItem(\n            name: \"FlowBeam\", \n            cut: nil, \n            rules: rules, \n            status:\"active\"\n        )\n\n        self.adminRef.setMarketOption(tenant: tenant, saleItem: tenantSaleItem)\n \n    }\n}",
               "spec": {
                  "order": [
                     "tenant"
                  ],
                  "parameters": {
                     "tenant": "Address"
                  }
               }
            },
            "adminTestnetAddBl0x": {
               "code": "import Admin from 0xf8d6e0586b0a20c7\nimport Bl0x from 0xe8124d8428980aa6\nimport FindMarket from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\n\ntransaction(tenant: Address) {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n        \n    }\n    execute{\n        self.adminRef.setNFTInfo(\n            alias: \"Bl0x\", \n            type: Type\u003c@Bl0x.NFT\u003e(), \n            icon: \"https://global-uploads.webflow.com/60f008ba9757da0940af288e/626e4af22f80f09e2783df44_blox.jpg\", \n            providerPath: Bl0x.CollectionPrivatePath, \n            publicPath: Bl0x.CollectionPublicPath, \n            storagePath: Bl0x.CollectionStoragePath, \n            allowedFTTypes: nil, \n            address:0xe8124d8428980aa6, externalFixedUrl: \"bl0x-5ccsb92pb-findonflow.vercel.app\")\n\n        let rules = [\n            FindMarket.TenantRule(name:\"Flow\", types:[Type\u003c@FlowToken.Vault\u003e()], ruleType: \"ft\", allow: true),\n            FindMarket.TenantRule(name:\"Bl0x\", types:[Type\u003c@Bl0x.NFT\u003e()], ruleType: \"nft\", allow: true)\n        ]\n\n        let tenantSaleItem = FindMarket.TenantSaleItem(\n            name: \"FlowBl0x\", \n            cut: nil, \n            rules: rules, \n            status:\"active\"\n        )\n\n        self.adminRef.setMarketOption(tenant: tenant, saleItem: tenantSaleItem)\n        \n    }\n}",
               "spec": {
                  "order": [
                     "tenant"
                  ],
                  "parameters": {
                     "tenant": "Address"
                  }
               }
            },
            "adminTestnetAddFlovatar": {
               "code": "import Admin from 0xf8d6e0586b0a20c7\nimport Flovatar from 0x9392a4a7c3f49a0b\nimport FindMarket from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\n\ntransaction(tenant:Address) {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n        \n    }\n    execute{\n\n        self.adminRef.setNFTInfo(alias: \"Flovatar\", type: Type\u003c@Flovatar.NFT\u003e(), icon: \"https://styles.redditmedia.com/t5_5ikf79/styles/communityIcon_fraplt3tgk681.jpg\", providerPath: /private/FlovatarCollection, publicPath: Flovatar.CollectionPublicPath, storagePath: Flovatar.CollectionStoragePath, allowedFTTypes: nil, address: 0x9392a4a7c3f49a0b, externalFixedUrl: \"flovatar.com\")\n\n        let rules = [\n            FindMarket.TenantRule(name:\"Flow\", types:[Type\u003c@FlowToken.Vault\u003e()], ruleType: \"ft\", allow: true),\n            FindMarket.TenantRule(name:\"Flovatar\", types:[Type\u003c@Flovatar.NFT\u003e()], ruleType: \"nft\", allow: true)\n        ]\n\n        let tenantSaleItem = FindMarket.TenantSaleItem(\n            name: \"FlowFLovatar\", \n            cut: nil, \n            rules: rules, \n            status:\"active\"\n        )\n\n        self.adminRef.setMarketOption(tenant: tenant, saleItem: tenantSaleItem)\n \n    }\n}",
               "spec": {
                  "order": [
                     "tenant"
                  ],
                  "parameters": {
                     "tenant": "Address"
                  }
               }
            },
            "adminTestnetAddVersus": {
               "code": "import Admin from 0xf8d6e0586b0a20c7\nimport Art from 0x99ca04281098b33d\nimport FindMarket from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\n\ntransaction(tenant: Address) {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n        \n    }\n    execute{\n        self.adminRef.setNFTInfo(\n            alias: \"Versus\", \n            type: Type\u003c@Art.NFT\u003e(), \n            icon: \"https://global-uploads.webflow.com/60f008ba9757da0940af288e/60f02cad72175a774926125f_flow%20versus%20twitter%20lgoo.jpg\",\n            providerPath: /private/versusArtCollection,\n            publicPath: Art.CollectionPublicPath, \n            storagePath: Art.CollectionStoragePath, \n            allowedFTTypes: nil, \n                        address:0x99ca04281098b33d, externalFixedUrl: \"https://versus.auction\")\n\n        let rules = [\n            FindMarket.TenantRule(name:\"Flow\", types:[Type\u003c@FlowToken.Vault\u003e()], ruleType: \"ft\", allow: true),\n            FindMarket.TenantRule(name:\"Versus\", types:[Type\u003c@Art.NFT\u003e()], ruleType: \"nft\", allow: true)\n        ]\n\n        let tenantSaleItem = FindMarket.TenantSaleItem(\n            name: \"FlowVersus\", \n            cut: nil, \n            rules: rules, \n            status:\"active\"\n        )\n\n        self.adminRef.setMarketOption(tenant: tenant, saleItem: tenantSaleItem)\n    }\n}",
               "spec": {
                  "order": [
                     "tenant"
                  ],
                  "parameters": {
                     "tenant": "Address"
                  }
               }
            },
            "adminTransferAllFusd": {
               "code": "// Mainnet\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FUSD from 0xf8d6e0586b0a20c7\n\n// Testnet\n// import FungibleToken from 0x9a0766d93b6608b7\n// import FUSD from 0xe223d8a629e49c68\n\ntransaction(recipient: Address) {\n\n  // The Vault resource that holds the tokens that are being transfered\n  let sentVault: @FungibleToken.Vault\n\n  prepare(signer: AuthAccount) {\n    // Get a reference to the signer's stored vault\n    let vaultRef = signer.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault)\n      ?? panic(\"Could not borrow reference to the owner's Vault!\")\n\n    // Withdraw tokens from the signer's stored vault\n    self.sentVault \u003c- vaultRef.withdraw(amount: vaultRef.balance)\n  }\n\n  execute {\n    // Get the recipient's public account object\n    let recipientAccount = getAccount(recipient)\n\n    // Get a reference to the recipient's Receiver\n    let receiverRef = recipientAccount.getCapability(/public/fusdReceiver)!\n      .borrow\u003c\u0026{FungibleToken.Receiver}\u003e()\n      ?? panic(\"Could not borrow receiver reference to the recipient's Vault\")\n\n    // Deposit the withdrawn tokens in the recipient's receiver\n    receiverRef.deposit(from: \u003c-self.sentVault)\n  }\n}",
               "spec": {
                  "order": [
                     "recipient"
                  ],
                  "parameters": {
                     "recipient": "Address"
                  }
               }
            },
            "alterMarketOption": {
               "code": "import FindMarket from 0xf8d6e0586b0a20c7\n\ntransaction(marketRule: String , action: String ){\n    prepare(account: AuthAccount){\n        let path = FindMarket.TenantClientStoragePath\n        let tenantRef = account.borrow\u003c\u0026FindMarket.TenantClient\u003e(from: path) ?? panic(\"Cannot borrow Reference.\")\n\n\n        switch action {\n            case \"enable\" :\n                tenantRef.enableMarketOption(marketRule)\n\n            case \"deprecate\" :\n                tenantRef.deprecateMarketOption(marketRule)\n\n            case \"stop\" :\n                tenantRef.stopMarketOption(marketRule)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "marketRule",
                     "action"
                  ],
                  "parameters": {
                     "action": "String",
                     "marketRule": "String"
                  }
               }
            },
            "bidLeaseMarketAuctionSoft": {
               "code": "import FindMarketSale from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionSoft from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FindViews from 0xf8d6e0586b0a20c7\nimport FTRegistry from 0xf8d6e0586b0a20c7\nimport FindMarket from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\nimport FUSD from 0xf8d6e0586b0a20c7\nimport FiatToken from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport Dandy from 0xf8d6e0586b0a20c7\nimport Profile from 0xf8d6e0586b0a20c7\nimport FindLeaseMarketSale from 0xf8d6e0586b0a20c7\nimport FindLeaseMarketAuctionSoft from 0xf8d6e0586b0a20c7\n// import FindLeaseMarketAuctionEscrow from \"../contracts/FindLeaseMarketAuctionEscrow.cdc\"\nimport FindLeaseMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\n// import FindLeaseMarketDirectOfferEscrow from \"../contracts/FindLeaseMarketDirectOfferEscrow.cdc\"\nimport FindLeaseMarket from 0xf8d6e0586b0a20c7\n\ntransaction(leaseName: String, amount: UFix64) {\n\n    let saleItemsCap: Capability\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic}\u003e \n    let walletReference : \u0026FungibleToken.Vault\n    let bidsReference: \u0026FindLeaseMarketAuctionSoft.MarketBidCollection?\n    let balanceBeforeBid: UFix64\n    let ftVaultType: Type\n\n    prepare(account: AuthAccount) {\n\n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n        //SYNC with register\n        //Add exising FUSD or create a new one and add it\n        let name = account.address.toString()\n        let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n        if !fusdReceiver.check() {\n            let fusd \u003c- FUSD.createEmptyVault()\n            account.save(\u003c- fusd, to: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n        }\n\n        let usdcCap = account.getCapability\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e(FiatToken.VaultReceiverPubPath)\n        if !usdcCap.check() {\n                account.save( \u003c-FiatToken.createEmptyVault(), to: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e( FiatToken.VaultReceiverPubPath, target: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FiatToken.ResourceId}\u003e( FiatToken.VaultUUIDPubPath, target: FiatToken.VaultStoragePath)\n                account.link\u003c\u0026FiatToken.Vault{FungibleToken.Balance}\u003e( FiatToken.VaultBalancePubPath, target:FiatToken.VaultStoragePath)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let dandyCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        let dandyCapPrivate= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPrivatePath)\n        if !dandyCapPrivate.check() {\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        var created=false\n        var updated=false\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        if !profile.hasWallet(\"Flow\") {\n            let flowWallet=Profile.Wallet( name:\"Flow\", receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), tags: [\"flow\"])\n    \n            profile.addWallet(flowWallet)\n            updated=true\n        }\n        if !profile.hasWallet(\"FUSD\") {\n            profile.addWallet(Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), tags: [\"fusd\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if !profile.hasWallet(\"USDC\") {\n            profile.addWallet(Profile.Wallet( name:\"USDC\", receiver:usdcCap, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(FiatToken.VaultBalancePubPath), accept: Type\u003c@FiatToken.Vault\u003e(), tags: [\"usdc\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else if updated {\n            profile.emitUpdatedEvent()\n        }\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        let doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        let doeSalePublicPath=FindMarket.getPublicPath(doeSaleType, name: tenant.name)\n        let doeSaleStoragePath= FindMarket.getStoragePath(doeSaleType, name:tenant.name)\n        let doeSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n        if !doeSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n        }\n\n        let doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        let doeBidPublicPath=FindMarket.getPublicPath(doeBidType, name: tenant.name)\n        let doeBidStoragePath= FindMarket.getStoragePath(doeBidType, name:tenant.name)\n        let doeBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n        if !doeBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n        }\n\n        /// auctions that escrow ft\n        let aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        let aeSalePublicPath=FindMarket.getPublicPath(aeSaleType, name: tenant.name)\n        let aeSaleStoragePath= FindMarket.getStoragePath(aeSaleType, name:tenant.name)\n        let aeSaleCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n        if !aeSaleCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n        }\n\n        let dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\n        let dosSalePublicPath=FindMarket.getPublicPath(dosSaleType, name: tenant.name)\n        let dosSaleStoragePath= FindMarket.getStoragePath(dosSaleType, name:tenant.name)\n\n        let dosSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n        if !dosSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n        }\n\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n        if !dosBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n        }\n\n        let aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\n        let aeBidPublicPath=FindMarket.getPublicPath(aeBidType, name: tenant.name)\n        let aeBidStoragePath= FindMarket.getStoragePath(aeBidType, name:tenant.name)\n        let aeBidCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n        if !aeBidCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n        }\n\n     /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n        }\n\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n        if !asBidCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n        }\n\n        let leaseTenantCapability= FindMarket.getTenantCapability(FindMarket.getTenantAddress(\"findLease\")!)!\n\n        let leaseSaleItemType= Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()\n        let leasePublicPath=FindMarket.getPublicPath(leaseSaleItemType, name: \"findLease\")\n        let leaseStoragePath= FindMarket.getStoragePath(leaseSaleItemType, name:\"findLease\")\n        let leaseSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath) \n        if !leaseSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketSale.SaleItemCollection\u003e(\u003c- FindLeaseMarketSale.createEmptySaleItemCollection(leaseTenantCapability), to: leaseStoragePath)\n            account.link\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath, target: leaseStoragePath)\n        }\n\n        let leaseASSaleItemType= Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e()\n        let leaseASPublicPath=FindMarket.getPublicPath(leaseASSaleItemType, name: \"findLease\")\n        let leaseASStoragePath= FindMarket.getStoragePath(leaseASSaleItemType, name:\"findLease\")\n        let leaseASSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath) \n        if !leaseASSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseASStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath, target: leaseASStoragePath)\n        }\n\n\n        let leaseASBidType= Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e()\n        let leaseASBidPublicPath=FindMarket.getPublicPath(leaseASBidType, name: \"findLease\")\n        let leaseASBidStoragePath= FindMarket.getStoragePath(leaseASBidType, name: \"findLease\")\n        let leaseASBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath) \n        if !leaseASBidCap.check() {\n            account.save\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseASBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath, target: leaseASBidStoragePath)\n        }\n\n        // let leaseAESaleItemType= Type\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e()\n        // let leaseAEPublicPath=FindMarket.getPublicPath(leaseAESaleItemType, name: \"findLease\")\n        // let leaseAEStoragePath= FindMarket.getStoragePath(leaseAESaleItemType, name:\"findLease\")\n        // let leaseAESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath) \n        // if !leaseAESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseAEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath, target: leaseAEStoragePath)\n        // }\n\n        // let leaseAEBidType= Type\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e()\n        // let leaseAEBidPublicPath=FindMarket.getPublicPath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidStoragePath= FindMarket.getStoragePath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath) \n        // if !leaseAEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseAEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath, target: leaseAEBidStoragePath)\n        // }\n\n        let leaseDOSSaleItemType= Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e()\n        let leaseDOSPublicPath=FindMarket.getPublicPath(leaseDOSSaleItemType, name: \"findLease\")\n        let leaseDOSStoragePath= FindMarket.getStoragePath(leaseDOSSaleItemType, name:\"findLease\")\n        let leaseDOSSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath) \n        if !leaseDOSSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOSStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath, target: leaseDOSStoragePath)\n        }\n\n        let leaseDOSBidType= Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let leaseDOSBidPublicPath=FindMarket.getPublicPath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidStoragePath= FindMarket.getStoragePath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath) \n        if !leaseDOSBidCap.check() {\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOSBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath, target: leaseDOSBidStoragePath)\n        }\n\n        // let leaseDOESaleItemType= Type\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        // let leaseDOEPublicPath=FindMarket.getPublicPath(leaseDOESaleItemType, name: \"findLease\")\n        // let leaseDOEStoragePath= FindMarket.getStoragePath(leaseDOESaleItemType, name:\"findLease\")\n        // let leaseDOESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath) \n        // if !leaseDOESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath, target: leaseDOEStoragePath)\n        // }\n\n        // let leaseDOEBidType= Type\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        // let leaseDOEBidPublicPath=FindMarket.getPublicPath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidStoragePath= FindMarket.getStoragePath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath) \n        // if !leaseDOEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath, target: leaseDOEBidStoragePath)\n        // }\n        //SYNC with register\n\n        let resolveAddress = FIND.resolve(leaseName)\n        if resolveAddress == nil {panic(\"The address input is not a valid name nor address. Input : \".concat(leaseName))}\n        let address = resolveAddress!\n\n        let leaseMarketplace = FindMarket.getTenantAddress(\"findLease\")!\n        let leaseTenant = leaseTenantCapability.borrow()!\n        self.saleItemsCap= FindLeaseMarketAuctionSoft.getSaleItemCapability(marketplace:leaseMarketplace, user:address) ?? panic(\"cannot find sale item cap\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e())\n\n        let item = FindLeaseMarket.assertOperationValid(tenant: leaseMarketplace, name: leaseName, marketOption: marketOption)\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n        \n        self.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account. Account address : \".concat(account.address.toString()))\n        self.ftVaultType = ft.type\n\n        let bidStoragePath=leaseTenant.getStoragePath(Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e())\n\n        self.bidsReference= account.borrow\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(from: bidStoragePath)\n        self.balanceBeforeBid=self.walletReference.balance\n    }\n\n    pre {\n        self.bidsReference != nil : \"This account does not have a bid collection\"\n        self.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n    }\n\n    execute {\n        self.bidsReference!.bid(name:leaseName, amount: amount, vaultType: self.ftVaultType, bidExtraField: {})\n    }\n}",
               "spec": {
                  "order": [
                     "leaseName",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "leaseName": "String"
                  }
               }
            },
            "bidLeaseMarketAuctionSoftDUC": {
               "code": "import FindMarketSale from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionSoft from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FindViews from 0xf8d6e0586b0a20c7\nimport FTRegistry from 0xf8d6e0586b0a20c7\nimport FindMarket from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\nimport TokenForwarding from 0xf8d6e0586b0a20c7\nimport DapperUtilityCoin from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport Dandy from 0xf8d6e0586b0a20c7\nimport Profile from 0xf8d6e0586b0a20c7\nimport FindLeaseMarketSale from 0xf8d6e0586b0a20c7\nimport FindLeaseMarketAuctionSoft from 0xf8d6e0586b0a20c7\n// import FindLeaseMarketAuctionEscrow from \"../contracts/FindLeaseMarketAuctionEscrow.cdc\"\nimport FindLeaseMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\n// import FindLeaseMarketDirectOfferEscrow from \"../contracts/FindLeaseMarketDirectOfferEscrow.cdc\"\nimport FindLeaseMarket from 0xf8d6e0586b0a20c7\n\ntransaction(dapperAddress: Address, leaseName: String, amount: UFix64) {\n\n    let saleItemsCap: Capability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic}\u003e \n    let bidsReference: \u0026FindLeaseMarketAuctionSoft.MarketBidCollection?\n    let ftVaultType: Type\n\n    prepare(account: AuthAccount) {\n\n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n        //SYNC with register\n        //Add exising FUSD or create a new one and add it\n        let name = account.address.toString()\n        let ducReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver)\n        if !ducReceiver.check() {\n            let dapper = getAccount(dapperAddress)\n            // Create a new Forwarder resource for DUC and store it in the new account's storage\n            let ducForwarder \u003c- TokenForwarding.createNewForwarder(recipient: dapper.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver))\n            account.save(\u003c-ducForwarder, to: /storage/dapperUtilityCoinReceiver)\n            // Publish a Receiver capability for the new account, which is linked to the DUC Forwarder\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver,target: /storage/dapperUtilityCoinReceiver)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: ducReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let dandyCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        let dandyCapPrivate= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPrivatePath)\n        if !dandyCapPrivate.check() {\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        var created=false\n        var updated=false\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        if !profile.hasWallet(\"Flow\") {\n            let flowWallet=Profile.Wallet( name:\"Flow\", receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), tags: [\"flow\"])\n    \n            profile.addWallet(flowWallet)\n            updated=true\n        }\n        if !profile.hasWallet(\"DUC\") {\n            profile.addWallet(Profile.Wallet( name:\"DUC\", receiver:ducReceiver, balance:getAccount(dapperAddress).getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/dapperUtilityCoinBalance), accept: Type\u003c@DapperUtilityCoin.Vault\u003e(), tags: [\"duc\", \"dapperUtilityCoin\",\"dapper\"]))\n            updated=true\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else {\n            profile.emitUpdatedEvent()\n        }\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        let doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        let doeSalePublicPath=FindMarket.getPublicPath(doeSaleType, name: tenant.name)\n        let doeSaleStoragePath= FindMarket.getStoragePath(doeSaleType, name:tenant.name)\n        let doeSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n        if !doeSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n        }\n\n        let doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        let doeBidPublicPath=FindMarket.getPublicPath(doeBidType, name: tenant.name)\n        let doeBidStoragePath= FindMarket.getStoragePath(doeBidType, name:tenant.name)\n        let doeBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n        if !doeBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n        }\n\n        /// auctions that escrow ft\n        let aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        let aeSalePublicPath=FindMarket.getPublicPath(aeSaleType, name: tenant.name)\n        let aeSaleStoragePath= FindMarket.getStoragePath(aeSaleType, name:tenant.name)\n        let aeSaleCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n        if !aeSaleCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n        }\n\n        let dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\n        let dosSalePublicPath=FindMarket.getPublicPath(dosSaleType, name: tenant.name)\n        let dosSaleStoragePath= FindMarket.getStoragePath(dosSaleType, name:tenant.name)\n\n        let dosSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n        if !dosSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n        }\n\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n        if !dosBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n        }\n\n        let aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\n        let aeBidPublicPath=FindMarket.getPublicPath(aeBidType, name: tenant.name)\n        let aeBidStoragePath= FindMarket.getStoragePath(aeBidType, name:tenant.name)\n        let aeBidCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n        if !aeBidCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n        }\n\n     /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n        }\n\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n        if !asBidCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n        }\n\n        let leaseTenantCapability= FindMarket.getTenantCapability(FindMarket.getTenantAddress(\"findLease\")!)!\n\n        let leaseSaleItemType= Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()\n        let leasePublicPath=FindMarket.getPublicPath(leaseSaleItemType, name: \"findLease\")\n        let leaseStoragePath= FindMarket.getStoragePath(leaseSaleItemType, name:\"findLease\")\n        let leaseSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath) \n        if !leaseSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketSale.SaleItemCollection\u003e(\u003c- FindLeaseMarketSale.createEmptySaleItemCollection(leaseTenantCapability), to: leaseStoragePath)\n            account.link\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath, target: leaseStoragePath)\n        }\n\n        let leaseASSaleItemType= Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e()\n        let leaseASPublicPath=FindMarket.getPublicPath(leaseASSaleItemType, name: \"findLease\")\n        let leaseASStoragePath= FindMarket.getStoragePath(leaseASSaleItemType, name:\"findLease\")\n        let leaseASSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath) \n        if !leaseASSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseASStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath, target: leaseASStoragePath)\n        }\n\n\n        let leaseASBidType= Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e()\n        let leaseASBidPublicPath=FindMarket.getPublicPath(leaseASBidType, name: \"findLease\")\n        let leaseASBidStoragePath= FindMarket.getStoragePath(leaseASBidType, name: \"findLease\")\n        let leaseASBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath) \n        if !leaseASBidCap.check() {\n            account.save\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseASBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath, target: leaseASBidStoragePath)\n        }\n\n        // let leaseAESaleItemType= Type\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e()\n        // let leaseAEPublicPath=FindMarket.getPublicPath(leaseAESaleItemType, name: \"findLease\")\n        // let leaseAEStoragePath= FindMarket.getStoragePath(leaseAESaleItemType, name:\"findLease\")\n        // let leaseAESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath) \n        // if !leaseAESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseAEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath, target: leaseAEStoragePath)\n        // }\n\n        // let leaseAEBidType= Type\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e()\n        // let leaseAEBidPublicPath=FindMarket.getPublicPath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidStoragePath= FindMarket.getStoragePath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath) \n        // if !leaseAEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseAEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath, target: leaseAEBidStoragePath)\n        // }\n\n        let leaseDOSSaleItemType= Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e()\n        let leaseDOSPublicPath=FindMarket.getPublicPath(leaseDOSSaleItemType, name: \"findLease\")\n        let leaseDOSStoragePath= FindMarket.getStoragePath(leaseDOSSaleItemType, name:\"findLease\")\n        let leaseDOSSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath) \n        if !leaseDOSSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOSStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath, target: leaseDOSStoragePath)\n        }\n\n        let leaseDOSBidType= Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let leaseDOSBidPublicPath=FindMarket.getPublicPath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidStoragePath= FindMarket.getStoragePath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath) \n        if !leaseDOSBidCap.check() {\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOSBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath, target: leaseDOSBidStoragePath)\n        }\n\n        // let leaseDOESaleItemType= Type\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        // let leaseDOEPublicPath=FindMarket.getPublicPath(leaseDOESaleItemType, name: \"findLease\")\n        // let leaseDOEStoragePath= FindMarket.getStoragePath(leaseDOESaleItemType, name:\"findLease\")\n        // let leaseDOESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath) \n        // if !leaseDOESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath, target: leaseDOEStoragePath)\n        // }\n\n        // let leaseDOEBidType= Type\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        // let leaseDOEBidPublicPath=FindMarket.getPublicPath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidStoragePath= FindMarket.getStoragePath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath) \n        // if !leaseDOEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath, target: leaseDOEBidStoragePath)\n        // }\n        //SYNC with register\n\n        let resolveAddress = FIND.resolve(leaseName)\n        if resolveAddress == nil {panic(\"The address input is not a valid name nor address. Input : \".concat(leaseName))}\n        let address = resolveAddress!\n\n        let leaseMarketplace = FindMarket.getTenantAddress(\"findLease\")!\n        let leaseTenant = leaseTenantCapability.borrow()!\n\n        self.saleItemsCap= FindMarketAuctionSoft.getSaleItemCapability(marketplace:leaseMarketplace, user:address) ?? panic(\"cannot find sale item cap\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e())\n\n        let item = FindLeaseMarket.assertOperationValid(tenant: leaseMarketplace, name: leaseName, marketOption: marketOption)\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n        \n        self.ftVaultType = ft.type\n\n        let bidStoragePath=leaseTenant.getStoragePath(Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e())\n\n        self.bidsReference= account.borrow\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(from: bidStoragePath)\n    }\n\n    pre {\n        self.bidsReference != nil : \"This account does not have a bid collection\"\n    }\n\n    execute {\n        self.bidsReference!.bid(name:leaseName, amount: amount, vaultType: self.ftVaultType, bidExtraField: {})\n    }\n}",
               "spec": {
                  "order": [
                     "dapperAddress",
                     "leaseName",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "dapperAddress": "Address",
                     "leaseName": "String"
                  }
               }
            },
            "bidLeaseMarketDirectOfferSoft": {
               "code": "import FindMarketSale from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionSoft from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\nimport FindMarket from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FindViews from 0xf8d6e0586b0a20c7\nimport FTRegistry from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\nimport FUSD from 0xf8d6e0586b0a20c7\nimport FiatToken from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport Dandy from 0xf8d6e0586b0a20c7\nimport Profile from 0xf8d6e0586b0a20c7\nimport FindLeaseMarketSale from 0xf8d6e0586b0a20c7\nimport FindLeaseMarketAuctionSoft from 0xf8d6e0586b0a20c7\n// import FindLeaseMarketAuctionEscrow from \"../contracts/FindLeaseMarketAuctionEscrow.cdc\"\nimport FindLeaseMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\n// import FindLeaseMarketDirectOfferEscrow from \"../contracts/FindLeaseMarketDirectOfferEscrow.cdc\"\nimport FindLeaseMarket from 0xf8d6e0586b0a20c7\n\ntransaction(leaseName: String, ftAliasOrIdentifier:String, amount: UFix64, validUntil: UFix64?) {\n\n    let bidsReference: \u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection?\n    let ftVaultType: Type\n\n    prepare(account: AuthAccount) {\n        \n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n        //SYNC with register\n        //Add exising FUSD or create a new one and add it\n        let name = account.address.toString()\n        let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n        if !fusdReceiver.check() {\n            let fusd \u003c- FUSD.createEmptyVault()\n            account.save(\u003c- fusd, to: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n        }\n\n        let usdcCap = account.getCapability\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e(FiatToken.VaultReceiverPubPath)\n        if !usdcCap.check() {\n                account.save( \u003c-FiatToken.createEmptyVault(), to: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e( FiatToken.VaultReceiverPubPath, target: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FiatToken.ResourceId}\u003e( FiatToken.VaultUUIDPubPath, target: FiatToken.VaultStoragePath)\n                account.link\u003c\u0026FiatToken.Vault{FungibleToken.Balance}\u003e( FiatToken.VaultBalancePubPath, target:FiatToken.VaultStoragePath)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let dandyCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        let dandyCapPrivate= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPrivatePath)\n        if !dandyCapPrivate.check() {\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        var created=false\n        var updated=false\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        if !profile.hasWallet(\"Flow\") {\n            let flowWallet=Profile.Wallet( name:\"Flow\", receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), tags: [\"flow\"])\n    \n            profile.addWallet(flowWallet)\n            updated=true\n        }\n        if !profile.hasWallet(\"FUSD\") {\n            profile.addWallet(Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), tags: [\"fusd\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if !profile.hasWallet(\"USDC\") {\n            profile.addWallet(Profile.Wallet( name:\"USDC\", receiver:usdcCap, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(FiatToken.VaultBalancePubPath), accept: Type\u003c@FiatToken.Vault\u003e(), tags: [\"usdc\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else if updated {\n            profile.emitUpdatedEvent()\n        }\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        let doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        let doeSalePublicPath=FindMarket.getPublicPath(doeSaleType, name: tenant.name)\n        let doeSaleStoragePath= FindMarket.getStoragePath(doeSaleType, name:tenant.name)\n        let doeSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n        if !doeSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n        }\n\n        let doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        let doeBidPublicPath=FindMarket.getPublicPath(doeBidType, name: tenant.name)\n        let doeBidStoragePath= FindMarket.getStoragePath(doeBidType, name:tenant.name)\n        let doeBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n        if !doeBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n        }\n\n        /// auctions that escrow ft\n        let aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        let aeSalePublicPath=FindMarket.getPublicPath(aeSaleType, name: tenant.name)\n        let aeSaleStoragePath= FindMarket.getStoragePath(aeSaleType, name:tenant.name)\n        let aeSaleCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n        if !aeSaleCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n        }\n\n        let dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\n        let dosSalePublicPath=FindMarket.getPublicPath(dosSaleType, name: tenant.name)\n        let dosSaleStoragePath= FindMarket.getStoragePath(dosSaleType, name:tenant.name)\n\n        let dosSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n        if !dosSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n        }\n\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n        if !dosBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n        }\n\n        let aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\n        let aeBidPublicPath=FindMarket.getPublicPath(aeBidType, name: tenant.name)\n        let aeBidStoragePath= FindMarket.getStoragePath(aeBidType, name:tenant.name)\n        let aeBidCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n        if !aeBidCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n        }\n\n     /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n        }\n\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n        if !asBidCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n        }\n\n        let leaseTenantCapability= FindMarket.getTenantCapability(FindMarket.getTenantAddress(\"findLease\")!)!\n\n        let leaseSaleItemType= Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()\n        let leasePublicPath=FindMarket.getPublicPath(leaseSaleItemType, name: \"findLease\")\n        let leaseStoragePath= FindMarket.getStoragePath(leaseSaleItemType, name:\"findLease\")\n        let leaseSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath) \n        if !leaseSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketSale.SaleItemCollection\u003e(\u003c- FindLeaseMarketSale.createEmptySaleItemCollection(leaseTenantCapability), to: leaseStoragePath)\n            account.link\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath, target: leaseStoragePath)\n        }\n\n        let leaseASSaleItemType= Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e()\n        let leaseASPublicPath=FindMarket.getPublicPath(leaseASSaleItemType, name: \"findLease\")\n        let leaseASStoragePath= FindMarket.getStoragePath(leaseASSaleItemType, name:\"findLease\")\n        let leaseASSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath) \n        if !leaseASSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseASStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath, target: leaseASStoragePath)\n        }\n\n\n        let leaseASBidType= Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e()\n        let leaseASBidPublicPath=FindMarket.getPublicPath(leaseASBidType, name: \"findLease\")\n        let leaseASBidStoragePath= FindMarket.getStoragePath(leaseASBidType, name: \"findLease\")\n        let leaseASBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath) \n        if !leaseASBidCap.check() {\n            account.save\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseASBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath, target: leaseASBidStoragePath)\n        }\n\n        // let leaseAESaleItemType= Type\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e()\n        // let leaseAEPublicPath=FindMarket.getPublicPath(leaseAESaleItemType, name: \"findLease\")\n        // let leaseAEStoragePath= FindMarket.getStoragePath(leaseAESaleItemType, name:\"findLease\")\n        // let leaseAESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath) \n        // if !leaseAESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseAEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath, target: leaseAEStoragePath)\n        // }\n\n        // let leaseAEBidType= Type\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e()\n        // let leaseAEBidPublicPath=FindMarket.getPublicPath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidStoragePath= FindMarket.getStoragePath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath) \n        // if !leaseAEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseAEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath, target: leaseAEBidStoragePath)\n        // }\n\n        let leaseDOSSaleItemType= Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e()\n        let leaseDOSPublicPath=FindMarket.getPublicPath(leaseDOSSaleItemType, name: \"findLease\")\n        let leaseDOSStoragePath= FindMarket.getStoragePath(leaseDOSSaleItemType, name:\"findLease\")\n        let leaseDOSSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath) \n        if !leaseDOSSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOSStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath, target: leaseDOSStoragePath)\n        }\n\n        let leaseDOSBidType= Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let leaseDOSBidPublicPath=FindMarket.getPublicPath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidStoragePath= FindMarket.getStoragePath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath) \n        if !leaseDOSBidCap.check() {\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOSBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath, target: leaseDOSBidStoragePath)\n        }\n\n        // let leaseDOESaleItemType= Type\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        // let leaseDOEPublicPath=FindMarket.getPublicPath(leaseDOESaleItemType, name: \"findLease\")\n        // let leaseDOEStoragePath= FindMarket.getStoragePath(leaseDOESaleItemType, name:\"findLease\")\n        // let leaseDOESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath) \n        // if !leaseDOESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath, target: leaseDOEStoragePath)\n        // }\n\n        // let leaseDOEBidType= Type\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        // let leaseDOEBidPublicPath=FindMarket.getPublicPath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidStoragePath= FindMarket.getStoragePath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath) \n        // if !leaseDOEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath, target: leaseDOEBidStoragePath)\n        // }\n        //SYNC with register\n\n        let resolveAddress = FIND.resolve(leaseName)\n        if resolveAddress == nil {panic(\"The address input is not a valid name nor address. Input : \".concat(leaseName))}\n        let address = resolveAddress!\n\n        let ft = FTRegistry.getFTInfo(ftAliasOrIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftAliasOrIdentifier))\n\n        self.ftVaultType = ft.type\n\n        let walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n        assert(walletReference.balance \u003e amount , message: \"Bidder has to have enough balance in wallet\")\n\n\n        let leaseTenant = leaseTenantCapability.borrow()!\n        let bidStoragePath=leaseTenant.getStoragePath(Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e())!\n        self.bidsReference= account.borrow\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(from: bidStoragePath)\n\n    }\n\n    pre {\n        self.bidsReference != nil : \"This account does not have a bid collection\"\n    }\n\n    execute {\n        self.bidsReference!.bid(name:leaseName, amount: amount, vaultType: self.ftVaultType, validUntil: validUntil, saleItemExtraField: {}, bidExtraField: {})\n    }\n}",
               "spec": {
                  "order": [
                     "leaseName",
                     "ftAliasOrIdentifier",
                     "amount",
                     "validUntil"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "ftAliasOrIdentifier": "String",
                     "leaseName": "String",
                     "validUntil": "UFix64?"
                  }
               }
            },
            "bidLeaseMarketDirectOfferSoftDUC": {
               "code": "import FindMarketSale from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionSoft from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\nimport FindMarket from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FindViews from 0xf8d6e0586b0a20c7\nimport FTRegistry from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport TokenForwarding from 0xf8d6e0586b0a20c7\nimport DapperUtilityCoin from 0xf8d6e0586b0a20c7\nimport Dandy from 0xf8d6e0586b0a20c7\nimport Profile from 0xf8d6e0586b0a20c7\nimport FindLeaseMarketSale from 0xf8d6e0586b0a20c7\nimport FindLeaseMarketAuctionSoft from 0xf8d6e0586b0a20c7\n// import FindLeaseMarketAuctionEscrow from \"../contracts/FindLeaseMarketAuctionEscrow.cdc\"\nimport FindLeaseMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\n// import FindLeaseMarketDirectOfferEscrow from \"../contracts/FindLeaseMarketDirectOfferEscrow.cdc\"\nimport FindLeaseMarket from 0xf8d6e0586b0a20c7\n\ntransaction(dapperAddress: Address, leaseName: String, amount: UFix64, validUntil: UFix64?) {\n\n    let bidsReference: \u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection?\n    let ftVaultType: Type\n\n    prepare(account: AuthAccount) {\n        \n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n        //SYNC with register\n        //Add exising FUSD or create a new one and add it\n        let name = account.address.toString()\n        let ducReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver)\n        if !ducReceiver.check() {\n            let dapper = getAccount(dapperAddress)\n            // Create a new Forwarder resource for DUC and store it in the new account's storage\n            let ducForwarder \u003c- TokenForwarding.createNewForwarder(recipient: dapper.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver))\n            account.save(\u003c-ducForwarder, to: /storage/dapperUtilityCoinReceiver)\n            // Publish a Receiver capability for the new account, which is linked to the DUC Forwarder\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver,target: /storage/dapperUtilityCoinReceiver)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: ducReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let dandyCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        let dandyCapPrivate= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPrivatePath)\n        if !dandyCapPrivate.check() {\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        var created=false\n        var updated=false\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        if !profile.hasWallet(\"Flow\") {\n            let flowWallet=Profile.Wallet( name:\"Flow\", receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), tags: [\"flow\"])\n    \n            profile.addWallet(flowWallet)\n            updated=true\n        }\n        if !profile.hasWallet(\"DUC\") {\n            profile.addWallet(Profile.Wallet( name:\"DUC\", receiver:ducReceiver, balance:getAccount(dapperAddress).getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/dapperUtilityCoinBalance), accept: Type\u003c@DapperUtilityCoin.Vault\u003e(), tags: [\"duc\", \"dapperUtilityCoin\",\"dapper\"]))\n            updated=true\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else {\n            profile.emitUpdatedEvent()\n        }\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        let doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        let doeSalePublicPath=FindMarket.getPublicPath(doeSaleType, name: tenant.name)\n        let doeSaleStoragePath= FindMarket.getStoragePath(doeSaleType, name:tenant.name)\n        let doeSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n        if !doeSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n        }\n\n        let doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        let doeBidPublicPath=FindMarket.getPublicPath(doeBidType, name: tenant.name)\n        let doeBidStoragePath= FindMarket.getStoragePath(doeBidType, name:tenant.name)\n        let doeBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n        if !doeBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n        }\n\n        /// auctions that escrow ft\n        let aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        let aeSalePublicPath=FindMarket.getPublicPath(aeSaleType, name: tenant.name)\n        let aeSaleStoragePath= FindMarket.getStoragePath(aeSaleType, name:tenant.name)\n        let aeSaleCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n        if !aeSaleCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n        }\n\n        let dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\n        let dosSalePublicPath=FindMarket.getPublicPath(dosSaleType, name: tenant.name)\n        let dosSaleStoragePath= FindMarket.getStoragePath(dosSaleType, name:tenant.name)\n\n        let dosSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n        if !dosSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n        }\n\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n        if !dosBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n        }\n\n        let aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\n        let aeBidPublicPath=FindMarket.getPublicPath(aeBidType, name: tenant.name)\n        let aeBidStoragePath= FindMarket.getStoragePath(aeBidType, name:tenant.name)\n        let aeBidCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n        if !aeBidCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n        }\n\n     /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n        }\n\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n        if !asBidCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n        }\n\n        let leaseTenantCapability= FindMarket.getTenantCapability(FindMarket.getTenantAddress(\"findLease\")!)!\n\n        let leaseSaleItemType= Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()\n        let leasePublicPath=FindMarket.getPublicPath(leaseSaleItemType, name: \"findLease\")\n        let leaseStoragePath= FindMarket.getStoragePath(leaseSaleItemType, name:\"findLease\")\n        let leaseSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath) \n        if !leaseSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketSale.SaleItemCollection\u003e(\u003c- FindLeaseMarketSale.createEmptySaleItemCollection(leaseTenantCapability), to: leaseStoragePath)\n            account.link\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath, target: leaseStoragePath)\n        }\n\n        let leaseASSaleItemType= Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e()\n        let leaseASPublicPath=FindMarket.getPublicPath(leaseASSaleItemType, name: \"findLease\")\n        let leaseASStoragePath= FindMarket.getStoragePath(leaseASSaleItemType, name:\"findLease\")\n        let leaseASSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath) \n        if !leaseASSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseASStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath, target: leaseASStoragePath)\n        }\n\n\n        let leaseASBidType= Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e()\n        let leaseASBidPublicPath=FindMarket.getPublicPath(leaseASBidType, name: \"findLease\")\n        let leaseASBidStoragePath= FindMarket.getStoragePath(leaseASBidType, name: \"findLease\")\n        let leaseASBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath) \n        if !leaseASBidCap.check() {\n            account.save\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseASBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath, target: leaseASBidStoragePath)\n        }\n\n        // let leaseAESaleItemType= Type\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e()\n        // let leaseAEPublicPath=FindMarket.getPublicPath(leaseAESaleItemType, name: \"findLease\")\n        // let leaseAEStoragePath= FindMarket.getStoragePath(leaseAESaleItemType, name:\"findLease\")\n        // let leaseAESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath) \n        // if !leaseAESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseAEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath, target: leaseAEStoragePath)\n        // }\n\n        // let leaseAEBidType= Type\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e()\n        // let leaseAEBidPublicPath=FindMarket.getPublicPath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidStoragePath= FindMarket.getStoragePath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath) \n        // if !leaseAEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseAEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath, target: leaseAEBidStoragePath)\n        // }\n\n        let leaseDOSSaleItemType= Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e()\n        let leaseDOSPublicPath=FindMarket.getPublicPath(leaseDOSSaleItemType, name: \"findLease\")\n        let leaseDOSStoragePath= FindMarket.getStoragePath(leaseDOSSaleItemType, name:\"findLease\")\n        let leaseDOSSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath) \n        if !leaseDOSSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOSStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath, target: leaseDOSStoragePath)\n        }\n\n        let leaseDOSBidType= Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let leaseDOSBidPublicPath=FindMarket.getPublicPath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidStoragePath= FindMarket.getStoragePath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath) \n        if !leaseDOSBidCap.check() {\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOSBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath, target: leaseDOSBidStoragePath)\n        }\n\n        // let leaseDOESaleItemType= Type\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        // let leaseDOEPublicPath=FindMarket.getPublicPath(leaseDOESaleItemType, name: \"findLease\")\n        // let leaseDOEStoragePath= FindMarket.getStoragePath(leaseDOESaleItemType, name:\"findLease\")\n        // let leaseDOESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath) \n        // if !leaseDOESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath, target: leaseDOEStoragePath)\n        // }\n\n        // let leaseDOEBidType= Type\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        // let leaseDOEBidPublicPath=FindMarket.getPublicPath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidStoragePath= FindMarket.getStoragePath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath) \n        // if !leaseDOEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath, target: leaseDOEBidStoragePath)\n        // }\n        //SYNC with register\n\n        let ft = FTRegistry.getFTInfo(Type\u003c@DapperUtilityCoin.Vault\u003e().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(Type\u003c@DapperUtilityCoin.Vault\u003e().identifier))\n\n        self.ftVaultType = ft.type\n\n        let leaseTenant = leaseTenantCapability.borrow()!\n        let bidStoragePath=leaseTenant.getStoragePath(Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e())!\n        self.bidsReference= account.borrow\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(from: bidStoragePath)\n\n    }\n\n    pre {\n        self.bidsReference != nil : \"This account does not have a bid collection\"\n    }\n\n    execute {\n        self.bidsReference!.bid(name:leaseName, amount: amount, vaultType: self.ftVaultType, validUntil: validUntil, saleItemExtraField: {}, bidExtraField: {})\n    }\n}",
               "spec": {
                  "order": [
                     "dapperAddress",
                     "leaseName",
                     "amount",
                     "validUntil"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "dapperAddress": "Address",
                     "leaseName": "String",
                     "validUntil": "UFix64?"
                  }
               }
            },
            "bidMarketAuctionEscrowed": {
               "code": "import FindMarketSale from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionSoft from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FindViews from 0xf8d6e0586b0a20c7\nimport NFTCatalog from 0xf8d6e0586b0a20c7\nimport FINDNFTCatalog from 0xf8d6e0586b0a20c7\nimport FTRegistry from 0xf8d6e0586b0a20c7\nimport FindMarket from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\nimport FUSD from 0xf8d6e0586b0a20c7\nimport FiatToken from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport Dandy from 0xf8d6e0586b0a20c7\nimport Profile from 0xf8d6e0586b0a20c7\nimport FindLeaseMarketSale from 0xf8d6e0586b0a20c7\nimport FindLeaseMarketAuctionSoft from 0xf8d6e0586b0a20c7\n// import FindLeaseMarketAuctionEscrow from \"../contracts/FindLeaseMarketAuctionEscrow.cdc\"\nimport FindLeaseMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\n// import FindLeaseMarketDirectOfferEscrow from \"../contracts/FindLeaseMarketDirectOfferEscrow.cdc\"\nimport FindLeaseMarket from 0xf8d6e0586b0a20c7\n\ntransaction(marketplace:Address, user: String, id: UInt64, amount: UFix64) {\n\n    let saleItemsCap: Capability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic}\u003e \n    var targetCapability : Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e\n    let walletReference : \u0026FungibleToken.Vault\n    let bidsReference: \u0026FindMarketAuctionEscrow.MarketBidCollection?\n    let balanceBeforeBid: UFix64\n    let pointer: FindViews.ViewReadPointer\n\n    prepare(account: AuthAccount) {\n\n\n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n        //SYNC with register\n        //Add exising FUSD or create a new one and add it\n        let name = account.address.toString()\n        let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n        if !fusdReceiver.check() {\n            let fusd \u003c- FUSD.createEmptyVault()\n            account.save(\u003c- fusd, to: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n        }\n\n        let usdcCap = account.getCapability\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e(FiatToken.VaultReceiverPubPath)\n        if !usdcCap.check() {\n                account.save( \u003c-FiatToken.createEmptyVault(), to: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e( FiatToken.VaultReceiverPubPath, target: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FiatToken.ResourceId}\u003e( FiatToken.VaultUUIDPubPath, target: FiatToken.VaultStoragePath)\n                account.link\u003c\u0026FiatToken.Vault{FungibleToken.Balance}\u003e( FiatToken.VaultBalancePubPath, target:FiatToken.VaultStoragePath)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let dandyCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        let dandyCapPrivate= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPrivatePath)\n        if !dandyCapPrivate.check() {\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        var created=false\n        var updated=false\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        if !profile.hasWallet(\"Flow\") {\n            let flowWallet=Profile.Wallet( name:\"Flow\", receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), tags: [\"flow\"])\n    \n            profile.addWallet(flowWallet)\n            updated=true\n        }\n        if !profile.hasWallet(\"FUSD\") {\n            profile.addWallet(Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), tags: [\"fusd\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if !profile.hasWallet(\"USDC\") {\n            profile.addWallet(Profile.Wallet( name:\"USDC\", receiver:usdcCap, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(FiatToken.VaultBalancePubPath), accept: Type\u003c@FiatToken.Vault\u003e(), tags: [\"usdc\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else if updated {\n            profile.emitUpdatedEvent()\n        }\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        let doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        let doeSalePublicPath=FindMarket.getPublicPath(doeSaleType, name: tenant.name)\n        let doeSaleStoragePath= FindMarket.getStoragePath(doeSaleType, name:tenant.name)\n        let doeSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n        if !doeSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n        }\n\n        let doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        let doeBidPublicPath=FindMarket.getPublicPath(doeBidType, name: tenant.name)\n        let doeBidStoragePath= FindMarket.getStoragePath(doeBidType, name:tenant.name)\n        let doeBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n        if !doeBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n        }\n\n        /// auctions that escrow ft\n        let aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        let aeSalePublicPath=FindMarket.getPublicPath(aeSaleType, name: tenant.name)\n        let aeSaleStoragePath= FindMarket.getStoragePath(aeSaleType, name:tenant.name)\n        let aeSaleCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n        if !aeSaleCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n        }\n\n        let dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\n        let dosSalePublicPath=FindMarket.getPublicPath(dosSaleType, name: tenant.name)\n        let dosSaleStoragePath= FindMarket.getStoragePath(dosSaleType, name:tenant.name)\n\n        let dosSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n        if !dosSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n        }\n\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n        if !dosBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n        }\n\n        let aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\n        let aeBidPublicPath=FindMarket.getPublicPath(aeBidType, name: tenant.name)\n        let aeBidStoragePath= FindMarket.getStoragePath(aeBidType, name:tenant.name)\n        let aeBidCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n        if !aeBidCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n        }\n\n     /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n        }\n\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n        if !asBidCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n        }\n\n        let leaseTenantCapability= FindMarket.getTenantCapability(FindMarket.getTenantAddress(\"findLease\")!)!\n\n        let leaseSaleItemType= Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()\n        let leasePublicPath=FindMarket.getPublicPath(leaseSaleItemType, name: \"findLease\")\n        let leaseStoragePath= FindMarket.getStoragePath(leaseSaleItemType, name:\"findLease\")\n        let leaseSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath) \n        if !leaseSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketSale.SaleItemCollection\u003e(\u003c- FindLeaseMarketSale.createEmptySaleItemCollection(leaseTenantCapability), to: leaseStoragePath)\n            account.link\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath, target: leaseStoragePath)\n        }\n\n        let leaseASSaleItemType= Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e()\n        let leaseASPublicPath=FindMarket.getPublicPath(leaseASSaleItemType, name: \"findLease\")\n        let leaseASStoragePath= FindMarket.getStoragePath(leaseASSaleItemType, name:\"findLease\")\n        let leaseASSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath) \n        if !leaseASSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseASStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath, target: leaseASStoragePath)\n        }\n\n\n        let leaseASBidType= Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e()\n        let leaseASBidPublicPath=FindMarket.getPublicPath(leaseASBidType, name: \"findLease\")\n        let leaseASBidStoragePath= FindMarket.getStoragePath(leaseASBidType, name: \"findLease\")\n        let leaseASBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath) \n        if !leaseASBidCap.check() {\n            account.save\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseASBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath, target: leaseASBidStoragePath)\n        }\n\n        // let leaseAESaleItemType= Type\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e()\n        // let leaseAEPublicPath=FindMarket.getPublicPath(leaseAESaleItemType, name: \"findLease\")\n        // let leaseAEStoragePath= FindMarket.getStoragePath(leaseAESaleItemType, name:\"findLease\")\n        // let leaseAESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath) \n        // if !leaseAESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseAEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath, target: leaseAEStoragePath)\n        // }\n\n        // let leaseAEBidType= Type\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e()\n        // let leaseAEBidPublicPath=FindMarket.getPublicPath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidStoragePath= FindMarket.getStoragePath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath) \n        // if !leaseAEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseAEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath, target: leaseAEBidStoragePath)\n        // }\n\n        let leaseDOSSaleItemType= Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e()\n        let leaseDOSPublicPath=FindMarket.getPublicPath(leaseDOSSaleItemType, name: \"findLease\")\n        let leaseDOSStoragePath= FindMarket.getStoragePath(leaseDOSSaleItemType, name:\"findLease\")\n        let leaseDOSSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath) \n        if !leaseDOSSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOSStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath, target: leaseDOSStoragePath)\n        }\n\n        let leaseDOSBidType= Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let leaseDOSBidPublicPath=FindMarket.getPublicPath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidStoragePath= FindMarket.getStoragePath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath) \n        if !leaseDOSBidCap.check() {\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOSBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath, target: leaseDOSBidStoragePath)\n        }\n\n        // let leaseDOESaleItemType= Type\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        // let leaseDOEPublicPath=FindMarket.getPublicPath(leaseDOESaleItemType, name: \"findLease\")\n        // let leaseDOEStoragePath= FindMarket.getStoragePath(leaseDOESaleItemType, name:\"findLease\")\n        // let leaseDOESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath) \n        // if !leaseDOESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath, target: leaseDOEStoragePath)\n        // }\n\n        // let leaseDOEBidType= Type\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        // let leaseDOEBidPublicPath=FindMarket.getPublicPath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidStoragePath= FindMarket.getStoragePath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath) \n        // if !leaseDOEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath, target: leaseDOEBidStoragePath)\n        // }\n        //SYNC with register\n\n        let resolveAddress = FIND.resolve(user)\n        if resolveAddress == nil {panic(\"The address input is not a valid name nor address. Input : \".concat(user))}\n        let address = resolveAddress!\n\n        self.saleItemsCap= FindMarketAuctionEscrow.getSaleItemCapability(marketplace:marketplace, user:address) ?? panic(\"cannot find sale item cap. User address : \".concat(address.toString()))\n\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e())\n        let item = FindMarket.assertOperationValid(tenant: marketplace, address: address, marketOption: marketOption, id: id)\n\n        let nftIdentifier = item.getItemType().identifier\n        let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier)) \n        let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n        let nft = collection.collectionData\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n    \n        self.targetCapability= account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(nft.publicPath)\n        /* Check for nftCapability */\n        if !self.targetCapability.check() {\n            let cd = item.getNFTCollectionData()\n            // should use account.type here instead\n            if account.type(at: cd.storagePath) != nil {\n                let pathIdentifier = nft.publicPath.toString()\n                let findPath = PublicPath(identifier: pathIdentifier.slice(from: \"/public/\".length , upTo: pathIdentifier.length).concat(\"_FIND\"))!\n                account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                    findPath,\n                    target: nft.storagePath\n                )\n                self.targetCapability = account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(findPath)\n            } else {\n                account.save(\u003c- cd.createEmptyCollection(), to: cd.storagePath)\n                account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.publicPath, target: cd.storagePath)\n                account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.providerPath, target: cd.storagePath)\n            }\n\n        }\n        \n        self.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n\n        let bidSstoragePath=tenant.getStoragePath(Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e())!\n\n        self.bidsReference= account.borrow\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection\u003e(from: bidSstoragePath)\n        self.balanceBeforeBid=self.walletReference.balance\n        self.pointer= FindViews.createViewReadPointer(address: address, path:nft.publicPath, id: item.getItemID())\n    }\n\n    pre {\n        self.bidsReference != nil : \"This account does not have a bid collection\"\n        self.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount) \n        self.bidsReference!.bid(item:self.pointer, vault: \u003c- vault, nftCap: self.targetCapability, bidExtraField: {})\n    }\n\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "user",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64",
                     "marketplace": "Address",
                     "user": "String"
                  }
               }
            },
            "bidMarketAuctionSoft": {
               "code": "import FindMarketSale from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionSoft from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FindViews from 0xf8d6e0586b0a20c7\nimport FTRegistry from 0xf8d6e0586b0a20c7\nimport NFTCatalog from 0xf8d6e0586b0a20c7\nimport FINDNFTCatalog from 0xf8d6e0586b0a20c7\nimport FindMarket from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\nimport FUSD from 0xf8d6e0586b0a20c7\nimport FiatToken from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport Dandy from 0xf8d6e0586b0a20c7\nimport Profile from 0xf8d6e0586b0a20c7\nimport FindLeaseMarketSale from 0xf8d6e0586b0a20c7\nimport FindLeaseMarketAuctionSoft from 0xf8d6e0586b0a20c7\n// import FindLeaseMarketAuctionEscrow from \"../contracts/FindLeaseMarketAuctionEscrow.cdc\"\nimport FindLeaseMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\n// import FindLeaseMarketDirectOfferEscrow from \"../contracts/FindLeaseMarketDirectOfferEscrow.cdc\"\nimport FindLeaseMarket from 0xf8d6e0586b0a20c7\n\ntransaction(marketplace:Address, user: String, id: UInt64, amount: UFix64) {\n\n    let saleItemsCap: Capability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic}\u003e \n    var targetCapability : Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e\n    let walletReference : \u0026FungibleToken.Vault\n    let bidsReference: \u0026FindMarketAuctionSoft.MarketBidCollection?\n    let balanceBeforeBid: UFix64\n    let pointer: FindViews.ViewReadPointer\n    let ftVaultType: Type\n\n    prepare(account: AuthAccount) {\n\n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n        //SYNC with register\n        //Add exising FUSD or create a new one and add it\n        let name = account.address.toString()\n        let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n        if !fusdReceiver.check() {\n            let fusd \u003c- FUSD.createEmptyVault()\n            account.save(\u003c- fusd, to: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n        }\n\n        let usdcCap = account.getCapability\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e(FiatToken.VaultReceiverPubPath)\n        if !usdcCap.check() {\n                account.save( \u003c-FiatToken.createEmptyVault(), to: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e( FiatToken.VaultReceiverPubPath, target: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FiatToken.ResourceId}\u003e( FiatToken.VaultUUIDPubPath, target: FiatToken.VaultStoragePath)\n                account.link\u003c\u0026FiatToken.Vault{FungibleToken.Balance}\u003e( FiatToken.VaultBalancePubPath, target:FiatToken.VaultStoragePath)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let dandyCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        let dandyCapPrivate= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPrivatePath)\n        if !dandyCapPrivate.check() {\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        var created=false\n        var updated=false\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        if !profile.hasWallet(\"Flow\") {\n            let flowWallet=Profile.Wallet( name:\"Flow\", receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), tags: [\"flow\"])\n    \n            profile.addWallet(flowWallet)\n            updated=true\n        }\n        if !profile.hasWallet(\"FUSD\") {\n            profile.addWallet(Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), tags: [\"fusd\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if !profile.hasWallet(\"USDC\") {\n            profile.addWallet(Profile.Wallet( name:\"USDC\", receiver:usdcCap, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(FiatToken.VaultBalancePubPath), accept: Type\u003c@FiatToken.Vault\u003e(), tags: [\"usdc\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else if updated {\n            profile.emitUpdatedEvent()\n        }\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        let doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        let doeSalePublicPath=FindMarket.getPublicPath(doeSaleType, name: tenant.name)\n        let doeSaleStoragePath= FindMarket.getStoragePath(doeSaleType, name:tenant.name)\n        let doeSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n        if !doeSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n        }\n\n        let doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        let doeBidPublicPath=FindMarket.getPublicPath(doeBidType, name: tenant.name)\n        let doeBidStoragePath= FindMarket.getStoragePath(doeBidType, name:tenant.name)\n        let doeBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n        if !doeBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n        }\n\n        /// auctions that escrow ft\n        let aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        let aeSalePublicPath=FindMarket.getPublicPath(aeSaleType, name: tenant.name)\n        let aeSaleStoragePath= FindMarket.getStoragePath(aeSaleType, name:tenant.name)\n        let aeSaleCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n        if !aeSaleCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n        }\n\n        let dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\n        let dosSalePublicPath=FindMarket.getPublicPath(dosSaleType, name: tenant.name)\n        let dosSaleStoragePath= FindMarket.getStoragePath(dosSaleType, name:tenant.name)\n\n        let dosSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n        if !dosSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n        }\n\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n        if !dosBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n        }\n\n        let aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\n        let aeBidPublicPath=FindMarket.getPublicPath(aeBidType, name: tenant.name)\n        let aeBidStoragePath= FindMarket.getStoragePath(aeBidType, name:tenant.name)\n        let aeBidCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n        if !aeBidCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n        }\n\n     /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n        }\n\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n        if !asBidCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n        }\n\n        let leaseTenantCapability= FindMarket.getTenantCapability(FindMarket.getTenantAddress(\"findLease\")!)!\n\n        let leaseSaleItemType= Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()\n        let leasePublicPath=FindMarket.getPublicPath(leaseSaleItemType, name: \"findLease\")\n        let leaseStoragePath= FindMarket.getStoragePath(leaseSaleItemType, name:\"findLease\")\n        let leaseSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath) \n        if !leaseSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketSale.SaleItemCollection\u003e(\u003c- FindLeaseMarketSale.createEmptySaleItemCollection(leaseTenantCapability), to: leaseStoragePath)\n            account.link\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath, target: leaseStoragePath)\n        }\n\n        let leaseASSaleItemType= Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e()\n        let leaseASPublicPath=FindMarket.getPublicPath(leaseASSaleItemType, name: \"findLease\")\n        let leaseASStoragePath= FindMarket.getStoragePath(leaseASSaleItemType, name:\"findLease\")\n        let leaseASSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath) \n        if !leaseASSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseASStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath, target: leaseASStoragePath)\n        }\n\n\n        let leaseASBidType= Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e()\n        let leaseASBidPublicPath=FindMarket.getPublicPath(leaseASBidType, name: \"findLease\")\n        let leaseASBidStoragePath= FindMarket.getStoragePath(leaseASBidType, name: \"findLease\")\n        let leaseASBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath) \n        if !leaseASBidCap.check() {\n            account.save\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseASBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath, target: leaseASBidStoragePath)\n        }\n\n        // let leaseAESaleItemType= Type\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e()\n        // let leaseAEPublicPath=FindMarket.getPublicPath(leaseAESaleItemType, name: \"findLease\")\n        // let leaseAEStoragePath= FindMarket.getStoragePath(leaseAESaleItemType, name:\"findLease\")\n        // let leaseAESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath) \n        // if !leaseAESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseAEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath, target: leaseAEStoragePath)\n        // }\n\n        // let leaseAEBidType= Type\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e()\n        // let leaseAEBidPublicPath=FindMarket.getPublicPath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidStoragePath= FindMarket.getStoragePath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath) \n        // if !leaseAEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseAEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath, target: leaseAEBidStoragePath)\n        // }\n\n        let leaseDOSSaleItemType= Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e()\n        let leaseDOSPublicPath=FindMarket.getPublicPath(leaseDOSSaleItemType, name: \"findLease\")\n        let leaseDOSStoragePath= FindMarket.getStoragePath(leaseDOSSaleItemType, name:\"findLease\")\n        let leaseDOSSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath) \n        if !leaseDOSSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOSStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath, target: leaseDOSStoragePath)\n        }\n\n        let leaseDOSBidType= Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let leaseDOSBidPublicPath=FindMarket.getPublicPath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidStoragePath= FindMarket.getStoragePath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath) \n        if !leaseDOSBidCap.check() {\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOSBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath, target: leaseDOSBidStoragePath)\n        }\n\n        // let leaseDOESaleItemType= Type\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        // let leaseDOEPublicPath=FindMarket.getPublicPath(leaseDOESaleItemType, name: \"findLease\")\n        // let leaseDOEStoragePath= FindMarket.getStoragePath(leaseDOESaleItemType, name:\"findLease\")\n        // let leaseDOESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath) \n        // if !leaseDOESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath, target: leaseDOEStoragePath)\n        // }\n\n        // let leaseDOEBidType= Type\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        // let leaseDOEBidPublicPath=FindMarket.getPublicPath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidStoragePath= FindMarket.getStoragePath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath) \n        // if !leaseDOEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath, target: leaseDOEBidStoragePath)\n        // }\n        //SYNC with register\n\n        let resolveAddress = FIND.resolve(user)\n        if resolveAddress == nil {panic(\"The address input is not a valid name nor address. Input : \".concat(user))}\n        let address = resolveAddress!\n\n        self.saleItemsCap= FindMarketAuctionSoft.getSaleItemCapability(marketplace:marketplace, user:address) ?? panic(\"cannot find sale item cap\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e())\n\n        let item = FindMarket.assertOperationValid(tenant: marketplace, address: address, marketOption: marketOption, id: id)\n\n        let nftIdentifier = item.getItemType().identifier\n        let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier)) \n        let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n        let nft = collection.collectionData\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n    \n        self.targetCapability= account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(nft.publicPath)\n        /* Check for nftCapability */\n        if !self.targetCapability.check() {\n            let cd = item.getNFTCollectionData()\n            // should use account.type here instead\n            if account.type(at: cd.storagePath) != nil {\n                let pathIdentifier = nft.publicPath.toString()\n                let findPath = PublicPath(identifier: pathIdentifier.slice(from: \"/public/\".length , upTo: pathIdentifier.length).concat(\"_FIND\"))!\n                account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                    findPath,\n                    target: nft.storagePath\n                )\n                self.targetCapability = account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(findPath)\n            } else {\n                account.save(\u003c- cd.createEmptyCollection(), to: cd.storagePath)\n                account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.publicPath, target: cd.storagePath)\n                account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.providerPath, target: cd.storagePath)\n            }\n\n        }\n        \n        self.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account. Account address : \".concat(account.address.toString()))\n        self.ftVaultType = ft.type\n\n        let bidStoragePath=tenant.getStoragePath(Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e())\n\n        self.bidsReference= account.borrow\u003c\u0026FindMarketAuctionSoft.MarketBidCollection\u003e(from: bidStoragePath)\n        self.balanceBeforeBid=self.walletReference.balance\n        self.pointer= FindViews.createViewReadPointer(address: address, path:nft.publicPath, id: item.getItemID())\n    }\n\n    pre {\n        self.bidsReference != nil : \"This account does not have a bid collection\"\n        self.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n    }\n\n    execute {\n        self.bidsReference!.bid(item:self.pointer, amount: amount, vaultType: self.ftVaultType, nftCap: self.targetCapability, bidExtraField: {})\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "user",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64",
                     "marketplace": "Address",
                     "user": "String"
                  }
               }
            },
            "bidMarketAuctionSoftDUC": {
               "code": "import FindMarketSale from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionSoft from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FindViews from 0xf8d6e0586b0a20c7\nimport FTRegistry from 0xf8d6e0586b0a20c7\nimport NFTCatalog from 0xf8d6e0586b0a20c7\nimport FINDNFTCatalog from 0xf8d6e0586b0a20c7\nimport FindMarket from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\nimport TokenForwarding from 0xf8d6e0586b0a20c7\nimport DapperUtilityCoin from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport Dandy from 0xf8d6e0586b0a20c7\nimport Profile from 0xf8d6e0586b0a20c7\nimport FindLeaseMarketSale from 0xf8d6e0586b0a20c7\nimport FindLeaseMarketAuctionSoft from 0xf8d6e0586b0a20c7\n// import FindLeaseMarketAuctionEscrow from \"../contracts/FindLeaseMarketAuctionEscrow.cdc\"\nimport FindLeaseMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\n// import FindLeaseMarketDirectOfferEscrow from \"../contracts/FindLeaseMarketDirectOfferEscrow.cdc\"\nimport FindLeaseMarket from 0xf8d6e0586b0a20c7\n\ntransaction(dapperAddress: Address, marketplace:Address, user: String, id: UInt64, amount: UFix64) {\n\n    let saleItemsCap: Capability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic}\u003e \n    var targetCapability : Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e\n    let bidsReference: \u0026FindMarketAuctionSoft.MarketBidCollection?\n    let pointer: FindViews.ViewReadPointer\n    let ftVaultType: Type\n\n    prepare(account: AuthAccount) {\n\n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n        //SYNC with register\n        //Add exising FUSD or create a new one and add it\n        let name = account.address.toString()\n        let ducReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver)\n        if !ducReceiver.check() {\n            let dapper = getAccount(dapperAddress)\n            // Create a new Forwarder resource for DUC and store it in the new account's storage\n            let ducForwarder \u003c- TokenForwarding.createNewForwarder(recipient: dapper.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver))\n            account.save(\u003c-ducForwarder, to: /storage/dapperUtilityCoinReceiver)\n            // Publish a Receiver capability for the new account, which is linked to the DUC Forwarder\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver,target: /storage/dapperUtilityCoinReceiver)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: ducReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let dandyCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        let dandyCapPrivate= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPrivatePath)\n        if !dandyCapPrivate.check() {\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        var created=false\n        var updated=false\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        if !profile.hasWallet(\"Flow\") {\n            let flowWallet=Profile.Wallet( name:\"Flow\", receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), tags: [\"flow\"])\n    \n            profile.addWallet(flowWallet)\n            updated=true\n        }\n        if !profile.hasWallet(\"DUC\") {\n            profile.addWallet(Profile.Wallet( name:\"DUC\", receiver:ducReceiver, balance:getAccount(dapperAddress).getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/dapperUtilityCoinBalance), accept: Type\u003c@DapperUtilityCoin.Vault\u003e(), tags: [\"duc\", \"dapperUtilityCoin\",\"dapper\"]))\n            updated=true\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else {\n            profile.emitUpdatedEvent()\n        }\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        let doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        let doeSalePublicPath=FindMarket.getPublicPath(doeSaleType, name: tenant.name)\n        let doeSaleStoragePath= FindMarket.getStoragePath(doeSaleType, name:tenant.name)\n        let doeSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n        if !doeSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n        }\n\n        let doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        let doeBidPublicPath=FindMarket.getPublicPath(doeBidType, name: tenant.name)\n        let doeBidStoragePath= FindMarket.getStoragePath(doeBidType, name:tenant.name)\n        let doeBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n        if !doeBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n        }\n\n        /// auctions that escrow ft\n        let aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        let aeSalePublicPath=FindMarket.getPublicPath(aeSaleType, name: tenant.name)\n        let aeSaleStoragePath= FindMarket.getStoragePath(aeSaleType, name:tenant.name)\n        let aeSaleCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n        if !aeSaleCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n        }\n\n        let dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\n        let dosSalePublicPath=FindMarket.getPublicPath(dosSaleType, name: tenant.name)\n        let dosSaleStoragePath= FindMarket.getStoragePath(dosSaleType, name:tenant.name)\n\n        let dosSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n        if !dosSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n        }\n\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n        if !dosBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n        }\n\n        let aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\n        let aeBidPublicPath=FindMarket.getPublicPath(aeBidType, name: tenant.name)\n        let aeBidStoragePath= FindMarket.getStoragePath(aeBidType, name:tenant.name)\n        let aeBidCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n        if !aeBidCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n        }\n\n     /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n        }\n\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n        if !asBidCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n        }\n\n        let leaseTenantCapability= FindMarket.getTenantCapability(FindMarket.getTenantAddress(\"findLease\")!)!\n\n        let leaseSaleItemType= Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()\n        let leasePublicPath=FindMarket.getPublicPath(leaseSaleItemType, name: \"findLease\")\n        let leaseStoragePath= FindMarket.getStoragePath(leaseSaleItemType, name:\"findLease\")\n        let leaseSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath) \n        if !leaseSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketSale.SaleItemCollection\u003e(\u003c- FindLeaseMarketSale.createEmptySaleItemCollection(leaseTenantCapability), to: leaseStoragePath)\n            account.link\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath, target: leaseStoragePath)\n        }\n\n        let leaseASSaleItemType= Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e()\n        let leaseASPublicPath=FindMarket.getPublicPath(leaseASSaleItemType, name: \"findLease\")\n        let leaseASStoragePath= FindMarket.getStoragePath(leaseASSaleItemType, name:\"findLease\")\n        let leaseASSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath) \n        if !leaseASSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseASStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath, target: leaseASStoragePath)\n        }\n\n\n        let leaseASBidType= Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e()\n        let leaseASBidPublicPath=FindMarket.getPublicPath(leaseASBidType, name: \"findLease\")\n        let leaseASBidStoragePath= FindMarket.getStoragePath(leaseASBidType, name: \"findLease\")\n        let leaseASBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath) \n        if !leaseASBidCap.check() {\n            account.save\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseASBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath, target: leaseASBidStoragePath)\n        }\n\n        // let leaseAESaleItemType= Type\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e()\n        // let leaseAEPublicPath=FindMarket.getPublicPath(leaseAESaleItemType, name: \"findLease\")\n        // let leaseAEStoragePath= FindMarket.getStoragePath(leaseAESaleItemType, name:\"findLease\")\n        // let leaseAESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath) \n        // if !leaseAESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseAEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath, target: leaseAEStoragePath)\n        // }\n\n        // let leaseAEBidType= Type\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e()\n        // let leaseAEBidPublicPath=FindMarket.getPublicPath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidStoragePath= FindMarket.getStoragePath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath) \n        // if !leaseAEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseAEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath, target: leaseAEBidStoragePath)\n        // }\n\n        let leaseDOSSaleItemType= Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e()\n        let leaseDOSPublicPath=FindMarket.getPublicPath(leaseDOSSaleItemType, name: \"findLease\")\n        let leaseDOSStoragePath= FindMarket.getStoragePath(leaseDOSSaleItemType, name:\"findLease\")\n        let leaseDOSSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath) \n        if !leaseDOSSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOSStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath, target: leaseDOSStoragePath)\n        }\n\n        let leaseDOSBidType= Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let leaseDOSBidPublicPath=FindMarket.getPublicPath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidStoragePath= FindMarket.getStoragePath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath) \n        if !leaseDOSBidCap.check() {\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOSBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath, target: leaseDOSBidStoragePath)\n        }\n\n        // let leaseDOESaleItemType= Type\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        // let leaseDOEPublicPath=FindMarket.getPublicPath(leaseDOESaleItemType, name: \"findLease\")\n        // let leaseDOEStoragePath= FindMarket.getStoragePath(leaseDOESaleItemType, name:\"findLease\")\n        // let leaseDOESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath) \n        // if !leaseDOESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath, target: leaseDOEStoragePath)\n        // }\n\n        // let leaseDOEBidType= Type\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        // let leaseDOEBidPublicPath=FindMarket.getPublicPath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidStoragePath= FindMarket.getStoragePath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath) \n        // if !leaseDOEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath, target: leaseDOEBidStoragePath)\n        // }\n        //SYNC with register\n\n        let resolveAddress = FIND.resolve(user)\n        if resolveAddress == nil {panic(\"The address input is not a valid name nor address. Input : \".concat(user))}\n        let address = resolveAddress!\n\n        self.saleItemsCap= FindMarketAuctionSoft.getSaleItemCapability(marketplace:marketplace, user:address) ?? panic(\"cannot find sale item cap\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e())\n\n        let item = FindMarket.assertOperationValid(tenant: marketplace, address: address, marketOption: marketOption, id: id)\n\n        let nftIdentifier = item.getItemType().identifier\n        let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier)) \n        let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n        let nft = collection.collectionData\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n    \n        self.targetCapability= account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(nft.publicPath)\n        /* Check for nftCapability */\n        if !self.targetCapability.check() {\n            let cd = item.getNFTCollectionData()\n            // should use account.type here instead\n            if account.type(at: cd.storagePath) != nil {\n                let pathIdentifier = nft.publicPath.toString()\n                let findPath = PublicPath(identifier: pathIdentifier.slice(from: \"/public/\".length , upTo: pathIdentifier.length).concat(\"_FIND\"))!\n                account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                    findPath,\n                    target: nft.storagePath\n                )\n                self.targetCapability = account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(findPath)\n            } else {\n                account.save(\u003c- cd.createEmptyCollection(), to: cd.storagePath)\n                account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.publicPath, target: cd.storagePath)\n                account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.providerPath, target: cd.storagePath)\n            }\n\n        }\n        \n        self.ftVaultType = ft.type\n\n        let bidStoragePath=tenant.getStoragePath(Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e())\n\n        self.bidsReference= account.borrow\u003c\u0026FindMarketAuctionSoft.MarketBidCollection\u003e(from: bidStoragePath)\n        self.pointer= FindViews.createViewReadPointer(address: address, path:nft.publicPath, id: item.getItemID())\n    }\n\n    pre {\n        self.bidsReference != nil : \"This account does not have a bid collection\"\n    }\n\n    execute {\n        self.bidsReference!.bid(item:self.pointer, amount: amount, vaultType: self.ftVaultType, nftCap: self.targetCapability, bidExtraField: {})\n    }\n}",
               "spec": {
                  "order": [
                     "dapperAddress",
                     "marketplace",
                     "user",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "dapperAddress": "Address",
                     "id": "UInt64",
                     "marketplace": "Address",
                     "user": "String"
                  }
               }
            },
            "bidMarketDirectOfferEscrowed": {
               "code": "import FindMarket from 0xf8d6e0586b0a20c7\nimport FindMarketSale from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionSoft from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FindViews from 0xf8d6e0586b0a20c7\nimport FTRegistry from 0xf8d6e0586b0a20c7\nimport NFTCatalog from 0xf8d6e0586b0a20c7\nimport FINDNFTCatalog from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\nimport FUSD from 0xf8d6e0586b0a20c7\nimport FiatToken from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport Dandy from 0xf8d6e0586b0a20c7\nimport Profile from 0xf8d6e0586b0a20c7\nimport FindLeaseMarketSale from 0xf8d6e0586b0a20c7\nimport FindLeaseMarketAuctionSoft from 0xf8d6e0586b0a20c7\n// import FindLeaseMarketAuctionEscrow from \"../contracts/FindLeaseMarketAuctionEscrow.cdc\"\nimport FindLeaseMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\n// import FindLeaseMarketDirectOfferEscrow from \"../contracts/FindLeaseMarketDirectOfferEscrow.cdc\"\nimport FindLeaseMarket from 0xf8d6e0586b0a20c7\n\ntransaction(marketplace:Address, user: String, nftAliasOrIdentifier: String, id: UInt64, ftAliasOrIdentifier:String, amount: UFix64, validUntil: UFix64?) {\n\n    var targetCapability : Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e\n    let walletReference : \u0026FungibleToken.Vault\n    let bidsReference: \u0026FindMarketDirectOfferEscrow.MarketBidCollection?\n    let pointer: FindViews.ViewReadPointer\n\n    prepare(account: AuthAccount) {\n\n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n        //SYNC with register\n        //Add exising FUSD or create a new one and add it\n        let name = account.address.toString()\n        let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n        if !fusdReceiver.check() {\n            let fusd \u003c- FUSD.createEmptyVault()\n            account.save(\u003c- fusd, to: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n        }\n\n        let usdcCap = account.getCapability\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e(FiatToken.VaultReceiverPubPath)\n        if !usdcCap.check() {\n                account.save( \u003c-FiatToken.createEmptyVault(), to: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e( FiatToken.VaultReceiverPubPath, target: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FiatToken.ResourceId}\u003e( FiatToken.VaultUUIDPubPath, target: FiatToken.VaultStoragePath)\n                account.link\u003c\u0026FiatToken.Vault{FungibleToken.Balance}\u003e( FiatToken.VaultBalancePubPath, target:FiatToken.VaultStoragePath)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let dandyCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        let dandyCapPrivate= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPrivatePath)\n        if !dandyCapPrivate.check() {\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        var created=false\n        var updated=false\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        if !profile.hasWallet(\"Flow\") {\n            let flowWallet=Profile.Wallet( name:\"Flow\", receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), tags: [\"flow\"])\n    \n            profile.addWallet(flowWallet)\n            updated=true\n        }\n        if !profile.hasWallet(\"FUSD\") {\n            profile.addWallet(Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), tags: [\"fusd\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if !profile.hasWallet(\"USDC\") {\n            profile.addWallet(Profile.Wallet( name:\"USDC\", receiver:usdcCap, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(FiatToken.VaultBalancePubPath), accept: Type\u003c@FiatToken.Vault\u003e(), tags: [\"usdc\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else if updated {\n            profile.emitUpdatedEvent()\n        }\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        let doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        let doeSalePublicPath=FindMarket.getPublicPath(doeSaleType, name: tenant.name)\n        let doeSaleStoragePath= FindMarket.getStoragePath(doeSaleType, name:tenant.name)\n        let doeSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n        if !doeSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n        }\n\n        let doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        let doeBidPublicPath=FindMarket.getPublicPath(doeBidType, name: tenant.name)\n        let doeBidStoragePath= FindMarket.getStoragePath(doeBidType, name:tenant.name)\n        let doeBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n        if !doeBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n        }\n\n        /// auctions that escrow ft\n        let aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        let aeSalePublicPath=FindMarket.getPublicPath(aeSaleType, name: tenant.name)\n        let aeSaleStoragePath= FindMarket.getStoragePath(aeSaleType, name:tenant.name)\n        let aeSaleCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n        if !aeSaleCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n        }\n\n        let dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\n        let dosSalePublicPath=FindMarket.getPublicPath(dosSaleType, name: tenant.name)\n        let dosSaleStoragePath= FindMarket.getStoragePath(dosSaleType, name:tenant.name)\n\n        let dosSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n        if !dosSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n        }\n\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n        if !dosBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n        }\n\n        let aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\n        let aeBidPublicPath=FindMarket.getPublicPath(aeBidType, name: tenant.name)\n        let aeBidStoragePath= FindMarket.getStoragePath(aeBidType, name:tenant.name)\n        let aeBidCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n        if !aeBidCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n        }\n\n     /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n        }\n\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n        if !asBidCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n        }\n\n        let leaseTenantCapability= FindMarket.getTenantCapability(FindMarket.getTenantAddress(\"findLease\")!)!\n\n        let leaseSaleItemType= Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()\n        let leasePublicPath=FindMarket.getPublicPath(leaseSaleItemType, name: \"findLease\")\n        let leaseStoragePath= FindMarket.getStoragePath(leaseSaleItemType, name:\"findLease\")\n        let leaseSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath) \n        if !leaseSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketSale.SaleItemCollection\u003e(\u003c- FindLeaseMarketSale.createEmptySaleItemCollection(leaseTenantCapability), to: leaseStoragePath)\n            account.link\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath, target: leaseStoragePath)\n        }\n\n        let leaseASSaleItemType= Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e()\n        let leaseASPublicPath=FindMarket.getPublicPath(leaseASSaleItemType, name: \"findLease\")\n        let leaseASStoragePath= FindMarket.getStoragePath(leaseASSaleItemType, name:\"findLease\")\n        let leaseASSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath) \n        if !leaseASSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseASStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath, target: leaseASStoragePath)\n        }\n\n\n        let leaseASBidType= Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e()\n        let leaseASBidPublicPath=FindMarket.getPublicPath(leaseASBidType, name: \"findLease\")\n        let leaseASBidStoragePath= FindMarket.getStoragePath(leaseASBidType, name: \"findLease\")\n        let leaseASBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath) \n        if !leaseASBidCap.check() {\n            account.save\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseASBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath, target: leaseASBidStoragePath)\n        }\n\n        // let leaseAESaleItemType= Type\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e()\n        // let leaseAEPublicPath=FindMarket.getPublicPath(leaseAESaleItemType, name: \"findLease\")\n        // let leaseAEStoragePath= FindMarket.getStoragePath(leaseAESaleItemType, name:\"findLease\")\n        // let leaseAESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath) \n        // if !leaseAESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseAEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath, target: leaseAEStoragePath)\n        // }\n\n        // let leaseAEBidType= Type\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e()\n        // let leaseAEBidPublicPath=FindMarket.getPublicPath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidStoragePath= FindMarket.getStoragePath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath) \n        // if !leaseAEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseAEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath, target: leaseAEBidStoragePath)\n        // }\n\n        let leaseDOSSaleItemType= Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e()\n        let leaseDOSPublicPath=FindMarket.getPublicPath(leaseDOSSaleItemType, name: \"findLease\")\n        let leaseDOSStoragePath= FindMarket.getStoragePath(leaseDOSSaleItemType, name:\"findLease\")\n        let leaseDOSSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath) \n        if !leaseDOSSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOSStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath, target: leaseDOSStoragePath)\n        }\n\n        let leaseDOSBidType= Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let leaseDOSBidPublicPath=FindMarket.getPublicPath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidStoragePath= FindMarket.getStoragePath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath) \n        if !leaseDOSBidCap.check() {\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOSBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath, target: leaseDOSBidStoragePath)\n        }\n\n        // let leaseDOESaleItemType= Type\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        // let leaseDOEPublicPath=FindMarket.getPublicPath(leaseDOESaleItemType, name: \"findLease\")\n        // let leaseDOEStoragePath= FindMarket.getStoragePath(leaseDOESaleItemType, name:\"findLease\")\n        // let leaseDOESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath) \n        // if !leaseDOESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath, target: leaseDOEStoragePath)\n        // }\n\n        // let leaseDOEBidType= Type\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        // let leaseDOEBidPublicPath=FindMarket.getPublicPath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidStoragePath= FindMarket.getStoragePath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath) \n        // if !leaseDOEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath, target: leaseDOEBidStoragePath)\n        // }\n        //SYNC with register\n\n        let resolveAddress = FIND.resolve(user)\n        if resolveAddress == nil {panic(\"The address input is not a valid name nor address. Input : \".concat(user))}\n        let address = resolveAddress!\n\n        let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftAliasOrIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftAliasOrIdentifier)) \n        let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n        let nft = collection.collectionData\n\n        let ft = FTRegistry.getFTInfo(ftAliasOrIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftAliasOrIdentifier))\n        \n        self.targetCapability= account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(nft.publicPath)\n        self.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n\n        let bidStoragePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e())!\n\n        self.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection\u003e(from: bidStoragePath)\n        self.pointer= FindViews.createViewReadPointer(address: address, path:nft.publicPath, id: id)\n\n        /* Check for nftCapability */\n        if !self.targetCapability.check() {\n            let cd = self.pointer.getNFTCollectionData()\n            // should use account.type here instead\n            if account.type(at: cd.storagePath) != nil {\n                let pathIdentifier = nft.publicPath.toString()\n                let findPath = PublicPath(identifier: pathIdentifier.slice(from: \"/public/\".length , upTo: pathIdentifier.length).concat(\"_FIND\"))!\n                account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                    findPath,\n                    target: nft.storagePath\n                )\n                self.targetCapability = account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(findPath)\n            } else {\n                account.save(\u003c- cd.createEmptyCollection(), to: cd.storagePath)\n                account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.publicPath, target: cd.storagePath)\n                account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.providerPath, target: cd.storagePath)\n            }\n\n        }\n    }\n\n    pre {\n        self.bidsReference != nil : \"This account does not have a bid collection\"\n        self.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount) \n        self.bidsReference!.bid(item:self.pointer, vault: \u003c- vault, nftCap: self.targetCapability, validUntil: validUntil, saleItemExtraField: {}, bidExtraField: {})\n    }\n\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "user",
                     "nftAliasOrIdentifier",
                     "id",
                     "ftAliasOrIdentifier",
                     "amount",
                     "validUntil"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "ftAliasOrIdentifier": "String",
                     "id": "UInt64",
                     "marketplace": "Address",
                     "nftAliasOrIdentifier": "String",
                     "user": "String",
                     "validUntil": "UFix64?"
                  }
               }
            },
            "bidMarketDirectOfferSoft": {
               "code": "import FindMarketSale from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionSoft from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\nimport FindMarket from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FindViews from 0xf8d6e0586b0a20c7\nimport FTRegistry from 0xf8d6e0586b0a20c7\nimport NFTCatalog from 0xf8d6e0586b0a20c7\nimport FINDNFTCatalog from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\nimport FUSD from 0xf8d6e0586b0a20c7\nimport FiatToken from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport Dandy from 0xf8d6e0586b0a20c7\nimport Profile from 0xf8d6e0586b0a20c7\nimport FindLeaseMarketSale from 0xf8d6e0586b0a20c7\nimport FindLeaseMarketAuctionSoft from 0xf8d6e0586b0a20c7\n// import FindLeaseMarketAuctionEscrow from \"../contracts/FindLeaseMarketAuctionEscrow.cdc\"\nimport FindLeaseMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\n// import FindLeaseMarketDirectOfferEscrow from \"../contracts/FindLeaseMarketDirectOfferEscrow.cdc\"\nimport FindLeaseMarket from 0xf8d6e0586b0a20c7\n\ntransaction(marketplace:Address, user: String, nftAliasOrIdentifier: String, id: UInt64, ftAliasOrIdentifier:String, amount: UFix64, validUntil: UFix64?) {\n\n    var targetCapability : Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e\n    let walletReference : \u0026FungibleToken.Vault\n    let bidsReference: \u0026FindMarketDirectOfferSoft.MarketBidCollection?\n    let balanceBeforeBid: UFix64\n    let pointer: FindViews.ViewReadPointer\n    let ftVaultType: Type\n\n    prepare(account: AuthAccount) {\n        \n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n        //SYNC with register\n        //Add exising FUSD or create a new one and add it\n        let name = account.address.toString()\n        let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n        if !fusdReceiver.check() {\n            let fusd \u003c- FUSD.createEmptyVault()\n            account.save(\u003c- fusd, to: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n        }\n\n        let usdcCap = account.getCapability\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e(FiatToken.VaultReceiverPubPath)\n        if !usdcCap.check() {\n                account.save( \u003c-FiatToken.createEmptyVault(), to: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e( FiatToken.VaultReceiverPubPath, target: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FiatToken.ResourceId}\u003e( FiatToken.VaultUUIDPubPath, target: FiatToken.VaultStoragePath)\n                account.link\u003c\u0026FiatToken.Vault{FungibleToken.Balance}\u003e( FiatToken.VaultBalancePubPath, target:FiatToken.VaultStoragePath)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let dandyCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        let dandyCapPrivate= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPrivatePath)\n        if !dandyCapPrivate.check() {\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        var created=false\n        var updated=false\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        if !profile.hasWallet(\"Flow\") {\n            let flowWallet=Profile.Wallet( name:\"Flow\", receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), tags: [\"flow\"])\n    \n            profile.addWallet(flowWallet)\n            updated=true\n        }\n        if !profile.hasWallet(\"FUSD\") {\n            profile.addWallet(Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), tags: [\"fusd\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if !profile.hasWallet(\"USDC\") {\n            profile.addWallet(Profile.Wallet( name:\"USDC\", receiver:usdcCap, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(FiatToken.VaultBalancePubPath), accept: Type\u003c@FiatToken.Vault\u003e(), tags: [\"usdc\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else if updated {\n            profile.emitUpdatedEvent()\n        }\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        let doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        let doeSalePublicPath=FindMarket.getPublicPath(doeSaleType, name: tenant.name)\n        let doeSaleStoragePath= FindMarket.getStoragePath(doeSaleType, name:tenant.name)\n        let doeSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n        if !doeSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n        }\n\n        let doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        let doeBidPublicPath=FindMarket.getPublicPath(doeBidType, name: tenant.name)\n        let doeBidStoragePath= FindMarket.getStoragePath(doeBidType, name:tenant.name)\n        let doeBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n        if !doeBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n        }\n\n        /// auctions that escrow ft\n        let aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        let aeSalePublicPath=FindMarket.getPublicPath(aeSaleType, name: tenant.name)\n        let aeSaleStoragePath= FindMarket.getStoragePath(aeSaleType, name:tenant.name)\n        let aeSaleCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n        if !aeSaleCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n        }\n\n        let dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\n        let dosSalePublicPath=FindMarket.getPublicPath(dosSaleType, name: tenant.name)\n        let dosSaleStoragePath= FindMarket.getStoragePath(dosSaleType, name:tenant.name)\n\n        let dosSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n        if !dosSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n        }\n\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n        if !dosBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n        }\n\n        let aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\n        let aeBidPublicPath=FindMarket.getPublicPath(aeBidType, name: tenant.name)\n        let aeBidStoragePath= FindMarket.getStoragePath(aeBidType, name:tenant.name)\n        let aeBidCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n        if !aeBidCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n        }\n\n     /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n        }\n\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n        if !asBidCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n        }\n\n        let leaseTenantCapability= FindMarket.getTenantCapability(FindMarket.getTenantAddress(\"findLease\")!)!\n\n        let leaseSaleItemType= Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()\n        let leasePublicPath=FindMarket.getPublicPath(leaseSaleItemType, name: \"findLease\")\n        let leaseStoragePath= FindMarket.getStoragePath(leaseSaleItemType, name:\"findLease\")\n        let leaseSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath) \n        if !leaseSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketSale.SaleItemCollection\u003e(\u003c- FindLeaseMarketSale.createEmptySaleItemCollection(leaseTenantCapability), to: leaseStoragePath)\n            account.link\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath, target: leaseStoragePath)\n        }\n\n        let leaseASSaleItemType= Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e()\n        let leaseASPublicPath=FindMarket.getPublicPath(leaseASSaleItemType, name: \"findLease\")\n        let leaseASStoragePath= FindMarket.getStoragePath(leaseASSaleItemType, name:\"findLease\")\n        let leaseASSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath) \n        if !leaseASSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseASStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath, target: leaseASStoragePath)\n        }\n\n\n        let leaseASBidType= Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e()\n        let leaseASBidPublicPath=FindMarket.getPublicPath(leaseASBidType, name: \"findLease\")\n        let leaseASBidStoragePath= FindMarket.getStoragePath(leaseASBidType, name: \"findLease\")\n        let leaseASBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath) \n        if !leaseASBidCap.check() {\n            account.save\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseASBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath, target: leaseASBidStoragePath)\n        }\n\n        // let leaseAESaleItemType= Type\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e()\n        // let leaseAEPublicPath=FindMarket.getPublicPath(leaseAESaleItemType, name: \"findLease\")\n        // let leaseAEStoragePath= FindMarket.getStoragePath(leaseAESaleItemType, name:\"findLease\")\n        // let leaseAESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath) \n        // if !leaseAESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseAEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath, target: leaseAEStoragePath)\n        // }\n\n        // let leaseAEBidType= Type\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e()\n        // let leaseAEBidPublicPath=FindMarket.getPublicPath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidStoragePath= FindMarket.getStoragePath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath) \n        // if !leaseAEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseAEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath, target: leaseAEBidStoragePath)\n        // }\n\n        let leaseDOSSaleItemType= Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e()\n        let leaseDOSPublicPath=FindMarket.getPublicPath(leaseDOSSaleItemType, name: \"findLease\")\n        let leaseDOSStoragePath= FindMarket.getStoragePath(leaseDOSSaleItemType, name:\"findLease\")\n        let leaseDOSSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath) \n        if !leaseDOSSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOSStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath, target: leaseDOSStoragePath)\n        }\n\n        let leaseDOSBidType= Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let leaseDOSBidPublicPath=FindMarket.getPublicPath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidStoragePath= FindMarket.getStoragePath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath) \n        if !leaseDOSBidCap.check() {\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOSBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath, target: leaseDOSBidStoragePath)\n        }\n\n        // let leaseDOESaleItemType= Type\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        // let leaseDOEPublicPath=FindMarket.getPublicPath(leaseDOESaleItemType, name: \"findLease\")\n        // let leaseDOEStoragePath= FindMarket.getStoragePath(leaseDOESaleItemType, name:\"findLease\")\n        // let leaseDOESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath) \n        // if !leaseDOESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath, target: leaseDOEStoragePath)\n        // }\n\n        // let leaseDOEBidType= Type\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        // let leaseDOEBidPublicPath=FindMarket.getPublicPath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidStoragePath= FindMarket.getStoragePath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath) \n        // if !leaseDOEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath, target: leaseDOEBidStoragePath)\n        // }\n        //SYNC with register\n\n        let resolveAddress = FIND.resolve(user)\n        if resolveAddress == nil {panic(\"The address input is not a valid name nor address. Input : \".concat(user))}\n        let address = resolveAddress!\n\n        let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftAliasOrIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftAliasOrIdentifier)) \n        let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n        let nft = collection.collectionData\n\n        let ft = FTRegistry.getFTInfo(ftAliasOrIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftAliasOrIdentifier))\n\n        self.ftVaultType = ft.type\n\n        self.targetCapability= account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(nft.publicPath)\n        self.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n\n        let bidStoragePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())!\n        self.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection\u003e(from: bidStoragePath)\n        self.balanceBeforeBid=self.walletReference.balance\n        self.pointer= FindViews.createViewReadPointer(address: address, path:nft.publicPath, id: id)\n\n        /* Check for nftCapability */\n        if !self.targetCapability.check() {\n            let cd = self.pointer.getNFTCollectionData()\n            // should use account.type here instead\n            if account.type(at: cd.storagePath) != nil {\n                let pathIdentifier = nft.publicPath.toString()\n                let findPath = PublicPath(identifier: pathIdentifier.slice(from: \"/public/\".length , upTo: pathIdentifier.length).concat(\"_FIND\"))!\n                account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                    findPath,\n                    target: nft.storagePath\n                )\n                self.targetCapability = account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(findPath)\n            } else {\n                account.save(\u003c- cd.createEmptyCollection(), to: cd.storagePath)\n                account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.publicPath, target: cd.storagePath)\n                account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.providerPath, target: cd.storagePath)\n            }\n\n        }\n    }\n\n    pre {\n        self.bidsReference != nil : \"This account does not have a bid collection\"\n        self.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n    }\n\n    execute {\n        self.bidsReference!.bid(item:self.pointer, amount: amount, vaultType: self.ftVaultType, nftCap: self.targetCapability, validUntil: validUntil, saleItemExtraField: {}, bidExtraField: {})\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "user",
                     "nftAliasOrIdentifier",
                     "id",
                     "ftAliasOrIdentifier",
                     "amount",
                     "validUntil"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "ftAliasOrIdentifier": "String",
                     "id": "UInt64",
                     "marketplace": "Address",
                     "nftAliasOrIdentifier": "String",
                     "user": "String",
                     "validUntil": "UFix64?"
                  }
               }
            },
            "bidMarketDirectOfferSoftDUC": {
               "code": "import FindMarketSale from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionSoft from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\nimport FindMarket from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FindViews from 0xf8d6e0586b0a20c7\nimport NFTCatalog from 0xf8d6e0586b0a20c7\nimport FINDNFTCatalog from 0xf8d6e0586b0a20c7\nimport FTRegistry from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport TokenForwarding from 0xf8d6e0586b0a20c7\nimport DapperUtilityCoin from 0xf8d6e0586b0a20c7\nimport Dandy from 0xf8d6e0586b0a20c7\nimport Profile from 0xf8d6e0586b0a20c7\nimport FindLeaseMarketSale from 0xf8d6e0586b0a20c7\nimport FindLeaseMarketAuctionSoft from 0xf8d6e0586b0a20c7\n// import FindLeaseMarketAuctionEscrow from \"../contracts/FindLeaseMarketAuctionEscrow.cdc\"\nimport FindLeaseMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\n// import FindLeaseMarketDirectOfferEscrow from \"../contracts/FindLeaseMarketDirectOfferEscrow.cdc\"\nimport FindLeaseMarket from 0xf8d6e0586b0a20c7\n\ntransaction(dapperAddress: Address, marketplace:Address, user: String, nftAliasOrIdentifier: String, id: UInt64, amount: UFix64, validUntil: UFix64?) {\n\n    var targetCapability : Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e\n    let bidsReference: \u0026FindMarketDirectOfferSoft.MarketBidCollection?\n    let pointer: FindViews.ViewReadPointer\n    let ftVaultType: Type\n\n    prepare(account: AuthAccount) {\n        \n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n        //SYNC with register\n        //Add exising FUSD or create a new one and add it\n        let name = account.address.toString()\n        let ducReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver)\n        if !ducReceiver.check() {\n            let dapper = getAccount(dapperAddress)\n            // Create a new Forwarder resource for DUC and store it in the new account's storage\n            let ducForwarder \u003c- TokenForwarding.createNewForwarder(recipient: dapper.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver))\n            account.save(\u003c-ducForwarder, to: /storage/dapperUtilityCoinReceiver)\n            // Publish a Receiver capability for the new account, which is linked to the DUC Forwarder\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver,target: /storage/dapperUtilityCoinReceiver)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: ducReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let dandyCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        let dandyCapPrivate= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPrivatePath)\n        if !dandyCapPrivate.check() {\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        var created=false\n        var updated=false\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        if !profile.hasWallet(\"Flow\") {\n            let flowWallet=Profile.Wallet( name:\"Flow\", receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), tags: [\"flow\"])\n    \n            profile.addWallet(flowWallet)\n            updated=true\n        }\n        if !profile.hasWallet(\"DUC\") {\n            profile.addWallet(Profile.Wallet( name:\"DUC\", receiver:ducReceiver, balance:getAccount(dapperAddress).getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/dapperUtilityCoinBalance), accept: Type\u003c@DapperUtilityCoin.Vault\u003e(), tags: [\"duc\", \"dapperUtilityCoin\",\"dapper\"]))\n            updated=true\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else {\n            profile.emitUpdatedEvent()\n        }\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        let doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        let doeSalePublicPath=FindMarket.getPublicPath(doeSaleType, name: tenant.name)\n        let doeSaleStoragePath= FindMarket.getStoragePath(doeSaleType, name:tenant.name)\n        let doeSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n        if !doeSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n        }\n\n        let doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        let doeBidPublicPath=FindMarket.getPublicPath(doeBidType, name: tenant.name)\n        let doeBidStoragePath= FindMarket.getStoragePath(doeBidType, name:tenant.name)\n        let doeBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n        if !doeBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n        }\n\n        /// auctions that escrow ft\n        let aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        let aeSalePublicPath=FindMarket.getPublicPath(aeSaleType, name: tenant.name)\n        let aeSaleStoragePath= FindMarket.getStoragePath(aeSaleType, name:tenant.name)\n        let aeSaleCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n        if !aeSaleCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n        }\n\n        let dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\n        let dosSalePublicPath=FindMarket.getPublicPath(dosSaleType, name: tenant.name)\n        let dosSaleStoragePath= FindMarket.getStoragePath(dosSaleType, name:tenant.name)\n\n        let dosSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n        if !dosSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n        }\n\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n        if !dosBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n        }\n\n        let aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\n        let aeBidPublicPath=FindMarket.getPublicPath(aeBidType, name: tenant.name)\n        let aeBidStoragePath= FindMarket.getStoragePath(aeBidType, name:tenant.name)\n        let aeBidCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n        if !aeBidCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n        }\n\n     /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n        }\n\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n        if !asBidCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n        }\n\n        let leaseTenantCapability= FindMarket.getTenantCapability(FindMarket.getTenantAddress(\"findLease\")!)!\n\n        let leaseSaleItemType= Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()\n        let leasePublicPath=FindMarket.getPublicPath(leaseSaleItemType, name: \"findLease\")\n        let leaseStoragePath= FindMarket.getStoragePath(leaseSaleItemType, name:\"findLease\")\n        let leaseSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath) \n        if !leaseSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketSale.SaleItemCollection\u003e(\u003c- FindLeaseMarketSale.createEmptySaleItemCollection(leaseTenantCapability), to: leaseStoragePath)\n            account.link\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath, target: leaseStoragePath)\n        }\n\n        let leaseASSaleItemType= Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e()\n        let leaseASPublicPath=FindMarket.getPublicPath(leaseASSaleItemType, name: \"findLease\")\n        let leaseASStoragePath= FindMarket.getStoragePath(leaseASSaleItemType, name:\"findLease\")\n        let leaseASSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath) \n        if !leaseASSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseASStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath, target: leaseASStoragePath)\n        }\n\n\n        let leaseASBidType= Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e()\n        let leaseASBidPublicPath=FindMarket.getPublicPath(leaseASBidType, name: \"findLease\")\n        let leaseASBidStoragePath= FindMarket.getStoragePath(leaseASBidType, name: \"findLease\")\n        let leaseASBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath) \n        if !leaseASBidCap.check() {\n            account.save\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseASBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath, target: leaseASBidStoragePath)\n        }\n\n        // let leaseAESaleItemType= Type\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e()\n        // let leaseAEPublicPath=FindMarket.getPublicPath(leaseAESaleItemType, name: \"findLease\")\n        // let leaseAEStoragePath= FindMarket.getStoragePath(leaseAESaleItemType, name:\"findLease\")\n        // let leaseAESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath) \n        // if !leaseAESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseAEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath, target: leaseAEStoragePath)\n        // }\n\n        // let leaseAEBidType= Type\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e()\n        // let leaseAEBidPublicPath=FindMarket.getPublicPath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidStoragePath= FindMarket.getStoragePath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath) \n        // if !leaseAEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseAEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath, target: leaseAEBidStoragePath)\n        // }\n\n        let leaseDOSSaleItemType= Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e()\n        let leaseDOSPublicPath=FindMarket.getPublicPath(leaseDOSSaleItemType, name: \"findLease\")\n        let leaseDOSStoragePath= FindMarket.getStoragePath(leaseDOSSaleItemType, name:\"findLease\")\n        let leaseDOSSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath) \n        if !leaseDOSSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOSStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath, target: leaseDOSStoragePath)\n        }\n\n        let leaseDOSBidType= Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let leaseDOSBidPublicPath=FindMarket.getPublicPath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidStoragePath= FindMarket.getStoragePath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath) \n        if !leaseDOSBidCap.check() {\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOSBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath, target: leaseDOSBidStoragePath)\n        }\n\n        // let leaseDOESaleItemType= Type\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        // let leaseDOEPublicPath=FindMarket.getPublicPath(leaseDOESaleItemType, name: \"findLease\")\n        // let leaseDOEStoragePath= FindMarket.getStoragePath(leaseDOESaleItemType, name:\"findLease\")\n        // let leaseDOESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath) \n        // if !leaseDOESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath, target: leaseDOEStoragePath)\n        // }\n\n        // let leaseDOEBidType= Type\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        // let leaseDOEBidPublicPath=FindMarket.getPublicPath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidStoragePath= FindMarket.getStoragePath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath) \n        // if !leaseDOEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath, target: leaseDOEBidStoragePath)\n        // }\n        //SYNC with register\n\n        let resolveAddress = FIND.resolve(user)\n        if resolveAddress == nil {panic(\"The address input is not a valid name nor address. Input : \".concat(user))}\n        let address = resolveAddress!\n\n        let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftAliasOrIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftAliasOrIdentifier)) \n        let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n        let nft = collection.collectionData\n\n        let ft = FTRegistry.getFTInfo(Type\u003c@DapperUtilityCoin.Vault\u003e().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(Type\u003c@DapperUtilityCoin.Vault\u003e().identifier))\n\n        self.ftVaultType = ft.type\n\n        self.targetCapability= account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(nft.publicPath)\n\n        let bidStoragePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())!\n        self.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection\u003e(from: bidStoragePath)\n        self.pointer= FindViews.createViewReadPointer(address: address, path:nft.publicPath, id: id)\n\n        /* Check for nftCapability */\n        if !self.targetCapability.check() {\n            let cd = self.pointer.getNFTCollectionData()\n            // should use account.type here instead\n            if account.type(at: cd.storagePath) != nil {\n                let pathIdentifier = nft.publicPath.toString()\n                let findPath = PublicPath(identifier: pathIdentifier.slice(from: \"/public/\".length , upTo: pathIdentifier.length).concat(\"_FIND\"))!\n                account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                    findPath,\n                    target: nft.storagePath\n                )\n                self.targetCapability = account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(findPath)\n            } else {\n                account.save(\u003c- cd.createEmptyCollection(), to: cd.storagePath)\n                account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.publicPath, target: cd.storagePath)\n                account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.providerPath, target: cd.storagePath)\n            }\n\n        }\n    }\n\n    pre {\n        self.bidsReference != nil : \"This account does not have a bid collection\"\n    }\n\n    execute {\n        self.bidsReference!.bid(item:self.pointer, amount: amount, vaultType: self.ftVaultType, nftCap: self.targetCapability, validUntil: validUntil, saleItemExtraField: {}, bidExtraField: {})\n    }\n}",
               "spec": {
                  "order": [
                     "dapperAddress",
                     "marketplace",
                     "user",
                     "nftAliasOrIdentifier",
                     "id",
                     "amount",
                     "validUntil"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "dapperAddress": "Address",
                     "id": "UInt64",
                     "marketplace": "Address",
                     "nftAliasOrIdentifier": "String",
                     "user": "String",
                     "validUntil": "UFix64?"
                  }
               }
            },
            "bidMultipleMarketDirectOfferEscrowed": {
               "code": "import FindMarket from 0xf8d6e0586b0a20c7\nimport FindMarketSale from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionSoft from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FindViews from 0xf8d6e0586b0a20c7\nimport FTRegistry from 0xf8d6e0586b0a20c7\nimport NFTCatalog from 0xf8d6e0586b0a20c7\nimport FINDNFTCatalog from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\nimport FUSD from 0xf8d6e0586b0a20c7\nimport FiatToken from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport Dandy from 0xf8d6e0586b0a20c7\nimport Profile from 0xf8d6e0586b0a20c7\n\ntransaction(marketplace:Address, users: [String], nftAliasOrIdentifiers: [String], ids: [UInt64], ftAliasOrIdentifiers:[String], amounts: [UFix64], validUntil: UFix64?) {\n\n    let targetCapability : [Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e]\n    let walletReference : [\u0026FungibleToken.Vault]\n    let bidsReference: \u0026FindMarketDirectOfferEscrow.MarketBidCollection?\n    let pointer: [FindViews.ViewReadPointer]\n\n    prepare(account: AuthAccount) {\n\n        if nftAliasOrIdentifiers.length != users.length {\n            panic(\"The length of arrays passed in has to be the same\")\n        } else if nftAliasOrIdentifiers.length != ids.length {\n            panic(\"The length of arrays passed in has to be the same\")\n        } else if nftAliasOrIdentifiers.length != ftAliasOrIdentifiers.length {\n            panic(\"The length of arrays passed in has to be the same\")\n        } else if nftAliasOrIdentifiers.length != amounts.length {\n            panic(\"The length of arrays passed in has to be the same\")\n        }\n\n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n        //SYNC with register\n        //Add exising FUSD or create a new one and add it\n        let name = account.address.toString()\n        let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n        if !fusdReceiver.check() {\n            let fusd \u003c- FUSD.createEmptyVault()\n            account.save(\u003c- fusd, to: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n        }\n\n        let usdcCap = account.getCapability\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e(FiatToken.VaultReceiverPubPath)\n        if !usdcCap.check() {\n                account.save( \u003c-FiatToken.createEmptyVault(), to: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e( FiatToken.VaultReceiverPubPath, target: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FiatToken.ResourceId}\u003e( FiatToken.VaultUUIDPubPath, target: FiatToken.VaultStoragePath)\n                account.link\u003c\u0026FiatToken.Vault{FungibleToken.Balance}\u003e( FiatToken.VaultBalancePubPath, target:FiatToken.VaultStoragePath)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let dandyCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        let dandyCapPrivate= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPrivatePath)\n        if !dandyCapPrivate.check() {\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        var created=false\n        var updated=false\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        if !profile.hasWallet(\"Flow\") {\n            let flowWallet=Profile.Wallet( name:\"Flow\", receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), tags: [\"flow\"])\n    \n            profile.addWallet(flowWallet)\n            updated=true\n        }\n        if !profile.hasWallet(\"FUSD\") {\n            profile.addWallet(Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), tags: [\"fusd\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if !profile.hasWallet(\"USDC\") {\n            profile.addWallet(Profile.Wallet( name:\"USDC\", receiver:usdcCap, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(FiatToken.VaultBalancePubPath), accept: Type\u003c@FiatToken.Vault\u003e(), tags: [\"usdc\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else if updated {\n            profile.emitUpdatedEvent()\n        }\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        let doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        let doeSalePublicPath=FindMarket.getPublicPath(doeSaleType, name: tenant.name)\n        let doeSaleStoragePath= FindMarket.getStoragePath(doeSaleType, name:tenant.name)\n        let doeSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n        if !doeSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n        }\n\n        let doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        let doeBidPublicPath=FindMarket.getPublicPath(doeBidType, name: tenant.name)\n        let doeBidStoragePath= FindMarket.getStoragePath(doeBidType, name:tenant.name)\n        let doeBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n        if !doeBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n        }\n\n        /// auctions that escrow ft\n        let aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        let aeSalePublicPath=FindMarket.getPublicPath(aeSaleType, name: tenant.name)\n        let aeSaleStoragePath= FindMarket.getStoragePath(aeSaleType, name:tenant.name)\n        let aeSaleCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n        if !aeSaleCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n        }\n\n        let dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\n        let dosSalePublicPath=FindMarket.getPublicPath(dosSaleType, name: tenant.name)\n        let dosSaleStoragePath= FindMarket.getStoragePath(dosSaleType, name:tenant.name)\n\n        let dosSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n        if !dosSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n        }\n\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n        if !dosBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n        }\n\n        let aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\n        let aeBidPublicPath=FindMarket.getPublicPath(aeBidType, name: tenant.name)\n        let aeBidStoragePath= FindMarket.getStoragePath(aeBidType, name:tenant.name)\n        let aeBidCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n        if !aeBidCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n        }\n\n     /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n        }\n\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n        if !asBidCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n        }\n        //SYNC with register\n\n        let addresses : {String : Address} = {}\n        let nfts : {String : NFTCatalog.NFTCollectionData} = {}\n        let fts : {String : FTRegistry.FTInfo} = {}\n\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketSale.SaleItemCollection\u003e())\n        let vaultRefs : {StoragePath : \u0026FungibleToken.Vault} = {}\n\n        let bidStoragePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e())!\n\n        self.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection\u003e(from: bidStoragePath)\n        self.walletReference = []\n        self.pointer = []\n        self.targetCapability = []\n\n        var counter = 0\n        while counter \u003c users.length {\n            var resolveAddress : Address? = nil\n            if addresses[users[counter]] != nil {\n                resolveAddress = addresses[users[counter]]!\n            } else {\n                let address = FIND.resolve(users[counter])\n                if address == nil {\n                    panic(\"The address input is not a valid name nor address. Input : \".concat(users[counter]))\n                }\n                addresses[users[counter]] = address!\n                resolveAddress = address!\n            }\n            let address = resolveAddress!\n\n            var nft : NFTCatalog.NFTCollectionData? = nil\n            var ft : FTRegistry.FTInfo? = nil\n            let nftIdentifier = nftAliasOrIdentifiers[counter]\n            let ftIdentifier = ftAliasOrIdentifiers[counter]\n\n            if nfts[nftIdentifier] != nil {\n                nft = nfts[nftIdentifier]\n            } else {\n                let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier)) \n                let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n                nft =  collection.collectionData\n\n                nfts[nftIdentifier] = nft\n            }\n\n            if fts[ftIdentifier] != nil {\n                ft = fts[ftIdentifier]\n            } else {\n                ft = FTRegistry.getFTInfo(ftIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftIdentifier))\n                fts[ftIdentifier] = ft \n            }\n        \n            if vaultRefs[ft!.vaultPath] != nil {\n                self.walletReference.append(vaultRefs[ft!.vaultPath]!)\n            } else {\n                let walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft!.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n                vaultRefs[ft!.vaultPath] = walletReference\n                self.walletReference.append(walletReference)\n            }\n\n            let pointer= FindViews.createViewReadPointer(address: address, path:nft!.publicPath, id: ids[counter])\n            self.pointer.append(pointer)\n\n            var targetCapability= account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(nft!.publicPath)\n            /* Check for nftCapability */\n            if !targetCapability.check() {\n                let cd = pointer.getNFTCollectionData()\n                // should use account.type here instead\n                if account.type(at: cd.storagePath) != nil {\n                    let pathIdentifier = nft!.publicPath.toString()\n                    let findPath = PublicPath(identifier: pathIdentifier.slice(from: \"/public/\".length , upTo: pathIdentifier.length).concat(\"_FIND\"))!\n                    account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                        findPath,\n                        target: nft!.storagePath\n                    )\n                    targetCapability = account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(findPath)\n                } else {\n                    account.save(\u003c- cd.createEmptyCollection(), to: cd.storagePath)\n                    account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.publicPath, target: cd.storagePath)\n                    account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.providerPath, target: cd.storagePath)\n                }\n\n            }\n            self.targetCapability.append(targetCapability)\n            counter = counter + 1\n        }\n    }\n\n    pre {\n        self.bidsReference != nil : \"This account does not have a bid collection\"\n    }\n\n    execute {\n        var counter = 0\n        while counter \u003c ids.length {\n            if self.walletReference[counter].balance \u003c amounts[counter] {\n                panic(\"Your wallet does not have enough funds to pay for this item. Fund Type : \".concat(ftAliasOrIdentifiers[counter]).concat(\"Required Amount : \").concat(amounts[counter].toString()))\n            }\n            let vault \u003c- self.walletReference[counter].withdraw(amount: amounts[counter]) \n            self.bidsReference!.bid(item:self.pointer[counter], vault: \u003c- vault, nftCap: self.targetCapability[counter], validUntil: validUntil, saleItemExtraField: {}, bidExtraField: {})\n            counter = counter + 1\n        }\n    }\n\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "users",
                     "nftAliasOrIdentifiers",
                     "ids",
                     "ftAliasOrIdentifiers",
                     "amounts",
                     "validUntil"
                  ],
                  "parameters": {
                     "amounts": "[UFix64]",
                     "ftAliasOrIdentifiers": "[String]",
                     "ids": "[UInt64]",
                     "marketplace": "Address",
                     "nftAliasOrIdentifiers": "[String]",
                     "users": "[String]",
                     "validUntil": "UFix64?"
                  }
               }
            },
            "bidMultipleMarketDirectOfferSoft": {
               "code": "import FindMarketSale from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionSoft from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\nimport FindMarket from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FindViews from 0xf8d6e0586b0a20c7\nimport FTRegistry from 0xf8d6e0586b0a20c7\nimport NFTCatalog from 0xf8d6e0586b0a20c7\nimport FINDNFTCatalog from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\nimport FUSD from 0xf8d6e0586b0a20c7\nimport FiatToken from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport Dandy from 0xf8d6e0586b0a20c7\nimport Profile from 0xf8d6e0586b0a20c7\n\ntransaction(marketplace:Address, users: [String], nftAliasOrIdentifiers: [String], ids: [UInt64], ftAliasOrIdentifiers:[String], amounts: [UFix64], validUntil: UFix64?) {\n\n    let targetCapability : [Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e]\n    let walletReference : [\u0026FungibleToken.Vault]\n    let bidsReference: \u0026FindMarketDirectOfferSoft.MarketBidCollection?\n    let pointer: [FindViews.ViewReadPointer]\n    let ftVaultType: [Type]\n    let totalPrice : {String : UFix64}\n\n    prepare(account: AuthAccount) {\n\n        if nftAliasOrIdentifiers.length != users.length {\n            panic(\"The length of arrays passed in has to be the same\")\n        } else if nftAliasOrIdentifiers.length != ids.length {\n            panic(\"The length of arrays passed in has to be the same\")\n        } else if nftAliasOrIdentifiers.length != ftAliasOrIdentifiers.length {\n            panic(\"The length of arrays passed in has to be the same\")\n        } else if nftAliasOrIdentifiers.length != amounts.length {\n            panic(\"The length of arrays passed in has to be the same\")\n        }\n        \n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n        //SYNC with register\n        //Add exising FUSD or create a new one and add it\n        let name = account.address.toString()\n        let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n        if !fusdReceiver.check() {\n            let fusd \u003c- FUSD.createEmptyVault()\n            account.save(\u003c- fusd, to: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n        }\n\n        let usdcCap = account.getCapability\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e(FiatToken.VaultReceiverPubPath)\n        if !usdcCap.check() {\n                account.save( \u003c-FiatToken.createEmptyVault(), to: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e( FiatToken.VaultReceiverPubPath, target: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FiatToken.ResourceId}\u003e( FiatToken.VaultUUIDPubPath, target: FiatToken.VaultStoragePath)\n                account.link\u003c\u0026FiatToken.Vault{FungibleToken.Balance}\u003e( FiatToken.VaultBalancePubPath, target:FiatToken.VaultStoragePath)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let dandyCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        let dandyCapPrivate= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPrivatePath)\n        if !dandyCapPrivate.check() {\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        var created=false\n        var updated=false\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        if !profile.hasWallet(\"Flow\") {\n            let flowWallet=Profile.Wallet( name:\"Flow\", receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), tags: [\"flow\"])\n    \n            profile.addWallet(flowWallet)\n            updated=true\n        }\n        if !profile.hasWallet(\"FUSD\") {\n            profile.addWallet(Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), tags: [\"fusd\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if !profile.hasWallet(\"USDC\") {\n            profile.addWallet(Profile.Wallet( name:\"USDC\", receiver:usdcCap, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(FiatToken.VaultBalancePubPath), accept: Type\u003c@FiatToken.Vault\u003e(), tags: [\"usdc\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else if updated {\n            profile.emitUpdatedEvent()\n        }\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        let doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        let doeSalePublicPath=FindMarket.getPublicPath(doeSaleType, name: tenant.name)\n        let doeSaleStoragePath= FindMarket.getStoragePath(doeSaleType, name:tenant.name)\n        let doeSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n        if !doeSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n        }\n\n        let doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        let doeBidPublicPath=FindMarket.getPublicPath(doeBidType, name: tenant.name)\n        let doeBidStoragePath= FindMarket.getStoragePath(doeBidType, name:tenant.name)\n        let doeBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n        if !doeBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n        }\n\n        /// auctions that escrow ft\n        let aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        let aeSalePublicPath=FindMarket.getPublicPath(aeSaleType, name: tenant.name)\n        let aeSaleStoragePath= FindMarket.getStoragePath(aeSaleType, name:tenant.name)\n        let aeSaleCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n        if !aeSaleCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n        }\n\n        let dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\n        let dosSalePublicPath=FindMarket.getPublicPath(dosSaleType, name: tenant.name)\n        let dosSaleStoragePath= FindMarket.getStoragePath(dosSaleType, name:tenant.name)\n\n        let dosSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n        if !dosSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n        }\n\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n        if !dosBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n        }\n\n        let aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\n        let aeBidPublicPath=FindMarket.getPublicPath(aeBidType, name: tenant.name)\n        let aeBidStoragePath= FindMarket.getStoragePath(aeBidType, name:tenant.name)\n        let aeBidCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n        if !aeBidCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n        }\n\n     /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n        }\n\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n        if !asBidCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n        }\n        //SYNC with register\n\n        let addresses : {String : Address} = {}\n        let nfts : {String : NFTCatalog.NFTCollectionData} = {}\n        let fts : {String : FTRegistry.FTInfo} = {}\n        let vaultRefs : {StoragePath : \u0026FungibleToken.Vault} = {}\n        \n\n        let bidStoragePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())!\n        self.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection\u003e(from: bidStoragePath)\n        self.walletReference = []\n        self.pointer = []\n        self.targetCapability = []\n        self.ftVaultType = []\n        self.totalPrice = {}\n\n        var counter = 0\n        while counter \u003c users.length {\n            var resolveAddress : Address? = nil\n            if addresses[users[counter]] != nil {\n                resolveAddress = addresses[users[counter]]!\n            } else {\n                let address = FIND.resolve(users[counter])\n                if address == nil {\n                    panic(\"The address input is not a valid name nor address. Input : \".concat(users[counter]))\n                }\n                addresses[users[counter]] = address!\n                resolveAddress = address!\n            }\n            let address = resolveAddress!\n\n            var nft : NFTCatalog.NFTCollectionData? = nil\n            var ft : FTRegistry.FTInfo? = nil\n            let nftIdentifier = nftAliasOrIdentifiers[counter]\n            let ftIdentifier = ftAliasOrIdentifiers[counter]\n\n            if nfts[nftIdentifier] != nil {\n                nft = nfts[nftIdentifier]\n            } else {\n                let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier)) \n                let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n                nft = collection.collectionData\n                nfts[nftIdentifier] = nft\n            }\n\n            if fts[ftIdentifier] != nil {\n                ft = fts[ftIdentifier]\n            } else {\n                ft = FTRegistry.getFTInfo(ftIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftIdentifier))\n                fts[ftIdentifier] = ft \n            }\n        \n            if vaultRefs[ft!.vaultPath] != nil {\n                self.walletReference.append(vaultRefs[ft!.vaultPath]!)\n                self.ftVaultType.append(vaultRefs[ft!.vaultPath]!.getType())\n            } else {\n                let walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft!.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n                vaultRefs[ft!.vaultPath] = walletReference\n                self.walletReference.append(walletReference)\n                self.ftVaultType.append(ft!.type)\n            }\n\n            if self.totalPrice[ftIdentifier] == nil {\n                self.totalPrice[ftIdentifier] = amounts[counter]\n            } else {\n                self.totalPrice[ftIdentifier] = self.totalPrice[ftIdentifier]! + amounts[counter]\n            }\n\n            let pointer= FindViews.createViewReadPointer(address: address, path:nft!.publicPath, id: ids[counter])\n            self.pointer.append(pointer)\n\n            var targetCapability= account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(nft!.publicPath)\n\n            /* Check for nftCapability */\n            if !targetCapability.check() {\n                let cd = pointer.getNFTCollectionData()\n                // should use account.type here instead\n                if account.type(at: cd.storagePath) != nil {\n                    let pathIdentifier = nft!.publicPath.toString()\n                    let findPath = PublicPath(identifier: pathIdentifier.slice(from: \"/public/\".length , upTo: pathIdentifier.length).concat(\"_FIND\"))!\n                    account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                        findPath,\n                        target: nft!.storagePath\n                    )\n                    targetCapability = account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(findPath)\n                } else {\n                    account.save(\u003c- cd.createEmptyCollection(), to: cd.storagePath)\n                    account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.publicPath, target: cd.storagePath)\n                    account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.providerPath, target: cd.storagePath)\n                }\n\n            }\n            self.targetCapability.append(targetCapability)\n            counter = counter + 1\n        }\n    }\n\n    pre {\n        self.bidsReference != nil : \"This account does not have a bid collection\"\n    }\n\n    execute {\n        var counter = 0\n        while counter \u003c ids.length {\n            if self.walletReference[counter].balance \u003c self.totalPrice[ftAliasOrIdentifiers[counter]]! {\n                panic(\"Your wallet does not have enough funds to pay for this item. Vault Type : \".concat(self.ftVaultType[counter].getType().identifier).concat(\" . Required : \".concat(self.totalPrice[ftAliasOrIdentifiers[counter]]!.toString())))\n            }    \n            self.bidsReference!.bid(item:self.pointer[counter], amount: amounts[counter], vaultType: self.ftVaultType[counter], nftCap: self.targetCapability[counter], validUntil: validUntil, saleItemExtraField: {}, bidExtraField: {})\n            counter = counter + 1 \n        }\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "users",
                     "nftAliasOrIdentifiers",
                     "ids",
                     "ftAliasOrIdentifiers",
                     "amounts",
                     "validUntil"
                  ],
                  "parameters": {
                     "amounts": "[UFix64]",
                     "ftAliasOrIdentifiers": "[String]",
                     "ids": "[UInt64]",
                     "marketplace": "Address",
                     "nftAliasOrIdentifiers": "[String]",
                     "users": "[String]",
                     "validUntil": "UFix64?"
                  }
               }
            },
            "bidMultipleMarketDirectOfferSoftDUC": {
               "code": "import FindMarketSale from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionSoft from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\nimport FindMarket from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FindViews from 0xf8d6e0586b0a20c7\nimport NFTCatalog from 0xf8d6e0586b0a20c7\nimport FINDNFTCatalog from 0xf8d6e0586b0a20c7\nimport FTRegistry from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport TokenForwarding from 0xf8d6e0586b0a20c7\nimport DapperUtilityCoin from 0xf8d6e0586b0a20c7\nimport Dandy from 0xf8d6e0586b0a20c7\nimport Profile from 0xf8d6e0586b0a20c7\n\ntransaction(dapperAddress: Address, marketplace:Address, users: [String], nftAliasOrIdentifiers: [String], ids: [UInt64], amounts: [UFix64], validUntil: UFix64?) {\n\n    let targetCapability : [Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e]\n    let bidsReference: \u0026FindMarketDirectOfferSoft.MarketBidCollection?\n    let pointer: [FindViews.ViewReadPointer]\n\n    prepare(account: AuthAccount) {\n\n        if nftAliasOrIdentifiers.length != users.length {\n            panic(\"The length of arrays passed in has to be the same\")\n        } else if nftAliasOrIdentifiers.length != ids.length {\n            panic(\"The length of arrays passed in has to be the same\")\n        } else if nftAliasOrIdentifiers.length != amounts.length {\n            panic(\"The length of arrays passed in has to be the same\")\n        }\n        \n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n        //SYNC with register\n        //Add exising FUSD or create a new one and add it\n        let name = account.address.toString()\n        let ducReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver)\n        if !ducReceiver.check() {\n            let dapper = getAccount(dapperAddress)\n            // Create a new Forwarder resource for DUC and store it in the new account's storage\n            let ducForwarder \u003c- TokenForwarding.createNewForwarder(recipient: dapper.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver))\n            account.save(\u003c-ducForwarder, to: /storage/dapperUtilityCoinReceiver)\n            // Publish a Receiver capability for the new account, which is linked to the DUC Forwarder\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver,target: /storage/dapperUtilityCoinReceiver)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: ducReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let dandyCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        let dandyCapPrivate= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPrivatePath)\n        if !dandyCapPrivate.check() {\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        var created=false\n        var updated=false\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        if !profile.hasWallet(\"Flow\") {\n            let flowWallet=Profile.Wallet( name:\"Flow\", receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), tags: [\"flow\"])\n    \n            profile.addWallet(flowWallet)\n            updated=true\n        }\n        if !profile.hasWallet(\"DUC\") {\n            profile.addWallet(Profile.Wallet( name:\"DUC\", receiver:ducReceiver, balance:getAccount(dapperAddress).getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/dapperUtilityCoinBalance), accept: Type\u003c@DapperUtilityCoin.Vault\u003e(), tags: [\"duc\", \"dapperUtilityCoin\",\"dapper\"]))\n            updated=true\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else {\n            profile.emitUpdatedEvent()\n        }\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        let doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        let doeSalePublicPath=FindMarket.getPublicPath(doeSaleType, name: tenant.name)\n        let doeSaleStoragePath= FindMarket.getStoragePath(doeSaleType, name:tenant.name)\n        let doeSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n        if !doeSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n        }\n\n        let doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        let doeBidPublicPath=FindMarket.getPublicPath(doeBidType, name: tenant.name)\n        let doeBidStoragePath= FindMarket.getStoragePath(doeBidType, name:tenant.name)\n        let doeBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n        if !doeBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n        }\n\n        /// auctions that escrow ft\n        let aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        let aeSalePublicPath=FindMarket.getPublicPath(aeSaleType, name: tenant.name)\n        let aeSaleStoragePath= FindMarket.getStoragePath(aeSaleType, name:tenant.name)\n        let aeSaleCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n        if !aeSaleCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n        }\n\n        let dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\n        let dosSalePublicPath=FindMarket.getPublicPath(dosSaleType, name: tenant.name)\n        let dosSaleStoragePath= FindMarket.getStoragePath(dosSaleType, name:tenant.name)\n\n        let dosSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n        if !dosSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n        }\n\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n        if !dosBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n        }\n\n        let aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\n        let aeBidPublicPath=FindMarket.getPublicPath(aeBidType, name: tenant.name)\n        let aeBidStoragePath= FindMarket.getStoragePath(aeBidType, name:tenant.name)\n        let aeBidCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n        if !aeBidCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n        }\n\n     /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n        }\n\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n        if !asBidCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n        }\n        //SYNC with register\n\n        let addresses : {String : Address} = {}\n        let nfts : {String : NFTCatalog.NFTCollectionData} = {}\n        let fts : {String : FTRegistry.FTInfo} = {}\n\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketSale.SaleItemCollection\u003e())\n        let vaultRefs : {StoragePath : \u0026FungibleToken.Vault} = {}\n\n\n        let bidStoragePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())!\n        self.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection\u003e(from: bidStoragePath)\n        \n        self.pointer = []\n        self.targetCapability = []\n\n        var counter = 0\n        while counter \u003c users.length {\n            var resolveAddress : Address? = nil\n            if addresses[users[counter]] != nil {\n                resolveAddress = addresses[users[counter]]!\n            } else {\n                let address = FIND.resolve(users[counter])\n                if address == nil {\n                    panic(\"The address input is not a valid name nor address. Input : \".concat(users[counter]))\n                }\n                addresses[users[counter]] = address!\n                resolveAddress = address!\n            }\n            let address = resolveAddress!\n\n            var nft : NFTCatalog.NFTCollectionData? = nil\n            let nftIdentifier = nftAliasOrIdentifiers[counter]\n\n            if nfts[nftIdentifier] != nil {\n                nft = nfts[nftIdentifier]\n            } else {\n                let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier)) \n                let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n                nft = collection.collectionData\n                nfts[nftIdentifier] = nft\n            }\n\n\n            let pointer= FindViews.createViewReadPointer(address: address, path:nft!.publicPath, id: ids[counter])\n            self.pointer.append(pointer)\n\n            var targetCapability= account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(nft!.publicPath)\n\n            /* Check for nftCapability */\n            if !targetCapability.check() {\n                let cd = pointer.getNFTCollectionData()\n                // should use account.type here instead\n                if account.type(at: cd.storagePath) != nil {\n                    let pathIdentifier = nft!.publicPath.toString()\n                    let findPath = PublicPath(identifier: pathIdentifier.slice(from: \"/public/\".length , upTo: pathIdentifier.length).concat(\"_FIND\"))!\n                    account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                        findPath,\n                        target: nft!.storagePath\n                    )\n                    targetCapability = account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(findPath)\n                } else {\n                    account.save(\u003c- cd.createEmptyCollection(), to: cd.storagePath)\n                    account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.publicPath, target: cd.storagePath)\n                    account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.providerPath, target: cd.storagePath)\n                }\n\n            }\n            self.targetCapability.append(targetCapability)\n            counter = counter + 1\n        }\n    }\n\n    pre {\n        self.bidsReference != nil : \"This account does not have a bid collection\"\n    }\n\n    execute {\n        var counter = 0\n        while counter \u003c ids.length {\n            self.bidsReference!.bid(item:self.pointer[counter], amount: amounts[counter], vaultType: Type\u003c@DapperUtilityCoin.Vault\u003e(), nftCap: self.targetCapability[counter], validUntil: validUntil, saleItemExtraField: {}, bidExtraField: {})\n            counter = counter + 1\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "dapperAddress",
                     "marketplace",
                     "users",
                     "nftAliasOrIdentifiers",
                     "ids",
                     "amounts",
                     "validUntil"
                  ],
                  "parameters": {
                     "amounts": "[UFix64]",
                     "dapperAddress": "Address",
                     "ids": "[UInt64]",
                     "marketplace": "Address",
                     "nftAliasOrIdentifiers": "[String]",
                     "users": "[String]",
                     "validUntil": "UFix64?"
                  }
               }
            },
            "bidName": {
               "code": "import FungibleToken from 0xee82856bf20e2aa6\nimport FUSD from 0xf8d6e0586b0a20c7\nimport FiatToken from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport Profile from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\nimport Dandy from 0xf8d6e0586b0a20c7\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FindMarketSale from 0xf8d6e0586b0a20c7\nimport FindMarket from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionSoft from 0xf8d6e0586b0a20c7\nimport FindLeaseMarketSale from 0xf8d6e0586b0a20c7\nimport FindLeaseMarketAuctionSoft from 0xf8d6e0586b0a20c7\n// import FindLeaseMarketAuctionEscrow from \"../contracts/FindLeaseMarketAuctionEscrow.cdc\"\nimport FindLeaseMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\n// import FindLeaseMarketDirectOfferEscrow from \"../contracts/FindLeaseMarketDirectOfferEscrow.cdc\"\nimport FindLeaseMarket from 0xf8d6e0586b0a20c7\n\ntransaction(name: String, amount: UFix64) {\n\n    let vaultRef : \u0026FUSD.Vault?\n    let bidRef : \u0026FIND.BidCollection?\n\n    prepare(account: AuthAccount) {\n\n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n        //SYNC with register\n        //Add exising FUSD or create a new one and add it\n        let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n        if !fusdReceiver.check() {\n            let fusd \u003c- FUSD.createEmptyVault()\n            account.save(\u003c- fusd, to: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n        }\n\n        let usdcCap = account.getCapability\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e(FiatToken.VaultReceiverPubPath)\n        if !usdcCap.check() {\n                account.save( \u003c-FiatToken.createEmptyVault(), to: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e( FiatToken.VaultReceiverPubPath, target: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FiatToken.ResourceId}\u003e( FiatToken.VaultUUIDPubPath, target: FiatToken.VaultStoragePath)\n                account.link\u003c\u0026FiatToken.Vault{FungibleToken.Balance}\u003e( FiatToken.VaultBalancePubPath, target:FiatToken.VaultStoragePath)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let dandyCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        var created=false\n        var updated=true\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        if !profile.hasWallet(\"Flow\") {\n            let flowWallet=Profile.Wallet( name:\"Flow\", receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), tags: [\"flow\"])\n    \n            profile.addWallet(flowWallet)\n            updated=true\n        }\n        if !profile.hasWallet(\"FUSD\") {\n            profile.addWallet(Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), tags: [\"fusd\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if !profile.hasWallet(\"USDC\") {\n            profile.addWallet(Profile.Wallet( name:\"USDC\", receiver:usdcCap, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(FiatToken.VaultBalancePubPath), accept: Type\u003c@FiatToken.Vault\u003e(), tags: [\"usdc\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else if updated {\n            profile.emitUpdatedEvent()\n        }\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let tenantCapability= FindMarket.getTenantCapability(FindMarket.getFindTenantAddress())!\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        let doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        let doeSalePublicPath=FindMarket.getPublicPath(doeSaleType, name: tenant.name)\n        let doeSaleStoragePath= FindMarket.getStoragePath(doeSaleType, name:tenant.name)\n        let doeSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n        if !doeSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n        }\n\n        let doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        let doeBidPublicPath=FindMarket.getPublicPath(doeBidType, name: tenant.name)\n        let doeBidStoragePath= FindMarket.getStoragePath(doeBidType, name:tenant.name)\n        let doeBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n        if !doeBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n        }\n\n        /// auctions that escrow ft\n        let aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        let aeSalePublicPath=FindMarket.getPublicPath(aeSaleType, name: tenant.name)\n        let aeSaleStoragePath= FindMarket.getStoragePath(aeSaleType, name:tenant.name)\n        let aeSaleCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n        if !aeSaleCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n        }\n\n        let dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\n        let dosSalePublicPath=FindMarket.getPublicPath(dosSaleType, name: tenant.name)\n        let dosSaleStoragePath= FindMarket.getStoragePath(dosSaleType, name:tenant.name)\n\n        let dosSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n        if !dosSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n        }\n\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n        if !dosBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n        }\n\n        let aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\n        let aeBidPublicPath=FindMarket.getPublicPath(aeBidType, name: tenant.name)\n        let aeBidStoragePath= FindMarket.getStoragePath(aeBidType, name:tenant.name)\n        let aeBidCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n        if !aeBidCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n        }\n\n     /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n        }\n\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n        if !asBidCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n        }\n\n        let leaseTenantCapability= FindMarket.getTenantCapability(FindMarket.getTenantAddress(\"findLease\")!)!\n\n        let leaseSaleItemType= Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()\n        let leasePublicPath=FindMarket.getPublicPath(leaseSaleItemType, name: \"findLease\")\n        let leaseStoragePath= FindMarket.getStoragePath(leaseSaleItemType, name:\"findLease\")\n        let leaseSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath) \n        if !leaseSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketSale.SaleItemCollection\u003e(\u003c- FindLeaseMarketSale.createEmptySaleItemCollection(leaseTenantCapability), to: leaseStoragePath)\n            account.link\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath, target: leaseStoragePath)\n        }\n\n        let leaseASSaleItemType= Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e()\n        let leaseASPublicPath=FindMarket.getPublicPath(leaseASSaleItemType, name: \"findLease\")\n        let leaseASStoragePath= FindMarket.getStoragePath(leaseASSaleItemType, name:\"findLease\")\n        let leaseASSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath) \n        if !leaseASSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseASStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath, target: leaseASStoragePath)\n        }\n\n\n        let leaseASBidType= Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e()\n        let leaseASBidPublicPath=FindMarket.getPublicPath(leaseASBidType, name: \"findLease\")\n        let leaseASBidStoragePath= FindMarket.getStoragePath(leaseASBidType, name: \"findLease\")\n        let leaseASBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath) \n        if !leaseASBidCap.check() {\n            account.save\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseASBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath, target: leaseASBidStoragePath)\n        }\n\n        // let leaseAESaleItemType= Type\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e()\n        // let leaseAEPublicPath=FindMarket.getPublicPath(leaseAESaleItemType, name: \"findLease\")\n        // let leaseAEStoragePath= FindMarket.getStoragePath(leaseAESaleItemType, name:\"findLease\")\n        // let leaseAESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath) \n        // if !leaseAESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseAEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath, target: leaseAEStoragePath)\n        // }\n\n        // let leaseAEBidType= Type\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e()\n        // let leaseAEBidPublicPath=FindMarket.getPublicPath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidStoragePath= FindMarket.getStoragePath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath) \n        // if !leaseAEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseAEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath, target: leaseAEBidStoragePath)\n        // }\n\n        let leaseDOSSaleItemType= Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e()\n        let leaseDOSPublicPath=FindMarket.getPublicPath(leaseDOSSaleItemType, name: \"findLease\")\n        let leaseDOSStoragePath= FindMarket.getStoragePath(leaseDOSSaleItemType, name:\"findLease\")\n        let leaseDOSSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath) \n        if !leaseDOSSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOSStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath, target: leaseDOSStoragePath)\n        }\n\n        let leaseDOSBidType= Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let leaseDOSBidPublicPath=FindMarket.getPublicPath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidStoragePath= FindMarket.getStoragePath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath) \n        if !leaseDOSBidCap.check() {\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOSBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath, target: leaseDOSBidStoragePath)\n        }\n\n        // let leaseDOESaleItemType= Type\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        // let leaseDOEPublicPath=FindMarket.getPublicPath(leaseDOESaleItemType, name: \"findLease\")\n        // let leaseDOEStoragePath= FindMarket.getStoragePath(leaseDOESaleItemType, name:\"findLease\")\n        // let leaseDOESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath) \n        // if !leaseDOESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath, target: leaseDOEStoragePath)\n        // }\n\n        // let leaseDOEBidType= Type\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        // let leaseDOEBidPublicPath=FindMarket.getPublicPath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidStoragePath= FindMarket.getStoragePath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath) \n        // if !leaseDOEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath, target: leaseDOEBidStoragePath)\n        // }\n        //SYNC with register\n\n        self.vaultRef = account.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault)\n        self.bidRef = account.borrow\u003c\u0026FIND.BidCollection\u003e(from: FIND.BidStoragePath)\n    }\n\n    pre{\n        self.vaultRef != nil : \"Could not borrow reference to the fusdVault!\" \n        self.bidRef != nil : \"Could not borrow reference to the bid collection!\" \n    }\n\n    execute {\n        let vault \u003c- self.vaultRef!.withdraw(amount: amount) as! @FUSD.Vault\n        self.bidRef!.bid(name: name, vault: \u003c- vault)\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "name": "String"
                  }
               }
            },
            "buyAddon": {
               "code": "import FUSD from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\n\n\ntransaction(name: String, addon:String, amount:UFix64) {\n\n    let leases : \u0026FIND.LeaseCollection?\n    let vaultRef : \u0026FUSD.Vault? \n\n    prepare(account: AuthAccount) {\n\n        self.leases= account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)\n        self.vaultRef = account.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault)\n\n    }\n\n    pre{\n        self.leases != nil : \"Could not borrow reference to the leases collection\"\n        self.vaultRef != nil : \"Could not borrow reference to the fusdVault!\"\n    }\n\n    execute {\n        let vault \u003c- self.vaultRef!.withdraw(amount: amount) as! @FUSD.Vault\n        self.leases!.buyAddon(name: name, addon: addon, vault: \u003c- vault)\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "addon",
                     "amount"
                  ],
                  "parameters": {
                     "addon": "String",
                     "amount": "UFix64",
                     "name": "String"
                  }
               }
            },
            "buyLeaseForSale": {
               "code": "import FindMarket from 0xf8d6e0586b0a20c7\nimport FindMarketSale from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionSoft from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FTRegistry from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FUSD from 0xf8d6e0586b0a20c7\nimport FiatToken from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport FIND from 0xf8d6e0586b0a20c7\nimport Dandy from 0xf8d6e0586b0a20c7\nimport Profile from 0xf8d6e0586b0a20c7\nimport FindLeaseMarketSale from 0xf8d6e0586b0a20c7\nimport FindLeaseMarketAuctionSoft from 0xf8d6e0586b0a20c7\n// import FindLeaseMarketAuctionEscrow from \"../contracts/FindLeaseMarketAuctionEscrow.cdc\"\nimport FindLeaseMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\n// import FindLeaseMarketDirectOfferEscrow from \"../contracts/FindLeaseMarketDirectOfferEscrow.cdc\"\nimport FindLeaseMarket from 0xf8d6e0586b0a20c7\n\ntransaction(leaseName: String, amount: UFix64) {\n\n    let targetCapability : Capability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e\n    let walletReference : \u0026FungibleToken.Vault\n\n    let saleItemsCap: Capability\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e\n    let buyer: Address\n\n    prepare(account: AuthAccount) {\n\n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n        //SYNC with register\n        //Add exising FUSD or create a new one and add it\n        let name = account.address.toString()\n        let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n        if !fusdReceiver.check() {\n            let fusd \u003c- FUSD.createEmptyVault()\n            account.save(\u003c- fusd, to: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n        }\n\n        let usdcCap = account.getCapability\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e(FiatToken.VaultReceiverPubPath)\n        if !usdcCap.check() {\n            account.save( \u003c-FiatToken.createEmptyVault(), to: FiatToken.VaultStoragePath)\n            account.link\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e( FiatToken.VaultReceiverPubPath, target: FiatToken.VaultStoragePath)\n            account.link\u003c\u0026FiatToken.Vault{FiatToken.ResourceId}\u003e( FiatToken.VaultUUIDPubPath, target: FiatToken.VaultStoragePath)\n            account.link\u003c\u0026FiatToken.Vault{FungibleToken.Balance}\u003e( FiatToken.VaultBalancePubPath, target:FiatToken.VaultStoragePath)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let dandyCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        let dandyCapPrivate= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPrivatePath)\n        if !dandyCapPrivate.check() {\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        var created=false\n        var updated=false\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        if !profile.hasWallet(\"Flow\") {\n            let flowWallet=Profile.Wallet( name:\"Flow\", receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), tags: [\"flow\"])\n    \n            profile.addWallet(flowWallet)\n            updated=true\n        }\n        if !profile.hasWallet(\"FUSD\") {\n            profile.addWallet(Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), tags: [\"fusd\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if !profile.hasWallet(\"USDC\") {\n            profile.addWallet(Profile.Wallet( name:\"USDC\", receiver:usdcCap, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(FiatToken.VaultBalancePubPath), accept: Type\u003c@FiatToken.Vault\u003e(), tags: [\"usdc\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else if updated {\n            profile.emitUpdatedEvent()\n        }\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let tenantCapability= FindMarket.getTenantCapability(FindMarket.getFindTenantAddress())!\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        let doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        let doeSalePublicPath=FindMarket.getPublicPath(doeSaleType, name: tenant.name)\n        let doeSaleStoragePath= FindMarket.getStoragePath(doeSaleType, name:tenant.name)\n        let doeSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n        if !doeSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n        }\n\n        let doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        let doeBidPublicPath=FindMarket.getPublicPath(doeBidType, name: tenant.name)\n        let doeBidStoragePath= FindMarket.getStoragePath(doeBidType, name:tenant.name)\n        let doeBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n        if !doeBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n        }\n\n        /// auctions that escrow ft\n        let aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        let aeSalePublicPath=FindMarket.getPublicPath(aeSaleType, name: tenant.name)\n        let aeSaleStoragePath= FindMarket.getStoragePath(aeSaleType, name:tenant.name)\n        let aeSaleCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n        if !aeSaleCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n        }\n\n        let dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\n        let dosSalePublicPath=FindMarket.getPublicPath(dosSaleType, name: tenant.name)\n        let dosSaleStoragePath= FindMarket.getStoragePath(dosSaleType, name:tenant.name)\n\n        let dosSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n        if !dosSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n        }\n\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n        if !dosBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n        }\n\n        let aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\n        let aeBidPublicPath=FindMarket.getPublicPath(aeBidType, name: tenant.name)\n        let aeBidStoragePath= FindMarket.getStoragePath(aeBidType, name:tenant.name)\n        let aeBidCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n        if !aeBidCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n        }\n\n     /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n        }\n\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n        if !asBidCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n        }\n\n        let leaseTenantCapability= FindMarket.getTenantCapability(FindMarket.getTenantAddress(\"findLease\")!)!\n\n        let leaseSaleItemType= Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()\n        let leasePublicPath=FindMarket.getPublicPath(leaseSaleItemType, name: \"findLease\")\n        let leaseStoragePath= FindMarket.getStoragePath(leaseSaleItemType, name:\"findLease\")\n        let leaseSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath) \n        if !leaseSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketSale.SaleItemCollection\u003e(\u003c- FindLeaseMarketSale.createEmptySaleItemCollection(leaseTenantCapability), to: leaseStoragePath)\n            account.link\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath, target: leaseStoragePath)\n        }\n\n        let leaseASSaleItemType= Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e()\n        let leaseASPublicPath=FindMarket.getPublicPath(leaseASSaleItemType, name: \"findLease\")\n        let leaseASStoragePath= FindMarket.getStoragePath(leaseASSaleItemType, name:\"findLease\")\n        let leaseASSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath) \n        if !leaseASSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseASStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath, target: leaseASStoragePath)\n        }\n\n\n        let leaseASBidType= Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e()\n        let leaseASBidPublicPath=FindMarket.getPublicPath(leaseASBidType, name: \"findLease\")\n        let leaseASBidStoragePath= FindMarket.getStoragePath(leaseASBidType, name: \"findLease\")\n        let leaseASBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath) \n        if !leaseASBidCap.check() {\n            account.save\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseASBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath, target: leaseASBidStoragePath)\n        }\n\n        // let leaseAESaleItemType= Type\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e()\n        // let leaseAEPublicPath=FindMarket.getPublicPath(leaseAESaleItemType, name: \"findLease\")\n        // let leaseAEStoragePath= FindMarket.getStoragePath(leaseAESaleItemType, name:\"findLease\")\n        // let leaseAESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath) \n        // if !leaseAESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseAEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath, target: leaseAEStoragePath)\n        // }\n\n        // let leaseAEBidType= Type\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e()\n        // let leaseAEBidPublicPath=FindMarket.getPublicPath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidStoragePath= FindMarket.getStoragePath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath) \n        // if !leaseAEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseAEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath, target: leaseAEBidStoragePath)\n        // }\n\n        let leaseDOSSaleItemType= Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e()\n        let leaseDOSPublicPath=FindMarket.getPublicPath(leaseDOSSaleItemType, name: \"findLease\")\n        let leaseDOSStoragePath= FindMarket.getStoragePath(leaseDOSSaleItemType, name:\"findLease\")\n        let leaseDOSSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath) \n        if !leaseDOSSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOSStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath, target: leaseDOSStoragePath)\n        }\n\n        let leaseDOSBidType= Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let leaseDOSBidPublicPath=FindMarket.getPublicPath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidStoragePath= FindMarket.getStoragePath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath) \n        if !leaseDOSBidCap.check() {\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOSBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath, target: leaseDOSBidStoragePath)\n        }\n\n        // let leaseDOESaleItemType= Type\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        // let leaseDOEPublicPath=FindMarket.getPublicPath(leaseDOESaleItemType, name: \"findLease\")\n        // let leaseDOEStoragePath= FindMarket.getStoragePath(leaseDOESaleItemType, name:\"findLease\")\n        // let leaseDOESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath) \n        // if !leaseDOESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath, target: leaseDOEStoragePath)\n        // }\n\n        // let leaseDOEBidType= Type\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        // let leaseDOEBidPublicPath=FindMarket.getPublicPath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidStoragePath= FindMarket.getStoragePath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath) \n        // if !leaseDOEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath, target: leaseDOEBidStoragePath)\n        // }\n        //SYNC with register\n\n        let resolveAddress = FIND.resolve(leaseName)\n        if resolveAddress == nil {\n            panic(\"The address input is not a valid name nor address. Input : \".concat(leaseName))\n        }\n        let address = resolveAddress!\n        let leaseMarketplace = FindMarket.getTenantAddress(\"findLease\")!\n        self.saleItemsCap= FindLeaseMarketSale.getSaleItemCapability(marketplace: leaseMarketplace, user:address) ?? panic(\"cannot find lease sale item cap\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e())\n\n        let item= FindLeaseMarket.assertOperationValid(tenant: leaseMarketplace, name: leaseName, marketOption: marketOption)\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n    \n        self.targetCapability= account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\n        self.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n        self.buyer = account.address\n    }\n\n    pre {\n        self.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount) \n        self.saleItemsCap.borrow()!.buy(name:leaseName, vault: \u003c- vault, to: self.buyer)\n    }\n}",
               "spec": {
                  "order": [
                     "leaseName",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "leaseName": "String"
                  }
               }
            },
            "buyLeaseForSaleDUC": {
               "code": "import FindMarket from 0xf8d6e0586b0a20c7\nimport FindMarketSale from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionSoft from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FTRegistry from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FIND from 0xf8d6e0586b0a20c7\nimport Dandy from 0xf8d6e0586b0a20c7\nimport Profile from 0xf8d6e0586b0a20c7\nimport TokenForwarding from 0xf8d6e0586b0a20c7\nimport DapperUtilityCoin from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport FindLeaseMarketSale from 0xf8d6e0586b0a20c7\nimport FindLeaseMarketAuctionSoft from 0xf8d6e0586b0a20c7\n// import FindLeaseMarketAuctionEscrow from \"../contracts/FindLeaseMarketAuctionEscrow.cdc\"\nimport FindLeaseMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\n// import FindLeaseMarketDirectOfferEscrow from \"../contracts/FindLeaseMarketDirectOfferEscrow.cdc\"\nimport FindLeaseMarket from 0xf8d6e0586b0a20c7\n\ntransaction(dapperAddress: Address, leaseName: String, amount: UFix64) {\n\n    let to : Address\n    let walletReference : \u0026FungibleToken.Vault\n\n    let saleItemsCap: Capability\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e\n    let mainDapperUtilityCoinVault: \u0026DapperUtilityCoin.Vault\n    let balanceBeforeTransfer: UFix64\n\n    prepare(dapper: AuthAccount, account: AuthAccount) {\n\n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n        //SYNC with register\n        //Add exising FUSD or create a new one and add it\n        let name = account.address.toString()\n        let ducReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver)\n        if !ducReceiver.check() {\n            let dapper = getAccount(dapperAddress)\n            // Create a new Forwarder resource for DUC and store it in the new account's storage\n            let ducForwarder \u003c- TokenForwarding.createNewForwarder(recipient: dapper.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver))\n            account.save(\u003c-ducForwarder, to: /storage/dapperUtilityCoinReceiver)\n            // Publish a Receiver capability for the new account, which is linked to the DUC Forwarder\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver,target: /storage/dapperUtilityCoinReceiver)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: ducReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let dandyCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        let dandyCapPrivate= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPrivatePath)\n        if !dandyCapPrivate.check() {\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        var created=false\n        var updated=false\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        if !profile.hasWallet(\"Flow\") {\n            let flowWallet=Profile.Wallet( name:\"Flow\", receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), tags: [\"flow\"])\n    \n            profile.addWallet(flowWallet)\n            updated=true\n        }\n        if !profile.hasWallet(\"DUC\") {\n            profile.addWallet(Profile.Wallet( name:\"DUC\", receiver:ducReceiver, balance:getAccount(dapperAddress).getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/dapperUtilityCoinBalance), accept: Type\u003c@DapperUtilityCoin.Vault\u003e(), tags: [\"duc\", \"dapperUtilityCoin\",\"dapper\"]))\n            updated=true\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else {\n            profile.emitUpdatedEvent()\n        }\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        let doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        let doeSalePublicPath=FindMarket.getPublicPath(doeSaleType, name: tenant.name)\n        let doeSaleStoragePath= FindMarket.getStoragePath(doeSaleType, name:tenant.name)\n        let doeSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n        if !doeSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n        }\n\n        let doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        let doeBidPublicPath=FindMarket.getPublicPath(doeBidType, name: tenant.name)\n        let doeBidStoragePath= FindMarket.getStoragePath(doeBidType, name:tenant.name)\n        let doeBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n        if !doeBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n        }\n\n        /// auctions that escrow ft\n        let aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        let aeSalePublicPath=FindMarket.getPublicPath(aeSaleType, name: tenant.name)\n        let aeSaleStoragePath= FindMarket.getStoragePath(aeSaleType, name:tenant.name)\n        let aeSaleCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n        if !aeSaleCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n        }\n\n        let dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\n        let dosSalePublicPath=FindMarket.getPublicPath(dosSaleType, name: tenant.name)\n        let dosSaleStoragePath= FindMarket.getStoragePath(dosSaleType, name:tenant.name)\n\n        let dosSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n        if !dosSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n        }\n\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n        if !dosBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n        }\n\n        let aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\n        let aeBidPublicPath=FindMarket.getPublicPath(aeBidType, name: tenant.name)\n        let aeBidStoragePath= FindMarket.getStoragePath(aeBidType, name:tenant.name)\n        let aeBidCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n        if !aeBidCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n        }\n\n     /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n        }\n\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n        if !asBidCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n        }\n\n        let leaseTenantCapability= FindMarket.getTenantCapability(FindMarket.getTenantAddress(\"findLease\")!)!\n\n        let leaseSaleItemType= Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()\n        let leasePublicPath=FindMarket.getPublicPath(leaseSaleItemType, name: \"findLease\")\n        let leaseStoragePath= FindMarket.getStoragePath(leaseSaleItemType, name:\"findLease\")\n        let leaseSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath) \n        if !leaseSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketSale.SaleItemCollection\u003e(\u003c- FindLeaseMarketSale.createEmptySaleItemCollection(leaseTenantCapability), to: leaseStoragePath)\n            account.link\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath, target: leaseStoragePath)\n        }\n\n        let leaseASSaleItemType= Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e()\n        let leaseASPublicPath=FindMarket.getPublicPath(leaseASSaleItemType, name: \"findLease\")\n        let leaseASStoragePath= FindMarket.getStoragePath(leaseASSaleItemType, name:\"findLease\")\n        let leaseASSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath) \n        if !leaseASSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseASStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath, target: leaseASStoragePath)\n        }\n\n\n        let leaseASBidType= Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e()\n        let leaseASBidPublicPath=FindMarket.getPublicPath(leaseASBidType, name: \"findLease\")\n        let leaseASBidStoragePath= FindMarket.getStoragePath(leaseASBidType, name: \"findLease\")\n        let leaseASBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath) \n        if !leaseASBidCap.check() {\n            account.save\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseASBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath, target: leaseASBidStoragePath)\n        }\n\n        // let leaseAESaleItemType= Type\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e()\n        // let leaseAEPublicPath=FindMarket.getPublicPath(leaseAESaleItemType, name: \"findLease\")\n        // let leaseAEStoragePath= FindMarket.getStoragePath(leaseAESaleItemType, name:\"findLease\")\n        // let leaseAESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath) \n        // if !leaseAESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseAEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath, target: leaseAEStoragePath)\n        // }\n\n        // let leaseAEBidType= Type\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e()\n        // let leaseAEBidPublicPath=FindMarket.getPublicPath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidStoragePath= FindMarket.getStoragePath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath) \n        // if !leaseAEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseAEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath, target: leaseAEBidStoragePath)\n        // }\n\n        let leaseDOSSaleItemType= Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e()\n        let leaseDOSPublicPath=FindMarket.getPublicPath(leaseDOSSaleItemType, name: \"findLease\")\n        let leaseDOSStoragePath= FindMarket.getStoragePath(leaseDOSSaleItemType, name:\"findLease\")\n        let leaseDOSSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath) \n        if !leaseDOSSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOSStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath, target: leaseDOSStoragePath)\n        }\n\n        let leaseDOSBidType= Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let leaseDOSBidPublicPath=FindMarket.getPublicPath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidStoragePath= FindMarket.getStoragePath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath) \n        if !leaseDOSBidCap.check() {\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOSBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath, target: leaseDOSBidStoragePath)\n        }\n\n        // let leaseDOESaleItemType= Type\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        // let leaseDOEPublicPath=FindMarket.getPublicPath(leaseDOESaleItemType, name: \"findLease\")\n        // let leaseDOEStoragePath= FindMarket.getStoragePath(leaseDOESaleItemType, name:\"findLease\")\n        // let leaseDOESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath) \n        // if !leaseDOESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath, target: leaseDOEStoragePath)\n        // }\n\n        // let leaseDOEBidType= Type\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        // let leaseDOEBidPublicPath=FindMarket.getPublicPath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidStoragePath= FindMarket.getStoragePath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath) \n        // if !leaseDOEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath, target: leaseDOEBidStoragePath)\n        // }\n        //SYNC with register\n\n        let resolveAddress = FIND.resolve(leaseName)\n        if resolveAddress == nil {\n            panic(\"The address input is not a valid name nor address. Input : \".concat(leaseName))\n        }\n        let address = resolveAddress!\n        let leaseMarketplace = FindMarket.getTenantAddress(\"findLease\")!\n        self.saleItemsCap= FindLeaseMarketSale.getSaleItemCapability(marketplace: leaseMarketplace, user:address) ?? panic(\"cannot find sale item cap\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e())\n\n        let item= FindLeaseMarket.assertOperationValid(tenant: leaseMarketplace, name: leaseName, marketOption: marketOption)\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n    \n        if ft.type != Type\u003c@DapperUtilityCoin.Vault\u003e() {\n            panic(\"This item is not listed for Dapper Wallets. Please buy in with other wallets.\")\n        }\n\n        self.mainDapperUtilityCoinVault = dapper.borrow\u003c\u0026DapperUtilityCoin.Vault\u003e(from: /storage/dapperUtilityCoinVault) ?? panic(\"Cannot borrow DapperUtilityCoin vault from account storage\".concat(dapper.address.toString()))\n        self.balanceBeforeTransfer = self.mainDapperUtilityCoinVault.balance\n\n        self.to= account.address\n\n        self.walletReference = dapper.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n    }\n\n    pre {\n        self.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount) \n        self.saleItemsCap.borrow()!.buy(name:leaseName, vault: \u003c- vault, to: self.to)\n    }\n\n    // Check that all dapperUtilityCoin was routed back to Dapper\n    post {\n        self.mainDapperUtilityCoinVault.balance == self.balanceBeforeTransfer: \"DapperUtilityCoin leakage\"\n    }\n}",
               "spec": {
                  "order": [
                     "dapperAddress",
                     "leaseName",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "dapperAddress": "Address",
                     "leaseName": "String"
                  }
               }
            },
            "buyMultipleNFTForSale": {
               "code": "import FindMarket from 0xf8d6e0586b0a20c7\nimport FindMarketSale from 0xf8d6e0586b0a20c7\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport NFTCatalog from 0xf8d6e0586b0a20c7\nimport FINDNFTCatalog from 0xf8d6e0586b0a20c7\nimport FTRegistry from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\n\ntransaction(marketplace:Address, users: [Address], ids: [UInt64], amounts: [UFix64]) {\n\n    let targetCapability : [Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e]\n    var walletReference : [\u0026FungibleToken.Vault]\n\n    let saleItems: [\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}]\n    var totalPrice : UFix64\n    let prices : [UFix64]\n    prepare(account: AuthAccount) {\n\n        if users.length != ids.length {\n            panic(\"The array length of users and ids should be the same\")\n        }\n\n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n\n        var counter = 0\n        self.walletReference= []\n        self.targetCapability = []\n\n        self.saleItems = []\n        let nfts : {String : NFTCatalog.NFTCollectionData} = {}\n        let fts : {String : FTRegistry.FTInfo} = {}\n        let saleItems : {Address : \u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}} = {}\n\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketSale.SaleItemCollection\u003e())\n\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(Type\u003c@FindMarketSale.SaleItemCollection\u003e(), name: tenant.name)\n        var vaultType : Type? = nil\n\n        self.totalPrice = 0.0\n        self.prices = []\n\n        while counter \u003c users.length {\n\n            let address=users[counter]\n\n            if saleItems[address] == nil {\n                let saleItem = getAccount(address).getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath).borrow() ?? panic(\"cannot find sale item cap\")\n                self.saleItems.append(saleItem)\n                saleItems[address] = saleItem \n            } else {\n                self.saleItems.append(saleItems[address]!)\n            }\n\n\n            // let item= FindMarket.assertOperationValid(tenant: marketplace, address: address, marketOption: marketOption, id: ids[counter])\n            let item=saleItems[address]!.borrowSaleItem(ids[counter])\n\n            self.prices.append(item.getBalance())\n            self.totalPrice = self.totalPrice + self.prices[counter]\n\n            var nft : NFTCatalog.NFTCollectionData? = nil\n            var ft : FTRegistry.FTInfo? = nil\n            let nftIdentifier = item.getItemType().identifier\n            let ftIdentifier = item.getFtType().identifier\n\n            if nfts[nftIdentifier] != nil {\n                nft = nfts[nftIdentifier]\n            } else {\n                let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier)) \n                let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n                nft = collection.collectionData\n                nfts[nftIdentifier] = nft\n            }\n\n            if fts[ftIdentifier] != nil {\n                ft = fts[ftIdentifier]\n            } else {\n                ft = FTRegistry.getFTInfo(ftIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftIdentifier))\n                fts[ftIdentifier] = ft \n            }\n\n            self.walletReference.append(\n                account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft!.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n            )\n\n            var targetCapability= account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(nft!.publicPath)\n            /* Check for nftCapability */\n            if !targetCapability.check() {\n                let cd = item.getNFTCollectionData()\n                // should use account.type here instead\n                if account.type(at: cd.storagePath) != nil {\n                    let pathIdentifier = nft!.publicPath.toString()\n                    let findPath = PublicPath(identifier: pathIdentifier.slice(from: \"/public/\".length , upTo: pathIdentifier.length).concat(\"_FIND\"))!\n                    account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                        findPath,\n                        target: nft!.storagePath\n                    )\n                    targetCapability = account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(findPath)\n                } else {\n                    account.save(\u003c- cd.createEmptyCollection(), to: cd.storagePath)\n                    account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.publicPath, target: cd.storagePath)\n                    account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.providerPath, target: cd.storagePath)\n                }\n\n            }\n            self.targetCapability.append(targetCapability)\n            counter = counter + 1\n        }\n\n\n    }\n\n    execute {\n        var counter = 0\n        while counter \u003c users.length {\n            if self.prices[counter] != amounts[counter] {\n                panic(\"Please pass in the correct price of the buy items. Required : \".concat(self.prices[counter].toString()).concat(\" . saleItem ID : \".concat(ids[counter].toString())))\n            }\n            if self.walletReference[counter].balance \u003c amounts[counter] {\n                panic(\"Your wallet does not have enough funds to pay for this item. Required : \".concat(self.prices[counter].toString()).concat(\" . saleItem ID : \".concat(ids[counter].toString())))\n            }\n\n            self.saleItems[counter].buy(id:ids[counter], vault: \u003c- self.walletReference[counter].withdraw(amount: amounts[counter]) \n            , nftCap: self.targetCapability[counter])\n            counter = counter + 1\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "users",
                     "ids",
                     "amounts"
                  ],
                  "parameters": {
                     "amounts": "[UFix64]",
                     "ids": "[UInt64]",
                     "marketplace": "Address",
                     "users": "[Address]"
                  }
               }
            },
            "buyMultipleNFTForSaleDUC": {
               "code": "import FindMarket from 0xf8d6e0586b0a20c7\nimport FindMarketSale from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionSoft from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport NFTCatalog from 0xf8d6e0586b0a20c7\nimport FINDNFTCatalog from 0xf8d6e0586b0a20c7\nimport FTRegistry from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FIND from 0xf8d6e0586b0a20c7\nimport Dandy from 0xf8d6e0586b0a20c7\nimport Profile from 0xf8d6e0586b0a20c7\nimport TokenForwarding from 0xf8d6e0586b0a20c7\nimport DapperUtilityCoin from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\n\ntransaction(dapperAddress: Address, marketplace:Address, users: [String], ids: [UInt64], amounts: [UFix64]) {\n\n    let targetCapability : [Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e]\n    var walletReference : \u0026FungibleToken.Vault\n\n    let saleItemsCap: [Capability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic}\u003e ]\n    let balanceBeforeTransfer: UFix64\n\n    var totalPrice : UFix64 \n    let prices : [UFix64]\n\n    prepare(dapper: AuthAccount, account: AuthAccount) {\n\n        if users.length != ids.length {\n            panic(\"The array length of users and ids should be the same\")\n        }\n\n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n        //SYNC with register\n        //Add exising FUSD or create a new one and add it\n        let name = account.address.toString()\n        let ducReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver)\n        if !ducReceiver.check() {\n            let dapper = getAccount(dapperAddress)\n            // Create a new Forwarder resource for DUC and store it in the new account's storage\n            let ducForwarder \u003c- TokenForwarding.createNewForwarder(recipient: dapper.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver))\n            account.save(\u003c-ducForwarder, to: /storage/dapperUtilityCoinReceiver)\n            // Publish a Receiver capability for the new account, which is linked to the DUC Forwarder\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver,target: /storage/dapperUtilityCoinReceiver)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: ducReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let dandyCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        let dandyCapPrivate= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPrivatePath)\n        if !dandyCapPrivate.check() {\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        var created=false\n        var updated=false\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        if !profile.hasWallet(\"Flow\") {\n            let flowWallet=Profile.Wallet( name:\"Flow\", receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), tags: [\"flow\"])\n    \n            profile.addWallet(flowWallet)\n            updated=true\n        }\n        if !profile.hasWallet(\"DUC\") {\n            profile.addWallet(Profile.Wallet( name:\"DUC\", receiver:ducReceiver, balance:getAccount(dapperAddress).getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/dapperUtilityCoinBalance), accept: Type\u003c@DapperUtilityCoin.Vault\u003e(), tags: [\"duc\", \"dapperUtilityCoin\",\"dapper\"]))\n            updated=true\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else {\n            profile.emitUpdatedEvent()\n        }\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        let doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        let doeSalePublicPath=FindMarket.getPublicPath(doeSaleType, name: tenant.name)\n        let doeSaleStoragePath= FindMarket.getStoragePath(doeSaleType, name:tenant.name)\n        let doeSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n        if !doeSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n        }\n\n        let doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        let doeBidPublicPath=FindMarket.getPublicPath(doeBidType, name: tenant.name)\n        let doeBidStoragePath= FindMarket.getStoragePath(doeBidType, name:tenant.name)\n        let doeBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n        if !doeBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n        }\n\n        /// auctions that escrow ft\n        let aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        let aeSalePublicPath=FindMarket.getPublicPath(aeSaleType, name: tenant.name)\n        let aeSaleStoragePath= FindMarket.getStoragePath(aeSaleType, name:tenant.name)\n        let aeSaleCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n        if !aeSaleCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n        }\n\n        let dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\n        let dosSalePublicPath=FindMarket.getPublicPath(dosSaleType, name: tenant.name)\n        let dosSaleStoragePath= FindMarket.getStoragePath(dosSaleType, name:tenant.name)\n\n        let dosSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n        if !dosSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n        }\n\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n        if !dosBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n        }\n\n        let aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\n        let aeBidPublicPath=FindMarket.getPublicPath(aeBidType, name: tenant.name)\n        let aeBidStoragePath= FindMarket.getStoragePath(aeBidType, name:tenant.name)\n        let aeBidCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n        if !aeBidCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n        }\n\n     /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n        }\n\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n        if !asBidCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n        }\n        //SYNC with register\n\n        var counter = 0\n        self.targetCapability = []\n        self.walletReference = dapper.borrow\u003c\u0026DapperUtilityCoin.Vault\u003e(from: /storage/dapperUtilityCoinVault) ?? panic(\"Cannot borrow DapperUtilityCoin vault from account storage\".concat(dapper.address.toString()))\n        self.balanceBeforeTransfer = self.walletReference.balance\n\n        self.saleItemsCap = []\n        let addresses : {String : Address} = {}\n        let nfts : {String : NFTCatalog.NFTCollectionData} = {}\n\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketSale.SaleItemCollection\u003e())\n\n        self.totalPrice = 0.0\n        self.prices = []\n\n        while counter \u003c users.length {\n            var resolveAddress : Address? = nil\n            if addresses[users[counter]] != nil {\n                resolveAddress = addresses[users[counter]]!\n            } else {\n                let address = FIND.resolve(users[counter])\n                if address == nil {\n                    panic(\"The address input is not a valid name nor address. Input : \".concat(users[counter]))\n                }\n                addresses[users[counter]] = address!\n                resolveAddress = address!\n            }\n            let address = resolveAddress!\n            let saleItemCap = FindMarketSale.getSaleItemCapability(marketplace: marketplace, user:address) ?? panic(\"cannot find sale item cap\")\n            self.saleItemsCap.append(saleItemCap)\n\n            let item= FindMarket.assertOperationValid(tenant: marketplace, address: address, marketOption: marketOption, id: ids[counter])\n\n            self.prices.append(item.getBalance())\n            if self.prices[counter] != amounts[counter] {\n                panic(\"Please pass in the correct amount for item. saleID : \".concat(ids[counter].toString()).concat(\" . Required : \".concat(self.prices[counter].toString())))\n            }\n\n            var nft : NFTCatalog.NFTCollectionData? = nil\n            let nftIdentifier = item.getItemType().identifier\n            let ftType = item.getFtType()\n\n            if nfts[nftIdentifier] != nil {\n                nft = nfts[nftIdentifier]\n            } else {\n                let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier)) \n                let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n                nft =  collection.collectionData\n                nfts[nftIdentifier] = nft\n            }\n            \n            if ftType != Type\u003c@DapperUtilityCoin.Vault\u003e() {\n                panic(\"This item is not listed for Dapper Wallets. Please buy in with other wallets.\")\n            }\n\n            var targetCapability= account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(nft!.publicPath)\n            /* Check for nftCapability */\n            if !targetCapability.check() {\n                let cd = item.getNFTCollectionData()\n                // should use account.type here instead\n                if account.type(at: cd.storagePath) != nil {\n                    let pathIdentifier = nft!.publicPath.toString()\n                    let findPath = PublicPath(identifier: pathIdentifier.slice(from: \"/public/\".length , upTo: pathIdentifier.length).concat(\"_FIND\"))!\n                    account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                        findPath,\n                        target: nft!.storagePath\n                    )\n                    targetCapability = account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(findPath)\n                } else {\n                    account.save(\u003c- cd.createEmptyCollection(), to: cd.storagePath)\n                    account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.publicPath, target: cd.storagePath)\n                    account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.providerPath, target: cd.storagePath)\n                }\n\n            }\n            self.targetCapability.append(targetCapability)\n            counter = counter + 1\n        }\n    }\n\n    execute {\n        var counter = 0 \n        while counter \u003c ids.length {\n            if self.walletReference!.balance \u003c amounts[counter] {\n                panic(\"Your wallet does not have enough funds to pay for this item. Required : \".concat(self.totalPrice.toString()))\n            }\n            let vault \u003c- self.walletReference!.withdraw(amount: self.prices[counter]) \n            self.saleItemsCap[counter].borrow()!.buy(id:ids[counter], vault: \u003c- vault, nftCap: self.targetCapability[counter])\n            counter = counter + 1\n        }\n    }\n\n    // Check that all dapperUtilityCoin was routed back to Dapper\n    post {\n        self.walletReference.balance == self.balanceBeforeTransfer: \"DapperUtilityCoin leakage\"\n    }\n}",
               "spec": {
                  "order": [
                     "dapperAddress",
                     "marketplace",
                     "users",
                     "ids",
                     "amounts"
                  ],
                  "parameters": {
                     "amounts": "[UFix64]",
                     "dapperAddress": "Address",
                     "ids": "[UInt64]",
                     "marketplace": "Address",
                     "users": "[String]"
                  }
               }
            },
            "buyNFTForSale": {
               "code": "import FindMarket from 0xf8d6e0586b0a20c7\nimport FindMarketSale from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionSoft from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport NFTCatalog from 0xf8d6e0586b0a20c7\nimport FINDNFTCatalog from 0xf8d6e0586b0a20c7\nimport FTRegistry from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FUSD from 0xf8d6e0586b0a20c7\nimport FiatToken from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport FIND from 0xf8d6e0586b0a20c7\nimport Dandy from 0xf8d6e0586b0a20c7\nimport Profile from 0xf8d6e0586b0a20c7\nimport FindLeaseMarketSale from 0xf8d6e0586b0a20c7\nimport FindLeaseMarketAuctionSoft from 0xf8d6e0586b0a20c7\n// import FindLeaseMarketAuctionEscrow from \"../contracts/FindLeaseMarketAuctionEscrow.cdc\"\nimport FindLeaseMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\n// import FindLeaseMarketDirectOfferEscrow from \"../contracts/FindLeaseMarketDirectOfferEscrow.cdc\"\nimport FindLeaseMarket from 0xf8d6e0586b0a20c7\n\ntransaction(marketplace:Address, user: String, id: UInt64, amount: UFix64) {\n\n    var targetCapability : Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e\n    let walletReference : \u0026FungibleToken.Vault\n\n    let saleItemsCap: Capability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic}\u003e \n\n    prepare(account: AuthAccount) {\n\n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n        //SYNC with register\n        //Add exising FUSD or create a new one and add it\n        let name = account.address.toString()\n        let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n        if !fusdReceiver.check() {\n            let fusd \u003c- FUSD.createEmptyVault()\n            account.save(\u003c- fusd, to: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n        }\n\n        let usdcCap = account.getCapability\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e(FiatToken.VaultReceiverPubPath)\n        if !usdcCap.check() {\n                account.save( \u003c-FiatToken.createEmptyVault(), to: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e( FiatToken.VaultReceiverPubPath, target: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FiatToken.ResourceId}\u003e( FiatToken.VaultUUIDPubPath, target: FiatToken.VaultStoragePath)\n                account.link\u003c\u0026FiatToken.Vault{FungibleToken.Balance}\u003e( FiatToken.VaultBalancePubPath, target:FiatToken.VaultStoragePath)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let dandyCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        let dandyCapPrivate= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPrivatePath)\n        if !dandyCapPrivate.check() {\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        var created=false\n        var updated=false\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        if !profile.hasWallet(\"Flow\") {\n            let flowWallet=Profile.Wallet( name:\"Flow\", receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), tags: [\"flow\"])\n    \n            profile.addWallet(flowWallet)\n            updated=true\n        }\n        if !profile.hasWallet(\"FUSD\") {\n            profile.addWallet(Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), tags: [\"fusd\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if !profile.hasWallet(\"USDC\") {\n            profile.addWallet(Profile.Wallet( name:\"USDC\", receiver:usdcCap, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(FiatToken.VaultBalancePubPath), accept: Type\u003c@FiatToken.Vault\u003e(), tags: [\"usdc\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else if updated {\n            profile.emitUpdatedEvent()\n        }\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        let doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        let doeSalePublicPath=FindMarket.getPublicPath(doeSaleType, name: tenant.name)\n        let doeSaleStoragePath= FindMarket.getStoragePath(doeSaleType, name:tenant.name)\n        let doeSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n        if !doeSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n        }\n\n        let doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        let doeBidPublicPath=FindMarket.getPublicPath(doeBidType, name: tenant.name)\n        let doeBidStoragePath= FindMarket.getStoragePath(doeBidType, name:tenant.name)\n        let doeBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n        if !doeBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n        }\n\n        /// auctions that escrow ft\n        let aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        let aeSalePublicPath=FindMarket.getPublicPath(aeSaleType, name: tenant.name)\n        let aeSaleStoragePath= FindMarket.getStoragePath(aeSaleType, name:tenant.name)\n        let aeSaleCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n        if !aeSaleCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n        }\n\n        let dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\n        let dosSalePublicPath=FindMarket.getPublicPath(dosSaleType, name: tenant.name)\n        let dosSaleStoragePath= FindMarket.getStoragePath(dosSaleType, name:tenant.name)\n\n        let dosSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n        if !dosSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n        }\n\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n        if !dosBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n        }\n\n        let aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\n        let aeBidPublicPath=FindMarket.getPublicPath(aeBidType, name: tenant.name)\n        let aeBidStoragePath= FindMarket.getStoragePath(aeBidType, name:tenant.name)\n        let aeBidCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n        if !aeBidCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n        }\n\n     /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n        }\n\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n        if !asBidCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n        }\n\n        let leaseTenantCapability= FindMarket.getTenantCapability(FindMarket.getTenantAddress(\"findLease\")!)!\n\n        let leaseSaleItemType= Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()\n        let leasePublicPath=FindMarket.getPublicPath(leaseSaleItemType, name: \"findLease\")\n        let leaseStoragePath= FindMarket.getStoragePath(leaseSaleItemType, name:\"findLease\")\n        let leaseSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath) \n        if !leaseSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketSale.SaleItemCollection\u003e(\u003c- FindLeaseMarketSale.createEmptySaleItemCollection(leaseTenantCapability), to: leaseStoragePath)\n            account.link\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath, target: leaseStoragePath)\n        }\n\n        let leaseASSaleItemType= Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e()\n        let leaseASPublicPath=FindMarket.getPublicPath(leaseASSaleItemType, name: \"findLease\")\n        let leaseASStoragePath= FindMarket.getStoragePath(leaseASSaleItemType, name:\"findLease\")\n        let leaseASSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath) \n        if !leaseASSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseASStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath, target: leaseASStoragePath)\n        }\n\n\n        let leaseASBidType= Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e()\n        let leaseASBidPublicPath=FindMarket.getPublicPath(leaseASBidType, name: \"findLease\")\n        let leaseASBidStoragePath= FindMarket.getStoragePath(leaseASBidType, name: \"findLease\")\n        let leaseASBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath) \n        if !leaseASBidCap.check() {\n            account.save\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseASBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath, target: leaseASBidStoragePath)\n        }\n\n        // let leaseAESaleItemType= Type\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e()\n        // let leaseAEPublicPath=FindMarket.getPublicPath(leaseAESaleItemType, name: \"findLease\")\n        // let leaseAEStoragePath= FindMarket.getStoragePath(leaseAESaleItemType, name:\"findLease\")\n        // let leaseAESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath) \n        // if !leaseAESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseAEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath, target: leaseAEStoragePath)\n        // }\n\n        // let leaseAEBidType= Type\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e()\n        // let leaseAEBidPublicPath=FindMarket.getPublicPath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidStoragePath= FindMarket.getStoragePath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath) \n        // if !leaseAEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseAEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath, target: leaseAEBidStoragePath)\n        // }\n\n        let leaseDOSSaleItemType= Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e()\n        let leaseDOSPublicPath=FindMarket.getPublicPath(leaseDOSSaleItemType, name: \"findLease\")\n        let leaseDOSStoragePath= FindMarket.getStoragePath(leaseDOSSaleItemType, name:\"findLease\")\n        let leaseDOSSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath) \n        if !leaseDOSSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOSStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath, target: leaseDOSStoragePath)\n        }\n\n        let leaseDOSBidType= Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let leaseDOSBidPublicPath=FindMarket.getPublicPath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidStoragePath= FindMarket.getStoragePath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath) \n        if !leaseDOSBidCap.check() {\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOSBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath, target: leaseDOSBidStoragePath)\n        }\n\n        // let leaseDOESaleItemType= Type\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        // let leaseDOEPublicPath=FindMarket.getPublicPath(leaseDOESaleItemType, name: \"findLease\")\n        // let leaseDOEStoragePath= FindMarket.getStoragePath(leaseDOESaleItemType, name:\"findLease\")\n        // let leaseDOESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath) \n        // if !leaseDOESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath, target: leaseDOEStoragePath)\n        // }\n\n        // let leaseDOEBidType= Type\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        // let leaseDOEBidPublicPath=FindMarket.getPublicPath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidStoragePath= FindMarket.getStoragePath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath) \n        // if !leaseDOEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath, target: leaseDOEBidStoragePath)\n        // }\n        //SYNC with register\n\n        let resolveAddress = FIND.resolve(user)\n        if resolveAddress == nil {\n            panic(\"The address input is not a valid name nor address. Input : \".concat(user))\n        }\n        let address = resolveAddress!\n        self.saleItemsCap= FindMarketSale.getSaleItemCapability(marketplace: marketplace, user:address) ?? panic(\"cannot find sale item cap\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketSale.SaleItemCollection\u003e())\n\n        let item= FindMarket.assertOperationValid(tenant: marketplace, address: address, marketOption: marketOption, id: id)\n\n        let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: item.getItemType().identifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(item.getItemType().identifier)) \n        let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n        let nft = collection.collectionData\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n    \n        self.targetCapability= account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(nft.publicPath)\n        /* Check for nftCapability */\n        if !self.targetCapability.check() {\n            let cd = item.getNFTCollectionData()\n            // should use account.type here instead\n            if account.type(at: cd.storagePath) != nil {\n                let pathIdentifier = nft.publicPath.toString()\n                let findPath = PublicPath(identifier: pathIdentifier.slice(from: \"/public/\".length , upTo: pathIdentifier.length).concat(\"_FIND\"))!\n                account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                    findPath,\n                    target: nft.storagePath\n                )\n                self.targetCapability = account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(findPath)\n            } else {\n                account.save(\u003c- cd.createEmptyCollection(), to: cd.storagePath)\n                account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.publicPath, target: cd.storagePath)\n                account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.providerPath, target: cd.storagePath)\n            }\n\n        }\n\n        self.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n    }\n\n    pre {\n        self.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount) \n        self.saleItemsCap.borrow()!.buy(id:id, vault: \u003c- vault, nftCap: self.targetCapability)\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "user",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64",
                     "marketplace": "Address",
                     "user": "String"
                  }
               }
            },
            "buyNFTForSaleDUC": {
               "code": "import FindMarket from 0xf8d6e0586b0a20c7\nimport Profile from 0xf8d6e0586b0a20c7\nimport FindMarketSale from 0xf8d6e0586b0a20c7\nimport NFTCatalog from 0xf8d6e0586b0a20c7\nimport FINDNFTCatalog from 0xf8d6e0586b0a20c7\nimport FTRegistry from 0xf8d6e0586b0a20c7\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport TokenForwarding from 0xf8d6e0586b0a20c7\nimport DapperUtilityCoin from 0xf8d6e0586b0a20c7\n\n//first argument is the address to the merchant that gets the funds\ntransaction(merchantAddress: Address, marketplace:Address, address: Address, id: UInt64, amount: UFix64) {\n\n    let targetCapability : Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e\n    let walletReference : \u0026FungibleToken.Vault\n\n    let saleItemsCap: Capability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic}\u003e \n    let balanceBeforeTransfer: UFix64\n    prepare(dapper: AuthAccount, account: AuthAccount) {\n\n        let name = account.address.toString()\n        let ducReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver)\n        if !ducReceiver.check() {\n            // Create a new Forwarder resource for DUC and store it in the new account's storage\n            let ducForwarder \u003c- TokenForwarding.createNewForwarder(recipient: dapper.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver))\n            account.save(\u003c-ducForwarder, to: /storage/dapperUtilityCoinReceiver)\n            // Publish a Receiver capability for the new account, which is linked to the DUC Forwarder\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver,target: /storage/dapperUtilityCoinReceiver)\n        }\n        \n        var created=false\n        var updated=false\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        if !profile.hasWallet(\"DUC\") {\n            updated=true\n            profile.addWallet(Profile.Wallet( name:\"DUC\", receiver:ducReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/dapperUtilityCoinBalance), accept: Type\u003c@DapperUtilityCoin.Vault\u003e(), tags: [\"duc\", \"dapperUtilityCoin\",\"dapper\"]))\n            updated=true\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else {\n            profile.emitUpdatedEvent()\n        }\n\n\n        if created {\n            profile.emitCreatedEvent()\n        } else if updated {\n            profile.emitUpdatedEvent()\n        }\n\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        self.saleItemsCap= FindMarketSale.getSaleItemCapability(marketplace: marketplace, user:address) ?? panic(\"cannot find sale item cap\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketSale.SaleItemCollection\u003e())\n    \n        //we do some security check to verify that this tenant can do this operation. This will ensure that the onefootball tenant can only sell using DUC and not some other token. But we can change this with transactions later and not have to modify code/transactions\n        let item= FindMarket.assertOperationValid(tenant: marketplace, address: address, marketOption: marketOption, id: id)\n   let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: item.getItemType().identifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(item.getItemType().identifier))\n        let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n        let nft = collection.collectionData\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n    \n        if ft.type != Type\u003c@DapperUtilityCoin.Vault\u003e() {\n            panic(\"This item is not listed for Dapper Wallets. Please buy in with other wallets.\")\n        }\n\n\n        self.targetCapability= account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(nft.publicPath)\n\n        if !self.targetCapability.check() {\n            let cd = item.getNFTCollectionData()\n            if account.borrow\u003c\u0026AnyResource\u003e(from: cd.storagePath) != nil {\n                panic(\"This collection public link is not set up properly.\")\n            }\n            account.save(\u003c- cd.createEmptyCollection(), to: cd.storagePath)\n            account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.publicPath, target: cd.storagePath)\n            account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.providerPath, target: cd.storagePath)\n        }\n\n        self.walletReference = dapper.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n        self.balanceBeforeTransfer = self.walletReference.balance\n    }\n\n    pre {\n        self.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount) \n        self.saleItemsCap.borrow()!.buy(id:id, vault: \u003c- vault, nftCap: self.targetCapability)\n    }\n\n    // Check that all dapperUtilityCoin was routed back to Dapper\n    post {\n        self.walletReference.balance == self.balanceBeforeTransfer: \"DapperUtilityCoin leakage\"\n    }\n}",
               "spec": {
                  "order": [
                     "merchantAddress",
                     "marketplace",
                     "address",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "address": "Address",
                     "amount": "UFix64",
                     "id": "UInt64",
                     "marketplace": "Address",
                     "merchantAddress": "Address"
                  }
               }
            },
            "cancelAllLeaseMarketAuctionSoft": {
               "code": "import FindMarket from 0xf8d6e0586b0a20c7\nimport FindLeaseMarketAuctionSoft from 0xf8d6e0586b0a20c7\n\ntransaction() {\n\n    let saleItems : \u0026FindLeaseMarketAuctionSoft.SaleItemCollection?\n\n    prepare(account: AuthAccount) {\n        let leaseMarketplace = FindMarket.getTenantAddress(\"findLease\")!\n        let tenant = FindMarket.getTenant(leaseMarketplace)\n        self.saleItems= account.borrow\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e()))\n\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to the saleItem.\"\n    }\n\n    execute {\n        let leaseNames = self.saleItems!.getNameSales()\n        for lease in leaseNames {\n            self.saleItems!.cancel(lease)\n        }\n    }\n}",
               "spec": {
                  "order": [],
                  "parameters": {}
               }
            },
            "cancelAllLeaseMarketDirectOfferSoft": {
               "code": "import FindMarket from 0xf8d6e0586b0a20c7\nimport FindLeaseMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\n\ntransaction() {\n\n    let saleItems : \u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection?\n\n    prepare(account: AuthAccount) {\n\n        let marketplace = FindMarket.getTenantAddress(\"findLease\")!\n        let tenant=FindMarket.getTenant(marketplace)\n        self.saleItems= account.borrow\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e()))\n\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to saleItem.\"\n    }\n\n    execute{\n        let nameLeases = self.saleItems!.getNameSales()\n        for nameLease in nameLeases {\n            self.saleItems!.cancel(nameLease)\n        }\n    }\n\n}",
               "spec": {
                  "order": [],
                  "parameters": {}
               }
            },
            "cancelAllMarketAuctionEscrowed": {
               "code": "import FindMarket from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionEscrow from 0xf8d6e0586b0a20c7\n\ntransaction(marketplace:Address) {\n\n    let saleItems : \u0026FindMarketAuctionEscrow.SaleItemCollection?\n\n    prepare(account: AuthAccount) {\n        let tenant = FindMarket.getTenant(marketplace)\n        self.saleItems= account.borrow\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()))\n\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to the saleItem capability.\"\n    }\n\n    execute {\n        let ids = self.saleItems!.getIds()\n        for id in ids {\n            self.saleItems!.cancel(id)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace"
                  ],
                  "parameters": {
                     "marketplace": "Address"
                  }
               }
            },
            "cancelAllMarketAuctionSoft": {
               "code": "import FindMarket from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionSoft from 0xf8d6e0586b0a20c7\n\ntransaction(marketplace:Address) {\n\n    let saleItems : \u0026FindMarketAuctionSoft.SaleItemCollection?\n\n    prepare(account: AuthAccount) {\n        let tenant = FindMarket.getTenant(marketplace)\n        self.saleItems= account.borrow\u003c\u0026FindMarketAuctionSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()))\n\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to the saleItem.\"\n    }\n\n    execute {\n        let ids = self.saleItems!.getIds()\n        for id in ids {\n            self.saleItems!.cancel(id)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace"
                  ],
                  "parameters": {
                     "marketplace": "Address"
                  }
               }
            },
            "cancelAllMarketDirectOfferEscrowed": {
               "code": "import FindMarket from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferEscrow from 0xf8d6e0586b0a20c7\n\ntransaction(marketplace:Address) {\n\n    let saleItems : \u0026FindMarketDirectOfferEscrow.SaleItemCollection?\n\n    prepare(account: AuthAccount) {\n\n        let tenant=FindMarket.getTenant(marketplace)\n        self.saleItems= account.borrow\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()))\n\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to saleItem.\"\n    }\n\n    execute{\n        let ids = self.saleItems!.getIds()\n        for id in ids {\n            self.saleItems!.cancel(id)\n        }\n    }\n\n}",
               "spec": {
                  "order": [
                     "marketplace"
                  ],
                  "parameters": {
                     "marketplace": "Address"
                  }
               }
            },
            "cancelAllMarketDirectOfferSoft": {
               "code": "import FindMarket from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\n\ntransaction(marketplace:Address) {\n\n    let saleItems : \u0026FindMarketDirectOfferSoft.SaleItemCollection?\n\n    prepare(account: AuthAccount) {\n\n        let tenant=FindMarket.getTenant(marketplace)\n        self.saleItems= account.borrow\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()))\n\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to saleItem.\"\n    }\n\n    execute{\n        let ids = self.saleItems!.getIds()\n        for id in ids {\n            self.saleItems!.cancel(id)\n        }\n    }\n\n}",
               "spec": {
                  "order": [
                     "marketplace"
                  ],
                  "parameters": {
                     "marketplace": "Address"
                  }
               }
            },
            "cancelAllMarketListings": {
               "code": "import FindMarket from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionSoft from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\nimport FindMarketSale from 0xf8d6e0586b0a20c7\n\ntransaction(marketplace:Address) {\n    prepare(account: AuthAccount) {\n\n        let tenant=FindMarket.getTenant(marketplace)\n\n        let saleItems= account.borrow\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()))!\n        var ids = saleItems.getIds()\n        for id in ids {\n            saleItems.cancel(id)\n        }\n\n        let saleItem2= account.borrow\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()))!\n        ids = saleItem2.getIds()\n        for id in ids {\n            saleItem2.cancel(id)\n        }\n\n        let saleItems3= account.borrow\u003c\u0026FindMarketAuctionSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()))!\n        ids = saleItems3.getIds()\n        for id in ids {\n            saleItems3.cancel(id)\n        }\n\n        let saleItems4= account.borrow\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()))!\n        ids = saleItems4.getIds()\n        for id in ids {\n            saleItems4.cancel(id)\n        }\n\n        let saleItems5= account.borrow\u003c\u0026FindMarketSale.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketSale.SaleItemCollection\u003e()))!\n        ids = saleItems5.getIds()\n        for id in ids {\n            saleItems5.delist(id)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace"
                  ],
                  "parameters": {
                     "marketplace": "Address"
                  }
               }
            },
            "cancelLeaseMarketAuctionSoft": {
               "code": "import FindMarket from 0xf8d6e0586b0a20c7\nimport FindLeaseMarketAuctionSoft from 0xf8d6e0586b0a20c7\n\ntransaction(leaseNames: [String]) {\n\n    let saleItems : \u0026FindLeaseMarketAuctionSoft.SaleItemCollection?\n\n    prepare(account: AuthAccount) {\n        let marketplace = FindMarket.getTenantAddress(\"findLease\")!\n        let tenant=FindMarket.getTenant(marketplace)\n        self.saleItems= account.borrow\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e()))\n    }\n\n    pre{\n        self.saleItems != nil \n    }\n\n    execute{\n        for leaseName in leaseNames {\n            self.saleItems!.cancel(leaseName)\n        }\n    }\n\n}",
               "spec": {
                  "order": [
                     "leaseNames"
                  ],
                  "parameters": {
                     "leaseNames": "[String]"
                  }
               }
            },
            "cancelLeaseMarketDirectOfferSoft": {
               "code": "import FindMarket from 0xf8d6e0586b0a20c7\nimport FindLeaseMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\n\ntransaction(leaseNames: [String]) {\n\n    let saleItems : \u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection?\n\n    prepare(account: AuthAccount) {\n        let marketplace = FindMarket.getTenantAddress(\"findLease\")!\n        let tenant=FindMarket.getTenant(marketplace)\n        self.saleItems= account.borrow\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e()))\n\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute {\n        for leaseName in leaseNames {\n            self.saleItems!.cancel(leaseName)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "leaseNames"
                  ],
                  "parameters": {
                     "leaseNames": "[String]"
                  }
               }
            },
            "cancelMarketAuctionEscrowed": {
               "code": "import FindMarket from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionEscrow from 0xf8d6e0586b0a20c7\n\ntransaction(marketplace:Address, ids: [UInt64]) {\n\n    let saleItems : \u0026FindMarketAuctionEscrow.SaleItemCollection?\n\n    prepare(account: AuthAccount) {\n\n        let tenant=FindMarket.getTenant(marketplace)\n        self.saleItems= account.borrow\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()))\n\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        for id in ids {\n            self.saleItems!.cancel(id)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "ids"
                  ],
                  "parameters": {
                     "ids": "[UInt64]",
                     "marketplace": "Address"
                  }
               }
            },
            "cancelMarketAuctionSoft": {
               "code": "import FindMarket from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionSoft from 0xf8d6e0586b0a20c7\n\ntransaction(marketplace:Address, ids: [UInt64]) {\n\n    let saleItems : \u0026FindMarketAuctionSoft.SaleItemCollection?\n\n    prepare(account: AuthAccount) {\n        let tenant=FindMarket.getTenant(marketplace)\n        self.saleItems= account.borrow\u003c\u0026FindMarketAuctionSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()))\n    }\n\n    pre{\n        self.saleItems != nil \n    }\n\n    execute{\n        for id in ids {\n            self.saleItems!.cancel(id)\n        }\n    }\n\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "ids"
                  ],
                  "parameters": {
                     "ids": "[UInt64]",
                     "marketplace": "Address"
                  }
               }
            },
            "cancelMarketDirectOfferEscrowed": {
               "code": "import FindMarket from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferEscrow from 0xf8d6e0586b0a20c7\n\ntransaction(marketplace:Address, ids: [UInt64]) {\n\n    let saleItems : \u0026FindMarketDirectOfferEscrow.SaleItemCollection?\n\n    prepare(account: AuthAccount) {\n\n        let tenant=FindMarket.getTenant(marketplace)\n        self.saleItems= account.borrow\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()))\n\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        for id in ids {\n            self.saleItems!.cancel(id)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "ids"
                  ],
                  "parameters": {
                     "ids": "[UInt64]",
                     "marketplace": "Address"
                  }
               }
            },
            "cancelMarketDirectOfferSoft": {
               "code": "import FindMarket from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\n\ntransaction(marketplace:Address, ids: [UInt64]) {\n\n    let saleItems : \u0026FindMarketDirectOfferSoft.SaleItemCollection?\n\n    prepare(account: AuthAccount) {\n\n        let tenant=FindMarket.getTenant(marketplace)\n        self.saleItems= account.borrow\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()))\n\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute {\n        for id in ids {\n            self.saleItems!.cancel(id)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "ids"
                  ],
                  "parameters": {
                     "ids": "[UInt64]",
                     "marketplace": "Address"
                  }
               }
            },
            "cancelMarketListings": {
               "code": "import FindMarket from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionSoft from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\nimport FindMarketSale from 0xf8d6e0586b0a20c7\n\ntransaction(marketplace:Address, ids: {String : [UInt64]}) {\n    prepare(account: AuthAccount) {\n\n        let tenant=FindMarket.getTenant(marketplace)\n\n        var saleType = Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        if let ids = ids[FindMarket.getMarketOptionFromType(saleType)] {\n            let saleItems= account.borrow\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection\u003e(from: tenant.getStoragePath(saleType))!\n            for id in ids {\n                saleItems.cancel(id)\n            }\n        }\n\n        saleType = Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        if let ids = ids[FindMarket.getMarketOptionFromType(saleType)] {\n            let saleItems= account.borrow\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection\u003e(from: tenant.getStoragePath(saleType))!\n            for id in ids {\n                saleItems.cancel(id)\n            }\n        }\n\n        saleType = Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        if let ids = ids[FindMarket.getMarketOptionFromType(saleType)] {\n            let saleItems= account.borrow\u003c\u0026FindMarketAuctionSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(saleType))!\n            for id in ids {\n                saleItems.cancel(id)\n            }\n        }\n\n        saleType = Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n        if let ids = ids[FindMarket.getMarketOptionFromType(saleType)] {\n            let saleItems= account.borrow\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(saleType))!\n            for id in ids {\n                saleItems.cancel(id)\n            }\n        }\n\n        saleType = Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        if let ids = ids[FindMarket.getMarketOptionFromType(saleType)] {\n            let saleItems= account.borrow\u003c\u0026FindMarketSale.SaleItemCollection\u003e(from: tenant.getStoragePath(saleType))!\n            for id in ids {\n                saleItems.delist(id)\n            }\n        }\n\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "ids"
                  ],
                  "parameters": {
                     "ids": "{String: [UInt64]}",
                     "marketplace": "Address"
                  }
               }
            },
            "cancelNameAuction": {
               "code": "import FIND from 0xf8d6e0586b0a20c7\n\ntransaction(names: [String]) {\n\n    let finLeases : \u0026FIND.LeaseCollection?\n\n    prepare(account: AuthAccount) {\n        self.finLeases= account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)\n    }\n\n    pre{\n        self.finLeases != nil : \"Cannot borrow reference to find leases collection\"\n    }\n\n    execute {\n        for name in names {\n            self.finLeases!.cancel(name)\n            self.finLeases!.delistAuction(name)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "names"
                  ],
                  "parameters": {
                     "names": "[String]"
                  }
               }
            },
            "cancelNameBid": {
               "code": "import FIND from 0xf8d6e0586b0a20c7\n\ntransaction(names: [String]) {\n\n    let bids : \u0026FIND.BidCollection?\n\n    prepare(account: AuthAccount) {\n        self.bids = account.borrow\u003c\u0026FIND.BidCollection\u003e(from: FIND.BidStoragePath)\n    }\n\n    pre{\n        self.bids != nil : \"Cannot borrow reference to find bid collection\"\n    }\n\n    execute {\n        for name in names {\n            self.bids!.cancelBid(name)\n        }\n    }\n\n}",
               "spec": {
                  "order": [
                     "names"
                  ],
                  "parameters": {
                     "names": "[String]"
                  }
               }
            },
            "createCharity": {
               "code": "import NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport CharityNFT from 0xf8d6e0586b0a20c7\n\n//This transaction will prepare the art collection\ntransaction() {\n    prepare(account: AuthAccount) {\n\n        let stdCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath)\n        if !stdCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- CharityNFT.createEmptyCollection(), to: CharityNFT.CollectionStoragePath)\n            account.link\u003c\u0026{NonFungibleToken.CollectionPublic, MetadataViews.ResolverCollection}\u003e(CharityNFT.CollectionPublicPath, target: CharityNFT.CollectionStoragePath)\n        }\n\n        let charityCap = account.getCapability\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection)\n        if !charityCap.check() {\n            account.link\u003c\u0026{CharityNFT.CollectionPublic, MetadataViews.ResolverCollection}\u003e(/public/findCharityNFTCollection, target: CharityNFT.CollectionStoragePath)\n        }\n    }\n}",
               "spec": {
                  "order": [],
                  "parameters": {}
               }
            },
            "createProfile": {
               "code": "import FungibleToken from 0xee82856bf20e2aa6\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport FUSD from 0xf8d6e0586b0a20c7\nimport FiatToken from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\nimport Profile from 0xf8d6e0586b0a20c7\nimport FindMarket from 0xf8d6e0586b0a20c7\nimport FindMarketSale from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionSoft from 0xf8d6e0586b0a20c7\nimport Dandy from 0xf8d6e0586b0a20c7\nimport FindLeaseMarketSale from 0xf8d6e0586b0a20c7\nimport FindLeaseMarketAuctionSoft from 0xf8d6e0586b0a20c7\n// import FindLeaseMarketAuctionEscrow from \"../contracts/FindLeaseMarketAuctionEscrow.cdc\"\nimport FindLeaseMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\n// import FindLeaseMarketDirectOfferEscrow from \"../contracts/FindLeaseMarketDirectOfferEscrow.cdc\"\nimport FindLeaseMarket from 0xf8d6e0586b0a20c7\n\ntransaction(name: String) {\n    prepare(account: AuthAccount) {\n        //if we do not have a profile it might be stored under a different address so we will just remove it\n        let profileCapFirst = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if profileCapFirst.check() {\n            return \n        }\n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n        //SYNC with register\n        //Add exising FUSD or create a new one and add it\n        let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n        if !fusdReceiver.check() {\n            let fusd \u003c- FUSD.createEmptyVault()\n            account.save(\u003c- fusd, to: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n        }\n\n        let usdcCap = account.getCapability\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e(FiatToken.VaultReceiverPubPath)\n        if !usdcCap.check() {\n                account.save( \u003c-FiatToken.createEmptyVault(), to: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e( FiatToken.VaultReceiverPubPath, target: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FiatToken.ResourceId}\u003e( FiatToken.VaultUUIDPubPath, target: FiatToken.VaultStoragePath)\n                account.link\u003c\u0026FiatToken.Vault{FungibleToken.Balance}\u003e( FiatToken.VaultBalancePubPath, target:FiatToken.VaultStoragePath)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let dandyCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        var created=false\n        var updated=false\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        if !profile.hasWallet(\"Flow\") {\n            let flowWallet=Profile.Wallet( name:\"Flow\", receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), tags: [\"flow\"])\n    \n            profile.addWallet(flowWallet)\n            updated=true\n        }\n        if !profile.hasWallet(\"FUSD\") {\n            profile.addWallet(Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), tags: [\"fusd\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if !profile.hasWallet(\"USDC\") {\n            profile.addWallet(Profile.Wallet( name:\"USDC\", receiver:usdcCap, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(FiatToken.VaultBalancePubPath), accept: Type\u003c@FiatToken.Vault\u003e(), tags: [\"usdc\", \"stablecoin\"]))\n            updated=true\n        }\n\n         //If find name not set and we have a profile set it.\n        if profile.getFindName() == \"\" {\n            if let findName = FIND.reverseLookup(account.address) {\n                profile.setFindName(findName)\n                // If name is set, it will emit Updated Event, there is no need to emit another update event below. \n                updated=false\n            }\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else if updated {\n            profile.emitUpdatedEvent()\n        }\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let tenantCapability= FindMarket.getTenantCapability(FindMarket.getFindTenantAddress())!\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        let doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        let doeSalePublicPath=FindMarket.getPublicPath(doeSaleType, name: tenant.name)\n        let doeSaleStoragePath= FindMarket.getStoragePath(doeSaleType, name:tenant.name)\n        let doeSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n        if !doeSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n        }\n\n        let doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        let doeBidPublicPath=FindMarket.getPublicPath(doeBidType, name: tenant.name)\n        let doeBidStoragePath= FindMarket.getStoragePath(doeBidType, name:tenant.name)\n        let doeBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n        if !doeBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n        }\n\n        /// auctions that escrow ft\n        let aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        let aeSalePublicPath=FindMarket.getPublicPath(aeSaleType, name: tenant.name)\n        let aeSaleStoragePath= FindMarket.getStoragePath(aeSaleType, name:tenant.name)\n        let aeSaleCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n        if !aeSaleCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n        }\n\n        let dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\n        let dosSalePublicPath=FindMarket.getPublicPath(dosSaleType, name: tenant.name)\n        let dosSaleStoragePath= FindMarket.getStoragePath(dosSaleType, name:tenant.name)\n\n        let dosSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n        if !dosSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n        }\n\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n        if !dosBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n        }\n\n        let aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\n        let aeBidPublicPath=FindMarket.getPublicPath(aeBidType, name: tenant.name)\n        let aeBidStoragePath= FindMarket.getStoragePath(aeBidType, name:tenant.name)\n        let aeBidCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n        if !aeBidCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n        }\n\n     /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n        }\n\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n        if !asBidCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n        }\n\n        let leaseTenantCapability= FindMarket.getTenantCapability(FindMarket.getTenantAddress(\"findLease\")!)!\n\n        let leaseSaleItemType= Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()\n        let leasePublicPath=FindMarket.getPublicPath(leaseSaleItemType, name: \"findLease\")\n        let leaseStoragePath= FindMarket.getStoragePath(leaseSaleItemType, name:\"findLease\")\n        let leaseSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath) \n        if !leaseSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketSale.SaleItemCollection\u003e(\u003c- FindLeaseMarketSale.createEmptySaleItemCollection(leaseTenantCapability), to: leaseStoragePath)\n            account.link\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath, target: leaseStoragePath)\n        }\n\n        let leaseASSaleItemType= Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e()\n        let leaseASPublicPath=FindMarket.getPublicPath(leaseASSaleItemType, name: \"findLease\")\n        let leaseASStoragePath= FindMarket.getStoragePath(leaseASSaleItemType, name:\"findLease\")\n        let leaseASSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath) \n        if !leaseASSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseASStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath, target: leaseASStoragePath)\n        }\n\n\n        let leaseASBidType= Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e()\n        let leaseASBidPublicPath=FindMarket.getPublicPath(leaseASBidType, name: \"findLease\")\n        let leaseASBidStoragePath= FindMarket.getStoragePath(leaseASBidType, name: \"findLease\")\n        let leaseASBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath) \n        if !leaseASBidCap.check() {\n            account.save\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseASBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath, target: leaseASBidStoragePath)\n        }\n\n        // let leaseAESaleItemType= Type\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e()\n        // let leaseAEPublicPath=FindMarket.getPublicPath(leaseAESaleItemType, name: \"findLease\")\n        // let leaseAEStoragePath= FindMarket.getStoragePath(leaseAESaleItemType, name:\"findLease\")\n        // let leaseAESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath) \n        // if !leaseAESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseAEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath, target: leaseAEStoragePath)\n        // }\n\n        // let leaseAEBidType= Type\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e()\n        // let leaseAEBidPublicPath=FindMarket.getPublicPath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidStoragePath= FindMarket.getStoragePath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath) \n        // if !leaseAEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseAEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath, target: leaseAEBidStoragePath)\n        // }\n\n        let leaseDOSSaleItemType= Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e()\n        let leaseDOSPublicPath=FindMarket.getPublicPath(leaseDOSSaleItemType, name: \"findLease\")\n        let leaseDOSStoragePath= FindMarket.getStoragePath(leaseDOSSaleItemType, name:\"findLease\")\n        let leaseDOSSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath) \n        if !leaseDOSSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOSStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath, target: leaseDOSStoragePath)\n        }\n\n        let leaseDOSBidType= Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let leaseDOSBidPublicPath=FindMarket.getPublicPath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidStoragePath= FindMarket.getStoragePath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath) \n        if !leaseDOSBidCap.check() {\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOSBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath, target: leaseDOSBidStoragePath)\n        }\n\n        // let leaseDOESaleItemType= Type\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        // let leaseDOEPublicPath=FindMarket.getPublicPath(leaseDOESaleItemType, name: \"findLease\")\n        // let leaseDOEStoragePath= FindMarket.getStoragePath(leaseDOESaleItemType, name:\"findLease\")\n        // let leaseDOESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath) \n        // if !leaseDOESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath, target: leaseDOEStoragePath)\n        // }\n\n        // let leaseDOEBidType= Type\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        // let leaseDOEBidPublicPath=FindMarket.getPublicPath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidStoragePath= FindMarket.getStoragePath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath) \n        // if !leaseDOEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath, target: leaseDOEBidStoragePath)\n        // }\n        //SYNC with register\n\n    }\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "delistAllLeaseSale": {
               "code": "import FindLeaseMarketSale from 0xf8d6e0586b0a20c7\nimport FindMarket from 0xf8d6e0586b0a20c7\nimport FindLeaseMarket from 0xf8d6e0586b0a20c7\n\ntransaction() {\n    prepare(account: AuthAccount) {\n        // Get all the saleItems Id\n\n        let tenant = FindMarket.getTenant(FindMarket.getTenantAddress(\"findLease\")!)\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindLeaseMarketSale.SaleItem\u003e())\n        let cap = FindLeaseMarket.getSaleItemCollectionCapability(tenantRef: tenant, marketOption: marketOption, address: account.address)\n        let ref = cap.borrow() ?? panic(\"Cannot borrow reference to the capability.\")\n\n        let listingType=Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()\n        let saleItems= account.borrow\u003c\u0026FindLeaseMarketSale.SaleItemCollection\u003e(from: tenant.getStoragePath(listingType))!\n        let leases = ref.getNameSales()\n        for lease in leases {\n            saleItems.delist(lease)\n        }\n    }\n}",
               "spec": {
                  "order": [],
                  "parameters": {}
               }
            },
            "delistAllNFTSale": {
               "code": "import FindMarketSale from 0xf8d6e0586b0a20c7\nimport FindMarket from 0xf8d6e0586b0a20c7\n\ntransaction(marketplace:Address) {\n\n    let saleItems : \u0026FindMarketSale.SaleItemCollection?\n\n    prepare(account: AuthAccount) {\n        let tenant = FindMarket.getTenant(marketplace)\n        self.saleItems= account.borrow\u003c\u0026FindMarketSale.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketSale.SaleItemCollection\u003e())) \n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        let ids = self.saleItems!.getIds()\n        for id in ids {\n            self.saleItems!.delist(id)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace"
                  ],
                  "parameters": {
                     "marketplace": "Address"
                  }
               }
            },
            "delistAllNameSale": {
               "code": "import FIND from 0xf8d6e0586b0a20c7\n\ntransaction() {\n\n    let finLeases : \u0026FIND.LeaseCollection?\n\n    prepare(acct: AuthAccount) {\n        self.finLeases= acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)\n\n    }\n\n    pre{\n        self.finLeases != nil : \"Cannot borrow reference to find lease collection\"\n    }\n\n    execute{\n        let leases = self.finLeases!.getLeaseInformation()\n        for lease in leases {\n            if lease.salePrice != nil {\n                self.finLeases!.delistSale(lease.name)\n            }\n        }\n    }\n}",
               "spec": {
                  "order": [],
                  "parameters": {}
               }
            },
            "delistLeaseSale": {
               "code": "import FindMarket from 0xf8d6e0586b0a20c7\nimport FindLeaseMarketSale from 0xf8d6e0586b0a20c7\n\ntransaction(leases: [String]) {\n    let saleItems : \u0026FindLeaseMarketSale.SaleItemCollection?\n\n    prepare(account: AuthAccount) {\n\n        let tenant=FindMarket.getTenant(FindMarket.getTenantAddress(\"findLease\")!)\n        self.saleItems= account.borrow\u003c\u0026FindLeaseMarketSale.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()))\n\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        for lease in leases {\n            self.saleItems!.delist(lease)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "leases"
                  ],
                  "parameters": {
                     "leases": "[String]"
                  }
               }
            },
            "delistNFTSale": {
               "code": "import FindMarket from 0xf8d6e0586b0a20c7\nimport FindMarketSale from 0xf8d6e0586b0a20c7\n\ntransaction(marketplace:Address, ids: [UInt64]) {\n\n    let saleItems : \u0026FindMarketSale.SaleItemCollection?\n\n    prepare(account: AuthAccount) {\n\n        let tenant=FindMarket.getTenant(marketplace)\n        self.saleItems= account.borrow\u003c\u0026FindMarketSale.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketSale.SaleItemCollection\u003e()))\n\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        for id in ids {\n            self.saleItems!.delist(id)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "ids"
                  ],
                  "parameters": {
                     "ids": "[UInt64]",
                     "marketplace": "Address"
                  }
               }
            },
            "delistNameSale": {
               "code": "import FIND from 0xf8d6e0586b0a20c7\n\ntransaction(names: [String]) {\n\n    let finLeases : \u0026FIND.LeaseCollection?\n\n    prepare(acct: AuthAccount) {\n        self.finLeases= acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)\n    }\n\n    pre{\n        self.finLeases != nil : \"Cannot borrow reference to find lease collection\"\n    }\n\n    execute{\n        for name in names {\n            self.finLeases!.delistSale(name)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "names"
                  ],
                  "parameters": {
                     "names": "[String]"
                  }
               }
            },
            "editProfile": {
               "code": "import FungibleToken from 0xee82856bf20e2aa6\nimport FUSD from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport FIND from 0xf8d6e0586b0a20c7\nimport Profile from 0xf8d6e0586b0a20c7\n\ntransaction(name:String, description: String, avatar: String, tags:[String], allowStoringFollowers: Bool, linkTitles : {String: String}, linkTypes: {String:String}, linkUrls : {String:String}, removeLinks : [String]) {\n    \n    let profile : \u0026Profile.User\n\n    prepare(account: AuthAccount) {\n\n        self.profile =account.borrow\u003c\u0026Profile.User\u003e(from:Profile.storagePath) ?? panic(\"Cannot borrow reference to profile\")\n\n        //Add exising FUSD or create a new one and add it\n        let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n        if !fusdReceiver.check() {\n            let fusd \u003c- FUSD.createEmptyVault()\n            account.save(\u003c- fusd, to: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n        }\n\n\n        var hasFusdWallet=false\n        var hasFlowWallet=false\n        let wallets=self.profile.getWallets()\n        for wallet in wallets {\n            if wallet.name==\"FUSD\" {\n                hasFusdWallet=true\n            }\n\n            if wallet.name ==\"Flow\" {\n                hasFlowWallet=true\n            }\n        }\n\n        if !hasFlowWallet {\n            let flowWallet=Profile.Wallet(\n                name:\"Flow\", \n                receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver),\n                balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance),\n                accept: Type\u003c@FlowToken.Vault\u003e(),\n                tags: [\"flow\"]\n            )\n            self.profile.addWallet(flowWallet)\n        }\n\n        if !hasFusdWallet {\n            let fusdWallet=Profile.Wallet(\n                name:\"FUSD\", \n                receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver),\n                balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance),\n                accept: Type\u003c@FUSD.Vault\u003e(),\n                tags: [\"fusd\", \"stablecoin\"]\n            )\n            self.profile.addWallet(fusdWallet)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n    }\n\n    execute{\n        self.profile!.setName(name)\n        self.profile!.setDescription(description)\n        self.profile!.setAvatar(avatar)\n        self.profile!.setTags(tags)\n\n        for link in removeLinks {\n            self.profile!.removeLink(link)\n        }\n\n        for titleName in linkTitles.keys {\n            let title=linkTitles[titleName]!\n            let url = linkUrls[titleName]!\n            let type = linkTypes[titleName]!\n\n            self.profile!.addLinkWithName(name:titleName, link: Profile.Link(title: title, type: type, url: url))\n        }\n        self.profile!.emitUpdatedEvent()\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "description",
                     "avatar",
                     "tags",
                     "allowStoringFollowers",
                     "linkTitles",
                     "linkTypes",
                     "linkUrls",
                     "removeLinks"
                  ],
                  "parameters": {
                     "allowStoringFollowers": "Bool",
                     "avatar": "String",
                     "description": "String",
                     "linkTitles": "{String: String}",
                     "linkTypes": "{String: String}",
                     "linkUrls": "{String: String}",
                     "name": "String",
                     "removeLinks": "[String]",
                     "tags": "[String]"
                  }
               }
            },
            "fulfillLeaseMarketAuctionSoft": {
               "code": "import FindLeaseMarketAuctionSoft from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FTRegistry from 0xf8d6e0586b0a20c7\nimport FindMarket from 0xf8d6e0586b0a20c7\nimport FindLeaseMarket from 0xf8d6e0586b0a20c7\n\ntransaction(leaseName: String, amount:UFix64) {\n\n    let walletReference : \u0026FungibleToken.Vault\n    let bidsReference: \u0026FindLeaseMarketAuctionSoft.MarketBidCollection\n    let requiredAmount: UFix64\n\n    prepare(account: AuthAccount) {\n        let marketplace = FindMarket.getTenantAddress(\"findLease\")!\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e())\n\n        self.bidsReference= account.borrow\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"This account does not have a bid collection\")\n\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e())\n        let item = FindLeaseMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, name: leaseName)\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n    \n        self.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n        self.requiredAmount = self.bidsReference.getBalance(leaseName)\n    }\n\n    pre{\n        self.walletReference.balance \u003e self.requiredAmount : \"Your wallet does not have enough funds to pay for this item\"\n        self.requiredAmount == amount : \"Amount needed to fulfill is \".concat(self.requiredAmount.toString()).concat(\" you sent in \").concat(amount.toString())\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount) \n        self.bidsReference.fulfillAuction(name: leaseName, vault: \u003c- vault)\n    }\n}",
               "spec": {
                  "order": [
                     "leaseName",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "leaseName": "String"
                  }
               }
            },
            "fulfillLeaseMarketAuctionSoftDUC": {
               "code": "import FindLeaseMarketAuctionSoft from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FTRegistry from 0xf8d6e0586b0a20c7\nimport FindMarket from 0xf8d6e0586b0a20c7\nimport FindLeaseMarket from 0xf8d6e0586b0a20c7\nimport DapperUtilityCoin from 0xf8d6e0586b0a20c7\n\ntransaction(leaseName: String, amount:UFix64) {\n\n    let walletReference : \u0026FungibleToken.Vault\n    let bidsReference: \u0026FindLeaseMarketAuctionSoft.MarketBidCollection\n    let requiredAmount: UFix64\n    let mainDapperUtilityCoinVault: \u0026DapperUtilityCoin.Vault\n    let balanceBeforeTransfer: UFix64\n\n    prepare(dapper: AuthAccount, account: AuthAccount) {\n        let marketplace = FindMarket.getTenantAddress(\"findLease\")!\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e())\n\n        self.bidsReference= account.borrow\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"This account does not have a bid collection\")\n\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e())\n        let item = FindLeaseMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, name: leaseName)\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n    \n        // There should be no need to assert this, there will be no listing in other tokens for Dapper wallet.\n        // if ft.type != Type\u003c@DapperUtilityCoin.Vault\u003e(){\n        //     panic(\"This item is not listed for Dapper Wallets. Please fulfill in with other wallets.\")\n        // }\n        self.mainDapperUtilityCoinVault = dapper.borrow\u003c\u0026DapperUtilityCoin.Vault\u003e(from: /storage/dapperUtilityCoinVault) ?? panic(\"Cannot borrow DapperUtilityCoin vault from account storage\")\n        self.balanceBeforeTransfer = self.mainDapperUtilityCoinVault.balance\n\n        self.walletReference = dapper.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n        self.requiredAmount = self.bidsReference.getBalance(leaseName)\n    }\n\n    pre{\n        self.walletReference.balance \u003e self.requiredAmount : \"Your wallet does not have enough funds to pay for this item\"\n        self.requiredAmount == amount : \"Amount needed to fulfill is \".concat(self.requiredAmount.toString()).concat(\" you sent in \").concat(amount.toString())\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount) \n        self.bidsReference.fulfillAuction(name: leaseName, vault: \u003c- vault)\n    }\n\n    // Check that all dapperUtilityCoin was routed back to Dapper\n    post {\n        self.mainDapperUtilityCoinVault.balance == self.balanceBeforeTransfer: \"DapperUtilityCoin leakage\"\n    }\n}",
               "spec": {
                  "order": [
                     "leaseName",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "leaseName": "String"
                  }
               }
            },
            "fulfillLeaseMarketDirectOfferSoft": {
               "code": "import FindLeaseMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FTRegistry from 0xf8d6e0586b0a20c7\nimport FindMarket from 0xf8d6e0586b0a20c7\nimport FindLeaseMarket from 0xf8d6e0586b0a20c7\n\ntransaction(leaseName: String, amount:UFix64) {\n\n    let walletReference : \u0026FungibleToken.Vault\n    let bidsReference: \u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection\n    let requiredAmount:UFix64\n\n    prepare(account: AuthAccount) {\n        let marketplace = FindMarket.getTenantAddress(\"findLease\")!\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e())\n        self.bidsReference= account.borrow\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"Cannot borrow direct offer soft bid collection\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e())\n        let item = FindLeaseMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, name: leaseName)\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n\n          self.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n\n        self.requiredAmount = self.bidsReference.getBalance(leaseName)\n    }\n\n    pre {\n        self.walletReference.balance \u003e self.requiredAmount : \"Your wallet does not have enough funds to pay for this item\"\n        self.requiredAmount == amount : \"Amount needed to fulfill is \".concat(amount.toString())\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount) \n        self.bidsReference.fulfillDirectOffer(name: leaseName, vault: \u003c- vault)\n    }\n}",
               "spec": {
                  "order": [
                     "leaseName",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "leaseName": "String"
                  }
               }
            },
            "fulfillLeaseMarketDirectOfferSoftDUC": {
               "code": "import FindLeaseMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FTRegistry from 0xf8d6e0586b0a20c7\nimport FindMarket from 0xf8d6e0586b0a20c7\nimport FindLeaseMarket from 0xf8d6e0586b0a20c7\nimport DapperUtilityCoin from 0xf8d6e0586b0a20c7\n\ntransaction(leaseName: String, amount:UFix64) {\n\n    let walletReference : \u0026FungibleToken.Vault\n    let bidsReference: \u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection\n    let requiredAmount:UFix64\n    let mainDapperUtilityCoinVault: \u0026DapperUtilityCoin.Vault\n    let balanceBeforeTransfer: UFix64\n\n    prepare(dapper: AuthAccount, account: AuthAccount) {\n        let marketplace = FindMarket.getTenantAddress(\"findLease\")!\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e())\n        self.bidsReference= account.borrow\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"Cannot borrow direct offer soft bid collection\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e())\n        let item = FindLeaseMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, name: leaseName)\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n\n        // There should be no need to assert this, there will be no listing in other tokens for Dapper wallet.\n        // if ft.type != Type\u003c@DapperUtilityCoin.Vault\u003e(){\n        //     panic(\"This item is not listed for Dapper Wallets. Please fulfill in with other wallets.\")\n        // }\n        self.mainDapperUtilityCoinVault = dapper.borrow\u003c\u0026DapperUtilityCoin.Vault\u003e(from: /storage/dapperUtilityCoinVault) ?? panic(\"Cannot borrow DapperUtilityCoin vault from account storage\")\n        self.balanceBeforeTransfer = self.mainDapperUtilityCoinVault.balance\n\n          self.walletReference = dapper.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n\n        self.requiredAmount = self.bidsReference.getBalance(leaseName)\n    }\n\n    pre {\n        self.walletReference.balance \u003e self.requiredAmount : \"Your wallet does not have enough funds to pay for this item\"\n        self.requiredAmount == amount : \"Amount needed to fulfill is \".concat(amount.toString())\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount) \n        self.bidsReference.fulfillDirectOffer(name: leaseName, vault: \u003c- vault)\n    }\n\n    // Check that all dapperUtilityCoin was routed back to Dapper\n    post {\n        self.mainDapperUtilityCoinVault.balance == self.balanceBeforeTransfer: \"DapperUtilityCoin leakage\"\n    }\n}",
               "spec": {
                  "order": [
                     "leaseName",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "leaseName": "String"
                  }
               }
            },
            "fulfillMarketAuctionEscrowed": {
               "code": "import FindMarketAuctionEscrow from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\n\ntransaction(marketplace:Address, owner: String, id: UInt64) {\n\n    let saleItem : Capability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic}\u003e?\n\n    prepare(account: AuthAccount) {\n        let resolveAddress = FIND.resolve(owner)\n        if resolveAddress == nil { \n            panic(\"The address input is not a valid name nor address. Input : \".concat(owner))\n        }\n        let address = resolveAddress!\n        self.saleItem = FindMarketAuctionEscrow.getSaleItemCapability(marketplace:marketplace, user:address)\n\n    }\n\n    pre{\n        self.saleItem != nil : \"This saleItem capability does not exist. Sale item ID: \".concat(id.toString())\n        self.saleItem!.check() : \"Cannot borrow reference to saleItem. Sale item ID: \".concat(id.toString())\n    }\n\n    execute {\n        self.saleItem!.borrow()!.fulfillAuction(id)\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "owner",
                     "id"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "marketplace": "Address",
                     "owner": "String"
                  }
               }
            },
            "fulfillMarketAuctionEscrowedFromBidder": {
               "code": "import FindMarketAuctionEscrow from 0xf8d6e0586b0a20c7\nimport FindMarket from 0xf8d6e0586b0a20c7\n\ntransaction(marketplace:Address, id: UInt64) {\n\n    let bidsReference : \u0026FindMarketAuctionEscrow.MarketBidCollection?\n\n    prepare(account: AuthAccount) {\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e())\n        self.bidsReference= account.borrow\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection\u003e(from: storagePath)\n\n        \n    }\n\n    pre{\n        self.bidsReference != nil : \"Cannot borrow reference to bid collection.\"\n    }\n\n    execute{\n        self.bidsReference!.fulfillAuction(id)\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "fulfillMarketAuctionSoft": {
               "code": "import FindMarketAuctionSoft from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FTRegistry from 0xf8d6e0586b0a20c7\nimport FindMarket from 0xf8d6e0586b0a20c7\n\ntransaction(marketplace:Address, id: UInt64, amount:UFix64) {\n\n    let walletReference : \u0026FungibleToken.Vault\n    let bidsReference: \u0026FindMarketAuctionSoft.MarketBidCollection\n    let requiredAmount: UFix64\n\n    prepare(account: AuthAccount) {\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e())\n\n        self.bidsReference= account.borrow\u003c\u0026FindMarketAuctionSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"This account does not have a bid collection\")\n\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e())\n        let item = FindMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: id)\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n    \n        self.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n        self.requiredAmount = self.bidsReference.getBalance(id)\n    }\n\n    pre{\n        self.walletReference.balance \u003e self.requiredAmount : \"Your wallet does not have enough funds to pay for this item\"\n        self.requiredAmount == amount : \"Amount needed to fulfill is \".concat(self.requiredAmount.toString()).concat(\" you sent in \").concat(amount.toString())\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount) \n        self.bidsReference.fulfillAuction(id: id, vault: \u003c- vault)\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "fulfillMarketAuctionSoftDUC": {
               "code": "import FindMarketAuctionSoft from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FTRegistry from 0xf8d6e0586b0a20c7\nimport FindMarket from 0xf8d6e0586b0a20c7\nimport DapperUtilityCoin from 0xf8d6e0586b0a20c7\n\ntransaction(marketplace:Address, id: UInt64, amount:UFix64) {\n\n    let walletReference : \u0026FungibleToken.Vault\n    let bidsReference: \u0026FindMarketAuctionSoft.MarketBidCollection\n    let requiredAmount: UFix64\n    let mainDapperUtilityCoinVault: \u0026DapperUtilityCoin.Vault\n    let balanceBeforeTransfer: UFix64\n\n    prepare(dapper: AuthAccount, account: AuthAccount) {\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e())\n\n        self.bidsReference= account.borrow\u003c\u0026FindMarketAuctionSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"This account does not have a bid collection\")\n\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e())\n        let item = FindMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: id)\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n    \n        // There should be no need to assert this, there will be no listing in other tokens for Dapper wallet.\n        // if ft.type != Type\u003c@DapperUtilityCoin.Vault\u003e(){\n        //     panic(\"This item is not listed for Dapper Wallets. Please fulfill in with other wallets.\")\n        // }\n        self.mainDapperUtilityCoinVault = dapper.borrow\u003c\u0026DapperUtilityCoin.Vault\u003e(from: /storage/dapperUtilityCoinVault) ?? panic(\"Cannot borrow DapperUtilityCoin vault from account storage\")\n        self.balanceBeforeTransfer = self.mainDapperUtilityCoinVault.balance\n\n        self.walletReference = dapper.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n        self.requiredAmount = self.bidsReference.getBalance(id)\n    }\n\n    pre{\n        self.walletReference.balance \u003e self.requiredAmount : \"Your wallet does not have enough funds to pay for this item\"\n        self.requiredAmount == amount : \"Amount needed to fulfill is \".concat(self.requiredAmount.toString()).concat(\" you sent in \").concat(amount.toString())\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount) \n        self.bidsReference.fulfillAuction(id: id, vault: \u003c- vault)\n    }\n\n    // Check that all dapperUtilityCoin was routed back to Dapper\n    post {\n        self.mainDapperUtilityCoinVault.balance == self.balanceBeforeTransfer: \"DapperUtilityCoin leakage\"\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "fulfillMarketDirectOfferEscrowed": {
               "code": "import FindMarketDirectOfferEscrow from 0xf8d6e0586b0a20c7\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FindViews from 0xf8d6e0586b0a20c7\nimport NFTCatalog from 0xf8d6e0586b0a20c7\nimport FINDNFTCatalog from 0xf8d6e0586b0a20c7\nimport FindMarket from 0xf8d6e0586b0a20c7\n\ntransaction(marketplace:Address, id: UInt64) {\n\n    let market : \u0026FindMarketDirectOfferEscrow.SaleItemCollection?\n    let pointer : FindViews.AuthNFTPointer\n\n    prepare(account: AuthAccount) {\n\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e())\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e())\n\n        let item = FindMarket.assertOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: id)\n\n        let nftIdentifier = item.getItemType().identifier\n        let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier)) \n        let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n        let nft = collection.collectionData\n\n    \n        var providerCap=account.getCapability\u003c\u0026{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e(nft.privatePath)\n\n        /* Ben : Question -\u003e Either client will have to provide the path here or agree that we set it up for the user */\n        if !providerCap.check() {\n            let newCap = account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                    nft.privatePath,\n                    target: nft.storagePath\n            )\n            if newCap == nil {\n                // If linking is not successful, we link it using finds custom link \n                let pathIdentifier = nft.privatePath.toString()\n                let findPath = PrivatePath(identifier: pathIdentifier.slice(from: \"/private/\".length , upTo: pathIdentifier.length).concat(\"_FIND\"))!\n                account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                    findPath,\n                    target: nft.storagePath\n                )\n                providerCap = account.getCapability\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(findPath)\n            }\n        }\n\n        self.pointer= FindViews.AuthNFTPointer(cap: providerCap, id: item.getItemID())\n        self.market = account.borrow\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection\u003e(from: storagePath)\n\n    }\n\n    pre{\n        self.market != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        self.market!.acceptDirectOffer(self.pointer)\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "fulfillMarketDirectOfferSoft": {
               "code": "import FindMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FTRegistry from 0xf8d6e0586b0a20c7\nimport FindMarket from 0xf8d6e0586b0a20c7\n\ntransaction(marketplace:Address, id: UInt64, amount:UFix64) {\n\n    let walletReference : \u0026FungibleToken.Vault\n    let bidsReference: \u0026FindMarketDirectOfferSoft.MarketBidCollection\n    let requiredAmount:UFix64\n\n    prepare(account: AuthAccount) {\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n        self.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"Cannot borrow direct offer soft bid collection\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n        let item = FindMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: id)\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n\n      self.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n\n        self.requiredAmount = self.bidsReference.getBalance(id)\n    }\n\n    pre {\n        self.walletReference.balance \u003e self.requiredAmount : \"Your wallet does not have enough funds to pay for this item\"\n        self.requiredAmount == amount : \"Amount needed to fulfill is \".concat(amount.toString())\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount) \n        self.bidsReference.fulfillDirectOffer(id: id, vault: \u003c- vault)\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "fulfillMarketDirectOfferSoftDUC": {
               "code": "import FindMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FTRegistry from 0xf8d6e0586b0a20c7\nimport FindMarket from 0xf8d6e0586b0a20c7\nimport DapperUtilityCoin from 0xf8d6e0586b0a20c7\n\ntransaction(marketplace:Address, id: UInt64, amount:UFix64) {\n\n    let walletReference : \u0026FungibleToken.Vault\n    let bidsReference: \u0026FindMarketDirectOfferSoft.MarketBidCollection\n    let requiredAmount:UFix64\n    let mainDapperUtilityCoinVault: \u0026DapperUtilityCoin.Vault\n    let balanceBeforeTransfer: UFix64\n\n    prepare(dapper: AuthAccount, account: AuthAccount) {\n\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n        self.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"Cannot borrow direct offer soft bid collection\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n        let item = FindMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: id)\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n\n        // There should be no need to assert this, there will be no listing in other tokens for Dapper wallet.\n        // if ft.type != Type\u003c@DapperUtilityCoin.Vault\u003e(){\n        //     panic(\"This item is not listed for Dapper Wallets. Please fulfill in with other wallets.\")\n        // }\n        self.mainDapperUtilityCoinVault = dapper.borrow\u003c\u0026DapperUtilityCoin.Vault\u003e(from: /storage/dapperUtilityCoinVault) ?? panic(\"Cannot borrow DapperUtilityCoin vault from account storage\")\n        self.balanceBeforeTransfer = self.mainDapperUtilityCoinVault.balance\n\n          self.walletReference = dapper.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n\n        self.requiredAmount = self.bidsReference.getBalance(id)\n    }\n\n    pre {\n        self.walletReference.balance \u003e self.requiredAmount : \"Your wallet does not have enough funds to pay for this item\"\n        self.requiredAmount == amount : \"Amount needed to fulfill is \".concat(amount.toString())\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount) \n        self.bidsReference.fulfillDirectOffer(id: id, vault: \u003c- vault)\n    }\n\n    // Check that all dapperUtilityCoin was routed back to Dapper\n    post {\n        self.mainDapperUtilityCoinVault.balance == self.balanceBeforeTransfer: \"DapperUtilityCoin leakage\"\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "fulfillMultipleMarketDirectOfferEscrowed": {
               "code": "import FindMarketDirectOfferEscrow from 0xf8d6e0586b0a20c7\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FindViews from 0xf8d6e0586b0a20c7\nimport NFTCatalog from 0xf8d6e0586b0a20c7\nimport FINDNFTCatalog from 0xf8d6e0586b0a20c7\nimport FindMarket from 0xf8d6e0586b0a20c7\n\ntransaction(marketplace:Address, ids: [UInt64]) {\n\n    let market : \u0026FindMarketDirectOfferEscrow.SaleItemCollection?\n    let pointer : [FindViews.AuthNFTPointer]\n\n    prepare(account: AuthAccount) {\n\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e())\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e())\n        self.market = account.borrow\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection\u003e(from: storagePath)\n        self.pointer = []\n\n        let nfts : {String : NFTCatalog.NFTCollectionData} = {}\n        var counter = 0\n        while counter \u003c ids.length {\n            let item = FindMarket.assertOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: ids[counter])\n\n            var nft : NFTCatalog.NFTCollectionData? = nil\n            let nftIdentifier = item.getItemType().identifier\n\n            if nfts[nftIdentifier] != nil {\n                nft = nfts[nftIdentifier]\n            } else {\n                let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier)) \n                let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n                nft = collection.collectionData\n                nfts[nftIdentifier] = nft\n            }\n        \n            var providerCap=account.getCapability\u003c\u0026{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e(nft!.privatePath)\n\n            /* Ben : Question -\u003e Either client will have to provide the path here or agree that we set it up for the user */\n            if !providerCap.check() {\n                let newCap = account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                        nft!.privatePath,\n                        target: nft!.storagePath\n                )\n                if newCap == nil {\n                    // If linking is not successful, we link it using finds custom link \n                    let pathIdentifier = nft!.privatePath.toString()\n                    let findPath = PrivatePath(identifier: pathIdentifier.slice(from: \"/private/\".length , upTo: pathIdentifier.length).concat(\"_FIND\"))!\n                    account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                        findPath,\n                        target: nft!.storagePath\n                    )\n                    providerCap = account.getCapability\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(findPath)\n                }\n            }\n\n            let pointer= FindViews.AuthNFTPointer(cap: providerCap, id: item.getItemID())\n            self.pointer.append(pointer)\n            counter = counter + 1\n        }\n\n    }\n\n    pre{\n        self.market != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        var counter = 0\n        while counter \u003c ids.length {\n            self.market!.acceptDirectOffer(self.pointer[counter])\n            counter = counter + 1\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "ids"
                  ],
                  "parameters": {
                     "ids": "[UInt64]",
                     "marketplace": "Address"
                  }
               }
            },
            "fulfillMultipleMarketDirectOfferSoft": {
               "code": "import FindMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FTRegistry from 0xf8d6e0586b0a20c7\nimport FindMarket from 0xf8d6e0586b0a20c7\n\ntransaction(marketplace:Address, ids: [UInt64], amounts:[UFix64]) {\n\n    let walletReference : [\u0026FungibleToken.Vault]\n    let bidsReference: \u0026FindMarketDirectOfferSoft.MarketBidCollection\n    let requiredAmount: [UFix64]\n\n    prepare(account: AuthAccount) {\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n        self.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"Cannot borrow direct offer soft bid collection\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n\n        var counter = 0\n        self.requiredAmount = []\n        self.walletReference = []\n        let fts : {String : FTRegistry.FTInfo} = {}\n        let vaultRefs : {StoragePath : \u0026FungibleToken.Vault} = {}\n\n\n        while counter \u003c ids.length {\n            let item = FindMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: ids[counter])\n\n            var ft : FTRegistry.FTInfo? = nil\n            let ftIdentifier = item.getFtType().identifier\n            if fts[ftIdentifier] != nil {\n                ft = fts[ftIdentifier]\n            } else {\n                ft = FTRegistry.getFTInfoByTypeIdentifier(ftIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftIdentifier))\n                fts[ftIdentifier] = ft\n            }\n\n            if vaultRefs[ft!.vaultPath] != nil {\n                self.walletReference.append(vaultRefs[ft!.vaultPath]!)\n            } else {\n                let walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft!.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n                vaultRefs[ft!.vaultPath] = walletReference\n                self.walletReference.append(walletReference)\n            }\n            let requiredAmount = self.bidsReference.getBalance(ids[counter])\n            self.requiredAmount.append(requiredAmount)\n            counter = counter + 1\n        }\n    }\n\n    execute {\n        var counter = 0\n        while counter \u003c ids.length {\n            if self.walletReference[counter].balance \u003c self.requiredAmount[counter] {\n                panic(\"Your wallet does not have enough funds to pay for this item. Item ID: \".concat(ids[counter].toString()))\n            }\n            if self.requiredAmount[counter] != amounts[counter] {\n                panic(\"Amount needed to fulfill is \".concat(amounts[counter].toString()))\n            }\n            let vault \u003c- self.walletReference[counter].withdraw(amount: amounts[counter]) \n            self.bidsReference.fulfillDirectOffer(id: ids[counter], vault: \u003c- vault)\n            counter = counter + 1\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "ids",
                     "amounts"
                  ],
                  "parameters": {
                     "amounts": "[UFix64]",
                     "ids": "[UInt64]",
                     "marketplace": "Address"
                  }
               }
            },
            "fulfillMultipleMarketDirectOfferSoftDUC": {
               "code": "import FindMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FTRegistry from 0xf8d6e0586b0a20c7\nimport FindMarket from 0xf8d6e0586b0a20c7\nimport DapperUtilityCoin from 0xf8d6e0586b0a20c7\n\ntransaction(marketplace:Address, ids: [UInt64], amounts:[UFix64]) {\n\n    let walletReference : \u0026FungibleToken.Vault\n    let bidsReference: \u0026FindMarketDirectOfferSoft.MarketBidCollection\n    var requiredAmount:UFix64\n    let balanceBeforeTransfer: UFix64\n    var totalAmount: UFix64\n\n    prepare(dapper: AuthAccount, account: AuthAccount) {\n\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n        self.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"Cannot borrow direct offer soft bid collection\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n          self.walletReference = dapper.borrow\u003c\u0026DapperUtilityCoin.Vault\u003e(from: /storage/dapperUtilityCoinVault) ?? panic(\"Cannot borrow DapperUtilityCoin vault from account storage\")\n        self.balanceBeforeTransfer = self.walletReference.balance\n\n        var counter = 0\n        self.totalAmount = 0.0\n        self.requiredAmount = 0.0\n        while counter \u003c ids.length {\n            let item = FindMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: ids[counter])\n            self.requiredAmount = self.requiredAmount + self.bidsReference.getBalance(ids[counter])\n            self.totalAmount = self.totalAmount + amounts[counter]\n            counter = counter + 1\n        }\n    }\n\n    pre {\n        self.walletReference.balance \u003e self.requiredAmount : \"Your wallet does not have enough funds to pay for this item\"\n        self.requiredAmount == self.totalAmount : \"Amount needed to fulfill is \".concat(self.totalAmount.toString())\n    }\n\n    execute {\n        var counter = 0\n        while counter \u003c ids.length {\n            let vault \u003c- self.walletReference.withdraw(amount: amounts[counter]) \n            self.bidsReference.fulfillDirectOffer(id: ids[counter], vault: \u003c- vault)\n            counter = counter + 1 \n        }\n    }\n\n    // Check that all dapperUtilityCoin was routed back to Dapper\n    post {\n        self.walletReference.balance == self.balanceBeforeTransfer: \"DapperUtilityCoin leakage\"\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "ids",
                     "amounts"
                  ],
                  "parameters": {
                     "amounts": "[UFix64]",
                     "ids": "[UInt64]",
                     "marketplace": "Address"
                  }
               }
            },
            "fulfillName": {
               "code": "import FIND from 0xf8d6e0586b0a20c7\nimport Profile from 0xf8d6e0586b0a20c7\n\ntransaction(name: String) {\n\n    let finLeases : \u0026FIND.LeaseCollection?\n\n    prepare(account: AuthAccount) {\n        self.finLeases= account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath) \n    }\n\n    pre{\n        self.finLeases != nil : \"Cannot borrow reference to find lease collection\"\n    }\n\n    execute{\n        self.finLeases!.fulfill(name)\n    }\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "fulfillNameAuction": {
               "code": "import FIND from 0xf8d6e0586b0a20c7\nimport Profile from 0xf8d6e0586b0a20c7\n\ntransaction(owner: Address, name: String) {\n\n    let leases : \u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}?\n\n    prepare(account: AuthAccount) {\n        self.leases = getAccount(owner).getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath).borrow()\n    }\n\n    pre{\n        self.leases != nil : \"Cannot borrow reference to lease collection reference. Account address: \".concat(owner.toString())\n    }\n\n    execute{\n        self.leases!.fulfillAuction(name)\n    }\n}",
               "spec": {
                  "order": [
                     "owner",
                     "name"
                  ],
                  "parameters": {
                     "name": "String",
                     "owner": "Address"
                  }
               }
            },
            "fulfillNameAuctionBidder": {
               "code": "import FIND from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FUSD from 0xf8d6e0586b0a20c7\nimport Profile from 0xf8d6e0586b0a20c7\n\ntransaction(owner: Address, name: String) {\n\n    let leaseCollectionOwner : \u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}?\n\n    prepare(account: AuthAccount) {\n\n\n    //Add exising FUSD or create a new one and add it\n        let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n        if !fusdReceiver.check() {\n            let fusd \u003c- FUSD.createEmptyVault()\n            account.save(\u003c- fusd, to: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n\n            let fusdWallet=Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), tags: [\"fusd\", \"stablecoin\"])\n\n            profile.addWallet(fusdWallet)\n\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n        }\n\n        self.leaseCollectionOwner = getAccount(owner).getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath).borrow()\n\n    }\n\n    pre{\n        self.leaseCollectionOwner != nil : \"Cannot borrow reference to find lease collection. Account address: \".concat(owner.toString())\n    }\n\n    execute {\n        self.leaseCollectionOwner!.fulfillAuction(name)\n    }\n}",
               "spec": {
                  "order": [
                     "owner",
                     "name"
                  ],
                  "parameters": {
                     "name": "String",
                     "owner": "Address"
                  }
               }
            },
            "increaseBidLeaseMarketAuctionSoft": {
               "code": "import FindLeaseMarketAuctionSoft from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FTRegistry from 0xf8d6e0586b0a20c7\nimport FindMarket from 0xf8d6e0586b0a20c7\nimport FindLeaseMarket from 0xf8d6e0586b0a20c7\n\ntransaction(leaseName: String, amount: UFix64) {\n\n    let bidsReference: \u0026FindLeaseMarketAuctionSoft.MarketBidCollection\n\n    prepare(account: AuthAccount) {\n        let marketplace = FindMarket.getTenantAddress(\"findLease\")!\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e())\n        self.bidsReference= account.borrow\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"Bid resource does not exist\")\n        // get Bidding Fungible Token Vault\n          let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e())\n        let item = FindLeaseMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, name: leaseName)\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n\n        let walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) \n        if ft.alias != \"DUC\" \u0026\u0026 walletReference == nil {\n            panic(\"No suitable wallet linked for this account\")\n        }\n    }\n\n    execute {\n        self.bidsReference.increaseBid(name: leaseName, increaseBy: amount)\n    }\n\n}",
               "spec": {
                  "order": [
                     "leaseName",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "leaseName": "String"
                  }
               }
            },
            "increaseBidLeaseMarketDirectOfferSoft": {
               "code": "import FindLeaseMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\nimport FindMarket from 0xf8d6e0586b0a20c7\nimport FindLeaseMarket from 0xf8d6e0586b0a20c7\n\ntransaction(leaseName: String, amount: UFix64) {\n\n    let bidsReference: \u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection\n\n    prepare(account: AuthAccount) {\n        let marketplace = FindMarket.getTenantAddress(\"findLease\")!\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e())\n        self.bidsReference= account.borrow\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"Bid resource does not exist\")\n        // get Bidding Fungible Token Vault\n          let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e())\n        let item = FindLeaseMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, name: leaseName)\n    }\n\n    execute {\n        self.bidsReference.increaseBid(name: leaseName, increaseBy: amount)\n    }\n}",
               "spec": {
                  "order": [
                     "leaseName",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "leaseName": "String"
                  }
               }
            },
            "increaseBidMarketAuctionEscrowed": {
               "code": "import FindMarketAuctionEscrow from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FTRegistry from 0xf8d6e0586b0a20c7\nimport FindMarket from 0xf8d6e0586b0a20c7\n\ntransaction(marketplace:Address, id: UInt64, amount: UFix64) {\n\n    let walletReference : \u0026FungibleToken.Vault\n    let bidsReference: \u0026FindMarketAuctionEscrow.MarketBidCollection\n    let balanceBeforeBid: UFix64\n\n    prepare(account: AuthAccount) {\n\n        // Get the accepted vault type from BidInfo\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e())\n        self.bidsReference= account.borrow\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection\u003e(from: storagePath) ?? panic(\"This account does not have a bid collection\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e())\n        let item = FindMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: id)\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n        self.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n        self.balanceBeforeBid = self.walletReference.balance\n    }\n\n    pre {\n        self.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount) \n        self.bidsReference.increaseBid(id: id, vault: \u003c- vault)\n    }\n\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "increaseBidMarketAuctionSoft": {
               "code": "import FindMarketAuctionSoft from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FTRegistry from 0xf8d6e0586b0a20c7\nimport FindMarket from 0xf8d6e0586b0a20c7\n\ntransaction(marketplace:Address, id: UInt64, amount: UFix64) {\n\n    let bidsReference: \u0026FindMarketAuctionSoft.MarketBidCollection\n\n\n    prepare(account: AuthAccount) {\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e())\n        self.bidsReference= account.borrow\u003c\u0026FindMarketAuctionSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"Bid resource does not exist\")\n        // get Bidding Fungible Token Vault\n          let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e())\n        let item = FindMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: id)\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n\n        let walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath)\n        if ft.alias != \"DUC\" \u0026\u0026 walletReference == nil {\n            panic(\"No suitable wallet linked for this account\")\n        }\n    }\n\n    execute {\n        self.bidsReference.increaseBid(id: id, increaseBy: amount)\n    }\n\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "increaseBidMarketDirectOfferEscrowed": {
               "code": "import FindMarketDirectOfferEscrow from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FTRegistry from 0xf8d6e0586b0a20c7\nimport FindMarket from 0xf8d6e0586b0a20c7\n\ntransaction(marketplace:Address, id: UInt64, amount: UFix64) {\n\n    let walletReference : \u0026FungibleToken.Vault\n    let bidsReference: \u0026FindMarketDirectOfferEscrow.MarketBidCollection\n    let balanceBeforeBid: UFix64\n\n    prepare(account: AuthAccount) {\n        let tenant=FindMarket.getTenantCapability(marketplace)!.borrow() ?? panic(\"Cannot borrow reference to tenant\")\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e())\n        self.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection\u003e(from: storagePath) ?? panic(\"This account does not have a bid collection\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e())\n        let item = FindMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: id)\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n        self.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n        self.balanceBeforeBid=self.walletReference.balance\n    }\n\n    pre {\n        self.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount) \n        self.bidsReference!.increaseBid(id: id, vault: \u003c- vault)\n    }\n\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "increaseBidMarketDirectOfferSoft": {
               "code": "import FindMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\nimport FindMarket from 0xf8d6e0586b0a20c7\n\ntransaction(marketplace: Address, id: UInt64, amount: UFix64) {\n\n    let bidsReference: \u0026FindMarketDirectOfferSoft.MarketBidCollection\n\n    prepare(account: AuthAccount) {\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n        self.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"Bid resource does not exist\")\n        // get Bidding Fungible Token Vault\n          let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n        let item = FindMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: id)\n    }\n\n    execute {\n        self.bidsReference.increaseBid(id: id, increaseBy: amount)\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "increaseNameBid": {
               "code": "import FIND from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FUSD from 0xf8d6e0586b0a20c7\n\ntransaction(name: String, amount: UFix64) {\n\n    let vaultRef : \u0026FUSD.Vault?\n    let bids : \u0026FIND.BidCollection?\n\n    prepare(account: AuthAccount) {\n\n        \n        let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        self.vaultRef = account.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault)\n        self.bids = account.borrow\u003c\u0026FIND.BidCollection\u003e(from: FIND.BidStoragePath)\n    }\n\n    pre{\n        self.vaultRef != nil : \"Could not borrow reference to the fusdVault!\"\n        self.bids != nil : \"Could not borrow reference to bid collection\"\n    }\n\n    execute{\n        let vault \u003c- self.vaultRef!.withdraw(amount: amount) as! @FUSD.Vault\n        self.bids!.increaseBid(name: name, vault: \u003c- vault)\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "name": "String"
                  }
               }
            },
            "listLeaseForAuctionSoft": {
               "code": "import FindMarket from 0xf8d6e0586b0a20c7\nimport FindMarketSale from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionSoft from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FindViews from 0xf8d6e0586b0a20c7\nimport FTRegistry from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FUSD from 0xf8d6e0586b0a20c7\nimport FiatToken from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport FIND from 0xf8d6e0586b0a20c7\nimport Dandy from 0xf8d6e0586b0a20c7\nimport Profile from 0xf8d6e0586b0a20c7\nimport FindLeaseMarketSale from 0xf8d6e0586b0a20c7\nimport FindLeaseMarketAuctionSoft from 0xf8d6e0586b0a20c7\n// import FindLeaseMarketAuctionEscrow from \"../contracts/FindLeaseMarketAuctionEscrow.cdc\"\nimport FindLeaseMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\n// import FindLeaseMarketDirectOfferEscrow from \"../contracts/FindLeaseMarketDirectOfferEscrow.cdc\"\nimport FindLeaseMarket from 0xf8d6e0586b0a20c7\n\ntransaction(leaseName: String, ftAliasOrIdentifier:String, price:UFix64, auctionReservePrice: UFix64, auctionDuration: UFix64, auctionExtensionOnLateBid: UFix64, minimumBidIncrement: UFix64, auctionValidUntil: UFix64?) {\n    \n    let saleItems : \u0026FindLeaseMarketAuctionSoft.SaleItemCollection?\n    let pointer : FindLeaseMarket.AuthLeasePointer\n    let vaultType : Type\n    \n    prepare(account: AuthAccount) {\n\n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n        //SYNC with register\n        //Add exising FUSD or create a new one and add it\n        let name = account.address.toString()\n        let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n        if !fusdReceiver.check() {\n            let fusd \u003c- FUSD.createEmptyVault()\n            account.save(\u003c- fusd, to: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n        }\n\n        let usdcCap = account.getCapability\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e(FiatToken.VaultReceiverPubPath)\n        if !usdcCap.check() {\n                account.save( \u003c-FiatToken.createEmptyVault(), to: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e( FiatToken.VaultReceiverPubPath, target: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FiatToken.ResourceId}\u003e( FiatToken.VaultUUIDPubPath, target: FiatToken.VaultStoragePath)\n                account.link\u003c\u0026FiatToken.Vault{FungibleToken.Balance}\u003e( FiatToken.VaultBalancePubPath, target:FiatToken.VaultStoragePath)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let dandyCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        let dandyCapPrivate= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPrivatePath)\n        if !dandyCapPrivate.check() {\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        var created=false\n        var updated=false\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        if !profile.hasWallet(\"Flow\") {\n            let flowWallet=Profile.Wallet( name:\"Flow\", receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), tags: [\"flow\"])\n    \n            profile.addWallet(flowWallet)\n            updated=true\n        }\n        if !profile.hasWallet(\"FUSD\") {\n            profile.addWallet(Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), tags: [\"fusd\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if !profile.hasWallet(\"USDC\") {\n            profile.addWallet(Profile.Wallet( name:\"USDC\", receiver:usdcCap, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(FiatToken.VaultBalancePubPath), accept: Type\u003c@FiatToken.Vault\u003e(), tags: [\"usdc\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else if updated {\n            profile.emitUpdatedEvent()\n        }\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        let doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        let doeSalePublicPath=FindMarket.getPublicPath(doeSaleType, name: tenant.name)\n        let doeSaleStoragePath= FindMarket.getStoragePath(doeSaleType, name:tenant.name)\n        let doeSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n        if !doeSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n        }\n\n        let doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        let doeBidPublicPath=FindMarket.getPublicPath(doeBidType, name: tenant.name)\n        let doeBidStoragePath= FindMarket.getStoragePath(doeBidType, name:tenant.name)\n        let doeBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n        if !doeBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n        }\n\n        /// auctions that escrow ft\n        let aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        let aeSalePublicPath=FindMarket.getPublicPath(aeSaleType, name: tenant.name)\n        let aeSaleStoragePath= FindMarket.getStoragePath(aeSaleType, name:tenant.name)\n        let aeSaleCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n        if !aeSaleCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n        }\n\n        let dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\n        let dosSalePublicPath=FindMarket.getPublicPath(dosSaleType, name: tenant.name)\n        let dosSaleStoragePath= FindMarket.getStoragePath(dosSaleType, name:tenant.name)\n\n        let dosSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n        if !dosSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n        }\n\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n        if !dosBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n        }\n\n        let aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\n        let aeBidPublicPath=FindMarket.getPublicPath(aeBidType, name: tenant.name)\n        let aeBidStoragePath= FindMarket.getStoragePath(aeBidType, name:tenant.name)\n        let aeBidCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n        if !aeBidCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n        }\n\n     /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n        }\n\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n        if !asBidCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n        }\n\n        let leaseTenantCapability= FindMarket.getTenantCapability(FindMarket.getTenantAddress(\"findLease\")!)!\n\n        let leaseSaleItemType= Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()\n        let leasePublicPath=FindMarket.getPublicPath(leaseSaleItemType, name: \"findLease\")\n        let leaseStoragePath= FindMarket.getStoragePath(leaseSaleItemType, name:\"findLease\")\n        let leaseSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath) \n        if !leaseSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketSale.SaleItemCollection\u003e(\u003c- FindLeaseMarketSale.createEmptySaleItemCollection(leaseTenantCapability), to: leaseStoragePath)\n            account.link\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath, target: leaseStoragePath)\n        }\n\n        let leaseASSaleItemType= Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e()\n        let leaseASPublicPath=FindMarket.getPublicPath(leaseASSaleItemType, name: \"findLease\")\n        let leaseASStoragePath= FindMarket.getStoragePath(leaseASSaleItemType, name:\"findLease\")\n        let leaseASSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath) \n        if !leaseASSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseASStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath, target: leaseASStoragePath)\n        }\n\n\n        let leaseASBidType= Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e()\n        let leaseASBidPublicPath=FindMarket.getPublicPath(leaseASBidType, name: \"findLease\")\n        let leaseASBidStoragePath= FindMarket.getStoragePath(leaseASBidType, name: \"findLease\")\n        let leaseASBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath) \n        if !leaseASBidCap.check() {\n            account.save\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseASBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath, target: leaseASBidStoragePath)\n        }\n\n        // let leaseAESaleItemType= Type\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e()\n        // let leaseAEPublicPath=FindMarket.getPublicPath(leaseAESaleItemType, name: \"findLease\")\n        // let leaseAEStoragePath= FindMarket.getStoragePath(leaseAESaleItemType, name:\"findLease\")\n        // let leaseAESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath) \n        // if !leaseAESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseAEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath, target: leaseAEStoragePath)\n        // }\n\n        // let leaseAEBidType= Type\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e()\n        // let leaseAEBidPublicPath=FindMarket.getPublicPath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidStoragePath= FindMarket.getStoragePath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath) \n        // if !leaseAEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseAEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath, target: leaseAEBidStoragePath)\n        // }\n\n        let leaseDOSSaleItemType= Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e()\n        let leaseDOSPublicPath=FindMarket.getPublicPath(leaseDOSSaleItemType, name: \"findLease\")\n        let leaseDOSStoragePath= FindMarket.getStoragePath(leaseDOSSaleItemType, name:\"findLease\")\n        let leaseDOSSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath) \n        if !leaseDOSSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOSStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath, target: leaseDOSStoragePath)\n        }\n\n        let leaseDOSBidType= Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let leaseDOSBidPublicPath=FindMarket.getPublicPath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidStoragePath= FindMarket.getStoragePath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath) \n        if !leaseDOSBidCap.check() {\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOSBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath, target: leaseDOSBidStoragePath)\n        }\n\n        // let leaseDOESaleItemType= Type\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        // let leaseDOEPublicPath=FindMarket.getPublicPath(leaseDOESaleItemType, name: \"findLease\")\n        // let leaseDOEStoragePath= FindMarket.getStoragePath(leaseDOESaleItemType, name:\"findLease\")\n        // let leaseDOESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath) \n        // if !leaseDOESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath, target: leaseDOEStoragePath)\n        // }\n\n        // let leaseDOEBidType= Type\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        // let leaseDOEBidPublicPath=FindMarket.getPublicPath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidStoragePath= FindMarket.getStoragePath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath) \n        // if !leaseDOEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath, target: leaseDOEBidStoragePath)\n        // }\n        //SYNC with register\n\n        // Get supported NFT and FT Information from Registries from input alias\n        let ft = FTRegistry.getFTInfo(ftAliasOrIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftAliasOrIdentifier))\n        \n        let leaseTenant = leaseTenantCapability.borrow()!\n        self.saleItems= account.borrow\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(from: leaseTenant.getStoragePath(Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e()))\n        let ref = account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from: FIND.LeaseStoragePath)!\n        self.pointer= FindLeaseMarket.AuthLeasePointer(ref: ref, name: leaseName)\n        self.vaultType= ft.type\n\n    }\n\n    pre{\n        // Ben : panic on some unreasonable inputs in trxn \n        minimumBidIncrement \u003e 0.0 :\"Minimum bid increment should be larger than 0.\"\n        (auctionReservePrice - auctionReservePrice) % minimumBidIncrement == 0.0 : \"Acution ReservePrice should be in step of minimum bid increment.\" \n        auctionDuration \u003e 0.0 : \"Auction Duration should be greater than 0.\"\n        auctionExtensionOnLateBid \u003e 0.0 : \"Auction Duration should be greater than 0.\"\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        self.saleItems!.listForAuction(pointer: self.pointer, vaultType: self.vaultType, auctionStartPrice: price, auctionReservePrice: auctionReservePrice, auctionDuration: auctionDuration, auctionExtensionOnLateBid: auctionExtensionOnLateBid, minimumBidIncrement: minimumBidIncrement, auctionValidUntil: auctionValidUntil, saleItemExtraField: {})\n\n    }\n}",
               "spec": {
                  "order": [
                     "leaseName",
                     "ftAliasOrIdentifier",
                     "price",
                     "auctionReservePrice",
                     "auctionDuration",
                     "auctionExtensionOnLateBid",
                     "minimumBidIncrement",
                     "auctionValidUntil"
                  ],
                  "parameters": {
                     "auctionDuration": "UFix64",
                     "auctionExtensionOnLateBid": "UFix64",
                     "auctionReservePrice": "UFix64",
                     "auctionValidUntil": "UFix64?",
                     "ftAliasOrIdentifier": "String",
                     "leaseName": "String",
                     "minimumBidIncrement": "UFix64",
                     "price": "UFix64"
                  }
               }
            },
            "listLeaseForAuctionSoftDUC": {
               "code": "import FindMarket from 0xf8d6e0586b0a20c7\nimport FindMarketSale from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionSoft from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FindViews from 0xf8d6e0586b0a20c7\nimport FTRegistry from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport TokenForwarding from 0xf8d6e0586b0a20c7\nimport DapperUtilityCoin from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\nimport Dandy from 0xf8d6e0586b0a20c7\nimport Profile from 0xf8d6e0586b0a20c7\nimport FindLeaseMarketSale from 0xf8d6e0586b0a20c7\nimport FindLeaseMarketAuctionSoft from 0xf8d6e0586b0a20c7\n// import FindLeaseMarketAuctionEscrow from \"../contracts/FindLeaseMarketAuctionEscrow.cdc\"\nimport FindLeaseMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\n// import FindLeaseMarketDirectOfferEscrow from \"../contracts/FindLeaseMarketDirectOfferEscrow.cdc\"\nimport FindLeaseMarket from 0xf8d6e0586b0a20c7\n\ntransaction(dapperAddress: Address, leaseName: String, price:UFix64, auctionReservePrice: UFix64, auctionDuration: UFix64, auctionExtensionOnLateBid: UFix64, minimumBidIncrement: UFix64, auctionValidUntil: UFix64?) {\n    \n    let saleItems : \u0026FindLeaseMarketAuctionSoft.SaleItemCollection?\n    let pointer : FindLeaseMarket.AuthLeasePointer\n    let vaultType : Type\n    \n    prepare(account: AuthAccount) {\n\n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n        //SYNC with register\n        //Add exising FUSD or create a new one and add it\n        let name = account.address.toString()\n        let ducReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver)\n        if !ducReceiver.check() {\n            let dapper = getAccount(dapperAddress)\n            // Create a new Forwarder resource for DUC and store it in the new account's storage\n            let ducForwarder \u003c- TokenForwarding.createNewForwarder(recipient: dapper.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver))\n            account.save(\u003c-ducForwarder, to: /storage/dapperUtilityCoinReceiver)\n            // Publish a Receiver capability for the new account, which is linked to the DUC Forwarder\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver,target: /storage/dapperUtilityCoinReceiver)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: ducReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let dandyCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        let dandyCapPrivate= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPrivatePath)\n        if !dandyCapPrivate.check() {\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        var created=false\n        var updated=false\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        if !profile.hasWallet(\"Flow\") {\n            let flowWallet=Profile.Wallet( name:\"Flow\", receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), tags: [\"flow\"])\n    \n            profile.addWallet(flowWallet)\n            updated=true\n        }\n        if !profile.hasWallet(\"DUC\") {\n            profile.addWallet(Profile.Wallet( name:\"DUC\", receiver:ducReceiver, balance:getAccount(dapperAddress).getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/dapperUtilityCoinBalance), accept: Type\u003c@DapperUtilityCoin.Vault\u003e(), tags: [\"duc\", \"dapperUtilityCoin\",\"dapper\"]))\n            updated=true\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else {\n            profile.emitUpdatedEvent()\n        }\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        let doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        let doeSalePublicPath=FindMarket.getPublicPath(doeSaleType, name: tenant.name)\n        let doeSaleStoragePath= FindMarket.getStoragePath(doeSaleType, name:tenant.name)\n        let doeSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n        if !doeSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n        }\n\n        let doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        let doeBidPublicPath=FindMarket.getPublicPath(doeBidType, name: tenant.name)\n        let doeBidStoragePath= FindMarket.getStoragePath(doeBidType, name:tenant.name)\n        let doeBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n        if !doeBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n        }\n\n        /// auctions that escrow ft\n        let aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        let aeSalePublicPath=FindMarket.getPublicPath(aeSaleType, name: tenant.name)\n        let aeSaleStoragePath= FindMarket.getStoragePath(aeSaleType, name:tenant.name)\n        let aeSaleCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n        if !aeSaleCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n        }\n\n        let dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\n        let dosSalePublicPath=FindMarket.getPublicPath(dosSaleType, name: tenant.name)\n        let dosSaleStoragePath= FindMarket.getStoragePath(dosSaleType, name:tenant.name)\n\n        let dosSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n        if !dosSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n        }\n\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n        if !dosBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n        }\n\n        let aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\n        let aeBidPublicPath=FindMarket.getPublicPath(aeBidType, name: tenant.name)\n        let aeBidStoragePath= FindMarket.getStoragePath(aeBidType, name:tenant.name)\n        let aeBidCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n        if !aeBidCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n        }\n\n     /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n        }\n\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n        if !asBidCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n        }\n\n        let leaseTenantCapability= FindMarket.getTenantCapability(FindMarket.getTenantAddress(\"findLease\")!)!\n\n        let leaseSaleItemType= Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()\n        let leasePublicPath=FindMarket.getPublicPath(leaseSaleItemType, name: \"findLease\")\n        let leaseStoragePath= FindMarket.getStoragePath(leaseSaleItemType, name:\"findLease\")\n        let leaseSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath) \n        if !leaseSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketSale.SaleItemCollection\u003e(\u003c- FindLeaseMarketSale.createEmptySaleItemCollection(leaseTenantCapability), to: leaseStoragePath)\n            account.link\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath, target: leaseStoragePath)\n        }\n\n        let leaseASSaleItemType= Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e()\n        let leaseASPublicPath=FindMarket.getPublicPath(leaseASSaleItemType, name: \"findLease\")\n        let leaseASStoragePath= FindMarket.getStoragePath(leaseASSaleItemType, name:\"findLease\")\n        let leaseASSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath) \n        if !leaseASSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseASStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath, target: leaseASStoragePath)\n        }\n\n\n        let leaseASBidType= Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e()\n        let leaseASBidPublicPath=FindMarket.getPublicPath(leaseASBidType, name: \"findLease\")\n        let leaseASBidStoragePath= FindMarket.getStoragePath(leaseASBidType, name: \"findLease\")\n        let leaseASBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath) \n        if !leaseASBidCap.check() {\n            account.save\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseASBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath, target: leaseASBidStoragePath)\n        }\n\n        // let leaseAESaleItemType= Type\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e()\n        // let leaseAEPublicPath=FindMarket.getPublicPath(leaseAESaleItemType, name: \"findLease\")\n        // let leaseAEStoragePath= FindMarket.getStoragePath(leaseAESaleItemType, name:\"findLease\")\n        // let leaseAESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath) \n        // if !leaseAESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseAEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath, target: leaseAEStoragePath)\n        // }\n\n        // let leaseAEBidType= Type\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e()\n        // let leaseAEBidPublicPath=FindMarket.getPublicPath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidStoragePath= FindMarket.getStoragePath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath) \n        // if !leaseAEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseAEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath, target: leaseAEBidStoragePath)\n        // }\n\n        let leaseDOSSaleItemType= Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e()\n        let leaseDOSPublicPath=FindMarket.getPublicPath(leaseDOSSaleItemType, name: \"findLease\")\n        let leaseDOSStoragePath= FindMarket.getStoragePath(leaseDOSSaleItemType, name:\"findLease\")\n        let leaseDOSSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath) \n        if !leaseDOSSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOSStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath, target: leaseDOSStoragePath)\n        }\n\n        let leaseDOSBidType= Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let leaseDOSBidPublicPath=FindMarket.getPublicPath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidStoragePath= FindMarket.getStoragePath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath) \n        if !leaseDOSBidCap.check() {\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOSBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath, target: leaseDOSBidStoragePath)\n        }\n\n        // let leaseDOESaleItemType= Type\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        // let leaseDOEPublicPath=FindMarket.getPublicPath(leaseDOESaleItemType, name: \"findLease\")\n        // let leaseDOEStoragePath= FindMarket.getStoragePath(leaseDOESaleItemType, name:\"findLease\")\n        // let leaseDOESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath) \n        // if !leaseDOESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath, target: leaseDOEStoragePath)\n        // }\n\n        // let leaseDOEBidType= Type\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        // let leaseDOEBidPublicPath=FindMarket.getPublicPath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidStoragePath= FindMarket.getStoragePath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath) \n        // if !leaseDOEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath, target: leaseDOEBidStoragePath)\n        // }\n        //SYNC with register\n\n        // Get supported NFT and FT Information from Registries from input alias\n        let ft = FTRegistry.getFTInfo(Type\u003c@DapperUtilityCoin.Vault\u003e().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(Type\u003c@DapperUtilityCoin.Vault\u003e().identifier))\n        \n        let leaseTenant = leaseTenantCapability.borrow()!\n        self.saleItems= account.borrow\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(from: leaseTenant.getStoragePath(Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e()))\n        let ref= account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from: FIND.LeaseStoragePath)!\n        self.pointer= FindLeaseMarket.AuthLeasePointer(ref: ref, name: leaseName)    \n        self.vaultType= ft.type    \n    }\n\n    pre{\n        // Ben : panic on some unreasonable inputs in trxn \n        minimumBidIncrement \u003e 0.0 :\"Minimum bid increment should be larger than 0.\"\n        (auctionReservePrice - auctionReservePrice) % minimumBidIncrement == 0.0 : \"Acution ReservePrice should be in step of minimum bid increment.\" \n        auctionDuration \u003e 0.0 : \"Auction Duration should be greater than 0.\"\n        auctionExtensionOnLateBid \u003e 0.0 : \"Auction Duration should be greater than 0.\"\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        self.saleItems!.listForAuction(pointer: self.pointer, vaultType: self.vaultType, auctionStartPrice: price, auctionReservePrice: auctionReservePrice, auctionDuration: auctionDuration, auctionExtensionOnLateBid: auctionExtensionOnLateBid, minimumBidIncrement: minimumBidIncrement, auctionValidUntil: auctionValidUntil, saleItemExtraField: {})\n\n    }\n}",
               "spec": {
                  "order": [
                     "dapperAddress",
                     "leaseName",
                     "price",
                     "auctionReservePrice",
                     "auctionDuration",
                     "auctionExtensionOnLateBid",
                     "minimumBidIncrement",
                     "auctionValidUntil"
                  ],
                  "parameters": {
                     "auctionDuration": "UFix64",
                     "auctionExtensionOnLateBid": "UFix64",
                     "auctionReservePrice": "UFix64",
                     "auctionValidUntil": "UFix64?",
                     "dapperAddress": "Address",
                     "leaseName": "String",
                     "minimumBidIncrement": "UFix64",
                     "price": "UFix64"
                  }
               }
            },
            "listLeaseForSale": {
               "code": "import FindMarket from 0xf8d6e0586b0a20c7\nimport FindMarketSale from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionSoft from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FUSD from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport FiatToken from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\nimport Dandy from 0xf8d6e0586b0a20c7\nimport Profile from 0xf8d6e0586b0a20c7\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FindViews from 0xf8d6e0586b0a20c7\nimport FTRegistry from 0xf8d6e0586b0a20c7\nimport FindLeaseMarketSale from 0xf8d6e0586b0a20c7\nimport FindLeaseMarketAuctionSoft from 0xf8d6e0586b0a20c7\n// import FindLeaseMarketAuctionEscrow from \"../contracts/FindLeaseMarketAuctionEscrow.cdc\"\nimport FindLeaseMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\n// import FindLeaseMarketDirectOfferEscrow from \"../contracts/FindLeaseMarketDirectOfferEscrow.cdc\"\nimport FindLeaseMarket from 0xf8d6e0586b0a20c7\n\ntransaction(leaseName: String, ftAliasOrIdentifier: String, directSellPrice:UFix64, validUntil: UFix64?) {\n\n    let saleItems : \u0026FindLeaseMarketSale.SaleItemCollection?\n    let pointer : FindLeaseMarket.AuthLeasePointer\n    let vaultType : Type\n\n    prepare(account: AuthAccount) {\n\n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n        //SYNC with register\n        //Add exising FUSD or create a new one and add it\n        let name = account.address.toString()\n        let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n        if !fusdReceiver.check() {\n            let fusd \u003c- FUSD.createEmptyVault()\n            account.save(\u003c- fusd, to: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n        }\n\n        let usdcCap = account.getCapability\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e(FiatToken.VaultReceiverPubPath)\n        if !usdcCap.check() {\n                account.save( \u003c-FiatToken.createEmptyVault(), to: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e( FiatToken.VaultReceiverPubPath, target: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FiatToken.ResourceId}\u003e( FiatToken.VaultUUIDPubPath, target: FiatToken.VaultStoragePath)\n                account.link\u003c\u0026FiatToken.Vault{FungibleToken.Balance}\u003e( FiatToken.VaultBalancePubPath, target:FiatToken.VaultStoragePath)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let dandyCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        let dandyCapPrivate= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPrivatePath)\n        if !dandyCapPrivate.check() {\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        var created=false\n        var updated=false\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        if !profile.hasWallet(\"Flow\") {\n            let flowWallet=Profile.Wallet( name:\"Flow\", receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), tags: [\"flow\"])\n    \n            profile.addWallet(flowWallet)\n            updated=true\n        }\n        if !profile.hasWallet(\"FUSD\") {\n            profile.addWallet(Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), tags: [\"fusd\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if !profile.hasWallet(\"USDC\") {\n            profile.addWallet(Profile.Wallet( name:\"USDC\", receiver:usdcCap, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(FiatToken.VaultBalancePubPath), accept: Type\u003c@FiatToken.Vault\u003e(), tags: [\"usdc\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else if updated {\n            profile.emitUpdatedEvent()\n        }\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let market = FindMarket.getFindTenantAddress()\n        let tenantCapability= FindMarket.getTenantCapability(market)!\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        let doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        let doeSalePublicPath=FindMarket.getPublicPath(doeSaleType, name: tenant.name)\n        let doeSaleStoragePath= FindMarket.getStoragePath(doeSaleType, name:tenant.name)\n        let doeSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n        if !doeSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n        }\n\n        let doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        let doeBidPublicPath=FindMarket.getPublicPath(doeBidType, name: tenant.name)\n        let doeBidStoragePath= FindMarket.getStoragePath(doeBidType, name:tenant.name)\n        let doeBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n        if !doeBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n        }\n\n        /// auctions that escrow ft\n        let aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        let aeSalePublicPath=FindMarket.getPublicPath(aeSaleType, name: tenant.name)\n        let aeSaleStoragePath= FindMarket.getStoragePath(aeSaleType, name:tenant.name)\n        let aeSaleCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n        if !aeSaleCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n        }\n\n        let dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\n        let dosSalePublicPath=FindMarket.getPublicPath(dosSaleType, name: tenant.name)\n        let dosSaleStoragePath= FindMarket.getStoragePath(dosSaleType, name:tenant.name)\n\n        let dosSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n        if !dosSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n        }\n\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n        if !dosBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n        }\n\n        let aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\n        let aeBidPublicPath=FindMarket.getPublicPath(aeBidType, name: tenant.name)\n        let aeBidStoragePath= FindMarket.getStoragePath(aeBidType, name:tenant.name)\n        let aeBidCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n        if !aeBidCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n        }\n\n     /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n        }\n\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n        if !asBidCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n        }\n\n        let leaseTenantCapability= FindMarket.getTenantCapability(FindMarket.getTenantAddress(\"findLease\")!)!\n\n        let leaseSaleItemType= Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()\n        let leasePublicPath=FindMarket.getPublicPath(leaseSaleItemType, name: \"findLease\")\n        let leaseStoragePath= FindMarket.getStoragePath(leaseSaleItemType, name:\"findLease\")\n        let leaseSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath) \n        if !leaseSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketSale.SaleItemCollection\u003e(\u003c- FindLeaseMarketSale.createEmptySaleItemCollection(leaseTenantCapability), to: leaseStoragePath)\n            account.link\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath, target: leaseStoragePath)\n        }\n\n        let leaseASSaleItemType= Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e()\n        let leaseASPublicPath=FindMarket.getPublicPath(leaseASSaleItemType, name: \"findLease\")\n        let leaseASStoragePath= FindMarket.getStoragePath(leaseASSaleItemType, name:\"findLease\")\n        let leaseASSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath) \n        if !leaseASSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseASStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath, target: leaseASStoragePath)\n        }\n\n\n        let leaseASBidType= Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e()\n        let leaseASBidPublicPath=FindMarket.getPublicPath(leaseASBidType, name: \"findLease\")\n        let leaseASBidStoragePath= FindMarket.getStoragePath(leaseASBidType, name: \"findLease\")\n        let leaseASBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath) \n        if !leaseASBidCap.check() {\n            account.save\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseASBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath, target: leaseASBidStoragePath)\n        }\n\n        // let leaseAESaleItemType= Type\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e()\n        // let leaseAEPublicPath=FindMarket.getPublicPath(leaseAESaleItemType, name: \"findLease\")\n        // let leaseAEStoragePath= FindMarket.getStoragePath(leaseAESaleItemType, name:\"findLease\")\n        // let leaseAESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath) \n        // if !leaseAESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseAEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath, target: leaseAEStoragePath)\n        // }\n\n        // let leaseAEBidType= Type\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e()\n        // let leaseAEBidPublicPath=FindMarket.getPublicPath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidStoragePath= FindMarket.getStoragePath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath) \n        // if !leaseAEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseAEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath, target: leaseAEBidStoragePath)\n        // }\n\n        let leaseDOSSaleItemType= Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e()\n        let leaseDOSPublicPath=FindMarket.getPublicPath(leaseDOSSaleItemType, name: \"findLease\")\n        let leaseDOSStoragePath= FindMarket.getStoragePath(leaseDOSSaleItemType, name:\"findLease\")\n        let leaseDOSSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath) \n        if !leaseDOSSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOSStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath, target: leaseDOSStoragePath)\n        }\n\n        let leaseDOSBidType= Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let leaseDOSBidPublicPath=FindMarket.getPublicPath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidStoragePath= FindMarket.getStoragePath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath) \n        if !leaseDOSBidCap.check() {\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOSBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath, target: leaseDOSBidStoragePath)\n        }\n\n        // let leaseDOESaleItemType= Type\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        // let leaseDOEPublicPath=FindMarket.getPublicPath(leaseDOESaleItemType, name: \"findLease\")\n        // let leaseDOEStoragePath= FindMarket.getStoragePath(leaseDOESaleItemType, name:\"findLease\")\n        // let leaseDOESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath) \n        // if !leaseDOESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath, target: leaseDOEStoragePath)\n        // }\n\n        // let leaseDOEBidType= Type\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        // let leaseDOEBidPublicPath=FindMarket.getPublicPath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidStoragePath= FindMarket.getStoragePath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath) \n        // if !leaseDOEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath, target: leaseDOEBidStoragePath)\n        // }\n        //SYNC with register\n\n        // Get the salesItemRef from tenant\n        let leaseTenant = leaseTenantCapability.borrow()!\n        self.saleItems= account.borrow\u003c\u0026FindLeaseMarketSale.SaleItemCollection\u003e(from: leaseTenant.getStoragePath(Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()))!\n\n        // Get supported NFT and FT Information from Registries from input alias\n        let ft = FTRegistry.getFTInfo(ftAliasOrIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftAliasOrIdentifier))\n        self.vaultType= ft.type\n\n        let lease=account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from: FIND.LeaseStoragePath)!\n\n\n        self.pointer= FindLeaseMarket.AuthLeasePointer(ref:lease, name: leaseName)\n\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        self.saleItems!.listForSale(pointer: self.pointer, vaultType: self.vaultType, directSellPrice: directSellPrice, validUntil: validUntil, extraField: {})\n    }\n}",
               "spec": {
                  "order": [
                     "leaseName",
                     "ftAliasOrIdentifier",
                     "directSellPrice",
                     "validUntil"
                  ],
                  "parameters": {
                     "directSellPrice": "UFix64",
                     "ftAliasOrIdentifier": "String",
                     "leaseName": "String",
                     "validUntil": "UFix64?"
                  }
               }
            },
            "listLeaseForSaleDUC": {
               "code": "import FindMarket from 0xf8d6e0586b0a20c7\nimport FindMarketSale from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionSoft from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport DapperUtilityCoin from 0xf8d6e0586b0a20c7\nimport TokenForwarding from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport FIND from 0xf8d6e0586b0a20c7\nimport Dandy from 0xf8d6e0586b0a20c7\nimport Profile from 0xf8d6e0586b0a20c7\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FindViews from 0xf8d6e0586b0a20c7\nimport FTRegistry from 0xf8d6e0586b0a20c7\nimport FindLeaseMarketSale from 0xf8d6e0586b0a20c7\nimport FindLeaseMarketAuctionSoft from 0xf8d6e0586b0a20c7\n// import FindLeaseMarketAuctionEscrow from \"../contracts/FindLeaseMarketAuctionEscrow.cdc\"\nimport FindLeaseMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\n// import FindLeaseMarketDirectOfferEscrow from \"../contracts/FindLeaseMarketDirectOfferEscrow.cdc\"\nimport FindLeaseMarket from 0xf8d6e0586b0a20c7\n\ntransaction(dapperAddress: Address, leaseName: String, directSellPrice:UFix64, validUntil: UFix64?) {\n\n    let saleItems : \u0026FindLeaseMarketSale.SaleItemCollection?\n    let pointer : FindLeaseMarket.AuthLeasePointer\n    let vaultType : Type\n\n    prepare(account: AuthAccount) {\n\n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n        //SYNC with register\n        //Add exising FUSD or create a new one and add it\n        let name = account.address.toString()\n        let ducReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver)\n        if !ducReceiver.check() {\n            let dapper = getAccount(dapperAddress)\n            // Create a new Forwarder resource for DUC and store it in the new account's storage\n            let ducForwarder \u003c- TokenForwarding.createNewForwarder(recipient: dapper.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver))\n            account.save(\u003c-ducForwarder, to: /storage/dapperUtilityCoinReceiver)\n            // Publish a Receiver capability for the new account, which is linked to the DUC Forwarder\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver,target: /storage/dapperUtilityCoinReceiver)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: ducReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let dandyCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        let dandyCapPrivate= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPrivatePath)\n        if !dandyCapPrivate.check() {\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        var created=false\n        var updated=false\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        if !profile.hasWallet(\"Flow\") {\n            let flowWallet=Profile.Wallet( name:\"Flow\", receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), tags: [\"flow\"])\n    \n            profile.addWallet(flowWallet)\n            updated=true\n        }\n        if !profile.hasWallet(\"DUC\") {\n            profile.addWallet(Profile.Wallet( name:\"DUC\", receiver:ducReceiver, balance:getAccount(dapperAddress).getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/dapperUtilityCoinBalance), accept: Type\u003c@DapperUtilityCoin.Vault\u003e(), tags: [\"duc\", \"dapperUtilityCoin\",\"dapper\"]))\n            updated=true\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else {\n            profile.emitUpdatedEvent()\n        }\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        let doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        let doeSalePublicPath=FindMarket.getPublicPath(doeSaleType, name: tenant.name)\n        let doeSaleStoragePath= FindMarket.getStoragePath(doeSaleType, name:tenant.name)\n        let doeSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n        if !doeSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n        }\n\n        let doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        let doeBidPublicPath=FindMarket.getPublicPath(doeBidType, name: tenant.name)\n        let doeBidStoragePath= FindMarket.getStoragePath(doeBidType, name:tenant.name)\n        let doeBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n        if !doeBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n        }\n\n        /// auctions that escrow ft\n        let aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        let aeSalePublicPath=FindMarket.getPublicPath(aeSaleType, name: tenant.name)\n        let aeSaleStoragePath= FindMarket.getStoragePath(aeSaleType, name:tenant.name)\n        let aeSaleCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n        if !aeSaleCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n        }\n\n        let dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\n        let dosSalePublicPath=FindMarket.getPublicPath(dosSaleType, name: tenant.name)\n        let dosSaleStoragePath= FindMarket.getStoragePath(dosSaleType, name:tenant.name)\n\n        let dosSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n        if !dosSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n        }\n\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n        if !dosBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n        }\n\n        let aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\n        let aeBidPublicPath=FindMarket.getPublicPath(aeBidType, name: tenant.name)\n        let aeBidStoragePath= FindMarket.getStoragePath(aeBidType, name:tenant.name)\n        let aeBidCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n        if !aeBidCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n        }\n\n     /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n        }\n\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n        if !asBidCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n        }\n\n        let leaseTenantCapability= FindMarket.getTenantCapability(FindMarket.getTenantAddress(\"findLease\")!)!\n\n        let leaseSaleItemType= Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()\n        let leasePublicPath=FindMarket.getPublicPath(leaseSaleItemType, name: \"findLease\")\n        let leaseStoragePath= FindMarket.getStoragePath(leaseSaleItemType, name:\"findLease\")\n        let leaseSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath) \n        if !leaseSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketSale.SaleItemCollection\u003e(\u003c- FindLeaseMarketSale.createEmptySaleItemCollection(leaseTenantCapability), to: leaseStoragePath)\n            account.link\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath, target: leaseStoragePath)\n        }\n\n        let leaseASSaleItemType= Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e()\n        let leaseASPublicPath=FindMarket.getPublicPath(leaseASSaleItemType, name: \"findLease\")\n        let leaseASStoragePath= FindMarket.getStoragePath(leaseASSaleItemType, name:\"findLease\")\n        let leaseASSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath) \n        if !leaseASSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseASStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath, target: leaseASStoragePath)\n        }\n\n\n        let leaseASBidType= Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e()\n        let leaseASBidPublicPath=FindMarket.getPublicPath(leaseASBidType, name: \"findLease\")\n        let leaseASBidStoragePath= FindMarket.getStoragePath(leaseASBidType, name: \"findLease\")\n        let leaseASBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath) \n        if !leaseASBidCap.check() {\n            account.save\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseASBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath, target: leaseASBidStoragePath)\n        }\n\n        // let leaseAESaleItemType= Type\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e()\n        // let leaseAEPublicPath=FindMarket.getPublicPath(leaseAESaleItemType, name: \"findLease\")\n        // let leaseAEStoragePath= FindMarket.getStoragePath(leaseAESaleItemType, name:\"findLease\")\n        // let leaseAESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath) \n        // if !leaseAESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseAEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath, target: leaseAEStoragePath)\n        // }\n\n        // let leaseAEBidType= Type\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e()\n        // let leaseAEBidPublicPath=FindMarket.getPublicPath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidStoragePath= FindMarket.getStoragePath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath) \n        // if !leaseAEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseAEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath, target: leaseAEBidStoragePath)\n        // }\n\n        let leaseDOSSaleItemType= Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e()\n        let leaseDOSPublicPath=FindMarket.getPublicPath(leaseDOSSaleItemType, name: \"findLease\")\n        let leaseDOSStoragePath= FindMarket.getStoragePath(leaseDOSSaleItemType, name:\"findLease\")\n        let leaseDOSSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath) \n        if !leaseDOSSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOSStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath, target: leaseDOSStoragePath)\n        }\n\n        let leaseDOSBidType= Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let leaseDOSBidPublicPath=FindMarket.getPublicPath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidStoragePath= FindMarket.getStoragePath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath) \n        if !leaseDOSBidCap.check() {\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOSBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath, target: leaseDOSBidStoragePath)\n        }\n\n        // let leaseDOESaleItemType= Type\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        // let leaseDOEPublicPath=FindMarket.getPublicPath(leaseDOESaleItemType, name: \"findLease\")\n        // let leaseDOEStoragePath= FindMarket.getStoragePath(leaseDOESaleItemType, name:\"findLease\")\n        // let leaseDOESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath) \n        // if !leaseDOESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath, target: leaseDOEStoragePath)\n        // }\n\n        // let leaseDOEBidType= Type\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        // let leaseDOEBidPublicPath=FindMarket.getPublicPath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidStoragePath= FindMarket.getStoragePath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath) \n        // if !leaseDOEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath, target: leaseDOEBidStoragePath)\n        // }\n        //SYNC with register\n\n        // Get the salesItemRef from tenant\n        let leaseTenant = leaseTenantCapability.borrow()!\n        self.saleItems= account.borrow\u003c\u0026FindLeaseMarketSale.SaleItemCollection\u003e(from: leaseTenant.getStoragePath(Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()))\n\n        // Get supported NFT and FT Information from Registries from input alias\n        let ft = FTRegistry.getFTInfo(Type\u003c@DapperUtilityCoin.Vault\u003e().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(Type\u003c@DapperUtilityCoin.Vault\u003e().identifier))\n        self.vaultType= ft.type\n\n        let ref=account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from: FIND.LeaseStoragePath)!\n\n        self.pointer= FindLeaseMarket.AuthLeasePointer(ref: ref, name: leaseName)\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        self.saleItems!.listForSale(pointer: self.pointer, vaultType: self.vaultType, directSellPrice: directSellPrice, validUntil: validUntil, extraField: {})\n\n    }\n\n}",
               "spec": {
                  "order": [
                     "dapperAddress",
                     "leaseName",
                     "directSellPrice",
                     "validUntil"
                  ],
                  "parameters": {
                     "dapperAddress": "Address",
                     "directSellPrice": "UFix64",
                     "leaseName": "String",
                     "validUntil": "UFix64?"
                  }
               }
            },
            "listMultipleNFTForSale": {
               "code": "import FindMarket from 0xf8d6e0586b0a20c7\nimport FindMarketSale from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionSoft from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FUSD from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport FiatToken from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\nimport Dandy from 0xf8d6e0586b0a20c7\nimport Profile from 0xf8d6e0586b0a20c7\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FindViews from 0xf8d6e0586b0a20c7\nimport NFTCatalog from 0xf8d6e0586b0a20c7\nimport FINDNFTCatalog from 0xf8d6e0586b0a20c7\nimport FTRegistry from 0xf8d6e0586b0a20c7\n\ntransaction(marketplace:Address, nftAliasOrIdentifiers: [String], ids: [UInt64], ftAliasOrIdentifiers: [String], directSellPrices:[UFix64], validUntil: UFix64?) {\n    \n    let saleItems : \u0026FindMarketSale.SaleItemCollection?\n    let pointers : [FindViews.AuthNFTPointer]\n    let vaultTypes : [Type]\n\n    prepare(account: AuthAccount) {\n\n        if nftAliasOrIdentifiers.length != ids.length {\n            panic(\"The length of arrays passed in has to be the same\")\n        } else if nftAliasOrIdentifiers.length != ftAliasOrIdentifiers.length {\n            panic(\"The length of arrays passed in has to be the same\")\n        } else if nftAliasOrIdentifiers.length != directSellPrices.length {\n            panic(\"The length of arrays passed in has to be the same\")\n        }\n\n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n        //SYNC with register\n        //Add exising FUSD or create a new one and add it\n        let name = account.address.toString()\n        let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n        if !fusdReceiver.check() {\n            let fusd \u003c- FUSD.createEmptyVault()\n            account.save(\u003c- fusd, to: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n        }\n\n        let usdcCap = account.getCapability\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e(FiatToken.VaultReceiverPubPath)\n        if !usdcCap.check() {\n                account.save( \u003c-FiatToken.createEmptyVault(), to: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e( FiatToken.VaultReceiverPubPath, target: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FiatToken.ResourceId}\u003e( FiatToken.VaultUUIDPubPath, target: FiatToken.VaultStoragePath)\n                account.link\u003c\u0026FiatToken.Vault{FungibleToken.Balance}\u003e( FiatToken.VaultBalancePubPath, target:FiatToken.VaultStoragePath)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let dandyCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        let dandyCapPrivate= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPrivatePath)\n        if !dandyCapPrivate.check() {\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        var created=false\n        var updated=false\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        if !profile.hasWallet(\"Flow\") {\n            let flowWallet=Profile.Wallet( name:\"Flow\", receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), tags: [\"flow\"])\n    \n            profile.addWallet(flowWallet)\n            updated=true\n        }\n        if !profile.hasWallet(\"FUSD\") {\n            profile.addWallet(Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), tags: [\"fusd\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if !profile.hasWallet(\"USDC\") {\n            profile.addWallet(Profile.Wallet( name:\"USDC\", receiver:usdcCap, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(FiatToken.VaultBalancePubPath), accept: Type\u003c@FiatToken.Vault\u003e(), tags: [\"usdc\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else if updated {\n            profile.emitUpdatedEvent()\n        }\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        let doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        let doeSalePublicPath=FindMarket.getPublicPath(doeSaleType, name: tenant.name)\n        let doeSaleStoragePath= FindMarket.getStoragePath(doeSaleType, name:tenant.name)\n        let doeSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n        if !doeSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n        }\n\n        let doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        let doeBidPublicPath=FindMarket.getPublicPath(doeBidType, name: tenant.name)\n        let doeBidStoragePath= FindMarket.getStoragePath(doeBidType, name:tenant.name)\n        let doeBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n        if !doeBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n        }\n\n        /// auctions that escrow ft\n        let aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        let aeSalePublicPath=FindMarket.getPublicPath(aeSaleType, name: tenant.name)\n        let aeSaleStoragePath= FindMarket.getStoragePath(aeSaleType, name:tenant.name)\n        let aeSaleCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n        if !aeSaleCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n        }\n\n        let dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\n        let dosSalePublicPath=FindMarket.getPublicPath(dosSaleType, name: tenant.name)\n        let dosSaleStoragePath= FindMarket.getStoragePath(dosSaleType, name:tenant.name)\n\n        let dosSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n        if !dosSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n        }\n\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n        if !dosBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n        }\n\n        let aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\n        let aeBidPublicPath=FindMarket.getPublicPath(aeBidType, name: tenant.name)\n        let aeBidStoragePath= FindMarket.getStoragePath(aeBidType, name:tenant.name)\n        let aeBidCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n        if !aeBidCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n        }\n\n     /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n        }\n\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n        if !asBidCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n        }\n        //SYNC with register\n\n        self.saleItems= account.borrow\u003c\u0026FindMarketSale.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketSale.SaleItemCollection\u003e()))\n        self.vaultTypes= []\n        self.pointers= []\n\n        var counter = 0\n\n        let nfts : {String : NFTCatalog.NFTCollectionData} = {}\n        let fts : {String : FTRegistry.FTInfo} = {}\n\n        while counter \u003c ids.length {\n            // Get supported NFT and FT Information from Registries from input alias\n            var nft : NFTCatalog.NFTCollectionData? = nil\n            var ft : FTRegistry.FTInfo? = nil\n\n            if nfts[nftAliasOrIdentifiers[counter]] != nil {\n                nft = nfts[nftAliasOrIdentifiers[counter]]\n            } else {\n                let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftAliasOrIdentifiers[counter])?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftAliasOrIdentifiers[counter])) \n                let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n                nft = collection.collectionData\n                nfts[nftAliasOrIdentifiers[counter]] = nft\n            }\n\n            if fts[ftAliasOrIdentifiers[counter]] != nil {\n                ft = fts[ftAliasOrIdentifiers[counter]]\n            } else {\n                ft = FTRegistry.getFTInfo(ftAliasOrIdentifiers[counter]) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftAliasOrIdentifiers[counter]))\n                fts[ftAliasOrIdentifiers[counter]] = ft \n            }\n\n            var providerCap=account.getCapability\u003c\u0026{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e(nft!.privatePath)\n\n            /* Ben : Question -\u003e Either client will have to provide the path here or agree that we set it up for the user */\n            if !providerCap.check() {\n                let newCap = account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                        nft!.privatePath,\n                        target: nft!.storagePath\n                )\n                if newCap == nil {\n                    // If linking is not successful, we link it using finds custom link \n                    let pathIdentifier = nft!.privatePath.toString()\n                    let findPath = PrivatePath(identifier: pathIdentifier.slice(from: \"/private/\".length , upTo: pathIdentifier.length).concat(\"_FIND\"))!\n                    account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                        findPath,\n                        target: nft!.storagePath\n                    )\n                    providerCap = account.getCapability\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(findPath)\n                }\n            }\n            // Get the salesItemRef from tenant\n            self.pointers.append(FindViews.AuthNFTPointer(cap: providerCap, id: ids[counter]))\n            self.vaultTypes.append(ft!.type)\n            counter = counter + 1\n        }\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        var counter = 0\n        while counter \u003c ids.length {\n            self.saleItems!.listForSale(pointer: self.pointers[counter], vaultType: self.vaultTypes[counter], directSellPrice: directSellPrices[counter], validUntil: validUntil, extraField: {})\n            counter = counter + 1\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "nftAliasOrIdentifiers",
                     "ids",
                     "ftAliasOrIdentifiers",
                     "directSellPrices",
                     "validUntil"
                  ],
                  "parameters": {
                     "directSellPrices": "[UFix64]",
                     "ftAliasOrIdentifiers": "[String]",
                     "ids": "[UInt64]",
                     "marketplace": "Address",
                     "nftAliasOrIdentifiers": "[String]",
                     "validUntil": "UFix64?"
                  }
               }
            },
            "listMultipleNFTForSaleDUC": {
               "code": "import FindMarket from 0xf8d6e0586b0a20c7\nimport FindMarketSale from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionSoft from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport DapperUtilityCoin from 0xf8d6e0586b0a20c7\nimport TokenForwarding from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport FIND from 0xf8d6e0586b0a20c7\nimport Dandy from 0xf8d6e0586b0a20c7\nimport Profile from 0xf8d6e0586b0a20c7\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FindViews from 0xf8d6e0586b0a20c7\nimport NFTCatalog from 0xf8d6e0586b0a20c7\nimport FINDNFTCatalog from 0xf8d6e0586b0a20c7\nimport FTRegistry from 0xf8d6e0586b0a20c7\n\ntransaction(dapperAddress: Address, marketplace:Address, nftAliasOrIdentifiers: [String], ids: [UInt64], directSellPrices:[UFix64], validUntil: UFix64?) {\n    \n    let saleItems : \u0026FindMarketSale.SaleItemCollection?\n    let pointers : [FindViews.AuthNFTPointer]\n    \n    prepare(account: AuthAccount) {\n\n        if nftAliasOrIdentifiers.length != ids.length {\n            panic(\"The length of arrays passed in has to be the same\")\n        } else if nftAliasOrIdentifiers.length != directSellPrices.length {\n            panic(\"The length of arrays passed in has to be the same\")\n        }\n\n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n        //SYNC with register\n        //Add exising FUSD or create a new one and add it\n        let name = account.address.toString()\n        let ducReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver)\n        if !ducReceiver.check() {\n            let dapper = getAccount(dapperAddress)\n            // Create a new Forwarder resource for DUC and store it in the new account's storage\n            let ducForwarder \u003c- TokenForwarding.createNewForwarder(recipient: dapper.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver))\n            account.save(\u003c-ducForwarder, to: /storage/dapperUtilityCoinReceiver)\n            // Publish a Receiver capability for the new account, which is linked to the DUC Forwarder\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver,target: /storage/dapperUtilityCoinReceiver)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: ducReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let dandyCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        let dandyCapPrivate= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPrivatePath)\n        if !dandyCapPrivate.check() {\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        var created=false\n        var updated=false\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        if !profile.hasWallet(\"Flow\") {\n            let flowWallet=Profile.Wallet( name:\"Flow\", receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), tags: [\"flow\"])\n    \n            profile.addWallet(flowWallet)\n            updated=true\n        }\n        if !profile.hasWallet(\"DUC\") {\n            profile.addWallet(Profile.Wallet( name:\"DUC\", receiver:ducReceiver, balance:getAccount(dapperAddress).getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/dapperUtilityCoinBalance), accept: Type\u003c@DapperUtilityCoin.Vault\u003e(), tags: [\"duc\", \"dapperUtilityCoin\",\"dapper\"]))\n            updated=true\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else {\n            profile.emitUpdatedEvent()\n        }\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        let doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        let doeSalePublicPath=FindMarket.getPublicPath(doeSaleType, name: tenant.name)\n        let doeSaleStoragePath= FindMarket.getStoragePath(doeSaleType, name:tenant.name)\n        let doeSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n        if !doeSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n        }\n\n        let doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        let doeBidPublicPath=FindMarket.getPublicPath(doeBidType, name: tenant.name)\n        let doeBidStoragePath= FindMarket.getStoragePath(doeBidType, name:tenant.name)\n        let doeBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n        if !doeBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n        }\n\n        /// auctions that escrow ft\n        let aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        let aeSalePublicPath=FindMarket.getPublicPath(aeSaleType, name: tenant.name)\n        let aeSaleStoragePath= FindMarket.getStoragePath(aeSaleType, name:tenant.name)\n        let aeSaleCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n        if !aeSaleCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n        }\n\n        let dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\n        let dosSalePublicPath=FindMarket.getPublicPath(dosSaleType, name: tenant.name)\n        let dosSaleStoragePath= FindMarket.getStoragePath(dosSaleType, name:tenant.name)\n\n        let dosSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n        if !dosSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n        }\n\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n        if !dosBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n        }\n\n        let aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\n        let aeBidPublicPath=FindMarket.getPublicPath(aeBidType, name: tenant.name)\n        let aeBidStoragePath= FindMarket.getStoragePath(aeBidType, name:tenant.name)\n        let aeBidCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n        if !aeBidCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n        }\n\n     /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n        }\n\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n        if !asBidCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n        }\n        //SYNC with register\n\n        self.saleItems= account.borrow\u003c\u0026FindMarketSale.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketSale.SaleItemCollection\u003e()))\n        self.pointers= []\n\n        let nfts : {String : NFTCatalog.NFTCollectionData} = {}\n\n        var counter = 0\n        while counter \u003c ids.length {\n            // Get supported NFT and FT Information from Registries from input alias\n            var nft : NFTCatalog.NFTCollectionData? = nil\n            var ft : FTRegistry.FTInfo? = nil\n\n            if nfts[nftAliasOrIdentifiers[counter]] != nil {\n                nft = nfts[nftAliasOrIdentifiers[counter]]\n            } else {\n                let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftAliasOrIdentifiers[counter])?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftAliasOrIdentifiers[counter])) \n                let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n                nft = collection.collectionData\n                nfts[nftAliasOrIdentifiers[counter]] = nft\n            }\n\n            var providerCap=account.getCapability\u003c\u0026{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e(nft!.privatePath)\n\n            /* Ben : Question -\u003e Either client will have to provide the path here or agree that we set it up for the user */\n            if !providerCap.check() {\n                let newCap = account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                        nft!.privatePath,\n                        target: nft!.storagePath\n                )\n                if newCap == nil {\n                    // If linking is not successful, we link it using finds custom link \n                    let pathIdentifier = nft!.privatePath.toString()\n                    let findPath = PrivatePath(identifier: pathIdentifier.slice(from: \"/private/\".length , upTo: pathIdentifier.length).concat(\"_FIND\"))!\n                    account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                        findPath,\n                        target: nft!.storagePath\n                    )\n                    providerCap = account.getCapability\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(findPath)\n                }\n            }\n            // Get the salesItemRef from tenant\n            self.pointers.append(FindViews.AuthNFTPointer(cap: providerCap, id: ids[counter]))\n            counter = counter + 1\n        }\n\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        var counter = 0\n        while counter \u003c ids.length {\n            self.saleItems!.listForSale(pointer: self.pointers[counter], vaultType: Type\u003c@DapperUtilityCoin.Vault\u003e(), directSellPrice: directSellPrices[counter], validUntil: validUntil, extraField: {})\n            counter = counter + 1\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "dapperAddress",
                     "marketplace",
                     "nftAliasOrIdentifiers",
                     "ids",
                     "directSellPrices",
                     "validUntil"
                  ],
                  "parameters": {
                     "dapperAddress": "Address",
                     "directSellPrices": "[UFix64]",
                     "ids": "[UInt64]",
                     "marketplace": "Address",
                     "nftAliasOrIdentifiers": "[String]",
                     "validUntil": "UFix64?"
                  }
               }
            },
            "listNFTForAuctionEscrowed": {
               "code": "import FindMarket from 0xf8d6e0586b0a20c7\nimport FindMarketSale from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionSoft from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FindViews from 0xf8d6e0586b0a20c7\nimport NFTCatalog from 0xf8d6e0586b0a20c7\nimport FINDNFTCatalog from 0xf8d6e0586b0a20c7\nimport FTRegistry from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FUSD from 0xf8d6e0586b0a20c7\nimport FiatToken from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport FIND from 0xf8d6e0586b0a20c7\nimport Dandy from 0xf8d6e0586b0a20c7\nimport Profile from 0xf8d6e0586b0a20c7\nimport FindLeaseMarketSale from 0xf8d6e0586b0a20c7\nimport FindLeaseMarketAuctionSoft from 0xf8d6e0586b0a20c7\n// import FindLeaseMarketAuctionEscrow from \"../contracts/FindLeaseMarketAuctionEscrow.cdc\"\nimport FindLeaseMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\n// import FindLeaseMarketDirectOfferEscrow from \"../contracts/FindLeaseMarketDirectOfferEscrow.cdc\"\nimport FindLeaseMarket from 0xf8d6e0586b0a20c7\n\ntransaction(marketplace:Address, nftAliasOrIdentifier:String, id: UInt64, ftAliasOrIdentifier:String, price:UFix64, auctionReservePrice: UFix64, auctionDuration: UFix64, auctionExtensionOnLateBid: UFix64, minimumBidIncrement: UFix64, auctionValidUntil: UFix64?) {\n    \n    let saleItems : \u0026FindMarketAuctionEscrow.SaleItemCollection?\n    let vaultType : Type\n    let pointer : FindViews.AuthNFTPointer\n    \n    prepare(account: AuthAccount) {\n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n        //SYNC with register\n        //Add exising FUSD or create a new one and add it\n        let name = account.address.toString()\n        let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n        if !fusdReceiver.check() {\n            let fusd \u003c- FUSD.createEmptyVault()\n            account.save(\u003c- fusd, to: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n        }\n\n        let usdcCap = account.getCapability\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e(FiatToken.VaultReceiverPubPath)\n        if !usdcCap.check() {\n                account.save( \u003c-FiatToken.createEmptyVault(), to: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e( FiatToken.VaultReceiverPubPath, target: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FiatToken.ResourceId}\u003e( FiatToken.VaultUUIDPubPath, target: FiatToken.VaultStoragePath)\n                account.link\u003c\u0026FiatToken.Vault{FungibleToken.Balance}\u003e( FiatToken.VaultBalancePubPath, target:FiatToken.VaultStoragePath)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let dandyCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        let dandyCapPrivate= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPrivatePath)\n        if !dandyCapPrivate.check() {\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        var created=false\n        var updated=false\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        if !profile.hasWallet(\"Flow\") {\n            let flowWallet=Profile.Wallet( name:\"Flow\", receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), tags: [\"flow\"])\n    \n            profile.addWallet(flowWallet)\n            updated=true\n        }\n        if !profile.hasWallet(\"FUSD\") {\n            profile.addWallet(Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), tags: [\"fusd\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if !profile.hasWallet(\"USDC\") {\n            profile.addWallet(Profile.Wallet( name:\"USDC\", receiver:usdcCap, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(FiatToken.VaultBalancePubPath), accept: Type\u003c@FiatToken.Vault\u003e(), tags: [\"usdc\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else if updated {\n            profile.emitUpdatedEvent()\n        }\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        let doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        let doeSalePublicPath=FindMarket.getPublicPath(doeSaleType, name: tenant.name)\n        let doeSaleStoragePath= FindMarket.getStoragePath(doeSaleType, name:tenant.name)\n        let doeSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n        if !doeSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n        }\n\n        let doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        let doeBidPublicPath=FindMarket.getPublicPath(doeBidType, name: tenant.name)\n        let doeBidStoragePath= FindMarket.getStoragePath(doeBidType, name:tenant.name)\n        let doeBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n        if !doeBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n        }\n\n        /// auctions that escrow ft\n        let aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        let aeSalePublicPath=FindMarket.getPublicPath(aeSaleType, name: tenant.name)\n        let aeSaleStoragePath= FindMarket.getStoragePath(aeSaleType, name:tenant.name)\n        let aeSaleCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n        if !aeSaleCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n        }\n\n        let dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\n        let dosSalePublicPath=FindMarket.getPublicPath(dosSaleType, name: tenant.name)\n        let dosSaleStoragePath= FindMarket.getStoragePath(dosSaleType, name:tenant.name)\n\n        let dosSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n        if !dosSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n        }\n\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n        if !dosBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n        }\n\n        let aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\n        let aeBidPublicPath=FindMarket.getPublicPath(aeBidType, name: tenant.name)\n        let aeBidStoragePath= FindMarket.getStoragePath(aeBidType, name:tenant.name)\n        let aeBidCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n        if !aeBidCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n        }\n\n     /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n        }\n\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n        if !asBidCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n        }\n\n        let leaseTenantCapability= FindMarket.getTenantCapability(FindMarket.getTenantAddress(\"findLease\")!)!\n\n        let leaseSaleItemType= Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()\n        let leasePublicPath=FindMarket.getPublicPath(leaseSaleItemType, name: \"findLease\")\n        let leaseStoragePath= FindMarket.getStoragePath(leaseSaleItemType, name:\"findLease\")\n        let leaseSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath) \n        if !leaseSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketSale.SaleItemCollection\u003e(\u003c- FindLeaseMarketSale.createEmptySaleItemCollection(leaseTenantCapability), to: leaseStoragePath)\n            account.link\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath, target: leaseStoragePath)\n        }\n\n        let leaseASSaleItemType= Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e()\n        let leaseASPublicPath=FindMarket.getPublicPath(leaseASSaleItemType, name: \"findLease\")\n        let leaseASStoragePath= FindMarket.getStoragePath(leaseASSaleItemType, name:\"findLease\")\n        let leaseASSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath) \n        if !leaseASSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseASStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath, target: leaseASStoragePath)\n        }\n\n\n        let leaseASBidType= Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e()\n        let leaseASBidPublicPath=FindMarket.getPublicPath(leaseASBidType, name: \"findLease\")\n        let leaseASBidStoragePath= FindMarket.getStoragePath(leaseASBidType, name: \"findLease\")\n        let leaseASBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath) \n        if !leaseASBidCap.check() {\n            account.save\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseASBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath, target: leaseASBidStoragePath)\n        }\n\n        // let leaseAESaleItemType= Type\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e()\n        // let leaseAEPublicPath=FindMarket.getPublicPath(leaseAESaleItemType, name: \"findLease\")\n        // let leaseAEStoragePath= FindMarket.getStoragePath(leaseAESaleItemType, name:\"findLease\")\n        // let leaseAESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath) \n        // if !leaseAESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseAEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath, target: leaseAEStoragePath)\n        // }\n\n        // let leaseAEBidType= Type\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e()\n        // let leaseAEBidPublicPath=FindMarket.getPublicPath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidStoragePath= FindMarket.getStoragePath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath) \n        // if !leaseAEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseAEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath, target: leaseAEBidStoragePath)\n        // }\n\n        let leaseDOSSaleItemType= Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e()\n        let leaseDOSPublicPath=FindMarket.getPublicPath(leaseDOSSaleItemType, name: \"findLease\")\n        let leaseDOSStoragePath= FindMarket.getStoragePath(leaseDOSSaleItemType, name:\"findLease\")\n        let leaseDOSSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath) \n        if !leaseDOSSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOSStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath, target: leaseDOSStoragePath)\n        }\n\n        let leaseDOSBidType= Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let leaseDOSBidPublicPath=FindMarket.getPublicPath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidStoragePath= FindMarket.getStoragePath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath) \n        if !leaseDOSBidCap.check() {\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOSBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath, target: leaseDOSBidStoragePath)\n        }\n\n        // let leaseDOESaleItemType= Type\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        // let leaseDOEPublicPath=FindMarket.getPublicPath(leaseDOESaleItemType, name: \"findLease\")\n        // let leaseDOEStoragePath= FindMarket.getStoragePath(leaseDOESaleItemType, name:\"findLease\")\n        // let leaseDOESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath) \n        // if !leaseDOESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath, target: leaseDOEStoragePath)\n        // }\n\n        // let leaseDOEBidType= Type\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        // let leaseDOEBidPublicPath=FindMarket.getPublicPath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidStoragePath= FindMarket.getStoragePath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath) \n        // if !leaseDOEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath, target: leaseDOEBidStoragePath)\n        // }\n        //SYNC with register\n\n        let path=FindMarket.getStoragePath(Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(), name: tenant.name)\n\n\n        // Get supported NFT and FT Information from Registries from input alias\n        let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftAliasOrIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftAliasOrIdentifier)) \n        let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n        let nft = collection.collectionData\n\n        let ft = FTRegistry.getFTInfo(ftAliasOrIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftAliasOrIdentifier))\n\n        var providerCap=account.getCapability\u003c\u0026{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e(nft.privatePath)\n        \n        /* Ben : Question -\u003e Either client will have to provide the path here or agree that we set it up for the user */\n        if !providerCap.check() {\n            let newCap = account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                    nft.privatePath,\n                    target: nft.storagePath\n            )\n            if newCap == nil {\n                // If linking is not successful, we link it using finds custom link \n                let pathIdentifier = nft.privatePath.toString()\n                let findPath = PrivatePath(identifier: pathIdentifier.slice(from: \"/private/\".length , upTo: pathIdentifier.length).concat(\"_FIND\"))!\n                account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                    findPath,\n                    target: nft.storagePath\n                )\n                providerCap = account.getCapability\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(findPath)\n            }\n        }\n\n        self.saleItems= account.borrow\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection\u003e(from: path)\n        self.pointer= FindViews.AuthNFTPointer(cap: providerCap, id: id)\n        self.vaultType= ft.type\n    }\n\n    pre{\n        // Ben : panic on some unreasonable inputs in trxn \n        minimumBidIncrement \u003e 0.0 : \"Minimum bid increment should be larger than 0.\"\n        (auctionReservePrice - auctionReservePrice) % minimumBidIncrement == 0.0 : \"Acution ReservePrice should be in step of minimum bid increment.\" \n        auctionDuration \u003e 0.0 : \"Auction Duration should be greater than 0.\"\n        auctionExtensionOnLateBid \u003e 0.0 : \"Auction Duration should be greater than 0.\"\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute {\n        self.saleItems!.listForAuction(pointer: self.pointer, vaultType: self.vaultType, auctionStartPrice: price, auctionReservePrice: auctionReservePrice, auctionDuration: auctionDuration, auctionExtensionOnLateBid: auctionExtensionOnLateBid, minimumBidIncrement: minimumBidIncrement, auctionValidUntil:auctionValidUntil, saleItemExtraField: {})\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "nftAliasOrIdentifier",
                     "id",
                     "ftAliasOrIdentifier",
                     "price",
                     "auctionReservePrice",
                     "auctionDuration",
                     "auctionExtensionOnLateBid",
                     "minimumBidIncrement",
                     "auctionValidUntil"
                  ],
                  "parameters": {
                     "auctionDuration": "UFix64",
                     "auctionExtensionOnLateBid": "UFix64",
                     "auctionReservePrice": "UFix64",
                     "auctionValidUntil": "UFix64?",
                     "ftAliasOrIdentifier": "String",
                     "id": "UInt64",
                     "marketplace": "Address",
                     "minimumBidIncrement": "UFix64",
                     "nftAliasOrIdentifier": "String",
                     "price": "UFix64"
                  }
               }
            },
            "listNFTForAuctionSoft": {
               "code": "import FindMarket from 0xf8d6e0586b0a20c7\nimport FindMarketSale from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionSoft from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FindViews from 0xf8d6e0586b0a20c7\nimport FTRegistry from 0xf8d6e0586b0a20c7\nimport NFTCatalog from 0xf8d6e0586b0a20c7\nimport FINDNFTCatalog from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FUSD from 0xf8d6e0586b0a20c7\nimport FiatToken from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport FIND from 0xf8d6e0586b0a20c7\nimport Dandy from 0xf8d6e0586b0a20c7\nimport Profile from 0xf8d6e0586b0a20c7\nimport FindLeaseMarketSale from 0xf8d6e0586b0a20c7\nimport FindLeaseMarketAuctionSoft from 0xf8d6e0586b0a20c7\n// import FindLeaseMarketAuctionEscrow from \"../contracts/FindLeaseMarketAuctionEscrow.cdc\"\nimport FindLeaseMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\n// import FindLeaseMarketDirectOfferEscrow from \"../contracts/FindLeaseMarketDirectOfferEscrow.cdc\"\nimport FindLeaseMarket from 0xf8d6e0586b0a20c7\n\ntransaction(marketplace:Address, nftAliasOrIdentifier:String, id: UInt64, ftAliasOrIdentifier:String, price:UFix64, auctionReservePrice: UFix64, auctionDuration: UFix64, auctionExtensionOnLateBid: UFix64, minimumBidIncrement: UFix64, auctionValidUntil: UFix64?) {\n    \n    let saleItems : \u0026FindMarketAuctionSoft.SaleItemCollection?\n    let pointer : FindViews.AuthNFTPointer\n    let vaultType : Type\n    \n    prepare(account: AuthAccount) {\n\n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n        //SYNC with register\n        //Add exising FUSD or create a new one and add it\n        let name = account.address.toString()\n        let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n        if !fusdReceiver.check() {\n            let fusd \u003c- FUSD.createEmptyVault()\n            account.save(\u003c- fusd, to: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n        }\n\n        let usdcCap = account.getCapability\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e(FiatToken.VaultReceiverPubPath)\n        if !usdcCap.check() {\n                account.save( \u003c-FiatToken.createEmptyVault(), to: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e( FiatToken.VaultReceiverPubPath, target: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FiatToken.ResourceId}\u003e( FiatToken.VaultUUIDPubPath, target: FiatToken.VaultStoragePath)\n                account.link\u003c\u0026FiatToken.Vault{FungibleToken.Balance}\u003e( FiatToken.VaultBalancePubPath, target:FiatToken.VaultStoragePath)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let dandyCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        let dandyCapPrivate= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPrivatePath)\n        if !dandyCapPrivate.check() {\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        var created=false\n        var updated=false\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        if !profile.hasWallet(\"Flow\") {\n            let flowWallet=Profile.Wallet( name:\"Flow\", receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), tags: [\"flow\"])\n    \n            profile.addWallet(flowWallet)\n            updated=true\n        }\n        if !profile.hasWallet(\"FUSD\") {\n            profile.addWallet(Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), tags: [\"fusd\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if !profile.hasWallet(\"USDC\") {\n            profile.addWallet(Profile.Wallet( name:\"USDC\", receiver:usdcCap, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(FiatToken.VaultBalancePubPath), accept: Type\u003c@FiatToken.Vault\u003e(), tags: [\"usdc\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else if updated {\n            profile.emitUpdatedEvent()\n        }\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        let doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        let doeSalePublicPath=FindMarket.getPublicPath(doeSaleType, name: tenant.name)\n        let doeSaleStoragePath= FindMarket.getStoragePath(doeSaleType, name:tenant.name)\n        let doeSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n        if !doeSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n        }\n\n        let doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        let doeBidPublicPath=FindMarket.getPublicPath(doeBidType, name: tenant.name)\n        let doeBidStoragePath= FindMarket.getStoragePath(doeBidType, name:tenant.name)\n        let doeBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n        if !doeBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n        }\n\n        /// auctions that escrow ft\n        let aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        let aeSalePublicPath=FindMarket.getPublicPath(aeSaleType, name: tenant.name)\n        let aeSaleStoragePath= FindMarket.getStoragePath(aeSaleType, name:tenant.name)\n        let aeSaleCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n        if !aeSaleCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n        }\n\n        let dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\n        let dosSalePublicPath=FindMarket.getPublicPath(dosSaleType, name: tenant.name)\n        let dosSaleStoragePath= FindMarket.getStoragePath(dosSaleType, name:tenant.name)\n\n        let dosSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n        if !dosSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n        }\n\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n        if !dosBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n        }\n\n        let aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\n        let aeBidPublicPath=FindMarket.getPublicPath(aeBidType, name: tenant.name)\n        let aeBidStoragePath= FindMarket.getStoragePath(aeBidType, name:tenant.name)\n        let aeBidCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n        if !aeBidCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n        }\n\n     /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n        }\n\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n        if !asBidCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n        }\n\n        let leaseTenantCapability= FindMarket.getTenantCapability(FindMarket.getTenantAddress(\"findLease\")!)!\n\n        let leaseSaleItemType= Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()\n        let leasePublicPath=FindMarket.getPublicPath(leaseSaleItemType, name: \"findLease\")\n        let leaseStoragePath= FindMarket.getStoragePath(leaseSaleItemType, name:\"findLease\")\n        let leaseSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath) \n        if !leaseSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketSale.SaleItemCollection\u003e(\u003c- FindLeaseMarketSale.createEmptySaleItemCollection(leaseTenantCapability), to: leaseStoragePath)\n            account.link\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath, target: leaseStoragePath)\n        }\n\n        let leaseASSaleItemType= Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e()\n        let leaseASPublicPath=FindMarket.getPublicPath(leaseASSaleItemType, name: \"findLease\")\n        let leaseASStoragePath= FindMarket.getStoragePath(leaseASSaleItemType, name:\"findLease\")\n        let leaseASSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath) \n        if !leaseASSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseASStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath, target: leaseASStoragePath)\n        }\n\n\n        let leaseASBidType= Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e()\n        let leaseASBidPublicPath=FindMarket.getPublicPath(leaseASBidType, name: \"findLease\")\n        let leaseASBidStoragePath= FindMarket.getStoragePath(leaseASBidType, name: \"findLease\")\n        let leaseASBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath) \n        if !leaseASBidCap.check() {\n            account.save\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseASBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath, target: leaseASBidStoragePath)\n        }\n\n        // let leaseAESaleItemType= Type\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e()\n        // let leaseAEPublicPath=FindMarket.getPublicPath(leaseAESaleItemType, name: \"findLease\")\n        // let leaseAEStoragePath= FindMarket.getStoragePath(leaseAESaleItemType, name:\"findLease\")\n        // let leaseAESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath) \n        // if !leaseAESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseAEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath, target: leaseAEStoragePath)\n        // }\n\n        // let leaseAEBidType= Type\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e()\n        // let leaseAEBidPublicPath=FindMarket.getPublicPath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidStoragePath= FindMarket.getStoragePath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath) \n        // if !leaseAEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseAEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath, target: leaseAEBidStoragePath)\n        // }\n\n        let leaseDOSSaleItemType= Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e()\n        let leaseDOSPublicPath=FindMarket.getPublicPath(leaseDOSSaleItemType, name: \"findLease\")\n        let leaseDOSStoragePath= FindMarket.getStoragePath(leaseDOSSaleItemType, name:\"findLease\")\n        let leaseDOSSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath) \n        if !leaseDOSSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOSStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath, target: leaseDOSStoragePath)\n        }\n\n        let leaseDOSBidType= Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let leaseDOSBidPublicPath=FindMarket.getPublicPath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidStoragePath= FindMarket.getStoragePath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath) \n        if !leaseDOSBidCap.check() {\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOSBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath, target: leaseDOSBidStoragePath)\n        }\n\n        // let leaseDOESaleItemType= Type\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        // let leaseDOEPublicPath=FindMarket.getPublicPath(leaseDOESaleItemType, name: \"findLease\")\n        // let leaseDOEStoragePath= FindMarket.getStoragePath(leaseDOESaleItemType, name:\"findLease\")\n        // let leaseDOESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath) \n        // if !leaseDOESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath, target: leaseDOEStoragePath)\n        // }\n\n        // let leaseDOEBidType= Type\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        // let leaseDOEBidPublicPath=FindMarket.getPublicPath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidStoragePath= FindMarket.getStoragePath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath) \n        // if !leaseDOEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath, target: leaseDOEBidStoragePath)\n        // }\n        //SYNC with register\n\n        // Get supported NFT and FT Information from Registries from input alias\n        let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftAliasOrIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftAliasOrIdentifier)) \n        let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n        let nft = collection.collectionData\n\n        let ft = FTRegistry.getFTInfo(ftAliasOrIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftAliasOrIdentifier))\n\n        var providerCap = account.getCapability\u003c\u0026{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e(nft.privatePath)\n\n        /* Ben : Question -\u003e Either client will have to provide the path here or agree that we set it up for the user */\n        if !providerCap.check() {\n            let newCap = account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                    nft.privatePath,\n                    target: nft.storagePath\n            )\n            if newCap == nil {\n                // If linking is not successful, we link it using finds custom link \n                let pathIdentifier = nft.privatePath.toString()\n                let findPath = PrivatePath(identifier: pathIdentifier.slice(from: \"/private/\".length , upTo: pathIdentifier.length).concat(\"_FIND\"))!\n                account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                    findPath,\n                    target: nft.storagePath\n                )\n                providerCap = account.getCapability\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(findPath)\n            }\n        }\n        \n        self.saleItems= account.borrow\u003c\u0026FindMarketAuctionSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()))\n        self.pointer= FindViews.AuthNFTPointer(cap: providerCap, id: id)\n        self.vaultType= ft.type\n\n        \n\n    }\n\n    pre{\n        // Ben : panic on some unreasonable inputs in trxn \n        minimumBidIncrement \u003e 0.0 :\"Minimum bid increment should be larger than 0.\"\n        (auctionReservePrice - auctionReservePrice) % minimumBidIncrement == 0.0 : \"Acution ReservePrice should be in step of minimum bid increment.\" \n        auctionDuration \u003e 0.0 : \"Auction Duration should be greater than 0.\"\n        auctionExtensionOnLateBid \u003e 0.0 : \"Auction Duration should be greater than 0.\"\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        self.saleItems!.listForAuction(pointer: self.pointer, vaultType: self.vaultType, auctionStartPrice: price, auctionReservePrice: auctionReservePrice, auctionDuration: auctionDuration, auctionExtensionOnLateBid: auctionExtensionOnLateBid, minimumBidIncrement: minimumBidIncrement, auctionValidUntil: auctionValidUntil, saleItemExtraField: {})\n\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "nftAliasOrIdentifier",
                     "id",
                     "ftAliasOrIdentifier",
                     "price",
                     "auctionReservePrice",
                     "auctionDuration",
                     "auctionExtensionOnLateBid",
                     "minimumBidIncrement",
                     "auctionValidUntil"
                  ],
                  "parameters": {
                     "auctionDuration": "UFix64",
                     "auctionExtensionOnLateBid": "UFix64",
                     "auctionReservePrice": "UFix64",
                     "auctionValidUntil": "UFix64?",
                     "ftAliasOrIdentifier": "String",
                     "id": "UInt64",
                     "marketplace": "Address",
                     "minimumBidIncrement": "UFix64",
                     "nftAliasOrIdentifier": "String",
                     "price": "UFix64"
                  }
               }
            },
            "listNFTForAuctionSoftDUC": {
               "code": "import FindMarket from 0xf8d6e0586b0a20c7\nimport FindMarketSale from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionSoft from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FindViews from 0xf8d6e0586b0a20c7\nimport NFTCatalog from 0xf8d6e0586b0a20c7\nimport FINDNFTCatalog from 0xf8d6e0586b0a20c7\nimport FTRegistry from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport TokenForwarding from 0xf8d6e0586b0a20c7\nimport DapperUtilityCoin from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\nimport Dandy from 0xf8d6e0586b0a20c7\nimport Profile from 0xf8d6e0586b0a20c7\nimport FindLeaseMarketSale from 0xf8d6e0586b0a20c7\nimport FindLeaseMarketAuctionSoft from 0xf8d6e0586b0a20c7\n// import FindLeaseMarketAuctionEscrow from \"../contracts/FindLeaseMarketAuctionEscrow.cdc\"\nimport FindLeaseMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\n// import FindLeaseMarketDirectOfferEscrow from \"../contracts/FindLeaseMarketDirectOfferEscrow.cdc\"\nimport FindLeaseMarket from 0xf8d6e0586b0a20c7\n\ntransaction(dapperAddress: Address, marketplace:Address, nftAliasOrIdentifier:String, id: UInt64, price:UFix64, auctionReservePrice: UFix64, auctionDuration: UFix64, auctionExtensionOnLateBid: UFix64, minimumBidIncrement: UFix64, auctionValidUntil: UFix64?) {\n    \n    let saleItems : \u0026FindMarketAuctionSoft.SaleItemCollection?\n    let pointer : FindViews.AuthNFTPointer\n    let vaultType : Type\n    \n    prepare(account: AuthAccount) {\n\n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n        //SYNC with register\n        //Add exising FUSD or create a new one and add it\n        let name = account.address.toString()\n        let ducReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver)\n        if !ducReceiver.check() {\n            let dapper = getAccount(dapperAddress)\n            // Create a new Forwarder resource for DUC and store it in the new account's storage\n            let ducForwarder \u003c- TokenForwarding.createNewForwarder(recipient: dapper.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver))\n            account.save(\u003c-ducForwarder, to: /storage/dapperUtilityCoinReceiver)\n            // Publish a Receiver capability for the new account, which is linked to the DUC Forwarder\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver,target: /storage/dapperUtilityCoinReceiver)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: ducReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let dandyCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        let dandyCapPrivate= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPrivatePath)\n        if !dandyCapPrivate.check() {\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        var created=false\n        var updated=false\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        if !profile.hasWallet(\"Flow\") {\n            let flowWallet=Profile.Wallet( name:\"Flow\", receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), tags: [\"flow\"])\n    \n            profile.addWallet(flowWallet)\n            updated=true\n        }\n        if !profile.hasWallet(\"DUC\") {\n            profile.addWallet(Profile.Wallet( name:\"DUC\", receiver:ducReceiver, balance:getAccount(dapperAddress).getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/dapperUtilityCoinBalance), accept: Type\u003c@DapperUtilityCoin.Vault\u003e(), tags: [\"duc\", \"dapperUtilityCoin\",\"dapper\"]))\n            updated=true\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else {\n            profile.emitUpdatedEvent()\n        }\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        let doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        let doeSalePublicPath=FindMarket.getPublicPath(doeSaleType, name: tenant.name)\n        let doeSaleStoragePath= FindMarket.getStoragePath(doeSaleType, name:tenant.name)\n        let doeSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n        if !doeSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n        }\n\n        let doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        let doeBidPublicPath=FindMarket.getPublicPath(doeBidType, name: tenant.name)\n        let doeBidStoragePath= FindMarket.getStoragePath(doeBidType, name:tenant.name)\n        let doeBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n        if !doeBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n        }\n\n        /// auctions that escrow ft\n        let aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        let aeSalePublicPath=FindMarket.getPublicPath(aeSaleType, name: tenant.name)\n        let aeSaleStoragePath= FindMarket.getStoragePath(aeSaleType, name:tenant.name)\n        let aeSaleCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n        if !aeSaleCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n        }\n\n        let dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\n        let dosSalePublicPath=FindMarket.getPublicPath(dosSaleType, name: tenant.name)\n        let dosSaleStoragePath= FindMarket.getStoragePath(dosSaleType, name:tenant.name)\n\n        let dosSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n        if !dosSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n        }\n\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n        if !dosBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n        }\n\n        let aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\n        let aeBidPublicPath=FindMarket.getPublicPath(aeBidType, name: tenant.name)\n        let aeBidStoragePath= FindMarket.getStoragePath(aeBidType, name:tenant.name)\n        let aeBidCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n        if !aeBidCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n        }\n\n     /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n        }\n\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n        if !asBidCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n        }\n\n        let leaseTenantCapability= FindMarket.getTenantCapability(FindMarket.getTenantAddress(\"findLease\")!)!\n\n        let leaseSaleItemType= Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()\n        let leasePublicPath=FindMarket.getPublicPath(leaseSaleItemType, name: \"findLease\")\n        let leaseStoragePath= FindMarket.getStoragePath(leaseSaleItemType, name:\"findLease\")\n        let leaseSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath) \n        if !leaseSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketSale.SaleItemCollection\u003e(\u003c- FindLeaseMarketSale.createEmptySaleItemCollection(leaseTenantCapability), to: leaseStoragePath)\n            account.link\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath, target: leaseStoragePath)\n        }\n\n        let leaseASSaleItemType= Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e()\n        let leaseASPublicPath=FindMarket.getPublicPath(leaseASSaleItemType, name: \"findLease\")\n        let leaseASStoragePath= FindMarket.getStoragePath(leaseASSaleItemType, name:\"findLease\")\n        let leaseASSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath) \n        if !leaseASSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseASStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath, target: leaseASStoragePath)\n        }\n\n\n        let leaseASBidType= Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e()\n        let leaseASBidPublicPath=FindMarket.getPublicPath(leaseASBidType, name: \"findLease\")\n        let leaseASBidStoragePath= FindMarket.getStoragePath(leaseASBidType, name: \"findLease\")\n        let leaseASBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath) \n        if !leaseASBidCap.check() {\n            account.save\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseASBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath, target: leaseASBidStoragePath)\n        }\n\n        // let leaseAESaleItemType= Type\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e()\n        // let leaseAEPublicPath=FindMarket.getPublicPath(leaseAESaleItemType, name: \"findLease\")\n        // let leaseAEStoragePath= FindMarket.getStoragePath(leaseAESaleItemType, name:\"findLease\")\n        // let leaseAESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath) \n        // if !leaseAESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseAEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath, target: leaseAEStoragePath)\n        // }\n\n        // let leaseAEBidType= Type\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e()\n        // let leaseAEBidPublicPath=FindMarket.getPublicPath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidStoragePath= FindMarket.getStoragePath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath) \n        // if !leaseAEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseAEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath, target: leaseAEBidStoragePath)\n        // }\n\n        let leaseDOSSaleItemType= Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e()\n        let leaseDOSPublicPath=FindMarket.getPublicPath(leaseDOSSaleItemType, name: \"findLease\")\n        let leaseDOSStoragePath= FindMarket.getStoragePath(leaseDOSSaleItemType, name:\"findLease\")\n        let leaseDOSSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath) \n        if !leaseDOSSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOSStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath, target: leaseDOSStoragePath)\n        }\n\n        let leaseDOSBidType= Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let leaseDOSBidPublicPath=FindMarket.getPublicPath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidStoragePath= FindMarket.getStoragePath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath) \n        if !leaseDOSBidCap.check() {\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOSBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath, target: leaseDOSBidStoragePath)\n        }\n\n        // let leaseDOESaleItemType= Type\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        // let leaseDOEPublicPath=FindMarket.getPublicPath(leaseDOESaleItemType, name: \"findLease\")\n        // let leaseDOEStoragePath= FindMarket.getStoragePath(leaseDOESaleItemType, name:\"findLease\")\n        // let leaseDOESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath) \n        // if !leaseDOESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath, target: leaseDOEStoragePath)\n        // }\n\n        // let leaseDOEBidType= Type\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        // let leaseDOEBidPublicPath=FindMarket.getPublicPath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidStoragePath= FindMarket.getStoragePath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath) \n        // if !leaseDOEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath, target: leaseDOEBidStoragePath)\n        // }\n        //SYNC with register\n\n        // Get supported NFT and FT Information from Registries from input alias\n        let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftAliasOrIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftAliasOrIdentifier)) \n        let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n        let nft = collection.collectionData\n\n        let ft = FTRegistry.getFTInfo(Type\u003c@DapperUtilityCoin.Vault\u003e().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(Type\u003c@DapperUtilityCoin.Vault\u003e().identifier))\n\n        var providerCap = account.getCapability\u003c\u0026{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e(nft.privatePath)\n\n        /* Ben : Question -\u003e Either client will have to provide the path here or agree that we set it up for the user */\n        if !providerCap.check() {\n            let newCap = account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                    nft.privatePath,\n                    target: nft.storagePath\n            )\n            if newCap == nil {\n                // If linking is not successful, we link it using finds custom link \n                let pathIdentifier = nft.privatePath.toString()\n                let findPath = PrivatePath(identifier: pathIdentifier.slice(from: \"/private/\".length , upTo: pathIdentifier.length).concat(\"_FIND\"))!\n                account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                    findPath,\n                    target: nft.storagePath\n                )\n                providerCap = account.getCapability\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(findPath)\n            }\n        }\n        \n        self.saleItems= account.borrow\u003c\u0026FindMarketAuctionSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()))\n        self.pointer= FindViews.AuthNFTPointer(cap: providerCap, id: id)    \n        self.vaultType= ft.type    \n    }\n\n    pre{\n        // Ben : panic on some unreasonable inputs in trxn \n        minimumBidIncrement \u003e 0.0 :\"Minimum bid increment should be larger than 0.\"\n        (auctionReservePrice - auctionReservePrice) % minimumBidIncrement == 0.0 : \"Acution ReservePrice should be in step of minimum bid increment.\" \n        auctionDuration \u003e 0.0 : \"Auction Duration should be greater than 0.\"\n        auctionExtensionOnLateBid \u003e 0.0 : \"Auction Duration should be greater than 0.\"\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        self.saleItems!.listForAuction(pointer: self.pointer, vaultType: self.vaultType, auctionStartPrice: price, auctionReservePrice: auctionReservePrice, auctionDuration: auctionDuration, auctionExtensionOnLateBid: auctionExtensionOnLateBid, minimumBidIncrement: minimumBidIncrement, auctionValidUntil: auctionValidUntil, saleItemExtraField: {})\n\n    }\n}",
               "spec": {
                  "order": [
                     "dapperAddress",
                     "marketplace",
                     "nftAliasOrIdentifier",
                     "id",
                     "price",
                     "auctionReservePrice",
                     "auctionDuration",
                     "auctionExtensionOnLateBid",
                     "minimumBidIncrement",
                     "auctionValidUntil"
                  ],
                  "parameters": {
                     "auctionDuration": "UFix64",
                     "auctionExtensionOnLateBid": "UFix64",
                     "auctionReservePrice": "UFix64",
                     "auctionValidUntil": "UFix64?",
                     "dapperAddress": "Address",
                     "id": "UInt64",
                     "marketplace": "Address",
                     "minimumBidIncrement": "UFix64",
                     "nftAliasOrIdentifier": "String",
                     "price": "UFix64"
                  }
               }
            },
            "listNFTForSale": {
               "code": "import FindMarket from 0xf8d6e0586b0a20c7\nimport FindMarketSale from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionSoft from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FUSD from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport FiatToken from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\nimport Dandy from 0xf8d6e0586b0a20c7\nimport Profile from 0xf8d6e0586b0a20c7\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FindViews from 0xf8d6e0586b0a20c7\nimport NFTCatalog from 0xf8d6e0586b0a20c7\nimport FINDNFTCatalog from 0xf8d6e0586b0a20c7\nimport FTRegistry from 0xf8d6e0586b0a20c7\nimport FindLeaseMarketSale from 0xf8d6e0586b0a20c7\nimport FindLeaseMarketAuctionSoft from 0xf8d6e0586b0a20c7\nimport FindLeaseMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\nimport FindLeaseMarket from 0xf8d6e0586b0a20c7\n\ntransaction(marketplace:Address, nftAliasOrIdentifier: String, id: UInt64, ftAliasOrIdentifier: String, directSellPrice:UFix64, validUntil: UFix64?) {\n    \n    let saleItems : \u0026FindMarketSale.SaleItemCollection?\n    let pointer : FindViews.AuthNFTPointer\n    let vaultType : Type\n\n    prepare(account: AuthAccount) {\n\n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n        //SYNC with register\n        //Add exising FUSD or create a new one and add it\n        let name = account.address.toString()\n        let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n        if !fusdReceiver.check() {\n            let fusd \u003c- FUSD.createEmptyVault()\n            account.save(\u003c- fusd, to: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n        }\n\n        let usdcCap = account.getCapability\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e(FiatToken.VaultReceiverPubPath)\n        if !usdcCap.check() {\n                account.save( \u003c-FiatToken.createEmptyVault(), to: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e( FiatToken.VaultReceiverPubPath, target: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FiatToken.ResourceId}\u003e( FiatToken.VaultUUIDPubPath, target: FiatToken.VaultStoragePath)\n                account.link\u003c\u0026FiatToken.Vault{FungibleToken.Balance}\u003e( FiatToken.VaultBalancePubPath, target:FiatToken.VaultStoragePath)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let dandyCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        let dandyCapPrivate= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPrivatePath)\n        if !dandyCapPrivate.check() {\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        var created=false\n        var updated=false\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        if !profile.hasWallet(\"Flow\") {\n            let flowWallet=Profile.Wallet( name:\"Flow\", receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), tags: [\"flow\"])\n    \n            profile.addWallet(flowWallet)\n            updated=true\n        }\n        if !profile.hasWallet(\"FUSD\") {\n            profile.addWallet(Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), tags: [\"fusd\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if !profile.hasWallet(\"USDC\") {\n            profile.addWallet(Profile.Wallet( name:\"USDC\", receiver:usdcCap, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(FiatToken.VaultBalancePubPath), accept: Type\u003c@FiatToken.Vault\u003e(), tags: [\"usdc\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else if updated {\n            profile.emitUpdatedEvent()\n        }\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        let doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        let doeSalePublicPath=FindMarket.getPublicPath(doeSaleType, name: tenant.name)\n        let doeSaleStoragePath= FindMarket.getStoragePath(doeSaleType, name:tenant.name)\n        let doeSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n        if !doeSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n        }\n\n        let doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        let doeBidPublicPath=FindMarket.getPublicPath(doeBidType, name: tenant.name)\n        let doeBidStoragePath= FindMarket.getStoragePath(doeBidType, name:tenant.name)\n        let doeBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n        if !doeBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n        }\n\n        /// auctions that escrow ft\n        let aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        let aeSalePublicPath=FindMarket.getPublicPath(aeSaleType, name: tenant.name)\n        let aeSaleStoragePath= FindMarket.getStoragePath(aeSaleType, name:tenant.name)\n        let aeSaleCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n        if !aeSaleCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n        }\n\n        let dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\n        let dosSalePublicPath=FindMarket.getPublicPath(dosSaleType, name: tenant.name)\n        let dosSaleStoragePath= FindMarket.getStoragePath(dosSaleType, name:tenant.name)\n\n        let dosSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n        if !dosSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n        }\n\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n        if !dosBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n        }\n\n        let aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\n        let aeBidPublicPath=FindMarket.getPublicPath(aeBidType, name: tenant.name)\n        let aeBidStoragePath= FindMarket.getStoragePath(aeBidType, name:tenant.name)\n        let aeBidCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n        if !aeBidCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n        }\n\n     /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n        }\n\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n        if !asBidCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n        }\n\n        let leaseTenantCapability= FindMarket.getTenantCapability(FindMarket.getTenantAddress(\"findLease\")!)!\n\n        let leaseSaleItemType= Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()\n        let leasePublicPath=FindMarket.getPublicPath(leaseSaleItemType, name: \"findLease\")\n        let leaseStoragePath= FindMarket.getStoragePath(leaseSaleItemType, name:\"findLease\")\n        let leaseSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath) \n        if !leaseSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketSale.SaleItemCollection\u003e(\u003c- FindLeaseMarketSale.createEmptySaleItemCollection(leaseTenantCapability), to: leaseStoragePath)\n            account.link\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath, target: leaseStoragePath)\n        }\n\n        let leaseASSaleItemType= Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e()\n        let leaseASPublicPath=FindMarket.getPublicPath(leaseASSaleItemType, name: \"findLease\")\n        let leaseASStoragePath= FindMarket.getStoragePath(leaseASSaleItemType, name:\"findLease\")\n        let leaseASSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath) \n        if !leaseASSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseASStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath, target: leaseASStoragePath)\n        }\n\n\n        let leaseASBidType= Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e()\n        let leaseASBidPublicPath=FindMarket.getPublicPath(leaseASBidType, name: \"findLease\")\n        let leaseASBidStoragePath= FindMarket.getStoragePath(leaseASBidType, name: \"findLease\")\n        let leaseASBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath) \n        if !leaseASBidCap.check() {\n            account.save\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseASBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath, target: leaseASBidStoragePath)\n        }\n\n        // let leaseAESaleItemType= Type\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e()\n        // let leaseAEPublicPath=FindMarket.getPublicPath(leaseAESaleItemType, name: \"findLease\")\n        // let leaseAEStoragePath= FindMarket.getStoragePath(leaseAESaleItemType, name:\"findLease\")\n        // let leaseAESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath) \n        // if !leaseAESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseAEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath, target: leaseAEStoragePath)\n        // }\n\n        // let leaseAEBidType= Type\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e()\n        // let leaseAEBidPublicPath=FindMarket.getPublicPath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidStoragePath= FindMarket.getStoragePath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath) \n        // if !leaseAEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseAEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath, target: leaseAEBidStoragePath)\n        // }\n\n        let leaseDOSSaleItemType= Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e()\n        let leaseDOSPublicPath=FindMarket.getPublicPath(leaseDOSSaleItemType, name: \"findLease\")\n        let leaseDOSStoragePath= FindMarket.getStoragePath(leaseDOSSaleItemType, name:\"findLease\")\n        let leaseDOSSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath) \n        if !leaseDOSSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOSStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath, target: leaseDOSStoragePath)\n        }\n\n        let leaseDOSBidType= Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let leaseDOSBidPublicPath=FindMarket.getPublicPath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidStoragePath= FindMarket.getStoragePath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath) \n        if !leaseDOSBidCap.check() {\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOSBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath, target: leaseDOSBidStoragePath)\n        }\n\n        // let leaseDOESaleItemType= Type\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        // let leaseDOEPublicPath=FindMarket.getPublicPath(leaseDOESaleItemType, name: \"findLease\")\n        // let leaseDOEStoragePath= FindMarket.getStoragePath(leaseDOESaleItemType, name:\"findLease\")\n        // let leaseDOESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath) \n        // if !leaseDOESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath, target: leaseDOEStoragePath)\n        // }\n\n        // let leaseDOEBidType= Type\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        // let leaseDOEBidPublicPath=FindMarket.getPublicPath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidStoragePath= FindMarket.getStoragePath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath) \n        // if !leaseDOEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath, target: leaseDOEBidStoragePath)\n        // }\n        //SYNC with register\n\n        // Get supported NFT and FT Information from Registries from input alias\n    let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier:nftAliasOrIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftAliasOrIdentifier)) \n    let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n    let nft = collection.collectionData\n\n        let ft = FTRegistry.getFTInfo(ftAliasOrIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftAliasOrIdentifier))\n\n        var providerCap=account.getCapability\u003c\u0026{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e(nft.privatePath)\n\n        /* Ben : Question -\u003e Either client will have to provide the path here or agree that we set it up for the user */\n        if !providerCap.check() {\n            let newCap = account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                nft.privatePath,\n                target: nft.storagePath\n            )\n            if newCap == nil {\n                // If linking is not successful, we link it using finds custom link \n                let pathIdentifier = nft.privatePath.toString()\n                let findPath = PrivatePath(identifier: pathIdentifier.slice(from: \"/private/\".length , upTo: pathIdentifier.length).concat(\"_FIND\"))!\n                account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                    findPath,\n                    target: nft.storagePath\n                )\n                providerCap = account.getCapability\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(findPath)\n            }\n        }\n        // Get the salesItemRef from tenant\n        self.saleItems= account.borrow\u003c\u0026FindMarketSale.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketSale.SaleItemCollection\u003e()))\n        self.pointer= FindViews.AuthNFTPointer(cap: providerCap, id: id)\n        self.vaultType= ft.type\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        self.saleItems!.listForSale(pointer: self.pointer, vaultType: self.vaultType, directSellPrice: directSellPrice, validUntil: validUntil, extraField: {})\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "nftAliasOrIdentifier",
                     "id",
                     "ftAliasOrIdentifier",
                     "directSellPrice",
                     "validUntil"
                  ],
                  "parameters": {
                     "directSellPrice": "UFix64",
                     "ftAliasOrIdentifier": "String",
                     "id": "UInt64",
                     "marketplace": "Address",
                     "nftAliasOrIdentifier": "String",
                     "validUntil": "UFix64?"
                  }
               }
            },
            "listNFTForSaleDUC": {
               "code": "import FindMarket from 0xf8d6e0586b0a20c7\nimport Profile from 0xf8d6e0586b0a20c7\nimport FindMarketSale from 0xf8d6e0586b0a20c7\nimport NFTCatalog from 0xf8d6e0586b0a20c7\nimport FINDNFTCatalog from 0xf8d6e0586b0a20c7\nimport FTRegistry from 0xf8d6e0586b0a20c7\nimport FindViews from 0xf8d6e0586b0a20c7\n\nimport FungibleToken from 0xee82856bf20e2aa6\nimport DapperUtilityCoin from 0xf8d6e0586b0a20c7\nimport TokenForwarding from 0xf8d6e0586b0a20c7\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\n\ntransaction(dapperAddress:Address, marketplace:Address, nftAliasOrIdentifier: String, id: UInt64, directSellPrice:UFix64, validUntil: UFix64?) {\n    \n    let saleItems : \u0026FindMarketSale.SaleItemCollection?\n    let pointer : FindViews.AuthNFTPointer\n    let vaultType : Type\n    \n    prepare(account: AuthAccount) {\n\n        let name = account.address.toString()\n        let ducReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver)\n        if !ducReceiver.check() {\n            let dapper = getAccount(dapperAddress)\n            let ducForwarder \u003c- TokenForwarding.createNewForwarder(recipient: dapper.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver))\n            account.save(\u003c-ducForwarder, to: /storage/dapperUtilityCoinReceiver)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver,target: /storage/dapperUtilityCoinReceiver)\n        }\n\n        var created=false\n        var updated=false\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            created=true\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"onefootball\")\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        if !profile.hasWallet(\"DUC\") {\n            updated=true\n            profile.addWallet(Profile.Wallet( name:\"DUC\", receiver:ducReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/dapperUtilityCoinBalance), accept: Type\u003c@DapperUtilityCoin.Vault\u003e(), tags: [\"duc\", \"dapperUtilityCoin\",\"dapper\"]))\n            updated=true\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else {\n            profile.emitUpdatedEvent()\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else if updated {\n            profile.emitUpdatedEvent()\n        }\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n        //end initializtion\n\n        // Get supported NFT and FT Information from Registries from input alias\n        let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftAliasOrIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftAliasOrIdentifier)) \n        let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n        let nft = collection.collectionData\n\n        let ft = FTRegistry.getFTInfo(Type\u003c@DapperUtilityCoin.Vault\u003e().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(Type\u003c@DapperUtilityCoin.Vault\u003e().identifier))\n\n        let providerCap=account.getCapability\u003c\u0026{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e(nft.privatePath)\n\n        if !providerCap.check() {\n            account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                nft.privatePath,\n                target: nft.storagePath\n            )\n        }\n        // Get the salesItemRef from tenant\n        self.saleItems= account.borrow\u003c\u0026FindMarketSale.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketSale.SaleItemCollection\u003e()))\n        self.pointer= FindViews.AuthNFTPointer(cap: providerCap, id: id)\n        self.vaultType= ft.type\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        self.saleItems!.listForSale(pointer: self.pointer, vaultType: self.vaultType, directSellPrice: directSellPrice, validUntil: validUntil, extraField: {})\n\n    }\n}",
               "spec": {
                  "order": [
                     "dapperAddress",
                     "marketplace",
                     "nftAliasOrIdentifier",
                     "id",
                     "directSellPrice",
                     "validUntil"
                  ],
                  "parameters": {
                     "dapperAddress": "Address",
                     "directSellPrice": "UFix64",
                     "id": "UInt64",
                     "marketplace": "Address",
                     "nftAliasOrIdentifier": "String",
                     "validUntil": "UFix64?"
                  }
               }
            },
            "listNameForAuction": {
               "code": "import FIND from 0xf8d6e0586b0a20c7\n\ntransaction(name: String, auctionStartPrice: UFix64, auctionReservePrice: UFix64, auctionDuration: UFix64, auctionExtensionOnLateBid: UFix64) {\n    \n    let finLeases : \u0026FIND.LeaseCollection?\n\n    prepare(acct: AuthAccount) {\n        self.finLeases= acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)\n    }\n\n    pre{\n        self.finLeases != nil : \"Cannot borrow reference to find lease collection\"\n    }\n\n    execute{\n        self.finLeases!.listForAuction(name: name, auctionStartPrice: auctionStartPrice, auctionReservePrice: auctionReservePrice, auctionDuration: auctionDuration,  auctionExtensionOnLateBid: auctionExtensionOnLateBid)\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "auctionStartPrice",
                     "auctionReservePrice",
                     "auctionDuration",
                     "auctionExtensionOnLateBid"
                  ],
                  "parameters": {
                     "auctionDuration": "UFix64",
                     "auctionExtensionOnLateBid": "UFix64",
                     "auctionReservePrice": "UFix64",
                     "auctionStartPrice": "UFix64",
                     "name": "String"
                  }
               }
            },
            "listNameForSale": {
               "code": "import FIND from 0xf8d6e0586b0a20c7\n\ntransaction(name: String, directSellPrice:UFix64) {\n\n    let finLeases : \u0026FIND.LeaseCollection?\n\n    prepare(acct: AuthAccount) {\n        self.finLeases= acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)\n    }\n\n    pre{\n        self.finLeases != nil : \"Cannot borrow reference to find lease collection\"\n    }\n\n    execute{\n        self.finLeases!.listForSale(name: name,  directSellPrice:directSellPrice)\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "directSellPrice"
                  ],
                  "parameters": {
                     "directSellPrice": "UFix64",
                     "name": "String"
                  }
               }
            },
            "moveNameTO": {
               "code": "import Profile from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\n\n\ntransaction(name: String, receiver:String) {\n\n\n    let receiverAddress:Address?\n    let sender : \u0026FIND.LeaseCollection\n\n    prepare(acct: AuthAccount) {\n        self.sender= acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n        self.receiverAddress=FIND.resolve(receiver)\n    } \n\n    pre{\n        self.receiverAddress != nil : \"The input pass in is not a valid name or address. Input : \".concat(receiver)\n    }\n\n    execute {\n        let receiver=getAccount(self.receiverAddress!)\n        let receiverLease = receiver.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        let receiverProfile = receiver.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\n        if !receiverLease.check() || !receiverProfile.check() {\n            panic(\"Not a valid FIND user\")\n        }\n\n        self.sender.move(name:name, profile:receiverProfile, to: receiverLease)\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "receiver"
                  ],
                  "parameters": {
                     "name": "String",
                     "receiver": "String"
                  }
               }
            },
            "openBl0xPack": {
               "code": "import Bl0x from 0xf8d6e0586b0a20c7\nimport Bl0xPack from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\n\n/// A transaction to open a pack with a given id\n/// @param packId: The id of the pack to open\ntransaction(packId:UInt64) {\n\n    let packs: \u0026Bl0xPack.Collection\n    var receiver: Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e\n\n    prepare(account: AuthAccount) {\n        self.packs=account.borrow\u003c\u0026Bl0xPack.Collection\u003e(from: Bl0xPack.CollectionStoragePath)!\n        self.receiver = account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(Bl0x.CollectionPublicPath)\n        if !self.receiver.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Bl0x.createEmptyCollection(), to: Bl0x.CollectionStoragePath)\n            account.link\u003c\u0026Bl0x.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                Bl0x.CollectionPublicPath,\n                target: Bl0x.CollectionStoragePath\n            )\n            account.link\u003c\u0026Bl0x.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                Bl0x.CollectionPrivatePath,\n                target: Bl0x.CollectionStoragePath\n            )\n\n            self.receiver = account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(Bl0x.CollectionPublicPath)\n        }\n\n    }\n\n    pre {\n        self.receiver.check() : \"The receiver collection for the packs is not set up properly\"\n    }\n    execute {\n        self.packs.open(packId: packId, receiverCap:self.receiver)\n    }\n\n    post {\n        !self.packs.getIDs().contains(packId) : \"The pack is still present in the users collection\"\n    }\n}",
               "spec": {
                  "order": [
                     "packId"
                  ],
                  "parameters": {
                     "packId": "UInt64"
                  }
               }
            },
            "redeemAllLostAndFoundNFTs": {
               "code": "import FindLostAndFoundWrapper from 0xf8d6e0586b0a20c7\nimport LostAndFound from 0xf8d6e0586b0a20c7\nimport FINDNFTCatalog from 0xf8d6e0586b0a20c7\nimport NFTCatalog from 0xf8d6e0586b0a20c7\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\nimport Bl0xPack from 0xf8d6e0586b0a20c7\n\n//IMPORT\n\ntransaction() {\n\n    let ids : {String : [UInt64]}\n    let nftInfos : {String : NFTCatalog.NFTCollectionData}\n    let receiverAddress : Address\n\n    prepare(account: AuthAccount){\n\n        //LINK\n\n        let findPackCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Bl0xPack.CollectionPublicPath)\n        if !findPackCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e( \u003c- Bl0xPack.createEmptyCollection(), to: Bl0xPack.CollectionStoragePath)\n            account.link\u003c\u0026Bl0xPack.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                Bl0xPack.CollectionPublicPath,\n                target: Bl0xPack.CollectionStoragePath\n            )\n        }\n\n        self.nftInfos = {}\n        self.ids = FindLostAndFoundWrapper.getTicketIDs(user: account.address, specificType: Type\u003c@NonFungibleToken.NFT\u003e())\n\n        for type in self.ids.keys{ \n            if self.nftInfos[type] == nil {\n                let collections = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: type) ?? panic(\"NFT type is not supported at the moment. Type : \".concat(type))\n                self.nftInfos[type] = FINDNFTCatalog.getCatalogEntry(collectionIdentifier: collections.keys[0])!.collectionData\n            }\n        }\n\n        self.receiverAddress = account.address\n    }\n\n    execute{\n        for type in self.ids.keys{ \n            let path = self.nftInfos[type]!.publicPath\n            for id in self.ids[type]! {\n                FindLostAndFoundWrapper.redeemNFT(type: CompositeType(type)!, ticketID: id, receiverAddress: self.receiverAddress, collectionPublicPath: path)\n            }\n        }\n    }\n}",
               "spec": {
                  "order": [],
                  "parameters": {}
               }
            },
            "redeemAllLostAndFoundNFTsOnBehalf": {
               "code": "import FindLostAndFoundWrapper from 0xf8d6e0586b0a20c7\nimport LostAndFound from 0xf8d6e0586b0a20c7\nimport FINDNFTCatalog from 0xf8d6e0586b0a20c7\nimport NFTCatalog from 0xf8d6e0586b0a20c7\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\n\n//IMPORT\n\ntransaction(receiverAddress: Address) {\n\n    let ids : {String : [UInt64]}\n    let nftInfos : {String : NFTCatalog.NFTCollectionData}\n    let receiverAddress : Address\n\n    prepare(account: AuthAccount){\n        self.receiverAddress = receiverAddress\n\n        self.nftInfos = {}\n        self.ids = FindLostAndFoundWrapper.getTicketIDs(user: receiverAddress, specificType: Type\u003c@NonFungibleToken.NFT\u003e())\n\n        for type in self.ids.keys{ \n            if self.nftInfos[type] == nil {\n                let collections = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: type) ?? panic(\"NFT type is not supported at the moment. Type : \".concat(type))\n                self.nftInfos[type] = FINDNFTCatalog.getCatalogEntry(collectionIdentifier: collections.keys[0])!.collectionData\n            }\n        }\n\n    }\n\n    execute{\n        for type in self.ids.keys{ \n            let path = self.nftInfos[type]!.publicPath\n            for id in self.ids[type]! {\n                FindLostAndFoundWrapper.redeemNFT(type: CompositeType(type)!, ticketID: id, receiverAddress: self.receiverAddress, collectionPublicPath: path)\n            }\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "receiverAddress"
                  ],
                  "parameters": {
                     "receiverAddress": "Address"
                  }
               }
            },
            "redeemLostAndFoundNFTs": {
               "code": "import FindLostAndFoundWrapper from 0xf8d6e0586b0a20c7\nimport LostAndFound from 0xf8d6e0586b0a20c7\nimport FINDNFTCatalog from 0xf8d6e0586b0a20c7\nimport NFTCatalog from 0xf8d6e0586b0a20c7\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FindViews from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\nimport Bl0xPack from 0xf8d6e0586b0a20c7\n\n//IMPORT\n\ntransaction(ids: {String : [UInt64]}) {\n\n    let nftInfos : {String : NFTCatalog.NFTCollectionData}\n    let receiverAddress : Address\n\n    prepare(account: AuthAccount){\n\n        //LINK\n\n        let findPackCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Bl0xPack.CollectionPublicPath)\n        if !findPackCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e( \u003c- Bl0xPack.createEmptyCollection(), to: Bl0xPack.CollectionStoragePath)\n            account.link\u003c\u0026Bl0xPack.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                Bl0xPack.CollectionPublicPath,\n                target: Bl0xPack.CollectionStoragePath\n            )\n        }\n\n        self.nftInfos = {}\n\n        for type in ids.keys{ \n            if self.nftInfos[type] == nil {\n                let collections = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: type) ?? panic(\"NFT type is not supported at the moment. Type : \".concat(type))\n                self.nftInfos[type] = FINDNFTCatalog.getCatalogEntry(collectionIdentifier: collections.keys[0])!.collectionData\n            }\n        }\n\n        self.receiverAddress = account.address\n    }\n\n    execute{\n        for type in ids.keys{ \n            let path = self.nftInfos[type]!.publicPath\n            for id in ids[type]! {\n                FindLostAndFoundWrapper.redeemNFT(type: CompositeType(type)!, ticketID: id, receiverAddress:self.receiverAddress, collectionPublicPath: path)\n            }\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "ids"
                  ],
                  "parameters": {
                     "ids": "{String: [UInt64]}"
                  }
               }
            },
            "redeemLostAndFoundNFTsOnBehalf": {
               "code": "import FindLostAndFoundWrapper from 0xf8d6e0586b0a20c7\nimport LostAndFound from 0xf8d6e0586b0a20c7\nimport FINDNFTCatalog from 0xf8d6e0586b0a20c7\nimport NFTCatalog from 0xf8d6e0586b0a20c7\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FindViews from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\nimport Bl0xPack from 0xf8d6e0586b0a20c7\n\n//IMPORT\n\ntransaction(receiverAddress: Address, ids: {String : [UInt64]}) {\n\n    let nftInfos : {String : NFTCatalog.NFTCollectionData}\n    let receiverAddress : Address\n\n    prepare(account: AuthAccount){\n\n        self.receiverAddress = receiverAddress\n\n        self.nftInfos = {}\n\n        for type in ids.keys{ \n            if self.nftInfos[type] == nil {\n                let collections = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: type) ?? panic(\"NFT type is not supported at the moment. Type : \".concat(type))\n                self.nftInfos[type] = FINDNFTCatalog.getCatalogEntry(collectionIdentifier: collections.keys[0])!.collectionData\n            }\n        }\n\n    }\n\n    execute{\n        for type in ids.keys{ \n            let path = self.nftInfos[type]!.publicPath\n            for id in ids[type]! {\n                FindLostAndFoundWrapper.redeemNFT(type: CompositeType(type)!, ticketID: id, receiverAddress:self.receiverAddress, collectionPublicPath: path)\n            }\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "receiverAddress",
                     "ids"
                  ],
                  "parameters": {
                     "ids": "{String: [UInt64]}",
                     "receiverAddress": "Address"
                  }
               }
            },
            "register": {
               "code": "import FungibleToken from 0xee82856bf20e2aa6\nimport FUSD from 0xf8d6e0586b0a20c7\nimport FiatToken from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport Profile from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\nimport FindMarketSale from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionSoft from 0xf8d6e0586b0a20c7\nimport FindMarket from 0xf8d6e0586b0a20c7\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport Dandy from 0xf8d6e0586b0a20c7\nimport FindLeaseMarketSale from 0xf8d6e0586b0a20c7\nimport FindLeaseMarketAuctionSoft from 0xf8d6e0586b0a20c7\n// import FindLeaseMarketAuctionEscrow from \"../contracts/FindLeaseMarketAuctionEscrow.cdc\"\nimport FindLeaseMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\n// import FindLeaseMarketDirectOfferEscrow from \"../contracts/FindLeaseMarketDirectOfferEscrow.cdc\"\nimport FindLeaseMarket from 0xf8d6e0586b0a20c7\n\ntransaction(name: String, amount: UFix64) {\n\n    let vaultRef : \u0026FUSD.Vault?\n    let leases : \u0026FIND.LeaseCollection?\n    let price : UFix64\n\n    prepare(account: AuthAccount) {\n\n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n        //SYNC with register\n        //Add exising FUSD or create a new one and add it\n        let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n        if !fusdReceiver.check() {\n            let fusd \u003c- FUSD.createEmptyVault()\n            account.save(\u003c- fusd, to: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n        }\n\n        let usdcCap = account.getCapability\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e(FiatToken.VaultReceiverPubPath)\n        if !usdcCap.check() {\n            account.save( \u003c-FiatToken.createEmptyVault(), to: FiatToken.VaultStoragePath)\n            account.link\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e( FiatToken.VaultReceiverPubPath, target: FiatToken.VaultStoragePath)\n            account.link\u003c\u0026FiatToken.Vault{FiatToken.ResourceId}\u003e( FiatToken.VaultUUIDPubPath, target: FiatToken.VaultStoragePath)\n            account.link\u003c\u0026FiatToken.Vault{FungibleToken.Balance}\u003e( FiatToken.VaultBalancePubPath, target:FiatToken.VaultStoragePath)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let dandyCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        let dandyCapPrivate= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPrivatePath)\n        if !dandyCapPrivate.check() {\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        var created=false\n        var updated=false\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        if !profile.hasWallet(\"Flow\") {\n            let flowWallet=Profile.Wallet( name:\"Flow\", receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), tags: [\"flow\"])\n    \n            profile.addWallet(flowWallet)\n            updated=true\n        }\n        if !profile.hasWallet(\"FUSD\") {\n            profile.addWallet(Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), tags: [\"fusd\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if !profile.hasWallet(\"USDC\") {\n            profile.addWallet(Profile.Wallet( name:\"USDC\", receiver:usdcCap, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(FiatToken.VaultBalancePubPath), accept: Type\u003c@FiatToken.Vault\u003e(), tags: [\"usdc\", \"stablecoin\"]))\n            updated=true\n        }\n\n          //If find name not set and we have a profile set it.\n        if profile.getFindName() == \"\" {\n            profile.setFindName(name)\n            // If name is set, it will emit Updated Event, there is no need to emit another update event below. \n            updated=false\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else if updated {\n            profile.emitUpdatedEvent()\n        }\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let tenantCapability= FindMarket.getTenantCapability(FindMarket.getFindTenantAddress())!\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        let doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        let doeSalePublicPath=FindMarket.getPublicPath(doeSaleType, name: tenant.name)\n        let doeSaleStoragePath= FindMarket.getStoragePath(doeSaleType, name:tenant.name)\n        let doeSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n        if !doeSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n        }\n\n        let doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        let doeBidPublicPath=FindMarket.getPublicPath(doeBidType, name: tenant.name)\n        let doeBidStoragePath= FindMarket.getStoragePath(doeBidType, name:tenant.name)\n        let doeBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n        if !doeBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n        }\n\n        /// auctions that escrow ft\n        let aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        let aeSalePublicPath=FindMarket.getPublicPath(aeSaleType, name: tenant.name)\n        let aeSaleStoragePath= FindMarket.getStoragePath(aeSaleType, name:tenant.name)\n        let aeSaleCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n        if !aeSaleCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n        }\n\n        let dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\n        let dosSalePublicPath=FindMarket.getPublicPath(dosSaleType, name: tenant.name)\n        let dosSaleStoragePath= FindMarket.getStoragePath(dosSaleType, name:tenant.name)\n\n        let dosSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n        if !dosSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n        }\n\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n        if !dosBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n        }\n\n        let aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\n        let aeBidPublicPath=FindMarket.getPublicPath(aeBidType, name: tenant.name)\n        let aeBidStoragePath= FindMarket.getStoragePath(aeBidType, name:tenant.name)\n        let aeBidCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n        if !aeBidCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n        }\n\n     /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n        }\n\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n        if !asBidCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n        }\n\n        let leaseTenantCapability= FindMarket.getTenantCapability(FindMarket.getTenantAddress(\"findLease\")!)!\n\n        let leaseSaleItemType= Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()\n        let leasePublicPath=FindMarket.getPublicPath(leaseSaleItemType, name: \"findLease\")\n        let leaseStoragePath= FindMarket.getStoragePath(leaseSaleItemType, name:\"findLease\")\n        let leaseSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath) \n        if !leaseSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketSale.SaleItemCollection\u003e(\u003c- FindLeaseMarketSale.createEmptySaleItemCollection(leaseTenantCapability), to: leaseStoragePath)\n            account.link\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath, target: leaseStoragePath)\n        }\n\n        let leaseASSaleItemType= Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e()\n        let leaseASPublicPath=FindMarket.getPublicPath(leaseASSaleItemType, name: \"findLease\")\n        let leaseASStoragePath= FindMarket.getStoragePath(leaseASSaleItemType, name:\"findLease\")\n        let leaseASSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath) \n        if !leaseASSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseASStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath, target: leaseASStoragePath)\n        }\n\n\n        let leaseASBidType= Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e()\n        let leaseASBidPublicPath=FindMarket.getPublicPath(leaseASBidType, name: \"findLease\")\n        let leaseASBidStoragePath= FindMarket.getStoragePath(leaseASBidType, name: \"findLease\")\n        let leaseASBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath) \n        if !leaseASBidCap.check() {\n            account.save\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseASBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath, target: leaseASBidStoragePath)\n        }\n\n        // let leaseAESaleItemType= Type\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e()\n        // let leaseAEPublicPath=FindMarket.getPublicPath(leaseAESaleItemType, name: \"findLease\")\n        // let leaseAEStoragePath= FindMarket.getStoragePath(leaseAESaleItemType, name:\"findLease\")\n        // let leaseAESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath) \n        // if !leaseAESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseAEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath, target: leaseAEStoragePath)\n        // }\n\n        // let leaseAEBidType= Type\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e()\n        // let leaseAEBidPublicPath=FindMarket.getPublicPath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidStoragePath= FindMarket.getStoragePath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath) \n        // if !leaseAEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseAEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath, target: leaseAEBidStoragePath)\n        // }\n\n        let leaseDOSSaleItemType= Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e()\n        let leaseDOSPublicPath=FindMarket.getPublicPath(leaseDOSSaleItemType, name: \"findLease\")\n        let leaseDOSStoragePath= FindMarket.getStoragePath(leaseDOSSaleItemType, name:\"findLease\")\n        let leaseDOSSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath) \n        if !leaseDOSSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOSStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath, target: leaseDOSStoragePath)\n        }\n\n        let leaseDOSBidType= Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let leaseDOSBidPublicPath=FindMarket.getPublicPath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidStoragePath= FindMarket.getStoragePath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath) \n        if !leaseDOSBidCap.check() {\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOSBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath, target: leaseDOSBidStoragePath)\n        }\n\n        // let leaseDOESaleItemType= Type\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        // let leaseDOEPublicPath=FindMarket.getPublicPath(leaseDOESaleItemType, name: \"findLease\")\n        // let leaseDOEStoragePath= FindMarket.getStoragePath(leaseDOESaleItemType, name:\"findLease\")\n        // let leaseDOESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath) \n        // if !leaseDOESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath, target: leaseDOEStoragePath)\n        // }\n\n        // let leaseDOEBidType= Type\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        // let leaseDOEBidPublicPath=FindMarket.getPublicPath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidStoragePath= FindMarket.getStoragePath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath) \n        // if !leaseDOEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath, target: leaseDOEBidStoragePath)\n        // }\n        //SYNC with register\n\n        self.price=FIND.calculateCost(name)\n        log(\"The cost for registering this name is \".concat(self.price.toString()))\n        self.vaultRef = account.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault)\n        self.leases=account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from: FIND.LeaseStoragePath)\n    }\n\n    pre{\n        self.vaultRef != nil : \"Could not borrow reference to the fusdVault!\"\n        self.leases != nil : \"Could not borrow reference to find lease collection\"\n        self.price == amount : \"Calculated cost : \".concat(self.price.toString()).concat(\" does not match expected cost : \").concat(amount.toString())\n    }\n\n    execute{\n        let payVault \u003c- self.vaultRef!.withdraw(amount: self.price) as! @FUSD.Vault\n        self.leases!.register(name: name, vault: \u003c- payVault)\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "name": "String"
                  }
               }
            },
            "registerGift": {
               "code": "import FUSD from 0xf8d6e0586b0a20c7\nimport Profile from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\n\ntransaction(name: String, amount: UFix64, recipient: String) {\n\n    let price : UFix64 \n    let vaultRef : \u0026FUSD.Vault? \n    let receiverLease : Capability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e\n    let receiverProfile : Capability\u003c\u0026{Profile.Public}\u003e\n    let leases : \u0026FIND.LeaseCollection?\n\n    prepare(acct: AuthAccount) {\n\n        let resolveAddress = FIND.resolve(recipient)\n        if resolveAddress == nil {panic(\"The input pass in is not a valid name or address. Input : \".concat(recipient))}\n        let address = resolveAddress!\n\n        self.price=FIND.calculateCost(name)\n        log(\"The cost for registering this name is \".concat(self.price.toString()))\n\n        self.vaultRef = acct.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault)\n\n        self.leases=acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from: FIND.LeaseStoragePath)\n\n        let receiver = getAccount(address)\n        self.receiverLease = receiver.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        self.receiverProfile = receiver.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\n    }\n\n    pre{\n        self.price == amount : \"Calculated cost : \".concat(self.price.toString()).concat(\" does not match expected cost\").concat(amount.toString())\n        self.vaultRef != nil : \"Cannot borrow reference to fusd Vault!\"\n        self.receiverLease.check() : \"Lease capability is invalid\"\n        self.receiverProfile.check() : \"Profile capability is invalid\"\n        self.leases != nil : \"Cannot borrow refernce to find lease collection\"\n    }\n\n    execute{\n        let payVault \u003c- self.vaultRef!.withdraw(amount: self.price) as! @FUSD.Vault\n        self.leases!.register(name: name, vault: \u003c- payVault)\n        self.leases!.move(name: name, profile: self.receiverProfile, to: self.receiverLease)\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "amount",
                     "recipient"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "name": "String",
                     "recipient": "String"
                  }
               }
            },
            "rejectNameDirectOffer": {
               "code": "import FIND from 0xf8d6e0586b0a20c7\n\ntransaction(names: [String]) {\n\n    let finLeases : \u0026FIND.LeaseCollection? \n\n    prepare(account: AuthAccount) {\n        self.finLeases= account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)\n    }\n\n    pre{\n        self.finLeases != nil : \"Cannot borrow reference to find lease collection\"\n    }\n\n    execute{\n        for name in names {\n            self.finLeases!.cancel(name)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "names"
                  ],
                  "parameters": {
                     "names": "[String]"
                  }
               }
            },
            "relistMarketListings": {
               "code": "import FindMarket from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionSoft from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\nimport FindMarketSale from 0xf8d6e0586b0a20c7\n\ntransaction(marketplace:Address, ids: {String : [UInt64]}) {\n    prepare(account: AuthAccount) {\n\n        let tenant=FindMarket.getTenant(marketplace)\n\n        var saleType = Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        if let ids = ids[FindMarket.getMarketOptionFromType(saleType)] {\n            let saleItems= account.borrow\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection\u003e(from: tenant.getStoragePath(saleType))!\n            for id in ids {\n                saleItems.relist(id)\n            }\n        }\n\n        saleType = Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        if let ids = ids[FindMarket.getMarketOptionFromType(saleType)] {\n            let saleItems= account.borrow\u003c\u0026FindMarketAuctionSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(saleType))!\n            for id in ids {\n                saleItems.relist(id)\n            }\n        }\n\n        saleType = Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        if let ids = ids[FindMarket.getMarketOptionFromType(saleType)] {\n            let saleItems= account.borrow\u003c\u0026FindMarketSale.SaleItemCollection\u003e(from: tenant.getStoragePath(saleType))!\n            for id in ids {\n                saleItems.relist(id)\n            }\n        }\n\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "ids"
                  ],
                  "parameters": {
                     "ids": "{String: [UInt64]}",
                     "marketplace": "Address"
                  }
               }
            },
            "removeCurratedCollection": {
               "code": "transaction(name: String) {\n    prepare(account: AuthAccount) {\n\n        let path=/storage/FindCuratedCollections\n        let publicPath=/public/FindCuratedCollections\n\n        var collections : {String: [String]} = {}\n        if account.borrow\u003c\u0026{String: [String]}\u003e(from:path) != nil {\n             collections=account.load\u003c{String: [String]}\u003e(from:path)!\n        }\n        collections.remove(key: name)\n        account.save(collections, to: path)\n        let link = account.getCapability\u003c\u0026{String: [String]}\u003e(publicPath)\n        if !link.check() {\n            account.link\u003c\u0026{String: [String]}\u003e( publicPath, target: path)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "removeMarketOption": {
               "code": "import FindMarket from 0xf8d6e0586b0a20c7\n\ntransaction(saleItemName: String){\n    \n    prepare(account: AuthAccount){\n        let path = FindMarket.TenantClientStoragePath\n        let tenantRef = account.borrow\u003c\u0026FindMarket.TenantClient\u003e(from: path) ?? panic(\"Cannot borrow Reference.\")\n\n        tenantRef.removeMarketOption(name: saleItemName)\n    }\n}",
               "spec": {
                  "order": [
                     "saleItemName"
                  ],
                  "parameters": {
                     "saleItemName": "String"
                  }
               }
            },
            "removeRelatedAccount": {
               "code": "import RelatedAccounts from 0xf8d6e0586b0a20c7\n\ntransaction(name: String){\n\n    var relatedAccounts : \u0026RelatedAccounts.Accounts?\n\n    prepare(account: AuthAccount) {\n\n        self.relatedAccounts= account.borrow\u003c\u0026RelatedAccounts.Accounts\u003e(from:RelatedAccounts.storagePath)\n        if self.relatedAccounts == nil {\n            let relatedAccounts \u003c- RelatedAccounts.createEmptyAccounts()\n            account.save(\u003c- relatedAccounts, to: RelatedAccounts.storagePath)\n            account.link\u003c\u0026RelatedAccounts.Accounts{RelatedAccounts.Public}\u003e(RelatedAccounts.publicPath, target: RelatedAccounts.storagePath)\n            self.relatedAccounts= account.borrow\u003c\u0026RelatedAccounts.Accounts\u003e(from:RelatedAccounts.storagePath)\n        }\n\n        let cap = account.getCapability\u003c\u0026RelatedAccounts.Accounts{RelatedAccounts.Public}\u003e(RelatedAccounts.publicPath)\n        if !cap.check() {\n            account.unlink(RelatedAccounts.publicPath)\n            account.link\u003c\u0026RelatedAccounts.Accounts{RelatedAccounts.Public}\u003e(RelatedAccounts.publicPath, target: RelatedAccounts.storagePath)\n        }\n\n    }\n\n    execute{\n        self.relatedAccounts!.deleteAccount(name: name)\n    }\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "removeTenantRule": {
               "code": "import FindMarket from 0xf8d6e0586b0a20c7\n\ntransaction(optionName: String, tenantRuleName: String){\n    prepare(account: AuthAccount){\n        let path = FindMarket.TenantClientStoragePath\n        let tenantRef = account.borrow\u003c\u0026FindMarket.TenantClient\u003e(from: path) ?? panic(\"Cannot borrow Reference.\")\n\n        tenantRef.removeTenantRule(optionName: optionName, tenantRuleName: tenantRuleName)\n    }\n}",
               "spec": {
                  "order": [
                     "optionName",
                     "tenantRuleName"
                  ],
                  "parameters": {
                     "optionName": "String",
                     "tenantRuleName": "String"
                  }
               }
            },
            "renewName": {
               "code": "import FUSD from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\n\ntransaction(name: String, amount: UFix64) {\n\n    let price : UFix64\n    let vaultRef : \u0026FUSD.Vault? \n    let finLeases : \u0026FIND.LeaseCollection? \n\n    prepare(acct: AuthAccount) {\n        self.price=FIND.calculateCost(name)\n        self.vaultRef = acct.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault)\n        self.finLeases= acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)\n    }\n\n    pre{\n        self.price == amount : \"expected renew cost : \".concat(self.price.toString()).concat(\" is not the same as calculated renew cost : \").concat(amount.toString())\n        self.vaultRef != nil : \"Could not borrow reference to the fusdVault!\"\n        self.finLeases != nil : \"Could not borrow reference to find lease collection\"\n    }\n\n    execute{\n        let payVault \u003c- self.vaultRef!.withdraw(amount: self.price) as! @FUSD.Vault\n        let finToken= self.finLeases!.borrow(name)\n        finToken.extendLease(\u003c- payVault)\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "name": "String"
                  }
               }
            },
            "retractOfferLeaseMarketDirectOfferSoft": {
               "code": "import FindMarket from 0xf8d6e0586b0a20c7\nimport FindLeaseMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\n\ntransaction(leaseName: String) {\n    let bidsReference: \u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection?\n\n    prepare(account: AuthAccount) {\n        let marketplace = FindMarket.getTenantAddress(\"findLease\")!\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e())\n        self.bidsReference= account.borrow\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(from: storagePath) \n    }\n\n    pre{\n        self.bidsReference != nil : \"Bid resource does not exist\"\n    }\n\n    execute {\n        self.bidsReference!.cancelBid(leaseName)\n    }\n}",
               "spec": {
                  "order": [
                     "leaseName"
                  ],
                  "parameters": {
                     "leaseName": "String"
                  }
               }
            },
            "retractOfferMarketDirectOfferEscrowed": {
               "code": "import FindMarket from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferEscrow from 0xf8d6e0586b0a20c7\n\ntransaction(marketplace:Address, id: UInt64) {\n    let bidsReference: \u0026FindMarketDirectOfferEscrow.MarketBidCollection? \n\n    prepare(account: AuthAccount) {\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e())\n        self.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection\u003e(from: storagePath) \n    }\n\n    pre{\n        self.bidsReference != nil : \"This account does not have a bid collection\"\n    }\n\n    execute {\n        self.bidsReference!.cancelBid(id)\n    }\n\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "retractOfferMarketDirectOfferSoft": {
               "code": "import FindMarket from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\n\ntransaction(marketplace:Address, id: UInt64) {\n    let bidsReference: \u0026FindMarketDirectOfferSoft.MarketBidCollection?\n\n    prepare(account: AuthAccount) {\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n        self.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection\u003e(from: storagePath) \n    }\n\n    pre{\n        self.bidsReference != nil : \"Bid resource does not exist\"\n    }\n\n    execute {\n        self.bidsReference!.cancelBid(id)\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "sendCharity": {
               "code": "import NonFungibleToken from 0xf8d6e0586b0a20c7\nimport CharityNFT from 0xf8d6e0586b0a20c7\n\n//mint an art and add it to a users collection\ntransaction(\n    id: UInt64,\n    recipient: Address\n) {\n    let receiverCap: Capability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e\n    let charityCollection: \u0026NonFungibleToken.Collection\n\n    prepare(account: AuthAccount) {\n        self.charityCollection =account.borrow\u003c\u0026NonFungibleToken.Collection\u003e(from: CharityNFT.CollectionStoragePath)!\n        self.receiverCap= getAccount(recipient).getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath)\n    }\n\n    pre{\n        self.receiverCap.check() : \"Receiver doesn't have receiving vault set up properly.\"\n    }\n\n    execute {\n        let nft \u003c- self.charityCollection.withdraw(withdrawID: id)\n        self.receiverCap.borrow()!.deposit(token: \u003c- nft)\n    }\n}",
               "spec": {
                  "order": [
                     "id",
                     "recipient"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "recipient": "Address"
                  }
               }
            },
            "sendDandy": {
               "code": "import FIND from 0xf8d6e0586b0a20c7\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport Dandy from 0xf8d6e0586b0a20c7\n\ntransaction(user: String, id: UInt64) {\n\n    let address : Address\n    let cap : Capability\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic}\u003e\n    let senderRef : \u0026Dandy.Collection\n\n    prepare(account: AuthAccount) {\n        self.address = FIND.resolve(user) ?? panic(\"Cannot find user with this name / address\")\n        self.cap = getAccount(self.address).getCapability\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n\n        self.senderRef = account.borrow\u003c\u0026Dandy.Collection\u003e(from: Dandy.CollectionStoragePath) ?? panic(\"Cannot borrow reference to sender Collection.\")\n    }\n\n    pre{\n        self.cap.check() : \"Cannot borrow reference to receiver Collection. Receiver account : \".concat(self.address.toString())\n        self.senderRef != nil : \"Cannot borrow reference to sender Collection.\"\n    }\n\n    execute{\n        self.cap.borrow()!.deposit(token: \u003c- self.senderRef!.withdraw(withdrawID: id))\n    }\n}",
               "spec": {
                  "order": [
                     "user",
                     "id"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "user": "String"
                  }
               }
            },
            "sendExampleNFT": {
               "code": "import FIND from 0xf8d6e0586b0a20c7\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport ExampleNFT from 0xf8d6e0586b0a20c7\n\ntransaction(user: String, id: UInt64) {\n    let address : Address\n    let cap : Capability\u003c\u0026ExampleNFT.Collection{NonFungibleToken.CollectionPublic}\u003e\n    let senderRef : \u0026ExampleNFT.Collection\n\n    prepare(account: AuthAccount) {\n        self.address = FIND.resolve(user) ?? panic(\"Cannot find user with this name / address\")\n        self.cap = getAccount(self.address).getCapability\u003c\u0026ExampleNFT.Collection{NonFungibleToken.CollectionPublic}\u003e(ExampleNFT.CollectionPublicPath)\n\n        self.senderRef = account.borrow\u003c\u0026ExampleNFT.Collection\u003e(from: ExampleNFT.CollectionStoragePath) ?? panic(\"Cannot borrow reference to sender Collection.\")\n    }\n\n    pre{\n        self.cap.check() : \"Cannot borrow reference to receiver Collection. Receiver account : \".concat(self.address.toString())\n        self.senderRef != nil : \"Cannot borrow reference to sender Collection.\"\n    }\n\n    execute{\n        self.cap.borrow()!.deposit(token: \u003c- self.senderRef!.withdraw(withdrawID: id))\n    }\n}",
               "spec": {
                  "order": [
                     "user",
                     "id"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "user": "String"
                  }
               }
            },
            "sendFT": {
               "code": "import FungibleToken from 0xee82856bf20e2aa6\nimport Sender from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\nimport FTRegistry from 0xf8d6e0586b0a20c7\n\n\ntransaction(name: String, amount: UFix64, ftAliasOrIdentifier: String, tag: String, message:String) {\n\n    var token : \u0026Sender.Token\n    let walletReference : \u0026FungibleToken.Vault? \n\n    prepare(account: AuthAccount) {\n\n        let ft = FTRegistry.getFTInfo(ftAliasOrIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftAliasOrIdentifier))\n        self.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath)\n\n        if account.borrow\u003c\u0026Sender.Token\u003e(from: Sender.storagePath) == nil {\n            account.save(\u003c- Sender.create(), to: Sender.storagePath)\n        }\n\n        self.token =account.borrow\u003c\u0026Sender.Token\u003e(from: Sender.storagePath)!\n    }\n\n    pre{\n        self.walletReference != nil : \"No suitable wallet linked for this account\"\n    }\n\n    execute{\n        let vault \u003c- self.walletReference!.withdraw(amount: amount)\n        FIND.depositWithTagAndMessage(to: name, message: message, tag: tag, vault: \u003c- vault, from: self.token)\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "amount",
                     "ftAliasOrIdentifier",
                     "tag",
                     "message"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "ftAliasOrIdentifier": "String",
                     "message": "String",
                     "name": "String",
                     "tag": "String"
                  }
               }
            },
            "sendFTWithTag": {
               "code": "import NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FUSD from 0xf8d6e0586b0a20c7\nimport Profile from 0xf8d6e0586b0a20c7\nimport Sender from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\nimport CharityNFT from 0xf8d6e0586b0a20c7\n\n\ntransaction(name: String, amount: UFix64, type: String, tag:String) {\n\n    prepare(account: AuthAccount) {\n\n        let stdCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath)\n        if !stdCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- CharityNFT.createEmptyCollection(), to: CharityNFT.CollectionStoragePath)\n            account.link\u003c\u0026{NonFungibleToken.CollectionPublic, MetadataViews.ResolverCollection}\u003e(CharityNFT.CollectionPublicPath, target: CharityNFT.CollectionStoragePath)\n        }\n\n        let charityCap = account.getCapability\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection)\n        if !charityCap.check() {\n            account.link\u003c\u0026{CharityNFT.CollectionPublic, MetadataViews.ResolverCollection}\u003e(/public/findCharityNFTCollection, target: CharityNFT.CollectionStoragePath)\n        }\n\n      let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n        if !fusdReceiver.check() {\n            let fusd \u003c- FUSD.createEmptyVault()\n            account.save(\u003c- fusd, to: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profileName = account.address.toString()\n\n            let profile \u003c-Profile.createUser(name:profileName, createdAt: \"find\")\n\n            let fusdWallet=Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), names: [\"fusd\", \"stablecoin\"])\n\n            profile.addWallet(fusdWallet)\n\n            let flowWallet=Profile.Wallet(\n                name:\"Flow\", \n                receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver),\n                balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance),\n                accept: Type\u003c@FlowToken.Vault\u003e(),\n                names: [\"flow\"]\n            )\n    \n            profile.addWallet(flowWallet)\n            profile.addCollection(Profile.ResourceCollection(\"FINDLeases\",leaseCollection, Type\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(), [\"find\", \"leases\"]))\n            profile.addCollection(Profile.ResourceCollection(\"FINDBids\", bidCollection, Type\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(), [\"find\", \"bids\"]))\n\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n        }\n\n        if account.borrow\u003c\u0026Sender.Token\u003e(from: Sender.storagePath) == nil {\n            account.save(\u003c- Sender.create(), to: Sender.storagePath)\n        }\n\n        let token =account.borrow\u003c\u0026Sender.Token\u003e(from: Sender.storagePath)!\n\n\n        if type == \"fusd\" {\n            let vaultRef = account.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault) ?? panic(\"Could not borrow reference to the fusdVault!\")\n            let vault \u003c- vaultRef.withdraw(amount: amount)\n            FIND.depositWithTagAndMessage(to: name, message: \"\", tag: tag, vault: \u003c- vault, from: token)\n            return \n        }\n\n        let vaultRef = account.borrow\u003c\u0026FlowToken.Vault\u003e(from: /storage/flowTokenVault) ?? panic(\"Could not borrow reference to the fusdVault!\")\n        let vault \u003c- vaultRef.withdraw(amount: amount)\n        FIND.depositWithTagAndMessage(to: name, message: \"\", tag: tag, vault: \u003c- vault, from: token)\n    }\n\n}",
               "spec": {
                  "order": [
                     "name",
                     "amount",
                     "type",
                     "tag"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "name": "String",
                     "tag": "String",
                     "type": "String"
                  }
               }
            },
            "sendNFTs": {
               "code": "import FINDNFTCatalog from 0xf8d6e0586b0a20c7\nimport NFTCatalog from 0xf8d6e0586b0a20c7\nimport FindViews from 0xf8d6e0586b0a20c7\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport FIND from 0xf8d6e0586b0a20c7\nimport FindLostAndFoundWrapper from 0xf8d6e0586b0a20c7\n\ntransaction(nftIdentifiers: [String], allReceivers: [String] , ids:[UInt64], memos: [String]) {\n\n    let pointers : [FindViews.AuthNFTPointer]\n    let nftInfos : [NFTCatalog.NFTCollectionData]\n    let flowVault : \u0026FungibleToken.Vault\n    let flowTokenRepayment : Capability\u003c\u0026FlowToken.Vault{FungibleToken.Receiver}\u003e\n\n    prepare(account: AuthAccount){\n\n        if allReceivers.length != nftIdentifiers.length || allReceivers.length != ids.length || allReceivers.length != memos.length {\n            panic(\"The length of arrays passed in are not equal\")\n        }\n\n        let pointers : [FindViews.AuthNFTPointer] = []\n        let nftInfos : {String : NFTCatalog.NFTCollectionData} = {}\n        self.nftInfos = []\n        let providerCaps : {String : Capability\u003c\u0026{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e} = {}\n\n\n        for i, id in ids {\n            if nftInfos[nftIdentifiers[i]] == nil {\n                let collections = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifiers[i]) ?? panic(\"NFT type is not supported at the moment. Type : \".concat(nftIdentifiers[i]))\n                nftInfos[nftIdentifiers[i]] = FINDNFTCatalog.getCatalogEntry(collectionIdentifier: collections.keys[0])!.collectionData\n            }\n            self.nftInfos.append(nftInfos[nftIdentifiers[i]]!)\n\n            if providerCaps[nftIdentifiers[i]] == nil {\n                // Initialize the providerCap if the user doesn't have one\n                var providerCap=account.getCapability\u003c\u0026{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e(self.nftInfos[i].privatePath)\n\n                if !providerCap.check() {\n                    let newCap = account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                        self.nftInfos[i].privatePath,\n                        target: self.nftInfos[i].storagePath\n                    )\n                    if newCap == nil {\n                        // If linking is not successful, we link it using finds custom link \n                        let pathIdentifier = self.nftInfos[i].privatePath.toString()\n                        let findPath = PrivatePath(identifier: pathIdentifier.slice(from: \"/private/\".length , upTo: pathIdentifier.length).concat(\"_FIND\"))!\n                        account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                            findPath,\n                            target: self.nftInfos[i].storagePath\n                        )\n                        providerCap = account.getCapability\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(findPath)\n                    }\n                }\n                providerCaps[nftIdentifiers[i]] = providerCap\n            }\n\n            let providerCap = providerCaps[nftIdentifiers[i]]!\n\n            pointers.append(FindViews.AuthNFTPointer(cap: providerCap, id: id))\n        }\n        self.pointers = pointers\n\n        // Get Vault for paying flow storage fee\n        self.flowVault = account.borrow\u003c\u0026FlowToken.Vault\u003e(from: /storage/flowTokenVault) ?? panic(\"Cannot borrow reference to sender's flow vault\")\n        self.flowTokenRepayment = account.getCapability\u003c\u0026FlowToken.Vault{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver) \n    }\n\n    execute{\n\n        for i , receiver in allReceivers {\n            FindLostAndFoundWrapper.depositNFT(\n                receiver: receiver,\n                collectionPublicPath: self.nftInfos[i].publicPath ,\n                item: self.pointers[i],\n                memo: memos[i],\n                storagePayment: self.flowVault,\n                flowTokenRepayment: self.flowTokenRepayment\n            )\n        }\n    \n    }\n\n\n}",
               "spec": {
                  "order": [
                     "nftIdentifiers",
                     "allReceivers",
                     "ids",
                     "memos"
                  ],
                  "parameters": {
                     "allReceivers": "[String]",
                     "ids": "[UInt64]",
                     "memos": "[String]",
                     "nftIdentifiers": "[String]"
                  }
               }
            },
            "setMainName": {
               "code": "import Profile from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\n\n\ntransaction(name: String) {\n\n    let leaseCollectionOwner : Capability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e\n    let profile : \u0026Profile.User\n\n    prepare(acct: AuthAccount) {\n        self.leaseCollectionOwner = acct.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        self.profile =acct.borrow\u003c\u0026Profile.User\u003e(from:Profile.storagePath)!\n    }\n\n    pre{\n        self.leaseCollectionOwner.check() : \"Not a find user\"\n        self.leaseCollectionOwner.borrow()!.getLease(name) != nil : \"You do not own this lease so you cannot set it as main name\"\n    }\n\n    execute{\n        self.profile.setFindName(name)\n    }\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "setMarketOptionFlowDandy": {
               "code": "import FindMarket from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport Dandy from 0xf8d6e0586b0a20c7\n\ntransaction(){\n    prepare(account: AuthAccount){\n        let path = FindMarket.TenantClientStoragePath\n        let tenantRef = account.borrow\u003c\u0026FindMarket.TenantClient\u003e(from: path) ?? panic(\"Cannot borrow Reference.\")\n\n        tenantRef.setMarketOption(name:\"FlowDandy\", cut: nil, rules:[\n            FindMarket.TenantRule(name:\"Flow\", types:[Type\u003c@FlowToken.Vault\u003e()], ruleType: \"ft\", allow: true),\n            FindMarket.TenantRule(name:\"Dandy\", types:[ Type\u003c@Dandy.NFT\u003e()], ruleType: \"nft\", allow: true)\n            ]\n        )\n    }\n}",
               "spec": {
                  "order": [],
                  "parameters": {}
               }
            },
            "setPrivateMode": {
               "code": "import Profile from 0xf8d6e0586b0a20c7\n\ntransaction(mode: Bool) {\n\n    let profile : \u0026Profile.User?\n\n    prepare(acct: AuthAccount) {\n        self.profile =acct.borrow\u003c\u0026Profile.User\u003e(from:Profile.storagePath)\n    }\n\n    pre{\n        self.profile != nil : \"Cannot borrow reference to profile\"\n    }\n\n    execute{\n        self.profile!.setPrivateMode(mode)\n        self.profile!.emitUpdatedEvent()\n    }\n}",
               "spec": {
                  "order": [
                     "mode"
                  ],
                  "parameters": {
                     "mode": "Bool"
                  }
               }
            },
            "setProfile": {
               "code": "import Profile from 0xf8d6e0586b0a20c7\n\ntransaction(avatar: String) {\n\n    let profile : \u0026Profile.User?\n\n    prepare(acct: AuthAccount) {\n        self.profile =acct.borrow\u003c\u0026Profile.User\u003e(from:Profile.storagePath)\n    }\n\n    pre{\n        self.profile != nil : \"Cannot borrow reference to profile\"\n    }\n\n    execute{\n        self.profile!.setAvatar(avatar)\n        self.profile!.emitUpdatedEvent()\n    }\n}",
               "spec": {
                  "order": [
                     "avatar"
                  ],
                  "parameters": {
                     "avatar": "String"
                  }
               }
            },
            "setRelatedAccount": {
               "code": "import RelatedAccounts from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\n\ntransaction(name: String, target: String) {\n\n    var relatedAccounts : \u0026RelatedAccounts.Accounts?\n    let address : Address?\n\n    prepare(account: AuthAccount) {\n\n\n        self.address = FIND.resolve(target)\n\n        self.relatedAccounts= account.borrow\u003c\u0026RelatedAccounts.Accounts\u003e(from:RelatedAccounts.storagePath)\n        if self.relatedAccounts == nil {\n            let relatedAccounts \u003c- RelatedAccounts.createEmptyAccounts()\n            account.save(\u003c- relatedAccounts, to: RelatedAccounts.storagePath)\n            account.link\u003c\u0026RelatedAccounts.Accounts{RelatedAccounts.Public}\u003e(RelatedAccounts.publicPath, target: RelatedAccounts.storagePath)\n            self.relatedAccounts= account.borrow\u003c\u0026RelatedAccounts.Accounts\u003e(from:RelatedAccounts.storagePath)\n        }\n\n        let cap = account.getCapability\u003c\u0026RelatedAccounts.Accounts{RelatedAccounts.Public}\u003e(RelatedAccounts.publicPath)\n        if !cap.check() {\n            account.unlink(RelatedAccounts.publicPath)\n            account.link\u003c\u0026RelatedAccounts.Accounts{RelatedAccounts.Public}\u003e(RelatedAccounts.publicPath, target: RelatedAccounts.storagePath)\n        }\n    }\n\n    pre{\n        self.address != nil : \"The input pass in is not a valid name or address. Input : \".concat(target)\n    }\n\n    execute{\n        self.relatedAccounts!.setFlowAccount(name: name, address: self.address!)\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "target"
                  ],
                  "parameters": {
                     "name": "String",
                     "target": "String"
                  }
               }
            },
            "setSellDandyRules": {
               "code": "import FindMarket from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport FUSD from 0xf8d6e0586b0a20c7\nimport Dandy from 0xf8d6e0586b0a20c7\n\ntransaction(){\n    prepare(account: AuthAccount){\n        let path = FindMarket.TenantClientStoragePath\n        let tenantRef = account.borrow\u003c\u0026FindMarket.TenantClient\u003e(from: path) ?? panic(\"Cannot borrow Reference.\")\n\n        tenantRef.setMarketOption(name:\"FUSDDandy\", cut: nil, rules:[\n            FindMarket.TenantRule(name:\"FUSD\", types:[Type\u003c@FUSD.Vault\u003e()], ruleType: \"ft\", allow: true),\n            FindMarket.TenantRule(name:\"Dandy\", types:[ Type\u003c@Dandy.NFT\u003e()], ruleType: \"nft\", allow: true)\n            ]\n        )\n\n        tenantRef.setMarketOption(name:\"FlowDandy\", cut: nil, rules:[\n            FindMarket.TenantRule(name:\"Flow\", types:[Type\u003c@FlowToken.Vault\u003e()], ruleType: \"ft\", allow: true),\n            FindMarket.TenantRule(name:\"Dandy\", types:[ Type\u003c@Dandy.NFT\u003e()], ruleType: \"nft\", allow: true)\n            ]\n        )\n\n    }\n}",
               "spec": {
                  "order": [],
                  "parameters": {}
               }
            },
            "setTenantRuleFUSD": {
               "code": "import FindMarket from 0xf8d6e0586b0a20c7\nimport FUSD from 0xf8d6e0586b0a20c7\n\ntransaction(optionName: String){\n    prepare(account: AuthAccount){\n        let path = FindMarket.TenantClientStoragePath\n        let tenantRef = account.borrow\u003c\u0026FindMarket.TenantClient\u003e(from: path) ?? panic(\"Cannot borrow Reference.\")\n\n        tenantRef.setTenantRule(optionName: optionName, tenantRule:\n            FindMarket.TenantRule(name:\"FUSD\", types:[Type\u003c@FUSD.Vault\u003e()], ruleType: \"ft\", allow: true)\n        )\n    }\n}",
               "spec": {
                  "order": [
                     "optionName"
                  ],
                  "parameters": {
                     "optionName": "String"
                  }
               }
            },
            "startNameAuction": {
               "code": "import FIND from 0xf8d6e0586b0a20c7\n\ntransaction(name: String) {\n\n    let finLeases : \u0026FIND.LeaseCollection?\n\n    prepare(account: AuthAccount) {\n        self.finLeases= account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)\n    }\n\n    pre{\n        self.finLeases != nil : \"Cannot borrow reference to find lease collection\"\n    }\n\n    execute{\n        self.finLeases!.startAuction(name)\n    }\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "storeCuratedCollections": {
               "code": "transaction(collections: {String :  [String]}) {\n    prepare(account: AuthAccount) {\n\n        let path=/storage/FindCuratedCollections\n        let publicPath=/public/FindCuratedCollections\n\n        if account.borrow\u003c\u0026{String: [String]}\u003e(from:path) != nil {\n             account.load\u003c{String: [String]}\u003e(from:path)\n        }\n        account.save(collections, to: path)\n\n        let link = account.getCapability\u003c\u0026{String: [String]}\u003e(publicPath)\n        if !link.check() {\n            account.link\u003c\u0026{String: [String]}\u003e( publicPath, target: path)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "collections"
                  ],
                  "parameters": {
                     "collections": "{String: [String]}"
                  }
               }
            }
         }
      },
      "mainnet": {
         "scripts": {
            "getAlchemy1IDs": {
               "code": "import MetadataViews from 0x1d7e57aa55817448\nimport FIND from 0x097bafa4e0b48eef\nimport FINDNFTCatalog from 0x097bafa4e0b48eef\n// /* Alchemy Mainnet Wrapper */\nimport AlchemyMetadataWrapperMainnetShard1 from 0xeb8cb4c3157d5dac\n// import AlchemyMetadataWrapperMainnetShard2 from 0xeb8cb4c3157d5dac\n// import AlchemyMetadataWrapperMainnetShard3 from 0xeb8cb4c3157d5dac\n// import AlchemyMetadataWrapperMainnetShard4 from 0xeb8cb4c3157d5dac\n\n// /* Alchemy Testnet Wrapper */\n\n// import AlchemyMetadataWrapperTestnetShard1 from 0x5ff2c7b4c40de11\n// import AlchemyMetadataWrapperTestnetShard2 from 0x5ff2c7b4c40de11\n// import AlchemyMetadataWrapperTestnetShard3 from 0x5ff2c7b4c40de11\n\n\n\n\n    pub fun main(user: String, collections: [String]) : {String : ItemReport}  {\n        return fetchAlchemyShard1(user: user, targetCollections:collections)\n    }\n\n    pub let NFTCatalogContracts : [String] = getNFTCatalogContracts()\n\n    pub struct ItemReport {\n        pub let length : Int // mapping of collection to no. of ids \n        pub let extraIDs : [UInt64]\n        pub let shard : String \n        pub let extraIDsIdentifier : String \n\n        init(length : Int, extraIDs :[UInt64] , shard: String, extraIDsIdentifier: String) {\n            self.length=length \n            self.extraIDs=extraIDs\n            self.shard=shard\n            self.extraIDsIdentifier=extraIDsIdentifier\n        }\n    }\n\n    // Helper function \n\n    pub fun resolveAddress(user: String) : Address? {\n        return FIND.resolve(user)\n    }\n\n    pub fun getNFTCatalogContracts() : [String] {\n        let catalogs = FINDNFTCatalog.getCatalog()\n        let names : [String] = []\n        for catalog in catalogs.values {\n            names.append(catalog.contractName)\n        }\n        return names\n    }\n\n    pub fun fetchAlchemyShard1(user: String, targetCollections: [String]) : {String : ItemReport} {\n        let source = \"Shard1\"\n        let account = resolveAddress(user: user)\n        if account == nil { return {} }\n\n\n        let extraIDs = AlchemyMetadataWrapperMainnetShard1.getNFTIDs(ownerAddress: account!)\n        let inventory : {String : ItemReport} = {}\n        var fetchedCount : Int = 0\n\n        for project in extraIDs.keys {\n\n            if extraIDs[project]! == nil || extraIDs[project]!.length \u003c 1{\n                extraIDs.remove(key: project)\n                continue\n            }\n            \n            let collectionLength = extraIDs[project]!.length\n\n            // by pass if this is not the target collection\n            if targetCollections.length \u003e 0 \u0026\u0026 !targetCollections.contains(project) {\n                // inventory[project] = ItemReport(items: [],  length : collectionLength, extraIDs :extraIDs[project]! , shard: source)\n                continue\n            }\n\n            let contractItem = AlchemyMetadataWrapperMainnetShard1.getNFTs(ownerAddress: account!, ids: {project : [extraIDs[project]![0]]})\n            if contractItem.length \u003e 0 \u0026\u0026 contractItem[0] != nil {\n                if NFTCatalogContracts.contains(contractItem[0]!.contract.name) {\n                    continue\n                }\n            }\n\n            inventory[project] = ItemReport(length : collectionLength, extraIDs :extraIDs[project] ?? [] , shard: source, extraIDsIdentifier: project)\n\n        }\n\n        return inventory\n\n    }",
               "spec": {
                  "order": [
                     "user",
                     "collections"
                  ],
                  "parameters": {
                     "collections": "[String]",
                     "user": "String"
                  }
               }
            },
            "getAlchemy1Items": {
               "code": "import MetadataViews from 0x1d7e57aa55817448\nimport FIND from 0x097bafa4e0b48eef\n\n// /* Alchemy Mainnet Wrapper */\nimport AlchemyMetadataWrapperMainnetShard1 from 0xeb8cb4c3157d5dac\n// import AlchemyMetadataWrapperMainnetShard2 from 0xeb8cb4c3157d5dac\n// import AlchemyMetadataWrapperMainnetShard3 from 0xeb8cb4c3157d5dac\n// import AlchemyMetadataWrapperMainnetShard4 from 0xeb8cb4c3157d5dac\n\n// /* Alchemy Testnet Wrapper */\n\n// import AlchemyMetadataWrapperTestnetShard1 from 0x5ff2c7b4c40de11\n// import AlchemyMetadataWrapperTestnetShard2 from 0x5ff2c7b4c40de11\n// import AlchemyMetadataWrapperTestnetShard3 from 0x5ff2c7b4c40de11\n\npub fun main(user: String, collectionIDs: {String : [UInt64]}) : {String : [MetadataCollectionItem]} {\n    return fetchAlchemyCollectionShard1(user: user, collectionIDs: collectionIDs)\n}\n\n    pub struct CollectionReport {\n        pub let items : {String : [MetadataCollectionItem]} \n        pub let collections : {String : Int} // mapping of collection to no. of ids \n        pub let extraIDs : {String : [UInt64]} \n\n        init(items: {String : [MetadataCollectionItem]},  collections : {String : Int}, extraIDs : {String : [UInt64]} ) {\n            self.items=items \n            self.collections=collections \n            self.extraIDs=extraIDs\n        }\n    }\n\n    pub struct MetadataCollectionItem {\n        pub let id:UInt64\n        pub let name: String\n        pub let collection: String // \u003c- This will be Alias unless they want something else\n        pub let subCollection: String? // \u003c- This will be Alias unless they want something else\n        pub let nftDetailIdentifier: String\n\n        pub let media  : String\n        pub let mediaType : String \n        pub let source : String \n\n        init(id:UInt64, name: String, collection: String, subCollection: String?, media  : String, mediaType : String, source : String, nftDetailIdentifier: String) {\n            self.id=id\n            self.name=name \n            self.collection=collection \n            self.subCollection=subCollection \n            self.media=media \n            self.mediaType=mediaType \n            self.source=source\n            self.nftDetailIdentifier=nftDetailIdentifier\n        }\n    }\n\n    // Helper function \n\n    pub fun resolveAddress(user: String) : PublicAccount? {\n        let address = FIND.resolve(user)\n        if address == nil {\n            return nil\n        }\n        return getAccount(address!)\n    }\n\n        \n    //////////////////////////////////////////////////////////////\n    // Fetch Specific Collections in Shard 1\n    //////////////////////////////////////////////////////////////\n    pub fun fetchAlchemyCollectionShard1(user: String, collectionIDs: {String : [UInt64]}) : {String : [MetadataCollectionItem]} {\n        let source = \"Shard1\"\n        let account = resolveAddress(user: user)\n        if account == nil { return {} }\n        if account!.balance == 0.0 {\n            return {}\n        }\n\n        let items : {String : [MetadataCollectionItem]} = {}\n        \n        let fetchingIDs = collectionIDs\n\n        for project in fetchingIDs.keys {\n            // For passing bugs\n            if project == \"Xtingles_NFT\" {\n                fetchingIDs[\"Xtingles\"] = fetchingIDs.remove(key: project)\n            }\n\n            if project == \"RCRDSHPNFT\" {\n                fetchingIDs.remove(key: project)\n            }\n        }\n\n        for project in fetchingIDs.keys {\n            let returnedNFTs = AlchemyMetadataWrapperMainnetShard1.getNFTs(ownerAddress: account!.address, ids: {project : fetchingIDs[project]!})\n\n            var collectionItems : [MetadataCollectionItem] = []\n            for nft in returnedNFTs {\n                if nft == nil {\n                    continue\n                }\n\n                var media = \"\"\n                var mediaType = \"\"\n                if nft!.media.length \u003e 0 \u0026\u0026 nft!.media[0]?.uri != nil {\n                    let m = nft!.media[0]!\n                    mediaType = m.mimetype ?? \"\"\n                    media = m.uri!\n                }\n\n                let item = MetadataCollectionItem(\n                    id: nft!.id,\n                    name: nft!.title ?? \"\",\n                    collection: project,\n                    subCollection: nil, \n                    media: media,\n                    mediaType: mediaType,\n                    source: source, \n                    nftDetailIdentifier: project \n                )\n                collectionItems.append(item)\n            }\n\n            if collectionItems.length \u003e 0 {\n                items[project] = collectionItems\n            }\n        }\n        return items\n    }",
               "spec": {
                  "order": [
                     "user",
                     "collectionIDs"
                  ],
                  "parameters": {
                     "collectionIDs": "{String: [UInt64]}",
                     "user": "String"
                  }
               }
            },
            "getAlchemy2IDs": {
               "code": "import MetadataViews from 0x1d7e57aa55817448\nimport FIND from 0x097bafa4e0b48eef\nimport FINDNFTCatalog from 0x097bafa4e0b48eef\n// /* Alchemy Mainnet Wrapper */\n// import AlchemyMetadataWrapperMainnetShard1 from 0xeb8cb4c3157d5dac\nimport AlchemyMetadataWrapperMainnetShard2 from 0xeb8cb4c3157d5dac\n// import AlchemyMetadataWrapperMainnetShard3 from 0xeb8cb4c3157d5dac\n// import AlchemyMetadataWrapperMainnetShard4 from 0xeb8cb4c3157d5dac\n\n// /* Alchemy Testnet Wrapper */\n\n// import AlchemyMetadataWrapperTestnetShard1 from 0x5ff2c7b4c40de11\n// import AlchemyMetadataWrapperTestnetShard2 from 0x5ff2c7b4c40de11\n// import AlchemyMetadataWrapperTestnetShard3 from 0x5ff2c7b4c40de11\n\n\n\n\n    pub fun main(user: String, collections: [String]) : {String : ItemReport} {\n        return fetchAlchemyShard2(user: user, targetCollections:collections)\n    }\n\n    pub let NFTCatalogContracts : [String] = getNFTCatalogContracts()\n\n    pub struct ItemReport {\n        pub let length : Int // mapping of collection to no. of ids \n        pub let extraIDs : [UInt64]\n        pub let shard : String \n        pub let extraIDsIdentifier : String \n\n        init(length : Int, extraIDs :[UInt64] , shard: String, extraIDsIdentifier: String) {\n            self.length=length \n            self.extraIDs=extraIDs\n            self.shard=shard\n            self.extraIDsIdentifier=extraIDsIdentifier\n        }\n    }\n\n    // Helper function \n\n    pub fun resolveAddress(user: String) : Address? {\n        return FIND.resolve(user)\n    }\n\n    pub fun getNFTCatalogContracts() : [String] {\n        let catalogs = FINDNFTCatalog.getCatalog()\n        let names : [String] = []\n        for catalog in catalogs.values {\n            names.append(catalog.contractName)\n        }\n        return names\n    }\n\n    pub fun fetchAlchemyShard2(user: String, targetCollections: [String]) : {String : ItemReport} {\n        let source = \"Shard2\"\n        let account = resolveAddress(user: user)\n        if account == nil { return {} }\n\n\n        let extraIDs = AlchemyMetadataWrapperMainnetShard2.getNFTIDs(ownerAddress: account!)\n        let inventory : {String : ItemReport} = {}\n        var fetchedCount : Int = 0\n\n        for project in extraIDs.keys {\n            if extraIDs[project]! == nil || extraIDs[project]!.length \u003c 1{\n                extraIDs.remove(key: project)\n                continue\n            }\n            \n            let collectionLength = extraIDs[project]!.length\n\n            // by pass if this is not the target collection\n            if targetCollections.length \u003e 0 \u0026\u0026 !targetCollections.contains(project) {\n                // inventory[project] = ItemReport(items: [],  length : collectionLength, extraIDs :extraIDs[project]! , shard: source)\n                continue\n            }\n\n            let contractItem = AlchemyMetadataWrapperMainnetShard2.getNFTs(ownerAddress: account!, ids: {rename(project) : [extraIDs[project]![0]]})\n            if contractItem.length \u003e 0 \u0026\u0026 contractItem[0] != nil {\n                if NFTCatalogContracts.contains(contractItem[0]!.contract.name) {\n                    continue\n                }\n            }\n            \n            inventory[project] = ItemReport(length : collectionLength, extraIDs :extraIDs[project] ?? [] , shard: source, extraIDsIdentifier: project)\n\n        }\n\n        return inventory\n\n    }\n\n    pub fun rename(_ name: String) : String {\n\n            let mslength = \"MintStoreItem\".length\n            \n            if name.length \u003e mslength  \u0026\u0026 name.slice(from: 0, upTo: mslength) == \"MintStoreItem\" {\n        return \"MintStoreItem\"\n      }\n      return name\n    }",
               "spec": {
                  "order": [
                     "user",
                     "collections"
                  ],
                  "parameters": {
                     "collections": "[String]",
                     "user": "String"
                  }
               }
            },
            "getAlchemy2Items": {
               "code": "import MetadataViews from 0x1d7e57aa55817448\nimport FIND from 0x097bafa4e0b48eef\n\n// /* Alchemy Mainnet Wrapper */\n// import AlchemyMetadataWrapperMainnetShard1 from 0xeb8cb4c3157d5dac\nimport AlchemyMetadataWrapperMainnetShard2 from 0xeb8cb4c3157d5dac\n// import AlchemyMetadataWrapperMainnetShard3 from 0xeb8cb4c3157d5dac\n// import AlchemyMetadataWrapperMainnetShard4 from 0xeb8cb4c3157d5dac\n\n// /* Alchemy Testnet Wrapper */\n\n// import AlchemyMetadataWrapperTestnetShard1 from 0x5ff2c7b4c40de11\n// import AlchemyMetadataWrapperTestnetShard2 from 0x5ff2c7b4c40de11\n// import AlchemyMetadataWrapperTestnetShard3 from 0x5ff2c7b4c40de11\n\npub fun main(user: String, collectionIDs: {String : [UInt64]}) : {String : [MetadataCollectionItem]} {\n    return fetchAlchemyCollectionShard2(user: user, collectionIDs: collectionIDs)\n}\n\n    pub struct CollectionReport {\n        pub let items : {String : [MetadataCollectionItem]} \n        pub let collections : {String : Int} // mapping of collection to no. of ids \n        pub let extraIDs : {String : [UInt64]} \n\n        init(items: {String : [MetadataCollectionItem]},  collections : {String : Int}, extraIDs : {String : [UInt64]} ) {\n            self.items=items \n            self.collections=collections \n            self.extraIDs=extraIDs\n        }\n    }\n\n    pub struct MetadataCollectionItem {\n        pub let id:UInt64\n        pub let name: String\n        pub let collection: String // \u003c- This will be Alias unless they want something else\n        pub let subCollection: String? // \u003c- This will be Alias unless they want something else\n        pub let nftDetailIdentifier: String\n\n        pub let media  : String\n        pub let mediaType : String \n        pub let source : String \n\n        init(id:UInt64, name: String, collection: String, subCollection: String?, media  : String, mediaType : String, source : String, nftDetailIdentifier: String) {\n            self.id=id\n            self.name=name \n            self.collection=collection \n            self.subCollection=subCollection \n            self.media=media \n            self.mediaType=mediaType \n            self.source=source\n            self.nftDetailIdentifier=nftDetailIdentifier\n        }\n    }\n\n    // Helper function \n\n    pub fun resolveAddress(user: String) : PublicAccount? {\n        let address = FIND.resolve(user)\n        if address == nil {\n            return nil\n        }\n        return getAccount(address!)\n    }\n\n\n    ////////////////////////////////////////////////////////////\n    // Fetch Specific Collections in Shard 2\n    ////////////////////////////////////////////////////////////\n    pub fun fetchAlchemyCollectionShard2(user: String, collectionIDs: {String : [UInt64]}) : {String : [MetadataCollectionItem]} {\n        let source = \"Shard2\"\n        let account = resolveAddress(user: user)\n        if account == nil { return {} }\n        if account!.balance == 0.0 {\n            return {}\n        }\n\n        let items : {String : [MetadataCollectionItem]} = {}\n        \n        let fetchingIDs = collectionIDs\n\n        for project in fetchingIDs.keys {\n            // For passing bugs\n            if project == \"Xtingles_NFT\" {\n                fetchingIDs[\"Xtingles\"] = fetchingIDs.remove(key: project)\n            }\n\n            if project == \"RCRDSHPNFT\" {\n                fetchingIDs.remove(key: project)\n            }\n        }\n\n        for project in fetchingIDs.keys {\n            let returnedNFTs = AlchemyMetadataWrapperMainnetShard2.getNFTs(ownerAddress: account!.address, ids: {rename(project) : fetchingIDs[project]!})\n\n            var collectionItems : [MetadataCollectionItem] = []\n            for nft in returnedNFTs {\n                if nft == nil {\n                    continue\n                }\n\n                var media = \"\"\n                var mediaType = \"\"\n                if nft!.media.length \u003e 0 \u0026\u0026 nft!.media[0]?.uri != nil {\n                    let m = nft!.media[0]!\n                    mediaType = m.mimetype ?? \"\"\n                    media = m.uri!\n                }\n\n                let item = MetadataCollectionItem(\n                    id: nft!.id,\n                    name: nft!.title ?? \"\",\n                    collection: project,\n                    subCollection: nil, \n                    media: media,\n                    mediaType: mediaType,\n                    source: source, \n                    nftDetailIdentifier: project \n                )\n                collectionItems.append(item)\n            }\n\n            if collectionItems.length \u003e 0 {\n                items[project] = collectionItems\n            }\n        }\n        return items\n    }\n\n\n    pub fun rename(_ name: String) : String {\n\n            let mslength = \"MintStoreItem\".length\n            \n            if name.length \u003e mslength  \u0026\u0026 name.slice(from: 0, upTo: mslength) == \"MintStoreItem\" {\n        return \"MintStoreItem\"\n      }\n      return name\n    }",
               "spec": {
                  "order": [
                     "user",
                     "collectionIDs"
                  ],
                  "parameters": {
                     "collectionIDs": "{String: [UInt64]}",
                     "user": "String"
                  }
               }
            },
            "getAlchemy3IDs": {
               "code": "import MetadataViews from 0x1d7e57aa55817448\nimport FIND from 0x097bafa4e0b48eef\nimport FINDNFTCatalog from 0x097bafa4e0b48eef\n// /* Alchemy Mainnet Wrapper */\n// import AlchemyMetadataWrapperMainnetShard1 from 0xeb8cb4c3157d5dac\n// import AlchemyMetadataWrapperMainnetShard2 from 0xeb8cb4c3157d5dac\nimport AlchemyMetadataWrapperMainnetShard3 from 0xeb8cb4c3157d5dac\n// import AlchemyMetadataWrapperMainnetShard4 from 0xeb8cb4c3157d5dac\n\n// /* Alchemy Testnet Wrapper */\n\n// import AlchemyMetadataWrapperTestnetShard1 from 0x5ff2c7b4c40de11\n// import AlchemyMetadataWrapperTestnetShard2 from 0x5ff2c7b4c40de11\n// import AlchemyMetadataWrapperTestnetShard3 from 0x5ff2c7b4c40de11\n\n    pub fun main(user: String, collections: [String]) : {String : ItemReport} {\n        return fetchAlchemyShard3(user: user, targetCollections:collections)\n    }\n\n    pub let NFTCatalogContracts : [String] = getNFTCatalogContracts()\n\n    pub struct ItemReport {\n        pub let length : Int // mapping of collection to no. of ids \n        pub let extraIDs : [UInt64]\n        pub let shard : String \n        pub let extraIDsIdentifier : String \n\n        init(length : Int, extraIDs :[UInt64] , shard: String, extraIDsIdentifier: String) {\n            self.length=length \n            self.extraIDs=extraIDs\n            self.shard=shard\n            self.extraIDsIdentifier=extraIDsIdentifier\n        }\n    }\n\n    // Helper function \n\n    pub fun resolveAddress(user: String) : Address? {\n        return FIND.resolve(user)\n    }\n\n    pub fun getNFTCatalogContracts() : [String] {\n        let catalogs = FINDNFTCatalog.getCatalog()\n        let names : [String] = []\n        for catalog in catalogs.values {\n            names.append(catalog.contractName)\n        }\n        return names\n    }\n            \n    pub fun fetchAlchemyShard3(user: String, targetCollections: [String]) : {String : ItemReport} {\n        let source = \"Shard3\"\n        let account = resolveAddress(user: user)\n        if account == nil { return {} }\n\n\n        let extraIDs = AlchemyMetadataWrapperMainnetShard3.getNFTIDs(ownerAddress: account!)\n        let inventory : {String : ItemReport} = {}\n        var fetchedCount : Int = 0\n\n        for project in extraIDs.keys {\n            if extraIDs[project]! == nil || extraIDs[project]!.length \u003c 1{\n                extraIDs.remove(key: project)\n                continue\n            }\n            \n            let collectionLength = extraIDs[project]!.length\n\n            // by pass if this is not the target collection\n            if targetCollections.length \u003e 0 \u0026\u0026 !targetCollections.contains(project) {\n                // inventory[project] = ItemReport(items: [],  length : collectionLength, extraIDs :extraIDs[project]! , shard: source)\n                continue\n            }\n\n            let contractItem = AlchemyMetadataWrapperMainnetShard3.getNFTs(ownerAddress: account!, ids: {project : [extraIDs[project]![0]]})\n            if contractItem.length \u003e 0 \u0026\u0026 contractItem[0] != nil {\n                if NFTCatalogContracts.contains(contractItem[0]!.contract.name) {\n                    continue\n                }\n            }\n\n            inventory[project] = ItemReport(length : collectionLength, extraIDs :extraIDs[project] ?? [] , shard: source, extraIDsIdentifier: project)\n\n        }\n\n        return inventory\n\n    }",
               "spec": {
                  "order": [
                     "user",
                     "collections"
                  ],
                  "parameters": {
                     "collections": "[String]",
                     "user": "String"
                  }
               }
            },
            "getAlchemy3Items": {
               "code": "import MetadataViews from 0x1d7e57aa55817448\nimport FIND from 0x097bafa4e0b48eef\n\n// /* Alchemy Mainnet Wrapper */\n// import AlchemyMetadataWrapperMainnetShard1 from 0xeb8cb4c3157d5dac\n// import AlchemyMetadataWrapperMainnetShard2 from 0xeb8cb4c3157d5dac\nimport AlchemyMetadataWrapperMainnetShard3 from 0xeb8cb4c3157d5dac\n// import AlchemyMetadataWrapperMainnetShard4 from 0xeb8cb4c3157d5dac\n\n// /* Alchemy Testnet Wrapper */\n\n// import AlchemyMetadataWrapperTestnetShard1 from 0x5ff2c7b4c40de11\n// import AlchemyMetadataWrapperTestnetShard2 from 0x5ff2c7b4c40de11\n// import AlchemyMetadataWrapperTestnetShard3 from 0x5ff2c7b4c40de11\n\npub fun main(user: String, collectionIDs: {String : [UInt64]}) : {String : [MetadataCollectionItem]} {\n    return fetchAlchemyCollectionShard3(user: user, collectionIDs: collectionIDs)\n}\n\n    pub struct CollectionReport {\n        pub let items : {String : [MetadataCollectionItem]} \n        pub let collections : {String : Int} // mapping of collection to no. of ids \n        pub let extraIDs : {String : [UInt64]} \n\n        init(items: {String : [MetadataCollectionItem]},  collections : {String : Int}, extraIDs : {String : [UInt64]} ) {\n            self.items=items \n            self.collections=collections \n            self.extraIDs=extraIDs\n        }\n    }\n\n    pub struct MetadataCollectionItem {\n        pub let id:UInt64\n        pub let name: String\n        pub let collection: String // \u003c- This will be Alias unless they want something else\n        pub let subCollection: String? // \u003c- This will be Alias unless they want something else\n        pub let nftDetailIdentifier: String\n\n        pub let media  : String\n        pub let mediaType : String \n        pub let source : String \n\n        init(id:UInt64, name: String, collection: String, subCollection: String?, media  : String, mediaType : String, source : String, nftDetailIdentifier: String) {\n            self.id=id\n            self.name=name \n            self.collection=collection \n            self.subCollection=subCollection \n            self.media=media \n            self.mediaType=mediaType \n            self.source=source\n            self.nftDetailIdentifier=nftDetailIdentifier\n        }\n    }\n\n    // Helper function \n\n    pub fun resolveAddress(user: String) : PublicAccount? {\n        let address = FIND.resolve(user)\n        if address == nil {\n            return nil\n        }\n        return getAccount(address!)\n    }\n\n\n    //////////////////////////////////////////////////////////////\n    // Fetch Specific Collections in Shard 3\n    //////////////////////////////////////////////////////////////\n    pub fun fetchAlchemyCollectionShard3(user: String, collectionIDs: {String : [UInt64]}) : {String : [MetadataCollectionItem]} {\n        let source = \"Shard3\"\n        let account = resolveAddress(user: user)\n        if account == nil { return {} }\n        if account!.balance == 0.0 {\n            return {}\n        }\n        \n        let items : {String : [MetadataCollectionItem]} = {}\n        \n        let fetchingIDs = collectionIDs\n\n        for project in fetchingIDs.keys {\n            // For passing bugs\n            if project == \"Xtingles_NFT\" {\n                fetchingIDs[\"Xtingles\"] = fetchingIDs.remove(key: project)\n            }\n\n            if project == \"RCRDSHPNFT\" {\n                fetchingIDs.remove(key: project)\n            }\n        }\n\n        for project in fetchingIDs.keys {\n            let returnedNFTs = AlchemyMetadataWrapperMainnetShard3.getNFTs(ownerAddress: account!.address, ids: {project : fetchingIDs[project]!})\n\n            var collectionItems : [MetadataCollectionItem] = []\n            for nft in returnedNFTs {\n                if nft == nil {\n                    continue\n                }\n\n                var media = \"\"\n                var mediaType = \"\"\n                if nft!.media.length \u003e 0 \u0026\u0026 nft!.media[0]?.uri != nil {\n                    let m = nft!.media[0]!\n                    mediaType = m.mimetype ?? \"\"\n                    media = m.uri!\n                }\n\n                let item = MetadataCollectionItem(\n                    id: nft!.id,\n                    name: nft!.title ?? \"\",\n                    collection: project,\n                    subCollection: nil, \n                    media: media,\n                    mediaType: mediaType,\n                    source: source, \n                    nftDetailIdentifier: project \n                )\n                collectionItems.append(item)\n            }\n\n            if collectionItems.length \u003e 0 {\n                items[project] = collectionItems\n            }\n        }\n        return items\n    }",
               "spec": {
                  "order": [
                     "user",
                     "collectionIDs"
                  ],
                  "parameters": {
                     "collectionIDs": "{String: [UInt64]}",
                     "user": "String"
                  }
               }
            },
            "getAlchemy4IDs": {
               "code": "import MetadataViews from 0x1d7e57aa55817448\nimport FIND from 0x097bafa4e0b48eef\nimport FINDNFTCatalog from 0x097bafa4e0b48eef\n// /* Alchemy Mainnet Wrapper */\n// import AlchemyMetadataWrapperMainnetShard1 from 0xeb8cb4c3157d5dac\n// import AlchemyMetadataWrapperMainnetShard2 from 0xeb8cb4c3157d5dac\n// import AlchemyMetadataWrapperMainnetShard3 from 0xeb8cb4c3157d5dac\nimport AlchemyMetadataWrapperMainnetShard4 from 0xeb8cb4c3157d5dac\n\n// /* Alchemy Testnet Wrapper */\n\n// import AlchemyMetadataWrapperTestnetShard1 from 0x5ff2c7b4c40de11\n// import AlchemyMetadataWrapperTestnetShard2 from 0x5ff2c7b4c40de11\n// import AlchemyMetadataWrapperTestnetShard3 from 0x5ff2c7b4c40de11\n\n    pub fun main(user: String, collections: [String]) : {String : ItemReport}  {\n        return fetchAlchemyShard4(user: user, targetCollections:collections)\n    }\n\n    pub let NFTCatalogContracts : [String] = getNFTCatalogContracts()\n\n    pub struct ItemReport {\n        pub let length : Int // mapping of collection to no. of ids \n        pub let extraIDs : [UInt64]\n        pub let shard : String \n        pub let extraIDsIdentifier : String \n\n        init(length : Int, extraIDs :[UInt64] , shard: String, extraIDsIdentifier: String) {\n            self.length=length \n            self.extraIDs=extraIDs\n            self.shard=shard\n            self.extraIDsIdentifier=extraIDsIdentifier\n        }\n    }\n\n    // Helper function \n\n    pub fun resolveAddress(user: String) : Address? {\n        return FIND.resolve(user)\n    }\n\n    pub fun getNFTCatalogContracts() : [String] {\n        let catalogs = FINDNFTCatalog.getCatalog()\n        let names : [String] = []\n        for catalog in catalogs.values {\n            names.append(catalog.contractName)\n        }\n        return names\n    }\n\n    pub fun fetchAlchemyShard4(user: String, targetCollections: [String]) : {String : ItemReport} {\n        let source = \"Shard4\"\n        let account = resolveAddress(user: user)\n        if account == nil { return {} }\n\n\n        let extraIDs = AlchemyMetadataWrapperMainnetShard4.getNFTIDs(ownerAddress: account!)\n        let inventory : {String : ItemReport} = {}\n        var fetchedCount : Int = 0\n\n        // For by-passing bugs\n\n        if extraIDs[\"MintStoreItem.NBA ALL STAR \"] != nil { // who the hell put a space at the end of the string\n            extraIDs[\"MintStoreItem\"] = extraIDs.remove(key: \"MintStoreItem.NBA ALL STAR \")\n        }\n\n\n        for project in extraIDs.keys {\n            if extraIDs[project]! == nil || extraIDs[project]!.length \u003c 1{\n                extraIDs.remove(key: project)\n                continue\n            }\n\n            if project == \"RCRDSHPNFT\" {\n                continue\n            }\n            \n            let collectionLength = extraIDs[project]!.length\n\n            // by pass if this is not the target collection\n            if targetCollections.length \u003e 0 \u0026\u0026 !targetCollections.contains(project) {\n                // inventory[project] = ItemReport(items: [],  length : collectionLength, extraIDs :extraIDs[project]! , shard: source)\n                continue\n            }\n\n           let contractItem = AlchemyMetadataWrapperMainnetShard4.getNFTs(ownerAddress: account!, ids: {project : [extraIDs[project]![0]]})\n            if contractItem.length \u003e 0 \u0026\u0026 contractItem[0] != nil {\n                if NFTCatalogContracts.contains(contractItem[0]!.contract.name) {\n                    continue\n                }\n            }\n\n            inventory[project] = ItemReport(length : collectionLength, extraIDs :extraIDs[project] ?? [] , shard: source, extraIDsIdentifier: project)\n\n        }\n\n        return inventory\n\n    }",
               "spec": {
                  "order": [
                     "user",
                     "collections"
                  ],
                  "parameters": {
                     "collections": "[String]",
                     "user": "String"
                  }
               }
            },
            "getAlchemy4Items": {
               "code": "import MetadataViews from 0x1d7e57aa55817448\nimport FIND from 0x097bafa4e0b48eef\n\n// /* Alchemy Mainnet Wrapper */\n// import AlchemyMetadataWrapperMainnetShard1 from 0xeb8cb4c3157d5dac\n// import AlchemyMetadataWrapperMainnetShard2 from 0xeb8cb4c3157d5dac\n// import AlchemyMetadataWrapperMainnetShard3 from 0xeb8cb4c3157d5dac\nimport AlchemyMetadataWrapperMainnetShard4 from 0xeb8cb4c3157d5dac\n\n// /* Alchemy Testnet Wrapper */\n\n// import AlchemyMetadataWrapperTestnetShard1 from 0x5ff2c7b4c40de11\n// import AlchemyMetadataWrapperTestnetShard2 from 0x5ff2c7b4c40de11\n// import AlchemyMetadataWrapperTestnetShard3 from 0x5ff2c7b4c40de11\n\npub fun main(user: String, collectionIDs: {String : [UInt64]}) : {String : [MetadataCollectionItem]} {\n    return fetchAlchemyCollectionShard4(user: user, collectionIDs: collectionIDs)\n}\n\n    pub struct CollectionReport {\n        pub let items : {String : [MetadataCollectionItem]} \n        pub let collections : {String : Int} // mapping of collection to no. of ids \n        pub let extraIDs : {String : [UInt64]} \n\n        init(items: {String : [MetadataCollectionItem]},  collections : {String : Int}, extraIDs : {String : [UInt64]} ) {\n            self.items=items \n            self.collections=collections \n            self.extraIDs=extraIDs\n        }\n    }\n\n    pub struct MetadataCollectionItem {\n        pub let id:UInt64\n        pub let name: String\n        pub let collection: String // \u003c- This will be Alias unless they want something else\n        pub let subCollection: String? // \u003c- This will be Alias unless they want something else\n        pub let nftDetailIdentifier: String\n\n        pub let media  : String\n        pub let mediaType : String \n        pub let source : String \n\n        init(id:UInt64, name: String, collection: String, subCollection: String?, media  : String, mediaType : String, source : String, nftDetailIdentifier: String) {\n            self.id=id\n            self.name=name \n            self.collection=collection \n            self.subCollection=subCollection \n            self.media=media \n            self.mediaType=mediaType \n            self.source=source\n            self.nftDetailIdentifier=nftDetailIdentifier\n        }\n    }\n\n    // Helper function \n\n    pub fun resolveAddress(user: String) : PublicAccount? {\n        let address = FIND.resolve(user)\n        if address == nil {\n            return nil\n        }\n        return getAccount(address!)\n    }\n\n        \n    //////////////////////////////////////////////////////////////\n    // Fetch Specific Collections in Shard 4\n    //////////////////////////////////////////////////////////////\n    pub fun fetchAlchemyCollectionShard4(user: String, collectionIDs: {String : [UInt64]}) : {String : [MetadataCollectionItem]} {\n        let source = \"Shard4\"\n        let account = resolveAddress(user: user)\n        if account == nil { return {} }\n        if account!.balance == 0.0 {\n            return {}\n        }\n        \n        let items : {String : [MetadataCollectionItem]} = {}\n        \n        let fetchingIDs = collectionIDs\n\n        for project in fetchingIDs.keys {\n            // For passing bugs\n            if project == \"Xtingles_NFT\" {\n                fetchingIDs[\"Xtingles\"] = fetchingIDs.remove(key: project)\n            }\n\n            if project == \"RCRDSHPNFT\" {\n                fetchingIDs.remove(key: project)\n            }\n        }\n\n        for project in fetchingIDs.keys {\n            let returnedNFTs = AlchemyMetadataWrapperMainnetShard4.getNFTs(ownerAddress: account!.address, ids: {project : fetchingIDs[project]!})\n\n            var collectionItems : [MetadataCollectionItem] = []\n            for nft in returnedNFTs {\n                if nft == nil {\n                    continue\n                }\n\n                var media = \"\"\n                var mediaType = \"\"\n                if nft!.media.length \u003e 0 \u0026\u0026 nft!.media[0]?.uri != nil {\n                    let m = nft!.media[0]!\n                    mediaType = m.mimetype ?? \"\"\n                    media = m.uri!\n                }\n\n                let item = MetadataCollectionItem(\n                    id: nft!.id,\n                    name: nft!.title ?? \"\",\n                    collection: project,\n                    subCollection: nil, \n                    media: media,\n                    mediaType: mediaType,\n                    source: source, \n                    nftDetailIdentifier: project \n                )\n                collectionItems.append(item)\n            }\n\n            if collectionItems.length \u003e 0 {\n                items[project] = collectionItems\n            }\n        }\n        return items\n    }",
               "spec": {
                  "order": [
                     "user",
                     "collectionIDs"
                  ],
                  "parameters": {
                     "collectionIDs": "{String: [UInt64]}",
                     "user": "String"
                  }
               }
            },
            "getCatalog": {
               "code": "import NFTCatalog from 0x49a7cda3a1eecc29\nimport FINDNFTCatalog from 0x097bafa4e0b48eef\n\npub fun main() : {String : NFTCatalog.NFTCatalogMetadata} {\n    return FINDNFTCatalog.getCatalog() \n}",
               "spec": {
                  "order": [],
                  "parameters": {}
               }
            },
            "getCatalogCollectionDisplay": {
               "code": "import MetadataViews from 0x1d7e57aa55817448\nimport NFTCatalog from 0x49a7cda3a1eecc29\nimport FINDNFTCatalog from 0x097bafa4e0b48eef\n\npub fun main(collectionIdentifier : String) : NFTCatalogMetadata? {\n    if let catalog = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier) {\n        return NFTCatalogMetadata(\n            contractName : catalog.contractName, \n            contractAddress : catalog.contractAddress, \n            nftType: catalog.nftType, \n            collectionDisplay : catalog.collectionDisplay\n        )\n    }\n    return nil\n}\n\npub struct NFTCatalogMetadata {\n    pub let contractName : String\n    pub let contractAddress : Address\n    pub let nftType: String\n    pub let collectionDisplay: MetadataViews.NFTCollectionDisplay\n\n    init (contractName : String, contractAddress : Address, nftType: Type, collectionDisplay : MetadataViews.NFTCollectionDisplay) {\n        self.contractName = contractName\n        self.contractAddress = contractAddress\n        self.nftType = nftType.identifier\n        self.collectionDisplay = collectionDisplay\n    }\n}",
               "spec": {
                  "order": [
                     "collectionIdentifier"
                  ],
                  "parameters": {
                     "collectionIdentifier": "String"
                  }
               }
            },
            "getCatalogEntry": {
               "code": "import NFTCatalog from 0x49a7cda3a1eecc29\nimport FINDNFTCatalog from 0x097bafa4e0b48eef\n\npub fun main(collectionIdentifier : String) : NFTCatalog.NFTCatalogMetadata? {\n    return FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier) \n}",
               "spec": {
                  "order": [
                     "collectionIdentifier"
                  ],
                  "parameters": {
                     "collectionIdentifier": "String"
                  }
               }
            },
            "getCatalogTypeData": {
               "code": "import NFTCatalog from 0x49a7cda3a1eecc29\nimport FINDNFTCatalog from 0x097bafa4e0b48eef\n\npub fun main() : {String : {String : Bool}} {\n    return FINDNFTCatalog.getCatalogTypeData() \n}",
               "spec": {
                  "order": [],
                  "parameters": {}
               }
            },
            "getCheckRoyalty": {
               "code": "import MetadataViews from 0x1d7e57aa55817448\nimport FIND from 0x097bafa4e0b48eef\nimport FINDNFTCatalog from 0x097bafa4e0b48eef\n\npub fun main(name: String, id: UInt64, nftAliasOrIdentifier: String, viewIdentifier: String) : AnyStruct? {\n\n    let address =FIND.resolve(name)!\n\n    // Get collection public path from NFT Registry\n    let collectionPublicPath = getPublicPath(nftAliasOrIdentifier)\n    let collection= getAuthAccount(address).borrow\u003c\u0026{MetadataViews.ResolverCollection}\u003e(from: collectionPublicPath)!\n\n    // let nft=collection.borrowViewResolver(id: id)\n    let nft=collection.borrowViewResolver(id: collection.getIDs()[0])\n    for v in nft.getViews() {\n        if v.identifier== viewIdentifier {\n            return nft.resolveView(v)\n        }\n    }\n    return nil\n}\n\npub fun getPublicPath(_ nftIdentifier: String) : StoragePath {\n    let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier)) \n    let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n    return collection.collectionData.storagePath\n}",
               "spec": {
                  "order": [
                     "name",
                     "id",
                     "nftAliasOrIdentifier",
                     "viewIdentifier"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "name": "String",
                     "nftAliasOrIdentifier": "String",
                     "viewIdentifier": "String"
                  }
               }
            },
            "getCollectionForType": {
               "code": "import NFTCatalog from 0x49a7cda3a1eecc29\nimport FINDNFTCatalog from 0x097bafa4e0b48eef\n\npub fun main(nftTypeIdentifier : String) : {String : Bool}? {\n    return FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftTypeIdentifier)\n}",
               "spec": {
                  "order": [
                     "nftTypeIdentifier"
                  ],
                  "parameters": {
                     "nftTypeIdentifier": "String"
                  }
               }
            },
            "getCollectionIndex": {
               "code": "import MetadataViews from 0x1d7e57aa55817448\nimport FINDNFTCatalog from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\n\npub fun main(user: String) : {String : [UInt64]} {\n\n    if let address = FIND.resolve(user) {\n        var resultMap : {String : [UInt64]} = {}\n        let account = getAccount(address)\n        for nftInfo in FINDNFTCatalog.getCatalog().values {\n            let publicPath = nftInfo.collectionData.publicPath\n\n            if let subCollections = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftInfo.nftType.identifier) {\n                if subCollections.length \u003c 1 {\n                    continue\n                } else if subCollections.length == 1 {\n                    let collection = nftInfo.nftType.identifier\n                    let resolverCollectionCap= account.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(publicPath)\n                    if resolverCollectionCap.check() {\n                        let collection = resolverCollectionCap.borrow()!\n                        resultMap[nftInfo.collectionDisplay.name] = collection.getIDs()\n                    }\n                } else {\n                    let collection = nftInfo.nftType.identifier\n                    let resolverCollectionCap= account.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(publicPath)\n\n                    let array : [UInt64] = []\n                    if resolverCollectionCap.check() {\n                        let collection = resolverCollectionCap.borrow()!\n                        for id in collection.getIDs() {\n                            let vr = collection.borrowViewResolver(id: id)\n                            if let sc = vr.resolveView(Type\u003cMetadataViews.NFTCollectionDisplay\u003e()) {\n                                let scv = sc as! MetadataViews.NFTCollectionDisplay\n                                if scv.name == nftInfo.collectionDisplay.name {\n                                    array.append(id)\n                                }\n                            }\n                        }\n                    }\n                    resultMap[nftInfo.collectionDisplay.name] = array\n                }\n            } \n\n        }\n\n        return resultMap\n    }\n    return {}\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "getCuratedCollections": {
               "code": "pub fun main(address: Address) : \u0026{String: [String]}? {\n    let account=getAccount(address)\n\n    if account.balance == 0.0 {\n        return nil\n    }\n\n    let publicPath=/public/FindCuratedCollections\n    let link = account.getCapability\u003c\u0026{String: [String]}\u003e(publicPath)\n    if link.check() {\n        return link.borrow()\n    }\n    return nil\n}",
               "spec": {
                  "order": [
                     "address"
                  ],
                  "parameters": {
                     "address": "Address"
                  }
               }
            },
            "getDandiesIDsFor": {
               "code": "import Dandy from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\n\npub fun main(user: String, minter: String) : [UInt64] {\n    let address = FIND.resolve(user)\n    if address == nil {\n        return []\n    }\n    let account = getAccount(address!)\n    if account.balance == 0.0 {\n        return []\n    }\n    let cap = account.getCapability\u003c\u0026Dandy.Collection{Dandy.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n    let ref = cap.borrow() ?? panic(\"Cannot borrow reference to Dandy Collection. Account address : \".concat(address!.toString()))\n\n    return ref.getIDsFor(minter: minter)\n}",
               "spec": {
                  "order": [
                     "user",
                     "minter"
                  ],
                  "parameters": {
                     "minter": "String",
                     "user": "String"
                  }
               }
            },
            "getDandiesMinters": {
               "code": "import Dandy from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\n\npub fun main(user: String) : [String] {\n    let address = FIND.resolve(user)\n    if address == nil {\n        return []\n    }\n    let account = getAccount(address!)\n    if account.balance == 0.0 {\n        return []\n    }\n    let cap = account.getCapability\u003c\u0026Dandy.Collection{Dandy.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n    let ref = cap.borrow() ?? panic(\"Cannot borrow reference to Dandy Collection. Account address : \".concat(address!.toString()))\n\n    return ref.getMinters()\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "getFTInfo": {
               "code": "import FTRegistry from 0x097bafa4e0b48eef\n\npub fun main(aliasOrIdentifier: String) : FTRegistry.FTInfo?{\n\n    return FTRegistry.getFTInfo(aliasOrIdentifier)\n\n}",
               "spec": {
                  "order": [
                     "aliasOrIdentifier"
                  ],
                  "parameters": {
                     "aliasOrIdentifier": "String"
                  }
               }
            },
            "getFTInfoAll": {
               "code": "import FTRegistry from 0x097bafa4e0b48eef\n\npub fun main() : {String: FTRegistry.FTInfo}{\n\n    return FTRegistry.getFTInfoAll()\n\n}",
               "spec": {
                  "order": [],
                  "parameters": {}
               }
            },
            "getItem": {
               "code": "import MetadataViews from 0x1d7e57aa55817448\nimport FIND from 0x097bafa4e0b48eef\nimport FINDNFTCatalog from 0x097bafa4e0b48eef\n\npub struct MetadataCollectionItem {\n    pub let id:UInt64\n    pub let uuid:UInt64\n    pub let name: String\n    pub let description: String?\n    pub let image: String\n    pub let url: String\n    pub let contentType:String\n    pub let rarity:String\n    pub let minter:String?\n    pub let type:Type\n\n\n    init(id:UInt64, uuid:UInt64, name:String, description:String?, image:String, url:String, contentType: String, rarity: String, minter:String?, type:Type) {\n        self.id=id\n        self.uuid=uuid\n        self.name=name\n        self.description=description\n        self.minter=minter\n        self.url=url\n        self.type=type\n        self.image=image\n        self.contentType=contentType\n        self.rarity=rarity\n    }\n}\n\n\npub fun main(user: String, aliasOrIdentifier: String, id:UInt64) : MetadataCollectionItem?{\n\n    let publicPath = getPublicPath(aliasOrIdentifier)\n\n    let resolveAddress = FIND.resolve(user) \n    if resolveAddress == nil {return nil}\n    let address = resolveAddress!\n    let account=getAccount(address)\n    if account.balance == 0.0 {\n        return nil\n    }\n    let resolverCollectionCap= account.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(publicPath)\n    if !resolverCollectionCap.check() {\n        return nil\n    }\n\n    let collection = resolverCollectionCap.borrow()!\n    let nft = collection.borrowViewResolver(id: id)!\n\n    if let displayView = nft.resolveView(Type\u003cMetadataViews.Display\u003e()) {\n        let display = displayView as! MetadataViews.Display\n\n        var externalUrl=\"\"\n        if let externalUrlView = nft.resolveView(Type\u003cMetadataViews.ExternalURL\u003e()) {\n            let edvu= externalUrlView as! MetadataViews.ExternalURL\n            externalUrl=edvu.url\n        }\n        let item = MetadataCollectionItem(\n            id: id,\n            uuid: nft.uuid,\n            name: display.name,\n            description:display.description,\n            image: display.thumbnail.uri(),\n            url: externalUrl,\n            contentType: \"image\",\n            rarity: \"\",\n            minter: \"\",\n            type: nft.getType()\n        )\n        return item\n    }\n    return nil\n}\n\npub fun getPublicPath(_ nftIdentifier: String) : PublicPath {\n    let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier)) \n    let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n    return collection.collectionData.publicPath\n}",
               "spec": {
                  "order": [
                     "user",
                     "aliasOrIdentifier",
                     "id"
                  ],
                  "parameters": {
                     "aliasOrIdentifier": "String",
                     "id": "UInt64",
                     "user": "String"
                  }
               }
            },
            "getLeases": {
               "code": "import FIND from 0x097bafa4e0b48eef\n\npub fun main() : [FIND.NetworkLease] {\n    return FIND.getLeases()\n}",
               "spec": {
                  "order": [],
                  "parameters": {}
               }
            },
            "getListings": {
               "code": "import FindMarket from 0x097bafa4e0b48eef \nimport FIND from 0x097bafa4e0b48eef \n\npub fun main(marketplace:Address, user: String) : {String : FindMarket.SaleItemCollectionReport} {\n    let resolveAddress = FIND.resolve(user)\n    if resolveAddress == nil { return {}}\n    let address = resolveAddress!\n        return FindMarket.getSaleItemReport(tenant:marketplace, address: address, getNFTInfo:false)\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "user"
                  ],
                  "parameters": {
                     "marketplace": "Address",
                     "user": "String"
                  }
               }
            },
            "getLostAndFoundNFTs": {
               "code": "import LostAndFoundHelper from 0x473d6a2c37eab5be\nimport FindLostAndFoundWrapper from 0x097bafa4e0b48eef\nimport NonFungibleToken from 0x1d7e57aa55817448\nimport FIND from 0x097bafa4e0b48eef\nimport FINDNFTCatalog from 0x097bafa4e0b48eef\n\npub fun main(user: String) : Report {\n\n    if let address = FIND.resolve(user) {\n        let runTimeType = Type\u003c@NonFungibleToken.NFT\u003e()\n\n        let ticketsInfo = FindLostAndFoundWrapper.getTickets(user: address, specificType: runTimeType)\n\n        let ticketIds : {String : [UInt64]} = {}\n        let NFTCatalogTicketInfo : {String : [LostAndFoundHelper.Ticket]} = {}\n        for type in ticketsInfo.keys {\n            // check if this type is in NFTCatalog\n            let nftCatalog = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: type)\n            var inNFTCatalog : Bool = true \n            if nftCatalog == nil {\n                inNFTCatalog = false\n            }\n\n            // append id in array\n            let id : [UInt64] = []\n            for ticket in ticketsInfo[type]! {\n                if ticket.ticketID != nil {\n                    id.append(ticket.ticketID!)\n                }\n            }\n            ticketIds[type] = id\n\n            // If it is in NFT Catalog, add it in NFTCatalogTicketInfo\n            if inNFTCatalog {\n                NFTCatalogTicketInfo[type] = ticketsInfo.remove(key: type)\n            }\n        }\n\n        return Report(nftCatalogTicketInfo : NFTCatalogTicketInfo, ticketInfo : ticketsInfo, ticketIds : ticketIds, error: nil)\n    }\n    return logErr(\"Cannot resolve user. User : \".concat(user))\n}\n\n\npub struct Report {\n\n    pub let nftCatalogTicketInfo : {String : [LostAndFoundHelper.Ticket]}\n    pub let ticketInfo : {String : [LostAndFoundHelper.Ticket]}\n    pub let ticketIds : {String : [UInt64]}\n    pub let error : String?\n\n    init(nftCatalogTicketInfo : {String : [LostAndFoundHelper.Ticket]}, ticketInfo : {String : [LostAndFoundHelper.Ticket]}, ticketIds : {String : [UInt64]}, error: String?) {\n        self.nftCatalogTicketInfo = nftCatalogTicketInfo\n        self.ticketInfo = ticketInfo\n        self.ticketIds = ticketIds\n        self.error = error\n    }\n}\n\npub fun logErr(_ err: String) : Report {\n    return Report(nftCatalogTicketInfo: {}, ticketInfo : {}, ticketIds : {} , error: err)\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "getLostAndFoundRedeemableNFTTypes": {
               "code": "import FindLostAndFoundWrapper from 0x097bafa4e0b48eef\nimport NonFungibleToken from 0x1d7e57aa55817448\nimport FIND from 0x097bafa4e0b48eef\n\npub fun main(user: String) : Report {\n\n    if let address = FIND.resolve(user){\n        let type : Type = Type\u003c@NonFungibleToken.NFT\u003e()\n        return Report(nftTypes: typeToStringArray(FindLostAndFoundWrapper.getSpecificRedeemableTypes(user: address, specificType: type)), err: nil)\n    }\n    return logErr(\"cannot resolve user\")\n\n}\n\npub fun typeToStringArray(_ array: [Type]) : [String] {\n    let res : [String] = []\n    for type in array {\n        res.append(type.identifier)\n    }\n    return res\n}\n\npub struct Report {\n    pub let nftTypes : [String]\n    pub let err : String? \n\n    init(nftTypes : [String] , err : String? ) {\n        self.nftTypes = nftTypes\n        self.err = err\n    }\n}\n\npub fun logErr(_ err: String) : Report{\n    return Report(nftTypes: [], err: err)\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "getLostAndFoundRequiredStorageType": {
               "code": "import FindLostAndFoundWrapper from 0x097bafa4e0b48eef\nimport FINDNFTCatalog from 0x097bafa4e0b48eef\nimport NonFungibleToken from 0x1d7e57aa55817448\nimport MetadataViews from 0x1d7e57aa55817448\nimport FIND from 0x097bafa4e0b48eef\n\npub fun main(user: String) : Report {\n\n    if let address = FIND.resolve(user){\n        let runTimeType : Type = Type\u003c@NonFungibleToken.NFT\u003e()\n\n        let types = FindLostAndFoundWrapper.getSpecificRedeemableTypes(user: address, specificType: runTimeType)\n\n        let account = getAuthAccount(address)\n\n        let initiableStorage : [String] = []\n        let relinkableStorage : [String] = []\n        let initiatedStorage : [String] = []\n        let problematicStorage : [String] = []\n        let notSupportedType : [String] = []\n        for type in types {\n\n            let nftInfo = FINDNFTCatalog.getCollectionDataForType(nftTypeIdentifier: type.identifier)\n\n            if nftInfo == nil {\n                initiableStorage.append(type.identifier)\n                continue\n            }\n\n            let storageType = account.type(at: nftInfo!.storagePath)\n            if storageType == nil {\n                initiableStorage.append(type.identifier)\n                continue\n            } \n            \n            let storageTypeIdentifier = storageType!.identifier.slice(from: 0 , upTo: storageType!.identifier.length - \".Collection\".length)\n            let typeIdentifier = type.identifier.slice(from: 0 , upTo: type.identifier.length - \".NFT\".length)\n            if storageTypeIdentifier != typeIdentifier {\n                problematicStorage.append(type.identifier)\n            } else {\n\n                // check if relink needed\n                if account.getCapability\u003c\u0026{NonFungibleToken.Receiver, NonFungibleToken.CollectionPublic, MetadataViews.ResolverCollection}\u003e(nftInfo!.publicPath).check() {\n                    initiatedStorage.append(type.identifier)\n                } else {\n                    relinkableStorage.append(type.identifier)\n                }\n\n            }\n        }\n        return Report(initiableStorage: initiableStorage, relinkableStorage: relinkableStorage ,initiatedStorage: initiatedStorage, problematicStorage: problematicStorage, notSupportedType: notSupportedType, err: nil)\n    }\n    return logErr(\"cannot resolve user\")\n\n}\n\npub struct Report {\n\n    pub let initiableStorage : [String] \n    pub let relinkableStorage : [String]\n    pub let initiatedStorage : [String] \n    pub let problematicStorage : [String] \n    pub let notSupportedType : [String] \n\n    pub let err : String? \n\n    init(initiableStorage : [String] , relinkableStorage : [String] , initiatedStorage : [String], problematicStorage : [String] , notSupportedType : [String] , err : String? ) {\n        self.initiableStorage = initiableStorage\n        self.relinkableStorage = relinkableStorage\n        self.initiatedStorage = initiatedStorage\n        self.problematicStorage = problematicStorage\n        self.notSupportedType = notSupportedType\n        self.err = err\n    }\n\n}\n\npub fun logErr(_ err: String) : Report {\n    return Report(initiableStorage: [] , relinkableStorage : [] , initiatedStorage : [] , problematicStorage: [], notSupportedType: [], err: err)\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "getMarketBlockedNFT": {
               "code": "import FindMarket from 0x097bafa4e0b48eef \n\npub fun main() : {String : [String] } {\n    let mapping : {String : [String] } = {}\n\n    let findAddress=FindMarket.getFindTenantAddress()\n    let tenantCap = FindMarket.getTenantCapability(findAddress)!\n    let tenantRef = tenantCap.borrow() ?? panic(\"This tenant is not set up. Tenant : \".concat(tenantCap.address.toString()))\n    let marketTypes = FindMarket.getSaleItemTypes()\n    for marketType in marketTypes {\n        let list : [String] = []\n        for type in tenantRef.getBlockedNFT(marketType: marketType) {\n            list.append(type.identifier)\n        }\n        mapping[FindMarket.getMarketOptionFromType(marketType)] = list\n    }\n\nreturn mapping\n}",
               "spec": {
                  "order": [],
                  "parameters": {}
               }
            },
            "getMetadataForSaleItem": {
               "code": "import FindMarketSale from 0x097bafa4e0b48eef\nimport FindMarket from 0x097bafa4e0b48eef\n\npub struct PurchaseData {\n    pub let id: UInt64\n    pub let name: String\n    pub let amount: UFix64\n    pub let description: String\n    pub let imageURL: String\n\n    init(id: UInt64, name: String, amount: UFix64, description: String, imageURL: String) {\n        self.id = id\n        self.name = name\n        self.amount = amount\n        self.description = description\n        self.imageURL = imageURL\n    }\n}\npub fun main(merchantAddress: Address, marketplace:Address, address: Address, id: UInt64, amount: UFix64) : PurchaseData{\n    let saleItemsCap= FindMarketSale.getSaleItemCapability(marketplace: marketplace, user:address) ?? panic(\"cannot find sale item cap\")\n    let saleItemCollection = saleItemsCap.borrow()!\n    let item = saleItemCollection.borrowSaleItem(id)\n\n    let display = item.getDisplay()\n\n    var thumbnail = replacePrefix(display.thumbnail.uri(), prefix: \"ipfs://\", replace:\"https://nftstorage.link/ipfs/\")\n    return PurchaseData(\n        id: id, \n        name: display.name, \n        amount: amount,\n        description: display.description, \n        imageURL: thumbnail\n    )\n}\n\npub fun replacePrefix(_ original: String, prefix:String, replace:String) : String {\n    if original.length \u003c prefix.length  {\n        return original\n    }\n    let oprefix = original.slice(from:0, upTo:prefix.length)\n    if oprefix != prefix {\n        return original\n    }\n    let rest = original.slice(from:prefix.length, upTo: original.length)\n    return replace.concat(rest)\n}",
               "spec": {
                  "order": [
                     "merchantAddress",
                     "marketplace",
                     "address",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "address": "Address",
                     "amount": "UFix64",
                     "id": "UInt64",
                     "marketplace": "Address",
                     "merchantAddress": "Address"
                  }
               }
            },
            "getNFTCatalogIDs": {
               "code": "import MetadataViews from 0x1d7e57aa55817448\nimport FIND from 0x097bafa4e0b48eef\nimport FINDNFTCatalog from 0x097bafa4e0b48eef\n\npub fun main(user: String, collections: [String]) : {String : ItemReport} {\n    return fetchNFTCatalog(user: user, targetCollections:collections)\n}\n\npub struct ItemReport {\n    pub let length : Int // mapping of collection to no. of ids \n    pub let extraIDs : [UInt64]\n    pub let shard : String \n    pub let extraIDsIdentifier : String \n\n    init(length : Int, extraIDs :[UInt64] , shard: String, extraIDsIdentifier: String) {\n        self.length=length \n        self.extraIDs=extraIDs\n        self.shard=shard\n        self.extraIDsIdentifier=extraIDsIdentifier\n    }\n}\n\n    pub struct NFTView {\n        pub let id: UInt64\n        pub let display: MetadataViews.Display?\n        pub let editions: MetadataViews.Editions?\n        pub let collectionDisplay: MetadataViews.NFTCollectionDisplay?\n        pub let nftType: Type\n\n        init(\n            id : UInt64,\n            display : MetadataViews.Display?,\n            editions : MetadataViews.Editions?,\n            collectionDisplay: MetadataViews.NFTCollectionDisplay?,\n            nftType: Type\n        ) {\n            self.id = id\n            self.display = display\n            self.editions = editions\n            self.collectionDisplay = collectionDisplay\n            self.nftType = nftType\n        }\n    }\n\n// Helper function \n\npub fun resolveAddress(user: String) : Address? {\n    return FIND.resolve(user)\n}\n\npub fun getNFTIDs(ownerAddress: Address) : {String:[UInt64]} {\n\n    let account = getAuthAccount(ownerAddress)\n\n    if account.balance == 0.0 {\n        return {}\n    }\n\n    let inventory : {String:[UInt64]}={}\n    let types = FINDNFTCatalog.getCatalogTypeData()\n    for nftType in types.keys {\n\n        let typeData=types[nftType]!\n        let collectionKey=typeData.keys[0]\n        let catalogEntry = FINDNFTCatalog.getCatalogEntry(collectionIdentifier:collectionKey)!\n        let storagePath = catalogEntry.collectionData.storagePath\n        let ref= account.borrow\u003c\u0026{MetadataViews.ResolverCollection}\u003e(from: storagePath)\n        if ref != nil {\n            inventory[collectionKey] = ref!.getIDs()\n        }\n\n    }\n    return inventory\n}\n\npub fun fetchNFTCatalog(user: String, targetCollections: [String]) : {String : ItemReport} {\n    let source = \"NFTCatalog\"\n    let account = resolveAddress(user: user)\n    if account == nil { return {} }\n\n\n    let extraIDs = getNFTIDs(ownerAddress: account!)\n    let inventory : {String : ItemReport} = {}\n    var fetchedCount : Int = 0\n\n    for project in extraIDs.keys {\n\n        let catalogEntry = FINDNFTCatalog.getCatalogEntry(collectionIdentifier:project)!\n        let projectName = catalogEntry.contractName\n\n        if extraIDs[project]! == nil || extraIDs[project]!.length \u003c 1{\n            extraIDs.remove(key: project)\n            continue\n        }\n        \n        let collectionLength = extraIDs[project]!.length\n\n        // by pass if this is not the target collection\n        if targetCollections.length \u003e 0 \u0026\u0026 !targetCollections.contains(project) {\n            // inventory[project] = ItemReport(length : collectionLength, extraIDs :extraIDs[project]! , shard: source)\n            continue\n        }\n\n        inventory[catalogEntry.contractName] = ItemReport(length : collectionLength, extraIDs :extraIDs[project] ?? [] , shard: source, extraIDsIdentifier: project)\n\n    }\n\n    return inventory\n\n}",
               "spec": {
                  "order": [
                     "user",
                     "collections"
                  ],
                  "parameters": {
                     "collections": "[String]",
                     "user": "String"
                  }
               }
            },
            "getNFTCatalogItems": {
               "code": "import MetadataViews from 0x1d7e57aa55817448\nimport FIND from 0x097bafa4e0b48eef\n\nimport FINDNFTCatalog from 0x097bafa4e0b48eef\n\npub fun main(user: String, collectionIDs: {String : [UInt64]}) : {String : [MetadataCollectionItem]} {\n    return fetchNFTCatalog(user: user, collectionIDs: collectionIDs)\n}\n\npub struct NFTView {\n    pub let id: UInt64\n    pub let display: MetadataViews.Display?\n    pub let editions: MetadataViews.Editions?\n    pub let collectionDisplay: MetadataViews.NFTCollectionDisplay?\n    pub let nftType: Type\n\n    init(\n        id : UInt64,\n        display : MetadataViews.Display?,\n        editions : MetadataViews.Editions?,\n        collectionDisplay: MetadataViews.NFTCollectionDisplay?,\n        nftType: Type\n    ) {\n        self.id = id\n        self.display = display\n        self.editions = editions\n        self.collectionDisplay = collectionDisplay\n        self.nftType = nftType\n    }\n}\n\npub fun getNFTs(ownerAddress: Address, ids: {String : [UInt64]}) : [NFTView] {\n\n    let account = getAuthAccount(ownerAddress)\n\n    if account.balance == 0.0 {\n        return []\n    }\n\n    let results : [NFTView] = []\n    for collectionKey in ids.keys {\n        let catalogEntry = FINDNFTCatalog.getCatalogEntry(collectionIdentifier:collectionKey)!\n        let storagePath = catalogEntry.collectionData.storagePath\n        let ref= account.borrow\u003c\u0026{MetadataViews.ResolverCollection}\u003e(from: storagePath)\n        if ref != nil{\n            for id in ids[collectionKey]! {\n                // results.append(MetadataViews.getNFTView(id:id, viewResolver: ref!.borrowViewResolver(id:id)!))\n                let viewResolver = ref!.borrowViewResolver(id:id)!\n                results.append(\n                    NFTView(\n                        id : id,\n                        display: MetadataViews.getDisplay(viewResolver),\n                        editions : MetadataViews.getEditions(viewResolver),\n                        collectionDisplay : MetadataViews.getNFTCollectionDisplay(viewResolver),\n                        nftType : viewResolver.getType()\n                    )\n                )\n            }\n        }\n    }\n    return results\n}\n\npub struct CollectionReport {\n    pub let items : {String : [MetadataCollectionItem]} \n    pub let collections : {String : Int} // mapping of collection to no. of ids \n    pub let extraIDs : {String : [UInt64]} \n\n    init(items: {String : [MetadataCollectionItem]},  collections : {String : Int}, extraIDs : {String : [UInt64]} ) {\n        self.items=items \n        self.collections=collections \n        self.extraIDs=extraIDs\n    }\n}\n\npub struct MetadataCollectionItem {\n    pub let id:UInt64\n    pub let name: String\n    pub let collection: String // \u003c- This will be Alias unless they want something else\n    pub let subCollection: String? // \u003c- This will be Alias unless they want something else\n    pub let nftDetailIdentifier: String\n\n    pub let media  : String\n    pub let mediaType : String \n    pub let source : String \n\n    init(id:UInt64, name: String, collection: String, subCollection: String?, media  : String, mediaType : String, source : String, nftDetailIdentifier: String) {\n        self.id=id\n        self.name=name \n        self.collection=collection \n        self.subCollection=subCollection \n        self.media=media \n        self.mediaType=mediaType \n        self.source=source\n        self.nftDetailIdentifier=nftDetailIdentifier\n    }\n}\n\n// Helper function \n\npub fun resolveAddress(user: String) : PublicAccount? {\n    let address = FIND.resolve(user)\n    if address == nil {\n        return nil\n    }\n    return getAccount(address!)\n}\n\n\n//////////////////////////////////////////////////////////////\n// Fetch Specific Collections in Shard 1\n//////////////////////////////////////////////////////////////\npub fun fetchNFTCatalog(user: String, collectionIDs: {String : [UInt64]}) : {String : [MetadataCollectionItem]} {\n    let source = \"NFTCatalog\"\n    let account = resolveAddress(user: user)\n    if account == nil { return {} }\n\n    let items : {String : [MetadataCollectionItem]} = {}\n\n    let fetchingIDs = collectionIDs\n\n\n    for project in fetchingIDs.keys {\n\n        let catalogEntry = FINDNFTCatalog.getCatalogEntry(collectionIdentifier:project)!\n        let projectName = catalogEntry.contractName\n\n        let returnedNFTs = getNFTs(ownerAddress: account!.address, ids: {project : fetchingIDs[project]!})\n\n        var collectionItems : [MetadataCollectionItem] = []\n        for nft in returnedNFTs {\n            if nft == nil {\n                continue\n            }\n\n            var subCollection = \"\"\n            if project != nft!.collectionDisplay!.name {\n             subCollection = nft!.collectionDisplay!.name\n            }\n\n            var name = nft!.display!.name \n            if name == \"\" {\n                name = projectName\n            }\n\n            if nft.editions != nil \u0026\u0026 nft.editions!.infoList.length \u003e 0 {\n                let edition = nft.editions!.infoList[0].number.toString()\n                // check if the name ends with \"editionNumber\"\n                // If the name ends with \"editionNumber\", we do not concat the edition\n                if name.length \u003e edition.length \u0026\u0026 name.slice(from: name.length - edition.length, upTo: name.length) != edition {\n                    name = name.concat(\"#\").concat(nft.editions!.infoList[0].number.toString())\n                }\n            }\n            \n            let item = MetadataCollectionItem(\n                id: nft!.id,\n                name: name,\n                collection: project,\n                subCollection: subCollection, \n                media: nft!.display!.thumbnail.uri(),\n                mediaType: \"image/png\",\n                source: source, \n                nftDetailIdentifier: nft!.nftType.identifier\n            )\n            collectionItems.append(item)\n        }\n\n        if collectionItems.length \u003e 0 {\n            items[project] = collectionItems\n        }\n    }\n    return items\n}",
               "spec": {
                  "order": [
                     "user",
                     "collectionIDs"
                  ],
                  "parameters": {
                     "collectionIDs": "{String: [UInt64]}",
                     "user": "String"
                  }
               }
            },
            "getNFTCatalogItemsWithMetadata": {
               "code": "import MetadataViews from 0x1d7e57aa55817448\nimport FIND from 0x097bafa4e0b48eef\n\nimport FINDNFTCatalog from 0x097bafa4e0b48eef\n\npub fun main(user: String, collectionIDs: {String : [UInt64]}) : {String : [MetadataCollectionItem]} {\n    return fetchNFTCatalog(user: user, collectionIDs: collectionIDs)\n}\n\npub struct NFTView {\n    pub let id: UInt64\n    pub let display: MetadataViews.Display?\n    pub let collectionDisplay: MetadataViews.NFTCollectionDisplay?\n    pub var rarity:MetadataViews.Rarity?\n    pub var editions: MetadataViews.Editions?\n    pub var serial: UInt64?\n    pub var traits: MetadataViews.Traits?\n    pub let nftType: Type\n\n    init(\n        id : UInt64,\n        display : MetadataViews.Display?,\n        editions : MetadataViews.Editions?,\n        rarity:MetadataViews.Rarity?,\n        serial: UInt64?,\n        traits: MetadataViews.Traits?,\n        collectionDisplay: MetadataViews.NFTCollectionDisplay?,\n        nftType: Type\n    ) {\n        self.id = id\n        self.display = display\n        self.editions = editions\n        self.rarity = rarity\n        self.serial = serial\n        self.traits = traits\n        self.collectionDisplay = collectionDisplay\n        self.nftType = nftType\n    }\n}\n\npub fun getNFTs(ownerAddress: Address, ids: {String : [UInt64]}) : [NFTView] {\n\n    let account = getAuthAccount(ownerAddress)\n\n    if account.balance == 0.0 {\n        return []\n    }\n\n    let results : [NFTView] = []\n    for collectionKey in ids.keys {\n        let catalogEntry = FINDNFTCatalog.getCatalogEntry(collectionIdentifier:collectionKey)!\n        let storagePath = catalogEntry.collectionData.storagePath\n        let ref= account.borrow\u003c\u0026{MetadataViews.ResolverCollection}\u003e(from: storagePath)\n        if ref != nil{\n            for id in ids[collectionKey]! {\n                // results.append(MetadataViews.getNFTView(id:id, viewResolver: ref!.borrowViewResolver(id:id)!))\n                let viewResolver = ref!.borrowViewResolver(id:id)!\n\n                var traitsStruct : MetadataViews.Traits? = nil \n\n                if let traits = MetadataViews.getTraits(viewResolver) {\n                    if let trait = getTrait(viewResolver) {\n                        var check = false \n                        for item in traits.traits {\n                            if item.name == trait.name {\n                                check = true \n                                break\n                            }\n                            if !check {\n                                let array = traits.traits\n                                array.append(trait)\n\n                                traitsStruct = cleanUpTraits(array)\n                            }\n                        }\n                    } else {\n                        traitsStruct = cleanUpTraits(traits.traits)\n                    }\n                } else {\n                    if let trait = getTrait(viewResolver) {\n                        traitsStruct = cleanUpTraits([trait])\n                    }\n                }\n\n                var editionStruct : MetadataViews.Editions? = nil \n\n                if let editions = MetadataViews.getEditions(viewResolver) {\n                    if let edition = getEdition(viewResolver) {\n                        var check = false\n                        for item in editions.infoList {\n                            if item.name == edition.name \u0026\u0026 item.number == edition.number \u0026\u0026 item.max == edition.max {\n                                check = true\n                                break\n                            }\n                        }\n                        // If the edition does not exist in editions, add it in\n                        if !check {\n                            let array = editions.infoList \n                            array.append(edition)\n                            editionStruct = MetadataViews.Editions(array)\n                        }\n                    } else {\n                    // If edition does not exist OR edition is already in editions , append it to views and continue\n                        editionStruct = editions\n                    }\n                } else if let edition = getEdition(viewResolver) {\n                        editionStruct = MetadataViews.Editions([edition])\n                }\n\n                results.append(\n                    NFTView(\n                        id : id,\n                        display: MetadataViews.getDisplay(viewResolver),\n                        editions : editionStruct,\n                        rarity : MetadataViews.getRarity(viewResolver),\n                        serial :  MetadataViews.getSerial(viewResolver)?.number,\n                        traits : traitsStruct,\n                        collectionDisplay : MetadataViews.getNFTCollectionDisplay(viewResolver),\n                        nftType : viewResolver.getType()\n                    )\n                )\n            }\n        }\n    }\n    return results\n}\n\npub struct CollectionReport {\n    pub let items : {String : [MetadataCollectionItem]} \n    pub let collections : {String : Int} // mapping of collection to no. of ids \n    pub let extraIDs : {String : [UInt64]} \n\n    init(items: {String : [MetadataCollectionItem]},  collections : {String : Int}, extraIDs : {String : [UInt64]} ) {\n        self.items=items \n        self.collections=collections \n        self.extraIDs=extraIDs\n    }\n}\n\npub struct MetadataCollectionItem {\n    pub let id:UInt64\n    pub let name: String\n    pub let collection: String // \u003c- This will be Alias unless they want something else\n    pub let subCollection: String? // \u003c- This will be Alias unless they want something else\n    pub let nftDetailIdentifier: String\n\n    pub let media  : String\n    pub let mediaType : String \n    pub let source : String \n\n    pub var rarity:MetadataViews.Rarity?\n    pub var editions: MetadataViews.Editions?\n    pub var serial: UInt64?\n    pub var traits: MetadataViews.Traits?\n\n    init(id:UInt64, \n         name: String, \n         collection: String, \n         subCollection: String?, \n         media  : String, \n         mediaType : String, \n         source : String, \n         nftDetailIdentifier: String, \n         editions : MetadataViews.Editions?,\n         rarity:MetadataViews.Rarity?,\n         serial: UInt64?,\n         traits: MetadataViews.Traits?,\n         ) {\n        self.id=id\n        self.name=name \n        self.collection=collection \n        self.subCollection=subCollection \n        self.media=media \n        self.mediaType=mediaType \n        self.source=source\n        self.nftDetailIdentifier=nftDetailIdentifier\n        self.editions=editions\n        self.rarity=rarity\n        self.serial=serial\n        self.traits=traits\n    }\n}\n\n// Helper function \n\npub fun resolveAddress(user: String) : PublicAccount? {\n    let address = FIND.resolve(user)\n    if address == nil {\n        return nil\n    }\n    return getAccount(address!)\n}\n\n\n//////////////////////////////////////////////////////////////\n// Fetch Specific Collections in Shard 1\n//////////////////////////////////////////////////////////////\npub fun fetchNFTCatalog(user: String, collectionIDs: {String : [UInt64]}) : {String : [MetadataCollectionItem]} {\n    let source = \"NFTCatalog\"\n    let account = resolveAddress(user: user)\n    if account == nil { return {} }\n\n    let items : {String : [MetadataCollectionItem]} = {}\n\n    let fetchingIDs = collectionIDs\n\n\n    for project in fetchingIDs.keys {\n\n        let catalogEntry = FINDNFTCatalog.getCatalogEntry(collectionIdentifier:project)!\n        let projectName = catalogEntry.contractName\n\n        let returnedNFTs = getNFTs(ownerAddress: account!.address, ids: {project : fetchingIDs[project]!})\n\n        var collectionItems : [MetadataCollectionItem] = []\n        for nft in returnedNFTs {\n            if nft == nil {\n                continue\n            }\n\n            var subCollection = \"\"\n            if project != nft!.collectionDisplay!.name {\n             subCollection = nft!.collectionDisplay!.name\n            }\n\n            var name = nft!.display!.name \n            if name == \"\" {\n                name = projectName\n            }\n\n            if nft.editions != nil \u0026\u0026 nft.editions!.infoList.length \u003e 0 {\n                let edition = nft.editions!.infoList[0].number.toString()\n                // check if the name ends with \"editionNumber\"\n                // If the name ends with \"editionNumber\", we do not concat the edition\n                if name.length \u003e edition.length \u0026\u0026 name.slice(from: name.length - edition.length, upTo: name.length) != edition {\n                    name = name.concat(\"#\").concat(nft.editions!.infoList[0].number.toString())\n                }\n            }\n            \n            let item = MetadataCollectionItem(\n                id: nft!.id,\n                name: name,\n                collection: project,\n                subCollection: subCollection, \n                media: nft!.display!.thumbnail.uri(),\n                mediaType: \"image/png\",\n                source: source, \n                nftDetailIdentifier: nft!.nftType.identifier, \n                editions : nft!.editions,\n                rarity: nft!.rarity,\n                serial: nft!.serial,\n                traits: nft!.traits,\n            )\n            collectionItems.append(item)\n        }\n\n        if collectionItems.length \u003e 0 {\n            items[project] = collectionItems\n        }\n    }\n    return items\n}\n\npub fun cleanUpTraits(_ traits: [MetadataViews.Trait]) : MetadataViews.Traits {\n    let dateValues  = {\"Date\" : true, \"Numeric\":false, \"Number\":false, \"date\":true, \"numeric\":false, \"number\":false}\n\n    let array : [MetadataViews.Trait] = []\n\n    for i , trait in traits {\n        let displayType = trait.displayType ?? \"string\"\n        if let isDate = dateValues[displayType] {\n            if isDate {\n                array.append(MetadataViews.Trait(name: trait.name, value: trait.value, displayType: \"Date\", rarity: trait.rarity))\n            } else {\n                array.append(MetadataViews.Trait(name: trait.name, value: trait.value, displayType: \"Numeric\", rarity: trait.rarity))\n            }\n        } else {\n            if let value = trait.value as? Bool {\n                if value {\n                    array.append(MetadataViews.Trait(name: trait.name, value: trait.value, displayType: \"Bool\", rarity: trait.rarity))\n                }else {\n                    array.append(MetadataViews.Trait(name: trait.name, value: trait.value, displayType: \"Bool\", rarity: trait.rarity))\n                }\n            } else if let value = trait.value as? String {\n                array.append(MetadataViews.Trait(name: trait.name, value: trait.value, displayType: \"String\", rarity: trait.rarity))\n            } else {\n                array.append(MetadataViews.Trait(name: trait.name, value: trait.value, displayType: \"String\", rarity: trait.rarity))\n            }\n        }\n    }\n    return MetadataViews.Traits(array)\n}\n\npub fun getTrait(_ viewResolver: \u0026{MetadataViews.Resolver}) : MetadataViews.Trait? {\n    if let view = viewResolver.resolveView(Type\u003cMetadataViews.Trait\u003e()) {\n        if let v = view as? MetadataViews.Trait {\n            return v\n        }\n    }\n    return nil\n}\n\npub fun getEdition(_ viewResolver: \u0026{MetadataViews.Resolver}) : MetadataViews.Edition? {\n    if let view = viewResolver.resolveView(Type\u003cMetadataViews.Edition\u003e()) {\n        if let v = view as? MetadataViews.Edition {\n            return v\n        }\n    }\n    return nil\n}",
               "spec": {
                  "order": [
                     "user",
                     "collectionIDs"
                  ],
                  "parameters": {
                     "collectionIDs": "{String: [UInt64]}",
                     "user": "String"
                  }
               }
            },
            "getNFTDetailsNFTCatalog": {
               "code": "import FindMarket from 0x097bafa4e0b48eef \nimport FindViews from 0x097bafa4e0b48eef \nimport FIND from 0x097bafa4e0b48eef \nimport MetadataViews from 0x1d7e57aa55817448\n//import NFTStorefront from \"../contracts/standard/NFTStorefront.cdc\"\nimport FINDNFTCatalog from 0x097bafa4e0b48eef\nimport FTRegistry from 0x097bafa4e0b48eef\n\npub struct NFTDetailReport {\n    pub let findMarket: {String : FindMarket.SaleItemInformation}\n    pub let storefront: StorefrontListing?\n    pub let nftDetail: NFTDetail?\n    pub let allowedListingActions: {String : ListingTypeReport}\n    pub let linkedForMarket : Bool?\n\n    init(findMarket:{String : FindMarket.SaleItemInformation}, storefront: StorefrontListing?, nftDetail: NFTDetail?, allowedListingActions: {String : ListingTypeReport}, linkedForMarket : Bool?) {\n        self.findMarket=findMarket\n        self.storefront=storefront\n        self.nftDetail=nftDetail\n        self.allowedListingActions=allowedListingActions\n        self.linkedForMarket = linkedForMarket\n    }\n}\n\n\npub struct ListingTypeReport {\n    pub let ftAlias: [String] \n    pub let ftIdentifiers: [String]\n    pub let listingType: String \n    pub let status: String \n    pub let ListingDetails: [ListingRoyalties]\n\n    init(listingType: String, ftAlias: [String], ftIdentifiers: [String],  status: String , ListingDetails: [ListingRoyalties]) {\n        self.listingType=listingType \n        self.status=status\n        self.ListingDetails=ListingDetails\n        self.ftAlias=ftAlias \n        self.ftIdentifiers=ftIdentifiers\n    }\n}\n\npub struct NFTDetail {\n    pub let id: UInt64 \n    pub let uuid: UInt64 \n    pub let name:String\n    pub let description:String\n    pub let thumbnail:String\n    pub let type: String\n    pub var externalViewURL: String?\n    pub var rarity:MetadataViews.Rarity?\n    pub var editions: [MetadataViews.Edition]\n    pub var serial: UInt64?\n    pub var traits: [MetadataViews.Trait]\n    pub var media : {String: String} //url to mediaType\n    pub var collection : NFTCollectionDisplay?\n    pub var license : String? \n    pub var data: {String : AnyStruct?}\n    pub var views :[String]\n\n    init(_ pointer: FindViews.ViewReadPointer, views: {String : AnyStruct}, resolvedViews: [Type]){\n\n        self.type=pointer.itemType.identifier\n        self.id=pointer.id\n        self.uuid=pointer.getUUID()\n\n        // Display \n        let display = views[\"Display\"] ?? panic(\"Could not find display\")\n        let d = display as! MetadataViews.Display\n        self.name=d.name\n        self.description=d.description\n        self.thumbnail=d.thumbnail.uri()\n        views.remove(key: \"Display\")\n\n        // External URL \n        self.externalViewURL = nil \n        if let externalURL = views[\"ExternalURL\"] {\n            if let e = externalURL as? MetadataViews.ExternalURL {\n                self.externalViewURL = e.url\n            }\n        }\n        views.remove(key: \"ExternalURL\")\n\n        // Edition\n        self.editions=[] \n        if let editions = views[\"Editions\"] {\n            if let e = editions as? MetadataViews.Editions {\n                if e.infoList.length \u003e 0 {\n                    self.editions=e.infoList\n                }\n            }\n        }\n        views.remove(key: \"Editions\")\n\n        // Serial\n        self.serial=nil\n        if let serial = views[\"Serial\"] {\n            if let s = serial as? MetadataViews.Serial {\n                self.serial=s.number\n            }\n        }\n        views.remove(key: \"Serial\")\n\n        // subCollection\n        self.collection=nil\n        if let grouping = views[\"NFTCollectionDisplay\"] {\n            if let sc = grouping as? MetadataViews.NFTCollectionDisplay {\n                self.collection=NFTCollectionDisplay(sc)\n            }\n        }\n        views.remove(key: \"NFTCollectionDisplay\")\n\n        // Medias \n        self.media={}\n        if let medias= views[\"Medias\"] {\n            if let ms = medias as? MetadataViews.Medias {\n                for m in ms.items {\n                    let url = m.file.uri() \n                    let type = m.mediaType\n                    self.media[url] = type\n                }\n            }\n        }\n        views.remove(key: \"Medias\")\n\n        // Rarity \n        self.rarity=nil\n        if let rarity= views[\"Rarity\"] {\n            if let r = rarity as? MetadataViews.Rarity {\n                self.rarity = r\n            }\n        }\n        views.remove(key: \"Rarity\")\n\n        // Traits\n        self.traits=[] \n        if let traits = views[\"Traits\"] {\n            if let t = traits as? MetadataViews.Traits {\n                if t.traits.length \u003e 0 {\n                    self.traits=t.traits\n                }\n            }\n        }\n        views.remove(key: \"Traits\")\n\n        // License \n        self.license= nil \n        if let license= views[\"License\"] {\n            if let l = license as? MetadataViews.License {\n                self.license = l.spdxIdentifier\n            }\n        }\n        views.remove(key: \"License\")\n\n        self.views=[]\n\n        for view in pointer.getViews() {\n            if defaultViews().contains(view) {\n                continue\n            }\n            if resolvedViews.contains(view) {\n                continue\n            }\n            self.views.append(view.identifier)\n        }\n        self.data=views\n\n    }\n}\n\n\npub struct StoreFrontCut {\n\n    pub let amount:UFix64\n    pub let address: Address\n    pub let findName:String?\n\n    init(amount:UFix64, address:Address){\n        self.amount=amount\n        self.address=address\n        self.findName= reverseLookup(address)\n    }\n}\n\npub struct ListingRoyalties {\n\n    pub let ftAlias: String?\n    pub let ftIdentifier: String\n    pub let royalties: [Royalties]\n\n    init(ftAlias: String?, ftIdentifier: String, royalties: [Royalties]) {\n        self.ftAlias=ftAlias \n        self.ftIdentifier=ftIdentifier\n        self.royalties=royalties \n    }\n}\n\npub struct Royalties {\n\n    pub let royaltyName: String \n    pub let address: Address \n    pub let findName: String? \n    pub let cut: UFix64 \n\n    init(royaltyName: String , address: Address, findName: String?, cut: UFix64) {\n        self.royaltyName=royaltyName \n        self.address=address \n        self.findName=findName \n        self.cut=cut\n    }\n}\n\n\npub struct StorefrontListing {\n    pub let foo:String\n\n    init() {\n\n        self.foo =\"bar\"\n    }\n}\n\npub struct NFTCollectionDisplay {\n    // Name that should be used when displaying this NFT collection.\n    pub let name: String\n\n    // Description that should be used to give an overview of this collection.\n    pub let description: String\n\n    // External link to a URL to view more information about this collection.\n    pub let externalURL: String\n\n    // Square-sized image to represent this collection.\n    pub let squareImage: {String : String}\n\n    // Banner-sized image for this collection, recommended to have a size near 1200x630.\n    pub let bannerImage: {String : String}\n\n    // Social links to reach this collection's social homepages.\n    // Possible keys may be \"instagram\", \"twitter\", \"discord\", etc.\n    pub let socials: {String: String}\n\n    init(\n        _ nftCD : MetadataViews.NFTCollectionDisplay\n    ) {\n        self.name = nftCD.name\n        self.description = nftCD.description\n        self.externalURL = nftCD.externalURL.url\n\n        let squareImage = {nftCD.squareImage.file.uri() : nftCD.squareImage.mediaType}\n        self.squareImage = squareImage\n\n        let bannerImage = {nftCD.bannerImage.file.uri() : nftCD.bannerImage.mediaType}\n        self.bannerImage = bannerImage\n\n        let socials : {String : String} = {}\n        for key in nftCD.socials.keys{\n            socials[key] = nftCD.socials[key]!.url\n        }\n        self.socials = socials\n    }\n}\n\n/*\npub struct StorefrontListing {\n    pub let nftID:UInt64\n    pub let nftIdentifier: String\n    pub let saleCut: [StoreFrontCut]\n    pub let amount:UFix64\n    pub let ftTypeIdentifier:String\n    pub let storefront:UInt64\n    pub let listingID:UInt64\n\n    init(listingId:UInt64, details: NFTStorefront.ListingDetails) {\n\n        self.saleCut=[]\n        self.nftID=details.nftID\n        self.nftIdentifier=details.nftType.identifier\n        for cutDetails in details.saleCuts {\n            self.saleCut.append(StoreFrontCut(amount:cutDetails.amount, address:cutDetails.receiver.address))\n        }\n        self.amount=details.salePrice\n        self.ftTypeIdentifier=details.salePaymentVaultType.identifier\n        self.storefront=details.storefrontID\n        self.listingID=listingId\n    }\n}\n*/\n\npub var counter = 0\n\npub fun main(user: String, project:String, id: UInt64, views: [String]) : NFTDetailReport?{\n    let resolveAddress = FIND.resolve(user) \n    if resolveAddress == nil {\n        return nil\n    }\n    let address = resolveAddress!\n\n    let account = getAuthAccount(address) \n\n    if account.balance \u003e 0.0 {\n        // check link for market\n        let linkedForMarket = account.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(getPublicPath(project)).check()\n\n        let storagePath = getStoragePath(project)\n        let publicPath = PublicPath(identifier: \"find_temp_path_\".concat(counter.toString()))!\n        counter = counter + 1\n        account.link\u003c\u0026{MetadataViews.ResolverCollection}\u003e(publicPath, target: storagePath)\n        let cap = account.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(publicPath)\n        if !cap.check() {\n            panic(\"The user does not set up collection correctly.\")\n        }\n        let pointer = FindViews.ViewReadPointer(cap: cap, id: id)\n\n        let nftDetail = getNFTDetail(pointer:pointer, views: views)\n        if nftDetail == nil {\n            return nil\n        }\n\n\n        let findAddress=FindMarket.getFindTenantAddress()\n        let findMarket=FindMarket.getNFTListing(tenant:findAddress, address: address, id: nftDetail!.uuid, getNFTInfo:false)\n\n        /*\n        var listings : StorefrontListing? = nil\n        let storefrontCap = account.getCapability\u003c\u0026NFTStorefront.Storefront{NFTStorefront.StorefrontPublic}\u003e(NFTStorefront.StorefrontPublicPath)\n\n        if storefrontCap.check() {\n            let storefrontRef=storefrontCap.borrow()!\n            for listingId in storefrontRef.getListingIDs() {\n                let listing = storefrontRef.borrowListing(listingResourceID: listingId)!\n                let nft=listing.borrowNFT()\n                if nft.id==id \u0026\u0026 !listing.getDetails().purchased {\n                    listings = StorefrontListing(listingId: listingId, details: listing.getDetails())\n                }\n            }\n        }\n        */\n\n        var report : {String : ListingTypeReport} = {}\n\n        // check if that's soulBound, if yes, the report will be nil\n        if !pointer.checkSoulBound() {\n            let tenantCap = FindMarket.getTenantCapability(findAddress)!\n            let tenantRef = tenantCap.borrow() ?? panic(\"This tenant is not set up. Tenant : \".concat(tenantCap.address.toString()))\n\n            let marketTypes = FindMarket.getSaleItemTypes()\n\n            for marketType in marketTypes {\n                if let allowedListing = tenantRef.getAllowedListings(nftType: pointer.getItemType(), marketType: marketType) {\n                    report[FindMarket.getMarketOptionFromType(marketType)] = createListingTypeReport(allowedListing, pointer: pointer, tenantRef: tenantRef)\n                }\n            }\n        }\n        return NFTDetailReport(findMarket:findMarket, storefront:nil, nftDetail: nftDetail, allowedListingActions: report, linkedForMarket : linkedForMarket)\n    }\n    return nil\n\n}\n\npub let resolvedAddresses : {Address : String} = {}\n\npub var nftRoyalties : [Royalties]? = nil\n\npub fun reverseLookup(_ addr: Address) : String? {\n\n    if let name = resolvedAddresses[addr] {\n        if name == \"\" {\n            return nil\n        } else {\n            return name\n        }\n    }\n    let name = FIND.reverseLookup(addr) \n    if name == nil {\n        resolvedAddresses[addr] = \"\"\n    } else {\n        resolvedAddresses[addr] = name\n    }\n    return name\n\n}\n\npub fun getNFTDetail(pointer: FindViews.ViewReadPointer, views: [String]) : NFTDetail? {\n\n    if !pointer.valid() {\n        return nil\n    }\n\n    var nftViews: {String : AnyStruct} = {}\n    var resolvedViews: [Type] = []\n    let viewResolver = pointer.getViewResolver()\n\n    let defaultViews = defaultViews()\n    for view in views {\n        if let runTimeType = CompositeType(view) {\n            if !defaultViews.contains(runTimeType) {\n                defaultViews.append(runTimeType)\n            }\n        }\n    }\n\n\n    for runTimeType in defaultViews {\n        // Resolve arrayed views to ensure we didn't miss any stuff \n        if runTimeType == Type\u003cMetadataViews.Editions\u003e() {\n            if let editions = MetadataViews.getEditions(viewResolver) {\n                if let edition = getEdition(viewResolver) {\n                    var check = false\n                    for item in editions.infoList {\n                        if item.name == edition.name \u0026\u0026 item.number == edition.number \u0026\u0026 item.max == edition.max {\n                            check = true\n                            break\n                        }\n                    }\n                    // If the edition does not exist in editions, add it in\n                    if !check {\n                        let array = editions.infoList \n                        array.append(edition)\n                        nftViews[\"Editions\"] = MetadataViews.Editions(array)\n                        resolvedViews.append(runTimeType)\n                        continue\n                    }\n                } \n                // If edition does not exist OR edition is already in editions , append it to views and continue\n                nftViews[\"Editions\"] = editions\n                resolvedViews.append(runTimeType)\n                continue\n            }\n        }\n\n        if runTimeType == Type\u003cMetadataViews.Edition\u003e() {\n            // If the editions does not exist, check if there is edition, if there is, add it in as editions\n            if nftViews[\"Editions\"] == nil {\n                if let edition = getEdition(viewResolver) {\n                    nftViews[\"Editions\"] = MetadataViews.Editions([edition])\n                    resolvedViews.append(runTimeType)\n                }\n            } \n            continue\n        }\n\n        if runTimeType == Type\u003cMetadataViews.Medias\u003e() {\n            if let medias = MetadataViews.getMedias(viewResolver) {\n                if let media = getMedia(viewResolver) {\n                    var check = false \n                    let uri = media.file.uri()\n                    for item in medias.items {\n                        if item.file.uri() == uri {\n                            check = true \n                            break\n                        }\n                        if !check {\n                            let array = medias.items\n                            array.append(media)\n                            nftViews[\"Medias\"] = MetadataViews.Medias(array)\n                            resolvedViews.append(runTimeType)\n                            continue\n                        }\n                    }\n                } \n                nftViews[\"Medias\"] = medias\n                resolvedViews.append(runTimeType)\n                continue\n            }\n        }\n\n        if runTimeType == Type\u003cMetadataViews.Media\u003e() {\n            if nftViews[\"Medias\"] == nil {\n                if let media = getMedia(viewResolver) {\n                    nftViews[\"Medias\"] = MetadataViews.Medias([media])\n                    resolvedViews.append(runTimeType)\n                }\n            }\n            continue\n        }\n\n        if runTimeType == Type\u003cMetadataViews.Traits\u003e() {\n            if let traits = MetadataViews.getTraits(viewResolver) {\n                if let trait = getTrait(viewResolver) {\n                    var check = false \n                    for item in traits.traits {\n                        if item.name == trait.name {\n                            check = true \n                            break\n                        }\n                        if !check {\n                            let array = traits.traits\n                            array.append(trait)\n\n                            nftViews[\"Traits\"] = cleanUpTraits(array)\n                            resolvedViews.append(runTimeType)\n                            continue\n                        }\n                    }\n                } \n                nftViews[\"Traits\"] = cleanUpTraits(traits.traits)\n                resolvedViews.append(runTimeType)\n                continue\n            }\n        }\n\n        if runTimeType == Type\u003cMetadataViews.Trait\u003e() {\n            if nftViews[\"Traits\"] == nil {\n                if let trait = getTrait(viewResolver) {\n                    nftViews[\"Traits\"] = MetadataViews.Traits([trait])\n                    resolvedViews.append(runTimeType)\n                }\n            } \n            continue\n        }\n\n        if let view = pointer.resolveView(runTimeType) {\n            nftViews[runTimeType.identifier.slice(from: \"A.1d7e57aa55817448.MetadataViews.\".length, upTo: runTimeType.identifier.length)] = view\n            resolvedViews.append(runTimeType)\n        }\n    }\n    \n    return NFTDetail(pointer, views: nftViews, resolvedViews: resolvedViews)\n\n\n}\n\npub fun getEdition(_ viewResolver: \u0026{MetadataViews.Resolver}) : MetadataViews.Edition? {\n    if let view = viewResolver.resolveView(Type\u003cMetadataViews.Edition\u003e()) {\n        if let v = view as? MetadataViews.Edition {\n            return v\n        }\n    }\n    return nil\n}\n\npub fun getMedia(_ viewResolver: \u0026{MetadataViews.Resolver}) : MetadataViews.Media? {\n    if let view = viewResolver.resolveView(Type\u003cMetadataViews.Media\u003e()) {\n        if let v = view as? MetadataViews.Media {\n            return v\n        }\n    }\n    return nil\n}\n\npub fun getTrait(_ viewResolver: \u0026{MetadataViews.Resolver}) : MetadataViews.Trait? {\n    if let view = viewResolver.resolveView(Type\u003cMetadataViews.Trait\u003e()) {\n        if let v = view as? MetadataViews.Trait {\n            return v\n        }\n    }\n    return nil\n}\n\n/* Helper Function */\npub fun resolveRoyalties(_ pointer: FindViews.ViewReadPointer) : [Royalties] {\n    let array : [Royalties] = []\n    for royalty in pointer.getRoyalty().getRoyalties() {\n        let address = royalty.receiver.address\n        array.append(Royalties(royaltyName: royalty.description, address: address, findName: reverseLookup(address), cut: royalty.cut))\n    }\n\n    return array\n}\n\npub fun resolveFindRoyalties(tenantRef: \u0026FindMarket.Tenant{FindMarket.TenantPublic}, listing: Type, nft: Type, ft: Type) : [Royalties] {\n\n    let cuts = tenantRef.getTenantCut(name:\"\", listingType: listing, nftType:nft, ftType:ft)\n\n    let royalties :[Royalties] = []\n    if cuts.findCut != nil {\n        royalties.append(Royalties(royaltyName: cuts.findCut!.description, address: cuts.findCut!.receiver.address, findName: reverseLookup(cuts.findCut!.receiver.address), cut: cuts.findCut!.cut))\n    }\n\n    if cuts.tenantCut != nil {\n        royalties.append(Royalties(royaltyName: cuts.tenantCut!.description, address: cuts.tenantCut!.receiver.address, findName: reverseLookup(cuts.tenantCut!.receiver.address), cut: cuts.tenantCut!.cut))\n    }\n    \n    return royalties\n}\n\npub fun createListingTypeReport(_ allowedListing: FindMarket.AllowedListing, pointer: FindViews.ViewReadPointer, tenantRef: \u0026FindMarket.Tenant{FindMarket.TenantPublic}) : ListingTypeReport {\n    let listingType = allowedListing.listingType.identifier\n    var ftAlias : [String] = []\n    var ftIdentifier : [String] = []\n    var listingDetails : [ListingRoyalties] = []\n    for ft in allowedListing.ftTypes {\n        ftIdentifier.append(ft.identifier)\n        var alias : String? = nil\n        if let ftInfo = FTRegistry.getFTInfo(ft.identifier) {\n            alias = ftInfo.alias\n            ftAlias.append(ftInfo.alias)\n        }\n\n        // getRoyalties \n        var nftR = nftRoyalties \n        if nftR == nil {\n            nftRoyalties = resolveRoyalties(pointer)\n            nftR = nftRoyalties\n        }\n\n        let findR = resolveFindRoyalties(tenantRef: tenantRef, listing: allowedListing.listingType , nft: pointer.getItemType(), ft: ft)\n        findR.appendAll(nftR!)\n\n        listingDetails.append(ListingRoyalties(ftAlias: alias, ftIdentifier: ft.identifier, royalties: findR))\n    }\n    \n    return ListingTypeReport(listingType: listingType, ftAlias: ftAlias, ftIdentifiers: ftIdentifier,  status: allowedListing.status , ListingDetails: listingDetails)\n}\n\npub fun defaultViews() : [Type] {\n    return [\n    Type\u003cMetadataViews.Display\u003e() ,\n    Type\u003cMetadataViews.Editions\u003e() , \n    Type\u003cMetadataViews.Edition\u003e() ,\n    Type\u003cMetadataViews.Serial\u003e() , \n    Type\u003cMetadataViews.Medias\u003e() ,\n    Type\u003cMetadataViews.Media\u003e() ,\n    Type\u003cMetadataViews.License\u003e() , \n    Type\u003cMetadataViews.ExternalURL\u003e() , \n    Type\u003cMetadataViews.NFTCollectionDisplay\u003e() , \n    Type\u003cMetadataViews.Traits\u003e() , \n    Type\u003cMetadataViews.Trait\u003e() ,\n    Type\u003cMetadataViews.Rarity\u003e() \n    ]\n}\n\npub fun getStoragePath(_ nftIdentifier: String) : StoragePath {\n    if let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys {\n        let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n        return collection.collectionData.storagePath\n    }\n\n    if let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier :nftIdentifier) {\n        return collection.collectionData.storagePath\n    }\n    panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier)) \n}\n\npub fun getPublicPath(_ nftIdentifier: String) : PublicPath {\n    if let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys {\n        let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n        return collection.collectionData.publicPath\n    }\n\n    if let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier :nftIdentifier) {\n        return collection.collectionData.publicPath\n    }\n    panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier)) \n}\n\npub fun cleanUpTraits(_ traits: [MetadataViews.Trait]) : MetadataViews.Traits {\n    let dateValues  = {\"Date\" : true, \"Numeric\":false, \"Number\":false, \"date\":true, \"numeric\":false, \"number\":false}\n\n    let array : [MetadataViews.Trait] = []\n\n    for i , trait in traits {\n        let displayType = trait.displayType ?? \"string\"\n        if let isDate = dateValues[displayType] {\n            if isDate {\n                array.append(MetadataViews.Trait(name: trait.name, value: trait.value, displayType: \"Date\", rarity: trait.rarity))\n            } else {\n                array.append(MetadataViews.Trait(name: trait.name, value: trait.value, displayType: \"Numeric\", rarity: trait.rarity))\n            }\n        } else {\n            if let value = trait.value as? Bool {\n                if value {\n                    array.append(MetadataViews.Trait(name: trait.name, value: trait.value, displayType: \"Bool\", rarity: trait.rarity))\n                }else {\n                    array.append(MetadataViews.Trait(name: trait.name, value: trait.value, displayType: \"Bool\", rarity: trait.rarity))\n                }\n            } else if let value = trait.value as? String {\n                array.append(MetadataViews.Trait(name: trait.name, value: trait.value, displayType: \"String\", rarity: trait.rarity))\n            } else {\n                array.append(MetadataViews.Trait(name: trait.name, value: trait.value, displayType: \"String\", rarity: trait.rarity))\n            }\n        }\n    }\n    return MetadataViews.Traits(array)\n}",
               "spec": {
                  "order": [
                     "user",
                     "project",
                     "id",
                     "views"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "project": "String",
                     "user": "String",
                     "views": "[String]"
                  }
               }
            },
            "getNFTDetailsShard1": {
               "code": "import FIND from 0x097bafa4e0b48eef\nimport AlchemyMetadataWrapperMainnetShard1 from 0xeb8cb4c3157d5dac\n\npub fun main(user: String , project: String, id: UInt64, views: [String]) : AlchemyMetadataWrapperMainnetShard1.NFTData? {\n\n    if let address = FIND.resolve(user) {\n        let ids : {String:[UInt64]} = {project : [id]}\n        let res = AlchemyMetadataWrapperMainnetShard1.getNFTs(ownerAddress: address, ids: ids)\n        if res.length == 0 || res[0] == nil {\n            return nil\n        }\n        return res[0]!\n    }\n    return nil\n\n}",
               "spec": {
                  "order": [
                     "user",
                     "project",
                     "id",
                     "views"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "project": "String",
                     "user": "String",
                     "views": "[String]"
                  }
               }
            },
            "getNFTDetailsShard2": {
               "code": "import FIND from 0x097bafa4e0b48eef\nimport AlchemyMetadataWrapperMainnetShard2 from 0xeb8cb4c3157d5dac\n\npub fun main(user: String , project: String, id: UInt64, views: [String]) : AlchemyMetadataWrapperMainnetShard2.NFTData? {\n\n    if let address = FIND.resolve(user) {\n        let ids : {String:[UInt64]} = {project : [id]}\n        let res = AlchemyMetadataWrapperMainnetShard2.getNFTs(ownerAddress: address, ids: ids)\n        if res.length == 0 || res[0] == nil {\n            return nil\n        }\n        return res[0]!\n    }\n    return nil\n\n}",
               "spec": {
                  "order": [
                     "user",
                     "project",
                     "id",
                     "views"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "project": "String",
                     "user": "String",
                     "views": "[String]"
                  }
               }
            },
            "getNFTDetailsShard3": {
               "code": "import FIND from 0x097bafa4e0b48eef\nimport AlchemyMetadataWrapperMainnetShard3 from 0xeb8cb4c3157d5dac\n\npub fun main(user: String , project: String, id: UInt64, views: [String]) : AlchemyMetadataWrapperMainnetShard3.NFTData? {\n\n    if let address = FIND.resolve(user) {\n        let ids : {String:[UInt64]} = {project : [id]}\n        let res = AlchemyMetadataWrapperMainnetShard3.getNFTs(ownerAddress: address, ids: ids)\n        if res.length == 0 || res[0] == nil {\n            return nil\n        }\n        return res[0]!\n    }\n    return nil\n\n}",
               "spec": {
                  "order": [
                     "user",
                     "project",
                     "id",
                     "views"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "project": "String",
                     "user": "String",
                     "views": "[String]"
                  }
               }
            },
            "getNFTDetailsShard4": {
               "code": "import FIND from 0x097bafa4e0b48eef\nimport AlchemyMetadataWrapperMainnetShard4 from 0xeb8cb4c3157d5dac\n\npub fun main(user: String , project: String, id: UInt64, views: [String]) : AlchemyMetadataWrapperMainnetShard4.NFTData? {\n\n    if let address = FIND.resolve(user) {\n        let ids : {String:[UInt64]} = {project : [id]}\n        let res = AlchemyMetadataWrapperMainnetShard4.getNFTs(ownerAddress: address, ids: ids)\n        if res.length == 0 || res[0] == nil {\n            return nil\n        }\n        return res[0]!\n    }\n    return nil\n\n}",
               "spec": {
                  "order": [
                     "user",
                     "project",
                     "id",
                     "views"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "project": "String",
                     "user": "String",
                     "views": "[String]"
                  }
               }
            },
            "getNFTDetailsSocks": {
               "code": "import FIND from 0x097bafa4e0b48eef\nimport RaribleNFT from 0x01ab36aaf654a13e\n\npub fun main(user: String , project: String, id: UInt64, views: [String]) : NFTData? {\n\n    if let address = FIND.resolve(user) {\n        if let uuid = getSocks(ownerAddress: address, id: id) {\n\n            let contract = NFTContractData(\n                name: \"RaribleNFT\",\n                address: 0x01ab36aaf654a13e,\n                storage_path: \"/storage/RaribleNFTCollection\",\n                public_path: \"/public/RaribleNFTCollection\",\n                public_collection_name: \"CollectionPublic\",\n                external_domain: \"https://rarible.com/\"\n            )\n\n            return NFTData(\n                contract: contract,\n                id: id,\n                uuid: uuid,\n                title: \"Flowverse socks\",\n                description: \"Socks by Flowverse NFTs were designed by NYC-based metaverse artist Jenny Jiang. The 111 Socks were then distributed to some of the earliest, most committed and most engaged Flowverse community members for Christmas 2021.\",\n                external_domain_view_url: nil,\n                token_uri: nil,\n                media: [\n                    NFTMedia(uri: \"https://img.rarible.com/prod/video/upload/t_video_big/prod-itemAnimations/FLOW-A.01ab36aaf654a13e.RaribleNFT:15029/b1cedf3\", mimetype: \"video\")\n                ],\n                metadata: {}\n            )\n        }\n    }\n    return nil\n\n}\n\npub fun getSocks(ownerAddress: Address, id: UInt64) : UInt64? {\n\n    let account = getAuthAccount(ownerAddress)\n    let ref = account.borrow\u003c\u0026RaribleNFT.Collection\u003e(from: RaribleNFT.collectionStoragePath)\n    if ref != nil {\n        let nfts = ref!\n        if nfts.ownedNFTs.containsKey(id) {\n            return ref!.borrowNFT(id: id).uuid\n        }\n    }\n    \n    return nil\n}\n\npub let FlowverseSocksIds : [UInt64] = [14813, 15013, 14946, 14808, 14899, 14792, 15016, 14961, 14816, 14796, 14992, 14977, 14815, 14863, 14817, 14814, 14875, 14960, 14985, 14850, 14849, 14966, 14826, 14972, 14795, 15021, 14950, 14847, 14970, 14833, 14786, 15010, 14953, 14799, 14883, 14947, 14844, 14801, 14886, 15015, 15023, 15027, 15029, 14802, 14810, 14948, 14955, 14957, 14988, 15007, 15009, 14837, 15024, 14803, 14973, 14969, 15002, 15017, 14797, 14894, 14881, 15025, 14791, 14979, 14789, 14993, 14873, 14939, 15005, 15006, 14869, 14889, 15004, 15008, 15026, 14990, 14998, 14898, 14819, 14840, 14974, 15019, 14856, 14838, 14787, 14876, 14996, 14798, 14855, 14824, 14843, 14959, 15020, 14862, 14822, 14897, 14830, 14790, 14867, 14878, 14991, 14835, 14818, 14892, 14800, 15000, 14857, 14986, 14805, 14812, 14962]\n\npub struct NFTData {\n    pub let contract: NFTContractData\n    pub let id: UInt64\n    pub let uuid: UInt64?\n    pub let title: String?\n    pub let description: String?\n    pub let external_domain_view_url: String?\n    pub let token_uri: String?\n    pub let media: [NFTMedia?]\n    pub let metadata: {String: String?}\n\n    init(\n        contract: NFTContractData,\n        id: UInt64,\n        uuid: UInt64?,\n        title: String?,\n        description: String?,\n        external_domain_view_url: String?,\n        token_uri: String?,\n        media: [NFTMedia?],\n        metadata: {String: String?}\n    ) {\n        self.contract = contract\n        self.id = id\n        self.uuid = uuid\n        self.title = title\n        self.description = description\n        self.external_domain_view_url = external_domain_view_url\n        self.token_uri = token_uri\n        self.media = media\n        self.metadata = metadata\n    }\n}\n\npub struct NFTContractData {\n    pub let name: String\n    pub let address: Address\n    pub let storage_path: String\n    pub let public_path: String\n    pub let public_collection_name: String\n    pub let external_domain: String\n\n    init(\n        name: String,\n        address: Address,\n        storage_path: String,\n        public_path: String,\n        public_collection_name: String,\n        external_domain: String\n    ) {\n        self.name = name\n        self.address = address\n        self.storage_path = storage_path\n        self.public_path = public_path\n        self.public_collection_name = public_collection_name\n        self.external_domain = external_domain\n    }\n}\n\npub struct NFTMedia {\n    pub let uri: String?\n    pub let mimetype: String?\n\n    init(\n        uri: String?,\n        mimetype: String?\n    ) {\n        self.uri = uri\n        self.mimetype = mimetype\n    }\n}",
               "spec": {
                  "order": [
                     "user",
                     "project",
                     "id",
                     "views"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "project": "String",
                     "user": "String",
                     "views": "[String]"
                  }
               }
            },
            "getNFTIds": {
               "code": "import NonFungibleToken from 0x1d7e57aa55817448\nimport GooberXContract from 0x34f2bf4a80bb0f69\n\nimport SturdyItems from 0x427ceada271aa0b1\nimport UFC_NFT from 0x329feb3ab062d289\n\nimport Gaia from 0x8b148183c28ff88f\n\nimport MatrixWorldFlowFestNFT from 0x2d2750f240198f91\nimport DGD_NFT from 0x329feb3ab062d289\nimport The_Next_Cartel_NFT from 0x329feb3ab062d289\nimport OneFootballCollectible from 0x6831760534292098\nimport MatrixWorldAssetsNFT from 0xf20df769e658c257\nimport Necryptolis from 0x718efe5e88fe48ea\nimport RareRooms_NFT from 0x329feb3ab062d289\nimport CNN_NFT from 0x329feb3ab062d289\nimport Evolution from 0xf4264ac8f3256818\nimport MintStoreItem from 0x20187093790b9aef\nimport MotoGPCard from 0xa49cc0ee46c54bfb\nimport SomePlaceCollectible from 0x667a16294a089ef8\nimport Canes_Vault_NFT from 0x329feb3ab062d289\nimport RaceDay_NFT from 0x329feb3ab062d289\nimport GeniaceNFT from 0xabda6627c70c7f52\nimport GoatedGoats from 0x2068315349bdfce5\nimport HaikuNFT from 0xf61e40c19db2a9e2\nimport KlktnNFT from 0xabd6e80be7e9682c\nimport Mynft from 0xf6fcbef550d97aa5\nimport BarterYardPackNFT from 0xa95b021cf8a30d80\nimport Moments from 0xd4ad4740ee426334\nimport CryptoPiggo from 0xd3df824bf81910a4\nimport GoatedGoatsVouchers from 0xdfc74d9d561374c0\nimport TraitPacksVouchers from 0xdfc74d9d561374c0\nimport GoatedGoatsTrait from 0x2068315349bdfce5\nimport GoatedGoatsTraitPack from 0x2068315349bdfce5\nimport Art from 0xd796ff17107bbff6\nimport Marketplace from 0xd796ff17107bbff6\nimport Flovatar from 0x921ea449dffec68a\nimport FlovatarMarketplace from  0x921ea449dffec68a\nimport CharityNFT from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\n\n\nimport NeoAvatar from 0xb25138dbf45e5801\nimport NeoVoucher from 0xb25138dbf45e5801\nimport NeoMember from 0xb25138dbf45e5801\nimport NeoViews from 0xb25138dbf45e5801\nimport MetadataViews from 0x1d7e57aa55817448\nimport BarterYardClubWerewolf from  0x28abb9f291cadaf2\n\n//Jambb\nimport Vouchers from 0x444f5ea22c6ea12c\n\n//xtingles\nimport Collectible from 0xf5b0eb433389ac3f\n\nimport Momentables from 0x9d21537544d9123d\nimport ZeedzINO from 0x62b3063fbe672fc8\nimport PartyMansionDrinksContract from 0x34f2bf4a80bb0f69\n\nimport DayNFT from 0x1600b04bf033fb99\nimport RaribleNFT from 0x01ab36aaf654a13e\n\nimport FLOAT from 0x2d4c3caffbeab845\n\nimport Bl0x from 0x7620acf6d7f2468a\nimport Bl0xPack from 0x7620acf6d7f2468a\n\n\npub fun getNFTIDs(ownerAddress: Address): {String: [UInt64]} {\n    let account = getAccount(ownerAddress)\n    if account.balance == 0.0 {\n        return {}\n    }\n    let ids: {String: [UInt64]} = {}\n\n\n    let flovatarCap = account.getCapability\u003c\u0026{Flovatar.CollectionPublic}\u003e(Flovatar.CollectionPublicPath)  \n    if flovatarCap.check() {\n        ids[\"Flovatar\"]=flovatarCap.borrow()!.getIDs()\n    }\n\n    let flovatarMarketCap = account.getCapability\u003c\u0026{FlovatarMarketplace.SalePublic}\u003e(FlovatarMarketplace.CollectionPublicPath)\n    if flovatarMarketCap.check() {\n        ids[\"FlovatarForSale\"]=flovatarMarketCap.borrow()!.getFlovatarIDs()\n    }\n\n    let versusMarketplace = account.getCapability\u003c\u0026{Marketplace.SalePublic}\u003e(Marketplace.CollectionPublicPath)\n    if versusMarketplace.check() {\n        ids[\"VersusForSale\"]=versusMarketplace.borrow()!.getIDs()\n    }\n\n    let versusArtCap=account.getCapability\u003c\u0026{Art.CollectionPublic}\u003e(Art.CollectionPublicPath)\n    if versusArtCap.check() {\n        ids[\"Versus\"]=versusArtCap.borrow()!.getIDs()\n    }\n\n    let goobersCap = account.getCapability\u003c\u0026GooberXContract.Collection{NonFungibleToken.CollectionPublic, GooberXContract.GooberCollectionPublic}\u003e(GooberXContract.CollectionPublicPath)\n    if goobersCap.check() {\n        ids[\"Gooberz\"] = goobersCap.borrow()!.getIDs()\n    }\n\n    let partyMansionDrinksCap = account.getCapability\u003c\u0026{PartyMansionDrinksContract.DrinkCollectionPublic}\u003e(PartyMansionDrinksContract.CollectionPublicPath)\n    if partyMansionDrinksCap.check() {\n        ids[\"PartyMansionDrinksContract\"] = partyMansionDrinksCap.borrow()!.getIDs()\n    }\n\n    let rareRoomCap = account.getCapability\u003c\u0026RareRooms_NFT.Collection{RareRooms_NFT.RareRooms_NFTCollectionPublic}\u003e(RareRooms_NFT.CollectionPublicPath)\n    if rareRoomCap.check() {\n        ids[\"RareRooms\"] = rareRoomCap.borrow()!.getIDs()\n    }\n\n    let cnnCap = account.getCapability\u003c\u0026CNN_NFT.Collection{CNN_NFT.CNN_NFTCollectionPublic}\u003e(CNN_NFT.CollectionPublicPath)\n    if cnnCap.check() {\n        ids[\"CNN\"] = cnnCap.borrow()!.getIDs()\n    }\n\n    let canesVaultCap = account.getCapability\u003c\u0026Canes_Vault_NFT.Collection{Canes_Vault_NFT.Canes_Vault_NFTCollectionPublic}\u003e(Canes_Vault_NFT.CollectionPublicPath)\n    if canesVaultCap.check() {\n        ids[\"Canes_Vault_NFT\"] = canesVaultCap.borrow()!.getIDs()\n    }\n    let dgdCap = account.getCapability\u003c\u0026DGD_NFT.Collection{DGD_NFT.DGD_NFTCollectionPublic}\u003e(DGD_NFT.CollectionPublicPath)\n    if dgdCap.check() {\n        ids[\"DGD_NFT\"] = dgdCap.borrow()!.getIDs()\n    }\n\n    let raceDayCap = account.getCapability\u003c\u0026RaceDay_NFT.Collection{RaceDay_NFT.RaceDay_NFTCollectionPublic}\u003e(RaceDay_NFT.CollectionPublicPath)\n    if raceDayCap.check() {\n        ids[\"RaceDay_NFT\"] = raceDayCap.borrow()!.getIDs()\n    }\n\n    let nextCartelCap = account.getCapability\u003c\u0026The_Next_Cartel_NFT.Collection{The_Next_Cartel_NFT.The_Next_Cartel_NFTCollectionPublic}\u003e(The_Next_Cartel_NFT.CollectionPublicPath)\n    if nextCartelCap.check() {\n        ids[\"The_Next_Cartel_NFT\"] = nextCartelCap.borrow()!.getIDs()\n    }\n    let ufcCap = account.getCapability\u003c\u0026UFC_NFT.Collection{UFC_NFT.UFC_NFTCollectionPublic}\u003e(UFC_NFT.CollectionPublicPath)\n    if ufcCap.check() {\n        ids[\"UFC\"] = ufcCap.borrow()!.getIDs()\n    }\n\n    let motoGPCollectionCap = account.getCapability\u003c\u0026MotoGPCard.Collection{MotoGPCard.ICardCollectionPublic}\u003e(/public/motogpCardCollection)\n    if motoGPCollectionCap.check() {\n        ids[\"MotoGPCard\"] = motoGPCollectionCap.borrow()!.getIDs()\n    }\n\n    let gaiaCap = account.getCapability\u003c\u0026{Gaia.CollectionPublic}\u003e(Gaia.CollectionPublicPath)\n    if gaiaCap.check() {\n        ids[\"Gaia\"] = gaiaCap.borrow()!.getIDs()\n    }\n\n    let jambbCap = account.getCapability\u003c\u0026Moments.Collection{Moments.CollectionPublic}\u003e(Moments.CollectionPublicPath)\n    if jambbCap.check() {\n        ids[\"Jambb\"] = jambbCap.borrow()!.getIDs()\n    }\n    let voucherCap = account.getCapability\u003c\u0026{Vouchers.CollectionPublic}\u003e(Vouchers.CollectionPublicPath)\n    if voucherCap.check() {\n        ids[\"JambbVoucher\"] = voucherCap.borrow()!.getIDs()\n    }\n\n    let mwaCap = account.getCapability\u003c\u0026{MatrixWorldAssetsNFT.Metadata, NonFungibleToken.CollectionPublic}\u003e(MatrixWorldAssetsNFT.collectionPublicPath)\n    if mwaCap.check() {\n        ids[\"MatrixWorldAssetsNFT\"] = mwaCap.borrow()!.getIDs()\n    }\n\n    let mwffCap = account.getCapability\u003c\u0026{MatrixWorldFlowFestNFT.MatrixWorldFlowFestNFTCollectionPublic}\u003e(MatrixWorldFlowFestNFT.CollectionPublicPath)\n    if mwffCap.check() {\n        ids[\"MatrixWorldFlowFest\"] = mwffCap.borrow()!.getIDs()\n    }\n\n    let sturdyCap = account.getCapability\u003c\u0026SturdyItems.Collection{SturdyItems.SturdyItemsCollectionPublic}\u003e(SturdyItems.CollectionPublicPath)\n    if sturdyCap.check() {\n        ids[\"SturdyItems\"] = sturdyCap.borrow()!.getIDs()\n    }\n\n    let charityCap = account.getCapability\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection)\n    if charityCap.check() {\n        ids[\"FindCharity\"] = charityCap.borrow()!.getIDs()\n    }\n\n    let evolutionCap=account.getCapability\u003c\u0026{Evolution.EvolutionCollectionPublic}\u003e(/public/f4264ac8f3256818_Evolution_Collection)\n    if evolutionCap.check() {\n        ids[\"Evolution\"] = evolutionCap.borrow()!.getIDs()\n    }\n\n    let geniaceCap = account.getCapability\u003c\u0026GeniaceNFT.Collection{NonFungibleToken.CollectionPublic, GeniaceNFT.GeniaceNFTCollectionPublic}\u003e(GeniaceNFT.CollectionPublicPath)\n    if geniaceCap.check() {\n        ids[\"GeniaceNFT\"] = geniaceCap.borrow()!.getIDs()\n    }\n\n    let ofCap = account.getCapability\u003c\u0026OneFootballCollectible.Collection{OneFootballCollectible.OneFootballCollectibleCollectionPublic}\u003e(OneFootballCollectible.CollectionPublicPath)\n    if ofCap.check() {\n        ids[\"OneFootballCollectible\"] = ofCap.borrow()!.getIDs()\n    }\n\n    let cryptoPiggoCap = account.getCapability\u003c\u0026{CryptoPiggo.CryptoPiggoCollectionPublic}\u003e(CryptoPiggo.CollectionPublicPath)\n    if cryptoPiggoCap.check() {\n        ids[\"CryptoPiggo\"] = cryptoPiggoCap.borrow()!.getIDs()\n    }\n\n    let xtinglesCap= account.getCapability\u003c\u0026{Collectible.CollectionPublic}\u003e(Collectible.CollectionPublicPath)\n    if xtinglesCap.check() {\n        ids[\"Xtingles\"] = xtinglesCap.borrow()!.getIDs()\n    }\n\n    let goatsVoucherCap = account.getCapability\u003c\u0026{GoatedGoatsVouchers.GoatsVoucherCollectionPublic}\u003e(GoatedGoatsVouchers.CollectionPublicPath)\n    if goatsVoucherCap.check() {\n        ids[\"GoatedGoatsVoucher\"] = goatsVoucherCap.borrow()!.getIDs()\n    }\n\n    let goatsTraitVoucherCap = account.getCapability\u003c\u0026{TraitPacksVouchers.PackVoucherCollectionPublic}\u003e(TraitPacksVouchers.CollectionPublicPath)\n    if goatsTraitVoucherCap.check() {\n        ids[\"GoatedGoatsTraitVoucher\"] = goatsTraitVoucherCap.borrow()!.getIDs()\n    }\n\n    let goatsCap = account.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(GoatedGoats.CollectionPublicPath)\n    if goatsCap.check() {\n        ids[\"GoatedGoats\"] = goatsCap.borrow()!.getIDs()\n    }\n\n    let goatsTraitCap = account.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(GoatedGoatsTrait.CollectionPublicPath)\n    if goatsTraitCap.check() {\n        ids[\"GoatedGoatsTrait\"] = goatsTraitCap.borrow()!.getIDs()\n    }\n\n    let goatsTraitPackCap = account.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(GoatedGoatsTraitPack.CollectionPublicPath)\n    if goatsTraitPackCap.check() {\n        ids[\"GoatedGoatsTraitPack\"] = goatsTraitPackCap.borrow()!.getIDs()\n    }\n\n\n    let bitkuCap = account.getCapability\u003c\u0026{HaikuNFT.HaikuCollectionPublic}\u003e(HaikuNFT.HaikuCollectionPublicPath)\n    if bitkuCap.check() {\n        ids[\"Bitku\"] = bitkuCap.borrow()!.getIDs()\n    }\n\n    let klktnCap = account.getCapability\u003c\u0026{KlktnNFT.KlktnNFTCollectionPublic}\u003e(KlktnNFT.CollectionPublicPath)\n    if klktnCap.check() {\n        ids[\"KLKTN\"] = klktnCap.borrow()!.getIDs()\n    }\n\n    let mynftCap = account.getCapability\u003c\u0026{Mynft.MynftCollectionPublic}\u003e(Mynft.CollectionPublicPath)\n    if mynftCap.check() {\n        ids[\"Mynft\"] = mynftCap.borrow()!.getIDs()\n    }\n\n    let neoAvatarCap = account.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(NeoAvatar.CollectionPublicPath)\n    if neoAvatarCap.check() {\n        ids[\"NeoAvatar\"] = neoAvatarCap.borrow()!.getIDs()\n    }\n\n    let neoVoucherCap = account.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(NeoVoucher.CollectionPublicPath)\n    if neoVoucherCap.check() {\n        ids[\"NeoVoucher\"] = neoVoucherCap.borrow()!.getIDs()\n    }\n\n    let neoMemberCap = account.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(NeoMember.CollectionPublicPath)\n    if neoMemberCap.check() {\n        ids[\"NeoMember\"] = neoMemberCap.borrow()!.getIDs()\n    }\n\n    let barterYardPackCap= account.getCapability\u003c\u0026{BarterYardPackNFT.BarterYardPackNFTCollectionPublic}\u003e(BarterYardPackNFT.CollectionPublicPath)\n    if barterYardPackCap.check() {\n        ids[\"BarterYardClubPack\"] = barterYardPackCap.borrow()!.getIDs()\n    }\n\n    let byCap = account.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(BarterYardClubWerewolf.CollectionPublicPath)\n    if byCap.check() {\n        ids[\"BarterYardClubWerewolf\"] = byCap.borrow()!.getIDs()\n    }\n\n    let momentablesCap = account.getCapability\u003c\u0026{Momentables.MomentablesCollectionPublic}\u003e(Momentables.CollectionPublicPath)\n    if momentablesCap.check(){\n        ids[\"Momentables\"] = momentablesCap.borrow()!.getIDs()\n    }\n\n    let zeedzCap = account.getCapability\u003c\u0026{ZeedzINO.ZeedzCollectionPublic}\u003e(ZeedzINO.CollectionPublicPath)\n    if zeedzCap.check(){\n        ids[\"ZeedzINO\"]=zeedzCap.borrow()!.getIDs()\n    }\n\n    let dayCap = account.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(DayNFT.CollectionPublicPath)\n    if dayCap.check() {\n        ids[\"DayNFT\"] = dayCap.borrow()!.getIDs()\n    }\n\n    let necroCap = account.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(Necryptolis.ResolverCollectionPublicPath)\n    if necroCap.check() {\n        ids[\"Necryptolis\"] = necroCap.borrow()!.getIDs()\n    }\n\n\n    let sockIds : [UInt64] = [14813, 15013, 14946, 14808, 14899, 14792, 15016, 14961, 14816, 14796, 14992, 14977, 14815, 14863, 14817, 14814, 14875, 14960, 14985, 14850, 14849, 14966, 14826, 14972, 14795, 15021, 14950, 14847, 14970, 14833, 14786, 15010, 14953, 14799, 14883, 14947, 14844, 14801, 14886, 15015, 15023, 15027, 15029, 14802, 14810, 14948, 14955, 14957, 14988, 15007, 15009, 14837, 15024, 14803, 14973, 14969, 15002, 15017, 14797, 14894, 14881, 15025, 14791, 14979, 14789, 14993, 14873, 14939, 15005, 15006, 14869, 14889, 15004, 15008, 15026, 14990, 14998, 14898, 14819, 14840, 14974, 15019, 14856, 14838, 14787, 14876, 14996, 14798, 14855, 14824, 14843, 14959, 15020, 14862, 14822, 14897, 14830, 14790, 14867, 14878, 14991, 14835, 14818, 14892, 14800, 15000, 14857, 14986, 14805, 14812, 14962]\n\n\n    let raribleCap = account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(RaribleNFT.collectionPublicPath)\n\n    if raribleCap.check() {\n    let mySockIds : [UInt64] = []\n    for id in raribleCap.borrow()!.getIDs() {\n        if sockIds.contains(id) {\n            mySockIds.append(id)\n        }\n    }\n    ids[\"FlowverseSocks\"] = mySockIds\n    }\n\n\n    let floatCap = account.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(FLOAT.FLOATCollectionPublicPath)\n    if floatCap.check() {\n        ids[\"FLOAT\"] = floatCap.borrow()!.getIDs()\n    }\n\n  let mintStoreCap = account.getCapability\u003c\u0026{MintStoreItem.MintStoreItemCollectionPublic}\u003e(MintStoreItem.CollectionPublicPath)\n    if mintStoreCap.check() {\n        ids[\"MintStore\"] = mintStoreCap.borrow()!.getIDs()\n    }\n\n    let somePlaceCap =account.getCapability\u003c\u0026{SomePlaceCollectible.CollectibleCollectionPublic}\u003e(SomePlaceCollectible.CollectionPublicPath)\n    if somePlaceCap.check(){\n        ids[\"SomePlace\"] = somePlaceCap.borrow()!.getIDs()\n    }\n\n    let bl0xCap = account.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(Bl0x.CollectionPublicPath)\n    if bl0xCap.check() {\n        ids[\"Bl0x\"] = bl0xCap.borrow()!.getIDs()\n    }\n\n    let bl0xPackCap = account.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(Bl0xPack.CollectionPublicPath)\n    if bl0xPackCap.check() {\n        ids[\"Bl0xPack\"] = bl0xPackCap.borrow()!.getIDs()\n    }\n\n    for key in ids.keys {\n        if ids[key]!.length == 0 {\n            ids.remove(key: key)\n        }\n    }\n    return ids\n}\n\n\npub fun main(user: String) : {String: [UInt64]} {\n    let resolvingAddress = FIND.resolve(user)\n    if resolvingAddress == nil {\n        return {}\n    }\n    let address = resolvingAddress!\n\n    return getNFTIDs(ownerAddress: address)\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "getNFTView": {
               "code": "import MetadataViews from 0x1d7e57aa55817448\nimport FINDNFTCatalog from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\n\n//Fetch a single view from a nft on a given path\npub fun main(user: String, aliasOrIdentifier:String, id: UInt64, identifier: String) : AnyStruct? {\n\n    let publicPath = getPublicPath(aliasOrIdentifier)\n    let resolveAddress = FIND.resolve(user) \n    if resolveAddress == nil {return []}\n    let address = resolveAddress!\n\n    let pp = publicPath\n    let account = getAccount(address)\n    if account.balance == 0.0 {\n        return nil\n    }\n    let collection= account.getCapability(pp).borrow\u003c\u0026{MetadataViews.ResolverCollection}\u003e()!\n\n    let nft=collection.borrowViewResolver(id: id)\n    for v in nft.getViews() {\n        if v.identifier== identifier {\n            return nft.resolveView(v)\n        }\n    }\n    return nil\n}\n\npub fun getPublicPath(_ nftIdentifier: String) : PublicPath {\n    let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier)) \n    let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n    return collection.collectionData.publicPath\n}",
               "spec": {
                  "order": [
                     "user",
                     "aliasOrIdentifier",
                     "id",
                     "identifier"
                  ],
                  "parameters": {
                     "aliasOrIdentifier": "String",
                     "id": "UInt64",
                     "identifier": "String",
                     "user": "String"
                  }
               }
            },
            "getNFTViews": {
               "code": "import MetadataViews from 0x1d7e57aa55817448\nimport NFTCatalog from 0x49a7cda3a1eecc29\nimport FINDNFTCatalog from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\n\n//get all the views for an nft and address/path/id\npub fun main(user: String, aliasOrIdentifier:String, id: UInt64) : [String] {\n    let nftInfo = getCollectionData(aliasOrIdentifier) \n\n    let resolveAddress = FIND.resolve(user) \n    if resolveAddress == nil {return []}\n    let address = resolveAddress!\n    let pp = nftInfo.publicPath\n    let collection= getAccount(address).getCapability(pp).borrow\u003c\u0026{MetadataViews.ResolverCollection}\u003e()!\n    let nft=collection.borrowViewResolver(id: id)\n    let views:[String]=[]\n    for v in nft.getViews() {\n        views.append(v.identifier)\n    }\n    return views\n}\n\npub fun getCollectionData(_ nftIdentifier: String) : NFTCatalog.NFTCollectionData {\n    let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier)) \n    let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n    return collection.collectionData\n}",
               "spec": {
                  "order": [
                     "user",
                     "aliasOrIdentifier",
                     "id"
                  ],
                  "parameters": {
                     "aliasOrIdentifier": "String",
                     "id": "UInt64",
                     "user": "String"
                  }
               }
            },
            "getNFTs": {
               "code": "import NonFungibleToken from 0x1d7e57aa55817448\nimport MetadataViews from 0x1d7e57aa55817448\n\n//are in alchemy\nimport Mynft from 0xf6fcbef550d97aa5\nimport GooberXContract from 0x34f2bf4a80bb0f69\nimport RareRooms_NFT from 0x329feb3ab062d289\nimport CNN_NFT from 0x329feb3ab062d289\nimport Canes_Vault_NFT from 0x329feb3ab062d289\nimport DGD_NFT from 0x329feb3ab062d289\nimport RaceDay_NFT from 0x329feb3ab062d289\nimport The_Next_Cartel_NFT from 0x329feb3ab062d289\nimport MatrixWorldFlowFestNFT from 0x2d2750f240198f91\nimport GeniaceNFT from 0xabda6627c70c7f52\nimport OneFootballCollectible from 0x6831760534292098\nimport GoatedGoats from 0x2068315349bdfce5\nimport GoatedGoatsTrait from 0x2068315349bdfce5\nimport HaikuNFT from 0xf61e40c19db2a9e2\nimport KlktnNFT from 0xabd6e80be7e9682c\nimport BarterYardPackNFT from 0xa95b021cf8a30d80\nimport Evolution from 0xf4264ac8f3256818\nimport UFC_NFT from 0x329feb3ab062d289\nimport Moments from 0xd4ad4740ee426334\nimport CryptoPiggo from 0xd3df824bf81910a4\nimport Momentables from 0x9d21537544d9123d\nimport ZeedzINO from 0x62b3063fbe672fc8\nimport PartyMansionDrinksContract from 0x34f2bf4a80bb0f69\nimport DayNFT from 0x1600b04bf033fb99\nimport RaribleNFT from 0x01ab36aaf654a13e\nimport SomePlaceCollectible from 0x667a16294a089ef8\nimport SturdyItems from 0x427ceada271aa0b1\n\n//we have better url\nimport MotoGPCard from 0xa49cc0ee46c54bfb\n\n//we have sent pr\nimport Gaia from 0x8b148183c28ff88f\n\nimport FIND from 0x097bafa4e0b48eef\n\n//They are lacking this one\nimport MatrixWorldAssetsNFT from 0xf20df769e658c257\n\n//Will have Views!\nimport NeoAvatar from 0xb25138dbf45e5801\nimport NeoVoucher from 0xb25138dbf45e5801\nimport NeoMember from 0xb25138dbf45e5801\nimport NeoViews from 0xb25138dbf45e5801\nimport Art from 0xd796ff17107bbff6\nimport Marketplace from 0xd796ff17107bbff6\nimport Flovatar from 0x921ea449dffec68a\nimport FlovatarMarketplace from  0x921ea449dffec68a\nimport CharityNFT from 0x097bafa4e0b48eef\nimport GoatedGoatsVouchers from 0xdfc74d9d561374c0\nimport TraitPacksVouchers from 0xdfc74d9d561374c0\nimport GoatedGoatsTraitPack from 0x2068315349bdfce5\nimport BarterYardClubWerewolf from  0x28abb9f291cadaf2\nimport Necryptolis from 0x718efe5e88fe48ea\nimport FLOAT from 0x2d4c3caffbeab845\nimport Bl0x from 0x7620acf6d7f2468a\nimport Bl0xPack from 0x7620acf6d7f2468a\n\n//Jambb, not called Jambb Vouchers\nimport Vouchers from 0x444f5ea22c6ea12c\n\n//xtingles\n//urls is wrong in alchemy to media\nimport Collectible from 0xf5b0eb433389ac3f\n\n//They do not have external url correct\nimport MintStoreItem from 0x20187093790b9aef\n\n\n\n\npub struct MetadataCollectionItem {\n    pub let id:UInt64\n    pub let name: String\n    pub let image: String\n    pub let url: String\n    pub let listPrice: UFix64?\n    pub let listToken: String?\n    pub let contentType:String\n    pub let rarity:String\n\n\n    init(id:UInt64, name:String, image:String, url:String, listPrice: UFix64?, listToken:String?, contentType: String, rarity: String) {\n        self.id=id\n        self.name=name\n        self.url=url\n        self.image=image\n        self.listToken=listToken\n        self.listPrice=listPrice\n        self.contentType=contentType\n        self.rarity=rarity\n    }\n}\n\n//TODO:missing some from mainnet\n\n// Same method signature as getNFTs.cdc for backwards-compatability.\npub fun getNFTs(ownerAddress: Address, ids: {String:[UInt64]}): [MetadataCollectionItem] {\n    let NFTs: [MetadataCollectionItem] = []\n    let owner = getAccount(ownerAddress)\n    if owner.balance == 0.0 {\n        return []\n    }\n\n    for key in ids.keys {\n        for id in ids[key]! {\n            var d: MetadataCollectionItem? = nil\n\n\n            switch key {\n                case \"CNN\": d  = getCNN(owner:owner, id:id) \n                case \"Mynft\": d  = getMynft(owner:owner, id:id)\n                case \"Flovatar\": d = getFlovatar(owner:owner, id:id)\n                case \"FlovatarForSale\": d = getFlovatarSale(owner:owner, id:id)\n                case \"VersusForSale\": d = getVersusSale(owner:owner, id:id)\n                case \"Versus\": d = getVersus(owner:owner, id:id)\n                case \"Gooberz\": d  = getGoober(owner:owner, id:id) \n                case \"PartyMansionDrinksContract\": d  = getPartyBeers(owner:owner, id:id) \n                case \"RareRooms\": d  = getRareRooms(owner:owner, id:id) \n                case \"Canes_Vault_NFT\": d  = getCanesVault(owner:owner, id:id)\n                case \"DGD_NFT\": d  = getDGD(owner:owner, id:id) \n                case \"RaceDay_NFT\": d  = getRaceDay(owner:owner, id:id) \n                case \"The_Next_Cartel_NFT\": d  = getTheNextCartel(owner:owner, id:id)\n                case \"UFC\": d  = getUFC(owner:owner, id:id)\n                case \"MotoGPCard\": d  = getMotoGP(owner:owner, id:id)\n                case \"Gaia\": d  = getGaia(owner:owner, id:id) \n                case \"Jambb\": d  = getJambb(owner:owner, id:id) \n                case \"JambbVoucher\": d  = getJambbVoucher(owner:owner, id:id) \n                case \"MatrixWorldAssetsNFT\": d  = getMatrixWorldAssets(owner:owner, id:id) \n                case \"MatrixWorldFlowFest\": d  = getMatrixWorldFlowFest(owner:owner, id:id) \n                case \"SturdyItems\": d  = getSturdyItems(owner:owner, id:id) \n                case \"FindCharity\": d  = getFindCharity(owner:owner, id:id)\n                case \"Evolution\": d  = getEvolution(owner:owner, id:id) \n                case \"GeniaceNFT\": d  = getGeniace(owner:owner, id:id) \n                case \"OneFootballCollectible\": d  = getOneFootballCollectible(owner:owner, id:id) \n                case \"CryptoPiggo\": d  = getCryptoPiggoes(owner:owner, id:id) \n                case \"Xtingles\": d  = getXtingles(owner:owner, id:id) \n                case \"GoatedGoatsVoucher\": d  = getGGVouhcer(owner:owner, id:id)\n                case \"GoatedGoatsTraitVoucher\": d  = getGGTraitVoucher(owner:owner, id:id) \n                case \"GoatedGoats\": d  = getGG(owner:owner, id:id) \n                case \"GoatedGoatsTrait\": d  = getGGT(owner:owner, id:id) \n                case \"GoatedGoatsTraitPack\": d  = getGGTP(owner:owner, id:id) \n                case \"Bitku\": d  = getBitku(owner:owner, id:id) \n                case \"KLKTN\": d  = getKLKNT(owner:owner, id:id)\n                case \"NeoAvatar\": d  = getNeoA(owner:owner, id:id)\n                case \"NeoVoucher\": d  = getNeoV(owner:owner, id:id)\n                case \"NeoMember\": d  = getNeoM(owner:owner, id:id) \n                case \"BarterYardClubPack\": d  = getBYCP(owner:owner, id:id) \n                case \"BarterYardClubWerewolf\": d  = getBYCW(owner:owner, id:id) \n                case \"Momentables\": d  = getMomentables(owner:owner, id:id) \n                case \"ZeedsINO\": d = getZeeds(owner:owner, id:id)\n                case \"DayNFT\" : d = getDayNFT(owner:owner, id:id)\n                case \"Necryptolis\" : d = getNecryptolis(owner:owner, id:id)\n                case \"FlowverseSocks\" : d = getFlowverseSocks(owner:owner, id:id)\n                case \"FLOAT\" : d = getFloat(owner:owner, id:id)\n                case \"MintStore\" : d = getMintStore(owner:owner, id:id)\n                case \"SomePlace\" : d = getSomePlace(owner:owner, id:id)\n                case \"Bl0x\" : d = getBl0x(owner: owner, id: id)\n                case \"Bl0xPack\" : d = getBl0xPack(owner: owner, id: id)\n\n            default:\n                panic(\"adapter for NFT not found: \".concat(key))\n            }\n\n            if d!= nil {\n                NFTs.append(d!)\n            }\n        }\n    }\n\n    return NFTs\n}\n\npub fun    getFlovatar(owner:PublicAccount, id:UInt64) : MetadataCollectionItem? {\n\n    let flovatarCap = owner.getCapability\u003c\u0026{Flovatar.CollectionPublic}\u003e(Flovatar.CollectionPublicPath)  \n    if !flovatarCap.check(){\n        return nil\n    }\n\n    let flovatars=flovatarCap.borrow()!\n    let flovatar = flovatars.borrowFlovatar(id: id)!\n\n    let metadata=flovatar.getMetadata()\n    var name = flovatar.getName()\n    if name == \"\" {\n        name=\"Flovatar #\".concat(flovatar.id.toString())\n    }\n\n    var rarity=\"common\"\n    if metadata.legendaryCount \u003e 0 {\n        rarity=\"legendary\"\n    } else if metadata.epicCount \u003e 0 {\n        rarity=\"epic\"\n    } else if metadata.rareCount \u003e 0 {\n        rarity=\"rare\"\n    }\n\n\n    return MetadataCollectionItem(\n        id: flovatar.id, \n        name: name, \n        image: \"https://flovatar.com/api/image/\".concat(flovatar.id.toString()),\n        url: \"https://flovatar.com/flovatars/\".concat(flovatar.id.toString()).concat(\"/\"),\n        listPrice:nil,\n        listToken:nil,\n        contentType: \"image\",\n        rarity: rarity\n    )\n}\n\npub fun    getFlovatarSale(owner:PublicAccount, id:UInt64) : MetadataCollectionItem? {\n    let flovatarMarketCap = owner.getCapability\u003c\u0026{FlovatarMarketplace.SalePublic}\u003e(FlovatarMarketplace.CollectionPublicPath)  \n    if !flovatarMarketCap.check(){\n        return nil\n    }\n\n    let saleCollection=flovatarMarketCap.borrow()!\n    let flovatar = saleCollection.getFlovatar(tokenId: id)!\n\n    let metadata=flovatar.getMetadata()\n    var name = flovatar.getName()\n    if name == \"\" {\n        name=\"Flovatar #\".concat(flovatar.id.toString())\n    }\n\n    var rarity=\"common\"\n    if metadata.legendaryCount \u003e 0 {\n        rarity=\"legendary\"\n    }else if metadata.epicCount \u003e 0 {\n        rarity=\"epic\"\n    }else if metadata.rareCount \u003e 0 {\n        rarity=\"rare\"\n    }\n\n    let price = saleCollection.getFlovatarPrice(tokenId: id)\n\n\n\n    return MetadataCollectionItem(\n        id: flovatar.id, \n        name: name, \n        image: \"https://flovatar.com/api/image/\".concat(flovatar.id.toString()),\n        url: \"https://flovatar.com/flovatars/\".concat(flovatar.id.toString()).concat(\"/\"),\n        listPrice: price,\n        listToken: \"Flow\",\n        contentType: \"image\",\n        rarity: rarity\n    )\n}\n\npub fun    getVersusSale(owner:PublicAccount, id:UInt64) : MetadataCollectionItem? {\n\n    let versusImageUrlPrefix = \"https://res.cloudinary.com/dxra4agvf/image/upload/c_fill,w_600/f_auto/maincache\"\n    let versusMarketplace = owner.getCapability\u003c\u0026{Marketplace.SalePublic}\u003e(Marketplace.CollectionPublicPath)\n    if !versusMarketplace.check() {\n        return nil\n    }\n\n    let versusMarket = versusMarketplace.borrow()!\n    let saleItem =versusMarket.getSaleItem(tokenID: id)\n    return  MetadataCollectionItem(\n        id: saleItem.id,\n        name: saleItem.art.name.concat(\" edition \").concat(saleItem.art.edition.toString()).concat(\"/\").concat(saleItem.art.maxEdition.toString()).concat(\" by \").concat(saleItem.art.artist),\n        image: versusImageUrlPrefix.concat(saleItem.cacheKey), \n        url: \"https://www.versus.auction/listing/\".concat(saleItem.id.toString()).concat(\"/\"),\n        listPrice: saleItem.price,\n        listToken: \"Flow\",\n        contentType: \"image\",\n        rarity: \"\"\n    )\n}\n\npub fun    getVersus(owner:PublicAccount, id:UInt64) : MetadataCollectionItem? {\n    let versusArtCap=owner.getCapability\u003c\u0026{Art.CollectionPublic}\u003e(Art.CollectionPublicPath)\n    let versusImageUrlPrefix = \"https://res.cloudinary.com/dxra4agvf/image/upload/c_fill,w_600/f_auto/maincache\"\n    if !versusArtCap.check(){\n        return nil\n    }\n    let address=owner.address!\n\n    let artCollection= versusArtCap.borrow()!\n    var art=artCollection.borrowArt(id: id)!\n    return MetadataCollectionItem(\n        id: id,\n        name: art.metadata.name.concat(\" edition \").concat(art.metadata.edition.toString()).concat(\"/\").concat(art.metadata.maxEdition.toString()).concat(\" by \").concat(art.metadata.artist),  \n        image: versusImageUrlPrefix.concat(art.cacheKey()), \n        url: \"https://www.versus.auction/piece/\".concat(address.toString()).concat(\"/\").concat(art.id.toString()).concat(\"/\"),\n        listPrice:nil,\n        listToken:nil,\n        contentType: \"image\",\n        rarity: \"\"\n    )\n}\n\npub fun    getGoober(owner:PublicAccount, id:UInt64) : MetadataCollectionItem? {\n\n    let goobersCap = owner.getCapability\u003c\u0026GooberXContract.Collection{NonFungibleToken.CollectionPublic, GooberXContract.GooberCollectionPublic}\u003e(GooberXContract.CollectionPublicPath)\n    if !goobersCap.check() {\n        return nil\n    }\n\n    let goobers = goobersCap.borrow()!\n    let goober= goobers.borrowGoober(id:id)!\n    return MetadataCollectionItem(\n        id: id,\n        name: \"Goober #\".concat(id.toString()),\n        image: goober.data.uri,\n        url: \"https://partymansion.io/gooberz/\".concat(id.toString()),\n        listPrice:nil,\n        listToken:nil,\n        contentType: \"image\",\n        rarity: \"\"\n    )\n} \n\npub fun    getPartyBeers(owner:PublicAccount, id:UInt64) : MetadataCollectionItem? {\n\n    let partyMansionDrinksCap = owner.getCapability\u003c\u0026{PartyMansionDrinksContract.DrinkCollectionPublic}\u003e(PartyMansionDrinksContract.CollectionPublicPath)\n    if !partyMansionDrinksCap.check() {\n        return nil\n    }\n\n    let collection = partyMansionDrinksCap.borrow()!\n    let nft = collection.borrowDrink(id: id)!\n    return MetadataCollectionItem(\n        id: id,\n        name: nft.data.description,\n        image: \"ipfs://\".concat(nft.imageCID()),\n        url: \"https://partymansion.io\",\n        listPrice: nil,\n        listToken: nil,\n        contentType: \"image\",\n        rarity: PartyMansionDrinksContract.rarityToString(rarity:nft.data.rarity)\n    )\n} \n\npub fun    getRareRooms(owner:PublicAccount, id:UInt64) : MetadataCollectionItem? {\n    let rareRoomCap = owner.getCapability\u003c\u0026RareRooms_NFT.Collection{RareRooms_NFT.RareRooms_NFTCollectionPublic}\u003e(RareRooms_NFT.CollectionPublicPath)\n    if !rareRoomCap.check() {\n        return nil\n    }\n    let collection = rareRoomCap.borrow()!\n    let nft = collection.borrowRareRooms_NFT(id: id)!\n    let metadata = RareRooms_NFT.getSetMetadata(setId: nft.setId)!\n    return MetadataCollectionItem(\n        id: id,\n        name: metadata[\"name\"]!,\n        image: metadata[\"preview\"]!,\n        url: \"https://rarerooms.io/tokens/\".concat(id.toString()),\n        listPrice: nil,\n        listToken: nil,\n        contentType: \"image\",\n        rarity: \"\"\n    )\n\n\n} \npub fun    getCNN(owner:PublicAccount, id:UInt64) : MetadataCollectionItem? {\n    let cnnCap = owner.getCapability\u003c\u0026CNN_NFT.Collection{CNN_NFT.CNN_NFTCollectionPublic}\u003e(CNN_NFT.CollectionPublicPath)\n    if !cnnCap.check() {\n        return nil\n\n    }\n    let collection = cnnCap.borrow()!\n    let nft = collection.borrowCNN_NFT(id: id)!\n    let metadata = CNN_NFT.getSetMetadata(setId: nft.setId)!\n\n    var image= metadata[\"preview\"]!\n    var contentType=\"image\"\n\n    return MetadataCollectionItem(\n        id: id,\n        name: metadata[\"name\"]!,\n        image: image,\n        url: \"http://vault.cnn.com\",\n        listPrice: nil,\n        listToken: nil,\n        contentType: contentType,\n        rarity: \"\"\n    )\n} \n\npub fun    getCanesVault(owner:PublicAccount, id:UInt64) : MetadataCollectionItem? {\n    let canesVaultCap = owner.getCapability\u003c\u0026Canes_Vault_NFT.Collection{Canes_Vault_NFT.Canes_Vault_NFTCollectionPublic}\u003e(Canes_Vault_NFT.CollectionPublicPath)\n    if !canesVaultCap.check() {\n        return nil\n    }\n    let collection = canesVaultCap.borrow()!\n    let nft = collection.borrowCanes_Vault_NFT(id: id)!\n    let metadata = Canes_Vault_NFT.getSetMetadata(setId: nft.setId)!\n    var image= metadata[\"preview\"]!\n    var contentType=\"image\"\n    return MetadataCollectionItem(\n        id: id,\n        name: metadata[\"name\"]!,\n        image: image,\n        url: \"https://canesvault.com/\",\n        listPrice: nil,\n        listToken: nil,\n        contentType: contentType,\n        rarity: \"\"\n    )\n}\n\npub fun    getDGD(owner:PublicAccount, id:UInt64) : MetadataCollectionItem? {\n    let dgdCap = owner.getCapability\u003c\u0026DGD_NFT.Collection{DGD_NFT.DGD_NFTCollectionPublic}\u003e(DGD_NFT.CollectionPublicPath)\n    if !dgdCap.check() {\n        return nil\n    }\n    let collection = dgdCap.borrow()!\n    let nft = collection.borrowDGD_NFT(id: id)!\n    let metadata = DGD_NFT.getSetMetadata(setId: nft.setId)!\n    var image= metadata[\"preview\"]!\n    var contentType=\"image\"\n\n    return MetadataCollectionItem(\n        id: id,\n        name: metadata[\"name\"]!,\n        image: image,\n        url: \"https://www.theplayerslounge.io/\",\n        listPrice: nil,\n        listToken: nil,\n        contentType: contentType,\n        rarity: \"\"\n    )\n} \n\npub fun    getRaceDay(owner:PublicAccount, id:UInt64) : MetadataCollectionItem? {\n    let raceDayCap = owner.getCapability\u003c\u0026RaceDay_NFT.Collection{RaceDay_NFT.RaceDay_NFTCollectionPublic}\u003e(RaceDay_NFT.CollectionPublicPath)\n    if !raceDayCap.check() {\n        return nil\n    }\n    let collection = raceDayCap.borrow()!\n    let nft = collection.borrowRaceDay_NFT(id: id)!\n    let metadata = RaceDay_NFT.getSetMetadata(setId: nft.setId)!\n    var image= metadata[\"preview\"]!\n    var contentType=\"image\"\n\n    return MetadataCollectionItem(\n        id: id,\n        name: metadata[\"name\"]!,\n        image: image, \n        url: \"https://www.racedaynft.com\",\n        listPrice: nil,\n        listToken: nil,\n        contentType: contentType,\n        rarity: \"\"\n    )\n} \n\npub fun    getTheNextCartel(owner:PublicAccount, id:UInt64) : MetadataCollectionItem? {\n    let nextCartelCap = owner.getCapability\u003c\u0026The_Next_Cartel_NFT.Collection{The_Next_Cartel_NFT.The_Next_Cartel_NFTCollectionPublic}\u003e(The_Next_Cartel_NFT.CollectionPublicPath)\n    if !nextCartelCap.check() {\n        return nil\n    }\n    let collection = nextCartelCap.borrow()!\n    let nft = collection.borrowThe_Next_Cartel_NFT(id: id)!\n    let metadata = The_Next_Cartel_NFT.getSetMetadata(setId: nft.setId)!\n    var image= metadata[\"preview\"]!\n    var contentType=\"image\"\n    return MetadataCollectionItem(\n        id: id,\n        name: metadata[\"name\"]!,\n        // we use \"preview\" and not \"image\" because of potential .glg and .mp4 file types\n        image: image,\n        url: \"https://thenextcartel.com/\",\n        listPrice: nil,\n        listToken: nil,\n        contentType: contentType,\n        rarity: \"\"\n    )\n}\n\npub fun    getUFC(owner:PublicAccount, id:UInt64) : MetadataCollectionItem? {\n    let ufcCap = owner.getCapability\u003c\u0026UFC_NFT.Collection{UFC_NFT.UFC_NFTCollectionPublic}\u003e(UFC_NFT.CollectionPublicPath)\n    if !ufcCap.check() {\n        return nil\n    }\n\n    let collection = ufcCap.borrow()!\n    let nft = collection.borrowUFC_NFT(id: id)!\n    let metadata = UFC_NFT.getSetMetadata(setId: nft.setId)!\n    var image= metadata[\"image\"]!\n    var contentType=\"video\"\n    return MetadataCollectionItem(\n        id: id,\n        name: metadata[\"name\"]!,\n        image: image,\n        url: \"https://www.ufcstrike.com\",\n        listPrice: nil,\n        listToken: nil,\n        contentType: contentType,\n        rarity: \"\"\n    )\n\n\n}\npub fun    getMotoGP(owner:PublicAccount, id:UInt64) : MetadataCollectionItem? {\n    let motoGPCollection = owner.getCapability\u003c\u0026MotoGPCard.Collection{MotoGPCard.ICardCollectionPublic}\u003e(/public/motogpCardCollection)\n    if !motoGPCollection.check() {\n        return nil\n    }\n    let address=owner.address!\n    let motoGPNfts = motoGPCollection.borrow()!.getIDs()\n    let nft = motoGPCollection.borrow()!.borrowCard(id: id)!\n    let metadata = nft.getCardMetadata()!\n    return MetadataCollectionItem(\n        id: id,\n        name: metadata.name,\n        image: metadata.imageUrl,\n        url: \"https://motogp-ignition.com/nft/card/\".concat(id.toString()).concat(\"?owner=\").concat(address.toString()),\n        listPrice: nil,\n        listToken: nil,\n        contentType: \"image\",\n        rarity: \"\"\n    )\n}\npub fun    getGaia(owner:PublicAccount, id:UInt64) : MetadataCollectionItem? {\n    let gaiaCollection = owner.getCapability\u003c\u0026{Gaia.CollectionPublic}\u003e(Gaia.CollectionPublicPath)\n    if !gaiaCollection.check() {\n        return nil\n    }\n\n    let gaiaNfts = gaiaCollection.borrow()!.getIDs()\n    let nft = gaiaCollection.borrow()!.borrowGaiaNFT(id: id)!\n    let metadata = Gaia.getTemplateMetaData(templateID: nft.data.templateID)!\n\n    //For ballerz we can do this...\n    var url=\"http://ongaia.com/\"\n    var name=metadata[\"title\"]!\n\n    if let seriesFullName=metadata[\"series\"] {\n        if seriesFullName==\"Bryson DeChambeau - Vegas, Baby!\" {\n            //For golf there is yet another way\n            url=\"http://ongaia.com/bryson/\".concat(nft.data.mintNumber.toString())\n            name=metadata[\"title\"]!.concat(\" #\").concat(nft.data.mintNumber.toString())\n        } else {\n            //If the series is basketball with shareef we can do this\n            url=\"http://ongaia.com/shareef/nft/\".concat(id.toString())\n            name=metadata[\"title\"]!.concat(\" #\").concat(nft.data.mintNumber.toString())\n        }\n    }\n\n    let newCollections= [\"ballerz\", \"sneakerz\"]\n    if let mid = metadata[\"id\"] {\n        if let uri = metadata[\"uri\"] {\n            for c in newCollections {\n                if uri == \"/collection/\".concat(c).concat(\"//\").concat(mid) {\n                url=\"http://ongaia.com/\".concat(c).concat(\"/\").concat(mid)\n            }\n        }\n    }\n}\n\n\nreturn MetadataCollectionItem(\n    id: id,\n    name: name,\n    image: metadata[\"img\"]!,\n    url: url,\n    listPrice: nil,\n    listToken: nil,\n    contentType: \"image\",\n    rarity: \"\"\n)\n} \n\npub fun    getJambb(owner:PublicAccount, id:UInt64) : MetadataCollectionItem? {\n    let jambbCap = owner.getCapability\u003c\u0026Moments.Collection{Moments.CollectionPublic}\u003e(Moments.CollectionPublicPath)\n    if !jambbCap.check() {\n        return nil\n    }\n    let jambb = jambbCap.borrow()!\n    let nft = jambb.borrowMoment(id: id)!\n    let metadata=nft.getMetadata()\n    return MetadataCollectionItem(\n        id: id,\n        name: metadata.contentName,\n        image: \"ipfs://\".concat(metadata.videoHash),\n        url: \"https://www.jambb.com/c/moment/\".concat(id.toString()),\n        listPrice: nil,\n        listToken: nil,\n        contentType: \"video\",\n        rarity: \"\"\n    )\n} \n\npub fun    getJambbVoucher(owner:PublicAccount, id:UInt64) : MetadataCollectionItem? {\n    let voucherCap = owner.getCapability\u003c\u0026{Vouchers.CollectionPublic}\u003e(Vouchers.CollectionPublicPath)\n    if !voucherCap.check() {\n        return nil\n    }\n    let collection = voucherCap.borrow()!\n    let nft = collection.borrowVoucher(id: id)!\n    let metadata=nft.getMetadata()!\n\n    let url=\"https://jambb.com\"\n    return  MetadataCollectionItem(\n        id: id,\n        name: metadata.name,\n        image: \"ipfs://\".concat(metadata.mediaHash),\n        url: url,\n        listPrice: nil,\n        listToken: nil,\n        contentType: metadata.mediaType,\n        rarity: \"\"\n    )\n} \n\npub fun    getMatrixWorldFlowFest(owner:PublicAccount, id:UInt64) : MetadataCollectionItem? {\n    let mwaCap = owner.getCapability\u003c\u0026{MatrixWorldFlowFestNFT.MatrixWorldFlowFestNFTCollectionPublic}\u003e(MatrixWorldFlowFestNFT.CollectionPublicPath)\n    if !mwaCap.check() {\n        return nil\n    }\n\n    let mwa=mwaCap.borrow()!\n    let nft = mwa.borrowVoucher(id: id)!\n    let metadata=nft.metadata\n    return MetadataCollectionItem(\n        id: nft.id,\n        name: metadata.name,\n        image: metadata.animationUrl,\n        url: \"https://matrixworld.org/\",\n        listPrice: nil,\n        listToken: nil,\n        contentType: \"image\",\n        rarity: \"\"\n    )\n} \n\npub fun    getMatrixWorldAssets(owner:PublicAccount, id:UInt64) : MetadataCollectionItem? {\n\n    let matrixworldAsset = owner.getCapability\u003c\u0026{MatrixWorldAssetsNFT.Metadata, NonFungibleToken.CollectionPublic}\u003e(MatrixWorldAssetsNFT.collectionPublicPath)\n    if !matrixworldAsset.check() {\n        return nil\n    }\n    let collection = matrixworldAsset.borrow()!\n    let metadata = collection.getMetadata(id: id)!\n    return  MetadataCollectionItem(\n        id: id,\n        name: metadata[\"name\"]!,\n        image: metadata[\"image\"]!,\n        url: metadata[\"external_url\"]!,\n        listPrice: nil,\n        listToken: nil,\n        contentType: \"image\",\n        rarity: \"\"\n    )\n} \n\npub fun    getSturdyItems(owner:PublicAccount, id:UInt64) : MetadataCollectionItem? {\n\n    let sturdyCollectionCap = owner.getCapability\u003c\u0026SturdyItems.Collection{SturdyItems.SturdyItemsCollectionPublic}\u003e(SturdyItems.CollectionPublicPath)\n    if !sturdyCollectionCap.check() {\n        return nil\n    }\n    let sturdyNfts = sturdyCollectionCap.borrow()!.getIDs()\n    let nft = sturdyCollectionCap.borrow()!.borrowSturdyItem(id: id)!\n    // the only thing we can play with is the nft title which is for example:\n    //     - \"HOODLUM#10\"\n    //     - \"HOLIDAY MYSTERY BADGE 2021\"\n    //  - \"EXCALIBUR\"\n    let isHoodlum = nft.tokenTitle.slice(from: 0, upTo: 7) == \"HOODLUM\"\n    if !isHoodlum {\n        return nil\n    }\n    // the hoodlum id is needed to retrieve the image but is not in the nft\n    let hoodlumId = nft.tokenTitle.slice(from: 8, upTo: nft.tokenTitle.length)\n    return  MetadataCollectionItem(\n        id: id,\n        name: nft.tokenTitle,\n        image: \"https://hoodlumsnft.com/_next/image?url=%2Fthumbs%2FsomeHoodlum_\".concat(hoodlumId).concat(\".png\u0026w=1920\u0026q=75\"),\n        url: \"https://hoodlumsnft.com/\",\n        listPrice:nil,\n        listToken:nil,\n        contentType:\"image\",\n        rarity: \"\"\n    )\n} \n\npub fun    getFindCharity(owner:PublicAccount, id:UInt64) : MetadataCollectionItem? {\n    let charityCap = owner.getCapability\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection)\n    if !charityCap.check() {\n        return nil\n    }\n    let collection = charityCap.borrow()!\n    let nft = collection.borrowCharity(id: id)!\n    let metadata = nft.getMetadata()\n    return MetadataCollectionItem(\n        id: id,\n        name: metadata[\"name\"]!,\n        image: metadata[\"thumbnail\"]!,\n        url: metadata[\"originUrl\"]!,\n        listPrice: nil,\n        listToken: nil,\n        contentType:\"image\",\n        rarity: \"\"\n    )\n}\n\npub fun    getEvolution(owner:PublicAccount, id:UInt64) : MetadataCollectionItem? {\n    let evolutionCap=owner.getCapability\u003c\u0026{Evolution.EvolutionCollectionPublic}\u003e(/public/f4264ac8f3256818_Evolution_Collection)\n    if !evolutionCap.check() {\n        return nil\n    }\n    let evolution=evolutionCap.borrow()!\n    let nfts = evolution.getIDs()\n    // the metadata is a JSON stored on IPFS at the address nft.tokenURI\n    let nft = evolution.borrowCollectible(id: id)!\n    let metadata = Evolution.getItemMetadata(itemId: nft.data.itemId)!\n    return MetadataCollectionItem(\n        id: id,\n        name: metadata[\"Title\"]!.concat(\" #\").concat(nft.data.serialNumber.toString()),\n        image: \"https://storage.viv3.com/0xf4264ac8f3256818/mv/\".concat(nft.data.itemId.toString()),\n        url: \"https://www.evolution-collect.com/\",\n        listPrice: nil,\n        listToken: nil,\n        contentType:\"video\",\n        rarity: \"\"\n    )\n}\n\npub fun    getGeniace(owner:PublicAccount, id:UInt64) : MetadataCollectionItem? {\n    let geniaceCap = owner.getCapability\u003c\u0026GeniaceNFT.Collection{NonFungibleToken.CollectionPublic, GeniaceNFT.GeniaceNFTCollectionPublic}\u003e(GeniaceNFT.CollectionPublicPath)\n    if !geniaceCap.check() {\n        return nil\n    }\n\n    let geniace=geniaceCap.borrow()!\n    let nft = geniace.borrowGeniaceNFT(id: id)!\n    let metadata = nft.metadata\n    var rarity=\"\"\n    if metadata.rarity == GeniaceNFT.Rarity.Collectible {\n        rarity=\"Collectible\"\n    }else if metadata.rarity == GeniaceNFT.Rarity.Rare {\n        rarity=\"Rare\"\n    }else if metadata.rarity == GeniaceNFT.Rarity.UltraRare {\n        rarity=\"UltraRare\"\n    }\n\n    return MetadataCollectionItem(\n        id: id,\n        name: metadata.name,\n        image: metadata.imageUrl,\n        url: \"https://www.geniace.com/product/\".concat(id.toString()),\n        listPrice: nil,\n        listToken: nil,\n        contentType: metadata.data[\"mimetype\"]!,\n        rarity: rarity,\n    )\n} \n\npub fun    getOneFootballCollectible(owner:PublicAccount, id:UInt64) : MetadataCollectionItem? {\n    let address=owner.address!\n    let oneFootballCollectibleCap = owner.getCapability\u003c\u0026OneFootballCollectible.Collection{OneFootballCollectible.OneFootballCollectibleCollectionPublic}\u003e(OneFootballCollectible.CollectionPublicPath)\n    if !oneFootballCollectibleCap.check() {\n        return nil\n    }\n    let collection = oneFootballCollectibleCap.borrow()!\n    let nft = collection.borrowOneFootballCollectible(id: id)!\n    let metadata = nft.getTemplate()!\n    return MetadataCollectionItem(\n        id: id,\n        name: metadata.name,\n        image: \"ipfs://\".concat(metadata.media),\n        url: \"https://xmas.onefootball.com/\".concat(owner.address.toString()),\n        listPrice: nil,\n        listToken: nil,\n        contentType: \"video\",\n        rarity: \"\"\n\n    )\n} \n\npub fun    getCryptoPiggoes(owner:PublicAccount, id:UInt64) : MetadataCollectionItem? {\n    let cryptoPiggoCap = owner.getCapability\u003c\u0026{CryptoPiggo.CryptoPiggoCollectionPublic}\u003e(CryptoPiggo.CollectionPublicPath)\n    if !cryptoPiggoCap.check() {\n        return nil\n    }\n    let collection = cryptoPiggoCap.borrow()!\n    let nft = collection.borrowItem(id: id)!\n    return MetadataCollectionItem(\n        id: id,\n        name: \"CryptoPiggo #\".concat(id.toString()),\n        image: \"https://s3.us-west-2.amazonaws.com/crypto-piggo.nft/piggo-\".concat(id.toString()).concat(\".png\"),\n        url: \"https://rareworx.com/piggo/details/\".concat(id.toString()),\n        listPrice: nil,\n        listToken: nil,\n        contentType: \"image\",\n        rarity: \"\"\n    )\n} \n\npub fun    getXtingles(owner:PublicAccount, id:UInt64) : MetadataCollectionItem? {\n    let xtinglesCap= owner.getCapability\u003c\u0026{Collectible.CollectionPublic}\u003e(Collectible.CollectionPublicPath)\n    if !xtinglesCap.check() {\n        return nil\n    }\n    let collection = xtinglesCap.borrow()!\n\n    let nft=collection.borrowCollectible(id:id)!\n    var image=nft.metadata.link\n\n    let prefix=\"https://\"\n    if image.slice(from:0, upTo:prefix.length) != prefix {\n        image=\"ipfs://\".concat(image)\n    }\n    return MetadataCollectionItem(\n        id: nft.id,\n        name: nft.metadata.name.concat(\" #\").concat(nft.metadata.edition.toString()),\n        image: image,\n        url: \"http://xtingles.com\",\n        listPrice: nil,\n        listToken: nil,\n        contentType: \"video\",\n        rarity: \"\"\n    )\n} \n\npub fun    getGGVouhcer(owner:PublicAccount, id:UInt64) : MetadataCollectionItem? {\n    let goatsCap = owner.getCapability\u003c\u0026{GoatedGoatsVouchers.GoatsVoucherCollectionPublic}\u003e(GoatedGoatsVouchers.CollectionPublicPath)\n    if !goatsCap.check() {\n        return nil\n    }\n    let goatsImageUrl= GoatedGoatsVouchers.getCollectionMetadata()[\"mediaURL\"]!\n    let collection = goatsCap.borrow()!\n    return MetadataCollectionItem(\n        id: id,\n        name: \"Goated Goat Base Goat Voucher #\".concat(id.toString()),\n        image: goatsImageUrl, \n        url: \"https://goatedgoats.com/\",\n        listPrice: nil,\n        listToken: nil,\n        contentType: \"image\",\n        rarity: \"\"\n\n    )\n}\npub fun    getGGTraitVoucher(owner:PublicAccount, id:UInt64) : MetadataCollectionItem? {\n    let goatsTraitCap = owner.getCapability\u003c\u0026{TraitPacksVouchers.PackVoucherCollectionPublic}\u003e(TraitPacksVouchers.CollectionPublicPath)\n    if !goatsTraitCap.check() {\n        return nil\n    }\n    let goatsImageUrl= TraitPacksVouchers.getCollectionMetadata()[\"mediaURL\"]!\n    let collection = goatsTraitCap.borrow()!\n    return MetadataCollectionItem(\n        id: id,\n        name: \"Goated Goat Trait Pack Voucher #\".concat(id.toString()),\n        image: goatsImageUrl, \n        url: \"https://goatedgoats.com/\",\n        listPrice: nil,\n        listToken: nil,\n        contentType: \"image\",\n        rarity: \"\"\n\n    )\n\n} \n\npub fun    getGG(owner:PublicAccount, id:UInt64) : MetadataCollectionItem? {\n    return getItemForMetadataStandard(path: GoatedGoats.CollectionPublicPath, owner: owner, externalFixedUrl: \"https://goatedgoats.com\", id:id)\n} \n\npub fun    getGGT(owner:PublicAccount, id:UInt64) : MetadataCollectionItem? {\n    return getItemForMetadataStandard(path: GoatedGoatsTrait.CollectionPublicPath, owner: owner, externalFixedUrl: \"https://goatedgoats.com\", id:id)\n} \n\npub fun    getGGTP(owner:PublicAccount, id:UInt64) : MetadataCollectionItem? {\n    return  getItemForMetadataStandard(path: GoatedGoatsTraitPack.CollectionPublicPath, owner: owner, externalFixedUrl: \"https://goatedgoats.com\", id:id)\n} \n\npub fun    getBitku(owner:PublicAccount, id:UInt64) : MetadataCollectionItem? {\n\n    let address=owner.address!\n    let bitkuCap = owner.getCapability\u003c\u0026{HaikuNFT.HaikuCollectionPublic}\u003e(HaikuNFT.HaikuCollectionPublicPath)\n    if !bitkuCap.check() {\n        return nil\n    }\n    let collection = bitkuCap.borrow()!\n    let nft = collection.borrowHaiku(id: id)!\n    return MetadataCollectionItem(\n        id: id,\n        name: \"Bitku #\".concat(id.toString()),\n        image: nft.text,\n        url: \"https://bitku.art/#\".concat(address.toString()).concat(\"/\").concat(id.toString()),\n        listPrice: nil,\n        listToken: nil,\n        contentType: \"text\",\n        rarity: \"\"\n    )\n} \n\npub fun    getKLKNT(owner:PublicAccount, id:UInt64) : MetadataCollectionItem? {\n    let klktnCap = owner.getCapability\u003c\u0026{KlktnNFT.KlktnNFTCollectionPublic}\u003e(KlktnNFT.CollectionPublicPath)\n    if !klktnCap.check() {\n        return nil\n    }\n    let collection = klktnCap.borrow()!\n    let nft = collection.borrowKlktnNFT(id: id)!\n\n    let metadata=nft.getNFTMetadata()\n    /*\n    Result: {\"uri\": \"ipfs://bafybeifsiousmtmcruuelgyiku3xa5hmw7ylsyqfdvpjsea7r4xa74bhym\", \"name\": \"Kevin Woo - What is KLKTN?\", \"mimeType\": \"video/mp4\", \"media\": \"https://ipfs.io/ipfs/bafybeifsiousmtmcruuelgyiku3xa5hmw7ylsyqfdvpjsea7r4xa74bhym/fb91ad34d61dde04f02ad240f0ca924902d8b4a3da25daaf0bb1ed769977848c.mp4\", \"description\": \"K-pop sensation Kevin Woo has partnered up with KLKTN to enhance his artist to fan interactions and experiences within his fandom. Join our chat to learn more: https://discord.gg/UJxb4erfUw\"}\n\n    */\n    return MetadataCollectionItem(\n        id: id,\n        name: metadata[\"name\"]!,\n        image: metadata[\"media\"]!,\n        url: \"https://klktn.com/\",\n        listPrice: nil,\n        listToken: nil,\n        contentType: \"video\", //metadata[\"mimeType\"]!,\n        rarity: \"\"\n    )\n}\n\npub fun    getMynft(owner:PublicAccount, id:UInt64) : MetadataCollectionItem? {\n    let mynftCap = owner.getCapability\u003c\u0026{Mynft.MynftCollectionPublic}\u003e(Mynft.CollectionPublicPath)\n    if !mynftCap.check() {\n        return nil\n    }\n    let collection = mynftCap.borrow()!\n    let nft = collection.borrowArt(id: id)!\n    let metadata=nft.metadata\n\n    var image= metadata.ipfsLink\n    if image == \"\" {\n        image=\"https://arweave.net/\".concat(metadata.arLink)\n    }\n\n    return MetadataCollectionItem(\n        id: id,\n        name: metadata.name,\n        image: image,\n        url: \"http://mynft.io\",\n        listPrice: nil,\n        listToken: nil,\n        contentType: metadata.type,\n        rarity: \"\"\n    )\n}\n\npub fun    getNeoA(owner:PublicAccount, id:UInt64) : MetadataCollectionItem? {\n    return getItemForMetadataStandard(path: NeoAvatar.CollectionPublicPath, owner: owner, externalFixedUrl: \"https://neocollectibles.xyz\", id:id)\n}\npub fun    getNeoV(owner:PublicAccount, id:UInt64) : MetadataCollectionItem? {\n    let address=owner.address!\n    return getItemForMetadataStandard(path: NeoVoucher.CollectionPublicPath, owner: owner, externalFixedUrl: \"https://neocollectibles.xyz/member/\".concat(address.toString()), id:id)\n}\n\npub fun    getNeoM(owner:PublicAccount, id:UInt64) : MetadataCollectionItem? {\n    let address=owner.address!\n    return getItemForMetadataStandard(path: NeoMember.CollectionPublicPath, owner: owner, externalFixedUrl: \"https://neocollectibles.xyz/member/\".concat(address.toString()), id:id)\n} \n\npub fun    getBYCP(owner:PublicAccount, id:UInt64) : MetadataCollectionItem? {\n    let barterYardCap= owner.getCapability\u003c\u0026{BarterYardPackNFT.BarterYardPackNFTCollectionPublic}\u003e(BarterYardPackNFT.CollectionPublicPath)\n    if !barterYardCap.check() {\n        return nil\n    }\n    let collection = barterYardCap.borrow()!\n    let nft = collection.borrowBarterYardPackNFT(id: id)!\n\n    if let displayView = nft.resolveView(Type\u003cMetadataViews.Display\u003e()) {\n        let display = displayView as! MetadataViews.Display\n        return MetadataCollectionItem(\n            id: id,\n            name: display.name,\n            image: display.thumbnail.uri(),\n            url: \"https://www.barteryard.club\",\n            listPrice: nil,\n            listToken: nil,\n            contentType: \"image\",\n            rarity: \"\"\n        )\n    }\n    return nil\n} \n\npub fun    getBYCW(owner:PublicAccount, id:UInt64) : MetadataCollectionItem? {\n    return getItemForMetadataStandard(path: BarterYardClubWerewolf.CollectionPublicPath, owner: owner, externalFixedUrl: \"https://barteryard.club\", id:id)\n} \n\npub fun    getMomentables(owner:PublicAccount, id:UInt64) : MetadataCollectionItem? {\n    let momentablesCap = owner.getCapability\u003c\u0026{Momentables.MomentablesCollectionPublic}\u003e(Momentables.CollectionPublicPath)\n    if !momentablesCap.check() {\n        return nil\n    }\n    let collection = momentablesCap.borrow()!\n\n    let nft = collection.borrowMomentables(id: id)!\n    let traits=nft.getTraits()\n    let commonTrait=traits[\"common\"]!\n\n    return MetadataCollectionItem(\n        id: id,\n        name: nft.name,\n        image: \"ipfs://\".concat(nft.imageCID),\n        url: \"https://www.cryptopharaohs.world/\",\n        listPrice: nil,\n        listToken: nil,\n        contentType: \"image\",\n        rarity: commonTrait[\"type\"] ?? \"\",\n    )\n} \n\npub fun    getZeeds(owner:PublicAccount, id:UInt64) : MetadataCollectionItem? {\n\n    let zeedzCap = owner.getCapability\u003c\u0026{ZeedzINO.ZeedzCollectionPublic}\u003e(ZeedzINO.CollectionPublicPath)\n    if !zeedzCap.check() {\n        return nil\n    }\n    let collection = zeedzCap.borrow()!\n    let nft = collection.borrowZeedle(id: id)!\n\n    return MetadataCollectionItem(\n        id: id,\n        name: nft.name,\n        image: \"ipfs://\".concat(nft.imageURI),\n        url: \"http://zeedz.io\",\n        listPrice: nil,\n        listToken: nil,\n        contentType: \"image\",\n        rarity: nft.rarity\n    )\n}\n\n\npub fun    getDayNFT(owner:PublicAccount, id:UInt64) : MetadataCollectionItem? {\n    return getItemForMetadataStandard(path: DayNFT.CollectionPublicPath, owner: owner, externalFixedUrl: \"https://day-nft.io\", id:id)\n} \n\npub fun    getNecryptolis(owner:PublicAccount, id:UInt64) : MetadataCollectionItem? {\n    return getItemForMetadataStandard(path: Necryptolis.ResolverCollectionPublicPath, owner: owner, externalFixedUrl: \"https://www.necryptolis.com\", id:id)\n}\n\npub fun    getFlowverseSocks(owner:PublicAccount, id:UInt64) : MetadataCollectionItem? {\n    let raribleCap = owner.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(RaribleNFT.collectionPublicPath)\n    if !raribleCap.check() {\n        return nil\n    }\n\n    let sockIds : [UInt64] = [14813, 15013, 14946, 14808, 14899, 14792, 15016, 14961, 14816, 14796, 14992, 14977, 14815, 14863, 14817, 14814, 14875, 14960, 14985, 14850, 14849, 14966, 14826, 14972, 14795, 15021, 14950, 14847, 14970, 14833, 14786, 15010, 14953, 14799, 14883, 14947, 14844, 14801, 14886, 15015, 15023, 15027, 15029, 14802, 14810, 14948, 14955, 14957, 14988, 15007, 15009, 14837, 15024, 14803, 14973, 14969, 15002, 15017, 14797, 14894, 14881, 15025, 14791, 14979, 14789, 14993, 14873, 14939, 15005, 15006, 14869, 14889, 15004, 15008, 15026, 14990, 14998, 14898, 14819, 14840, 14974, 15019, 14856, 14838, 14787, 14876, 14996, 14798, 14855, 14824, 14843, 14959, 15020, 14862, 14822, 14897, 14830, 14790, 14867, 14878, 14991, 14835, 14818, 14892, 14800, 15000, 14857, 14986, 14805, 14812, 14962]\n\n    if !sockIds.contains(id) {\n        return nil\n    }\n\n    let collection = raribleCap.borrow()!\n    collection.borrowNFT(id:id)!\n\n    return MetadataCollectionItem(\n        id: id,\n        name: \"Flowverse socks\",\n        image: \"https://img.rarible.com/prod/video/upload/t_video_big/prod-itemAnimations/FLOW-A.01ab36aaf654a13e.RaribleNFT:15029/b1cedf3\",\n        url: \"https://www.flowverse.co/socks\",\n        listPrice: nil,\n        listToken: nil,\n        contentType: \"video\",\n        rarity: \"\"\n    )\n}\n\npub fun    getFloat(owner:PublicAccount, id:UInt64) : MetadataCollectionItem? {\n    let address=owner.address!\n    return getItemForMetadataStandard(path: FLOAT.FLOATCollectionPublicPath, owner: owner, externalFixedUrl: \"https://floats.city/\".concat(address.toString()), id:id)\n}\n\npub fun    getMintStore(owner:PublicAccount, id:UInt64) : MetadataCollectionItem? {\n    let mintStoreCap = owner.getCapability\u003c\u0026{MintStoreItem.MintStoreItemCollectionPublic}\u003e(MintStoreItem.CollectionPublicPath)\n    if !mintStoreCap.check() {\n        return nil\n    }\n    let collection = mintStoreCap.borrow()!\n    let nft = collection.borrowMintStoreItem(id: id)!\n    let display= nft.resolveView(Type\u003cMetadataViews.Display\u003e())! as! MetadataViews.Display\n\n    let merchantName = MintStoreItem.getMerchant(merchantID:nft.data.merchantID)!\n    let editionData = MintStoreItem.EditionData(editionID: nft.data.editionID)!\n    var external_domain = \"\"\n    switch merchantName {\n    case \"Bulls\":\n        external_domain =  \"https://bulls.mint.store\"\n        break;\n    case \"Charlotte Hornets\":\n        external_domain =  \"https://hornets.mint.store\"\n        break;\n    default:\n        external_domain =  \"\"\n    }\n    if editionData!.metadata[\"nftType\"]! == \"Type C\" {\n        external_domain =  \"https://misa.art/collections/nft\"\n    }\n\n    let name=editionData.name\n    let image = editionData.metadata[\"thumbnail\"] ?? \"\"\n    return MetadataCollectionItem(\n        id: id,\n        name: name,\n        image: image,\n        url: external_domain,\n        listPrice: nil,\n        listToken: nil,\n        contentType: \"image\",\n        rarity: \"\"\n    )\n}\n\npub fun    getSomePlace(owner:PublicAccount, id:UInt64) : MetadataCollectionItem? {\n    let somePlaceCap =owner.getCapability\u003c\u0026{SomePlaceCollectible.CollectibleCollectionPublic}\u003e(SomePlaceCollectible.CollectionPublicPath)\n    if !somePlaceCap.check() {\n        return nil\n    }\n    let collection = somePlaceCap.borrow()!\n    let nft = collection.borrowCollectible(id: id)!\n    let setID = nft.setID\n    let setMetadata = SomePlaceCollectible.getMetadataForSetID(setID: setID)!\n    let editionMetadata = SomePlaceCollectible.getMetadataForNFTByUUID(uuid: nft.id)!\n    return MetadataCollectionItem(\n        id: id,\n        name: editionMetadata.getMetadata()[\"title\"] ?? setMetadata.getMetadata()[\"title\"] ?? \"\",\n        image: editionMetadata.getMetadata()[\"mediaURL\"] ?? setMetadata.getMetadata()[\"mediaURL\"] ?? \"\",\n        url: \"https://some.place\",\n        listPrice: nil,\n        listToken: nil,\n        contentType: \"image\",\n        rarity: \"\"\n    )\n}\n\n\npub fun    getBl0xPack(owner:PublicAccount, id:UInt64) : MetadataCollectionItem? {\n    return getItemForMetadataStandard(path: Bl0xPack.CollectionPublicPath, owner: owner, externalFixedUrl: \"http://bl0x.xyz\", id:id)\n}\n\npub fun    getBl0x(owner:PublicAccount, id:UInt64) : MetadataCollectionItem? {\n    return getItemForMetadataStandard(path: Bl0x.CollectionPublicPath, owner: owner, externalFixedUrl: \"http://bl0x.xyz\", id:id)\n}\n\n\n//This uses a view from Neo until we agree on another for ExternalDomainViewUrl\npub fun getItemForMetadataStandard(path: PublicPath, owner:PublicAccount, externalFixedUrl: String, id:UInt64) : MetadataCollectionItem? {\n    let resolverCollectionCap= owner.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(path)\n    if !resolverCollectionCap.check() {\n        return nil\n    }\n    let collection = resolverCollectionCap.borrow()!\n    let nft = collection.borrowViewResolver(id: id)!\n\n    if let displayView = nft.resolveView(Type\u003cMetadataViews.Display\u003e()) {\n        let display = displayView as! MetadataViews.Display\n        var externalUrl=externalFixedUrl\n        if let externalUrlView = nft.resolveView(Type\u003cMetadataViews.ExternalURL\u003e()) {\n            let url= externalUrlView! as! MetadataViews.ExternalURL\n            externalUrl=url.url\n        }\n\n        return MetadataCollectionItem(\n            id: id,\n            name: display.name,\n            image: display.thumbnail.uri(),\n            url: externalUrl,\n            listPrice: nil,\n            listToken: nil,\n            contentType: \"image\",\n            rarity: \"\"\n        )\n    }\n    return nil\n}\n\n/*\npub fun main(user: String) : {String: [UInt64]} {\n    let resolvingAddress = FIND.resolve(user)\n    if resolvingAddress == nil {\n        return {}\n    }\n    let address = resolvingAddress!\n\n    return getNFTIDs(ownerAddress: address)\n}\n*/\n\n\npub fun main(address: Address, ids: {String:[UInt64]}): [MetadataCollectionItem] {\n\n    return getNFTs(ownerAddress:address, ids:ids)\n}",
               "spec": {
                  "order": [
                     "address",
                     "ids"
                  ],
                  "parameters": {
                     "address": "Address",
                     "ids": "{String: [UInt64]}"
                  }
               }
            },
            "getName": {
               "code": "import FIND from 0x097bafa4e0b48eef\n\npub fun main(address: Address) : String?{\n    return FIND.reverseLookup(address)\n}",
               "spec": {
                  "order": [
                     "address"
                  ],
                  "parameters": {
                     "address": "Address"
                  }
               }
            },
            "getNameDetails": {
               "code": "import FIND from 0x097bafa4e0b48eef\nimport Profile from 0x097bafa4e0b48eef\nimport RelatedAccounts from 0x097bafa4e0b48eef\n\npub struct FINDReport {\n    pub let profile:Profile.UserReport?\n    pub let bids: [FIND.BidInfo]\n    pub let relatedAccounts: { String: Address}\n    pub let leases: [FIND.LeaseInformation]\n    pub let privateMode: Bool\n    pub let activatedAccount: Bool \n\n\n    init(profile: Profile.UserReport?, relatedAccounts: {String: Address}, bids: [FIND.BidInfo], leases : [FIND.LeaseInformation], privateMode: Bool, activatedAccount: Bool ) {\n        self.profile=profile\n        self.bids=bids\n        self.leases=leases\n        self.relatedAccounts=relatedAccounts\n        self.privateMode=privateMode\n        self.activatedAccount=activatedAccount\n    }\n}\n\npub struct NameReport {\n    pub let status: String\n    pub let cost: UFix64 \n    pub let leaseStatus: FIND.LeaseInformation?\n    pub let userReport: FINDReport? \n\n    init(status: String, cost: UFix64, leaseStatus: FIND.LeaseInformation?, userReport: FINDReport? ) {\n        self.status=status \n        self.cost=cost \n        self.leaseStatus=leaseStatus\n        self.userReport=userReport\n    }\n}\n\npub fun main(user: String) : NameReport? {\n\n    var findReport: FINDReport? = nil\n    var nameLease: FIND.LeaseInformation? = nil\n    if let address=FIND.resolve(user) {\n        let account=getAccount(address)\n        if account.balance != 0.0 {\n            let bidCap = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n            let leaseCap = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n            let profile=account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath).borrow()\n\n            var profileReport = profile?.asReport() \n            if profileReport != nil \u0026\u0026 profileReport!.findName != FIND.reverseLookup(address) {\n                profileReport = Profile.UserReport(\n                    findName: \"\",\n                    address: profileReport!.address,\n                    name: profileReport!.name,\n                    gender: profileReport!.gender,\n                    description: profileReport!.description,\n                    tags: profileReport!.tags,\n                    avatar: profileReport!.avatar,\n                    links: profileReport!.links,\n                    wallets: profileReport!.wallets, \n                    following: profileReport!.following,\n                    followers: profileReport!.followers,\n                    allowStoringFollowers: profileReport!.allowStoringFollowers,\n                    createdAt: profileReport!.createdAt\n                )\n            }\n\n            findReport = FINDReport(\n                profile: profileReport,\n                relatedAccounts: RelatedAccounts.findRelatedFlowAccounts(address:address),\n                bids: bidCap.borrow()?.getBids() ?? [],\n                leases: leaseCap.borrow()?.getLeaseInformation() ?? [],\n                privateMode: profile?.isPrivateModeEnabled() ?? false, \n                activatedAccount: true\n            )\n            if FIND.validateFindName(user) \u0026\u0026 findReport != nil {\n                for lease in findReport!.leases {\n                    if lease.name == user {\n                        nameLease = lease\n                        break\n                    }\n                }\n            }\n        } else {\n            findReport = FINDReport(\n                profile: nil,\n                relatedAccounts: {},\n                bids: [],\n                leases: [],\n                privateMode: false, \n                activatedAccount: false\n            )\n        }\n        \n    }\n\n    var nameReport : NameReport? = nil \n    if FIND.validateFindName(user) {\n        let status = FIND.status(user)\n        let cost=FIND.calculateCost(user)\n        var s=\"TAKEN\"    \n        if status.status == FIND.LeaseStatus.FREE {\n            s=\"FREE\"\n        } else if status.status == FIND.LeaseStatus.LOCKED {\n            s=\"LOCKED\"\n        }\n        nameReport = NameReport(status: s, cost: cost, leaseStatus: nameLease, userReport: findReport)\n    }\n    \n\n    return nameReport\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "getNameStatus": {
               "code": "import FIND from 0x097bafa4e0b48eef\nimport Profile from 0x097bafa4e0b48eef\n\npub fun main(name: String) :  \u0026{Profile.Public}? {\n    return FIND.lookup(name)\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "getNames": {
               "code": "import FIND from 0x097bafa4e0b48eef\n\npub fun main(address: [Address]) : { Address:String}{\n\n    let items : {Address:String} = {}\n    for a in address {\n        if let name= FIND.reverseLookup(a) {\n            items[a]=name\n        }\n    }\n    return items\n}",
               "spec": {
                  "order": [
                     "address"
                  ],
                  "parameters": {
                     "address": "[Address]"
                  }
               }
            },
            "getNamesWithBids": {
               "code": "import FIND from 0x097bafa4e0b48eef\n\npub fun main(user: String) : [FIND.LeaseInformation] {\n\n    let resolveAddress = FIND.resolve(user) \n    if resolveAddress == nil {return []}\n    let address = resolveAddress!\n    let account=getAccount(address)\n\n    if account.balance == 0.0 {\n        return []\n    }\n\n    let leaseCap = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\n    let leases=leaseCap.borrow()?.getLeaseInformation() ?? []\n\n    var leasesWithBids :[FIND.LeaseInformation] =[]\n    for lease in leases {\n        if lease.latestBidBy != nil {\n            leasesWithBids.append(lease)\n        }\n    }\n\n    return leasesWithBids\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "getNamesWithoutBids": {
               "code": "import FIND from 0x097bafa4e0b48eef\n\n\npub fun main(user: String) : [String] {\n\n    let resolveAddress = FIND.resolve(user) \n    if resolveAddress == nil {return []}\n    let address = resolveAddress!\n    let account=getAccount(address)\n\n    if account.balance == 0.0 {\n        return []\n    }\n\n    let leaseCap = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\n    let leases=leaseCap.borrow()?.getLeaseInformation() ?? []\n\n    var leasesWithBids :[String] =[]\n    for lease in leases {\n        if lease.latestBidBy == nil {\n            leasesWithBids.append(lease.name)\n        }\n    }\n\n    return leasesWithBids\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "getProfile": {
               "code": "import Profile from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\n\npub fun main(user: String) :  Profile.UserReport? {\n    let resolveAddress = FIND.resolve(user) \n    if resolveAddress == nil {return nil}\n    let address = resolveAddress!\n    let account = getAccount(address)\n    if account.balance == 0.0 {\n        return nil\n    }\n\n    var profileReport = account\n        .getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        .borrow()?.asReport()\n\n    if profileReport != nil \u0026\u0026 profileReport!.findName != FIND.reverseLookup(address) {\n        profileReport = Profile.UserReport(\n            findName: \"\",\n            address: profileReport!.address,\n            name: profileReport!.name,\n            gender: profileReport!.gender,\n            description: profileReport!.description,\n            tags: profileReport!.tags,\n            avatar: profileReport!.avatar,\n            links: profileReport!.links,\n            wallets: profileReport!.wallets, \n            following: profileReport!.following,\n            followers: profileReport!.followers,\n            allowStoringFollowers: profileReport!.allowStoringFollowers,\n            createdAt: profileReport!.createdAt\n        )\n    }\n\n    return profileReport\n\n\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "getRoyaltyChangedIds": {
               "code": "import FindMarket from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\n\npub fun main(marketplace: Address, user: String) : {String : [UInt64]} {\n    if let address = FIND.resolve(user){\n        return FindMarket.getRoyaltiesChangedIds(tenant:marketplace, address: address)\n    }\n    return {}\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "user"
                  ],
                  "parameters": {
                     "marketplace": "Address",
                     "user": "String"
                  }
               }
            },
            "getRoyaltyChangedItems": {
               "code": "import FindMarket from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\n\npub fun main(marketplace: Address, user: String) : {String : FindMarket.SaleItemCollectionReport} {\n    if let address = FIND.resolve(user){\n        return FindMarket.getRoyaltiesChangedItems(tenant:marketplace, address: address)\n    }\n    return {}\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "user"
                  ],
                  "parameters": {
                     "marketplace": "Address",
                     "user": "String"
                  }
               }
            },
            "getShardCollectionsNFTCatalog": {
               "code": "import NonFungibleToken from 0x1d7e57aa55817448\nimport FIND from 0x097bafa4e0b48eef\nimport FINDNFTCatalog from 0x097bafa4e0b48eef\n\npub fun main(user: String) : {String : CollectionLength} {\n\n    if let address = FIND.resolve(user) {\n\n        return getNFTIDs_Catalog(ownerAddress: address, cacheCollections: {})\n\n    }\n    return {}\n\n}\n\npub struct CollectionLength {\n    pub let shard : String \n    pub let length : Int \n    init(shard : String, length : Int ) {\n        self.shard=shard \n        self.length=length\n    }\n}\n\n// Helper function \n\npub fun resolveAddress(user: String) : Address? {\n    return FIND.resolve(user)\n}\n\npub fun getNFTIDs_Catalog(ownerAddress: Address, cacheCollections: {String:CollectionLength}) : {String:CollectionLength} {\n\n    let account = getAuthAccount(ownerAddress)\n\n    let types = FINDNFTCatalog.getCatalogTypeData()\n    for nftType in types.keys {\n\n        let typeData=types[nftType]!\n        let collectionKey=typeData.keys[0]\n        let catalogEntry = FINDNFTCatalog.getCatalogEntry(collectionIdentifier:collectionKey)!\n        let tempPathStr = \"catalog\".concat(collectionKey)\n        let tempPublicPath = PublicPath(identifier: tempPathStr)!\n        account.link\u003c\u0026NonFungibleToken.Collection\u003e(tempPublicPath, target: catalogEntry.collectionData.storagePath)\n        let cap= account.getCapability\u003c\u0026NonFungibleToken.Collection\u003e(tempPublicPath)\n        if cap.check(){\n            let collection = cap.borrow()!\n            let length = collection.ownedNFTs.length\n            if length == 0 {\n                continue\n            }\n            cacheCollections[collectionKey] = CollectionLength(shard: \"NFTCatalog\", length: length)\n        }\n    }\n    return cacheCollections\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "getSocksIDs": {
               "code": "import NonFungibleToken from 0x1d7e57aa55817448\nimport MetadataViews from 0x1d7e57aa55817448\nimport FIND from 0x097bafa4e0b48eef\nimport RaribleNFT from 0x01ab36aaf654a13e\n\npub fun main(user: String, collections: [String]) : {String : ItemReport} {\n    return fetchRaribleNFT(user: user, targetCollections: collections)\n}\n\npub let FlowverseSocksIds : [UInt64] = [14813, 15013, 14946, 14808, 14899, 14792, 15016, 14961, 14816, 14796, 14992, 14977, 14815, 14863, 14817, 14814, 14875, 14960, 14985, 14850, 14849, 14966, 14826, 14972, 14795, 15021, 14950, 14847, 14970, 14833, 14786, 15010, 14953, 14799, 14883, 14947, 14844, 14801, 14886, 15015, 15023, 15027, 15029, 14802, 14810, 14948, 14955, 14957, 14988, 15007, 15009, 14837, 15024, 14803, 14973, 14969, 15002, 15017, 14797, 14894, 14881, 15025, 14791, 14979, 14789, 14993, 14873, 14939, 15005, 15006, 14869, 14889, 15004, 15008, 15026, 14990, 14998, 14898, 14819, 14840, 14974, 15019, 14856, 14838, 14787, 14876, 14996, 14798, 14855, 14824, 14843, 14959, 15020, 14862, 14822, 14897, 14830, 14790, 14867, 14878, 14991, 14835, 14818, 14892, 14800, 15000, 14857, 14986, 14805, 14812, 14962]\n\npub struct ItemReport {\n    pub let length : Int // mapping of collection to no. of ids \n    pub let extraIDs : [UInt64]\n    pub let shard : String \n    pub let extraIDsIdentifier : String \n\n    init(length : Int, extraIDs :[UInt64] , shard: String, extraIDsIdentifier: String) {\n        self.length=length \n        self.extraIDs=extraIDs\n        self.shard=shard\n        self.extraIDsIdentifier=extraIDsIdentifier\n    }\n}\n\npub struct MetadataCollectionItem {\n    pub let id:UInt64\n    pub let name: String\n    pub let collection: String // \u003c- This will be Alias unless they want something else\n    pub let subCollection: String? // \u003c- This will be Alias unless they want something else\n    pub let nftDetailIdentifier: String\n\n    pub let media  : String\n    pub let mediaType : String \n    pub let source : String \n\n    init(id:UInt64, name: String, collection: String, subCollection: String?, media  : String, mediaType : String, source : String, nftDetailIdentifier: String) {\n        self.id=id\n        self.name=name \n        self.collection=collection \n        self.subCollection=subCollection \n        self.media=media \n        self.mediaType=mediaType \n        self.source=source\n        self.nftDetailIdentifier=nftDetailIdentifier\n    }\n}\n\n// Helper function \n\npub fun resolveAddress(user: String) : Address? {\n    return FIND.resolve(user)\n}\n\npub fun getNFTIDs(ownerAddress: Address) : {String:[UInt64]} {\n\n    let account = getAuthAccount(ownerAddress)\n\n    let inventory : {String:[UInt64]}={}\n\n    let tempPathStr = \"RaribleNFT\"\n    let tempPublicPath = PublicPath(identifier: tempPathStr)!\n    account.link\u003c\u0026RaribleNFT.Collection\u003e(tempPublicPath, target: RaribleNFT.collectionStoragePath)\n    let cap= account.getCapability\u003c\u0026RaribleNFT.Collection\u003e(tempPublicPath)\n    if cap.check(){\n            // let rarible : [UInt64] = []\n            let socks : [UInt64] = []\n        for id in cap.borrow()!.getIDs() {\n            if FlowverseSocksIds.contains(id) {\n                socks.append(id)\n            // } else {\n            //     rarible.append(id)\n            }\n        }\n\n        // inventory[\"RaribleNFT\"] = rarible\n        inventory[\"FlowverseSocks\"] = socks\n\n    }\n    \n    return inventory\n}\n\npub fun fetchRaribleNFT(user: String, targetCollections: [String]) : {String : ItemReport} {\n    let source = \"RaribleNFT\"\n    let account = resolveAddress(user: user)\n    if account == nil { return {} }\n\n\n    let extraIDs = getNFTIDs(ownerAddress: account!)\n    let inventory : {String : ItemReport} = {}\n    var fetchedCount : Int = 0\n\n    for project in extraIDs.keys {\n        if extraIDs[project]! == nil || extraIDs[project]!.length \u003c 1{\n            extraIDs.remove(key: project)\n            continue\n        }\n        \n        let collectionLength = extraIDs[project]!.length\n\n        // by pass if this is not the target collection\n        if targetCollections.length \u003e 0 \u0026\u0026 !targetCollections.contains(project) {\n            // inventory[project] = ItemReport(items: [],  length : collectionLength, extraIDs :extraIDs[project]! , shard: source)\n            continue\n        }\n\n        inventory[project] = ItemReport(length : collectionLength, extraIDs :extraIDs[project] ?? [] , shard: source, extraIDsIdentifier: project)\n\n    }\n\n    return inventory\n\n}",
               "spec": {
                  "order": [
                     "user",
                     "collections"
                  ],
                  "parameters": {
                     "collections": "[String]",
                     "user": "String"
                  }
               }
            },
            "getSocksItems": {
               "code": "import NonFungibleToken from 0x1d7e57aa55817448\nimport MetadataViews from 0x1d7e57aa55817448\nimport FIND from 0x097bafa4e0b48eef\n\nimport RaribleNFT from 0x01ab36aaf654a13e\n\npub fun main(user: String, collectionIDs: {String : [UInt64]}) : {String : [MetadataCollectionItem]} {\n\n    return fetchRaribleNFTs(user: user, collectionIDs: collectionIDs)\n}\npub let FlowverseSocksIds : [UInt64] = [14813, 15013, 14946, 14808, 14899, 14792, 15016, 14961, 14816, 14796, 14992, 14977, 14815, 14863, 14817, 14814, 14875, 14960, 14985, 14850, 14849, 14966, 14826, 14972, 14795, 15021, 14950, 14847, 14970, 14833, 14786, 15010, 14953, 14799, 14883, 14947, 14844, 14801, 14886, 15015, 15023, 15027, 15029, 14802, 14810, 14948, 14955, 14957, 14988, 15007, 15009, 14837, 15024, 14803, 14973, 14969, 15002, 15017, 14797, 14894, 14881, 15025, 14791, 14979, 14789, 14993, 14873, 14939, 15005, 15006, 14869, 14889, 15004, 15008, 15026, 14990, 14998, 14898, 14819, 14840, 14974, 15019, 14856, 14838, 14787, 14876, 14996, 14798, 14855, 14824, 14843, 14959, 15020, 14862, 14822, 14897, 14830, 14790, 14867, 14878, 14991, 14835, 14818, 14892, 14800, 15000, 14857, 14986, 14805, 14812, 14962]\n\npub fun getNFTs(ownerAddress: Address, ids: [UInt64]) : [MetadataViews.NFTView] {\n\n    let account = getAuthAccount(ownerAddress)\n    let results : [MetadataViews.NFTView] = []\n    let tempPathStr = \"RaribleNFT\"\n    let tempPublicPath = PublicPath(identifier: tempPathStr)!\n    account.link\u003c\u0026RaribleNFT.Collection\u003e(tempPublicPath, target: RaribleNFT.collectionStoragePath)\n    let cap= account.getCapability\u003c\u0026RaribleNFT.Collection\u003e(tempPublicPath)\n    if cap.check(){\n        let collection = cap.borrow()!\n        for id in ids {\n\n            let authNFT = (\u0026collection.ownedNFTs[id] as auth \u0026NonFungibleToken.NFT?)!\n            let nft = authNFT as! \u0026RaribleNFT.NFT\n\n            let md = nft.getMetadata()\n\n            let display = MetadataViews.Display(\n                name: md[\"name\"] ?? \"\",\n                description: md[\"description\"] ?? \"\",\n                thumbnail: MetadataViews.HTTPFile(url: md[\"metaURI\"] ?? \"\"),\n            )\n\n            let view =  MetadataViews.NFTView(\n                id : id,\n                uuid: nft.uuid,\n                display: display,\n                externalURL : nil,\n                collectionData : nil,\n                collectionDisplay : nil,\n                royalties : nil,\n                traits : nil\n            )\n            results.append(view)\n        }\n    }\n    \n    return results\n}\n\npub struct CollectionReport {\n    pub let items : {String : [MetadataCollectionItem]} \n    pub let collections : {String : Int} // mapping of collection to no. of ids \n    pub let extraIDs : {String : [UInt64]} \n\n    init(items: {String : [MetadataCollectionItem]},  collections : {String : Int}, extraIDs : {String : [UInt64]} ) {\n        self.items=items \n        self.collections=collections \n        self.extraIDs=extraIDs\n    }\n}\n\npub struct MetadataCollectionItem {\n    pub let id:UInt64\n    pub let name: String\n    pub let collection: String // \u003c- This will be Alias unless they want something else\n    pub let subCollection: String? // \u003c- This will be Alias unless they want something else\n    pub let nftDetailIdentifier: String\n\n    pub let media  : String\n    pub let mediaType : String \n    pub let source : String \n\n    init(id:UInt64, name: String, collection: String, subCollection: String?, media  : String, mediaType : String, source : String, nftDetailIdentifier: String) {\n        self.id=id\n        self.name=name \n        self.collection=collection \n        self.subCollection=subCollection \n        self.media=media \n        self.mediaType=mediaType \n        self.source=source\n        self.nftDetailIdentifier=nftDetailIdentifier\n    }\n}\n\n// Helper function \n\npub fun resolveAddress(user: String) : PublicAccount? {\n    let address = FIND.resolve(user)\n    if address == nil {\n        return nil\n    }\n    return getAccount(address!)\n}\n\npub fun fetchRaribleNFTs(user: String, collectionIDs: {String : [UInt64]}) : {String : [MetadataCollectionItem]} {\n    let source = \"RaribleNFT\"\n    let account = resolveAddress(user: user)\n    if account == nil { return {} }\n    if account!.balance == 0.0 {\n        return {}\n    }\n\n    let items : {String : [MetadataCollectionItem]} = {}\n\n    let fetchingIDs = collectionIDs\n    for project in fetchingIDs.keys {\n\n        var collectionItems : [MetadataCollectionItem] = []\n        for id in fetchingIDs[project]! {\n\n            if !FlowverseSocksIds.contains(id) {\n                continue\n            }\n            \n            let image = \"https://img.rarible.com/prod/video/upload/t_video_big/prod-itemAnimations/FLOW-A.01ab36aaf654a13e.RaribleNFT:15029/b1cedf3\"\n            let item = MetadataCollectionItem(\n                id: id,\n                name: \"Flowverse socks\",\n                collection: \"Flowverse socks\",\n                subCollection: nil, \n                media: image,\n                mediaType: \"video\",\n                source: source, \n                nftDetailIdentifier: project \n            )\n            collectionItems.append(item)\n        }\n\n        if collectionItems.length \u003e 0 {\n            items[project] = collectionItems\n        }\n    }\n    return items\n}",
               "spec": {
                  "order": [
                     "user",
                     "collectionIDs"
                  ],
                  "parameters": {
                     "collectionIDs": "{String: [UInt64]}",
                     "user": "String"
                  }
               }
            },
            "getStatus": {
               "code": "import FIND from 0x097bafa4e0b48eef\nimport Profile from 0x097bafa4e0b48eef\nimport RelatedAccounts from 0x097bafa4e0b48eef\nimport FindMarket from 0x097bafa4e0b48eef\nimport FindLeaseMarket from 0x097bafa4e0b48eef\nimport FINDNFTCatalog from 0x097bafa4e0b48eef\nimport NonFungibleToken from 0x1d7e57aa55817448\nimport FindLostAndFoundWrapper from 0x097bafa4e0b48eef\nimport NFTCatalog from 0x49a7cda3a1eecc29\nimport EmeraldIdentity from 0x39e42c67cc851cfb\nimport EmeraldIdentityDapper from 0x39e42c67cc851cfb\nimport EmeraldIdentityLilico from 0x39e42c67cc851cfb\n\npub struct FINDReport{\n    pub let profile:Profile.UserReport?\n    pub let bids: [FIND.BidInfo]\n    pub let relatedAccounts: { String: Address}\n    pub let leases: [FIND.LeaseInformation]\n    pub let privateMode: Bool\n    pub let leasesForSale: {String : FindLeaseMarket.SaleItemCollectionReport}\n    pub let leasesBids: {String : FindLeaseMarket.BidItemCollectionReport}\n    pub let itemsForSale: {String : FindMarket.SaleItemCollectionReport}\n    pub let marketBids: {String : FindMarket.BidItemCollectionReport}\n    pub let activatedAccount: Bool \n\n    // NFT Catalog outputs\n    pub let lostAndFoundTypes: {String : NFTCatalog.NFTCollectionData}\n\n    // EmeraldID Account Linkage \n    pub let emeraldIDAccounts : {String : Address}\n\n\n    init(profile: Profile.UserReport?, \n         relatedAccounts: {String: Address}, \n         bids: [FIND.BidInfo], \n         leases : [FIND.LeaseInformation], \n         privateMode: Bool, \n         leasesForSale: {String : FindLeaseMarket.SaleItemCollectionReport}, \n         leasesBids: {String : FindLeaseMarket.BidItemCollectionReport}, \n         itemsForSale: {String : FindMarket.SaleItemCollectionReport}, \n         marketBids: {String : FindMarket.BidItemCollectionReport}, \n         activatedAccount: Bool, \n         lostAndFoundTypes: {String : NFTCatalog.NFTCollectionData}, \n         emeraldIDAccounts : {String : Address}\n         ) {\n\n        self.profile=profile\n        self.bids=bids\n        self.leases=leases\n        self.relatedAccounts=relatedAccounts\n        self.privateMode=privateMode\n        self.leasesForSale=leasesForSale\n        self.leasesBids=leasesBids\n        self.itemsForSale=itemsForSale\n        self.marketBids=marketBids\n        self.activatedAccount=activatedAccount\n        self.lostAndFoundTypes=lostAndFoundTypes\n        self.emeraldIDAccounts=emeraldIDAccounts\n    }\n}\n\npub struct NameReport {\n    pub let status: String \n    pub let cost: UFix64 \n\n    init(status: String, cost: UFix64) {\n        self.status=status \n        self.cost=cost\n    }\n}\n\npub struct Report {\n    pub let FINDReport: FINDReport?\n    pub let NameReport: NameReport?\n\n    init(FINDReport: FINDReport?, NameReport: NameReport?) {\n        self.FINDReport=FINDReport \n        self.NameReport=NameReport\n    }\n}\n\npub fun main(user: String) : Report? {\n\n    var findReport: FINDReport? = nil\n    if let address=FIND.resolve(user) {\n        let account=getAccount(address)\n        if account.balance \u003e 0.0 {\n            let bidCap = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n            let leaseCap = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n            let profile=account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath).borrow()\n\n            let find= FindMarket.getFindTenantAddress()\n            let findLease= FindMarket.getTenantAddress(\"findLease\")!\n            let items : {String : FindMarket.SaleItemCollectionReport} = FindMarket.getSaleItemReport(tenant:find, address: address, getNFTInfo:true)\n\n            let marketBids : {String : FindMarket.BidItemCollectionReport} = FindMarket.getBidsReport(tenant:find, address: address, getNFTInfo:true)\n\n            let leasesSale : {String : FindLeaseMarket.SaleItemCollectionReport} = FindLeaseMarket.getSaleItemReport(tenant:findLease, address: address, getLeaseInfo:true)\n\n            let leasesBids : {String : FindLeaseMarket.BidItemCollectionReport} = FindLeaseMarket.getBidsReport(tenant:findLease, address: address, getLeaseInfo:true)\n\n            var profileReport = profile?.asReport() \n            if profileReport != nil \u0026\u0026 profileReport!.findName != FIND.reverseLookup(address) {\n                profileReport = Profile.UserReport(\n                    findName: \"\",\n                    address: profileReport!.address,\n                    name: profileReport!.name,\n                    gender: profileReport!.gender,\n                    description: profileReport!.description,\n                    tags: profileReport!.tags,\n                    avatar: profileReport!.avatar,\n                    links: profileReport!.links,\n                    wallets: profileReport!.wallets, \n                    following: profileReport!.following,\n                    followers: profileReport!.followers,\n                    allowStoringFollowers: profileReport!.allowStoringFollowers,\n                    createdAt: profileReport!.createdAt\n                )\n            }\n\n            // NFTCatalog Output \n            let nftCatalogTypes = FINDNFTCatalog.getCatalogTypeData()\n            let types : {String : NFTCatalog.NFTCollectionData} = {}\n            for type in FindLostAndFoundWrapper.getSpecificRedeemableTypes(user: address, specificType: Type\u003c@NonFungibleToken.NFT\u003e()) {\n                types[type.identifier] = FINDNFTCatalog.getCollectionDataForType(nftTypeIdentifier: type.identifier)\n            }\n\n            let discordID = EmeraldIdentity.getDiscordFromAccount(account: address) \n                                    ?? EmeraldIdentityDapper.getDiscordFromAccount(account: address) \n                                    ?? EmeraldIdentityLilico.getDiscordFromAccount(account: address)\n                                    ?? \"\"\n\n            let emeraldIDAccounts : {String : Address} = {}\n            emeraldIDAccounts[\"blocto\"] = EmeraldIdentity.getAccountFromDiscord(discordID: discordID)\n            emeraldIDAccounts[\"lilico\"] = EmeraldIdentityLilico.getAccountFromDiscord(discordID: discordID)\n            emeraldIDAccounts[\"dapper\"] = EmeraldIdentityDapper.getAccountFromDiscord(discordID: discordID)\n            \n            findReport = FINDReport(\n                profile: profileReport,\n                relatedAccounts: RelatedAccounts.findRelatedFlowAccounts(address:address),\n                bids: bidCap.borrow()?.getBids() ?? [],\n                leases: leaseCap.borrow()?.getLeaseInformation() ?? [],\n                privateMode: profile?.isPrivateModeEnabled() ?? false,\n                leasesForSale: leasesSale, \n                leasesBids: leasesBids,\n                itemsForSale: items,\n                marketBids: marketBids,\n                activatedAccount: true, \n                lostAndFoundTypes: types, \n                emeraldIDAccounts: emeraldIDAccounts\n            )\n        } else {\n            findReport = FINDReport(\n                profile: nil,\n                relatedAccounts: {},\n                bids: [],\n                leases: [],\n                privateMode: false,\n                leasesForSale: {}, \n                leasesBids: {},\n                itemsForSale: {},\n                marketBids: {},\n                activatedAccount: false, \n                lostAndFoundTypes: {}, \n                emeraldIDAccounts: {}\n            )\n        }\n    }\n\n    var nameReport : NameReport? = nil \n    if FIND.validateFindName(user) {\n        let status = FIND.status(user)\n        let cost=FIND.calculateCost(user)\n        var s=\"TAKEN\"    \n        if status.status == FIND.LeaseStatus.FREE {\n            s=\"FREE\"\n        } else if status.status == FIND.LeaseStatus.LOCKED {\n            s=\"LOCKED\"\n        }\n        nameReport = NameReport(status: s, cost: cost)\n    }\n    \n\n    return Report(FINDReport: findReport, NameReport: nameReport)\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "getStoreFrontListings": {
               "code": "import FIND from 0x097bafa4e0b48eef\n\nimport NFTStorefront from 0x4eb8a10cb9f87357\nimport Marketplace from 0xd796ff17107bbff6\nimport Art from 0xd796ff17107bbff6\nimport FlowToken from 0x1654653399040a61\nimport Flovatar from 0x921ea449dffec68a\nimport FlovatarMarketplace from  0x921ea449dffec68a\n\n// This script returns the details for a listing within a storefront\n\npub struct Listing {\n    pub let marketplace : String\n    pub let ftVault: Type\n    pub let price:UFix64\n    pub let nftType: Type\n    pub let nftId: UInt64\n\n    init(marketplace:String, ftVault:Type, price:UFix64, nftType:Type, nftId:UInt64) {\n        self.marketplace=marketplace\n        self.ftVault=ftVault\n        self.price=price\n        self.nftType=nftType\n        self.nftId=nftId\n    }\n}\n\npub fun main(user: String): {UInt64 :[Listing]} {\n\n    let resolveAddress = FIND.resolve(user) \n    if resolveAddress == nil {return {}}\n    let address = resolveAddress!\n    let account=getAccount(address)\n    if account.balance == 0.0 {\n        return {}\n    }\n    let storefrontRef = account.getCapability\u003c\u0026NFTStorefront.Storefront{NFTStorefront.StorefrontPublic}\u003e(NFTStorefront.StorefrontPublicPath).borrow()!\n\n    let listings : {UInt64 : [Listing]} = {}\n\n    for id in storefrontRef.getListingIDs() {\n        let listing = storefrontRef.borrowListing(listingResourceID: id)!\n        let details=listing.getDetails()\n        if details.purchased==true {\n            continue\n        }\n        let uuid=listing.borrowNFT()!.uuid\n\n        let item = Listing( \n            marketplace:\"nftstorefront-\".concat(details.storefrontID.toString()),\n            ftVault: details.salePaymentVaultType, \n            price: details.salePrice,\n            nftType:details.nftType,\n            nftId: details.nftID,\n        )\n        let uuidListings= listings[uuid] ?? []\n        uuidListings.append(item)\n        listings[uuid]= uuidListings\n    }\n\n\n    let versusMarketplace = account.getCapability\u003c\u0026{Marketplace.SalePublic}\u003e(Marketplace.CollectionPublicPath)\n    if versusMarketplace.check() {\n\n        let versusMarket = versusMarketplace.borrow()!\n\n        let saleItems = versusMarket.listSaleItems()\n        for saleItem in saleItems {\n\n            let item = Listing( \n                marketplace:\"versus\",\n                ftVault: Type\u003c@FlowToken.Vault\u003e(),\n                price: saleItem.price,\n                nftType:Type\u003c@Art.NFT\u003e(),\n                nftId: saleItem.id\n            )\n\n            let uuid = versusMarket.getUUIDforSaleItem(tokenID: saleItem.id)\n            //let uuid = art.borrowNFT(id:saleItem.id)!.uuid\n            let uuidListings= listings[uuid] ?? []\n            uuidListings.append(item)\n            listings[uuid]= uuidListings\n\n        }\n    }\n\n\n\n    let flovatarCap = account.getCapability\u003c\u0026{FlovatarMarketplace.SalePublic}\u003e(FlovatarMarketplace.CollectionPublicPath)  \n    if flovatarCap.check(){\n        let saleCollection=flovatarCap.borrow()!\n        for id in saleCollection.getFlovatarIDs() {\n            let price = saleCollection.getFlovatarPrice(tokenId: id)!\n            let flovatar = saleCollection.getFlovatar(tokenId: id)!\n\n            let item = Listing( \n                marketplace:\"flovatar\",\n                ftVault: Type\u003c@FlowToken.Vault\u003e(),\n                price: price,\n                nftType:Type\u003c@Flovatar.NFT\u003e(),\n                nftId: id\n            )\n\n            let uuid =  flovatar.uuid\n            //let uuid = art.borrowNFT(id:saleItem.id)!.uuid\n            let uuidListings= listings[uuid] ?? []\n            uuidListings.append(item)\n            listings[uuid]= uuidListings\n        }\n    }\n    return listings\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "getTenantSaleItem": {
               "code": "import FindMarket from 0x097bafa4e0b48eef\n\npub fun main(tenant: Address) : TenantSaleItems {\n    let tenantCap = FindMarket.getTenantCapability(tenant) ?? panic(\"No tenant capability is set up. Tenant Address : \".concat(tenant.toString()))\n    let tenantRef = tenantCap.borrow() ?? panic(\"Cannot borrow tenant reference. Tenant Address : \".concat(tenant.toString()))\n    let saleItems = tenantRef.getSaleItems()\n    return TenantSaleItems(findSaleItems: saleItems[\"findSaleItems\"]! ,\n                           tenantSaleItems: saleItems[\"tenantSaleItems\"]! ,\n                           findCuts: saleItems[\"findCuts\"]! )\n\n}\n\npub struct TenantSaleItems {\n    pub let findSaleItems : {String : FindMarket.TenantSaleItem}\n    pub let tenantSaleItems : {String : FindMarket.TenantSaleItem}\n    pub let findCuts : {String : FindMarket.TenantSaleItem} \n\n    init(findSaleItems : {String : FindMarket.TenantSaleItem}, \n         tenantSaleItems : {String : FindMarket.TenantSaleItem},\n         findCuts : {String : FindMarket.TenantSaleItem}) {\n             self.findSaleItems = findSaleItems\n             self.tenantSaleItems = tenantSaleItems \n             self.findCuts = findCuts \n         }\n}",
               "spec": {
                  "order": [
                     "tenant"
                  ],
                  "parameters": {
                     "tenant": "Address"
                  }
               }
            },
            "hasCharity": {
               "code": "import CharityNFT from 0x097bafa4e0b48eef\n\npub fun main(user: Address) : Bool {\n    let account=getAccount(user)\n    if account.balance == 0.0 {\n        return false\n    }\n    let charityCap = account.getCapability\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection)\n    return charityCap.check()\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "Address"
                  }
               }
            },
            "isFindUser": {
               "code": "import Profile from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\n\npub fun main(user: Address) : Bool {\n\n    let account=getAccount(user)\n    if account.balance == 0.0 {\n        return false\n    }\n    let leaseCap=account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n    let profileCap=account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\n    return leaseCap.check() \u0026\u0026 profileCap.check()\n\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "Address"
                  }
               }
            },
            "resolve": {
               "code": "import FIND from 0x097bafa4e0b48eef\n\npub fun main(input:String) : Address?{\n    return FIND.resolve(input)\n}",
               "spec": {
                  "order": [
                     "input"
                  ],
                  "parameters": {
                     "input": "String"
                  }
               }
            }
         },
         "transactions": {
            "acceptDirectOfferSoft": {
               "code": "import FindMarketDirectOfferSoft from 0x097bafa4e0b48eef\nimport NonFungibleToken from 0x1d7e57aa55817448\nimport MetadataViews from 0x1d7e57aa55817448\nimport FindViews from 0x097bafa4e0b48eef\nimport FINDNFTCatalog from 0x097bafa4e0b48eef\nimport FindMarket from 0x097bafa4e0b48eef\n\ntransaction(marketplace:Address, id: UInt64) {\n\n    let market : \u0026FindMarketDirectOfferSoft.SaleItemCollection\n    let pointer : FindViews.AuthNFTPointer\n\n    prepare(account: AuthAccount) {\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e())\n        self.market = account.borrow\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection\u003e(from: storagePath)!\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e())\n        let item = FindMarket.assertOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: id)\n        let nftIdentifier = item.getItemType().identifier\n\n        //If this is nil, there must be something wrong with FIND setup\n        // let privatePath = getPrivatePath(nftIdentifier)\n\n        let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier)) \n        let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n        let privatePath = collection.collectionData.privatePath\n\n\n        let providerCap=account.getCapability\u003c\u0026{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e(privatePath)\n        self.pointer= FindViews.AuthNFTPointer(cap: providerCap, id: item.getItemID())\n    }\n\n    execute {\n        self.market.acceptOffer(self.pointer)\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "acceptDirectOfferSoftDUC": {
               "code": "import FindMarketDirectOfferSoft from 0x097bafa4e0b48eef\nimport NonFungibleToken from 0x1d7e57aa55817448\nimport MetadataViews from 0x1d7e57aa55817448\nimport FindViews from 0x097bafa4e0b48eef\nimport NFTCatalog from 0x49a7cda3a1eecc29\nimport FINDNFTCatalog from 0x097bafa4e0b48eef\nimport FindMarket from 0x097bafa4e0b48eef\nimport FungibleToken from 0xf233dcee88fe0abe\nimport TokenForwarding from 0xe544175ee0461c4b\nimport DapperUtilityCoin from 0xead892083b3e2c6c\nimport Profile from 0x097bafa4e0b48eef\n\ntransaction(dapperAddress: Address, marketplace:Address, id: UInt64) {\n\n    let market : \u0026FindMarketDirectOfferSoft.SaleItemCollection\n    let pointer : FindViews.AuthNFTPointer\n\n    prepare(account: AuthAccount) {\n\n        let ducReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver)\n        if !ducReceiver.check() {\n            let dapper = getAccount(dapperAddress)\n            // Create a new Forwarder resource for DUC and store it in the new account's storage\n            let ducForwarder \u003c- TokenForwarding.createNewForwarder(recipient: dapper.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver))\n            account.save(\u003c-ducForwarder, to: /storage/dapperUtilityCoinReceiver)\n            // Publish a Receiver capability for the new account, which is linked to the DUC Forwarder\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver,target: /storage/dapperUtilityCoinReceiver)\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n        if !profile.hasWallet(\"DUC\") {\n            profile.addWallet(Profile.Wallet( name:\"DUC\", receiver:ducReceiver, balance:getAccount(dapperAddress).getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/dapperUtilityCoinBalance), accept: Type\u003c@DapperUtilityCoin.Vault\u003e(), tags: [\"duc\", \"dapperUtilityCoin\",\"dapper\"]))\n            profile.emitUpdatedEvent()\n        }\n\n\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e())\n        self.market = account.borrow\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection\u003e(from: storagePath)!\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e())\n        let item = FindMarket.assertOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: id)\n        let nftIdentifier = item.getItemType().identifier\n\n        //If this is nil, there must be something wrong with FIND setup\n        // let nft = getCollectionData(nftIdentifier)\n        let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier)) \n        let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n        let nft = collection.collectionData\n\n        let providerCap=account.getCapability\u003c\u0026{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e(nft.privatePath)\n        self.pointer= FindViews.AuthNFTPointer(cap: providerCap, id: item.getItemID())\n\n    }\n\n    execute {\n        self.market.acceptOffer(self.pointer)\n    }\n    \n}",
               "spec": {
                  "order": [
                     "dapperAddress",
                     "marketplace",
                     "id"
                  ],
                  "parameters": {
                     "dapperAddress": "Address",
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "acceptLeaseDirectOfferSoft": {
               "code": "import FindLeaseMarketDirectOfferSoft from 0x097bafa4e0b48eef\nimport NonFungibleToken from 0x1d7e57aa55817448\nimport MetadataViews from 0x1d7e57aa55817448\nimport FindViews from 0x097bafa4e0b48eef\nimport FindMarket from 0x097bafa4e0b48eef\nimport FindLeaseMarket from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\n\ntransaction(leaseName: String) {\n\n    let market : \u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection\n    let pointer : FindLeaseMarket.AuthLeasePointer\n\n    prepare(account: AuthAccount) {\n        let marketplace = FindMarket.getTenantAddress(\"findLease\")!\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e())\n        self.market = account.borrow\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(from: storagePath)!\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e())\n        let item = FindLeaseMarket.assertOperationValid(tenant: marketplace, name: leaseName, marketOption: marketOption)\n        let ref = account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from: FIND.LeaseStoragePath) ?? panic(\"Cannot borrow reference to find lease collection. Account : \".concat(account.address.toString()))\n        self.pointer= FindLeaseMarket.AuthLeasePointer(ref: ref, name: leaseName)\n    }\n\n    execute {\n        self.market.acceptOffer(self.pointer)\n    }\n}",
               "spec": {
                  "order": [
                     "leaseName"
                  ],
                  "parameters": {
                     "leaseName": "String"
                  }
               }
            },
            "acceptLeaseDirectOfferSoftDUC": {
               "code": "import FindLeaseMarketDirectOfferSoft from 0x097bafa4e0b48eef\nimport NonFungibleToken from 0x1d7e57aa55817448\nimport MetadataViews from 0x1d7e57aa55817448\nimport FindViews from 0x097bafa4e0b48eef\nimport FindMarket from 0x097bafa4e0b48eef\nimport FindLeaseMarket from 0x097bafa4e0b48eef\nimport FungibleToken from 0xf233dcee88fe0abe\nimport TokenForwarding from 0xe544175ee0461c4b\nimport DapperUtilityCoin from 0xead892083b3e2c6c\nimport Profile from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\n\ntransaction(dapperAddress: Address, leaseName: String) {\n\n    let market : \u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection\n    let pointer : FindLeaseMarket.AuthLeasePointer\n\n    prepare(account: AuthAccount) {\n\n        let ducReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver)\n        if !ducReceiver.check() {\n            let dapper = getAccount(dapperAddress)\n            // Create a new Forwarder resource for DUC and store it in the new account's storage\n            let ducForwarder \u003c- TokenForwarding.createNewForwarder(recipient: dapper.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver))\n            account.save(\u003c-ducForwarder, to: /storage/dapperUtilityCoinReceiver)\n            // Publish a Receiver capability for the new account, which is linked to the DUC Forwarder\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver,target: /storage/dapperUtilityCoinReceiver)\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n        if !profile.hasWallet(\"DUC\") {\n            profile.addWallet(Profile.Wallet( name:\"DUC\", receiver:ducReceiver, balance:getAccount(dapperAddress).getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/dapperUtilityCoinBalance), accept: Type\u003c@DapperUtilityCoin.Vault\u003e(), tags: [\"duc\", \"dapperUtilityCoin\",\"dapper\"]))\n            profile.emitUpdatedEvent()\n        }\n\n        let marketplace = FindMarket.getTenantAddress(\"findLease\")!\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e())\n        self.market = account.borrow\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(from: storagePath)!\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e())\n        let item = FindLeaseMarket.assertOperationValid(tenant: marketplace, name: leaseName, marketOption: marketOption)\n\n        let ref = account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from: FIND.LeaseStoragePath) ?? panic(\"Cannot borrow reference to Find lease collection. Account : \".concat(account.address.toString()))\n        self.pointer= FindLeaseMarket.AuthLeasePointer(ref: ref, name: leaseName)\n\n    }\n\n    execute {\n        self.market.acceptOffer(self.pointer)\n    }\n    \n}",
               "spec": {
                  "order": [
                     "dapperAddress",
                     "leaseName"
                  ],
                  "parameters": {
                     "dapperAddress": "Address",
                     "leaseName": "String"
                  }
               }
            },
            "acceptMultipleDirectOfferSoft": {
               "code": "import FindMarketDirectOfferSoft from 0x097bafa4e0b48eef\nimport NonFungibleToken from 0x1d7e57aa55817448\nimport MetadataViews from 0x1d7e57aa55817448\nimport FindViews from 0x097bafa4e0b48eef\nimport NFTCatalog from 0x49a7cda3a1eecc29\nimport FINDNFTCatalog from 0x097bafa4e0b48eef\nimport FindMarket from 0x097bafa4e0b48eef\n\ntransaction(marketplace:Address, ids: [UInt64]) {\n\n    let market : \u0026FindMarketDirectOfferSoft.SaleItemCollection\n    let pointer : [FindViews.AuthNFTPointer]\n\n    prepare(account: AuthAccount) {\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e())\n        self.market = account.borrow\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection\u003e(from: storagePath)!\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e())\n\n        var counter = 0\n        self.pointer = []\n        let nfts : {String : NFTCatalog.NFTCollectionData} = {}\n\n        while counter \u003c ids.length {\n            let item = FindMarket.assertOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: ids[counter])\n            var nft : NFTCatalog.NFTCollectionData? = nil\n            let nftIdentifier = item.getItemType().identifier\n\n            if nfts[nftIdentifier] != nil {\n                nft = nfts[nftIdentifier]\n            } else {\n                // nft = getCollectionData(nftIdentifier) \n                let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier)) \n                let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n                nft = collection.collectionData\n                nfts[nftIdentifier] = nft\n            }\n\n            let providerCap=account.getCapability\u003c\u0026{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e(nft!.privatePath)\n            let pointer= FindViews.AuthNFTPointer(cap: providerCap, id: item.getItemID())\n            self.pointer.append(pointer)\n            counter = counter + 1\n        }\n    }\n\n    execute {\n        var counter = 0\n        while counter \u003c ids.length {\n            self.market.acceptOffer(self.pointer[counter])\n            counter = counter + 1\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "ids"
                  ],
                  "parameters": {
                     "ids": "[UInt64]",
                     "marketplace": "Address"
                  }
               }
            },
            "acceptMultipleDirectOfferSoftDUC": {
               "code": "import FindMarketDirectOfferSoft from 0x097bafa4e0b48eef\nimport NonFungibleToken from 0x1d7e57aa55817448\nimport MetadataViews from 0x1d7e57aa55817448\nimport FindViews from 0x097bafa4e0b48eef\nimport NFTCatalog from 0x49a7cda3a1eecc29\nimport FINDNFTCatalog from 0x097bafa4e0b48eef\nimport FindMarket from 0x097bafa4e0b48eef\nimport FungibleToken from 0xf233dcee88fe0abe\nimport TokenForwarding from 0xe544175ee0461c4b\nimport DapperUtilityCoin from 0xead892083b3e2c6c\nimport Profile from 0x097bafa4e0b48eef\n\ntransaction(dapperAddress: Address, marketplace:Address, ids: [UInt64]) {\n\n    let market : \u0026FindMarketDirectOfferSoft.SaleItemCollection\n    let pointer : [FindViews.AuthNFTPointer]\n\n    prepare(account: AuthAccount) {\n\n        let ducReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver)\n        if !ducReceiver.check() {\n            let dapper = getAccount(dapperAddress)\n            // Create a new Forwarder resource for DUC and store it in the new account's storage\n            let ducForwarder \u003c- TokenForwarding.createNewForwarder(recipient: dapper.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver))\n            account.save(\u003c-ducForwarder, to: /storage/dapperUtilityCoinReceiver)\n            // Publish a Receiver capability for the new account, which is linked to the DUC Forwarder\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver,target: /storage/dapperUtilityCoinReceiver)\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n        if !profile.hasWallet(\"DUC\") {\n            profile.addWallet(Profile.Wallet( name:\"DUC\", receiver:ducReceiver, balance:getAccount(dapperAddress).getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/dapperUtilityCoinBalance), accept: Type\u003c@DapperUtilityCoin.Vault\u003e(), tags: [\"duc\", \"dapperUtilityCoin\",\"dapper\"]))\n            profile.emitUpdatedEvent()\n        }\n\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e())\n        self.market = account.borrow\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection\u003e(from: storagePath)!\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e())\n\n        var counter = 0\n        self.pointer = []\n        let nfts : {String : NFTCatalog.NFTCollectionData} = {}\n\n        while counter \u003c ids.length {\n            let item = FindMarket.assertOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: ids[counter])\n            var nft : NFTCatalog.NFTCollectionData? = nil\n            let nftIdentifier = item.getItemType().identifier\n            let ftType = item.getFtType()\n\n            if nfts[nftIdentifier] != nil {\n                nft = nfts[nftIdentifier]\n            } else {\n                // nft = getCollectionData(nftIdentifier) \n                let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier)) \n                let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n                nft = collection.collectionData\n                nfts[nftIdentifier] = nft\n            }\n\n            let providerCap=account.getCapability\u003c\u0026{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e(nft!.privatePath)\n            let pointer= FindViews.AuthNFTPointer(cap: providerCap, id: item.getItemID())\n            self.pointer.append(pointer)\n            counter = counter + 1\n        }\n\n    }\n\n    execute {\n        var counter = 0\n        while counter \u003c ids.length {\n            self.market.acceptOffer(self.pointer[counter])\n            counter = counter + 1\n        }\n    }\n    \n}",
               "spec": {
                  "order": [
                     "dapperAddress",
                     "marketplace",
                     "ids"
                  ],
                  "parameters": {
                     "dapperAddress": "Address",
                     "ids": "[UInt64]",
                     "marketplace": "Address"
                  }
               }
            },
            "addCuratedCollection": {
               "code": "transaction(name: String, items: [String]) {\n    prepare(account: AuthAccount) {\n\n        let path=/storage/FindCuratedCollections\n        let publicPath=/public/FindCuratedCollections\n\n        var collections : {String: [String]} = {}\n        if account.borrow\u003c\u0026{String: [String]}\u003e(from:path) != nil {\n             collections=account.load\u003c{String: [String]}\u003e(from:path)!\n        }\n        collections[name] = items\n        account.save(collections, to: path)\n        let link = account.getCapability\u003c\u0026{String: [String]}\u003e(publicPath)\n        if !link.check() {\n            account.link\u003c\u0026{String: [String]}\u003e( publicPath, target: path)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "items"
                  ],
                  "parameters": {
                     "items": "[String]",
                     "name": "String"
                  }
               }
            },
            "adminAddForge": {
               "code": "import Admin from 0x097bafa4e0b48eef\n\ntransaction(name: String, type: String) {\n\n    prepare(admin:AuthAccount) {\n\n        let client= admin.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath)!\n\n        client.addPrivateForgeType(name: name, forgeType: CompositeType(type)!)\n\n    }\n\n}",
               "spec": {
                  "order": [
                     "name",
                     "type"
                  ],
                  "parameters": {
                     "name": "String",
                     "type": "String"
                  }
               }
            },
            "adminAddNFTCatalog": {
               "code": "import MetadataViews from 0x1d7e57aa55817448\nimport FINDNFTCatalog from 0x097bafa4e0b48eef\nimport NFTCatalog from 0x49a7cda3a1eecc29\nimport FINDNFTCatalogAdmin from 0x097bafa4e0b48eef\n\ntransaction(\n    collectionIdentifier : String,\n    contractName: String,\n    contractAddress: Address,\n    addressWithNFT: Address,\n    nftID: UInt64,\n    publicPathIdentifier: String\n) {\n    \n    let adminResource: \u0026FINDNFTCatalogAdmin.Admin\n    \n    prepare(acct: AuthAccount) {\n        self.adminResource = acct.borrow\u003c\u0026FINDNFTCatalogAdmin.Admin\u003e(from: FINDNFTCatalogAdmin.AdminStoragePath)!\n    }\n    \n    execute {\n        let nftAccount = getAccount(addressWithNFT)\n        let pubPath = PublicPath(identifier: publicPathIdentifier)!\n        let collectionCap = nftAccount.getCapability\u003c\u0026AnyResource{MetadataViews.ResolverCollection}\u003e(pubPath)\n        assert(collectionCap.check(), message: \"MetadataViews Collection is not set up properly, ensure the Capability was created/linked correctly.\")\n        let collectionRef = collectionCap.borrow()!\n        assert(collectionRef.getIDs().length \u003e 0, message: \"No NFTs exist in this collection.\")\n        let nftResolver = collectionRef.borrowViewResolver(id: nftID)\n        \n        let metadataCollectionData = MetadataViews.getNFTCollectionData(nftResolver)!\n        \n        let collectionData = NFTCatalog.NFTCollectionData(\n            storagePath: metadataCollectionData.storagePath,\n            publicPath: metadataCollectionData.publicPath,\n            privatePath: metadataCollectionData.providerPath,\n            publicLinkedType : metadataCollectionData.publicLinkedType,\n            privateLinkedType : metadataCollectionData.providerLinkedType\n        )\n\n        let collectionDisplay = MetadataViews.getNFTCollectionDisplay(nftResolver)!\n\n        let catalogData = NFTCatalog.NFTCatalogMetadata(\n            contractName: contractName,\n            contractAddress: contractAddress,\n            nftType: nftResolver.getType(),\n            collectionData: collectionData,\n            collectionDisplay : collectionDisplay\n        )\n\n        self.adminResource.addCatalogEntry(collectionIdentifier : collectionIdentifier, metadata : catalogData)\n    }\n}",
               "spec": {
                  "order": [
                     "collectionIdentifier",
                     "contractName",
                     "contractAddress",
                     "addressWithNFT",
                     "nftID",
                     "publicPathIdentifier"
                  ],
                  "parameters": {
                     "addressWithNFT": "Address",
                     "collectionIdentifier": "String",
                     "contractAddress": "Address",
                     "contractName": "String",
                     "nftID": "UInt64",
                     "publicPathIdentifier": "String"
                  }
               }
            },
            "adminAddNFTCatalogDirect": {
               "code": "import MetadataViews from 0x1d7e57aa55817448\nimport FINDNFTCatalog from 0x097bafa4e0b48eef\nimport NFTCatalog from 0x49a7cda3a1eecc29\nimport FINDNFTCatalogAdmin from 0x097bafa4e0b48eef\n\ntransaction(\n    collectionIdentifier : String,\n    contractName: String,\n    contractAddress: Address,\n    nftTypeIdentifer: String,\n    storagePathIdentifier: String,\n    publicPathIdentifier: String,\n    privatePathIdentifier: String,\n    publicLinkedTypeIdentifier : String,\n    publicLinkedTypeRestrictions : [String],\n    privateLinkedTypeIdentifier : String,\n    privateLinkedTypeRestrictions : [String],\n    collectionName : String,\n    collectionDescription: String,\n    externalURL : String,\n    squareImageMediaURL : String,\n    squareImageMediaType : String,\n    bannerImageMediaURL : String,\n    bannerImageMediaType : String,\n    socials: {String : String},\n) {\n    \n    let adminResource: \u0026FINDNFTCatalogAdmin.Admin\n    \n    prepare(acct: AuthAccount) {\n        self.adminResource = acct.borrow\u003c\u0026FINDNFTCatalogAdmin.Admin\u003e(from: FINDNFTCatalogAdmin.AdminStoragePath)!\n    }\n    \n    execute {\n        let collectionData = NFTCatalog.NFTCollectionData(\n            storagePath: StoragePath(identifier: storagePathIdentifier)!,\n            publicPath: PublicPath(identifier : publicPathIdentifier)!,\n            privatePath: PrivatePath(identifier: privatePathIdentifier)!,\n            publicLinkedType : RestrictedType(identifier : publicLinkedTypeIdentifier, restrictions: publicLinkedTypeRestrictions)!,\n            privateLinkedType : RestrictedType(identifier : privateLinkedTypeIdentifier, restrictions: privateLinkedTypeRestrictions)!\n        )\n\n        let squareMedia = MetadataViews.Media(\n                        file: MetadataViews.HTTPFile(\n                            url: squareImageMediaURL\n                        ),\n                        mediaType: squareImageMediaURL\n                    )\n        \n        let bannerMedia = MetadataViews.Media(\n                        file: MetadataViews.HTTPFile(\n                            url: bannerImageMediaURL\n                        ),\n                        mediaType: bannerImageMediaURL\n                    )\n\n        let socialsStruct : {String : MetadataViews.ExternalURL} = {}\n        for key in socials.keys {\n            socialsStruct[key] =  MetadataViews.ExternalURL(socials[key]!)\n        }\n        \n        let collectionDisplay = MetadataViews.NFTCollectionDisplay(\n            name: collectionName,\n            description: collectionDescription,\n            externalURL: MetadataViews.ExternalURL(externalURL),\n            squareImage: squareMedia,\n            bannerImage: bannerMedia,\n            socials: socialsStruct\n        )\n\n        let catalogData = NFTCatalog.NFTCatalogMetadata(\n            contractName: contractName,\n            contractAddress: contractAddress,\n            nftType: CompositeType(nftTypeIdentifer)!,\n            collectionData: collectionData,\n            collectionDisplay : collectionDisplay\n        )\n\n        self.adminResource.addCatalogEntry(collectionIdentifier : collectionIdentifier, metadata : catalogData)\n    }\n}",
               "spec": {
                  "order": [
                     "collectionIdentifier",
                     "contractName",
                     "contractAddress",
                     "nftTypeIdentifer",
                     "storagePathIdentifier",
                     "publicPathIdentifier",
                     "privatePathIdentifier",
                     "publicLinkedTypeIdentifier",
                     "publicLinkedTypeRestrictions",
                     "privateLinkedTypeIdentifier",
                     "privateLinkedTypeRestrictions",
                     "collectionName",
                     "collectionDescription",
                     "externalURL",
                     "squareImageMediaURL",
                     "squareImageMediaType",
                     "bannerImageMediaURL",
                     "bannerImageMediaType",
                     "socials"
                  ],
                  "parameters": {
                     "bannerImageMediaType": "String",
                     "bannerImageMediaURL": "String",
                     "collectionDescription": "String",
                     "collectionIdentifier": "String",
                     "collectionName": "String",
                     "contractAddress": "Address",
                     "contractName": "String",
                     "externalURL": "String",
                     "nftTypeIdentifer": "String",
                     "privateLinkedTypeIdentifier": "String",
                     "privateLinkedTypeRestrictions": "[String]",
                     "privatePathIdentifier": "String",
                     "publicLinkedTypeIdentifier": "String",
                     "publicLinkedTypeRestrictions": "[String]",
                     "publicPathIdentifier": "String",
                     "socials": "{String: String}",
                     "squareImageMediaType": "String",
                     "squareImageMediaURL": "String",
                     "storagePathIdentifier": "String"
                  }
               }
            },
            "adminInitDUC": {
               "code": "import FungibleToken from 0xf233dcee88fe0abe\nimport DapperUtilityCoin from 0xead892083b3e2c6c\nimport TokenForwarding from 0xe544175ee0461c4b\n\n\ntransaction(dapperAddress:Address) {\n\n    prepare(acct: AuthAccount) {\n        // Get a Receiver reference for the Dapper account that will be the recipient of the forwarded DUC\n        let dapper = getAccount(dapperAddress)\n      let dapperDUCReceiver = dapper.getCapability(/public/dapperUtilityCoinReceiver)\n\n      // Create a new Forwarder resource for DUC and store it in the new account's storage\n      let ducForwarder \u003c- TokenForwarding.createNewForwarder(recipient: dapperDUCReceiver)\n      acct.save(\u003c-ducForwarder, to: /storage/dapperUtilityCoinReceiver)\n\n      // Publish a Receiver capability for the new account, which is linked to the DUC Forwarder\n      acct.link\u003c\u0026{FungibleToken.Receiver}\u003e(\n      /public/dapperUtilityCoinReceiver,\n      target: /storage/dapperUtilityCoinReceiver\n      )\n    }\n}",
               "spec": {
                  "order": [
                     "dapperAddress"
                  ],
                  "parameters": {
                     "dapperAddress": "Address"
                  }
               }
            },
            "adminMainnetAddItem": {
               "code": "import Admin from 0x097bafa4e0b48eef\nimport FindMarket from 0x097bafa4e0b48eef\nimport FlowToken from 0x1654653399040a61\n\ntransaction(tenant: Address, ftName: String, ftTypes: [String] , nftName: String, nftTypes: [String], listingName: String, listingTypes: [String]) {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n        \n    }\n    execute{\n\n        let ft : [Type] = []\n        for type in ftTypes {\n            ft.append(CompositeType(type)!)\n        }\n\n        let nft : [Type] = []\n        for type in nftTypes {\n            nft.append(CompositeType(type)!)\n        }\n\n        let listing : [Type] = []\n        for type in listingTypes {\n            listing.append(CompositeType(type)!)\n        }\n\n        let rules : [FindMarket.TenantRule] = []\n        if listing.length \u003e 0 {\n            rules.append(FindMarket.TenantRule(name:listingName, types:listing, ruleType: \"listing\", allow: true))\n        }\n\n        if ft.length \u003e 0 {\n            rules.append(FindMarket.TenantRule(name:ftName, types:ft, ruleType: \"ft\", allow: true))\n        }\n\n        if nft.length \u003e 0 {\n            rules.append(FindMarket.TenantRule(name:nftName, types:nft, ruleType: \"nft\", allow: true))\n        }\n        \n\n        let tenantSaleItem = FindMarket.TenantSaleItem(\n            name: listingName.concat(ftName).concat(nftName), \n            cut: nil, \n            rules: rules, \n            status:\"active\"\n        )\n\n        self.adminRef.setMarketOption(tenant: tenant, saleItem: tenantSaleItem)\n        \n    }\n}",
               "spec": {
                  "order": [
                     "tenant",
                     "ftName",
                     "ftTypes",
                     "nftName",
                     "nftTypes",
                     "listingName",
                     "listingTypes"
                  ],
                  "parameters": {
                     "ftName": "String",
                     "ftTypes": "[String]",
                     "listingName": "String",
                     "listingTypes": "[String]",
                     "nftName": "String",
                     "nftTypes": "[String]",
                     "tenant": "Address"
                  }
               }
            },
            "adminMintCharity": {
               "code": "import NonFungibleToken from 0x1d7e57aa55817448\nimport CharityNFT from 0x097bafa4e0b48eef\nimport Admin from 0x097bafa4e0b48eef\n\n//mint an art and add it to a users collection\ntransaction(\n    name: String,\n    image: String,\n    thumbnail: String,\n    originUrl: String,\n    description: String,\n    recipient: Address\n) {\n    let receiverCap: Capability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e\n    let client: \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount) {\n        self.client= account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath)!\n        self.receiverCap= getAccount(recipient).getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath)\n    }\n\n    execute {\n        let metadata = {\"name\" : name, \"image\" : image, \"thumbnail\": thumbnail, \"originUrl\": originUrl, \"description\":description}\n        self.client.mintCharity(metadata: metadata, recipient: self.receiverCap)\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "image",
                     "thumbnail",
                     "originUrl",
                     "description",
                     "recipient"
                  ],
                  "parameters": {
                     "description": "String",
                     "image": "String",
                     "name": "String",
                     "originUrl": "String",
                     "recipient": "Address",
                     "thumbnail": "String"
                  }
               }
            },
            "adminMintFindDandy": {
               "code": "import FIND from 0x097bafa4e0b48eef\nimport NonFungibleToken from 0x1d7e57aa55817448\nimport Dandy from 0x097bafa4e0b48eef\nimport MetadataViews from 0x1d7e57aa55817448\nimport FindForge from 0x097bafa4e0b48eef\n\ntransaction(name: String, maxEdition:UInt64, nftName:String, nftDescription:String, folderHash:String) {\n    prepare(account: AuthAccount) {\n\n        let finLeases= account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n        let lease=finLeases.borrow(name)\n        let forgeType = Dandy.getForgeType()\n\n        let dandyCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        let thumbNail=MetadataViews.IPFSFile(cid:folderHash, path: \"thumbnail.webp\")\n        let fullsize=MetadataViews.IPFSFile(cid:folderHash, path: \"fullsize.webp\")\n        let mediaFullsize=MetadataViews.Media(file: fullsize, mediaType: \"image/webp\")\n        let mediaThumbnail=MetadataViews.Media(file: thumbNail, mediaType: \"image/webp\")\n\n        let nftReceiver=account.getCapability\u003c\u0026{NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(Dandy.CollectionPublicPath).borrow() ?? panic(\"Cannot borrow reference to Dandy collection.\")\n\n        let traits = MetadataViews.Traits([])\n        traits.addTrait(MetadataViews.Trait(name: \"Creator\", value: \".find\", displayType:\"Author\", rarity:nil))\n\n        let collection=dandyCap.borrow()!\n        var i:UInt64=1\n\n        while i \u003c= maxEdition {\n\n            let editioned= MetadataViews.Edition(name: nil, number:i, max:maxEdition)\n            let set= MetadataViews.Edition(name: \"set\", number:i, max:maxEdition)\n            let editions = MetadataViews.Editions([editioned, set])\n\n            let schemas: [AnyStruct] = [ editions, MetadataViews.Medias([mediaFullsize, mediaThumbnail]), traits ]\n            \n            let mintData = Dandy.DandyInfo(name: nftName, \n                                                description: nftDescription, \n                                                thumbnail: mediaThumbnail, \n                                                schemas: schemas, \n                                                externalUrlPrefix:\"https://find.xyz/\".concat(name).concat(\"/collection/Dandy\"))\n            \n            FindForge.mint(lease: lease, forgeType: forgeType, data: mintData, receiver: nftReceiver)\n        \n            i=i+1\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "maxEdition",
                     "nftName",
                     "nftDescription",
                     "folderHash"
                  ],
                  "parameters": {
                     "folderHash": "String",
                     "maxEdition": "UInt64",
                     "name": "String",
                     "nftDescription": "String",
                     "nftName": "String"
                  }
               }
            },
            "adminRecreateDandy": {
               "code": "import NonFungibleToken from 0x1d7e57aa55817448\nimport Dandy from 0x097bafa4e0b48eef\nimport MetadataViews from 0x1d7e57aa55817448\n\ntransaction {\n    prepare(account: AuthAccount) {\n        account.unlink(Dandy.CollectionPrivatePath)\n        account.unlink(Dandy.CollectionPublicPath)\n        destroy \u003c- account.load\u003c@NonFungibleToken.Collection\u003e(from:Dandy.CollectionStoragePath)\n\n        let dandyCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n    }\n}",
               "spec": {
                  "order": [],
                  "parameters": {}
               }
            },
            "adminRegisterName": {
               "code": "import FIND from 0x097bafa4e0b48eef\nimport Admin from 0x097bafa4e0b48eef\nimport Profile from 0x097bafa4e0b48eef\n\ntransaction(names: [String], user: Address) {\n\n    prepare(account: AuthAccount) {\n\n        let userAccount=getAccount(user)\n        let profileCap = userAccount.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        let leaseCollectionCap=userAccount.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        let adminClient=account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath)!\n\n        for name in names {\n            adminClient.register(name: name,  profile: profileCap, leases: leaseCollectionCap)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "names",
                     "user"
                  ],
                  "parameters": {
                     "names": "[String]",
                     "user": "Address"
                  }
               }
            },
            "adminRemoveFTInfoByAlias": {
               "code": "import Admin from 0x097bafa4e0b48eef\n\ntransaction(alias: String) {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n        \n    }\n\n    execute{\n\n        self.adminRef.removeFTInfoByAlias(alias)\n\n    }\n}",
               "spec": {
                  "order": [
                     "alias"
                  ],
                  "parameters": {
                     "alias": "String"
                  }
               }
            },
            "adminRemoveFTInfoByTypeIdentifier": {
               "code": "import Admin from 0x097bafa4e0b48eef\n\ntransaction(typeIdentifier: String) {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n        \n    }\n\n    execute{\n\n        self.adminRef.removeFTInfoByTypeIdentifier(typeIdentifier) \n       \n    }\n}",
               "spec": {
                  "order": [
                     "typeIdentifier"
                  ],
                  "parameters": {
                     "typeIdentifier": "String"
                  }
               }
            },
            "adminRemoveForge": {
               "code": "import Admin from 0x097bafa4e0b48eef\n\ntransaction(type: String) {\n\n    prepare(admin:AuthAccount) {\n\n        let client= admin.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath)!\n\n        client.removeForgeType(CompositeType(type)!)\n\n    }\n\n}",
               "spec": {
                  "order": [
                     "type"
                  ],
                  "parameters": {
                     "type": "String"
                  }
               }
            },
            "adminRemoveNFTCatalog": {
               "code": "import MetadataViews from 0x1d7e57aa55817448\nimport FINDNFTCatalog from 0x097bafa4e0b48eef\nimport FINDNFTCatalogAdmin from 0x097bafa4e0b48eef\n\ntransaction(\n    collectionIdentifier : String\n) {\n    let adminProxyResource : \u0026FINDNFTCatalogAdmin.Admin\n\n    prepare(acct: AuthAccount) { \n        self.adminProxyResource = acct.borrow\u003c\u0026FINDNFTCatalogAdmin.Admin\u003e(from : FINDNFTCatalogAdmin.AdminStoragePath)!\n    }\n\n    execute {     \n        self.adminProxyResource.removeCatalogEntry(collectionIdentifier : collectionIdentifier)\n    }\n}",
               "spec": {
                  "order": [
                     "collectionIdentifier"
                  ],
                  "parameters": {
                     "collectionIdentifier": "String"
                  }
               }
            },
            "adminRemoveNFTInfoByAlias": {
               "code": "import Admin from 0x097bafa4e0b48eef\n\ntransaction(alias: String) {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n        \n    }\n\n    execute{\n\n        self.adminRef.removeNFTInfoByAlias(alias)\n        \n    }\n}",
               "spec": {
                  "order": [
                     "alias"
                  ],
                  "parameters": {
                     "alias": "String"
                  }
               }
            },
            "adminRemoveNFTInfoByTypeIdentifier": {
               "code": "import Admin from 0x097bafa4e0b48eef\n\ntransaction(typeIdentifier: String) {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n        \n    }\n\n    execute{\n\n        self.adminRef.removeNFTInfoByTypeIdentifier(typeIdentifier) \n       \n    }\n}",
               "spec": {
                  "order": [
                     "typeIdentifier"
                  ],
                  "parameters": {
                     "typeIdentifier": "String"
                  }
               }
            },
            "adminRemoveProfileBan": {
               "code": "import Profile from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\n\ntransaction(user: String) {\n    prepare(acct: AuthAccount) {\n        let profile =acct.borrow\u003c\u0026Profile.User\u003e(from:Profile.storagePath)!\n        let address =FIND.resolve(user) ?? panic(\"Not a registered name or valid address.\")\n        profile.removeBan(address)\n    }\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "adminSendFUSD": {
               "code": "import FungibleToken from 0xf233dcee88fe0abe\nimport FUSD from 0x3c5959b568896393\n\ntransaction(receiver: Address, amount:UFix64) {\n    prepare(acct: AuthAccount) {\n        let receiver = getAccount(receiver).getCapability\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e(/public/fusdReceiver).borrow() ?? panic(\"Cannot borrow FUSD receiver\")\n\n        let sender = acct.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault)\n            ?? panic(\"Cannot borrow FUSD vault from authAcct storage\")\n\n        receiver.deposit(from: \u003c- sender.withdraw(amount:amount))\n    }\n}",
               "spec": {
                  "order": [
                     "receiver",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "receiver": "Address"
                  }
               }
            },
            "adminSetAddonPrice": {
               "code": "import Admin from 0x097bafa4e0b48eef\n\ntransaction(addon:String, price:UFix64) {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n        \n    }\n    execute{\n        self.adminRef.setAddonPrice(name: addon, price: price)\n    }\n}",
               "spec": {
                  "order": [
                     "addon",
                     "price"
                  ],
                  "parameters": {
                     "addon": "String",
                     "price": "UFix64"
                  }
               }
            },
            "adminSetFTInfo_duc": {
               "code": "import Admin from 0x097bafa4e0b48eef\nimport DapperUtilityCoin from 0xead892083b3e2c6c\n\ntransaction() {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n    }\n\n    execute{\n        let type: Type = Type\u003c@DapperUtilityCoin.Vault\u003e()\n        self.adminRef.setFTInfo(alias: \"DUC\", type: type, tag:[\"dapper utility coin\"] , icon: \"https://assets.website-files.com/5bf4437b68f8b29e67b7ebdc/61a159f8899a41507bc46bcb_feature%20image%20dapper%20post.png\", receiverPath: /public/dapperUtilityCoinReceiver, balancePath: /public/dapperUtilityCoinBalance, vaultPath: /storage/dapperUtilityCoinVault)\n    }\n}",
               "spec": {
                  "order": [],
                  "parameters": {}
               }
            },
            "adminSetFTInfo_flow": {
               "code": "import Admin from 0x097bafa4e0b48eef\nimport FlowToken from 0x1654653399040a61\n\ntransaction() {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n    }\n\n    execute{\n        let type: Type = Type\u003c@FlowToken.Vault\u003e()\n        self.adminRef.setFTInfo(alias: \"Flow\", type: type, tag:[\"utility coin\"] , icon: \"https://static.flowscan.org/mainnet/icons/A.1654653399040a61.FlowToken.png\", receiverPath: /public/flowTokenReceiver, balancePath: /public/flowTokenBalance, vaultPath: /storage/flowTokenVault)\n    }\n}",
               "spec": {
                  "order": [],
                  "parameters": {}
               }
            },
            "adminSetFTInfo_fusd": {
               "code": "import Admin from 0x097bafa4e0b48eef\nimport FUSD from 0x3c5959b568896393\n\ntransaction() {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n    }\n\n    execute{\n        let type: Type = Type\u003c@FUSD.Vault\u003e()\n        self.adminRef.setFTInfo(alias: \"FUSD\", type: type, tag:[\"stablecoin\"], icon: \"https://static.flowscan.org/mainnet/icons/A.3c5959b568896393.FUSD.png\", receiverPath: /public/fusdReceiver, balancePath: /public/fusdBalance, vaultPath: /storage/fusdVault)\n    }\n}",
               "spec": {
                  "order": [],
                  "parameters": {}
               }
            },
            "adminSetFTInfo_usdc": {
               "code": "import Admin from 0x097bafa4e0b48eef\nimport FiatToken from 0xb19436aae4d94622\n\ntransaction() {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n    }\n\n    execute{\n        let type: Type = Type\u003c@FiatToken.Vault\u003e()\n        self.adminRef.setFTInfo(alias: \"USDC\", type: type, tag:[\"stablecoin\"] , icon: \"https://static.flowscan.org/mainnet/icons/A.b19436aae4d94622.FiatToken.png\", receiverPath: FiatToken.VaultReceiverPubPath, balancePath: FiatToken.VaultBalancePubPath, vaultPath: FiatToken.VaultStoragePath)\n    }\n}",
               "spec": {
                  "order": [],
                  "parameters": {}
               }
            },
            "adminSetFindCut": {
               "code": "import Admin from 0x097bafa4e0b48eef\n\ntransaction(tenant: Address, cut: UFix64){\n    prepare(account: AuthAccount){\n        let adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n\n        adminRef.setFindCut(tenant: tenant, saleItemName:\"findRoyalty\", cut: cut, rules: nil, status: \"active\")\n    }\n}",
               "spec": {
                  "order": [
                     "tenant",
                     "cut"
                  ],
                  "parameters": {
                     "cut": "UFix64",
                     "tenant": "Address"
                  }
               }
            },
            "adminSetNFTInfo_Dandy": {
               "code": "import Admin from 0x097bafa4e0b48eef\nimport Dandy from 0x097bafa4e0b48eef\n\ntransaction() {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n        \n    }\n    execute{\n        let type: Type = Type\u003c@Dandy.NFT\u003e()\n        self.adminRef.setNFTInfo(alias: \"Dandy\", type: type, icon: nil, providerPath: Dandy.CollectionPrivatePath, publicPath: Dandy.CollectionPublicPath, storagePath: Dandy.CollectionStoragePath, allowedFTTypes: nil, address: 0xf8d6e0586b0a20c7, externalFixedUrl: \"find.xyz\")\n\n    }\n}",
               "spec": {
                  "order": [],
                  "parameters": {}
               }
            },
            "adminSetNFTInfo_FLOAT": {
               "code": "import Admin from 0x097bafa4e0b48eef\n\ntransaction() {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n\n    }\n    execute{\n        if let type = CompositeType(\"A.0afe396ebc8eee65.FLOAT.NFT\") { // Testnet Address \n            self.adminRef.setNFTInfo(alias: \"FLOAT\", type: type, icon: \"https://testnet.floats.city/floatlogowebpage.png\", providerPath: /private/FLOATCollectionPublicPath, publicPath: /public/FLOATCollectionPublicPath, storagePath: /storage/FLOATCollectionStoragePath, allowedFTTypes: nil, address: 0x0afe396ebc8eee65, externalFixedUrl: \"testnet.floats.city\")\n            \n        } else if let type = CompositeType(\"A.2d4c3caffbeab845.FLOAT.NFT\") {\n            self.adminRef.setNFTInfo(alias: \"FLOAT\", type: type, icon: \"https://floats.city/floatlogowebpage.png\", providerPath: /private/FLOATCollectionPublicPath, publicPath: /public/FLOATCollectionPublicPath, storagePath: /storage/FLOATCollectionStoragePath, allowedFTTypes: nil, address: 0x2d4c3caffbeab845, externalFixedUrl: \"floats.city\")\n        }\n\n    }\n}",
               "spec": {
                  "order": [],
                  "parameters": {}
               }
            },
            "adminSetNFTInfo_Neo": {
               "code": "import Admin from 0x097bafa4e0b48eef\nimport NeoVoucher from 0xd6b39e5b5b367aad\n\ntransaction() {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n        \n    }\n    execute{\n\n        self.adminRef.setNFTInfo(alias: \"NeoVoucher\", type: Type\u003c@NeoVoucher.NFT\u003e(), icon: \"https://test.neocollectibles.xyz/pages/images/neo-collectibles-logo.webp\", providerPath: /private/neoVoucherCollection, publicPath: NeoVoucher.CollectionPublicPath, storagePath: NeoVoucher.CollectionStoragePath, allowedFTTypes: nil, address: 0xd6b39e5b5b367aad, externalFixedUrl: \"test.neocollectibles.xyx\")\n\n    }\n}",
               "spec": {
                  "order": [],
                  "parameters": {}
               }
            },
            "adminSetProfileBan": {
               "code": "import Profile from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\n\ntransaction(user: String) {\n    prepare(acct: AuthAccount) {\n        let profile =acct.borrow\u003c\u0026Profile.User\u003e(from:Profile.storagePath)!\n        let address =FIND.resolve(user) ?? panic(\"Not a registered name or valid address.\")\n        profile.addBan(address)\n    }\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "adminSetSellDUCLeaseRules": {
               "code": "import FindMarket from 0x097bafa4e0b48eef\nimport Admin from 0x097bafa4e0b48eef\nimport DapperUtilityCoin from 0xead892083b3e2c6c\nimport MetadataViews from 0x1d7e57aa55817448\nimport FungibleToken from 0xf233dcee88fe0abe\nimport FIND from 0x097bafa4e0b48eef\n\ntransaction(tenant: Address) {\n    prepare(account: AuthAccount){\n        let adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n\n        let rules = [\n            FindMarket.TenantRule(name:\"DUC\", types:[Type\u003c@DapperUtilityCoin.Vault\u003e()], ruleType: \"ft\", allow: true),\n            FindMarket.TenantRule(name:\"Lease\", types:[ Type\u003c@FIND.Lease\u003e()], ruleType: \"nft\", allow: true)\n            ]\n\n        let ducExample = FindMarket.TenantSaleItem(name:\"DUCLease\", cut: nil, rules:rules, status: \"active\" )\n\n        adminRef.setMarketOption(tenant: tenant, saleItem: ducExample)\n\n        let cap = getAccount(account.address).getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver)\n        adminRef.addFindCut(tenant: tenant, FindCutName: \"findDapperRoyalty\", rayalty: MetadataViews.Royalty(receiver: cap, cut: 0.02, description: \"find\"), rules: rules, status: \"active\")\n\n    }\n}",
               "spec": {
                  "order": [
                     "tenant"
                  ],
                  "parameters": {
                     "tenant": "Address"
                  }
               }
            },
            "adminSetSellDandyForFUSD": {
               "code": "import FindMarket from 0x097bafa4e0b48eef\nimport Admin from 0x097bafa4e0b48eef\nimport FUSD from 0x3c5959b568896393\nimport Dandy from 0x097bafa4e0b48eef\nimport FindMarketSale from 0x097bafa4e0b48eef\nimport FindMarketAuctionEscrow from 0x097bafa4e0b48eef\nimport FindMarketAuctionSoft from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferEscrow from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferSoft from 0x097bafa4e0b48eef\n\n\ntransaction(tenant: Address, market: String){\n    prepare(account: AuthAccount){\n        let adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n\n        var marketType : [Type] = [Type\u003c@FindMarketSale.SaleItem\u003e()]\n        switch market {\n            case \"AuctionEscrow\" :\n                marketType = [Type\u003c@FindMarketAuctionEscrow.SaleItem\u003e()]\n\n            case \"AuctionSoft\" :\n                marketType = [Type\u003c@FindMarketAuctionSoft.SaleItem\u003e()]\n\n            case \"DirectOfferEscrow\" :\n                marketType = [Type\u003c@FindMarketDirectOfferEscrow.SaleItem\u003e()]\n\n            case \"DirectOfferSoft\" :\n                marketType = [Type\u003c@FindMarketDirectOfferSoft.SaleItem\u003e()]\n\n        }\n\n        let saleItem = FindMarket.TenantSaleItem(name:\"FlowDandy\".concat(market), cut: nil, rules:[\n            FindMarket.TenantRule(name:\"Flow\", types:[Type\u003c@FUSD.Vault\u003e()], ruleType: \"ft\", allow: true),\n            FindMarket.TenantRule(name:\"Dandy\", types:[Type\u003c@Dandy.NFT\u003e()], ruleType: \"nft\", allow: true),\n            FindMarket.TenantRule(name: market, types:marketType, ruleType: \"listing\", allow: true)\n            ], \n            status: \"active\"\n        )\n\n        adminRef.setMarketOption(tenant: tenant, saleItem: saleItem)\n    }\n}",
               "spec": {
                  "order": [
                     "tenant",
                     "market"
                  ],
                  "parameters": {
                     "market": "String",
                     "tenant": "Address"
                  }
               }
            },
            "adminSetSellDandyForFlow": {
               "code": "import FindMarket from 0x097bafa4e0b48eef\nimport Admin from 0x097bafa4e0b48eef\nimport FlowToken from 0x1654653399040a61\nimport Dandy from 0x097bafa4e0b48eef\nimport FindMarketSale from 0x097bafa4e0b48eef\nimport FindMarketAuctionEscrow from 0x097bafa4e0b48eef\nimport FindMarketAuctionSoft from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferEscrow from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferSoft from 0x097bafa4e0b48eef\n\n\ntransaction(tenant: Address, market: String){\n    prepare(account: AuthAccount){\n        let adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n\n        var marketType : [Type] = [Type\u003c@FindMarketSale.SaleItem\u003e()]\n        switch market {\n            case \"AuctionEscrow\" :\n                marketType = [Type\u003c@FindMarketAuctionEscrow.SaleItem\u003e()]\n\n            case \"AuctionSoft\" :\n                marketType = [Type\u003c@FindMarketAuctionSoft.SaleItem\u003e()]\n\n            case \"DirectOfferEscrow\" :\n                marketType = [Type\u003c@FindMarketDirectOfferEscrow.SaleItem\u003e()]\n\n            case \"DirectOfferSoft\" :\n                marketType = [Type\u003c@FindMarketDirectOfferSoft.SaleItem\u003e()]\n\n        }\n\n        let saleItem = FindMarket.TenantSaleItem(name:\"FlowDandy\".concat(market), cut: nil, rules:[\n            FindMarket.TenantRule(name:\"Flow\", types:[Type\u003c@FlowToken.Vault\u003e()], ruleType: \"ft\", allow: true),\n            FindMarket.TenantRule(name:\"Dandy\", types:[Type\u003c@Dandy.NFT\u003e()], ruleType: \"nft\", allow: true),\n            FindMarket.TenantRule(name: market, types:marketType, ruleType: \"listing\", allow: true)\n            ], \n            status: \"active\"\n        )\n\n        adminRef.setMarketOption(tenant: tenant, saleItem: saleItem)\n    }\n}",
               "spec": {
                  "order": [
                     "tenant",
                     "market"
                  ],
                  "parameters": {
                     "market": "String",
                     "tenant": "Address"
                  }
               }
            },
            "adminSetSellDandyRules": {
               "code": "import FindMarket from 0x097bafa4e0b48eef\nimport Admin from 0x097bafa4e0b48eef\nimport FlowToken from 0x1654653399040a61\nimport FUSD from 0x3c5959b568896393\nimport Dandy from 0x097bafa4e0b48eef\n\ntransaction(tenant: Address) {\n    prepare(account: AuthAccount){\n        let adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n\n        let fusdDandy = FindMarket.TenantSaleItem(name:\"FUSDDandy\", cut: nil, rules:[\n            FindMarket.TenantRule(name:\"FUSD\", types:[Type\u003c@FUSD.Vault\u003e()], ruleType: \"ft\", allow: true),\n            FindMarket.TenantRule(name:\"Dandy\", types:[ Type\u003c@Dandy.NFT\u003e()], ruleType: \"nft\", allow: true)\n            ], \n            status: \"active\"\n        )\n\n        let flowDandy = FindMarket.TenantSaleItem(name:\"FlowDandy\", cut: nil, rules:[\n            FindMarket.TenantRule(name:\"Flow\", types:[Type\u003c@FlowToken.Vault\u003e()], ruleType: \"ft\", allow: true),\n            FindMarket.TenantRule(name:\"Dandy\", types:[ Type\u003c@Dandy.NFT\u003e()], ruleType: \"nft\", allow: true)\n            ], \n            status: \"active\"\n        )\n\n        adminRef.setMarketOption(tenant: tenant, saleItem: fusdDandy)\n        adminRef.setMarketOption(tenant: tenant, saleItem: flowDandy)\n\n    }\n}",
               "spec": {
                  "order": [
                     "tenant"
                  ],
                  "parameters": {
                     "tenant": "Address"
                  }
               }
            },
            "adminSetSellLeaseForFlow": {
               "code": "import FindMarket from 0x097bafa4e0b48eef\nimport Admin from 0x097bafa4e0b48eef\nimport FlowToken from 0x1654653399040a61\nimport FIND from 0x097bafa4e0b48eef\nimport FindLeaseMarketSale from 0x097bafa4e0b48eef\nimport FindLeaseMarketAuctionSoft from 0x097bafa4e0b48eef\nimport FindLeaseMarketDirectOfferSoft from 0x097bafa4e0b48eef\n\ntransaction(tenant: Address, market: String){\n    prepare(account: AuthAccount){\n        let adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n\n        var marketType : [Type] = [Type\u003c@FindLeaseMarketSale.SaleItem\u003e()]\n        switch market {\n            // case \"AuctionEscrow\" :\n            //     marketType = [Type\u003c@FindLeaseMarketAuctionEscrow.SaleItem\u003e()]\n\n            case \"AuctionSoft\" :\n                marketType = [Type\u003c@FindLeaseMarketAuctionSoft.SaleItem\u003e()]\n\n            // case \"DirectOfferEscrow\" :\n            //     marketType = [Type\u003c@FindLeaseMarketDirectOfferEscrow.SaleItem\u003e()]\n\n            case \"DirectOfferSoft\" :\n                marketType = [Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItem\u003e()]\n\n        }\n\n        let saleItem = FindMarket.TenantSaleItem(name:\"FlowLease\".concat(market), cut: nil, rules:[\n            FindMarket.TenantRule(name:\"Flow\", types:[Type\u003c@FlowToken.Vault\u003e()], ruleType: \"ft\", allow: true),\n            FindMarket.TenantRule(name:\"Lease\", types:[Type\u003c@FIND.Lease\u003e()], ruleType: \"nft\", allow: true),\n            FindMarket.TenantRule(name: market, types:marketType, ruleType: \"listing\", allow: true)\n            ], \n            status: \"active\"\n        )\n\n        adminRef.setMarketOption(tenant: tenant, saleItem: saleItem)\n    }\n}",
               "spec": {
                  "order": [
                     "tenant",
                     "market"
                  ],
                  "parameters": {
                     "market": "String",
                     "tenant": "Address"
                  }
               }
            },
            "adminTestnetAddBeam": {
               "code": "import Admin from 0x097bafa4e0b48eef\n// import Beam from 0x6085ae87e78e1433\nimport FindMarket from 0x097bafa4e0b48eef\nimport FlowToken from 0x1654653399040a61\n\ntransaction(tenant:Address) {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n        \n    }\n    execute{\n        let nftType = CompositeType(\"A.6085ae87e78e1433.Beam.NFT\")!\n        self.adminRef.setNFTInfo(alias: \"Beam\", type: nftType, icon: \"https://frightclub.niftory.com/fc_black_logo_round.svg\", providerPath: /private/BeamCollection001, publicPath: /public/BeamCollection001, storagePath: /storage/BeamCollection001, allowedFTTypes: nil, address: 0x6085ae87e78e1433, externalFixedUrl: \"frightclub.niftory.com\")\n\n        let rules = [\n            FindMarket.TenantRule(name:\"Flow\", types:[Type\u003c@FlowToken.Vault\u003e()], ruleType: \"ft\", allow: true),\n            FindMarket.TenantRule(name:\"Beam\", types:[nftType], ruleType: \"nft\", allow: true)\n        ]\n\n        let tenantSaleItem = FindMarket.TenantSaleItem(\n            name: \"FlowBeam\", \n            cut: nil, \n            rules: rules, \n            status:\"active\"\n        )\n\n        self.adminRef.setMarketOption(tenant: tenant, saleItem: tenantSaleItem)\n \n    }\n}",
               "spec": {
                  "order": [
                     "tenant"
                  ],
                  "parameters": {
                     "tenant": "Address"
                  }
               }
            },
            "adminTestnetAddBl0x": {
               "code": "import Admin from 0x097bafa4e0b48eef\nimport Bl0x from 0xe8124d8428980aa6\nimport FindMarket from 0x097bafa4e0b48eef\nimport FlowToken from 0x1654653399040a61\n\ntransaction(tenant: Address) {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n        \n    }\n    execute{\n        self.adminRef.setNFTInfo(\n            alias: \"Bl0x\", \n            type: Type\u003c@Bl0x.NFT\u003e(), \n            icon: \"https://global-uploads.webflow.com/60f008ba9757da0940af288e/626e4af22f80f09e2783df44_blox.jpg\", \n            providerPath: Bl0x.CollectionPrivatePath, \n            publicPath: Bl0x.CollectionPublicPath, \n            storagePath: Bl0x.CollectionStoragePath, \n            allowedFTTypes: nil, \n            address:0xe8124d8428980aa6, externalFixedUrl: \"bl0x-5ccsb92pb-findonflow.vercel.app\")\n\n        let rules = [\n            FindMarket.TenantRule(name:\"Flow\", types:[Type\u003c@FlowToken.Vault\u003e()], ruleType: \"ft\", allow: true),\n            FindMarket.TenantRule(name:\"Bl0x\", types:[Type\u003c@Bl0x.NFT\u003e()], ruleType: \"nft\", allow: true)\n        ]\n\n        let tenantSaleItem = FindMarket.TenantSaleItem(\n            name: \"FlowBl0x\", \n            cut: nil, \n            rules: rules, \n            status:\"active\"\n        )\n\n        self.adminRef.setMarketOption(tenant: tenant, saleItem: tenantSaleItem)\n        \n    }\n}",
               "spec": {
                  "order": [
                     "tenant"
                  ],
                  "parameters": {
                     "tenant": "Address"
                  }
               }
            },
            "adminTestnetAddFlovatar": {
               "code": "import Admin from 0x097bafa4e0b48eef\nimport Flovatar from 0x9392a4a7c3f49a0b\nimport FindMarket from 0x097bafa4e0b48eef\nimport FlowToken from 0x1654653399040a61\n\ntransaction(tenant:Address) {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n        \n    }\n    execute{\n\n        self.adminRef.setNFTInfo(alias: \"Flovatar\", type: Type\u003c@Flovatar.NFT\u003e(), icon: \"https://styles.redditmedia.com/t5_5ikf79/styles/communityIcon_fraplt3tgk681.jpg\", providerPath: /private/FlovatarCollection, publicPath: Flovatar.CollectionPublicPath, storagePath: Flovatar.CollectionStoragePath, allowedFTTypes: nil, address: 0x9392a4a7c3f49a0b, externalFixedUrl: \"flovatar.com\")\n\n        let rules = [\n            FindMarket.TenantRule(name:\"Flow\", types:[Type\u003c@FlowToken.Vault\u003e()], ruleType: \"ft\", allow: true),\n            FindMarket.TenantRule(name:\"Flovatar\", types:[Type\u003c@Flovatar.NFT\u003e()], ruleType: \"nft\", allow: true)\n        ]\n\n        let tenantSaleItem = FindMarket.TenantSaleItem(\n            name: \"FlowFLovatar\", \n            cut: nil, \n            rules: rules, \n            status:\"active\"\n        )\n\n        self.adminRef.setMarketOption(tenant: tenant, saleItem: tenantSaleItem)\n \n    }\n}",
               "spec": {
                  "order": [
                     "tenant"
                  ],
                  "parameters": {
                     "tenant": "Address"
                  }
               }
            },
            "adminTestnetAddVersus": {
               "code": "import Admin from 0x097bafa4e0b48eef\nimport Art from 0x99ca04281098b33d\nimport FindMarket from 0x097bafa4e0b48eef\nimport FlowToken from 0x1654653399040a61\n\ntransaction(tenant: Address) {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n        \n    }\n    execute{\n        self.adminRef.setNFTInfo(\n            alias: \"Versus\", \n            type: Type\u003c@Art.NFT\u003e(), \n            icon: \"https://global-uploads.webflow.com/60f008ba9757da0940af288e/60f02cad72175a774926125f_flow%20versus%20twitter%20lgoo.jpg\",\n            providerPath: /private/versusArtCollection,\n            publicPath: Art.CollectionPublicPath, \n            storagePath: Art.CollectionStoragePath, \n            allowedFTTypes: nil, \n                        address:0x99ca04281098b33d, externalFixedUrl: \"https://versus.auction\")\n\n        let rules = [\n            FindMarket.TenantRule(name:\"Flow\", types:[Type\u003c@FlowToken.Vault\u003e()], ruleType: \"ft\", allow: true),\n            FindMarket.TenantRule(name:\"Versus\", types:[Type\u003c@Art.NFT\u003e()], ruleType: \"nft\", allow: true)\n        ]\n\n        let tenantSaleItem = FindMarket.TenantSaleItem(\n            name: \"FlowVersus\", \n            cut: nil, \n            rules: rules, \n            status:\"active\"\n        )\n\n        self.adminRef.setMarketOption(tenant: tenant, saleItem: tenantSaleItem)\n    }\n}",
               "spec": {
                  "order": [
                     "tenant"
                  ],
                  "parameters": {
                     "tenant": "Address"
                  }
               }
            },
            "adminTransferAllFusd": {
               "code": "// Mainnet\nimport FungibleToken from 0xf233dcee88fe0abe\nimport FUSD from 0x3c5959b568896393\n\n// Testnet\n// import FungibleToken from 0x9a0766d93b6608b7\n// import FUSD from 0xe223d8a629e49c68\n\ntransaction(recipient: Address) {\n\n  // The Vault resource that holds the tokens that are being transfered\n  let sentVault: @FungibleToken.Vault\n\n  prepare(signer: AuthAccount) {\n    // Get a reference to the signer's stored vault\n    let vaultRef = signer.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault)\n      ?? panic(\"Could not borrow reference to the owner's Vault!\")\n\n    // Withdraw tokens from the signer's stored vault\n    self.sentVault \u003c- vaultRef.withdraw(amount: vaultRef.balance)\n  }\n\n  execute {\n    // Get the recipient's public account object\n    let recipientAccount = getAccount(recipient)\n\n    // Get a reference to the recipient's Receiver\n    let receiverRef = recipientAccount.getCapability(/public/fusdReceiver)!\n      .borrow\u003c\u0026{FungibleToken.Receiver}\u003e()\n      ?? panic(\"Could not borrow receiver reference to the recipient's Vault\")\n\n    // Deposit the withdrawn tokens in the recipient's receiver\n    receiverRef.deposit(from: \u003c-self.sentVault)\n  }\n}",
               "spec": {
                  "order": [
                     "recipient"
                  ],
                  "parameters": {
                     "recipient": "Address"
                  }
               }
            },
            "alterMarketOption": {
               "code": "import FindMarket from 0x097bafa4e0b48eef\n\ntransaction(marketRule: String , action: String ){\n    prepare(account: AuthAccount){\n        let path = FindMarket.TenantClientStoragePath\n        let tenantRef = account.borrow\u003c\u0026FindMarket.TenantClient\u003e(from: path) ?? panic(\"Cannot borrow Reference.\")\n\n\n        switch action {\n            case \"enable\" :\n                tenantRef.enableMarketOption(marketRule)\n\n            case \"deprecate\" :\n                tenantRef.deprecateMarketOption(marketRule)\n\n            case \"stop\" :\n                tenantRef.stopMarketOption(marketRule)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "marketRule",
                     "action"
                  ],
                  "parameters": {
                     "action": "String",
                     "marketRule": "String"
                  }
               }
            },
            "bidLeaseMarketAuctionSoft": {
               "code": "import FindMarketSale from 0x097bafa4e0b48eef\nimport FindMarketAuctionEscrow from 0x097bafa4e0b48eef\nimport FindMarketAuctionSoft from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferEscrow from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferSoft from 0x097bafa4e0b48eef\nimport FungibleToken from 0xf233dcee88fe0abe\nimport NonFungibleToken from 0x1d7e57aa55817448\nimport MetadataViews from 0x1d7e57aa55817448\nimport FindViews from 0x097bafa4e0b48eef\nimport FTRegistry from 0x097bafa4e0b48eef\nimport FindMarket from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\nimport FUSD from 0x3c5959b568896393\nimport FiatToken from 0xb19436aae4d94622\nimport FlowToken from 0x1654653399040a61\nimport Dandy from 0x097bafa4e0b48eef\nimport Profile from 0x097bafa4e0b48eef\nimport FindLeaseMarketSale from 0x097bafa4e0b48eef\nimport FindLeaseMarketAuctionSoft from 0x097bafa4e0b48eef\n// import FindLeaseMarketAuctionEscrow from \"../contracts/FindLeaseMarketAuctionEscrow.cdc\"\nimport FindLeaseMarketDirectOfferSoft from 0x097bafa4e0b48eef\n// import FindLeaseMarketDirectOfferEscrow from \"../contracts/FindLeaseMarketDirectOfferEscrow.cdc\"\nimport FindLeaseMarket from 0x097bafa4e0b48eef\n\ntransaction(leaseName: String, amount: UFix64) {\n\n    let saleItemsCap: Capability\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic}\u003e \n    let walletReference : \u0026FungibleToken.Vault\n    let bidsReference: \u0026FindLeaseMarketAuctionSoft.MarketBidCollection?\n    let balanceBeforeBid: UFix64\n    let ftVaultType: Type\n\n    prepare(account: AuthAccount) {\n\n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n        //SYNC with register\n        //Add exising FUSD or create a new one and add it\n        let name = account.address.toString()\n        let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n        if !fusdReceiver.check() {\n            let fusd \u003c- FUSD.createEmptyVault()\n            account.save(\u003c- fusd, to: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n        }\n\n        let usdcCap = account.getCapability\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e(FiatToken.VaultReceiverPubPath)\n        if !usdcCap.check() {\n                account.save( \u003c-FiatToken.createEmptyVault(), to: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e( FiatToken.VaultReceiverPubPath, target: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FiatToken.ResourceId}\u003e( FiatToken.VaultUUIDPubPath, target: FiatToken.VaultStoragePath)\n                account.link\u003c\u0026FiatToken.Vault{FungibleToken.Balance}\u003e( FiatToken.VaultBalancePubPath, target:FiatToken.VaultStoragePath)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let dandyCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        let dandyCapPrivate= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPrivatePath)\n        if !dandyCapPrivate.check() {\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        var created=false\n        var updated=false\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        if !profile.hasWallet(\"Flow\") {\n            let flowWallet=Profile.Wallet( name:\"Flow\", receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), tags: [\"flow\"])\n    \n            profile.addWallet(flowWallet)\n            updated=true\n        }\n        if !profile.hasWallet(\"FUSD\") {\n            profile.addWallet(Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), tags: [\"fusd\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if !profile.hasWallet(\"USDC\") {\n            profile.addWallet(Profile.Wallet( name:\"USDC\", receiver:usdcCap, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(FiatToken.VaultBalancePubPath), accept: Type\u003c@FiatToken.Vault\u003e(), tags: [\"usdc\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else if updated {\n            profile.emitUpdatedEvent()\n        }\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        let doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        let doeSalePublicPath=FindMarket.getPublicPath(doeSaleType, name: tenant.name)\n        let doeSaleStoragePath= FindMarket.getStoragePath(doeSaleType, name:tenant.name)\n        let doeSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n        if !doeSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n        }\n\n        let doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        let doeBidPublicPath=FindMarket.getPublicPath(doeBidType, name: tenant.name)\n        let doeBidStoragePath= FindMarket.getStoragePath(doeBidType, name:tenant.name)\n        let doeBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n        if !doeBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n        }\n\n        /// auctions that escrow ft\n        let aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        let aeSalePublicPath=FindMarket.getPublicPath(aeSaleType, name: tenant.name)\n        let aeSaleStoragePath= FindMarket.getStoragePath(aeSaleType, name:tenant.name)\n        let aeSaleCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n        if !aeSaleCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n        }\n\n        let dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\n        let dosSalePublicPath=FindMarket.getPublicPath(dosSaleType, name: tenant.name)\n        let dosSaleStoragePath= FindMarket.getStoragePath(dosSaleType, name:tenant.name)\n\n        let dosSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n        if !dosSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n        }\n\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n        if !dosBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n        }\n\n        let aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\n        let aeBidPublicPath=FindMarket.getPublicPath(aeBidType, name: tenant.name)\n        let aeBidStoragePath= FindMarket.getStoragePath(aeBidType, name:tenant.name)\n        let aeBidCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n        if !aeBidCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n        }\n\n     /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n        }\n\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n        if !asBidCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n        }\n\n        let leaseTenantCapability= FindMarket.getTenantCapability(FindMarket.getTenantAddress(\"findLease\")!)!\n\n        let leaseSaleItemType= Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()\n        let leasePublicPath=FindMarket.getPublicPath(leaseSaleItemType, name: \"findLease\")\n        let leaseStoragePath= FindMarket.getStoragePath(leaseSaleItemType, name:\"findLease\")\n        let leaseSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath) \n        if !leaseSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketSale.SaleItemCollection\u003e(\u003c- FindLeaseMarketSale.createEmptySaleItemCollection(leaseTenantCapability), to: leaseStoragePath)\n            account.link\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath, target: leaseStoragePath)\n        }\n\n        let leaseASSaleItemType= Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e()\n        let leaseASPublicPath=FindMarket.getPublicPath(leaseASSaleItemType, name: \"findLease\")\n        let leaseASStoragePath= FindMarket.getStoragePath(leaseASSaleItemType, name:\"findLease\")\n        let leaseASSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath) \n        if !leaseASSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseASStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath, target: leaseASStoragePath)\n        }\n\n\n        let leaseASBidType= Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e()\n        let leaseASBidPublicPath=FindMarket.getPublicPath(leaseASBidType, name: \"findLease\")\n        let leaseASBidStoragePath= FindMarket.getStoragePath(leaseASBidType, name: \"findLease\")\n        let leaseASBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath) \n        if !leaseASBidCap.check() {\n            account.save\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseASBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath, target: leaseASBidStoragePath)\n        }\n\n        // let leaseAESaleItemType= Type\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e()\n        // let leaseAEPublicPath=FindMarket.getPublicPath(leaseAESaleItemType, name: \"findLease\")\n        // let leaseAEStoragePath= FindMarket.getStoragePath(leaseAESaleItemType, name:\"findLease\")\n        // let leaseAESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath) \n        // if !leaseAESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseAEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath, target: leaseAEStoragePath)\n        // }\n\n        // let leaseAEBidType= Type\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e()\n        // let leaseAEBidPublicPath=FindMarket.getPublicPath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidStoragePath= FindMarket.getStoragePath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath) \n        // if !leaseAEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseAEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath, target: leaseAEBidStoragePath)\n        // }\n\n        let leaseDOSSaleItemType= Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e()\n        let leaseDOSPublicPath=FindMarket.getPublicPath(leaseDOSSaleItemType, name: \"findLease\")\n        let leaseDOSStoragePath= FindMarket.getStoragePath(leaseDOSSaleItemType, name:\"findLease\")\n        let leaseDOSSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath) \n        if !leaseDOSSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOSStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath, target: leaseDOSStoragePath)\n        }\n\n        let leaseDOSBidType= Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let leaseDOSBidPublicPath=FindMarket.getPublicPath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidStoragePath= FindMarket.getStoragePath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath) \n        if !leaseDOSBidCap.check() {\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOSBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath, target: leaseDOSBidStoragePath)\n        }\n\n        // let leaseDOESaleItemType= Type\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        // let leaseDOEPublicPath=FindMarket.getPublicPath(leaseDOESaleItemType, name: \"findLease\")\n        // let leaseDOEStoragePath= FindMarket.getStoragePath(leaseDOESaleItemType, name:\"findLease\")\n        // let leaseDOESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath) \n        // if !leaseDOESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath, target: leaseDOEStoragePath)\n        // }\n\n        // let leaseDOEBidType= Type\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        // let leaseDOEBidPublicPath=FindMarket.getPublicPath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidStoragePath= FindMarket.getStoragePath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath) \n        // if !leaseDOEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath, target: leaseDOEBidStoragePath)\n        // }\n        //SYNC with register\n\n        let resolveAddress = FIND.resolve(leaseName)\n        if resolveAddress == nil {panic(\"The address input is not a valid name nor address. Input : \".concat(leaseName))}\n        let address = resolveAddress!\n\n        let leaseMarketplace = FindMarket.getTenantAddress(\"findLease\")!\n        let leaseTenant = leaseTenantCapability.borrow()!\n        self.saleItemsCap= FindLeaseMarketAuctionSoft.getSaleItemCapability(marketplace:leaseMarketplace, user:address) ?? panic(\"cannot find sale item cap\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e())\n\n        let item = FindLeaseMarket.assertOperationValid(tenant: leaseMarketplace, name: leaseName, marketOption: marketOption)\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n        \n        self.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account. Account address : \".concat(account.address.toString()))\n        self.ftVaultType = ft.type\n\n        let bidStoragePath=leaseTenant.getStoragePath(Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e())\n\n        self.bidsReference= account.borrow\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(from: bidStoragePath)\n        self.balanceBeforeBid=self.walletReference.balance\n    }\n\n    pre {\n        self.bidsReference != nil : \"This account does not have a bid collection\"\n        self.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n    }\n\n    execute {\n        self.bidsReference!.bid(name:leaseName, amount: amount, vaultType: self.ftVaultType, bidExtraField: {})\n    }\n}",
               "spec": {
                  "order": [
                     "leaseName",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "leaseName": "String"
                  }
               }
            },
            "bidLeaseMarketAuctionSoftDUC": {
               "code": "import FindMarketSale from 0x097bafa4e0b48eef\nimport FindMarketAuctionEscrow from 0x097bafa4e0b48eef\nimport FindMarketAuctionSoft from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferEscrow from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferSoft from 0x097bafa4e0b48eef\nimport FungibleToken from 0xf233dcee88fe0abe\nimport NonFungibleToken from 0x1d7e57aa55817448\nimport MetadataViews from 0x1d7e57aa55817448\nimport FindViews from 0x097bafa4e0b48eef\nimport FTRegistry from 0x097bafa4e0b48eef\nimport FindMarket from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\nimport TokenForwarding from 0xe544175ee0461c4b\nimport DapperUtilityCoin from 0xead892083b3e2c6c\nimport FlowToken from 0x1654653399040a61\nimport Dandy from 0x097bafa4e0b48eef\nimport Profile from 0x097bafa4e0b48eef\nimport FindLeaseMarketSale from 0x097bafa4e0b48eef\nimport FindLeaseMarketAuctionSoft from 0x097bafa4e0b48eef\n// import FindLeaseMarketAuctionEscrow from \"../contracts/FindLeaseMarketAuctionEscrow.cdc\"\nimport FindLeaseMarketDirectOfferSoft from 0x097bafa4e0b48eef\n// import FindLeaseMarketDirectOfferEscrow from \"../contracts/FindLeaseMarketDirectOfferEscrow.cdc\"\nimport FindLeaseMarket from 0x097bafa4e0b48eef\n\ntransaction(dapperAddress: Address, leaseName: String, amount: UFix64) {\n\n    let saleItemsCap: Capability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic}\u003e \n    let bidsReference: \u0026FindLeaseMarketAuctionSoft.MarketBidCollection?\n    let ftVaultType: Type\n\n    prepare(account: AuthAccount) {\n\n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n        //SYNC with register\n        //Add exising FUSD or create a new one and add it\n        let name = account.address.toString()\n        let ducReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver)\n        if !ducReceiver.check() {\n            let dapper = getAccount(dapperAddress)\n            // Create a new Forwarder resource for DUC and store it in the new account's storage\n            let ducForwarder \u003c- TokenForwarding.createNewForwarder(recipient: dapper.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver))\n            account.save(\u003c-ducForwarder, to: /storage/dapperUtilityCoinReceiver)\n            // Publish a Receiver capability for the new account, which is linked to the DUC Forwarder\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver,target: /storage/dapperUtilityCoinReceiver)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: ducReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let dandyCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        let dandyCapPrivate= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPrivatePath)\n        if !dandyCapPrivate.check() {\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        var created=false\n        var updated=false\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        if !profile.hasWallet(\"Flow\") {\n            let flowWallet=Profile.Wallet( name:\"Flow\", receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), tags: [\"flow\"])\n    \n            profile.addWallet(flowWallet)\n            updated=true\n        }\n        if !profile.hasWallet(\"DUC\") {\n            profile.addWallet(Profile.Wallet( name:\"DUC\", receiver:ducReceiver, balance:getAccount(dapperAddress).getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/dapperUtilityCoinBalance), accept: Type\u003c@DapperUtilityCoin.Vault\u003e(), tags: [\"duc\", \"dapperUtilityCoin\",\"dapper\"]))\n            updated=true\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else {\n            profile.emitUpdatedEvent()\n        }\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        let doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        let doeSalePublicPath=FindMarket.getPublicPath(doeSaleType, name: tenant.name)\n        let doeSaleStoragePath= FindMarket.getStoragePath(doeSaleType, name:tenant.name)\n        let doeSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n        if !doeSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n        }\n\n        let doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        let doeBidPublicPath=FindMarket.getPublicPath(doeBidType, name: tenant.name)\n        let doeBidStoragePath= FindMarket.getStoragePath(doeBidType, name:tenant.name)\n        let doeBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n        if !doeBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n        }\n\n        /// auctions that escrow ft\n        let aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        let aeSalePublicPath=FindMarket.getPublicPath(aeSaleType, name: tenant.name)\n        let aeSaleStoragePath= FindMarket.getStoragePath(aeSaleType, name:tenant.name)\n        let aeSaleCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n        if !aeSaleCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n        }\n\n        let dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\n        let dosSalePublicPath=FindMarket.getPublicPath(dosSaleType, name: tenant.name)\n        let dosSaleStoragePath= FindMarket.getStoragePath(dosSaleType, name:tenant.name)\n\n        let dosSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n        if !dosSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n        }\n\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n        if !dosBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n        }\n\n        let aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\n        let aeBidPublicPath=FindMarket.getPublicPath(aeBidType, name: tenant.name)\n        let aeBidStoragePath= FindMarket.getStoragePath(aeBidType, name:tenant.name)\n        let aeBidCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n        if !aeBidCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n        }\n\n     /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n        }\n\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n        if !asBidCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n        }\n\n        let leaseTenantCapability= FindMarket.getTenantCapability(FindMarket.getTenantAddress(\"findLease\")!)!\n\n        let leaseSaleItemType= Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()\n        let leasePublicPath=FindMarket.getPublicPath(leaseSaleItemType, name: \"findLease\")\n        let leaseStoragePath= FindMarket.getStoragePath(leaseSaleItemType, name:\"findLease\")\n        let leaseSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath) \n        if !leaseSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketSale.SaleItemCollection\u003e(\u003c- FindLeaseMarketSale.createEmptySaleItemCollection(leaseTenantCapability), to: leaseStoragePath)\n            account.link\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath, target: leaseStoragePath)\n        }\n\n        let leaseASSaleItemType= Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e()\n        let leaseASPublicPath=FindMarket.getPublicPath(leaseASSaleItemType, name: \"findLease\")\n        let leaseASStoragePath= FindMarket.getStoragePath(leaseASSaleItemType, name:\"findLease\")\n        let leaseASSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath) \n        if !leaseASSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseASStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath, target: leaseASStoragePath)\n        }\n\n\n        let leaseASBidType= Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e()\n        let leaseASBidPublicPath=FindMarket.getPublicPath(leaseASBidType, name: \"findLease\")\n        let leaseASBidStoragePath= FindMarket.getStoragePath(leaseASBidType, name: \"findLease\")\n        let leaseASBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath) \n        if !leaseASBidCap.check() {\n            account.save\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseASBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath, target: leaseASBidStoragePath)\n        }\n\n        // let leaseAESaleItemType= Type\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e()\n        // let leaseAEPublicPath=FindMarket.getPublicPath(leaseAESaleItemType, name: \"findLease\")\n        // let leaseAEStoragePath= FindMarket.getStoragePath(leaseAESaleItemType, name:\"findLease\")\n        // let leaseAESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath) \n        // if !leaseAESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseAEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath, target: leaseAEStoragePath)\n        // }\n\n        // let leaseAEBidType= Type\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e()\n        // let leaseAEBidPublicPath=FindMarket.getPublicPath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidStoragePath= FindMarket.getStoragePath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath) \n        // if !leaseAEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseAEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath, target: leaseAEBidStoragePath)\n        // }\n\n        let leaseDOSSaleItemType= Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e()\n        let leaseDOSPublicPath=FindMarket.getPublicPath(leaseDOSSaleItemType, name: \"findLease\")\n        let leaseDOSStoragePath= FindMarket.getStoragePath(leaseDOSSaleItemType, name:\"findLease\")\n        let leaseDOSSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath) \n        if !leaseDOSSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOSStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath, target: leaseDOSStoragePath)\n        }\n\n        let leaseDOSBidType= Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let leaseDOSBidPublicPath=FindMarket.getPublicPath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidStoragePath= FindMarket.getStoragePath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath) \n        if !leaseDOSBidCap.check() {\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOSBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath, target: leaseDOSBidStoragePath)\n        }\n\n        // let leaseDOESaleItemType= Type\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        // let leaseDOEPublicPath=FindMarket.getPublicPath(leaseDOESaleItemType, name: \"findLease\")\n        // let leaseDOEStoragePath= FindMarket.getStoragePath(leaseDOESaleItemType, name:\"findLease\")\n        // let leaseDOESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath) \n        // if !leaseDOESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath, target: leaseDOEStoragePath)\n        // }\n\n        // let leaseDOEBidType= Type\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        // let leaseDOEBidPublicPath=FindMarket.getPublicPath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidStoragePath= FindMarket.getStoragePath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath) \n        // if !leaseDOEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath, target: leaseDOEBidStoragePath)\n        // }\n        //SYNC with register\n\n        let resolveAddress = FIND.resolve(leaseName)\n        if resolveAddress == nil {panic(\"The address input is not a valid name nor address. Input : \".concat(leaseName))}\n        let address = resolveAddress!\n\n        let leaseMarketplace = FindMarket.getTenantAddress(\"findLease\")!\n        let leaseTenant = leaseTenantCapability.borrow()!\n\n        self.saleItemsCap= FindMarketAuctionSoft.getSaleItemCapability(marketplace:leaseMarketplace, user:address) ?? panic(\"cannot find sale item cap\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e())\n\n        let item = FindLeaseMarket.assertOperationValid(tenant: leaseMarketplace, name: leaseName, marketOption: marketOption)\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n        \n        self.ftVaultType = ft.type\n\n        let bidStoragePath=leaseTenant.getStoragePath(Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e())\n\n        self.bidsReference= account.borrow\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(from: bidStoragePath)\n    }\n\n    pre {\n        self.bidsReference != nil : \"This account does not have a bid collection\"\n    }\n\n    execute {\n        self.bidsReference!.bid(name:leaseName, amount: amount, vaultType: self.ftVaultType, bidExtraField: {})\n    }\n}",
               "spec": {
                  "order": [
                     "dapperAddress",
                     "leaseName",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "dapperAddress": "Address",
                     "leaseName": "String"
                  }
               }
            },
            "bidLeaseMarketDirectOfferSoft": {
               "code": "import FindMarketSale from 0x097bafa4e0b48eef\nimport FindMarketAuctionEscrow from 0x097bafa4e0b48eef\nimport FindMarketAuctionSoft from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferEscrow from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferSoft from 0x097bafa4e0b48eef\nimport FindMarket from 0x097bafa4e0b48eef\nimport FungibleToken from 0xf233dcee88fe0abe\nimport NonFungibleToken from 0x1d7e57aa55817448\nimport MetadataViews from 0x1d7e57aa55817448\nimport FindViews from 0x097bafa4e0b48eef\nimport FTRegistry from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\nimport FUSD from 0x3c5959b568896393\nimport FiatToken from 0xb19436aae4d94622\nimport FlowToken from 0x1654653399040a61\nimport Dandy from 0x097bafa4e0b48eef\nimport Profile from 0x097bafa4e0b48eef\nimport FindLeaseMarketSale from 0x097bafa4e0b48eef\nimport FindLeaseMarketAuctionSoft from 0x097bafa4e0b48eef\n// import FindLeaseMarketAuctionEscrow from \"../contracts/FindLeaseMarketAuctionEscrow.cdc\"\nimport FindLeaseMarketDirectOfferSoft from 0x097bafa4e0b48eef\n// import FindLeaseMarketDirectOfferEscrow from \"../contracts/FindLeaseMarketDirectOfferEscrow.cdc\"\nimport FindLeaseMarket from 0x097bafa4e0b48eef\n\ntransaction(leaseName: String, ftAliasOrIdentifier:String, amount: UFix64, validUntil: UFix64?) {\n\n    let bidsReference: \u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection?\n    let ftVaultType: Type\n\n    prepare(account: AuthAccount) {\n        \n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n        //SYNC with register\n        //Add exising FUSD or create a new one and add it\n        let name = account.address.toString()\n        let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n        if !fusdReceiver.check() {\n            let fusd \u003c- FUSD.createEmptyVault()\n            account.save(\u003c- fusd, to: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n        }\n\n        let usdcCap = account.getCapability\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e(FiatToken.VaultReceiverPubPath)\n        if !usdcCap.check() {\n                account.save( \u003c-FiatToken.createEmptyVault(), to: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e( FiatToken.VaultReceiverPubPath, target: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FiatToken.ResourceId}\u003e( FiatToken.VaultUUIDPubPath, target: FiatToken.VaultStoragePath)\n                account.link\u003c\u0026FiatToken.Vault{FungibleToken.Balance}\u003e( FiatToken.VaultBalancePubPath, target:FiatToken.VaultStoragePath)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let dandyCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        let dandyCapPrivate= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPrivatePath)\n        if !dandyCapPrivate.check() {\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        var created=false\n        var updated=false\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        if !profile.hasWallet(\"Flow\") {\n            let flowWallet=Profile.Wallet( name:\"Flow\", receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), tags: [\"flow\"])\n    \n            profile.addWallet(flowWallet)\n            updated=true\n        }\n        if !profile.hasWallet(\"FUSD\") {\n            profile.addWallet(Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), tags: [\"fusd\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if !profile.hasWallet(\"USDC\") {\n            profile.addWallet(Profile.Wallet( name:\"USDC\", receiver:usdcCap, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(FiatToken.VaultBalancePubPath), accept: Type\u003c@FiatToken.Vault\u003e(), tags: [\"usdc\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else if updated {\n            profile.emitUpdatedEvent()\n        }\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        let doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        let doeSalePublicPath=FindMarket.getPublicPath(doeSaleType, name: tenant.name)\n        let doeSaleStoragePath= FindMarket.getStoragePath(doeSaleType, name:tenant.name)\n        let doeSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n        if !doeSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n        }\n\n        let doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        let doeBidPublicPath=FindMarket.getPublicPath(doeBidType, name: tenant.name)\n        let doeBidStoragePath= FindMarket.getStoragePath(doeBidType, name:tenant.name)\n        let doeBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n        if !doeBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n        }\n\n        /// auctions that escrow ft\n        let aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        let aeSalePublicPath=FindMarket.getPublicPath(aeSaleType, name: tenant.name)\n        let aeSaleStoragePath= FindMarket.getStoragePath(aeSaleType, name:tenant.name)\n        let aeSaleCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n        if !aeSaleCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n        }\n\n        let dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\n        let dosSalePublicPath=FindMarket.getPublicPath(dosSaleType, name: tenant.name)\n        let dosSaleStoragePath= FindMarket.getStoragePath(dosSaleType, name:tenant.name)\n\n        let dosSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n        if !dosSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n        }\n\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n        if !dosBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n        }\n\n        let aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\n        let aeBidPublicPath=FindMarket.getPublicPath(aeBidType, name: tenant.name)\n        let aeBidStoragePath= FindMarket.getStoragePath(aeBidType, name:tenant.name)\n        let aeBidCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n        if !aeBidCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n        }\n\n     /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n        }\n\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n        if !asBidCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n        }\n\n        let leaseTenantCapability= FindMarket.getTenantCapability(FindMarket.getTenantAddress(\"findLease\")!)!\n\n        let leaseSaleItemType= Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()\n        let leasePublicPath=FindMarket.getPublicPath(leaseSaleItemType, name: \"findLease\")\n        let leaseStoragePath= FindMarket.getStoragePath(leaseSaleItemType, name:\"findLease\")\n        let leaseSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath) \n        if !leaseSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketSale.SaleItemCollection\u003e(\u003c- FindLeaseMarketSale.createEmptySaleItemCollection(leaseTenantCapability), to: leaseStoragePath)\n            account.link\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath, target: leaseStoragePath)\n        }\n\n        let leaseASSaleItemType= Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e()\n        let leaseASPublicPath=FindMarket.getPublicPath(leaseASSaleItemType, name: \"findLease\")\n        let leaseASStoragePath= FindMarket.getStoragePath(leaseASSaleItemType, name:\"findLease\")\n        let leaseASSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath) \n        if !leaseASSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseASStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath, target: leaseASStoragePath)\n        }\n\n\n        let leaseASBidType= Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e()\n        let leaseASBidPublicPath=FindMarket.getPublicPath(leaseASBidType, name: \"findLease\")\n        let leaseASBidStoragePath= FindMarket.getStoragePath(leaseASBidType, name: \"findLease\")\n        let leaseASBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath) \n        if !leaseASBidCap.check() {\n            account.save\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseASBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath, target: leaseASBidStoragePath)\n        }\n\n        // let leaseAESaleItemType= Type\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e()\n        // let leaseAEPublicPath=FindMarket.getPublicPath(leaseAESaleItemType, name: \"findLease\")\n        // let leaseAEStoragePath= FindMarket.getStoragePath(leaseAESaleItemType, name:\"findLease\")\n        // let leaseAESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath) \n        // if !leaseAESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseAEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath, target: leaseAEStoragePath)\n        // }\n\n        // let leaseAEBidType= Type\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e()\n        // let leaseAEBidPublicPath=FindMarket.getPublicPath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidStoragePath= FindMarket.getStoragePath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath) \n        // if !leaseAEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseAEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath, target: leaseAEBidStoragePath)\n        // }\n\n        let leaseDOSSaleItemType= Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e()\n        let leaseDOSPublicPath=FindMarket.getPublicPath(leaseDOSSaleItemType, name: \"findLease\")\n        let leaseDOSStoragePath= FindMarket.getStoragePath(leaseDOSSaleItemType, name:\"findLease\")\n        let leaseDOSSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath) \n        if !leaseDOSSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOSStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath, target: leaseDOSStoragePath)\n        }\n\n        let leaseDOSBidType= Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let leaseDOSBidPublicPath=FindMarket.getPublicPath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidStoragePath= FindMarket.getStoragePath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath) \n        if !leaseDOSBidCap.check() {\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOSBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath, target: leaseDOSBidStoragePath)\n        }\n\n        // let leaseDOESaleItemType= Type\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        // let leaseDOEPublicPath=FindMarket.getPublicPath(leaseDOESaleItemType, name: \"findLease\")\n        // let leaseDOEStoragePath= FindMarket.getStoragePath(leaseDOESaleItemType, name:\"findLease\")\n        // let leaseDOESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath) \n        // if !leaseDOESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath, target: leaseDOEStoragePath)\n        // }\n\n        // let leaseDOEBidType= Type\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        // let leaseDOEBidPublicPath=FindMarket.getPublicPath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidStoragePath= FindMarket.getStoragePath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath) \n        // if !leaseDOEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath, target: leaseDOEBidStoragePath)\n        // }\n        //SYNC with register\n\n        let resolveAddress = FIND.resolve(leaseName)\n        if resolveAddress == nil {panic(\"The address input is not a valid name nor address. Input : \".concat(leaseName))}\n        let address = resolveAddress!\n\n        let ft = FTRegistry.getFTInfo(ftAliasOrIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftAliasOrIdentifier))\n\n        self.ftVaultType = ft.type\n\n        let walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n        assert(walletReference.balance \u003e amount , message: \"Bidder has to have enough balance in wallet\")\n\n\n        let leaseTenant = leaseTenantCapability.borrow()!\n        let bidStoragePath=leaseTenant.getStoragePath(Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e())!\n        self.bidsReference= account.borrow\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(from: bidStoragePath)\n\n    }\n\n    pre {\n        self.bidsReference != nil : \"This account does not have a bid collection\"\n    }\n\n    execute {\n        self.bidsReference!.bid(name:leaseName, amount: amount, vaultType: self.ftVaultType, validUntil: validUntil, saleItemExtraField: {}, bidExtraField: {})\n    }\n}",
               "spec": {
                  "order": [
                     "leaseName",
                     "ftAliasOrIdentifier",
                     "amount",
                     "validUntil"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "ftAliasOrIdentifier": "String",
                     "leaseName": "String",
                     "validUntil": "UFix64?"
                  }
               }
            },
            "bidLeaseMarketDirectOfferSoftDUC": {
               "code": "import FindMarketSale from 0x097bafa4e0b48eef\nimport FindMarketAuctionEscrow from 0x097bafa4e0b48eef\nimport FindMarketAuctionSoft from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferEscrow from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferSoft from 0x097bafa4e0b48eef\nimport FindMarket from 0x097bafa4e0b48eef\nimport FungibleToken from 0xf233dcee88fe0abe\nimport NonFungibleToken from 0x1d7e57aa55817448\nimport MetadataViews from 0x1d7e57aa55817448\nimport FindViews from 0x097bafa4e0b48eef\nimport FTRegistry from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\nimport FlowToken from 0x1654653399040a61\nimport TokenForwarding from 0xe544175ee0461c4b\nimport DapperUtilityCoin from 0xead892083b3e2c6c\nimport Dandy from 0x097bafa4e0b48eef\nimport Profile from 0x097bafa4e0b48eef\nimport FindLeaseMarketSale from 0x097bafa4e0b48eef\nimport FindLeaseMarketAuctionSoft from 0x097bafa4e0b48eef\n// import FindLeaseMarketAuctionEscrow from \"../contracts/FindLeaseMarketAuctionEscrow.cdc\"\nimport FindLeaseMarketDirectOfferSoft from 0x097bafa4e0b48eef\n// import FindLeaseMarketDirectOfferEscrow from \"../contracts/FindLeaseMarketDirectOfferEscrow.cdc\"\nimport FindLeaseMarket from 0x097bafa4e0b48eef\n\ntransaction(dapperAddress: Address, leaseName: String, amount: UFix64, validUntil: UFix64?) {\n\n    let bidsReference: \u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection?\n    let ftVaultType: Type\n\n    prepare(account: AuthAccount) {\n        \n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n        //SYNC with register\n        //Add exising FUSD or create a new one and add it\n        let name = account.address.toString()\n        let ducReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver)\n        if !ducReceiver.check() {\n            let dapper = getAccount(dapperAddress)\n            // Create a new Forwarder resource for DUC and store it in the new account's storage\n            let ducForwarder \u003c- TokenForwarding.createNewForwarder(recipient: dapper.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver))\n            account.save(\u003c-ducForwarder, to: /storage/dapperUtilityCoinReceiver)\n            // Publish a Receiver capability for the new account, which is linked to the DUC Forwarder\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver,target: /storage/dapperUtilityCoinReceiver)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: ducReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let dandyCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        let dandyCapPrivate= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPrivatePath)\n        if !dandyCapPrivate.check() {\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        var created=false\n        var updated=false\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        if !profile.hasWallet(\"Flow\") {\n            let flowWallet=Profile.Wallet( name:\"Flow\", receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), tags: [\"flow\"])\n    \n            profile.addWallet(flowWallet)\n            updated=true\n        }\n        if !profile.hasWallet(\"DUC\") {\n            profile.addWallet(Profile.Wallet( name:\"DUC\", receiver:ducReceiver, balance:getAccount(dapperAddress).getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/dapperUtilityCoinBalance), accept: Type\u003c@DapperUtilityCoin.Vault\u003e(), tags: [\"duc\", \"dapperUtilityCoin\",\"dapper\"]))\n            updated=true\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else {\n            profile.emitUpdatedEvent()\n        }\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        let doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        let doeSalePublicPath=FindMarket.getPublicPath(doeSaleType, name: tenant.name)\n        let doeSaleStoragePath= FindMarket.getStoragePath(doeSaleType, name:tenant.name)\n        let doeSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n        if !doeSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n        }\n\n        let doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        let doeBidPublicPath=FindMarket.getPublicPath(doeBidType, name: tenant.name)\n        let doeBidStoragePath= FindMarket.getStoragePath(doeBidType, name:tenant.name)\n        let doeBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n        if !doeBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n        }\n\n        /// auctions that escrow ft\n        let aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        let aeSalePublicPath=FindMarket.getPublicPath(aeSaleType, name: tenant.name)\n        let aeSaleStoragePath= FindMarket.getStoragePath(aeSaleType, name:tenant.name)\n        let aeSaleCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n        if !aeSaleCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n        }\n\n        let dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\n        let dosSalePublicPath=FindMarket.getPublicPath(dosSaleType, name: tenant.name)\n        let dosSaleStoragePath= FindMarket.getStoragePath(dosSaleType, name:tenant.name)\n\n        let dosSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n        if !dosSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n        }\n\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n        if !dosBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n        }\n\n        let aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\n        let aeBidPublicPath=FindMarket.getPublicPath(aeBidType, name: tenant.name)\n        let aeBidStoragePath= FindMarket.getStoragePath(aeBidType, name:tenant.name)\n        let aeBidCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n        if !aeBidCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n        }\n\n     /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n        }\n\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n        if !asBidCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n        }\n\n        let leaseTenantCapability= FindMarket.getTenantCapability(FindMarket.getTenantAddress(\"findLease\")!)!\n\n        let leaseSaleItemType= Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()\n        let leasePublicPath=FindMarket.getPublicPath(leaseSaleItemType, name: \"findLease\")\n        let leaseStoragePath= FindMarket.getStoragePath(leaseSaleItemType, name:\"findLease\")\n        let leaseSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath) \n        if !leaseSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketSale.SaleItemCollection\u003e(\u003c- FindLeaseMarketSale.createEmptySaleItemCollection(leaseTenantCapability), to: leaseStoragePath)\n            account.link\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath, target: leaseStoragePath)\n        }\n\n        let leaseASSaleItemType= Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e()\n        let leaseASPublicPath=FindMarket.getPublicPath(leaseASSaleItemType, name: \"findLease\")\n        let leaseASStoragePath= FindMarket.getStoragePath(leaseASSaleItemType, name:\"findLease\")\n        let leaseASSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath) \n        if !leaseASSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseASStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath, target: leaseASStoragePath)\n        }\n\n\n        let leaseASBidType= Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e()\n        let leaseASBidPublicPath=FindMarket.getPublicPath(leaseASBidType, name: \"findLease\")\n        let leaseASBidStoragePath= FindMarket.getStoragePath(leaseASBidType, name: \"findLease\")\n        let leaseASBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath) \n        if !leaseASBidCap.check() {\n            account.save\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseASBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath, target: leaseASBidStoragePath)\n        }\n\n        // let leaseAESaleItemType= Type\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e()\n        // let leaseAEPublicPath=FindMarket.getPublicPath(leaseAESaleItemType, name: \"findLease\")\n        // let leaseAEStoragePath= FindMarket.getStoragePath(leaseAESaleItemType, name:\"findLease\")\n        // let leaseAESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath) \n        // if !leaseAESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseAEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath, target: leaseAEStoragePath)\n        // }\n\n        // let leaseAEBidType= Type\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e()\n        // let leaseAEBidPublicPath=FindMarket.getPublicPath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidStoragePath= FindMarket.getStoragePath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath) \n        // if !leaseAEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseAEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath, target: leaseAEBidStoragePath)\n        // }\n\n        let leaseDOSSaleItemType= Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e()\n        let leaseDOSPublicPath=FindMarket.getPublicPath(leaseDOSSaleItemType, name: \"findLease\")\n        let leaseDOSStoragePath= FindMarket.getStoragePath(leaseDOSSaleItemType, name:\"findLease\")\n        let leaseDOSSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath) \n        if !leaseDOSSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOSStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath, target: leaseDOSStoragePath)\n        }\n\n        let leaseDOSBidType= Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let leaseDOSBidPublicPath=FindMarket.getPublicPath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidStoragePath= FindMarket.getStoragePath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath) \n        if !leaseDOSBidCap.check() {\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOSBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath, target: leaseDOSBidStoragePath)\n        }\n\n        // let leaseDOESaleItemType= Type\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        // let leaseDOEPublicPath=FindMarket.getPublicPath(leaseDOESaleItemType, name: \"findLease\")\n        // let leaseDOEStoragePath= FindMarket.getStoragePath(leaseDOESaleItemType, name:\"findLease\")\n        // let leaseDOESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath) \n        // if !leaseDOESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath, target: leaseDOEStoragePath)\n        // }\n\n        // let leaseDOEBidType= Type\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        // let leaseDOEBidPublicPath=FindMarket.getPublicPath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidStoragePath= FindMarket.getStoragePath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath) \n        // if !leaseDOEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath, target: leaseDOEBidStoragePath)\n        // }\n        //SYNC with register\n\n        let ft = FTRegistry.getFTInfo(Type\u003c@DapperUtilityCoin.Vault\u003e().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(Type\u003c@DapperUtilityCoin.Vault\u003e().identifier))\n\n        self.ftVaultType = ft.type\n\n        let leaseTenant = leaseTenantCapability.borrow()!\n        let bidStoragePath=leaseTenant.getStoragePath(Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e())!\n        self.bidsReference= account.borrow\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(from: bidStoragePath)\n\n    }\n\n    pre {\n        self.bidsReference != nil : \"This account does not have a bid collection\"\n    }\n\n    execute {\n        self.bidsReference!.bid(name:leaseName, amount: amount, vaultType: self.ftVaultType, validUntil: validUntil, saleItemExtraField: {}, bidExtraField: {})\n    }\n}",
               "spec": {
                  "order": [
                     "dapperAddress",
                     "leaseName",
                     "amount",
                     "validUntil"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "dapperAddress": "Address",
                     "leaseName": "String",
                     "validUntil": "UFix64?"
                  }
               }
            },
            "bidMarketAuctionEscrowed": {
               "code": "import FindMarketSale from 0x097bafa4e0b48eef\nimport FindMarketAuctionEscrow from 0x097bafa4e0b48eef\nimport FindMarketAuctionSoft from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferEscrow from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferSoft from 0x097bafa4e0b48eef\nimport FungibleToken from 0xf233dcee88fe0abe\nimport NonFungibleToken from 0x1d7e57aa55817448\nimport MetadataViews from 0x1d7e57aa55817448\nimport FindViews from 0x097bafa4e0b48eef\nimport NFTCatalog from 0x49a7cda3a1eecc29\nimport FINDNFTCatalog from 0x097bafa4e0b48eef\nimport FTRegistry from 0x097bafa4e0b48eef\nimport FindMarket from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\nimport FUSD from 0x3c5959b568896393\nimport FiatToken from 0xb19436aae4d94622\nimport FlowToken from 0x1654653399040a61\nimport Dandy from 0x097bafa4e0b48eef\nimport Profile from 0x097bafa4e0b48eef\nimport FindLeaseMarketSale from 0x097bafa4e0b48eef\nimport FindLeaseMarketAuctionSoft from 0x097bafa4e0b48eef\n// import FindLeaseMarketAuctionEscrow from \"../contracts/FindLeaseMarketAuctionEscrow.cdc\"\nimport FindLeaseMarketDirectOfferSoft from 0x097bafa4e0b48eef\n// import FindLeaseMarketDirectOfferEscrow from \"../contracts/FindLeaseMarketDirectOfferEscrow.cdc\"\nimport FindLeaseMarket from 0x097bafa4e0b48eef\n\ntransaction(marketplace:Address, user: String, id: UInt64, amount: UFix64) {\n\n    let saleItemsCap: Capability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic}\u003e \n    var targetCapability : Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e\n    let walletReference : \u0026FungibleToken.Vault\n    let bidsReference: \u0026FindMarketAuctionEscrow.MarketBidCollection?\n    let balanceBeforeBid: UFix64\n    let pointer: FindViews.ViewReadPointer\n\n    prepare(account: AuthAccount) {\n\n\n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n        //SYNC with register\n        //Add exising FUSD or create a new one and add it\n        let name = account.address.toString()\n        let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n        if !fusdReceiver.check() {\n            let fusd \u003c- FUSD.createEmptyVault()\n            account.save(\u003c- fusd, to: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n        }\n\n        let usdcCap = account.getCapability\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e(FiatToken.VaultReceiverPubPath)\n        if !usdcCap.check() {\n                account.save( \u003c-FiatToken.createEmptyVault(), to: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e( FiatToken.VaultReceiverPubPath, target: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FiatToken.ResourceId}\u003e( FiatToken.VaultUUIDPubPath, target: FiatToken.VaultStoragePath)\n                account.link\u003c\u0026FiatToken.Vault{FungibleToken.Balance}\u003e( FiatToken.VaultBalancePubPath, target:FiatToken.VaultStoragePath)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let dandyCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        let dandyCapPrivate= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPrivatePath)\n        if !dandyCapPrivate.check() {\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        var created=false\n        var updated=false\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        if !profile.hasWallet(\"Flow\") {\n            let flowWallet=Profile.Wallet( name:\"Flow\", receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), tags: [\"flow\"])\n    \n            profile.addWallet(flowWallet)\n            updated=true\n        }\n        if !profile.hasWallet(\"FUSD\") {\n            profile.addWallet(Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), tags: [\"fusd\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if !profile.hasWallet(\"USDC\") {\n            profile.addWallet(Profile.Wallet( name:\"USDC\", receiver:usdcCap, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(FiatToken.VaultBalancePubPath), accept: Type\u003c@FiatToken.Vault\u003e(), tags: [\"usdc\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else if updated {\n            profile.emitUpdatedEvent()\n        }\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        let doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        let doeSalePublicPath=FindMarket.getPublicPath(doeSaleType, name: tenant.name)\n        let doeSaleStoragePath= FindMarket.getStoragePath(doeSaleType, name:tenant.name)\n        let doeSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n        if !doeSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n        }\n\n        let doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        let doeBidPublicPath=FindMarket.getPublicPath(doeBidType, name: tenant.name)\n        let doeBidStoragePath= FindMarket.getStoragePath(doeBidType, name:tenant.name)\n        let doeBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n        if !doeBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n        }\n\n        /// auctions that escrow ft\n        let aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        let aeSalePublicPath=FindMarket.getPublicPath(aeSaleType, name: tenant.name)\n        let aeSaleStoragePath= FindMarket.getStoragePath(aeSaleType, name:tenant.name)\n        let aeSaleCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n        if !aeSaleCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n        }\n\n        let dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\n        let dosSalePublicPath=FindMarket.getPublicPath(dosSaleType, name: tenant.name)\n        let dosSaleStoragePath= FindMarket.getStoragePath(dosSaleType, name:tenant.name)\n\n        let dosSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n        if !dosSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n        }\n\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n        if !dosBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n        }\n\n        let aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\n        let aeBidPublicPath=FindMarket.getPublicPath(aeBidType, name: tenant.name)\n        let aeBidStoragePath= FindMarket.getStoragePath(aeBidType, name:tenant.name)\n        let aeBidCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n        if !aeBidCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n        }\n\n     /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n        }\n\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n        if !asBidCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n        }\n\n        let leaseTenantCapability= FindMarket.getTenantCapability(FindMarket.getTenantAddress(\"findLease\")!)!\n\n        let leaseSaleItemType= Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()\n        let leasePublicPath=FindMarket.getPublicPath(leaseSaleItemType, name: \"findLease\")\n        let leaseStoragePath= FindMarket.getStoragePath(leaseSaleItemType, name:\"findLease\")\n        let leaseSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath) \n        if !leaseSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketSale.SaleItemCollection\u003e(\u003c- FindLeaseMarketSale.createEmptySaleItemCollection(leaseTenantCapability), to: leaseStoragePath)\n            account.link\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath, target: leaseStoragePath)\n        }\n\n        let leaseASSaleItemType= Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e()\n        let leaseASPublicPath=FindMarket.getPublicPath(leaseASSaleItemType, name: \"findLease\")\n        let leaseASStoragePath= FindMarket.getStoragePath(leaseASSaleItemType, name:\"findLease\")\n        let leaseASSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath) \n        if !leaseASSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseASStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath, target: leaseASStoragePath)\n        }\n\n\n        let leaseASBidType= Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e()\n        let leaseASBidPublicPath=FindMarket.getPublicPath(leaseASBidType, name: \"findLease\")\n        let leaseASBidStoragePath= FindMarket.getStoragePath(leaseASBidType, name: \"findLease\")\n        let leaseASBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath) \n        if !leaseASBidCap.check() {\n            account.save\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseASBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath, target: leaseASBidStoragePath)\n        }\n\n        // let leaseAESaleItemType= Type\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e()\n        // let leaseAEPublicPath=FindMarket.getPublicPath(leaseAESaleItemType, name: \"findLease\")\n        // let leaseAEStoragePath= FindMarket.getStoragePath(leaseAESaleItemType, name:\"findLease\")\n        // let leaseAESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath) \n        // if !leaseAESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseAEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath, target: leaseAEStoragePath)\n        // }\n\n        // let leaseAEBidType= Type\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e()\n        // let leaseAEBidPublicPath=FindMarket.getPublicPath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidStoragePath= FindMarket.getStoragePath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath) \n        // if !leaseAEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseAEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath, target: leaseAEBidStoragePath)\n        // }\n\n        let leaseDOSSaleItemType= Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e()\n        let leaseDOSPublicPath=FindMarket.getPublicPath(leaseDOSSaleItemType, name: \"findLease\")\n        let leaseDOSStoragePath= FindMarket.getStoragePath(leaseDOSSaleItemType, name:\"findLease\")\n        let leaseDOSSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath) \n        if !leaseDOSSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOSStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath, target: leaseDOSStoragePath)\n        }\n\n        let leaseDOSBidType= Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let leaseDOSBidPublicPath=FindMarket.getPublicPath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidStoragePath= FindMarket.getStoragePath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath) \n        if !leaseDOSBidCap.check() {\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOSBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath, target: leaseDOSBidStoragePath)\n        }\n\n        // let leaseDOESaleItemType= Type\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        // let leaseDOEPublicPath=FindMarket.getPublicPath(leaseDOESaleItemType, name: \"findLease\")\n        // let leaseDOEStoragePath= FindMarket.getStoragePath(leaseDOESaleItemType, name:\"findLease\")\n        // let leaseDOESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath) \n        // if !leaseDOESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath, target: leaseDOEStoragePath)\n        // }\n\n        // let leaseDOEBidType= Type\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        // let leaseDOEBidPublicPath=FindMarket.getPublicPath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidStoragePath= FindMarket.getStoragePath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath) \n        // if !leaseDOEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath, target: leaseDOEBidStoragePath)\n        // }\n        //SYNC with register\n\n        let resolveAddress = FIND.resolve(user)\n        if resolveAddress == nil {panic(\"The address input is not a valid name nor address. Input : \".concat(user))}\n        let address = resolveAddress!\n\n        self.saleItemsCap= FindMarketAuctionEscrow.getSaleItemCapability(marketplace:marketplace, user:address) ?? panic(\"cannot find sale item cap. User address : \".concat(address.toString()))\n\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e())\n        let item = FindMarket.assertOperationValid(tenant: marketplace, address: address, marketOption: marketOption, id: id)\n\n        let nftIdentifier = item.getItemType().identifier\n        let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier)) \n        let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n        let nft = collection.collectionData\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n    \n        self.targetCapability= account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(nft.publicPath)\n        /* Check for nftCapability */\n        if !self.targetCapability.check() {\n            let cd = item.getNFTCollectionData()\n            // should use account.type here instead\n            if account.type(at: cd.storagePath) != nil {\n                let pathIdentifier = nft.publicPath.toString()\n                let findPath = PublicPath(identifier: pathIdentifier.slice(from: \"/public/\".length , upTo: pathIdentifier.length).concat(\"_FIND\"))!\n                account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                    findPath,\n                    target: nft.storagePath\n                )\n                self.targetCapability = account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(findPath)\n            } else {\n                account.save(\u003c- cd.createEmptyCollection(), to: cd.storagePath)\n                account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.publicPath, target: cd.storagePath)\n                account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.providerPath, target: cd.storagePath)\n            }\n\n        }\n        \n        self.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n\n        let bidSstoragePath=tenant.getStoragePath(Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e())!\n\n        self.bidsReference= account.borrow\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection\u003e(from: bidSstoragePath)\n        self.balanceBeforeBid=self.walletReference.balance\n        self.pointer= FindViews.createViewReadPointer(address: address, path:nft.publicPath, id: item.getItemID())\n    }\n\n    pre {\n        self.bidsReference != nil : \"This account does not have a bid collection\"\n        self.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount) \n        self.bidsReference!.bid(item:self.pointer, vault: \u003c- vault, nftCap: self.targetCapability, bidExtraField: {})\n    }\n\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "user",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64",
                     "marketplace": "Address",
                     "user": "String"
                  }
               }
            },
            "bidMarketAuctionSoft": {
               "code": "import FindMarketSale from 0x097bafa4e0b48eef\nimport FindMarketAuctionEscrow from 0x097bafa4e0b48eef\nimport FindMarketAuctionSoft from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferEscrow from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferSoft from 0x097bafa4e0b48eef\nimport FungibleToken from 0xf233dcee88fe0abe\nimport NonFungibleToken from 0x1d7e57aa55817448\nimport MetadataViews from 0x1d7e57aa55817448\nimport FindViews from 0x097bafa4e0b48eef\nimport FTRegistry from 0x097bafa4e0b48eef\nimport NFTCatalog from 0x49a7cda3a1eecc29\nimport FINDNFTCatalog from 0x097bafa4e0b48eef\nimport FindMarket from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\nimport FUSD from 0x3c5959b568896393\nimport FiatToken from 0xb19436aae4d94622\nimport FlowToken from 0x1654653399040a61\nimport Dandy from 0x097bafa4e0b48eef\nimport Profile from 0x097bafa4e0b48eef\nimport FindLeaseMarketSale from 0x097bafa4e0b48eef\nimport FindLeaseMarketAuctionSoft from 0x097bafa4e0b48eef\n// import FindLeaseMarketAuctionEscrow from \"../contracts/FindLeaseMarketAuctionEscrow.cdc\"\nimport FindLeaseMarketDirectOfferSoft from 0x097bafa4e0b48eef\n// import FindLeaseMarketDirectOfferEscrow from \"../contracts/FindLeaseMarketDirectOfferEscrow.cdc\"\nimport FindLeaseMarket from 0x097bafa4e0b48eef\n\ntransaction(marketplace:Address, user: String, id: UInt64, amount: UFix64) {\n\n    let saleItemsCap: Capability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic}\u003e \n    var targetCapability : Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e\n    let walletReference : \u0026FungibleToken.Vault\n    let bidsReference: \u0026FindMarketAuctionSoft.MarketBidCollection?\n    let balanceBeforeBid: UFix64\n    let pointer: FindViews.ViewReadPointer\n    let ftVaultType: Type\n\n    prepare(account: AuthAccount) {\n\n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n        //SYNC with register\n        //Add exising FUSD or create a new one and add it\n        let name = account.address.toString()\n        let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n        if !fusdReceiver.check() {\n            let fusd \u003c- FUSD.createEmptyVault()\n            account.save(\u003c- fusd, to: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n        }\n\n        let usdcCap = account.getCapability\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e(FiatToken.VaultReceiverPubPath)\n        if !usdcCap.check() {\n                account.save( \u003c-FiatToken.createEmptyVault(), to: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e( FiatToken.VaultReceiverPubPath, target: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FiatToken.ResourceId}\u003e( FiatToken.VaultUUIDPubPath, target: FiatToken.VaultStoragePath)\n                account.link\u003c\u0026FiatToken.Vault{FungibleToken.Balance}\u003e( FiatToken.VaultBalancePubPath, target:FiatToken.VaultStoragePath)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let dandyCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        let dandyCapPrivate= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPrivatePath)\n        if !dandyCapPrivate.check() {\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        var created=false\n        var updated=false\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        if !profile.hasWallet(\"Flow\") {\n            let flowWallet=Profile.Wallet( name:\"Flow\", receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), tags: [\"flow\"])\n    \n            profile.addWallet(flowWallet)\n            updated=true\n        }\n        if !profile.hasWallet(\"FUSD\") {\n            profile.addWallet(Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), tags: [\"fusd\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if !profile.hasWallet(\"USDC\") {\n            profile.addWallet(Profile.Wallet( name:\"USDC\", receiver:usdcCap, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(FiatToken.VaultBalancePubPath), accept: Type\u003c@FiatToken.Vault\u003e(), tags: [\"usdc\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else if updated {\n            profile.emitUpdatedEvent()\n        }\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        let doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        let doeSalePublicPath=FindMarket.getPublicPath(doeSaleType, name: tenant.name)\n        let doeSaleStoragePath= FindMarket.getStoragePath(doeSaleType, name:tenant.name)\n        let doeSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n        if !doeSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n        }\n\n        let doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        let doeBidPublicPath=FindMarket.getPublicPath(doeBidType, name: tenant.name)\n        let doeBidStoragePath= FindMarket.getStoragePath(doeBidType, name:tenant.name)\n        let doeBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n        if !doeBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n        }\n\n        /// auctions that escrow ft\n        let aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        let aeSalePublicPath=FindMarket.getPublicPath(aeSaleType, name: tenant.name)\n        let aeSaleStoragePath= FindMarket.getStoragePath(aeSaleType, name:tenant.name)\n        let aeSaleCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n        if !aeSaleCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n        }\n\n        let dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\n        let dosSalePublicPath=FindMarket.getPublicPath(dosSaleType, name: tenant.name)\n        let dosSaleStoragePath= FindMarket.getStoragePath(dosSaleType, name:tenant.name)\n\n        let dosSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n        if !dosSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n        }\n\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n        if !dosBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n        }\n\n        let aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\n        let aeBidPublicPath=FindMarket.getPublicPath(aeBidType, name: tenant.name)\n        let aeBidStoragePath= FindMarket.getStoragePath(aeBidType, name:tenant.name)\n        let aeBidCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n        if !aeBidCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n        }\n\n     /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n        }\n\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n        if !asBidCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n        }\n\n        let leaseTenantCapability= FindMarket.getTenantCapability(FindMarket.getTenantAddress(\"findLease\")!)!\n\n        let leaseSaleItemType= Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()\n        let leasePublicPath=FindMarket.getPublicPath(leaseSaleItemType, name: \"findLease\")\n        let leaseStoragePath= FindMarket.getStoragePath(leaseSaleItemType, name:\"findLease\")\n        let leaseSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath) \n        if !leaseSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketSale.SaleItemCollection\u003e(\u003c- FindLeaseMarketSale.createEmptySaleItemCollection(leaseTenantCapability), to: leaseStoragePath)\n            account.link\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath, target: leaseStoragePath)\n        }\n\n        let leaseASSaleItemType= Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e()\n        let leaseASPublicPath=FindMarket.getPublicPath(leaseASSaleItemType, name: \"findLease\")\n        let leaseASStoragePath= FindMarket.getStoragePath(leaseASSaleItemType, name:\"findLease\")\n        let leaseASSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath) \n        if !leaseASSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseASStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath, target: leaseASStoragePath)\n        }\n\n\n        let leaseASBidType= Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e()\n        let leaseASBidPublicPath=FindMarket.getPublicPath(leaseASBidType, name: \"findLease\")\n        let leaseASBidStoragePath= FindMarket.getStoragePath(leaseASBidType, name: \"findLease\")\n        let leaseASBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath) \n        if !leaseASBidCap.check() {\n            account.save\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseASBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath, target: leaseASBidStoragePath)\n        }\n\n        // let leaseAESaleItemType= Type\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e()\n        // let leaseAEPublicPath=FindMarket.getPublicPath(leaseAESaleItemType, name: \"findLease\")\n        // let leaseAEStoragePath= FindMarket.getStoragePath(leaseAESaleItemType, name:\"findLease\")\n        // let leaseAESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath) \n        // if !leaseAESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseAEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath, target: leaseAEStoragePath)\n        // }\n\n        // let leaseAEBidType= Type\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e()\n        // let leaseAEBidPublicPath=FindMarket.getPublicPath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidStoragePath= FindMarket.getStoragePath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath) \n        // if !leaseAEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseAEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath, target: leaseAEBidStoragePath)\n        // }\n\n        let leaseDOSSaleItemType= Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e()\n        let leaseDOSPublicPath=FindMarket.getPublicPath(leaseDOSSaleItemType, name: \"findLease\")\n        let leaseDOSStoragePath= FindMarket.getStoragePath(leaseDOSSaleItemType, name:\"findLease\")\n        let leaseDOSSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath) \n        if !leaseDOSSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOSStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath, target: leaseDOSStoragePath)\n        }\n\n        let leaseDOSBidType= Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let leaseDOSBidPublicPath=FindMarket.getPublicPath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidStoragePath= FindMarket.getStoragePath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath) \n        if !leaseDOSBidCap.check() {\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOSBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath, target: leaseDOSBidStoragePath)\n        }\n\n        // let leaseDOESaleItemType= Type\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        // let leaseDOEPublicPath=FindMarket.getPublicPath(leaseDOESaleItemType, name: \"findLease\")\n        // let leaseDOEStoragePath= FindMarket.getStoragePath(leaseDOESaleItemType, name:\"findLease\")\n        // let leaseDOESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath) \n        // if !leaseDOESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath, target: leaseDOEStoragePath)\n        // }\n\n        // let leaseDOEBidType= Type\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        // let leaseDOEBidPublicPath=FindMarket.getPublicPath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidStoragePath= FindMarket.getStoragePath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath) \n        // if !leaseDOEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath, target: leaseDOEBidStoragePath)\n        // }\n        //SYNC with register\n\n        let resolveAddress = FIND.resolve(user)\n        if resolveAddress == nil {panic(\"The address input is not a valid name nor address. Input : \".concat(user))}\n        let address = resolveAddress!\n\n        self.saleItemsCap= FindMarketAuctionSoft.getSaleItemCapability(marketplace:marketplace, user:address) ?? panic(\"cannot find sale item cap\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e())\n\n        let item = FindMarket.assertOperationValid(tenant: marketplace, address: address, marketOption: marketOption, id: id)\n\n        let nftIdentifier = item.getItemType().identifier\n        let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier)) \n        let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n        let nft = collection.collectionData\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n    \n        self.targetCapability= account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(nft.publicPath)\n        /* Check for nftCapability */\n        if !self.targetCapability.check() {\n            let cd = item.getNFTCollectionData()\n            // should use account.type here instead\n            if account.type(at: cd.storagePath) != nil {\n                let pathIdentifier = nft.publicPath.toString()\n                let findPath = PublicPath(identifier: pathIdentifier.slice(from: \"/public/\".length , upTo: pathIdentifier.length).concat(\"_FIND\"))!\n                account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                    findPath,\n                    target: nft.storagePath\n                )\n                self.targetCapability = account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(findPath)\n            } else {\n                account.save(\u003c- cd.createEmptyCollection(), to: cd.storagePath)\n                account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.publicPath, target: cd.storagePath)\n                account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.providerPath, target: cd.storagePath)\n            }\n\n        }\n        \n        self.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account. Account address : \".concat(account.address.toString()))\n        self.ftVaultType = ft.type\n\n        let bidStoragePath=tenant.getStoragePath(Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e())\n\n        self.bidsReference= account.borrow\u003c\u0026FindMarketAuctionSoft.MarketBidCollection\u003e(from: bidStoragePath)\n        self.balanceBeforeBid=self.walletReference.balance\n        self.pointer= FindViews.createViewReadPointer(address: address, path:nft.publicPath, id: item.getItemID())\n    }\n\n    pre {\n        self.bidsReference != nil : \"This account does not have a bid collection\"\n        self.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n    }\n\n    execute {\n        self.bidsReference!.bid(item:self.pointer, amount: amount, vaultType: self.ftVaultType, nftCap: self.targetCapability, bidExtraField: {})\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "user",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64",
                     "marketplace": "Address",
                     "user": "String"
                  }
               }
            },
            "bidMarketAuctionSoftDUC": {
               "code": "import FindMarketSale from 0x097bafa4e0b48eef\nimport FindMarketAuctionEscrow from 0x097bafa4e0b48eef\nimport FindMarketAuctionSoft from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferEscrow from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferSoft from 0x097bafa4e0b48eef\nimport FungibleToken from 0xf233dcee88fe0abe\nimport NonFungibleToken from 0x1d7e57aa55817448\nimport MetadataViews from 0x1d7e57aa55817448\nimport FindViews from 0x097bafa4e0b48eef\nimport FTRegistry from 0x097bafa4e0b48eef\nimport NFTCatalog from 0x49a7cda3a1eecc29\nimport FINDNFTCatalog from 0x097bafa4e0b48eef\nimport FindMarket from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\nimport TokenForwarding from 0xe544175ee0461c4b\nimport DapperUtilityCoin from 0xead892083b3e2c6c\nimport FlowToken from 0x1654653399040a61\nimport Dandy from 0x097bafa4e0b48eef\nimport Profile from 0x097bafa4e0b48eef\nimport FindLeaseMarketSale from 0x097bafa4e0b48eef\nimport FindLeaseMarketAuctionSoft from 0x097bafa4e0b48eef\n// import FindLeaseMarketAuctionEscrow from \"../contracts/FindLeaseMarketAuctionEscrow.cdc\"\nimport FindLeaseMarketDirectOfferSoft from 0x097bafa4e0b48eef\n// import FindLeaseMarketDirectOfferEscrow from \"../contracts/FindLeaseMarketDirectOfferEscrow.cdc\"\nimport FindLeaseMarket from 0x097bafa4e0b48eef\n\ntransaction(dapperAddress: Address, marketplace:Address, user: String, id: UInt64, amount: UFix64) {\n\n    let saleItemsCap: Capability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic}\u003e \n    var targetCapability : Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e\n    let bidsReference: \u0026FindMarketAuctionSoft.MarketBidCollection?\n    let pointer: FindViews.ViewReadPointer\n    let ftVaultType: Type\n\n    prepare(account: AuthAccount) {\n\n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n        //SYNC with register\n        //Add exising FUSD or create a new one and add it\n        let name = account.address.toString()\n        let ducReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver)\n        if !ducReceiver.check() {\n            let dapper = getAccount(dapperAddress)\n            // Create a new Forwarder resource for DUC and store it in the new account's storage\n            let ducForwarder \u003c- TokenForwarding.createNewForwarder(recipient: dapper.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver))\n            account.save(\u003c-ducForwarder, to: /storage/dapperUtilityCoinReceiver)\n            // Publish a Receiver capability for the new account, which is linked to the DUC Forwarder\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver,target: /storage/dapperUtilityCoinReceiver)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: ducReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let dandyCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        let dandyCapPrivate= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPrivatePath)\n        if !dandyCapPrivate.check() {\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        var created=false\n        var updated=false\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        if !profile.hasWallet(\"Flow\") {\n            let flowWallet=Profile.Wallet( name:\"Flow\", receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), tags: [\"flow\"])\n    \n            profile.addWallet(flowWallet)\n            updated=true\n        }\n        if !profile.hasWallet(\"DUC\") {\n            profile.addWallet(Profile.Wallet( name:\"DUC\", receiver:ducReceiver, balance:getAccount(dapperAddress).getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/dapperUtilityCoinBalance), accept: Type\u003c@DapperUtilityCoin.Vault\u003e(), tags: [\"duc\", \"dapperUtilityCoin\",\"dapper\"]))\n            updated=true\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else {\n            profile.emitUpdatedEvent()\n        }\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        let doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        let doeSalePublicPath=FindMarket.getPublicPath(doeSaleType, name: tenant.name)\n        let doeSaleStoragePath= FindMarket.getStoragePath(doeSaleType, name:tenant.name)\n        let doeSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n        if !doeSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n        }\n\n        let doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        let doeBidPublicPath=FindMarket.getPublicPath(doeBidType, name: tenant.name)\n        let doeBidStoragePath= FindMarket.getStoragePath(doeBidType, name:tenant.name)\n        let doeBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n        if !doeBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n        }\n\n        /// auctions that escrow ft\n        let aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        let aeSalePublicPath=FindMarket.getPublicPath(aeSaleType, name: tenant.name)\n        let aeSaleStoragePath= FindMarket.getStoragePath(aeSaleType, name:tenant.name)\n        let aeSaleCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n        if !aeSaleCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n        }\n\n        let dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\n        let dosSalePublicPath=FindMarket.getPublicPath(dosSaleType, name: tenant.name)\n        let dosSaleStoragePath= FindMarket.getStoragePath(dosSaleType, name:tenant.name)\n\n        let dosSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n        if !dosSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n        }\n\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n        if !dosBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n        }\n\n        let aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\n        let aeBidPublicPath=FindMarket.getPublicPath(aeBidType, name: tenant.name)\n        let aeBidStoragePath= FindMarket.getStoragePath(aeBidType, name:tenant.name)\n        let aeBidCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n        if !aeBidCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n        }\n\n     /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n        }\n\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n        if !asBidCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n        }\n\n        let leaseTenantCapability= FindMarket.getTenantCapability(FindMarket.getTenantAddress(\"findLease\")!)!\n\n        let leaseSaleItemType= Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()\n        let leasePublicPath=FindMarket.getPublicPath(leaseSaleItemType, name: \"findLease\")\n        let leaseStoragePath= FindMarket.getStoragePath(leaseSaleItemType, name:\"findLease\")\n        let leaseSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath) \n        if !leaseSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketSale.SaleItemCollection\u003e(\u003c- FindLeaseMarketSale.createEmptySaleItemCollection(leaseTenantCapability), to: leaseStoragePath)\n            account.link\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath, target: leaseStoragePath)\n        }\n\n        let leaseASSaleItemType= Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e()\n        let leaseASPublicPath=FindMarket.getPublicPath(leaseASSaleItemType, name: \"findLease\")\n        let leaseASStoragePath= FindMarket.getStoragePath(leaseASSaleItemType, name:\"findLease\")\n        let leaseASSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath) \n        if !leaseASSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseASStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath, target: leaseASStoragePath)\n        }\n\n\n        let leaseASBidType= Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e()\n        let leaseASBidPublicPath=FindMarket.getPublicPath(leaseASBidType, name: \"findLease\")\n        let leaseASBidStoragePath= FindMarket.getStoragePath(leaseASBidType, name: \"findLease\")\n        let leaseASBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath) \n        if !leaseASBidCap.check() {\n            account.save\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseASBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath, target: leaseASBidStoragePath)\n        }\n\n        // let leaseAESaleItemType= Type\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e()\n        // let leaseAEPublicPath=FindMarket.getPublicPath(leaseAESaleItemType, name: \"findLease\")\n        // let leaseAEStoragePath= FindMarket.getStoragePath(leaseAESaleItemType, name:\"findLease\")\n        // let leaseAESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath) \n        // if !leaseAESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseAEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath, target: leaseAEStoragePath)\n        // }\n\n        // let leaseAEBidType= Type\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e()\n        // let leaseAEBidPublicPath=FindMarket.getPublicPath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidStoragePath= FindMarket.getStoragePath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath) \n        // if !leaseAEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseAEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath, target: leaseAEBidStoragePath)\n        // }\n\n        let leaseDOSSaleItemType= Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e()\n        let leaseDOSPublicPath=FindMarket.getPublicPath(leaseDOSSaleItemType, name: \"findLease\")\n        let leaseDOSStoragePath= FindMarket.getStoragePath(leaseDOSSaleItemType, name:\"findLease\")\n        let leaseDOSSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath) \n        if !leaseDOSSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOSStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath, target: leaseDOSStoragePath)\n        }\n\n        let leaseDOSBidType= Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let leaseDOSBidPublicPath=FindMarket.getPublicPath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidStoragePath= FindMarket.getStoragePath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath) \n        if !leaseDOSBidCap.check() {\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOSBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath, target: leaseDOSBidStoragePath)\n        }\n\n        // let leaseDOESaleItemType= Type\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        // let leaseDOEPublicPath=FindMarket.getPublicPath(leaseDOESaleItemType, name: \"findLease\")\n        // let leaseDOEStoragePath= FindMarket.getStoragePath(leaseDOESaleItemType, name:\"findLease\")\n        // let leaseDOESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath) \n        // if !leaseDOESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath, target: leaseDOEStoragePath)\n        // }\n\n        // let leaseDOEBidType= Type\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        // let leaseDOEBidPublicPath=FindMarket.getPublicPath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidStoragePath= FindMarket.getStoragePath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath) \n        // if !leaseDOEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath, target: leaseDOEBidStoragePath)\n        // }\n        //SYNC with register\n\n        let resolveAddress = FIND.resolve(user)\n        if resolveAddress == nil {panic(\"The address input is not a valid name nor address. Input : \".concat(user))}\n        let address = resolveAddress!\n\n        self.saleItemsCap= FindMarketAuctionSoft.getSaleItemCapability(marketplace:marketplace, user:address) ?? panic(\"cannot find sale item cap\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e())\n\n        let item = FindMarket.assertOperationValid(tenant: marketplace, address: address, marketOption: marketOption, id: id)\n\n        let nftIdentifier = item.getItemType().identifier\n        let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier)) \n        let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n        let nft = collection.collectionData\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n    \n        self.targetCapability= account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(nft.publicPath)\n        /* Check for nftCapability */\n        if !self.targetCapability.check() {\n            let cd = item.getNFTCollectionData()\n            // should use account.type here instead\n            if account.type(at: cd.storagePath) != nil {\n                let pathIdentifier = nft.publicPath.toString()\n                let findPath = PublicPath(identifier: pathIdentifier.slice(from: \"/public/\".length , upTo: pathIdentifier.length).concat(\"_FIND\"))!\n                account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                    findPath,\n                    target: nft.storagePath\n                )\n                self.targetCapability = account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(findPath)\n            } else {\n                account.save(\u003c- cd.createEmptyCollection(), to: cd.storagePath)\n                account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.publicPath, target: cd.storagePath)\n                account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.providerPath, target: cd.storagePath)\n            }\n\n        }\n        \n        self.ftVaultType = ft.type\n\n        let bidStoragePath=tenant.getStoragePath(Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e())\n\n        self.bidsReference= account.borrow\u003c\u0026FindMarketAuctionSoft.MarketBidCollection\u003e(from: bidStoragePath)\n        self.pointer= FindViews.createViewReadPointer(address: address, path:nft.publicPath, id: item.getItemID())\n    }\n\n    pre {\n        self.bidsReference != nil : \"This account does not have a bid collection\"\n    }\n\n    execute {\n        self.bidsReference!.bid(item:self.pointer, amount: amount, vaultType: self.ftVaultType, nftCap: self.targetCapability, bidExtraField: {})\n    }\n}",
               "spec": {
                  "order": [
                     "dapperAddress",
                     "marketplace",
                     "user",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "dapperAddress": "Address",
                     "id": "UInt64",
                     "marketplace": "Address",
                     "user": "String"
                  }
               }
            },
            "bidMarketDirectOfferEscrowed": {
               "code": "import FindMarket from 0x097bafa4e0b48eef\nimport FindMarketSale from 0x097bafa4e0b48eef\nimport FindMarketAuctionEscrow from 0x097bafa4e0b48eef\nimport FindMarketAuctionSoft from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferEscrow from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferSoft from 0x097bafa4e0b48eef\nimport FungibleToken from 0xf233dcee88fe0abe\nimport NonFungibleToken from 0x1d7e57aa55817448\nimport MetadataViews from 0x1d7e57aa55817448\nimport FindViews from 0x097bafa4e0b48eef\nimport FTRegistry from 0x097bafa4e0b48eef\nimport NFTCatalog from 0x49a7cda3a1eecc29\nimport FINDNFTCatalog from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\nimport FUSD from 0x3c5959b568896393\nimport FiatToken from 0xb19436aae4d94622\nimport FlowToken from 0x1654653399040a61\nimport Dandy from 0x097bafa4e0b48eef\nimport Profile from 0x097bafa4e0b48eef\nimport FindLeaseMarketSale from 0x097bafa4e0b48eef\nimport FindLeaseMarketAuctionSoft from 0x097bafa4e0b48eef\n// import FindLeaseMarketAuctionEscrow from \"../contracts/FindLeaseMarketAuctionEscrow.cdc\"\nimport FindLeaseMarketDirectOfferSoft from 0x097bafa4e0b48eef\n// import FindLeaseMarketDirectOfferEscrow from \"../contracts/FindLeaseMarketDirectOfferEscrow.cdc\"\nimport FindLeaseMarket from 0x097bafa4e0b48eef\n\ntransaction(marketplace:Address, user: String, nftAliasOrIdentifier: String, id: UInt64, ftAliasOrIdentifier:String, amount: UFix64, validUntil: UFix64?) {\n\n    var targetCapability : Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e\n    let walletReference : \u0026FungibleToken.Vault\n    let bidsReference: \u0026FindMarketDirectOfferEscrow.MarketBidCollection?\n    let pointer: FindViews.ViewReadPointer\n\n    prepare(account: AuthAccount) {\n\n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n        //SYNC with register\n        //Add exising FUSD or create a new one and add it\n        let name = account.address.toString()\n        let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n        if !fusdReceiver.check() {\n            let fusd \u003c- FUSD.createEmptyVault()\n            account.save(\u003c- fusd, to: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n        }\n\n        let usdcCap = account.getCapability\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e(FiatToken.VaultReceiverPubPath)\n        if !usdcCap.check() {\n                account.save( \u003c-FiatToken.createEmptyVault(), to: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e( FiatToken.VaultReceiverPubPath, target: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FiatToken.ResourceId}\u003e( FiatToken.VaultUUIDPubPath, target: FiatToken.VaultStoragePath)\n                account.link\u003c\u0026FiatToken.Vault{FungibleToken.Balance}\u003e( FiatToken.VaultBalancePubPath, target:FiatToken.VaultStoragePath)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let dandyCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        let dandyCapPrivate= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPrivatePath)\n        if !dandyCapPrivate.check() {\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        var created=false\n        var updated=false\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        if !profile.hasWallet(\"Flow\") {\n            let flowWallet=Profile.Wallet( name:\"Flow\", receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), tags: [\"flow\"])\n    \n            profile.addWallet(flowWallet)\n            updated=true\n        }\n        if !profile.hasWallet(\"FUSD\") {\n            profile.addWallet(Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), tags: [\"fusd\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if !profile.hasWallet(\"USDC\") {\n            profile.addWallet(Profile.Wallet( name:\"USDC\", receiver:usdcCap, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(FiatToken.VaultBalancePubPath), accept: Type\u003c@FiatToken.Vault\u003e(), tags: [\"usdc\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else if updated {\n            profile.emitUpdatedEvent()\n        }\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        let doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        let doeSalePublicPath=FindMarket.getPublicPath(doeSaleType, name: tenant.name)\n        let doeSaleStoragePath= FindMarket.getStoragePath(doeSaleType, name:tenant.name)\n        let doeSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n        if !doeSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n        }\n\n        let doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        let doeBidPublicPath=FindMarket.getPublicPath(doeBidType, name: tenant.name)\n        let doeBidStoragePath= FindMarket.getStoragePath(doeBidType, name:tenant.name)\n        let doeBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n        if !doeBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n        }\n\n        /// auctions that escrow ft\n        let aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        let aeSalePublicPath=FindMarket.getPublicPath(aeSaleType, name: tenant.name)\n        let aeSaleStoragePath= FindMarket.getStoragePath(aeSaleType, name:tenant.name)\n        let aeSaleCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n        if !aeSaleCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n        }\n\n        let dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\n        let dosSalePublicPath=FindMarket.getPublicPath(dosSaleType, name: tenant.name)\n        let dosSaleStoragePath= FindMarket.getStoragePath(dosSaleType, name:tenant.name)\n\n        let dosSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n        if !dosSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n        }\n\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n        if !dosBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n        }\n\n        let aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\n        let aeBidPublicPath=FindMarket.getPublicPath(aeBidType, name: tenant.name)\n        let aeBidStoragePath= FindMarket.getStoragePath(aeBidType, name:tenant.name)\n        let aeBidCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n        if !aeBidCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n        }\n\n     /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n        }\n\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n        if !asBidCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n        }\n\n        let leaseTenantCapability= FindMarket.getTenantCapability(FindMarket.getTenantAddress(\"findLease\")!)!\n\n        let leaseSaleItemType= Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()\n        let leasePublicPath=FindMarket.getPublicPath(leaseSaleItemType, name: \"findLease\")\n        let leaseStoragePath= FindMarket.getStoragePath(leaseSaleItemType, name:\"findLease\")\n        let leaseSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath) \n        if !leaseSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketSale.SaleItemCollection\u003e(\u003c- FindLeaseMarketSale.createEmptySaleItemCollection(leaseTenantCapability), to: leaseStoragePath)\n            account.link\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath, target: leaseStoragePath)\n        }\n\n        let leaseASSaleItemType= Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e()\n        let leaseASPublicPath=FindMarket.getPublicPath(leaseASSaleItemType, name: \"findLease\")\n        let leaseASStoragePath= FindMarket.getStoragePath(leaseASSaleItemType, name:\"findLease\")\n        let leaseASSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath) \n        if !leaseASSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseASStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath, target: leaseASStoragePath)\n        }\n\n\n        let leaseASBidType= Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e()\n        let leaseASBidPublicPath=FindMarket.getPublicPath(leaseASBidType, name: \"findLease\")\n        let leaseASBidStoragePath= FindMarket.getStoragePath(leaseASBidType, name: \"findLease\")\n        let leaseASBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath) \n        if !leaseASBidCap.check() {\n            account.save\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseASBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath, target: leaseASBidStoragePath)\n        }\n\n        // let leaseAESaleItemType= Type\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e()\n        // let leaseAEPublicPath=FindMarket.getPublicPath(leaseAESaleItemType, name: \"findLease\")\n        // let leaseAEStoragePath= FindMarket.getStoragePath(leaseAESaleItemType, name:\"findLease\")\n        // let leaseAESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath) \n        // if !leaseAESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseAEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath, target: leaseAEStoragePath)\n        // }\n\n        // let leaseAEBidType= Type\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e()\n        // let leaseAEBidPublicPath=FindMarket.getPublicPath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidStoragePath= FindMarket.getStoragePath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath) \n        // if !leaseAEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseAEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath, target: leaseAEBidStoragePath)\n        // }\n\n        let leaseDOSSaleItemType= Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e()\n        let leaseDOSPublicPath=FindMarket.getPublicPath(leaseDOSSaleItemType, name: \"findLease\")\n        let leaseDOSStoragePath= FindMarket.getStoragePath(leaseDOSSaleItemType, name:\"findLease\")\n        let leaseDOSSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath) \n        if !leaseDOSSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOSStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath, target: leaseDOSStoragePath)\n        }\n\n        let leaseDOSBidType= Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let leaseDOSBidPublicPath=FindMarket.getPublicPath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidStoragePath= FindMarket.getStoragePath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath) \n        if !leaseDOSBidCap.check() {\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOSBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath, target: leaseDOSBidStoragePath)\n        }\n\n        // let leaseDOESaleItemType= Type\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        // let leaseDOEPublicPath=FindMarket.getPublicPath(leaseDOESaleItemType, name: \"findLease\")\n        // let leaseDOEStoragePath= FindMarket.getStoragePath(leaseDOESaleItemType, name:\"findLease\")\n        // let leaseDOESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath) \n        // if !leaseDOESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath, target: leaseDOEStoragePath)\n        // }\n\n        // let leaseDOEBidType= Type\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        // let leaseDOEBidPublicPath=FindMarket.getPublicPath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidStoragePath= FindMarket.getStoragePath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath) \n        // if !leaseDOEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath, target: leaseDOEBidStoragePath)\n        // }\n        //SYNC with register\n\n        let resolveAddress = FIND.resolve(user)\n        if resolveAddress == nil {panic(\"The address input is not a valid name nor address. Input : \".concat(user))}\n        let address = resolveAddress!\n\n        let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftAliasOrIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftAliasOrIdentifier)) \n        let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n        let nft = collection.collectionData\n\n        let ft = FTRegistry.getFTInfo(ftAliasOrIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftAliasOrIdentifier))\n        \n        self.targetCapability= account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(nft.publicPath)\n        self.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n\n        let bidStoragePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e())!\n\n        self.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection\u003e(from: bidStoragePath)\n        self.pointer= FindViews.createViewReadPointer(address: address, path:nft.publicPath, id: id)\n\n        /* Check for nftCapability */\n        if !self.targetCapability.check() {\n            let cd = self.pointer.getNFTCollectionData()\n            // should use account.type here instead\n            if account.type(at: cd.storagePath) != nil {\n                let pathIdentifier = nft.publicPath.toString()\n                let findPath = PublicPath(identifier: pathIdentifier.slice(from: \"/public/\".length , upTo: pathIdentifier.length).concat(\"_FIND\"))!\n                account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                    findPath,\n                    target: nft.storagePath\n                )\n                self.targetCapability = account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(findPath)\n            } else {\n                account.save(\u003c- cd.createEmptyCollection(), to: cd.storagePath)\n                account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.publicPath, target: cd.storagePath)\n                account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.providerPath, target: cd.storagePath)\n            }\n\n        }\n    }\n\n    pre {\n        self.bidsReference != nil : \"This account does not have a bid collection\"\n        self.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount) \n        self.bidsReference!.bid(item:self.pointer, vault: \u003c- vault, nftCap: self.targetCapability, validUntil: validUntil, saleItemExtraField: {}, bidExtraField: {})\n    }\n\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "user",
                     "nftAliasOrIdentifier",
                     "id",
                     "ftAliasOrIdentifier",
                     "amount",
                     "validUntil"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "ftAliasOrIdentifier": "String",
                     "id": "UInt64",
                     "marketplace": "Address",
                     "nftAliasOrIdentifier": "String",
                     "user": "String",
                     "validUntil": "UFix64?"
                  }
               }
            },
            "bidMarketDirectOfferSoft": {
               "code": "import FindMarketSale from 0x097bafa4e0b48eef\nimport FindMarketAuctionEscrow from 0x097bafa4e0b48eef\nimport FindMarketAuctionSoft from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferEscrow from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferSoft from 0x097bafa4e0b48eef\nimport FindMarket from 0x097bafa4e0b48eef\nimport FungibleToken from 0xf233dcee88fe0abe\nimport NonFungibleToken from 0x1d7e57aa55817448\nimport MetadataViews from 0x1d7e57aa55817448\nimport FindViews from 0x097bafa4e0b48eef\nimport FTRegistry from 0x097bafa4e0b48eef\nimport NFTCatalog from 0x49a7cda3a1eecc29\nimport FINDNFTCatalog from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\nimport FUSD from 0x3c5959b568896393\nimport FiatToken from 0xb19436aae4d94622\nimport FlowToken from 0x1654653399040a61\nimport Dandy from 0x097bafa4e0b48eef\nimport Profile from 0x097bafa4e0b48eef\nimport FindLeaseMarketSale from 0x097bafa4e0b48eef\nimport FindLeaseMarketAuctionSoft from 0x097bafa4e0b48eef\n// import FindLeaseMarketAuctionEscrow from \"../contracts/FindLeaseMarketAuctionEscrow.cdc\"\nimport FindLeaseMarketDirectOfferSoft from 0x097bafa4e0b48eef\n// import FindLeaseMarketDirectOfferEscrow from \"../contracts/FindLeaseMarketDirectOfferEscrow.cdc\"\nimport FindLeaseMarket from 0x097bafa4e0b48eef\n\ntransaction(marketplace:Address, user: String, nftAliasOrIdentifier: String, id: UInt64, ftAliasOrIdentifier:String, amount: UFix64, validUntil: UFix64?) {\n\n    var targetCapability : Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e\n    let walletReference : \u0026FungibleToken.Vault\n    let bidsReference: \u0026FindMarketDirectOfferSoft.MarketBidCollection?\n    let balanceBeforeBid: UFix64\n    let pointer: FindViews.ViewReadPointer\n    let ftVaultType: Type\n\n    prepare(account: AuthAccount) {\n        \n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n        //SYNC with register\n        //Add exising FUSD or create a new one and add it\n        let name = account.address.toString()\n        let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n        if !fusdReceiver.check() {\n            let fusd \u003c- FUSD.createEmptyVault()\n            account.save(\u003c- fusd, to: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n        }\n\n        let usdcCap = account.getCapability\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e(FiatToken.VaultReceiverPubPath)\n        if !usdcCap.check() {\n                account.save( \u003c-FiatToken.createEmptyVault(), to: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e( FiatToken.VaultReceiverPubPath, target: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FiatToken.ResourceId}\u003e( FiatToken.VaultUUIDPubPath, target: FiatToken.VaultStoragePath)\n                account.link\u003c\u0026FiatToken.Vault{FungibleToken.Balance}\u003e( FiatToken.VaultBalancePubPath, target:FiatToken.VaultStoragePath)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let dandyCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        let dandyCapPrivate= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPrivatePath)\n        if !dandyCapPrivate.check() {\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        var created=false\n        var updated=false\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        if !profile.hasWallet(\"Flow\") {\n            let flowWallet=Profile.Wallet( name:\"Flow\", receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), tags: [\"flow\"])\n    \n            profile.addWallet(flowWallet)\n            updated=true\n        }\n        if !profile.hasWallet(\"FUSD\") {\n            profile.addWallet(Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), tags: [\"fusd\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if !profile.hasWallet(\"USDC\") {\n            profile.addWallet(Profile.Wallet( name:\"USDC\", receiver:usdcCap, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(FiatToken.VaultBalancePubPath), accept: Type\u003c@FiatToken.Vault\u003e(), tags: [\"usdc\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else if updated {\n            profile.emitUpdatedEvent()\n        }\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        let doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        let doeSalePublicPath=FindMarket.getPublicPath(doeSaleType, name: tenant.name)\n        let doeSaleStoragePath= FindMarket.getStoragePath(doeSaleType, name:tenant.name)\n        let doeSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n        if !doeSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n        }\n\n        let doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        let doeBidPublicPath=FindMarket.getPublicPath(doeBidType, name: tenant.name)\n        let doeBidStoragePath= FindMarket.getStoragePath(doeBidType, name:tenant.name)\n        let doeBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n        if !doeBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n        }\n\n        /// auctions that escrow ft\n        let aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        let aeSalePublicPath=FindMarket.getPublicPath(aeSaleType, name: tenant.name)\n        let aeSaleStoragePath= FindMarket.getStoragePath(aeSaleType, name:tenant.name)\n        let aeSaleCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n        if !aeSaleCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n        }\n\n        let dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\n        let dosSalePublicPath=FindMarket.getPublicPath(dosSaleType, name: tenant.name)\n        let dosSaleStoragePath= FindMarket.getStoragePath(dosSaleType, name:tenant.name)\n\n        let dosSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n        if !dosSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n        }\n\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n        if !dosBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n        }\n\n        let aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\n        let aeBidPublicPath=FindMarket.getPublicPath(aeBidType, name: tenant.name)\n        let aeBidStoragePath= FindMarket.getStoragePath(aeBidType, name:tenant.name)\n        let aeBidCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n        if !aeBidCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n        }\n\n     /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n        }\n\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n        if !asBidCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n        }\n\n        let leaseTenantCapability= FindMarket.getTenantCapability(FindMarket.getTenantAddress(\"findLease\")!)!\n\n        let leaseSaleItemType= Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()\n        let leasePublicPath=FindMarket.getPublicPath(leaseSaleItemType, name: \"findLease\")\n        let leaseStoragePath= FindMarket.getStoragePath(leaseSaleItemType, name:\"findLease\")\n        let leaseSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath) \n        if !leaseSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketSale.SaleItemCollection\u003e(\u003c- FindLeaseMarketSale.createEmptySaleItemCollection(leaseTenantCapability), to: leaseStoragePath)\n            account.link\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath, target: leaseStoragePath)\n        }\n\n        let leaseASSaleItemType= Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e()\n        let leaseASPublicPath=FindMarket.getPublicPath(leaseASSaleItemType, name: \"findLease\")\n        let leaseASStoragePath= FindMarket.getStoragePath(leaseASSaleItemType, name:\"findLease\")\n        let leaseASSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath) \n        if !leaseASSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseASStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath, target: leaseASStoragePath)\n        }\n\n\n        let leaseASBidType= Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e()\n        let leaseASBidPublicPath=FindMarket.getPublicPath(leaseASBidType, name: \"findLease\")\n        let leaseASBidStoragePath= FindMarket.getStoragePath(leaseASBidType, name: \"findLease\")\n        let leaseASBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath) \n        if !leaseASBidCap.check() {\n            account.save\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseASBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath, target: leaseASBidStoragePath)\n        }\n\n        // let leaseAESaleItemType= Type\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e()\n        // let leaseAEPublicPath=FindMarket.getPublicPath(leaseAESaleItemType, name: \"findLease\")\n        // let leaseAEStoragePath= FindMarket.getStoragePath(leaseAESaleItemType, name:\"findLease\")\n        // let leaseAESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath) \n        // if !leaseAESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseAEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath, target: leaseAEStoragePath)\n        // }\n\n        // let leaseAEBidType= Type\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e()\n        // let leaseAEBidPublicPath=FindMarket.getPublicPath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidStoragePath= FindMarket.getStoragePath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath) \n        // if !leaseAEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseAEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath, target: leaseAEBidStoragePath)\n        // }\n\n        let leaseDOSSaleItemType= Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e()\n        let leaseDOSPublicPath=FindMarket.getPublicPath(leaseDOSSaleItemType, name: \"findLease\")\n        let leaseDOSStoragePath= FindMarket.getStoragePath(leaseDOSSaleItemType, name:\"findLease\")\n        let leaseDOSSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath) \n        if !leaseDOSSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOSStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath, target: leaseDOSStoragePath)\n        }\n\n        let leaseDOSBidType= Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let leaseDOSBidPublicPath=FindMarket.getPublicPath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidStoragePath= FindMarket.getStoragePath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath) \n        if !leaseDOSBidCap.check() {\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOSBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath, target: leaseDOSBidStoragePath)\n        }\n\n        // let leaseDOESaleItemType= Type\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        // let leaseDOEPublicPath=FindMarket.getPublicPath(leaseDOESaleItemType, name: \"findLease\")\n        // let leaseDOEStoragePath= FindMarket.getStoragePath(leaseDOESaleItemType, name:\"findLease\")\n        // let leaseDOESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath) \n        // if !leaseDOESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath, target: leaseDOEStoragePath)\n        // }\n\n        // let leaseDOEBidType= Type\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        // let leaseDOEBidPublicPath=FindMarket.getPublicPath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidStoragePath= FindMarket.getStoragePath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath) \n        // if !leaseDOEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath, target: leaseDOEBidStoragePath)\n        // }\n        //SYNC with register\n\n        let resolveAddress = FIND.resolve(user)\n        if resolveAddress == nil {panic(\"The address input is not a valid name nor address. Input : \".concat(user))}\n        let address = resolveAddress!\n\n        let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftAliasOrIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftAliasOrIdentifier)) \n        let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n        let nft = collection.collectionData\n\n        let ft = FTRegistry.getFTInfo(ftAliasOrIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftAliasOrIdentifier))\n\n        self.ftVaultType = ft.type\n\n        self.targetCapability= account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(nft.publicPath)\n        self.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n\n        let bidStoragePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())!\n        self.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection\u003e(from: bidStoragePath)\n        self.balanceBeforeBid=self.walletReference.balance\n        self.pointer= FindViews.createViewReadPointer(address: address, path:nft.publicPath, id: id)\n\n        /* Check for nftCapability */\n        if !self.targetCapability.check() {\n            let cd = self.pointer.getNFTCollectionData()\n            // should use account.type here instead\n            if account.type(at: cd.storagePath) != nil {\n                let pathIdentifier = nft.publicPath.toString()\n                let findPath = PublicPath(identifier: pathIdentifier.slice(from: \"/public/\".length , upTo: pathIdentifier.length).concat(\"_FIND\"))!\n                account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                    findPath,\n                    target: nft.storagePath\n                )\n                self.targetCapability = account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(findPath)\n            } else {\n                account.save(\u003c- cd.createEmptyCollection(), to: cd.storagePath)\n                account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.publicPath, target: cd.storagePath)\n                account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.providerPath, target: cd.storagePath)\n            }\n\n        }\n    }\n\n    pre {\n        self.bidsReference != nil : \"This account does not have a bid collection\"\n        self.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n    }\n\n    execute {\n        self.bidsReference!.bid(item:self.pointer, amount: amount, vaultType: self.ftVaultType, nftCap: self.targetCapability, validUntil: validUntil, saleItemExtraField: {}, bidExtraField: {})\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "user",
                     "nftAliasOrIdentifier",
                     "id",
                     "ftAliasOrIdentifier",
                     "amount",
                     "validUntil"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "ftAliasOrIdentifier": "String",
                     "id": "UInt64",
                     "marketplace": "Address",
                     "nftAliasOrIdentifier": "String",
                     "user": "String",
                     "validUntil": "UFix64?"
                  }
               }
            },
            "bidMarketDirectOfferSoftDUC": {
               "code": "import FindMarketSale from 0x097bafa4e0b48eef\nimport FindMarketAuctionEscrow from 0x097bafa4e0b48eef\nimport FindMarketAuctionSoft from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferEscrow from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferSoft from 0x097bafa4e0b48eef\nimport FindMarket from 0x097bafa4e0b48eef\nimport FungibleToken from 0xf233dcee88fe0abe\nimport NonFungibleToken from 0x1d7e57aa55817448\nimport MetadataViews from 0x1d7e57aa55817448\nimport FindViews from 0x097bafa4e0b48eef\nimport NFTCatalog from 0x49a7cda3a1eecc29\nimport FINDNFTCatalog from 0x097bafa4e0b48eef\nimport FTRegistry from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\nimport FlowToken from 0x1654653399040a61\nimport TokenForwarding from 0xe544175ee0461c4b\nimport DapperUtilityCoin from 0xead892083b3e2c6c\nimport Dandy from 0x097bafa4e0b48eef\nimport Profile from 0x097bafa4e0b48eef\nimport FindLeaseMarketSale from 0x097bafa4e0b48eef\nimport FindLeaseMarketAuctionSoft from 0x097bafa4e0b48eef\n// import FindLeaseMarketAuctionEscrow from \"../contracts/FindLeaseMarketAuctionEscrow.cdc\"\nimport FindLeaseMarketDirectOfferSoft from 0x097bafa4e0b48eef\n// import FindLeaseMarketDirectOfferEscrow from \"../contracts/FindLeaseMarketDirectOfferEscrow.cdc\"\nimport FindLeaseMarket from 0x097bafa4e0b48eef\n\ntransaction(dapperAddress: Address, marketplace:Address, user: String, nftAliasOrIdentifier: String, id: UInt64, amount: UFix64, validUntil: UFix64?) {\n\n    var targetCapability : Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e\n    let bidsReference: \u0026FindMarketDirectOfferSoft.MarketBidCollection?\n    let pointer: FindViews.ViewReadPointer\n    let ftVaultType: Type\n\n    prepare(account: AuthAccount) {\n        \n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n        //SYNC with register\n        //Add exising FUSD or create a new one and add it\n        let name = account.address.toString()\n        let ducReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver)\n        if !ducReceiver.check() {\n            let dapper = getAccount(dapperAddress)\n            // Create a new Forwarder resource for DUC and store it in the new account's storage\n            let ducForwarder \u003c- TokenForwarding.createNewForwarder(recipient: dapper.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver))\n            account.save(\u003c-ducForwarder, to: /storage/dapperUtilityCoinReceiver)\n            // Publish a Receiver capability for the new account, which is linked to the DUC Forwarder\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver,target: /storage/dapperUtilityCoinReceiver)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: ducReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let dandyCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        let dandyCapPrivate= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPrivatePath)\n        if !dandyCapPrivate.check() {\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        var created=false\n        var updated=false\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        if !profile.hasWallet(\"Flow\") {\n            let flowWallet=Profile.Wallet( name:\"Flow\", receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), tags: [\"flow\"])\n    \n            profile.addWallet(flowWallet)\n            updated=true\n        }\n        if !profile.hasWallet(\"DUC\") {\n            profile.addWallet(Profile.Wallet( name:\"DUC\", receiver:ducReceiver, balance:getAccount(dapperAddress).getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/dapperUtilityCoinBalance), accept: Type\u003c@DapperUtilityCoin.Vault\u003e(), tags: [\"duc\", \"dapperUtilityCoin\",\"dapper\"]))\n            updated=true\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else {\n            profile.emitUpdatedEvent()\n        }\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        let doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        let doeSalePublicPath=FindMarket.getPublicPath(doeSaleType, name: tenant.name)\n        let doeSaleStoragePath= FindMarket.getStoragePath(doeSaleType, name:tenant.name)\n        let doeSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n        if !doeSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n        }\n\n        let doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        let doeBidPublicPath=FindMarket.getPublicPath(doeBidType, name: tenant.name)\n        let doeBidStoragePath= FindMarket.getStoragePath(doeBidType, name:tenant.name)\n        let doeBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n        if !doeBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n        }\n\n        /// auctions that escrow ft\n        let aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        let aeSalePublicPath=FindMarket.getPublicPath(aeSaleType, name: tenant.name)\n        let aeSaleStoragePath= FindMarket.getStoragePath(aeSaleType, name:tenant.name)\n        let aeSaleCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n        if !aeSaleCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n        }\n\n        let dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\n        let dosSalePublicPath=FindMarket.getPublicPath(dosSaleType, name: tenant.name)\n        let dosSaleStoragePath= FindMarket.getStoragePath(dosSaleType, name:tenant.name)\n\n        let dosSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n        if !dosSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n        }\n\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n        if !dosBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n        }\n\n        let aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\n        let aeBidPublicPath=FindMarket.getPublicPath(aeBidType, name: tenant.name)\n        let aeBidStoragePath= FindMarket.getStoragePath(aeBidType, name:tenant.name)\n        let aeBidCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n        if !aeBidCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n        }\n\n     /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n        }\n\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n        if !asBidCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n        }\n\n        let leaseTenantCapability= FindMarket.getTenantCapability(FindMarket.getTenantAddress(\"findLease\")!)!\n\n        let leaseSaleItemType= Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()\n        let leasePublicPath=FindMarket.getPublicPath(leaseSaleItemType, name: \"findLease\")\n        let leaseStoragePath= FindMarket.getStoragePath(leaseSaleItemType, name:\"findLease\")\n        let leaseSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath) \n        if !leaseSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketSale.SaleItemCollection\u003e(\u003c- FindLeaseMarketSale.createEmptySaleItemCollection(leaseTenantCapability), to: leaseStoragePath)\n            account.link\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath, target: leaseStoragePath)\n        }\n\n        let leaseASSaleItemType= Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e()\n        let leaseASPublicPath=FindMarket.getPublicPath(leaseASSaleItemType, name: \"findLease\")\n        let leaseASStoragePath= FindMarket.getStoragePath(leaseASSaleItemType, name:\"findLease\")\n        let leaseASSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath) \n        if !leaseASSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseASStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath, target: leaseASStoragePath)\n        }\n\n\n        let leaseASBidType= Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e()\n        let leaseASBidPublicPath=FindMarket.getPublicPath(leaseASBidType, name: \"findLease\")\n        let leaseASBidStoragePath= FindMarket.getStoragePath(leaseASBidType, name: \"findLease\")\n        let leaseASBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath) \n        if !leaseASBidCap.check() {\n            account.save\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseASBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath, target: leaseASBidStoragePath)\n        }\n\n        // let leaseAESaleItemType= Type\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e()\n        // let leaseAEPublicPath=FindMarket.getPublicPath(leaseAESaleItemType, name: \"findLease\")\n        // let leaseAEStoragePath= FindMarket.getStoragePath(leaseAESaleItemType, name:\"findLease\")\n        // let leaseAESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath) \n        // if !leaseAESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseAEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath, target: leaseAEStoragePath)\n        // }\n\n        // let leaseAEBidType= Type\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e()\n        // let leaseAEBidPublicPath=FindMarket.getPublicPath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidStoragePath= FindMarket.getStoragePath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath) \n        // if !leaseAEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseAEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath, target: leaseAEBidStoragePath)\n        // }\n\n        let leaseDOSSaleItemType= Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e()\n        let leaseDOSPublicPath=FindMarket.getPublicPath(leaseDOSSaleItemType, name: \"findLease\")\n        let leaseDOSStoragePath= FindMarket.getStoragePath(leaseDOSSaleItemType, name:\"findLease\")\n        let leaseDOSSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath) \n        if !leaseDOSSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOSStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath, target: leaseDOSStoragePath)\n        }\n\n        let leaseDOSBidType= Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let leaseDOSBidPublicPath=FindMarket.getPublicPath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidStoragePath= FindMarket.getStoragePath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath) \n        if !leaseDOSBidCap.check() {\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOSBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath, target: leaseDOSBidStoragePath)\n        }\n\n        // let leaseDOESaleItemType= Type\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        // let leaseDOEPublicPath=FindMarket.getPublicPath(leaseDOESaleItemType, name: \"findLease\")\n        // let leaseDOEStoragePath= FindMarket.getStoragePath(leaseDOESaleItemType, name:\"findLease\")\n        // let leaseDOESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath) \n        // if !leaseDOESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath, target: leaseDOEStoragePath)\n        // }\n\n        // let leaseDOEBidType= Type\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        // let leaseDOEBidPublicPath=FindMarket.getPublicPath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidStoragePath= FindMarket.getStoragePath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath) \n        // if !leaseDOEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath, target: leaseDOEBidStoragePath)\n        // }\n        //SYNC with register\n\n        let resolveAddress = FIND.resolve(user)\n        if resolveAddress == nil {panic(\"The address input is not a valid name nor address. Input : \".concat(user))}\n        let address = resolveAddress!\n\n        let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftAliasOrIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftAliasOrIdentifier)) \n        let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n        let nft = collection.collectionData\n\n        let ft = FTRegistry.getFTInfo(Type\u003c@DapperUtilityCoin.Vault\u003e().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(Type\u003c@DapperUtilityCoin.Vault\u003e().identifier))\n\n        self.ftVaultType = ft.type\n\n        self.targetCapability= account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(nft.publicPath)\n\n        let bidStoragePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())!\n        self.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection\u003e(from: bidStoragePath)\n        self.pointer= FindViews.createViewReadPointer(address: address, path:nft.publicPath, id: id)\n\n        /* Check for nftCapability */\n        if !self.targetCapability.check() {\n            let cd = self.pointer.getNFTCollectionData()\n            // should use account.type here instead\n            if account.type(at: cd.storagePath) != nil {\n                let pathIdentifier = nft.publicPath.toString()\n                let findPath = PublicPath(identifier: pathIdentifier.slice(from: \"/public/\".length , upTo: pathIdentifier.length).concat(\"_FIND\"))!\n                account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                    findPath,\n                    target: nft.storagePath\n                )\n                self.targetCapability = account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(findPath)\n            } else {\n                account.save(\u003c- cd.createEmptyCollection(), to: cd.storagePath)\n                account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.publicPath, target: cd.storagePath)\n                account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.providerPath, target: cd.storagePath)\n            }\n\n        }\n    }\n\n    pre {\n        self.bidsReference != nil : \"This account does not have a bid collection\"\n    }\n\n    execute {\n        self.bidsReference!.bid(item:self.pointer, amount: amount, vaultType: self.ftVaultType, nftCap: self.targetCapability, validUntil: validUntil, saleItemExtraField: {}, bidExtraField: {})\n    }\n}",
               "spec": {
                  "order": [
                     "dapperAddress",
                     "marketplace",
                     "user",
                     "nftAliasOrIdentifier",
                     "id",
                     "amount",
                     "validUntil"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "dapperAddress": "Address",
                     "id": "UInt64",
                     "marketplace": "Address",
                     "nftAliasOrIdentifier": "String",
                     "user": "String",
                     "validUntil": "UFix64?"
                  }
               }
            },
            "bidMultipleMarketDirectOfferEscrowed": {
               "code": "import FindMarket from 0x097bafa4e0b48eef\nimport FindMarketSale from 0x097bafa4e0b48eef\nimport FindMarketAuctionEscrow from 0x097bafa4e0b48eef\nimport FindMarketAuctionSoft from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferEscrow from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferSoft from 0x097bafa4e0b48eef\nimport FungibleToken from 0xf233dcee88fe0abe\nimport NonFungibleToken from 0x1d7e57aa55817448\nimport MetadataViews from 0x1d7e57aa55817448\nimport FindViews from 0x097bafa4e0b48eef\nimport FTRegistry from 0x097bafa4e0b48eef\nimport NFTCatalog from 0x49a7cda3a1eecc29\nimport FINDNFTCatalog from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\nimport FUSD from 0x3c5959b568896393\nimport FiatToken from 0xb19436aae4d94622\nimport FlowToken from 0x1654653399040a61\nimport Dandy from 0x097bafa4e0b48eef\nimport Profile from 0x097bafa4e0b48eef\n\ntransaction(marketplace:Address, users: [String], nftAliasOrIdentifiers: [String], ids: [UInt64], ftAliasOrIdentifiers:[String], amounts: [UFix64], validUntil: UFix64?) {\n\n    let targetCapability : [Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e]\n    let walletReference : [\u0026FungibleToken.Vault]\n    let bidsReference: \u0026FindMarketDirectOfferEscrow.MarketBidCollection?\n    let pointer: [FindViews.ViewReadPointer]\n\n    prepare(account: AuthAccount) {\n\n        if nftAliasOrIdentifiers.length != users.length {\n            panic(\"The length of arrays passed in has to be the same\")\n        } else if nftAliasOrIdentifiers.length != ids.length {\n            panic(\"The length of arrays passed in has to be the same\")\n        } else if nftAliasOrIdentifiers.length != ftAliasOrIdentifiers.length {\n            panic(\"The length of arrays passed in has to be the same\")\n        } else if nftAliasOrIdentifiers.length != amounts.length {\n            panic(\"The length of arrays passed in has to be the same\")\n        }\n\n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n        //SYNC with register\n        //Add exising FUSD or create a new one and add it\n        let name = account.address.toString()\n        let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n        if !fusdReceiver.check() {\n            let fusd \u003c- FUSD.createEmptyVault()\n            account.save(\u003c- fusd, to: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n        }\n\n        let usdcCap = account.getCapability\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e(FiatToken.VaultReceiverPubPath)\n        if !usdcCap.check() {\n                account.save( \u003c-FiatToken.createEmptyVault(), to: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e( FiatToken.VaultReceiverPubPath, target: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FiatToken.ResourceId}\u003e( FiatToken.VaultUUIDPubPath, target: FiatToken.VaultStoragePath)\n                account.link\u003c\u0026FiatToken.Vault{FungibleToken.Balance}\u003e( FiatToken.VaultBalancePubPath, target:FiatToken.VaultStoragePath)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let dandyCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        let dandyCapPrivate= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPrivatePath)\n        if !dandyCapPrivate.check() {\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        var created=false\n        var updated=false\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        if !profile.hasWallet(\"Flow\") {\n            let flowWallet=Profile.Wallet( name:\"Flow\", receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), tags: [\"flow\"])\n    \n            profile.addWallet(flowWallet)\n            updated=true\n        }\n        if !profile.hasWallet(\"FUSD\") {\n            profile.addWallet(Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), tags: [\"fusd\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if !profile.hasWallet(\"USDC\") {\n            profile.addWallet(Profile.Wallet( name:\"USDC\", receiver:usdcCap, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(FiatToken.VaultBalancePubPath), accept: Type\u003c@FiatToken.Vault\u003e(), tags: [\"usdc\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else if updated {\n            profile.emitUpdatedEvent()\n        }\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        let doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        let doeSalePublicPath=FindMarket.getPublicPath(doeSaleType, name: tenant.name)\n        let doeSaleStoragePath= FindMarket.getStoragePath(doeSaleType, name:tenant.name)\n        let doeSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n        if !doeSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n        }\n\n        let doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        let doeBidPublicPath=FindMarket.getPublicPath(doeBidType, name: tenant.name)\n        let doeBidStoragePath= FindMarket.getStoragePath(doeBidType, name:tenant.name)\n        let doeBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n        if !doeBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n        }\n\n        /// auctions that escrow ft\n        let aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        let aeSalePublicPath=FindMarket.getPublicPath(aeSaleType, name: tenant.name)\n        let aeSaleStoragePath= FindMarket.getStoragePath(aeSaleType, name:tenant.name)\n        let aeSaleCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n        if !aeSaleCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n        }\n\n        let dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\n        let dosSalePublicPath=FindMarket.getPublicPath(dosSaleType, name: tenant.name)\n        let dosSaleStoragePath= FindMarket.getStoragePath(dosSaleType, name:tenant.name)\n\n        let dosSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n        if !dosSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n        }\n\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n        if !dosBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n        }\n\n        let aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\n        let aeBidPublicPath=FindMarket.getPublicPath(aeBidType, name: tenant.name)\n        let aeBidStoragePath= FindMarket.getStoragePath(aeBidType, name:tenant.name)\n        let aeBidCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n        if !aeBidCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n        }\n\n     /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n        }\n\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n        if !asBidCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n        }\n        //SYNC with register\n\n        let addresses : {String : Address} = {}\n        let nfts : {String : NFTCatalog.NFTCollectionData} = {}\n        let fts : {String : FTRegistry.FTInfo} = {}\n\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketSale.SaleItemCollection\u003e())\n        let vaultRefs : {StoragePath : \u0026FungibleToken.Vault} = {}\n\n        let bidStoragePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e())!\n\n        self.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection\u003e(from: bidStoragePath)\n        self.walletReference = []\n        self.pointer = []\n        self.targetCapability = []\n\n        var counter = 0\n        while counter \u003c users.length {\n            var resolveAddress : Address? = nil\n            if addresses[users[counter]] != nil {\n                resolveAddress = addresses[users[counter]]!\n            } else {\n                let address = FIND.resolve(users[counter])\n                if address == nil {\n                    panic(\"The address input is not a valid name nor address. Input : \".concat(users[counter]))\n                }\n                addresses[users[counter]] = address!\n                resolveAddress = address!\n            }\n            let address = resolveAddress!\n\n            var nft : NFTCatalog.NFTCollectionData? = nil\n            var ft : FTRegistry.FTInfo? = nil\n            let nftIdentifier = nftAliasOrIdentifiers[counter]\n            let ftIdentifier = ftAliasOrIdentifiers[counter]\n\n            if nfts[nftIdentifier] != nil {\n                nft = nfts[nftIdentifier]\n            } else {\n                let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier)) \n                let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n                nft =  collection.collectionData\n\n                nfts[nftIdentifier] = nft\n            }\n\n            if fts[ftIdentifier] != nil {\n                ft = fts[ftIdentifier]\n            } else {\n                ft = FTRegistry.getFTInfo(ftIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftIdentifier))\n                fts[ftIdentifier] = ft \n            }\n        \n            if vaultRefs[ft!.vaultPath] != nil {\n                self.walletReference.append(vaultRefs[ft!.vaultPath]!)\n            } else {\n                let walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft!.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n                vaultRefs[ft!.vaultPath] = walletReference\n                self.walletReference.append(walletReference)\n            }\n\n            let pointer= FindViews.createViewReadPointer(address: address, path:nft!.publicPath, id: ids[counter])\n            self.pointer.append(pointer)\n\n            var targetCapability= account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(nft!.publicPath)\n            /* Check for nftCapability */\n            if !targetCapability.check() {\n                let cd = pointer.getNFTCollectionData()\n                // should use account.type here instead\n                if account.type(at: cd.storagePath) != nil {\n                    let pathIdentifier = nft!.publicPath.toString()\n                    let findPath = PublicPath(identifier: pathIdentifier.slice(from: \"/public/\".length , upTo: pathIdentifier.length).concat(\"_FIND\"))!\n                    account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                        findPath,\n                        target: nft!.storagePath\n                    )\n                    targetCapability = account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(findPath)\n                } else {\n                    account.save(\u003c- cd.createEmptyCollection(), to: cd.storagePath)\n                    account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.publicPath, target: cd.storagePath)\n                    account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.providerPath, target: cd.storagePath)\n                }\n\n            }\n            self.targetCapability.append(targetCapability)\n            counter = counter + 1\n        }\n    }\n\n    pre {\n        self.bidsReference != nil : \"This account does not have a bid collection\"\n    }\n\n    execute {\n        var counter = 0\n        while counter \u003c ids.length {\n            if self.walletReference[counter].balance \u003c amounts[counter] {\n                panic(\"Your wallet does not have enough funds to pay for this item. Fund Type : \".concat(ftAliasOrIdentifiers[counter]).concat(\"Required Amount : \").concat(amounts[counter].toString()))\n            }\n            let vault \u003c- self.walletReference[counter].withdraw(amount: amounts[counter]) \n            self.bidsReference!.bid(item:self.pointer[counter], vault: \u003c- vault, nftCap: self.targetCapability[counter], validUntil: validUntil, saleItemExtraField: {}, bidExtraField: {})\n            counter = counter + 1\n        }\n    }\n\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "users",
                     "nftAliasOrIdentifiers",
                     "ids",
                     "ftAliasOrIdentifiers",
                     "amounts",
                     "validUntil"
                  ],
                  "parameters": {
                     "amounts": "[UFix64]",
                     "ftAliasOrIdentifiers": "[String]",
                     "ids": "[UInt64]",
                     "marketplace": "Address",
                     "nftAliasOrIdentifiers": "[String]",
                     "users": "[String]",
                     "validUntil": "UFix64?"
                  }
               }
            },
            "bidMultipleMarketDirectOfferSoft": {
               "code": "import FindMarketSale from 0x097bafa4e0b48eef\nimport FindMarketAuctionEscrow from 0x097bafa4e0b48eef\nimport FindMarketAuctionSoft from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferEscrow from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferSoft from 0x097bafa4e0b48eef\nimport FindMarket from 0x097bafa4e0b48eef\nimport FungibleToken from 0xf233dcee88fe0abe\nimport NonFungibleToken from 0x1d7e57aa55817448\nimport MetadataViews from 0x1d7e57aa55817448\nimport FindViews from 0x097bafa4e0b48eef\nimport FTRegistry from 0x097bafa4e0b48eef\nimport NFTCatalog from 0x49a7cda3a1eecc29\nimport FINDNFTCatalog from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\nimport FUSD from 0x3c5959b568896393\nimport FiatToken from 0xb19436aae4d94622\nimport FlowToken from 0x1654653399040a61\nimport Dandy from 0x097bafa4e0b48eef\nimport Profile from 0x097bafa4e0b48eef\n\ntransaction(marketplace:Address, users: [String], nftAliasOrIdentifiers: [String], ids: [UInt64], ftAliasOrIdentifiers:[String], amounts: [UFix64], validUntil: UFix64?) {\n\n    let targetCapability : [Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e]\n    let walletReference : [\u0026FungibleToken.Vault]\n    let bidsReference: \u0026FindMarketDirectOfferSoft.MarketBidCollection?\n    let pointer: [FindViews.ViewReadPointer]\n    let ftVaultType: [Type]\n    let totalPrice : {String : UFix64}\n\n    prepare(account: AuthAccount) {\n\n        if nftAliasOrIdentifiers.length != users.length {\n            panic(\"The length of arrays passed in has to be the same\")\n        } else if nftAliasOrIdentifiers.length != ids.length {\n            panic(\"The length of arrays passed in has to be the same\")\n        } else if nftAliasOrIdentifiers.length != ftAliasOrIdentifiers.length {\n            panic(\"The length of arrays passed in has to be the same\")\n        } else if nftAliasOrIdentifiers.length != amounts.length {\n            panic(\"The length of arrays passed in has to be the same\")\n        }\n        \n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n        //SYNC with register\n        //Add exising FUSD or create a new one and add it\n        let name = account.address.toString()\n        let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n        if !fusdReceiver.check() {\n            let fusd \u003c- FUSD.createEmptyVault()\n            account.save(\u003c- fusd, to: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n        }\n\n        let usdcCap = account.getCapability\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e(FiatToken.VaultReceiverPubPath)\n        if !usdcCap.check() {\n                account.save( \u003c-FiatToken.createEmptyVault(), to: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e( FiatToken.VaultReceiverPubPath, target: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FiatToken.ResourceId}\u003e( FiatToken.VaultUUIDPubPath, target: FiatToken.VaultStoragePath)\n                account.link\u003c\u0026FiatToken.Vault{FungibleToken.Balance}\u003e( FiatToken.VaultBalancePubPath, target:FiatToken.VaultStoragePath)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let dandyCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        let dandyCapPrivate= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPrivatePath)\n        if !dandyCapPrivate.check() {\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        var created=false\n        var updated=false\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        if !profile.hasWallet(\"Flow\") {\n            let flowWallet=Profile.Wallet( name:\"Flow\", receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), tags: [\"flow\"])\n    \n            profile.addWallet(flowWallet)\n            updated=true\n        }\n        if !profile.hasWallet(\"FUSD\") {\n            profile.addWallet(Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), tags: [\"fusd\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if !profile.hasWallet(\"USDC\") {\n            profile.addWallet(Profile.Wallet( name:\"USDC\", receiver:usdcCap, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(FiatToken.VaultBalancePubPath), accept: Type\u003c@FiatToken.Vault\u003e(), tags: [\"usdc\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else if updated {\n            profile.emitUpdatedEvent()\n        }\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        let doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        let doeSalePublicPath=FindMarket.getPublicPath(doeSaleType, name: tenant.name)\n        let doeSaleStoragePath= FindMarket.getStoragePath(doeSaleType, name:tenant.name)\n        let doeSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n        if !doeSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n        }\n\n        let doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        let doeBidPublicPath=FindMarket.getPublicPath(doeBidType, name: tenant.name)\n        let doeBidStoragePath= FindMarket.getStoragePath(doeBidType, name:tenant.name)\n        let doeBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n        if !doeBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n        }\n\n        /// auctions that escrow ft\n        let aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        let aeSalePublicPath=FindMarket.getPublicPath(aeSaleType, name: tenant.name)\n        let aeSaleStoragePath= FindMarket.getStoragePath(aeSaleType, name:tenant.name)\n        let aeSaleCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n        if !aeSaleCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n        }\n\n        let dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\n        let dosSalePublicPath=FindMarket.getPublicPath(dosSaleType, name: tenant.name)\n        let dosSaleStoragePath= FindMarket.getStoragePath(dosSaleType, name:tenant.name)\n\n        let dosSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n        if !dosSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n        }\n\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n        if !dosBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n        }\n\n        let aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\n        let aeBidPublicPath=FindMarket.getPublicPath(aeBidType, name: tenant.name)\n        let aeBidStoragePath= FindMarket.getStoragePath(aeBidType, name:tenant.name)\n        let aeBidCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n        if !aeBidCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n        }\n\n     /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n        }\n\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n        if !asBidCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n        }\n        //SYNC with register\n\n        let addresses : {String : Address} = {}\n        let nfts : {String : NFTCatalog.NFTCollectionData} = {}\n        let fts : {String : FTRegistry.FTInfo} = {}\n        let vaultRefs : {StoragePath : \u0026FungibleToken.Vault} = {}\n        \n\n        let bidStoragePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())!\n        self.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection\u003e(from: bidStoragePath)\n        self.walletReference = []\n        self.pointer = []\n        self.targetCapability = []\n        self.ftVaultType = []\n        self.totalPrice = {}\n\n        var counter = 0\n        while counter \u003c users.length {\n            var resolveAddress : Address? = nil\n            if addresses[users[counter]] != nil {\n                resolveAddress = addresses[users[counter]]!\n            } else {\n                let address = FIND.resolve(users[counter])\n                if address == nil {\n                    panic(\"The address input is not a valid name nor address. Input : \".concat(users[counter]))\n                }\n                addresses[users[counter]] = address!\n                resolveAddress = address!\n            }\n            let address = resolveAddress!\n\n            var nft : NFTCatalog.NFTCollectionData? = nil\n            var ft : FTRegistry.FTInfo? = nil\n            let nftIdentifier = nftAliasOrIdentifiers[counter]\n            let ftIdentifier = ftAliasOrIdentifiers[counter]\n\n            if nfts[nftIdentifier] != nil {\n                nft = nfts[nftIdentifier]\n            } else {\n                let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier)) \n                let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n                nft = collection.collectionData\n                nfts[nftIdentifier] = nft\n            }\n\n            if fts[ftIdentifier] != nil {\n                ft = fts[ftIdentifier]\n            } else {\n                ft = FTRegistry.getFTInfo(ftIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftIdentifier))\n                fts[ftIdentifier] = ft \n            }\n        \n            if vaultRefs[ft!.vaultPath] != nil {\n                self.walletReference.append(vaultRefs[ft!.vaultPath]!)\n                self.ftVaultType.append(vaultRefs[ft!.vaultPath]!.getType())\n            } else {\n                let walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft!.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n                vaultRefs[ft!.vaultPath] = walletReference\n                self.walletReference.append(walletReference)\n                self.ftVaultType.append(ft!.type)\n            }\n\n            if self.totalPrice[ftIdentifier] == nil {\n                self.totalPrice[ftIdentifier] = amounts[counter]\n            } else {\n                self.totalPrice[ftIdentifier] = self.totalPrice[ftIdentifier]! + amounts[counter]\n            }\n\n            let pointer= FindViews.createViewReadPointer(address: address, path:nft!.publicPath, id: ids[counter])\n            self.pointer.append(pointer)\n\n            var targetCapability= account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(nft!.publicPath)\n\n            /* Check for nftCapability */\n            if !targetCapability.check() {\n                let cd = pointer.getNFTCollectionData()\n                // should use account.type here instead\n                if account.type(at: cd.storagePath) != nil {\n                    let pathIdentifier = nft!.publicPath.toString()\n                    let findPath = PublicPath(identifier: pathIdentifier.slice(from: \"/public/\".length , upTo: pathIdentifier.length).concat(\"_FIND\"))!\n                    account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                        findPath,\n                        target: nft!.storagePath\n                    )\n                    targetCapability = account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(findPath)\n                } else {\n                    account.save(\u003c- cd.createEmptyCollection(), to: cd.storagePath)\n                    account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.publicPath, target: cd.storagePath)\n                    account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.providerPath, target: cd.storagePath)\n                }\n\n            }\n            self.targetCapability.append(targetCapability)\n            counter = counter + 1\n        }\n    }\n\n    pre {\n        self.bidsReference != nil : \"This account does not have a bid collection\"\n    }\n\n    execute {\n        var counter = 0\n        while counter \u003c ids.length {\n            if self.walletReference[counter].balance \u003c self.totalPrice[ftAliasOrIdentifiers[counter]]! {\n                panic(\"Your wallet does not have enough funds to pay for this item. Vault Type : \".concat(self.ftVaultType[counter].getType().identifier).concat(\" . Required : \".concat(self.totalPrice[ftAliasOrIdentifiers[counter]]!.toString())))\n            }    \n            self.bidsReference!.bid(item:self.pointer[counter], amount: amounts[counter], vaultType: self.ftVaultType[counter], nftCap: self.targetCapability[counter], validUntil: validUntil, saleItemExtraField: {}, bidExtraField: {})\n            counter = counter + 1 \n        }\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "users",
                     "nftAliasOrIdentifiers",
                     "ids",
                     "ftAliasOrIdentifiers",
                     "amounts",
                     "validUntil"
                  ],
                  "parameters": {
                     "amounts": "[UFix64]",
                     "ftAliasOrIdentifiers": "[String]",
                     "ids": "[UInt64]",
                     "marketplace": "Address",
                     "nftAliasOrIdentifiers": "[String]",
                     "users": "[String]",
                     "validUntil": "UFix64?"
                  }
               }
            },
            "bidMultipleMarketDirectOfferSoftDUC": {
               "code": "import FindMarketSale from 0x097bafa4e0b48eef\nimport FindMarketAuctionEscrow from 0x097bafa4e0b48eef\nimport FindMarketAuctionSoft from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferEscrow from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferSoft from 0x097bafa4e0b48eef\nimport FindMarket from 0x097bafa4e0b48eef\nimport FungibleToken from 0xf233dcee88fe0abe\nimport NonFungibleToken from 0x1d7e57aa55817448\nimport MetadataViews from 0x1d7e57aa55817448\nimport FindViews from 0x097bafa4e0b48eef\nimport NFTCatalog from 0x49a7cda3a1eecc29\nimport FINDNFTCatalog from 0x097bafa4e0b48eef\nimport FTRegistry from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\nimport FlowToken from 0x1654653399040a61\nimport TokenForwarding from 0xe544175ee0461c4b\nimport DapperUtilityCoin from 0xead892083b3e2c6c\nimport Dandy from 0x097bafa4e0b48eef\nimport Profile from 0x097bafa4e0b48eef\n\ntransaction(dapperAddress: Address, marketplace:Address, users: [String], nftAliasOrIdentifiers: [String], ids: [UInt64], amounts: [UFix64], validUntil: UFix64?) {\n\n    let targetCapability : [Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e]\n    let bidsReference: \u0026FindMarketDirectOfferSoft.MarketBidCollection?\n    let pointer: [FindViews.ViewReadPointer]\n\n    prepare(account: AuthAccount) {\n\n        if nftAliasOrIdentifiers.length != users.length {\n            panic(\"The length of arrays passed in has to be the same\")\n        } else if nftAliasOrIdentifiers.length != ids.length {\n            panic(\"The length of arrays passed in has to be the same\")\n        } else if nftAliasOrIdentifiers.length != amounts.length {\n            panic(\"The length of arrays passed in has to be the same\")\n        }\n        \n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n        //SYNC with register\n        //Add exising FUSD or create a new one and add it\n        let name = account.address.toString()\n        let ducReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver)\n        if !ducReceiver.check() {\n            let dapper = getAccount(dapperAddress)\n            // Create a new Forwarder resource for DUC and store it in the new account's storage\n            let ducForwarder \u003c- TokenForwarding.createNewForwarder(recipient: dapper.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver))\n            account.save(\u003c-ducForwarder, to: /storage/dapperUtilityCoinReceiver)\n            // Publish a Receiver capability for the new account, which is linked to the DUC Forwarder\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver,target: /storage/dapperUtilityCoinReceiver)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: ducReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let dandyCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        let dandyCapPrivate= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPrivatePath)\n        if !dandyCapPrivate.check() {\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        var created=false\n        var updated=false\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        if !profile.hasWallet(\"Flow\") {\n            let flowWallet=Profile.Wallet( name:\"Flow\", receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), tags: [\"flow\"])\n    \n            profile.addWallet(flowWallet)\n            updated=true\n        }\n        if !profile.hasWallet(\"DUC\") {\n            profile.addWallet(Profile.Wallet( name:\"DUC\", receiver:ducReceiver, balance:getAccount(dapperAddress).getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/dapperUtilityCoinBalance), accept: Type\u003c@DapperUtilityCoin.Vault\u003e(), tags: [\"duc\", \"dapperUtilityCoin\",\"dapper\"]))\n            updated=true\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else {\n            profile.emitUpdatedEvent()\n        }\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        let doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        let doeSalePublicPath=FindMarket.getPublicPath(doeSaleType, name: tenant.name)\n        let doeSaleStoragePath= FindMarket.getStoragePath(doeSaleType, name:tenant.name)\n        let doeSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n        if !doeSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n        }\n\n        let doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        let doeBidPublicPath=FindMarket.getPublicPath(doeBidType, name: tenant.name)\n        let doeBidStoragePath= FindMarket.getStoragePath(doeBidType, name:tenant.name)\n        let doeBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n        if !doeBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n        }\n\n        /// auctions that escrow ft\n        let aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        let aeSalePublicPath=FindMarket.getPublicPath(aeSaleType, name: tenant.name)\n        let aeSaleStoragePath= FindMarket.getStoragePath(aeSaleType, name:tenant.name)\n        let aeSaleCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n        if !aeSaleCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n        }\n\n        let dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\n        let dosSalePublicPath=FindMarket.getPublicPath(dosSaleType, name: tenant.name)\n        let dosSaleStoragePath= FindMarket.getStoragePath(dosSaleType, name:tenant.name)\n\n        let dosSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n        if !dosSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n        }\n\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n        if !dosBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n        }\n\n        let aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\n        let aeBidPublicPath=FindMarket.getPublicPath(aeBidType, name: tenant.name)\n        let aeBidStoragePath= FindMarket.getStoragePath(aeBidType, name:tenant.name)\n        let aeBidCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n        if !aeBidCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n        }\n\n     /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n        }\n\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n        if !asBidCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n        }\n        //SYNC with register\n\n        let addresses : {String : Address} = {}\n        let nfts : {String : NFTCatalog.NFTCollectionData} = {}\n        let fts : {String : FTRegistry.FTInfo} = {}\n\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketSale.SaleItemCollection\u003e())\n        let vaultRefs : {StoragePath : \u0026FungibleToken.Vault} = {}\n\n\n        let bidStoragePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())!\n        self.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection\u003e(from: bidStoragePath)\n        \n        self.pointer = []\n        self.targetCapability = []\n\n        var counter = 0\n        while counter \u003c users.length {\n            var resolveAddress : Address? = nil\n            if addresses[users[counter]] != nil {\n                resolveAddress = addresses[users[counter]]!\n            } else {\n                let address = FIND.resolve(users[counter])\n                if address == nil {\n                    panic(\"The address input is not a valid name nor address. Input : \".concat(users[counter]))\n                }\n                addresses[users[counter]] = address!\n                resolveAddress = address!\n            }\n            let address = resolveAddress!\n\n            var nft : NFTCatalog.NFTCollectionData? = nil\n            let nftIdentifier = nftAliasOrIdentifiers[counter]\n\n            if nfts[nftIdentifier] != nil {\n                nft = nfts[nftIdentifier]\n            } else {\n                let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier)) \n                let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n                nft = collection.collectionData\n                nfts[nftIdentifier] = nft\n            }\n\n\n            let pointer= FindViews.createViewReadPointer(address: address, path:nft!.publicPath, id: ids[counter])\n            self.pointer.append(pointer)\n\n            var targetCapability= account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(nft!.publicPath)\n\n            /* Check for nftCapability */\n            if !targetCapability.check() {\n                let cd = pointer.getNFTCollectionData()\n                // should use account.type here instead\n                if account.type(at: cd.storagePath) != nil {\n                    let pathIdentifier = nft!.publicPath.toString()\n                    let findPath = PublicPath(identifier: pathIdentifier.slice(from: \"/public/\".length , upTo: pathIdentifier.length).concat(\"_FIND\"))!\n                    account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                        findPath,\n                        target: nft!.storagePath\n                    )\n                    targetCapability = account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(findPath)\n                } else {\n                    account.save(\u003c- cd.createEmptyCollection(), to: cd.storagePath)\n                    account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.publicPath, target: cd.storagePath)\n                    account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.providerPath, target: cd.storagePath)\n                }\n\n            }\n            self.targetCapability.append(targetCapability)\n            counter = counter + 1\n        }\n    }\n\n    pre {\n        self.bidsReference != nil : \"This account does not have a bid collection\"\n    }\n\n    execute {\n        var counter = 0\n        while counter \u003c ids.length {\n            self.bidsReference!.bid(item:self.pointer[counter], amount: amounts[counter], vaultType: Type\u003c@DapperUtilityCoin.Vault\u003e(), nftCap: self.targetCapability[counter], validUntil: validUntil, saleItemExtraField: {}, bidExtraField: {})\n            counter = counter + 1\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "dapperAddress",
                     "marketplace",
                     "users",
                     "nftAliasOrIdentifiers",
                     "ids",
                     "amounts",
                     "validUntil"
                  ],
                  "parameters": {
                     "amounts": "[UFix64]",
                     "dapperAddress": "Address",
                     "ids": "[UInt64]",
                     "marketplace": "Address",
                     "nftAliasOrIdentifiers": "[String]",
                     "users": "[String]",
                     "validUntil": "UFix64?"
                  }
               }
            },
            "bidName": {
               "code": "import FungibleToken from 0xf233dcee88fe0abe\nimport FUSD from 0x3c5959b568896393\nimport FiatToken from 0xb19436aae4d94622\nimport FlowToken from 0x1654653399040a61\nimport Profile from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\nimport Dandy from 0x097bafa4e0b48eef\nimport NonFungibleToken from 0x1d7e57aa55817448\nimport MetadataViews from 0x1d7e57aa55817448\nimport FindMarketSale from 0x097bafa4e0b48eef\nimport FindMarket from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferEscrow from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferSoft from 0x097bafa4e0b48eef\nimport FindMarketAuctionEscrow from 0x097bafa4e0b48eef\nimport FindMarketAuctionSoft from 0x097bafa4e0b48eef\nimport FindLeaseMarketSale from 0x097bafa4e0b48eef\nimport FindLeaseMarketAuctionSoft from 0x097bafa4e0b48eef\n// import FindLeaseMarketAuctionEscrow from \"../contracts/FindLeaseMarketAuctionEscrow.cdc\"\nimport FindLeaseMarketDirectOfferSoft from 0x097bafa4e0b48eef\n// import FindLeaseMarketDirectOfferEscrow from \"../contracts/FindLeaseMarketDirectOfferEscrow.cdc\"\nimport FindLeaseMarket from 0x097bafa4e0b48eef\n\ntransaction(name: String, amount: UFix64) {\n\n    let vaultRef : \u0026FUSD.Vault?\n    let bidRef : \u0026FIND.BidCollection?\n\n    prepare(account: AuthAccount) {\n\n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n        //SYNC with register\n        //Add exising FUSD or create a new one and add it\n        let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n        if !fusdReceiver.check() {\n            let fusd \u003c- FUSD.createEmptyVault()\n            account.save(\u003c- fusd, to: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n        }\n\n        let usdcCap = account.getCapability\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e(FiatToken.VaultReceiverPubPath)\n        if !usdcCap.check() {\n                account.save( \u003c-FiatToken.createEmptyVault(), to: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e( FiatToken.VaultReceiverPubPath, target: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FiatToken.ResourceId}\u003e( FiatToken.VaultUUIDPubPath, target: FiatToken.VaultStoragePath)\n                account.link\u003c\u0026FiatToken.Vault{FungibleToken.Balance}\u003e( FiatToken.VaultBalancePubPath, target:FiatToken.VaultStoragePath)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let dandyCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        var created=false\n        var updated=true\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        if !profile.hasWallet(\"Flow\") {\n            let flowWallet=Profile.Wallet( name:\"Flow\", receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), tags: [\"flow\"])\n    \n            profile.addWallet(flowWallet)\n            updated=true\n        }\n        if !profile.hasWallet(\"FUSD\") {\n            profile.addWallet(Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), tags: [\"fusd\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if !profile.hasWallet(\"USDC\") {\n            profile.addWallet(Profile.Wallet( name:\"USDC\", receiver:usdcCap, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(FiatToken.VaultBalancePubPath), accept: Type\u003c@FiatToken.Vault\u003e(), tags: [\"usdc\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else if updated {\n            profile.emitUpdatedEvent()\n        }\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let tenantCapability= FindMarket.getTenantCapability(FindMarket.getFindTenantAddress())!\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        let doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        let doeSalePublicPath=FindMarket.getPublicPath(doeSaleType, name: tenant.name)\n        let doeSaleStoragePath= FindMarket.getStoragePath(doeSaleType, name:tenant.name)\n        let doeSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n        if !doeSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n        }\n\n        let doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        let doeBidPublicPath=FindMarket.getPublicPath(doeBidType, name: tenant.name)\n        let doeBidStoragePath= FindMarket.getStoragePath(doeBidType, name:tenant.name)\n        let doeBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n        if !doeBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n        }\n\n        /// auctions that escrow ft\n        let aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        let aeSalePublicPath=FindMarket.getPublicPath(aeSaleType, name: tenant.name)\n        let aeSaleStoragePath= FindMarket.getStoragePath(aeSaleType, name:tenant.name)\n        let aeSaleCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n        if !aeSaleCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n        }\n\n        let dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\n        let dosSalePublicPath=FindMarket.getPublicPath(dosSaleType, name: tenant.name)\n        let dosSaleStoragePath= FindMarket.getStoragePath(dosSaleType, name:tenant.name)\n\n        let dosSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n        if !dosSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n        }\n\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n        if !dosBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n        }\n\n        let aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\n        let aeBidPublicPath=FindMarket.getPublicPath(aeBidType, name: tenant.name)\n        let aeBidStoragePath= FindMarket.getStoragePath(aeBidType, name:tenant.name)\n        let aeBidCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n        if !aeBidCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n        }\n\n     /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n        }\n\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n        if !asBidCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n        }\n\n        let leaseTenantCapability= FindMarket.getTenantCapability(FindMarket.getTenantAddress(\"findLease\")!)!\n\n        let leaseSaleItemType= Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()\n        let leasePublicPath=FindMarket.getPublicPath(leaseSaleItemType, name: \"findLease\")\n        let leaseStoragePath= FindMarket.getStoragePath(leaseSaleItemType, name:\"findLease\")\n        let leaseSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath) \n        if !leaseSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketSale.SaleItemCollection\u003e(\u003c- FindLeaseMarketSale.createEmptySaleItemCollection(leaseTenantCapability), to: leaseStoragePath)\n            account.link\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath, target: leaseStoragePath)\n        }\n\n        let leaseASSaleItemType= Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e()\n        let leaseASPublicPath=FindMarket.getPublicPath(leaseASSaleItemType, name: \"findLease\")\n        let leaseASStoragePath= FindMarket.getStoragePath(leaseASSaleItemType, name:\"findLease\")\n        let leaseASSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath) \n        if !leaseASSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseASStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath, target: leaseASStoragePath)\n        }\n\n\n        let leaseASBidType= Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e()\n        let leaseASBidPublicPath=FindMarket.getPublicPath(leaseASBidType, name: \"findLease\")\n        let leaseASBidStoragePath= FindMarket.getStoragePath(leaseASBidType, name: \"findLease\")\n        let leaseASBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath) \n        if !leaseASBidCap.check() {\n            account.save\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseASBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath, target: leaseASBidStoragePath)\n        }\n\n        // let leaseAESaleItemType= Type\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e()\n        // let leaseAEPublicPath=FindMarket.getPublicPath(leaseAESaleItemType, name: \"findLease\")\n        // let leaseAEStoragePath= FindMarket.getStoragePath(leaseAESaleItemType, name:\"findLease\")\n        // let leaseAESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath) \n        // if !leaseAESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseAEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath, target: leaseAEStoragePath)\n        // }\n\n        // let leaseAEBidType= Type\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e()\n        // let leaseAEBidPublicPath=FindMarket.getPublicPath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidStoragePath= FindMarket.getStoragePath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath) \n        // if !leaseAEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseAEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath, target: leaseAEBidStoragePath)\n        // }\n\n        let leaseDOSSaleItemType= Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e()\n        let leaseDOSPublicPath=FindMarket.getPublicPath(leaseDOSSaleItemType, name: \"findLease\")\n        let leaseDOSStoragePath= FindMarket.getStoragePath(leaseDOSSaleItemType, name:\"findLease\")\n        let leaseDOSSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath) \n        if !leaseDOSSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOSStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath, target: leaseDOSStoragePath)\n        }\n\n        let leaseDOSBidType= Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let leaseDOSBidPublicPath=FindMarket.getPublicPath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidStoragePath= FindMarket.getStoragePath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath) \n        if !leaseDOSBidCap.check() {\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOSBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath, target: leaseDOSBidStoragePath)\n        }\n\n        // let leaseDOESaleItemType= Type\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        // let leaseDOEPublicPath=FindMarket.getPublicPath(leaseDOESaleItemType, name: \"findLease\")\n        // let leaseDOEStoragePath= FindMarket.getStoragePath(leaseDOESaleItemType, name:\"findLease\")\n        // let leaseDOESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath) \n        // if !leaseDOESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath, target: leaseDOEStoragePath)\n        // }\n\n        // let leaseDOEBidType= Type\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        // let leaseDOEBidPublicPath=FindMarket.getPublicPath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidStoragePath= FindMarket.getStoragePath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath) \n        // if !leaseDOEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath, target: leaseDOEBidStoragePath)\n        // }\n        //SYNC with register\n\n        self.vaultRef = account.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault)\n        self.bidRef = account.borrow\u003c\u0026FIND.BidCollection\u003e(from: FIND.BidStoragePath)\n    }\n\n    pre{\n        self.vaultRef != nil : \"Could not borrow reference to the fusdVault!\" \n        self.bidRef != nil : \"Could not borrow reference to the bid collection!\" \n    }\n\n    execute {\n        let vault \u003c- self.vaultRef!.withdraw(amount: amount) as! @FUSD.Vault\n        self.bidRef!.bid(name: name, vault: \u003c- vault)\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "name": "String"
                  }
               }
            },
            "buyAddon": {
               "code": "import FUSD from 0x3c5959b568896393\nimport FIND from 0x097bafa4e0b48eef\n\n\ntransaction(name: String, addon:String, amount:UFix64) {\n\n    let leases : \u0026FIND.LeaseCollection?\n    let vaultRef : \u0026FUSD.Vault? \n\n    prepare(account: AuthAccount) {\n\n        self.leases= account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)\n        self.vaultRef = account.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault)\n\n    }\n\n    pre{\n        self.leases != nil : \"Could not borrow reference to the leases collection\"\n        self.vaultRef != nil : \"Could not borrow reference to the fusdVault!\"\n    }\n\n    execute {\n        let vault \u003c- self.vaultRef!.withdraw(amount: amount) as! @FUSD.Vault\n        self.leases!.buyAddon(name: name, addon: addon, vault: \u003c- vault)\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "addon",
                     "amount"
                  ],
                  "parameters": {
                     "addon": "String",
                     "amount": "UFix64",
                     "name": "String"
                  }
               }
            },
            "buyLeaseForSale": {
               "code": "import FindMarket from 0x097bafa4e0b48eef\nimport FindMarketSale from 0x097bafa4e0b48eef\nimport FindMarketAuctionEscrow from 0x097bafa4e0b48eef\nimport FindMarketAuctionSoft from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferEscrow from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferSoft from 0x097bafa4e0b48eef\nimport NonFungibleToken from 0x1d7e57aa55817448\nimport MetadataViews from 0x1d7e57aa55817448\nimport FTRegistry from 0x097bafa4e0b48eef\nimport FungibleToken from 0xf233dcee88fe0abe\nimport FUSD from 0x3c5959b568896393\nimport FiatToken from 0xb19436aae4d94622\nimport FlowToken from 0x1654653399040a61\nimport FIND from 0x097bafa4e0b48eef\nimport Dandy from 0x097bafa4e0b48eef\nimport Profile from 0x097bafa4e0b48eef\nimport FindLeaseMarketSale from 0x097bafa4e0b48eef\nimport FindLeaseMarketAuctionSoft from 0x097bafa4e0b48eef\n// import FindLeaseMarketAuctionEscrow from \"../contracts/FindLeaseMarketAuctionEscrow.cdc\"\nimport FindLeaseMarketDirectOfferSoft from 0x097bafa4e0b48eef\n// import FindLeaseMarketDirectOfferEscrow from \"../contracts/FindLeaseMarketDirectOfferEscrow.cdc\"\nimport FindLeaseMarket from 0x097bafa4e0b48eef\n\ntransaction(leaseName: String, amount: UFix64) {\n\n    let targetCapability : Capability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e\n    let walletReference : \u0026FungibleToken.Vault\n\n    let saleItemsCap: Capability\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e\n    let buyer: Address\n\n    prepare(account: AuthAccount) {\n\n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n        //SYNC with register\n        //Add exising FUSD or create a new one and add it\n        let name = account.address.toString()\n        let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n        if !fusdReceiver.check() {\n            let fusd \u003c- FUSD.createEmptyVault()\n            account.save(\u003c- fusd, to: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n        }\n\n        let usdcCap = account.getCapability\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e(FiatToken.VaultReceiverPubPath)\n        if !usdcCap.check() {\n            account.save( \u003c-FiatToken.createEmptyVault(), to: FiatToken.VaultStoragePath)\n            account.link\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e( FiatToken.VaultReceiverPubPath, target: FiatToken.VaultStoragePath)\n            account.link\u003c\u0026FiatToken.Vault{FiatToken.ResourceId}\u003e( FiatToken.VaultUUIDPubPath, target: FiatToken.VaultStoragePath)\n            account.link\u003c\u0026FiatToken.Vault{FungibleToken.Balance}\u003e( FiatToken.VaultBalancePubPath, target:FiatToken.VaultStoragePath)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let dandyCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        let dandyCapPrivate= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPrivatePath)\n        if !dandyCapPrivate.check() {\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        var created=false\n        var updated=false\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        if !profile.hasWallet(\"Flow\") {\n            let flowWallet=Profile.Wallet( name:\"Flow\", receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), tags: [\"flow\"])\n    \n            profile.addWallet(flowWallet)\n            updated=true\n        }\n        if !profile.hasWallet(\"FUSD\") {\n            profile.addWallet(Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), tags: [\"fusd\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if !profile.hasWallet(\"USDC\") {\n            profile.addWallet(Profile.Wallet( name:\"USDC\", receiver:usdcCap, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(FiatToken.VaultBalancePubPath), accept: Type\u003c@FiatToken.Vault\u003e(), tags: [\"usdc\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else if updated {\n            profile.emitUpdatedEvent()\n        }\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let tenantCapability= FindMarket.getTenantCapability(FindMarket.getFindTenantAddress())!\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        let doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        let doeSalePublicPath=FindMarket.getPublicPath(doeSaleType, name: tenant.name)\n        let doeSaleStoragePath= FindMarket.getStoragePath(doeSaleType, name:tenant.name)\n        let doeSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n        if !doeSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n        }\n\n        let doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        let doeBidPublicPath=FindMarket.getPublicPath(doeBidType, name: tenant.name)\n        let doeBidStoragePath= FindMarket.getStoragePath(doeBidType, name:tenant.name)\n        let doeBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n        if !doeBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n        }\n\n        /// auctions that escrow ft\n        let aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        let aeSalePublicPath=FindMarket.getPublicPath(aeSaleType, name: tenant.name)\n        let aeSaleStoragePath= FindMarket.getStoragePath(aeSaleType, name:tenant.name)\n        let aeSaleCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n        if !aeSaleCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n        }\n\n        let dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\n        let dosSalePublicPath=FindMarket.getPublicPath(dosSaleType, name: tenant.name)\n        let dosSaleStoragePath= FindMarket.getStoragePath(dosSaleType, name:tenant.name)\n\n        let dosSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n        if !dosSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n        }\n\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n        if !dosBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n        }\n\n        let aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\n        let aeBidPublicPath=FindMarket.getPublicPath(aeBidType, name: tenant.name)\n        let aeBidStoragePath= FindMarket.getStoragePath(aeBidType, name:tenant.name)\n        let aeBidCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n        if !aeBidCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n        }\n\n     /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n        }\n\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n        if !asBidCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n        }\n\n        let leaseTenantCapability= FindMarket.getTenantCapability(FindMarket.getTenantAddress(\"findLease\")!)!\n\n        let leaseSaleItemType= Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()\n        let leasePublicPath=FindMarket.getPublicPath(leaseSaleItemType, name: \"findLease\")\n        let leaseStoragePath= FindMarket.getStoragePath(leaseSaleItemType, name:\"findLease\")\n        let leaseSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath) \n        if !leaseSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketSale.SaleItemCollection\u003e(\u003c- FindLeaseMarketSale.createEmptySaleItemCollection(leaseTenantCapability), to: leaseStoragePath)\n            account.link\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath, target: leaseStoragePath)\n        }\n\n        let leaseASSaleItemType= Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e()\n        let leaseASPublicPath=FindMarket.getPublicPath(leaseASSaleItemType, name: \"findLease\")\n        let leaseASStoragePath= FindMarket.getStoragePath(leaseASSaleItemType, name:\"findLease\")\n        let leaseASSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath) \n        if !leaseASSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseASStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath, target: leaseASStoragePath)\n        }\n\n\n        let leaseASBidType= Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e()\n        let leaseASBidPublicPath=FindMarket.getPublicPath(leaseASBidType, name: \"findLease\")\n        let leaseASBidStoragePath= FindMarket.getStoragePath(leaseASBidType, name: \"findLease\")\n        let leaseASBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath) \n        if !leaseASBidCap.check() {\n            account.save\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseASBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath, target: leaseASBidStoragePath)\n        }\n\n        // let leaseAESaleItemType= Type\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e()\n        // let leaseAEPublicPath=FindMarket.getPublicPath(leaseAESaleItemType, name: \"findLease\")\n        // let leaseAEStoragePath= FindMarket.getStoragePath(leaseAESaleItemType, name:\"findLease\")\n        // let leaseAESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath) \n        // if !leaseAESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseAEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath, target: leaseAEStoragePath)\n        // }\n\n        // let leaseAEBidType= Type\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e()\n        // let leaseAEBidPublicPath=FindMarket.getPublicPath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidStoragePath= FindMarket.getStoragePath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath) \n        // if !leaseAEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseAEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath, target: leaseAEBidStoragePath)\n        // }\n\n        let leaseDOSSaleItemType= Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e()\n        let leaseDOSPublicPath=FindMarket.getPublicPath(leaseDOSSaleItemType, name: \"findLease\")\n        let leaseDOSStoragePath= FindMarket.getStoragePath(leaseDOSSaleItemType, name:\"findLease\")\n        let leaseDOSSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath) \n        if !leaseDOSSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOSStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath, target: leaseDOSStoragePath)\n        }\n\n        let leaseDOSBidType= Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let leaseDOSBidPublicPath=FindMarket.getPublicPath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidStoragePath= FindMarket.getStoragePath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath) \n        if !leaseDOSBidCap.check() {\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOSBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath, target: leaseDOSBidStoragePath)\n        }\n\n        // let leaseDOESaleItemType= Type\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        // let leaseDOEPublicPath=FindMarket.getPublicPath(leaseDOESaleItemType, name: \"findLease\")\n        // let leaseDOEStoragePath= FindMarket.getStoragePath(leaseDOESaleItemType, name:\"findLease\")\n        // let leaseDOESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath) \n        // if !leaseDOESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath, target: leaseDOEStoragePath)\n        // }\n\n        // let leaseDOEBidType= Type\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        // let leaseDOEBidPublicPath=FindMarket.getPublicPath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidStoragePath= FindMarket.getStoragePath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath) \n        // if !leaseDOEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath, target: leaseDOEBidStoragePath)\n        // }\n        //SYNC with register\n\n        let resolveAddress = FIND.resolve(leaseName)\n        if resolveAddress == nil {\n            panic(\"The address input is not a valid name nor address. Input : \".concat(leaseName))\n        }\n        let address = resolveAddress!\n        let leaseMarketplace = FindMarket.getTenantAddress(\"findLease\")!\n        self.saleItemsCap= FindLeaseMarketSale.getSaleItemCapability(marketplace: leaseMarketplace, user:address) ?? panic(\"cannot find lease sale item cap\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e())\n\n        let item= FindLeaseMarket.assertOperationValid(tenant: leaseMarketplace, name: leaseName, marketOption: marketOption)\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n    \n        self.targetCapability= account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\n        self.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n        self.buyer = account.address\n    }\n\n    pre {\n        self.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount) \n        self.saleItemsCap.borrow()!.buy(name:leaseName, vault: \u003c- vault, to: self.buyer)\n    }\n}",
               "spec": {
                  "order": [
                     "leaseName",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "leaseName": "String"
                  }
               }
            },
            "buyLeaseForSaleDUC": {
               "code": "import FindMarket from 0x097bafa4e0b48eef\nimport FindMarketSale from 0x097bafa4e0b48eef\nimport FindMarketAuctionEscrow from 0x097bafa4e0b48eef\nimport FindMarketAuctionSoft from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferEscrow from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferSoft from 0x097bafa4e0b48eef\nimport NonFungibleToken from 0x1d7e57aa55817448\nimport MetadataViews from 0x1d7e57aa55817448\nimport FTRegistry from 0x097bafa4e0b48eef\nimport FungibleToken from 0xf233dcee88fe0abe\nimport FIND from 0x097bafa4e0b48eef\nimport Dandy from 0x097bafa4e0b48eef\nimport Profile from 0x097bafa4e0b48eef\nimport TokenForwarding from 0xe544175ee0461c4b\nimport DapperUtilityCoin from 0xead892083b3e2c6c\nimport FlowToken from 0x1654653399040a61\nimport FindLeaseMarketSale from 0x097bafa4e0b48eef\nimport FindLeaseMarketAuctionSoft from 0x097bafa4e0b48eef\n// import FindLeaseMarketAuctionEscrow from \"../contracts/FindLeaseMarketAuctionEscrow.cdc\"\nimport FindLeaseMarketDirectOfferSoft from 0x097bafa4e0b48eef\n// import FindLeaseMarketDirectOfferEscrow from \"../contracts/FindLeaseMarketDirectOfferEscrow.cdc\"\nimport FindLeaseMarket from 0x097bafa4e0b48eef\n\ntransaction(dapperAddress: Address, leaseName: String, amount: UFix64) {\n\n    let to : Address\n    let walletReference : \u0026FungibleToken.Vault\n\n    let saleItemsCap: Capability\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e\n    let mainDapperUtilityCoinVault: \u0026DapperUtilityCoin.Vault\n    let balanceBeforeTransfer: UFix64\n\n    prepare(dapper: AuthAccount, account: AuthAccount) {\n\n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n        //SYNC with register\n        //Add exising FUSD or create a new one and add it\n        let name = account.address.toString()\n        let ducReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver)\n        if !ducReceiver.check() {\n            let dapper = getAccount(dapperAddress)\n            // Create a new Forwarder resource for DUC and store it in the new account's storage\n            let ducForwarder \u003c- TokenForwarding.createNewForwarder(recipient: dapper.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver))\n            account.save(\u003c-ducForwarder, to: /storage/dapperUtilityCoinReceiver)\n            // Publish a Receiver capability for the new account, which is linked to the DUC Forwarder\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver,target: /storage/dapperUtilityCoinReceiver)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: ducReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let dandyCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        let dandyCapPrivate= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPrivatePath)\n        if !dandyCapPrivate.check() {\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        var created=false\n        var updated=false\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        if !profile.hasWallet(\"Flow\") {\n            let flowWallet=Profile.Wallet( name:\"Flow\", receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), tags: [\"flow\"])\n    \n            profile.addWallet(flowWallet)\n            updated=true\n        }\n        if !profile.hasWallet(\"DUC\") {\n            profile.addWallet(Profile.Wallet( name:\"DUC\", receiver:ducReceiver, balance:getAccount(dapperAddress).getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/dapperUtilityCoinBalance), accept: Type\u003c@DapperUtilityCoin.Vault\u003e(), tags: [\"duc\", \"dapperUtilityCoin\",\"dapper\"]))\n            updated=true\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else {\n            profile.emitUpdatedEvent()\n        }\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        let doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        let doeSalePublicPath=FindMarket.getPublicPath(doeSaleType, name: tenant.name)\n        let doeSaleStoragePath= FindMarket.getStoragePath(doeSaleType, name:tenant.name)\n        let doeSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n        if !doeSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n        }\n\n        let doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        let doeBidPublicPath=FindMarket.getPublicPath(doeBidType, name: tenant.name)\n        let doeBidStoragePath= FindMarket.getStoragePath(doeBidType, name:tenant.name)\n        let doeBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n        if !doeBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n        }\n\n        /// auctions that escrow ft\n        let aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        let aeSalePublicPath=FindMarket.getPublicPath(aeSaleType, name: tenant.name)\n        let aeSaleStoragePath= FindMarket.getStoragePath(aeSaleType, name:tenant.name)\n        let aeSaleCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n        if !aeSaleCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n        }\n\n        let dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\n        let dosSalePublicPath=FindMarket.getPublicPath(dosSaleType, name: tenant.name)\n        let dosSaleStoragePath= FindMarket.getStoragePath(dosSaleType, name:tenant.name)\n\n        let dosSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n        if !dosSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n        }\n\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n        if !dosBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n        }\n\n        let aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\n        let aeBidPublicPath=FindMarket.getPublicPath(aeBidType, name: tenant.name)\n        let aeBidStoragePath= FindMarket.getStoragePath(aeBidType, name:tenant.name)\n        let aeBidCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n        if !aeBidCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n        }\n\n     /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n        }\n\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n        if !asBidCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n        }\n\n        let leaseTenantCapability= FindMarket.getTenantCapability(FindMarket.getTenantAddress(\"findLease\")!)!\n\n        let leaseSaleItemType= Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()\n        let leasePublicPath=FindMarket.getPublicPath(leaseSaleItemType, name: \"findLease\")\n        let leaseStoragePath= FindMarket.getStoragePath(leaseSaleItemType, name:\"findLease\")\n        let leaseSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath) \n        if !leaseSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketSale.SaleItemCollection\u003e(\u003c- FindLeaseMarketSale.createEmptySaleItemCollection(leaseTenantCapability), to: leaseStoragePath)\n            account.link\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath, target: leaseStoragePath)\n        }\n\n        let leaseASSaleItemType= Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e()\n        let leaseASPublicPath=FindMarket.getPublicPath(leaseASSaleItemType, name: \"findLease\")\n        let leaseASStoragePath= FindMarket.getStoragePath(leaseASSaleItemType, name:\"findLease\")\n        let leaseASSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath) \n        if !leaseASSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseASStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath, target: leaseASStoragePath)\n        }\n\n\n        let leaseASBidType= Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e()\n        let leaseASBidPublicPath=FindMarket.getPublicPath(leaseASBidType, name: \"findLease\")\n        let leaseASBidStoragePath= FindMarket.getStoragePath(leaseASBidType, name: \"findLease\")\n        let leaseASBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath) \n        if !leaseASBidCap.check() {\n            account.save\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseASBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath, target: leaseASBidStoragePath)\n        }\n\n        // let leaseAESaleItemType= Type\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e()\n        // let leaseAEPublicPath=FindMarket.getPublicPath(leaseAESaleItemType, name: \"findLease\")\n        // let leaseAEStoragePath= FindMarket.getStoragePath(leaseAESaleItemType, name:\"findLease\")\n        // let leaseAESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath) \n        // if !leaseAESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseAEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath, target: leaseAEStoragePath)\n        // }\n\n        // let leaseAEBidType= Type\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e()\n        // let leaseAEBidPublicPath=FindMarket.getPublicPath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidStoragePath= FindMarket.getStoragePath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath) \n        // if !leaseAEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseAEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath, target: leaseAEBidStoragePath)\n        // }\n\n        let leaseDOSSaleItemType= Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e()\n        let leaseDOSPublicPath=FindMarket.getPublicPath(leaseDOSSaleItemType, name: \"findLease\")\n        let leaseDOSStoragePath= FindMarket.getStoragePath(leaseDOSSaleItemType, name:\"findLease\")\n        let leaseDOSSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath) \n        if !leaseDOSSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOSStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath, target: leaseDOSStoragePath)\n        }\n\n        let leaseDOSBidType= Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let leaseDOSBidPublicPath=FindMarket.getPublicPath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidStoragePath= FindMarket.getStoragePath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath) \n        if !leaseDOSBidCap.check() {\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOSBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath, target: leaseDOSBidStoragePath)\n        }\n\n        // let leaseDOESaleItemType= Type\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        // let leaseDOEPublicPath=FindMarket.getPublicPath(leaseDOESaleItemType, name: \"findLease\")\n        // let leaseDOEStoragePath= FindMarket.getStoragePath(leaseDOESaleItemType, name:\"findLease\")\n        // let leaseDOESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath) \n        // if !leaseDOESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath, target: leaseDOEStoragePath)\n        // }\n\n        // let leaseDOEBidType= Type\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        // let leaseDOEBidPublicPath=FindMarket.getPublicPath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidStoragePath= FindMarket.getStoragePath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath) \n        // if !leaseDOEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath, target: leaseDOEBidStoragePath)\n        // }\n        //SYNC with register\n\n        let resolveAddress = FIND.resolve(leaseName)\n        if resolveAddress == nil {\n            panic(\"The address input is not a valid name nor address. Input : \".concat(leaseName))\n        }\n        let address = resolveAddress!\n        let leaseMarketplace = FindMarket.getTenantAddress(\"findLease\")!\n        self.saleItemsCap= FindLeaseMarketSale.getSaleItemCapability(marketplace: leaseMarketplace, user:address) ?? panic(\"cannot find sale item cap\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e())\n\n        let item= FindLeaseMarket.assertOperationValid(tenant: leaseMarketplace, name: leaseName, marketOption: marketOption)\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n    \n        if ft.type != Type\u003c@DapperUtilityCoin.Vault\u003e() {\n            panic(\"This item is not listed for Dapper Wallets. Please buy in with other wallets.\")\n        }\n\n        self.mainDapperUtilityCoinVault = dapper.borrow\u003c\u0026DapperUtilityCoin.Vault\u003e(from: /storage/dapperUtilityCoinVault) ?? panic(\"Cannot borrow DapperUtilityCoin vault from account storage\".concat(dapper.address.toString()))\n        self.balanceBeforeTransfer = self.mainDapperUtilityCoinVault.balance\n\n        self.to= account.address\n\n        self.walletReference = dapper.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n    }\n\n    pre {\n        self.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount) \n        self.saleItemsCap.borrow()!.buy(name:leaseName, vault: \u003c- vault, to: self.to)\n    }\n\n    // Check that all dapperUtilityCoin was routed back to Dapper\n    post {\n        self.mainDapperUtilityCoinVault.balance == self.balanceBeforeTransfer: \"DapperUtilityCoin leakage\"\n    }\n}",
               "spec": {
                  "order": [
                     "dapperAddress",
                     "leaseName",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "dapperAddress": "Address",
                     "leaseName": "String"
                  }
               }
            },
            "buyMultipleNFTForSale": {
               "code": "import FindMarket from 0x097bafa4e0b48eef\nimport FindMarketSale from 0x097bafa4e0b48eef\nimport NonFungibleToken from 0x1d7e57aa55817448\nimport MetadataViews from 0x1d7e57aa55817448\nimport NFTCatalog from 0x49a7cda3a1eecc29\nimport FINDNFTCatalog from 0x097bafa4e0b48eef\nimport FTRegistry from 0x097bafa4e0b48eef\nimport FungibleToken from 0xf233dcee88fe0abe\n\ntransaction(marketplace:Address, users: [Address], ids: [UInt64], amounts: [UFix64]) {\n\n    let targetCapability : [Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e]\n    var walletReference : [\u0026FungibleToken.Vault]\n\n    let saleItems: [\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}]\n    var totalPrice : UFix64\n    let prices : [UFix64]\n    prepare(account: AuthAccount) {\n\n        if users.length != ids.length {\n            panic(\"The array length of users and ids should be the same\")\n        }\n\n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n\n        var counter = 0\n        self.walletReference= []\n        self.targetCapability = []\n\n        self.saleItems = []\n        let nfts : {String : NFTCatalog.NFTCollectionData} = {}\n        let fts : {String : FTRegistry.FTInfo} = {}\n        let saleItems : {Address : \u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}} = {}\n\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketSale.SaleItemCollection\u003e())\n\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(Type\u003c@FindMarketSale.SaleItemCollection\u003e(), name: tenant.name)\n        var vaultType : Type? = nil\n\n        self.totalPrice = 0.0\n        self.prices = []\n\n        while counter \u003c users.length {\n\n            let address=users[counter]\n\n            if saleItems[address] == nil {\n                let saleItem = getAccount(address).getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath).borrow() ?? panic(\"cannot find sale item cap\")\n                self.saleItems.append(saleItem)\n                saleItems[address] = saleItem \n            } else {\n                self.saleItems.append(saleItems[address]!)\n            }\n\n\n            // let item= FindMarket.assertOperationValid(tenant: marketplace, address: address, marketOption: marketOption, id: ids[counter])\n            let item=saleItems[address]!.borrowSaleItem(ids[counter])\n\n            self.prices.append(item.getBalance())\n            self.totalPrice = self.totalPrice + self.prices[counter]\n\n            var nft : NFTCatalog.NFTCollectionData? = nil\n            var ft : FTRegistry.FTInfo? = nil\n            let nftIdentifier = item.getItemType().identifier\n            let ftIdentifier = item.getFtType().identifier\n\n            if nfts[nftIdentifier] != nil {\n                nft = nfts[nftIdentifier]\n            } else {\n                let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier)) \n                let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n                nft = collection.collectionData\n                nfts[nftIdentifier] = nft\n            }\n\n            if fts[ftIdentifier] != nil {\n                ft = fts[ftIdentifier]\n            } else {\n                ft = FTRegistry.getFTInfo(ftIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftIdentifier))\n                fts[ftIdentifier] = ft \n            }\n\n            self.walletReference.append(\n                account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft!.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n            )\n\n            var targetCapability= account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(nft!.publicPath)\n            /* Check for nftCapability */\n            if !targetCapability.check() {\n                let cd = item.getNFTCollectionData()\n                // should use account.type here instead\n                if account.type(at: cd.storagePath) != nil {\n                    let pathIdentifier = nft!.publicPath.toString()\n                    let findPath = PublicPath(identifier: pathIdentifier.slice(from: \"/public/\".length , upTo: pathIdentifier.length).concat(\"_FIND\"))!\n                    account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                        findPath,\n                        target: nft!.storagePath\n                    )\n                    targetCapability = account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(findPath)\n                } else {\n                    account.save(\u003c- cd.createEmptyCollection(), to: cd.storagePath)\n                    account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.publicPath, target: cd.storagePath)\n                    account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.providerPath, target: cd.storagePath)\n                }\n\n            }\n            self.targetCapability.append(targetCapability)\n            counter = counter + 1\n        }\n\n\n    }\n\n    execute {\n        var counter = 0\n        while counter \u003c users.length {\n            if self.prices[counter] != amounts[counter] {\n                panic(\"Please pass in the correct price of the buy items. Required : \".concat(self.prices[counter].toString()).concat(\" . saleItem ID : \".concat(ids[counter].toString())))\n            }\n            if self.walletReference[counter].balance \u003c amounts[counter] {\n                panic(\"Your wallet does not have enough funds to pay for this item. Required : \".concat(self.prices[counter].toString()).concat(\" . saleItem ID : \".concat(ids[counter].toString())))\n            }\n\n            self.saleItems[counter].buy(id:ids[counter], vault: \u003c- self.walletReference[counter].withdraw(amount: amounts[counter]) \n            , nftCap: self.targetCapability[counter])\n            counter = counter + 1\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "users",
                     "ids",
                     "amounts"
                  ],
                  "parameters": {
                     "amounts": "[UFix64]",
                     "ids": "[UInt64]",
                     "marketplace": "Address",
                     "users": "[Address]"
                  }
               }
            },
            "buyMultipleNFTForSaleDUC": {
               "code": "import FindMarket from 0x097bafa4e0b48eef\nimport FindMarketSale from 0x097bafa4e0b48eef\nimport FindMarketAuctionEscrow from 0x097bafa4e0b48eef\nimport FindMarketAuctionSoft from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferEscrow from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferSoft from 0x097bafa4e0b48eef\nimport NonFungibleToken from 0x1d7e57aa55817448\nimport MetadataViews from 0x1d7e57aa55817448\nimport NFTCatalog from 0x49a7cda3a1eecc29\nimport FINDNFTCatalog from 0x097bafa4e0b48eef\nimport FTRegistry from 0x097bafa4e0b48eef\nimport FungibleToken from 0xf233dcee88fe0abe\nimport FIND from 0x097bafa4e0b48eef\nimport Dandy from 0x097bafa4e0b48eef\nimport Profile from 0x097bafa4e0b48eef\nimport TokenForwarding from 0xe544175ee0461c4b\nimport DapperUtilityCoin from 0xead892083b3e2c6c\nimport FlowToken from 0x1654653399040a61\n\ntransaction(dapperAddress: Address, marketplace:Address, users: [String], ids: [UInt64], amounts: [UFix64]) {\n\n    let targetCapability : [Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e]\n    var walletReference : \u0026FungibleToken.Vault\n\n    let saleItemsCap: [Capability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic}\u003e ]\n    let balanceBeforeTransfer: UFix64\n\n    var totalPrice : UFix64 \n    let prices : [UFix64]\n\n    prepare(dapper: AuthAccount, account: AuthAccount) {\n\n        if users.length != ids.length {\n            panic(\"The array length of users and ids should be the same\")\n        }\n\n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n        //SYNC with register\n        //Add exising FUSD or create a new one and add it\n        let name = account.address.toString()\n        let ducReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver)\n        if !ducReceiver.check() {\n            let dapper = getAccount(dapperAddress)\n            // Create a new Forwarder resource for DUC and store it in the new account's storage\n            let ducForwarder \u003c- TokenForwarding.createNewForwarder(recipient: dapper.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver))\n            account.save(\u003c-ducForwarder, to: /storage/dapperUtilityCoinReceiver)\n            // Publish a Receiver capability for the new account, which is linked to the DUC Forwarder\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver,target: /storage/dapperUtilityCoinReceiver)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: ducReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let dandyCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        let dandyCapPrivate= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPrivatePath)\n        if !dandyCapPrivate.check() {\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        var created=false\n        var updated=false\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        if !profile.hasWallet(\"Flow\") {\n            let flowWallet=Profile.Wallet( name:\"Flow\", receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), tags: [\"flow\"])\n    \n            profile.addWallet(flowWallet)\n            updated=true\n        }\n        if !profile.hasWallet(\"DUC\") {\n            profile.addWallet(Profile.Wallet( name:\"DUC\", receiver:ducReceiver, balance:getAccount(dapperAddress).getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/dapperUtilityCoinBalance), accept: Type\u003c@DapperUtilityCoin.Vault\u003e(), tags: [\"duc\", \"dapperUtilityCoin\",\"dapper\"]))\n            updated=true\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else {\n            profile.emitUpdatedEvent()\n        }\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        let doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        let doeSalePublicPath=FindMarket.getPublicPath(doeSaleType, name: tenant.name)\n        let doeSaleStoragePath= FindMarket.getStoragePath(doeSaleType, name:tenant.name)\n        let doeSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n        if !doeSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n        }\n\n        let doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        let doeBidPublicPath=FindMarket.getPublicPath(doeBidType, name: tenant.name)\n        let doeBidStoragePath= FindMarket.getStoragePath(doeBidType, name:tenant.name)\n        let doeBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n        if !doeBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n        }\n\n        /// auctions that escrow ft\n        let aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        let aeSalePublicPath=FindMarket.getPublicPath(aeSaleType, name: tenant.name)\n        let aeSaleStoragePath= FindMarket.getStoragePath(aeSaleType, name:tenant.name)\n        let aeSaleCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n        if !aeSaleCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n        }\n\n        let dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\n        let dosSalePublicPath=FindMarket.getPublicPath(dosSaleType, name: tenant.name)\n        let dosSaleStoragePath= FindMarket.getStoragePath(dosSaleType, name:tenant.name)\n\n        let dosSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n        if !dosSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n        }\n\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n        if !dosBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n        }\n\n        let aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\n        let aeBidPublicPath=FindMarket.getPublicPath(aeBidType, name: tenant.name)\n        let aeBidStoragePath= FindMarket.getStoragePath(aeBidType, name:tenant.name)\n        let aeBidCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n        if !aeBidCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n        }\n\n     /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n        }\n\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n        if !asBidCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n        }\n        //SYNC with register\n\n        var counter = 0\n        self.targetCapability = []\n        self.walletReference = dapper.borrow\u003c\u0026DapperUtilityCoin.Vault\u003e(from: /storage/dapperUtilityCoinVault) ?? panic(\"Cannot borrow DapperUtilityCoin vault from account storage\".concat(dapper.address.toString()))\n        self.balanceBeforeTransfer = self.walletReference.balance\n\n        self.saleItemsCap = []\n        let addresses : {String : Address} = {}\n        let nfts : {String : NFTCatalog.NFTCollectionData} = {}\n\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketSale.SaleItemCollection\u003e())\n\n        self.totalPrice = 0.0\n        self.prices = []\n\n        while counter \u003c users.length {\n            var resolveAddress : Address? = nil\n            if addresses[users[counter]] != nil {\n                resolveAddress = addresses[users[counter]]!\n            } else {\n                let address = FIND.resolve(users[counter])\n                if address == nil {\n                    panic(\"The address input is not a valid name nor address. Input : \".concat(users[counter]))\n                }\n                addresses[users[counter]] = address!\n                resolveAddress = address!\n            }\n            let address = resolveAddress!\n            let saleItemCap = FindMarketSale.getSaleItemCapability(marketplace: marketplace, user:address) ?? panic(\"cannot find sale item cap\")\n            self.saleItemsCap.append(saleItemCap)\n\n            let item= FindMarket.assertOperationValid(tenant: marketplace, address: address, marketOption: marketOption, id: ids[counter])\n\n            self.prices.append(item.getBalance())\n            if self.prices[counter] != amounts[counter] {\n                panic(\"Please pass in the correct amount for item. saleID : \".concat(ids[counter].toString()).concat(\" . Required : \".concat(self.prices[counter].toString())))\n            }\n\n            var nft : NFTCatalog.NFTCollectionData? = nil\n            let nftIdentifier = item.getItemType().identifier\n            let ftType = item.getFtType()\n\n            if nfts[nftIdentifier] != nil {\n                nft = nfts[nftIdentifier]\n            } else {\n                let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier)) \n                let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n                nft =  collection.collectionData\n                nfts[nftIdentifier] = nft\n            }\n            \n            if ftType != Type\u003c@DapperUtilityCoin.Vault\u003e() {\n                panic(\"This item is not listed for Dapper Wallets. Please buy in with other wallets.\")\n            }\n\n            var targetCapability= account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(nft!.publicPath)\n            /* Check for nftCapability */\n            if !targetCapability.check() {\n                let cd = item.getNFTCollectionData()\n                // should use account.type here instead\n                if account.type(at: cd.storagePath) != nil {\n                    let pathIdentifier = nft!.publicPath.toString()\n                    let findPath = PublicPath(identifier: pathIdentifier.slice(from: \"/public/\".length , upTo: pathIdentifier.length).concat(\"_FIND\"))!\n                    account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                        findPath,\n                        target: nft!.storagePath\n                    )\n                    targetCapability = account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(findPath)\n                } else {\n                    account.save(\u003c- cd.createEmptyCollection(), to: cd.storagePath)\n                    account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.publicPath, target: cd.storagePath)\n                    account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.providerPath, target: cd.storagePath)\n                }\n\n            }\n            self.targetCapability.append(targetCapability)\n            counter = counter + 1\n        }\n    }\n\n    execute {\n        var counter = 0 \n        while counter \u003c ids.length {\n            if self.walletReference!.balance \u003c amounts[counter] {\n                panic(\"Your wallet does not have enough funds to pay for this item. Required : \".concat(self.totalPrice.toString()))\n            }\n            let vault \u003c- self.walletReference!.withdraw(amount: self.prices[counter]) \n            self.saleItemsCap[counter].borrow()!.buy(id:ids[counter], vault: \u003c- vault, nftCap: self.targetCapability[counter])\n            counter = counter + 1\n        }\n    }\n\n    // Check that all dapperUtilityCoin was routed back to Dapper\n    post {\n        self.walletReference.balance == self.balanceBeforeTransfer: \"DapperUtilityCoin leakage\"\n    }\n}",
               "spec": {
                  "order": [
                     "dapperAddress",
                     "marketplace",
                     "users",
                     "ids",
                     "amounts"
                  ],
                  "parameters": {
                     "amounts": "[UFix64]",
                     "dapperAddress": "Address",
                     "ids": "[UInt64]",
                     "marketplace": "Address",
                     "users": "[String]"
                  }
               }
            },
            "buyNFTForSale": {
               "code": "import FindMarket from 0x097bafa4e0b48eef\nimport FindMarketSale from 0x097bafa4e0b48eef\nimport FindMarketAuctionEscrow from 0x097bafa4e0b48eef\nimport FindMarketAuctionSoft from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferEscrow from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferSoft from 0x097bafa4e0b48eef\nimport NonFungibleToken from 0x1d7e57aa55817448\nimport MetadataViews from 0x1d7e57aa55817448\nimport NFTCatalog from 0x49a7cda3a1eecc29\nimport FINDNFTCatalog from 0x097bafa4e0b48eef\nimport FTRegistry from 0x097bafa4e0b48eef\nimport FungibleToken from 0xf233dcee88fe0abe\nimport FUSD from 0x3c5959b568896393\nimport FiatToken from 0xb19436aae4d94622\nimport FlowToken from 0x1654653399040a61\nimport FIND from 0x097bafa4e0b48eef\nimport Dandy from 0x097bafa4e0b48eef\nimport Profile from 0x097bafa4e0b48eef\nimport FindLeaseMarketSale from 0x097bafa4e0b48eef\nimport FindLeaseMarketAuctionSoft from 0x097bafa4e0b48eef\n// import FindLeaseMarketAuctionEscrow from \"../contracts/FindLeaseMarketAuctionEscrow.cdc\"\nimport FindLeaseMarketDirectOfferSoft from 0x097bafa4e0b48eef\n// import FindLeaseMarketDirectOfferEscrow from \"../contracts/FindLeaseMarketDirectOfferEscrow.cdc\"\nimport FindLeaseMarket from 0x097bafa4e0b48eef\n\ntransaction(marketplace:Address, user: String, id: UInt64, amount: UFix64) {\n\n    var targetCapability : Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e\n    let walletReference : \u0026FungibleToken.Vault\n\n    let saleItemsCap: Capability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic}\u003e \n\n    prepare(account: AuthAccount) {\n\n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n        //SYNC with register\n        //Add exising FUSD or create a new one and add it\n        let name = account.address.toString()\n        let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n        if !fusdReceiver.check() {\n            let fusd \u003c- FUSD.createEmptyVault()\n            account.save(\u003c- fusd, to: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n        }\n\n        let usdcCap = account.getCapability\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e(FiatToken.VaultReceiverPubPath)\n        if !usdcCap.check() {\n                account.save( \u003c-FiatToken.createEmptyVault(), to: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e( FiatToken.VaultReceiverPubPath, target: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FiatToken.ResourceId}\u003e( FiatToken.VaultUUIDPubPath, target: FiatToken.VaultStoragePath)\n                account.link\u003c\u0026FiatToken.Vault{FungibleToken.Balance}\u003e( FiatToken.VaultBalancePubPath, target:FiatToken.VaultStoragePath)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let dandyCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        let dandyCapPrivate= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPrivatePath)\n        if !dandyCapPrivate.check() {\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        var created=false\n        var updated=false\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        if !profile.hasWallet(\"Flow\") {\n            let flowWallet=Profile.Wallet( name:\"Flow\", receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), tags: [\"flow\"])\n    \n            profile.addWallet(flowWallet)\n            updated=true\n        }\n        if !profile.hasWallet(\"FUSD\") {\n            profile.addWallet(Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), tags: [\"fusd\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if !profile.hasWallet(\"USDC\") {\n            profile.addWallet(Profile.Wallet( name:\"USDC\", receiver:usdcCap, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(FiatToken.VaultBalancePubPath), accept: Type\u003c@FiatToken.Vault\u003e(), tags: [\"usdc\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else if updated {\n            profile.emitUpdatedEvent()\n        }\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        let doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        let doeSalePublicPath=FindMarket.getPublicPath(doeSaleType, name: tenant.name)\n        let doeSaleStoragePath= FindMarket.getStoragePath(doeSaleType, name:tenant.name)\n        let doeSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n        if !doeSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n        }\n\n        let doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        let doeBidPublicPath=FindMarket.getPublicPath(doeBidType, name: tenant.name)\n        let doeBidStoragePath= FindMarket.getStoragePath(doeBidType, name:tenant.name)\n        let doeBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n        if !doeBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n        }\n\n        /// auctions that escrow ft\n        let aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        let aeSalePublicPath=FindMarket.getPublicPath(aeSaleType, name: tenant.name)\n        let aeSaleStoragePath= FindMarket.getStoragePath(aeSaleType, name:tenant.name)\n        let aeSaleCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n        if !aeSaleCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n        }\n\n        let dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\n        let dosSalePublicPath=FindMarket.getPublicPath(dosSaleType, name: tenant.name)\n        let dosSaleStoragePath= FindMarket.getStoragePath(dosSaleType, name:tenant.name)\n\n        let dosSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n        if !dosSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n        }\n\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n        if !dosBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n        }\n\n        let aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\n        let aeBidPublicPath=FindMarket.getPublicPath(aeBidType, name: tenant.name)\n        let aeBidStoragePath= FindMarket.getStoragePath(aeBidType, name:tenant.name)\n        let aeBidCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n        if !aeBidCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n        }\n\n     /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n        }\n\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n        if !asBidCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n        }\n\n        let leaseTenantCapability= FindMarket.getTenantCapability(FindMarket.getTenantAddress(\"findLease\")!)!\n\n        let leaseSaleItemType= Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()\n        let leasePublicPath=FindMarket.getPublicPath(leaseSaleItemType, name: \"findLease\")\n        let leaseStoragePath= FindMarket.getStoragePath(leaseSaleItemType, name:\"findLease\")\n        let leaseSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath) \n        if !leaseSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketSale.SaleItemCollection\u003e(\u003c- FindLeaseMarketSale.createEmptySaleItemCollection(leaseTenantCapability), to: leaseStoragePath)\n            account.link\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath, target: leaseStoragePath)\n        }\n\n        let leaseASSaleItemType= Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e()\n        let leaseASPublicPath=FindMarket.getPublicPath(leaseASSaleItemType, name: \"findLease\")\n        let leaseASStoragePath= FindMarket.getStoragePath(leaseASSaleItemType, name:\"findLease\")\n        let leaseASSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath) \n        if !leaseASSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseASStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath, target: leaseASStoragePath)\n        }\n\n\n        let leaseASBidType= Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e()\n        let leaseASBidPublicPath=FindMarket.getPublicPath(leaseASBidType, name: \"findLease\")\n        let leaseASBidStoragePath= FindMarket.getStoragePath(leaseASBidType, name: \"findLease\")\n        let leaseASBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath) \n        if !leaseASBidCap.check() {\n            account.save\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseASBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath, target: leaseASBidStoragePath)\n        }\n\n        // let leaseAESaleItemType= Type\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e()\n        // let leaseAEPublicPath=FindMarket.getPublicPath(leaseAESaleItemType, name: \"findLease\")\n        // let leaseAEStoragePath= FindMarket.getStoragePath(leaseAESaleItemType, name:\"findLease\")\n        // let leaseAESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath) \n        // if !leaseAESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseAEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath, target: leaseAEStoragePath)\n        // }\n\n        // let leaseAEBidType= Type\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e()\n        // let leaseAEBidPublicPath=FindMarket.getPublicPath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidStoragePath= FindMarket.getStoragePath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath) \n        // if !leaseAEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseAEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath, target: leaseAEBidStoragePath)\n        // }\n\n        let leaseDOSSaleItemType= Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e()\n        let leaseDOSPublicPath=FindMarket.getPublicPath(leaseDOSSaleItemType, name: \"findLease\")\n        let leaseDOSStoragePath= FindMarket.getStoragePath(leaseDOSSaleItemType, name:\"findLease\")\n        let leaseDOSSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath) \n        if !leaseDOSSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOSStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath, target: leaseDOSStoragePath)\n        }\n\n        let leaseDOSBidType= Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let leaseDOSBidPublicPath=FindMarket.getPublicPath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidStoragePath= FindMarket.getStoragePath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath) \n        if !leaseDOSBidCap.check() {\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOSBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath, target: leaseDOSBidStoragePath)\n        }\n\n        // let leaseDOESaleItemType= Type\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        // let leaseDOEPublicPath=FindMarket.getPublicPath(leaseDOESaleItemType, name: \"findLease\")\n        // let leaseDOEStoragePath= FindMarket.getStoragePath(leaseDOESaleItemType, name:\"findLease\")\n        // let leaseDOESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath) \n        // if !leaseDOESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath, target: leaseDOEStoragePath)\n        // }\n\n        // let leaseDOEBidType= Type\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        // let leaseDOEBidPublicPath=FindMarket.getPublicPath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidStoragePath= FindMarket.getStoragePath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath) \n        // if !leaseDOEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath, target: leaseDOEBidStoragePath)\n        // }\n        //SYNC with register\n\n        let resolveAddress = FIND.resolve(user)\n        if resolveAddress == nil {\n            panic(\"The address input is not a valid name nor address. Input : \".concat(user))\n        }\n        let address = resolveAddress!\n        self.saleItemsCap= FindMarketSale.getSaleItemCapability(marketplace: marketplace, user:address) ?? panic(\"cannot find sale item cap\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketSale.SaleItemCollection\u003e())\n\n        let item= FindMarket.assertOperationValid(tenant: marketplace, address: address, marketOption: marketOption, id: id)\n\n        let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: item.getItemType().identifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(item.getItemType().identifier)) \n        let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n        let nft = collection.collectionData\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n    \n        self.targetCapability= account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(nft.publicPath)\n        /* Check for nftCapability */\n        if !self.targetCapability.check() {\n            let cd = item.getNFTCollectionData()\n            // should use account.type here instead\n            if account.type(at: cd.storagePath) != nil {\n                let pathIdentifier = nft.publicPath.toString()\n                let findPath = PublicPath(identifier: pathIdentifier.slice(from: \"/public/\".length , upTo: pathIdentifier.length).concat(\"_FIND\"))!\n                account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                    findPath,\n                    target: nft.storagePath\n                )\n                self.targetCapability = account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(findPath)\n            } else {\n                account.save(\u003c- cd.createEmptyCollection(), to: cd.storagePath)\n                account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.publicPath, target: cd.storagePath)\n                account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.providerPath, target: cd.storagePath)\n            }\n\n        }\n\n        self.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n    }\n\n    pre {\n        self.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount) \n        self.saleItemsCap.borrow()!.buy(id:id, vault: \u003c- vault, nftCap: self.targetCapability)\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "user",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64",
                     "marketplace": "Address",
                     "user": "String"
                  }
               }
            },
            "buyNFTForSaleDUC": {
               "code": "import FindMarket from 0x097bafa4e0b48eef\nimport Profile from 0x097bafa4e0b48eef\nimport FindMarketSale from 0x097bafa4e0b48eef\nimport NFTCatalog from 0x49a7cda3a1eecc29\nimport FINDNFTCatalog from 0x097bafa4e0b48eef\nimport FTRegistry from 0x097bafa4e0b48eef\nimport NonFungibleToken from 0x1d7e57aa55817448\nimport MetadataViews from 0x1d7e57aa55817448\nimport FungibleToken from 0xf233dcee88fe0abe\nimport TokenForwarding from 0xe544175ee0461c4b\nimport DapperUtilityCoin from 0xead892083b3e2c6c\n\n//first argument is the address to the merchant that gets the funds\ntransaction(merchantAddress: Address, marketplace:Address, address: Address, id: UInt64, amount: UFix64) {\n\n    let targetCapability : Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e\n    let walletReference : \u0026FungibleToken.Vault\n\n    let saleItemsCap: Capability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic}\u003e \n    let balanceBeforeTransfer: UFix64\n    prepare(dapper: AuthAccount, account: AuthAccount) {\n\n        let name = account.address.toString()\n        let ducReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver)\n        if !ducReceiver.check() {\n            // Create a new Forwarder resource for DUC and store it in the new account's storage\n            let ducForwarder \u003c- TokenForwarding.createNewForwarder(recipient: dapper.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver))\n            account.save(\u003c-ducForwarder, to: /storage/dapperUtilityCoinReceiver)\n            // Publish a Receiver capability for the new account, which is linked to the DUC Forwarder\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver,target: /storage/dapperUtilityCoinReceiver)\n        }\n        \n        var created=false\n        var updated=false\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        if !profile.hasWallet(\"DUC\") {\n            updated=true\n            profile.addWallet(Profile.Wallet( name:\"DUC\", receiver:ducReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/dapperUtilityCoinBalance), accept: Type\u003c@DapperUtilityCoin.Vault\u003e(), tags: [\"duc\", \"dapperUtilityCoin\",\"dapper\"]))\n            updated=true\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else {\n            profile.emitUpdatedEvent()\n        }\n\n\n        if created {\n            profile.emitCreatedEvent()\n        } else if updated {\n            profile.emitUpdatedEvent()\n        }\n\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        self.saleItemsCap= FindMarketSale.getSaleItemCapability(marketplace: marketplace, user:address) ?? panic(\"cannot find sale item cap\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketSale.SaleItemCollection\u003e())\n    \n        //we do some security check to verify that this tenant can do this operation. This will ensure that the onefootball tenant can only sell using DUC and not some other token. But we can change this with transactions later and not have to modify code/transactions\n        let item= FindMarket.assertOperationValid(tenant: marketplace, address: address, marketOption: marketOption, id: id)\n   let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: item.getItemType().identifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(item.getItemType().identifier))\n        let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n        let nft = collection.collectionData\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n    \n        if ft.type != Type\u003c@DapperUtilityCoin.Vault\u003e() {\n            panic(\"This item is not listed for Dapper Wallets. Please buy in with other wallets.\")\n        }\n\n\n        self.targetCapability= account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(nft.publicPath)\n\n        if !self.targetCapability.check() {\n            let cd = item.getNFTCollectionData()\n            if account.borrow\u003c\u0026AnyResource\u003e(from: cd.storagePath) != nil {\n                panic(\"This collection public link is not set up properly.\")\n            }\n            account.save(\u003c- cd.createEmptyCollection(), to: cd.storagePath)\n            account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.publicPath, target: cd.storagePath)\n            account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.providerPath, target: cd.storagePath)\n        }\n\n        self.walletReference = dapper.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n        self.balanceBeforeTransfer = self.walletReference.balance\n    }\n\n    pre {\n        self.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount) \n        self.saleItemsCap.borrow()!.buy(id:id, vault: \u003c- vault, nftCap: self.targetCapability)\n    }\n\n    // Check that all dapperUtilityCoin was routed back to Dapper\n    post {\n        self.walletReference.balance == self.balanceBeforeTransfer: \"DapperUtilityCoin leakage\"\n    }\n}",
               "spec": {
                  "order": [
                     "merchantAddress",
                     "marketplace",
                     "address",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "address": "Address",
                     "amount": "UFix64",
                     "id": "UInt64",
                     "marketplace": "Address",
                     "merchantAddress": "Address"
                  }
               }
            },
            "cancelAllLeaseMarketAuctionSoft": {
               "code": "import FindMarket from 0x097bafa4e0b48eef\nimport FindLeaseMarketAuctionSoft from 0x097bafa4e0b48eef\n\ntransaction() {\n\n    let saleItems : \u0026FindLeaseMarketAuctionSoft.SaleItemCollection?\n\n    prepare(account: AuthAccount) {\n        let leaseMarketplace = FindMarket.getTenantAddress(\"findLease\")!\n        let tenant = FindMarket.getTenant(leaseMarketplace)\n        self.saleItems= account.borrow\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e()))\n\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to the saleItem.\"\n    }\n\n    execute {\n        let leaseNames = self.saleItems!.getNameSales()\n        for lease in leaseNames {\n            self.saleItems!.cancel(lease)\n        }\n    }\n}",
               "spec": {
                  "order": [],
                  "parameters": {}
               }
            },
            "cancelAllLeaseMarketDirectOfferSoft": {
               "code": "import FindMarket from 0x097bafa4e0b48eef\nimport FindLeaseMarketDirectOfferSoft from 0x097bafa4e0b48eef\n\ntransaction() {\n\n    let saleItems : \u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection?\n\n    prepare(account: AuthAccount) {\n\n        let marketplace = FindMarket.getTenantAddress(\"findLease\")!\n        let tenant=FindMarket.getTenant(marketplace)\n        self.saleItems= account.borrow\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e()))\n\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to saleItem.\"\n    }\n\n    execute{\n        let nameLeases = self.saleItems!.getNameSales()\n        for nameLease in nameLeases {\n            self.saleItems!.cancel(nameLease)\n        }\n    }\n\n}",
               "spec": {
                  "order": [],
                  "parameters": {}
               }
            },
            "cancelAllMarketAuctionEscrowed": {
               "code": "import FindMarket from 0x097bafa4e0b48eef\nimport FindMarketAuctionEscrow from 0x097bafa4e0b48eef\n\ntransaction(marketplace:Address) {\n\n    let saleItems : \u0026FindMarketAuctionEscrow.SaleItemCollection?\n\n    prepare(account: AuthAccount) {\n        let tenant = FindMarket.getTenant(marketplace)\n        self.saleItems= account.borrow\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()))\n\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to the saleItem capability.\"\n    }\n\n    execute {\n        let ids = self.saleItems!.getIds()\n        for id in ids {\n            self.saleItems!.cancel(id)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace"
                  ],
                  "parameters": {
                     "marketplace": "Address"
                  }
               }
            },
            "cancelAllMarketAuctionSoft": {
               "code": "import FindMarket from 0x097bafa4e0b48eef\nimport FindMarketAuctionSoft from 0x097bafa4e0b48eef\n\ntransaction(marketplace:Address) {\n\n    let saleItems : \u0026FindMarketAuctionSoft.SaleItemCollection?\n\n    prepare(account: AuthAccount) {\n        let tenant = FindMarket.getTenant(marketplace)\n        self.saleItems= account.borrow\u003c\u0026FindMarketAuctionSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()))\n\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to the saleItem.\"\n    }\n\n    execute {\n        let ids = self.saleItems!.getIds()\n        for id in ids {\n            self.saleItems!.cancel(id)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace"
                  ],
                  "parameters": {
                     "marketplace": "Address"
                  }
               }
            },
            "cancelAllMarketDirectOfferEscrowed": {
               "code": "import FindMarket from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferEscrow from 0x097bafa4e0b48eef\n\ntransaction(marketplace:Address) {\n\n    let saleItems : \u0026FindMarketDirectOfferEscrow.SaleItemCollection?\n\n    prepare(account: AuthAccount) {\n\n        let tenant=FindMarket.getTenant(marketplace)\n        self.saleItems= account.borrow\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()))\n\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to saleItem.\"\n    }\n\n    execute{\n        let ids = self.saleItems!.getIds()\n        for id in ids {\n            self.saleItems!.cancel(id)\n        }\n    }\n\n}",
               "spec": {
                  "order": [
                     "marketplace"
                  ],
                  "parameters": {
                     "marketplace": "Address"
                  }
               }
            },
            "cancelAllMarketDirectOfferSoft": {
               "code": "import FindMarket from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferSoft from 0x097bafa4e0b48eef\n\ntransaction(marketplace:Address) {\n\n    let saleItems : \u0026FindMarketDirectOfferSoft.SaleItemCollection?\n\n    prepare(account: AuthAccount) {\n\n        let tenant=FindMarket.getTenant(marketplace)\n        self.saleItems= account.borrow\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()))\n\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to saleItem.\"\n    }\n\n    execute{\n        let ids = self.saleItems!.getIds()\n        for id in ids {\n            self.saleItems!.cancel(id)\n        }\n    }\n\n}",
               "spec": {
                  "order": [
                     "marketplace"
                  ],
                  "parameters": {
                     "marketplace": "Address"
                  }
               }
            },
            "cancelAllMarketListings": {
               "code": "import FindMarket from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferEscrow from 0x097bafa4e0b48eef\nimport FindMarketAuctionEscrow from 0x097bafa4e0b48eef\nimport FindMarketAuctionSoft from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferSoft from 0x097bafa4e0b48eef\nimport FindMarketSale from 0x097bafa4e0b48eef\n\ntransaction(marketplace:Address) {\n    prepare(account: AuthAccount) {\n\n        let tenant=FindMarket.getTenant(marketplace)\n\n        let saleItems= account.borrow\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()))!\n        var ids = saleItems.getIds()\n        for id in ids {\n            saleItems.cancel(id)\n        }\n\n        let saleItem2= account.borrow\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()))!\n        ids = saleItem2.getIds()\n        for id in ids {\n            saleItem2.cancel(id)\n        }\n\n        let saleItems3= account.borrow\u003c\u0026FindMarketAuctionSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()))!\n        ids = saleItems3.getIds()\n        for id in ids {\n            saleItems3.cancel(id)\n        }\n\n        let saleItems4= account.borrow\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()))!\n        ids = saleItems4.getIds()\n        for id in ids {\n            saleItems4.cancel(id)\n        }\n\n        let saleItems5= account.borrow\u003c\u0026FindMarketSale.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketSale.SaleItemCollection\u003e()))!\n        ids = saleItems5.getIds()\n        for id in ids {\n            saleItems5.delist(id)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace"
                  ],
                  "parameters": {
                     "marketplace": "Address"
                  }
               }
            },
            "cancelLeaseMarketAuctionSoft": {
               "code": "import FindMarket from 0x097bafa4e0b48eef\nimport FindLeaseMarketAuctionSoft from 0x097bafa4e0b48eef\n\ntransaction(leaseNames: [String]) {\n\n    let saleItems : \u0026FindLeaseMarketAuctionSoft.SaleItemCollection?\n\n    prepare(account: AuthAccount) {\n        let marketplace = FindMarket.getTenantAddress(\"findLease\")!\n        let tenant=FindMarket.getTenant(marketplace)\n        self.saleItems= account.borrow\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e()))\n    }\n\n    pre{\n        self.saleItems != nil \n    }\n\n    execute{\n        for leaseName in leaseNames {\n            self.saleItems!.cancel(leaseName)\n        }\n    }\n\n}",
               "spec": {
                  "order": [
                     "leaseNames"
                  ],
                  "parameters": {
                     "leaseNames": "[String]"
                  }
               }
            },
            "cancelLeaseMarketDirectOfferSoft": {
               "code": "import FindMarket from 0x097bafa4e0b48eef\nimport FindLeaseMarketDirectOfferSoft from 0x097bafa4e0b48eef\n\ntransaction(leaseNames: [String]) {\n\n    let saleItems : \u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection?\n\n    prepare(account: AuthAccount) {\n        let marketplace = FindMarket.getTenantAddress(\"findLease\")!\n        let tenant=FindMarket.getTenant(marketplace)\n        self.saleItems= account.borrow\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e()))\n\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute {\n        for leaseName in leaseNames {\n            self.saleItems!.cancel(leaseName)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "leaseNames"
                  ],
                  "parameters": {
                     "leaseNames": "[String]"
                  }
               }
            },
            "cancelMarketAuctionEscrowed": {
               "code": "import FindMarket from 0x097bafa4e0b48eef\nimport FindMarketAuctionEscrow from 0x097bafa4e0b48eef\n\ntransaction(marketplace:Address, ids: [UInt64]) {\n\n    let saleItems : \u0026FindMarketAuctionEscrow.SaleItemCollection?\n\n    prepare(account: AuthAccount) {\n\n        let tenant=FindMarket.getTenant(marketplace)\n        self.saleItems= account.borrow\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()))\n\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        for id in ids {\n            self.saleItems!.cancel(id)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "ids"
                  ],
                  "parameters": {
                     "ids": "[UInt64]",
                     "marketplace": "Address"
                  }
               }
            },
            "cancelMarketAuctionSoft": {
               "code": "import FindMarket from 0x097bafa4e0b48eef\nimport FindMarketAuctionSoft from 0x097bafa4e0b48eef\n\ntransaction(marketplace:Address, ids: [UInt64]) {\n\n    let saleItems : \u0026FindMarketAuctionSoft.SaleItemCollection?\n\n    prepare(account: AuthAccount) {\n        let tenant=FindMarket.getTenant(marketplace)\n        self.saleItems= account.borrow\u003c\u0026FindMarketAuctionSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()))\n    }\n\n    pre{\n        self.saleItems != nil \n    }\n\n    execute{\n        for id in ids {\n            self.saleItems!.cancel(id)\n        }\n    }\n\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "ids"
                  ],
                  "parameters": {
                     "ids": "[UInt64]",
                     "marketplace": "Address"
                  }
               }
            },
            "cancelMarketDirectOfferEscrowed": {
               "code": "import FindMarket from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferEscrow from 0x097bafa4e0b48eef\n\ntransaction(marketplace:Address, ids: [UInt64]) {\n\n    let saleItems : \u0026FindMarketDirectOfferEscrow.SaleItemCollection?\n\n    prepare(account: AuthAccount) {\n\n        let tenant=FindMarket.getTenant(marketplace)\n        self.saleItems= account.borrow\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()))\n\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        for id in ids {\n            self.saleItems!.cancel(id)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "ids"
                  ],
                  "parameters": {
                     "ids": "[UInt64]",
                     "marketplace": "Address"
                  }
               }
            },
            "cancelMarketDirectOfferSoft": {
               "code": "import FindMarket from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferSoft from 0x097bafa4e0b48eef\n\ntransaction(marketplace:Address, ids: [UInt64]) {\n\n    let saleItems : \u0026FindMarketDirectOfferSoft.SaleItemCollection?\n\n    prepare(account: AuthAccount) {\n\n        let tenant=FindMarket.getTenant(marketplace)\n        self.saleItems= account.borrow\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()))\n\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute {\n        for id in ids {\n            self.saleItems!.cancel(id)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "ids"
                  ],
                  "parameters": {
                     "ids": "[UInt64]",
                     "marketplace": "Address"
                  }
               }
            },
            "cancelMarketListings": {
               "code": "import FindMarket from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferEscrow from 0x097bafa4e0b48eef\nimport FindMarketAuctionEscrow from 0x097bafa4e0b48eef\nimport FindMarketAuctionSoft from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferSoft from 0x097bafa4e0b48eef\nimport FindMarketSale from 0x097bafa4e0b48eef\n\ntransaction(marketplace:Address, ids: {String : [UInt64]}) {\n    prepare(account: AuthAccount) {\n\n        let tenant=FindMarket.getTenant(marketplace)\n\n        var saleType = Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        if let ids = ids[FindMarket.getMarketOptionFromType(saleType)] {\n            let saleItems= account.borrow\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection\u003e(from: tenant.getStoragePath(saleType))!\n            for id in ids {\n                saleItems.cancel(id)\n            }\n        }\n\n        saleType = Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        if let ids = ids[FindMarket.getMarketOptionFromType(saleType)] {\n            let saleItems= account.borrow\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection\u003e(from: tenant.getStoragePath(saleType))!\n            for id in ids {\n                saleItems.cancel(id)\n            }\n        }\n\n        saleType = Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        if let ids = ids[FindMarket.getMarketOptionFromType(saleType)] {\n            let saleItems= account.borrow\u003c\u0026FindMarketAuctionSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(saleType))!\n            for id in ids {\n                saleItems.cancel(id)\n            }\n        }\n\n        saleType = Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n        if let ids = ids[FindMarket.getMarketOptionFromType(saleType)] {\n            let saleItems= account.borrow\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(saleType))!\n            for id in ids {\n                saleItems.cancel(id)\n            }\n        }\n\n        saleType = Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        if let ids = ids[FindMarket.getMarketOptionFromType(saleType)] {\n            let saleItems= account.borrow\u003c\u0026FindMarketSale.SaleItemCollection\u003e(from: tenant.getStoragePath(saleType))!\n            for id in ids {\n                saleItems.delist(id)\n            }\n        }\n\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "ids"
                  ],
                  "parameters": {
                     "ids": "{String: [UInt64]}",
                     "marketplace": "Address"
                  }
               }
            },
            "cancelNameAuction": {
               "code": "import FIND from 0x097bafa4e0b48eef\n\ntransaction(names: [String]) {\n\n    let finLeases : \u0026FIND.LeaseCollection?\n\n    prepare(account: AuthAccount) {\n        self.finLeases= account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)\n    }\n\n    pre{\n        self.finLeases != nil : \"Cannot borrow reference to find leases collection\"\n    }\n\n    execute {\n        for name in names {\n            self.finLeases!.cancel(name)\n            self.finLeases!.delistAuction(name)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "names"
                  ],
                  "parameters": {
                     "names": "[String]"
                  }
               }
            },
            "cancelNameBid": {
               "code": "import FIND from 0x097bafa4e0b48eef\n\ntransaction(names: [String]) {\n\n    let bids : \u0026FIND.BidCollection?\n\n    prepare(account: AuthAccount) {\n        self.bids = account.borrow\u003c\u0026FIND.BidCollection\u003e(from: FIND.BidStoragePath)\n    }\n\n    pre{\n        self.bids != nil : \"Cannot borrow reference to find bid collection\"\n    }\n\n    execute {\n        for name in names {\n            self.bids!.cancelBid(name)\n        }\n    }\n\n}",
               "spec": {
                  "order": [
                     "names"
                  ],
                  "parameters": {
                     "names": "[String]"
                  }
               }
            },
            "createCharity": {
               "code": "import NonFungibleToken from 0x1d7e57aa55817448\nimport MetadataViews from 0x1d7e57aa55817448\nimport CharityNFT from 0x097bafa4e0b48eef\n\n//This transaction will prepare the art collection\ntransaction() {\n    prepare(account: AuthAccount) {\n\n        let stdCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath)\n        if !stdCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- CharityNFT.createEmptyCollection(), to: CharityNFT.CollectionStoragePath)\n            account.link\u003c\u0026{NonFungibleToken.CollectionPublic, MetadataViews.ResolverCollection}\u003e(CharityNFT.CollectionPublicPath, target: CharityNFT.CollectionStoragePath)\n        }\n\n        let charityCap = account.getCapability\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection)\n        if !charityCap.check() {\n            account.link\u003c\u0026{CharityNFT.CollectionPublic, MetadataViews.ResolverCollection}\u003e(/public/findCharityNFTCollection, target: CharityNFT.CollectionStoragePath)\n        }\n    }\n}",
               "spec": {
                  "order": [],
                  "parameters": {}
               }
            },
            "createProfile": {
               "code": "import FungibleToken from 0xf233dcee88fe0abe\nimport NonFungibleToken from 0x1d7e57aa55817448\nimport FUSD from 0x3c5959b568896393\nimport FiatToken from 0xb19436aae4d94622\nimport FlowToken from 0x1654653399040a61\nimport MetadataViews from 0x1d7e57aa55817448\nimport FIND from 0x097bafa4e0b48eef\nimport Profile from 0x097bafa4e0b48eef\nimport FindMarket from 0x097bafa4e0b48eef\nimport FindMarketSale from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferEscrow from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferSoft from 0x097bafa4e0b48eef\nimport FindMarketAuctionEscrow from 0x097bafa4e0b48eef\nimport FindMarketAuctionSoft from 0x097bafa4e0b48eef\nimport Dandy from 0x097bafa4e0b48eef\nimport FindLeaseMarketSale from 0x097bafa4e0b48eef\nimport FindLeaseMarketAuctionSoft from 0x097bafa4e0b48eef\n// import FindLeaseMarketAuctionEscrow from \"../contracts/FindLeaseMarketAuctionEscrow.cdc\"\nimport FindLeaseMarketDirectOfferSoft from 0x097bafa4e0b48eef\n// import FindLeaseMarketDirectOfferEscrow from \"../contracts/FindLeaseMarketDirectOfferEscrow.cdc\"\nimport FindLeaseMarket from 0x097bafa4e0b48eef\n\ntransaction(name: String) {\n    prepare(account: AuthAccount) {\n        //if we do not have a profile it might be stored under a different address so we will just remove it\n        let profileCapFirst = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if profileCapFirst.check() {\n            return \n        }\n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n        //SYNC with register\n        //Add exising FUSD or create a new one and add it\n        let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n        if !fusdReceiver.check() {\n            let fusd \u003c- FUSD.createEmptyVault()\n            account.save(\u003c- fusd, to: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n        }\n\n        let usdcCap = account.getCapability\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e(FiatToken.VaultReceiverPubPath)\n        if !usdcCap.check() {\n                account.save( \u003c-FiatToken.createEmptyVault(), to: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e( FiatToken.VaultReceiverPubPath, target: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FiatToken.ResourceId}\u003e( FiatToken.VaultUUIDPubPath, target: FiatToken.VaultStoragePath)\n                account.link\u003c\u0026FiatToken.Vault{FungibleToken.Balance}\u003e( FiatToken.VaultBalancePubPath, target:FiatToken.VaultStoragePath)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let dandyCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        var created=false\n        var updated=false\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        if !profile.hasWallet(\"Flow\") {\n            let flowWallet=Profile.Wallet( name:\"Flow\", receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), tags: [\"flow\"])\n    \n            profile.addWallet(flowWallet)\n            updated=true\n        }\n        if !profile.hasWallet(\"FUSD\") {\n            profile.addWallet(Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), tags: [\"fusd\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if !profile.hasWallet(\"USDC\") {\n            profile.addWallet(Profile.Wallet( name:\"USDC\", receiver:usdcCap, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(FiatToken.VaultBalancePubPath), accept: Type\u003c@FiatToken.Vault\u003e(), tags: [\"usdc\", \"stablecoin\"]))\n            updated=true\n        }\n\n         //If find name not set and we have a profile set it.\n        if profile.getFindName() == \"\" {\n            if let findName = FIND.reverseLookup(account.address) {\n                profile.setFindName(findName)\n                // If name is set, it will emit Updated Event, there is no need to emit another update event below. \n                updated=false\n            }\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else if updated {\n            profile.emitUpdatedEvent()\n        }\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let tenantCapability= FindMarket.getTenantCapability(FindMarket.getFindTenantAddress())!\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        let doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        let doeSalePublicPath=FindMarket.getPublicPath(doeSaleType, name: tenant.name)\n        let doeSaleStoragePath= FindMarket.getStoragePath(doeSaleType, name:tenant.name)\n        let doeSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n        if !doeSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n        }\n\n        let doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        let doeBidPublicPath=FindMarket.getPublicPath(doeBidType, name: tenant.name)\n        let doeBidStoragePath= FindMarket.getStoragePath(doeBidType, name:tenant.name)\n        let doeBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n        if !doeBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n        }\n\n        /// auctions that escrow ft\n        let aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        let aeSalePublicPath=FindMarket.getPublicPath(aeSaleType, name: tenant.name)\n        let aeSaleStoragePath= FindMarket.getStoragePath(aeSaleType, name:tenant.name)\n        let aeSaleCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n        if !aeSaleCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n        }\n\n        let dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\n        let dosSalePublicPath=FindMarket.getPublicPath(dosSaleType, name: tenant.name)\n        let dosSaleStoragePath= FindMarket.getStoragePath(dosSaleType, name:tenant.name)\n\n        let dosSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n        if !dosSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n        }\n\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n        if !dosBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n        }\n\n        let aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\n        let aeBidPublicPath=FindMarket.getPublicPath(aeBidType, name: tenant.name)\n        let aeBidStoragePath= FindMarket.getStoragePath(aeBidType, name:tenant.name)\n        let aeBidCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n        if !aeBidCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n        }\n\n     /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n        }\n\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n        if !asBidCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n        }\n\n        let leaseTenantCapability= FindMarket.getTenantCapability(FindMarket.getTenantAddress(\"findLease\")!)!\n\n        let leaseSaleItemType= Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()\n        let leasePublicPath=FindMarket.getPublicPath(leaseSaleItemType, name: \"findLease\")\n        let leaseStoragePath= FindMarket.getStoragePath(leaseSaleItemType, name:\"findLease\")\n        let leaseSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath) \n        if !leaseSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketSale.SaleItemCollection\u003e(\u003c- FindLeaseMarketSale.createEmptySaleItemCollection(leaseTenantCapability), to: leaseStoragePath)\n            account.link\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath, target: leaseStoragePath)\n        }\n\n        let leaseASSaleItemType= Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e()\n        let leaseASPublicPath=FindMarket.getPublicPath(leaseASSaleItemType, name: \"findLease\")\n        let leaseASStoragePath= FindMarket.getStoragePath(leaseASSaleItemType, name:\"findLease\")\n        let leaseASSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath) \n        if !leaseASSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseASStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath, target: leaseASStoragePath)\n        }\n\n\n        let leaseASBidType= Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e()\n        let leaseASBidPublicPath=FindMarket.getPublicPath(leaseASBidType, name: \"findLease\")\n        let leaseASBidStoragePath= FindMarket.getStoragePath(leaseASBidType, name: \"findLease\")\n        let leaseASBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath) \n        if !leaseASBidCap.check() {\n            account.save\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseASBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath, target: leaseASBidStoragePath)\n        }\n\n        // let leaseAESaleItemType= Type\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e()\n        // let leaseAEPublicPath=FindMarket.getPublicPath(leaseAESaleItemType, name: \"findLease\")\n        // let leaseAEStoragePath= FindMarket.getStoragePath(leaseAESaleItemType, name:\"findLease\")\n        // let leaseAESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath) \n        // if !leaseAESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseAEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath, target: leaseAEStoragePath)\n        // }\n\n        // let leaseAEBidType= Type\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e()\n        // let leaseAEBidPublicPath=FindMarket.getPublicPath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidStoragePath= FindMarket.getStoragePath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath) \n        // if !leaseAEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseAEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath, target: leaseAEBidStoragePath)\n        // }\n\n        let leaseDOSSaleItemType= Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e()\n        let leaseDOSPublicPath=FindMarket.getPublicPath(leaseDOSSaleItemType, name: \"findLease\")\n        let leaseDOSStoragePath= FindMarket.getStoragePath(leaseDOSSaleItemType, name:\"findLease\")\n        let leaseDOSSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath) \n        if !leaseDOSSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOSStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath, target: leaseDOSStoragePath)\n        }\n\n        let leaseDOSBidType= Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let leaseDOSBidPublicPath=FindMarket.getPublicPath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidStoragePath= FindMarket.getStoragePath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath) \n        if !leaseDOSBidCap.check() {\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOSBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath, target: leaseDOSBidStoragePath)\n        }\n\n        // let leaseDOESaleItemType= Type\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        // let leaseDOEPublicPath=FindMarket.getPublicPath(leaseDOESaleItemType, name: \"findLease\")\n        // let leaseDOEStoragePath= FindMarket.getStoragePath(leaseDOESaleItemType, name:\"findLease\")\n        // let leaseDOESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath) \n        // if !leaseDOESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath, target: leaseDOEStoragePath)\n        // }\n\n        // let leaseDOEBidType= Type\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        // let leaseDOEBidPublicPath=FindMarket.getPublicPath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidStoragePath= FindMarket.getStoragePath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath) \n        // if !leaseDOEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath, target: leaseDOEBidStoragePath)\n        // }\n        //SYNC with register\n\n    }\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "delistAllLeaseSale": {
               "code": "import FindLeaseMarketSale from 0x097bafa4e0b48eef\nimport FindMarket from 0x097bafa4e0b48eef\nimport FindLeaseMarket from 0x097bafa4e0b48eef\n\ntransaction() {\n    prepare(account: AuthAccount) {\n        // Get all the saleItems Id\n\n        let tenant = FindMarket.getTenant(FindMarket.getTenantAddress(\"findLease\")!)\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindLeaseMarketSale.SaleItem\u003e())\n        let cap = FindLeaseMarket.getSaleItemCollectionCapability(tenantRef: tenant, marketOption: marketOption, address: account.address)\n        let ref = cap.borrow() ?? panic(\"Cannot borrow reference to the capability.\")\n\n        let listingType=Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()\n        let saleItems= account.borrow\u003c\u0026FindLeaseMarketSale.SaleItemCollection\u003e(from: tenant.getStoragePath(listingType))!\n        let leases = ref.getNameSales()\n        for lease in leases {\n            saleItems.delist(lease)\n        }\n    }\n}",
               "spec": {
                  "order": [],
                  "parameters": {}
               }
            },
            "delistAllNFTSale": {
               "code": "import FindMarketSale from 0x097bafa4e0b48eef\nimport FindMarket from 0x097bafa4e0b48eef\n\ntransaction(marketplace:Address) {\n\n    let saleItems : \u0026FindMarketSale.SaleItemCollection?\n\n    prepare(account: AuthAccount) {\n        let tenant = FindMarket.getTenant(marketplace)\n        self.saleItems= account.borrow\u003c\u0026FindMarketSale.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketSale.SaleItemCollection\u003e())) \n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        let ids = self.saleItems!.getIds()\n        for id in ids {\n            self.saleItems!.delist(id)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace"
                  ],
                  "parameters": {
                     "marketplace": "Address"
                  }
               }
            },
            "delistAllNameSale": {
               "code": "import FIND from 0x097bafa4e0b48eef\n\ntransaction() {\n\n    let finLeases : \u0026FIND.LeaseCollection?\n\n    prepare(acct: AuthAccount) {\n        self.finLeases= acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)\n\n    }\n\n    pre{\n        self.finLeases != nil : \"Cannot borrow reference to find lease collection\"\n    }\n\n    execute{\n        let leases = self.finLeases!.getLeaseInformation()\n        for lease in leases {\n            if lease.salePrice != nil {\n                self.finLeases!.delistSale(lease.name)\n            }\n        }\n    }\n}",
               "spec": {
                  "order": [],
                  "parameters": {}
               }
            },
            "delistLeaseSale": {
               "code": "import FindMarket from 0x097bafa4e0b48eef\nimport FindLeaseMarketSale from 0x097bafa4e0b48eef\n\ntransaction(leases: [String]) {\n    let saleItems : \u0026FindLeaseMarketSale.SaleItemCollection?\n\n    prepare(account: AuthAccount) {\n\n        let tenant=FindMarket.getTenant(FindMarket.getTenantAddress(\"findLease\")!)\n        self.saleItems= account.borrow\u003c\u0026FindLeaseMarketSale.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()))\n\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        for lease in leases {\n            self.saleItems!.delist(lease)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "leases"
                  ],
                  "parameters": {
                     "leases": "[String]"
                  }
               }
            },
            "delistNFTSale": {
               "code": "import FindMarket from 0x097bafa4e0b48eef\nimport FindMarketSale from 0x097bafa4e0b48eef\n\ntransaction(marketplace:Address, ids: [UInt64]) {\n\n    let saleItems : \u0026FindMarketSale.SaleItemCollection?\n\n    prepare(account: AuthAccount) {\n\n        let tenant=FindMarket.getTenant(marketplace)\n        self.saleItems= account.borrow\u003c\u0026FindMarketSale.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketSale.SaleItemCollection\u003e()))\n\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        for id in ids {\n            self.saleItems!.delist(id)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "ids"
                  ],
                  "parameters": {
                     "ids": "[UInt64]",
                     "marketplace": "Address"
                  }
               }
            },
            "delistNameSale": {
               "code": "import FIND from 0x097bafa4e0b48eef\n\ntransaction(names: [String]) {\n\n    let finLeases : \u0026FIND.LeaseCollection?\n\n    prepare(acct: AuthAccount) {\n        self.finLeases= acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)\n    }\n\n    pre{\n        self.finLeases != nil : \"Cannot borrow reference to find lease collection\"\n    }\n\n    execute{\n        for name in names {\n            self.finLeases!.delistSale(name)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "names"
                  ],
                  "parameters": {
                     "names": "[String]"
                  }
               }
            },
            "editProfile": {
               "code": "import FungibleToken from 0xf233dcee88fe0abe\nimport FUSD from 0x3c5959b568896393\nimport FlowToken from 0x1654653399040a61\nimport FIND from 0x097bafa4e0b48eef\nimport Profile from 0x097bafa4e0b48eef\n\ntransaction(name:String, description: String, avatar: String, tags:[String], allowStoringFollowers: Bool, linkTitles : {String: String}, linkTypes: {String:String}, linkUrls : {String:String}, removeLinks : [String]) {\n    \n    let profile : \u0026Profile.User\n\n    prepare(account: AuthAccount) {\n\n        self.profile =account.borrow\u003c\u0026Profile.User\u003e(from:Profile.storagePath) ?? panic(\"Cannot borrow reference to profile\")\n\n        //Add exising FUSD or create a new one and add it\n        let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n        if !fusdReceiver.check() {\n            let fusd \u003c- FUSD.createEmptyVault()\n            account.save(\u003c- fusd, to: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n        }\n\n\n        var hasFusdWallet=false\n        var hasFlowWallet=false\n        let wallets=self.profile.getWallets()\n        for wallet in wallets {\n            if wallet.name==\"FUSD\" {\n                hasFusdWallet=true\n            }\n\n            if wallet.name ==\"Flow\" {\n                hasFlowWallet=true\n            }\n        }\n\n        if !hasFlowWallet {\n            let flowWallet=Profile.Wallet(\n                name:\"Flow\", \n                receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver),\n                balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance),\n                accept: Type\u003c@FlowToken.Vault\u003e(),\n                tags: [\"flow\"]\n            )\n            self.profile.addWallet(flowWallet)\n        }\n\n        if !hasFusdWallet {\n            let fusdWallet=Profile.Wallet(\n                name:\"FUSD\", \n                receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver),\n                balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance),\n                accept: Type\u003c@FUSD.Vault\u003e(),\n                tags: [\"fusd\", \"stablecoin\"]\n            )\n            self.profile.addWallet(fusdWallet)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n    }\n\n    execute{\n        self.profile!.setName(name)\n        self.profile!.setDescription(description)\n        self.profile!.setAvatar(avatar)\n        self.profile!.setTags(tags)\n\n        for link in removeLinks {\n            self.profile!.removeLink(link)\n        }\n\n        for titleName in linkTitles.keys {\n            let title=linkTitles[titleName]!\n            let url = linkUrls[titleName]!\n            let type = linkTypes[titleName]!\n\n            self.profile!.addLinkWithName(name:titleName, link: Profile.Link(title: title, type: type, url: url))\n        }\n        self.profile!.emitUpdatedEvent()\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "description",
                     "avatar",
                     "tags",
                     "allowStoringFollowers",
                     "linkTitles",
                     "linkTypes",
                     "linkUrls",
                     "removeLinks"
                  ],
                  "parameters": {
                     "allowStoringFollowers": "Bool",
                     "avatar": "String",
                     "description": "String",
                     "linkTitles": "{String: String}",
                     "linkTypes": "{String: String}",
                     "linkUrls": "{String: String}",
                     "name": "String",
                     "removeLinks": "[String]",
                     "tags": "[String]"
                  }
               }
            },
            "fulfillLeaseMarketAuctionSoft": {
               "code": "import FindLeaseMarketAuctionSoft from 0x097bafa4e0b48eef\nimport FungibleToken from 0xf233dcee88fe0abe\nimport FTRegistry from 0x097bafa4e0b48eef\nimport FindMarket from 0x097bafa4e0b48eef\nimport FindLeaseMarket from 0x097bafa4e0b48eef\n\ntransaction(leaseName: String, amount:UFix64) {\n\n    let walletReference : \u0026FungibleToken.Vault\n    let bidsReference: \u0026FindLeaseMarketAuctionSoft.MarketBidCollection\n    let requiredAmount: UFix64\n\n    prepare(account: AuthAccount) {\n        let marketplace = FindMarket.getTenantAddress(\"findLease\")!\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e())\n\n        self.bidsReference= account.borrow\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"This account does not have a bid collection\")\n\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e())\n        let item = FindLeaseMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, name: leaseName)\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n    \n        self.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n        self.requiredAmount = self.bidsReference.getBalance(leaseName)\n    }\n\n    pre{\n        self.walletReference.balance \u003e self.requiredAmount : \"Your wallet does not have enough funds to pay for this item\"\n        self.requiredAmount == amount : \"Amount needed to fulfill is \".concat(self.requiredAmount.toString()).concat(\" you sent in \").concat(amount.toString())\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount) \n        self.bidsReference.fulfillAuction(name: leaseName, vault: \u003c- vault)\n    }\n}",
               "spec": {
                  "order": [
                     "leaseName",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "leaseName": "String"
                  }
               }
            },
            "fulfillLeaseMarketAuctionSoftDUC": {
               "code": "import FindLeaseMarketAuctionSoft from 0x097bafa4e0b48eef\nimport FungibleToken from 0xf233dcee88fe0abe\nimport FTRegistry from 0x097bafa4e0b48eef\nimport FindMarket from 0x097bafa4e0b48eef\nimport FindLeaseMarket from 0x097bafa4e0b48eef\nimport DapperUtilityCoin from 0xead892083b3e2c6c\n\ntransaction(leaseName: String, amount:UFix64) {\n\n    let walletReference : \u0026FungibleToken.Vault\n    let bidsReference: \u0026FindLeaseMarketAuctionSoft.MarketBidCollection\n    let requiredAmount: UFix64\n    let mainDapperUtilityCoinVault: \u0026DapperUtilityCoin.Vault\n    let balanceBeforeTransfer: UFix64\n\n    prepare(dapper: AuthAccount, account: AuthAccount) {\n        let marketplace = FindMarket.getTenantAddress(\"findLease\")!\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e())\n\n        self.bidsReference= account.borrow\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"This account does not have a bid collection\")\n\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e())\n        let item = FindLeaseMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, name: leaseName)\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n    \n        // There should be no need to assert this, there will be no listing in other tokens for Dapper wallet.\n        // if ft.type != Type\u003c@DapperUtilityCoin.Vault\u003e(){\n        //     panic(\"This item is not listed for Dapper Wallets. Please fulfill in with other wallets.\")\n        // }\n        self.mainDapperUtilityCoinVault = dapper.borrow\u003c\u0026DapperUtilityCoin.Vault\u003e(from: /storage/dapperUtilityCoinVault) ?? panic(\"Cannot borrow DapperUtilityCoin vault from account storage\")\n        self.balanceBeforeTransfer = self.mainDapperUtilityCoinVault.balance\n\n        self.walletReference = dapper.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n        self.requiredAmount = self.bidsReference.getBalance(leaseName)\n    }\n\n    pre{\n        self.walletReference.balance \u003e self.requiredAmount : \"Your wallet does not have enough funds to pay for this item\"\n        self.requiredAmount == amount : \"Amount needed to fulfill is \".concat(self.requiredAmount.toString()).concat(\" you sent in \").concat(amount.toString())\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount) \n        self.bidsReference.fulfillAuction(name: leaseName, vault: \u003c- vault)\n    }\n\n    // Check that all dapperUtilityCoin was routed back to Dapper\n    post {\n        self.mainDapperUtilityCoinVault.balance == self.balanceBeforeTransfer: \"DapperUtilityCoin leakage\"\n    }\n}",
               "spec": {
                  "order": [
                     "leaseName",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "leaseName": "String"
                  }
               }
            },
            "fulfillLeaseMarketDirectOfferSoft": {
               "code": "import FindLeaseMarketDirectOfferSoft from 0x097bafa4e0b48eef\nimport FungibleToken from 0xf233dcee88fe0abe\nimport FTRegistry from 0x097bafa4e0b48eef\nimport FindMarket from 0x097bafa4e0b48eef\nimport FindLeaseMarket from 0x097bafa4e0b48eef\n\ntransaction(leaseName: String, amount:UFix64) {\n\n    let walletReference : \u0026FungibleToken.Vault\n    let bidsReference: \u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection\n    let requiredAmount:UFix64\n\n    prepare(account: AuthAccount) {\n        let marketplace = FindMarket.getTenantAddress(\"findLease\")!\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e())\n        self.bidsReference= account.borrow\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"Cannot borrow direct offer soft bid collection\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e())\n        let item = FindLeaseMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, name: leaseName)\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n\n          self.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n\n        self.requiredAmount = self.bidsReference.getBalance(leaseName)\n    }\n\n    pre {\n        self.walletReference.balance \u003e self.requiredAmount : \"Your wallet does not have enough funds to pay for this item\"\n        self.requiredAmount == amount : \"Amount needed to fulfill is \".concat(amount.toString())\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount) \n        self.bidsReference.fulfillDirectOffer(name: leaseName, vault: \u003c- vault)\n    }\n}",
               "spec": {
                  "order": [
                     "leaseName",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "leaseName": "String"
                  }
               }
            },
            "fulfillLeaseMarketDirectOfferSoftDUC": {
               "code": "import FindLeaseMarketDirectOfferSoft from 0x097bafa4e0b48eef\nimport FungibleToken from 0xf233dcee88fe0abe\nimport FTRegistry from 0x097bafa4e0b48eef\nimport FindMarket from 0x097bafa4e0b48eef\nimport FindLeaseMarket from 0x097bafa4e0b48eef\nimport DapperUtilityCoin from 0xead892083b3e2c6c\n\ntransaction(leaseName: String, amount:UFix64) {\n\n    let walletReference : \u0026FungibleToken.Vault\n    let bidsReference: \u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection\n    let requiredAmount:UFix64\n    let mainDapperUtilityCoinVault: \u0026DapperUtilityCoin.Vault\n    let balanceBeforeTransfer: UFix64\n\n    prepare(dapper: AuthAccount, account: AuthAccount) {\n        let marketplace = FindMarket.getTenantAddress(\"findLease\")!\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e())\n        self.bidsReference= account.borrow\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"Cannot borrow direct offer soft bid collection\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e())\n        let item = FindLeaseMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, name: leaseName)\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n\n        // There should be no need to assert this, there will be no listing in other tokens for Dapper wallet.\n        // if ft.type != Type\u003c@DapperUtilityCoin.Vault\u003e(){\n        //     panic(\"This item is not listed for Dapper Wallets. Please fulfill in with other wallets.\")\n        // }\n        self.mainDapperUtilityCoinVault = dapper.borrow\u003c\u0026DapperUtilityCoin.Vault\u003e(from: /storage/dapperUtilityCoinVault) ?? panic(\"Cannot borrow DapperUtilityCoin vault from account storage\")\n        self.balanceBeforeTransfer = self.mainDapperUtilityCoinVault.balance\n\n          self.walletReference = dapper.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n\n        self.requiredAmount = self.bidsReference.getBalance(leaseName)\n    }\n\n    pre {\n        self.walletReference.balance \u003e self.requiredAmount : \"Your wallet does not have enough funds to pay for this item\"\n        self.requiredAmount == amount : \"Amount needed to fulfill is \".concat(amount.toString())\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount) \n        self.bidsReference.fulfillDirectOffer(name: leaseName, vault: \u003c- vault)\n    }\n\n    // Check that all dapperUtilityCoin was routed back to Dapper\n    post {\n        self.mainDapperUtilityCoinVault.balance == self.balanceBeforeTransfer: \"DapperUtilityCoin leakage\"\n    }\n}",
               "spec": {
                  "order": [
                     "leaseName",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "leaseName": "String"
                  }
               }
            },
            "fulfillMarketAuctionEscrowed": {
               "code": "import FindMarketAuctionEscrow from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\n\ntransaction(marketplace:Address, owner: String, id: UInt64) {\n\n    let saleItem : Capability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic}\u003e?\n\n    prepare(account: AuthAccount) {\n        let resolveAddress = FIND.resolve(owner)\n        if resolveAddress == nil { \n            panic(\"The address input is not a valid name nor address. Input : \".concat(owner))\n        }\n        let address = resolveAddress!\n        self.saleItem = FindMarketAuctionEscrow.getSaleItemCapability(marketplace:marketplace, user:address)\n\n    }\n\n    pre{\n        self.saleItem != nil : \"This saleItem capability does not exist. Sale item ID: \".concat(id.toString())\n        self.saleItem!.check() : \"Cannot borrow reference to saleItem. Sale item ID: \".concat(id.toString())\n    }\n\n    execute {\n        self.saleItem!.borrow()!.fulfillAuction(id)\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "owner",
                     "id"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "marketplace": "Address",
                     "owner": "String"
                  }
               }
            },
            "fulfillMarketAuctionEscrowedFromBidder": {
               "code": "import FindMarketAuctionEscrow from 0x097bafa4e0b48eef\nimport FindMarket from 0x097bafa4e0b48eef\n\ntransaction(marketplace:Address, id: UInt64) {\n\n    let bidsReference : \u0026FindMarketAuctionEscrow.MarketBidCollection?\n\n    prepare(account: AuthAccount) {\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e())\n        self.bidsReference= account.borrow\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection\u003e(from: storagePath)\n\n        \n    }\n\n    pre{\n        self.bidsReference != nil : \"Cannot borrow reference to bid collection.\"\n    }\n\n    execute{\n        self.bidsReference!.fulfillAuction(id)\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "fulfillMarketAuctionSoft": {
               "code": "import FindMarketAuctionSoft from 0x097bafa4e0b48eef\nimport FungibleToken from 0xf233dcee88fe0abe\nimport FTRegistry from 0x097bafa4e0b48eef\nimport FindMarket from 0x097bafa4e0b48eef\n\ntransaction(marketplace:Address, id: UInt64, amount:UFix64) {\n\n    let walletReference : \u0026FungibleToken.Vault\n    let bidsReference: \u0026FindMarketAuctionSoft.MarketBidCollection\n    let requiredAmount: UFix64\n\n    prepare(account: AuthAccount) {\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e())\n\n        self.bidsReference= account.borrow\u003c\u0026FindMarketAuctionSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"This account does not have a bid collection\")\n\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e())\n        let item = FindMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: id)\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n    \n        self.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n        self.requiredAmount = self.bidsReference.getBalance(id)\n    }\n\n    pre{\n        self.walletReference.balance \u003e self.requiredAmount : \"Your wallet does not have enough funds to pay for this item\"\n        self.requiredAmount == amount : \"Amount needed to fulfill is \".concat(self.requiredAmount.toString()).concat(\" you sent in \").concat(amount.toString())\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount) \n        self.bidsReference.fulfillAuction(id: id, vault: \u003c- vault)\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "fulfillMarketAuctionSoftDUC": {
               "code": "import FindMarketAuctionSoft from 0x097bafa4e0b48eef\nimport FungibleToken from 0xf233dcee88fe0abe\nimport FTRegistry from 0x097bafa4e0b48eef\nimport FindMarket from 0x097bafa4e0b48eef\nimport DapperUtilityCoin from 0xead892083b3e2c6c\n\ntransaction(marketplace:Address, id: UInt64, amount:UFix64) {\n\n    let walletReference : \u0026FungibleToken.Vault\n    let bidsReference: \u0026FindMarketAuctionSoft.MarketBidCollection\n    let requiredAmount: UFix64\n    let mainDapperUtilityCoinVault: \u0026DapperUtilityCoin.Vault\n    let balanceBeforeTransfer: UFix64\n\n    prepare(dapper: AuthAccount, account: AuthAccount) {\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e())\n\n        self.bidsReference= account.borrow\u003c\u0026FindMarketAuctionSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"This account does not have a bid collection\")\n\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e())\n        let item = FindMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: id)\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n    \n        // There should be no need to assert this, there will be no listing in other tokens for Dapper wallet.\n        // if ft.type != Type\u003c@DapperUtilityCoin.Vault\u003e(){\n        //     panic(\"This item is not listed for Dapper Wallets. Please fulfill in with other wallets.\")\n        // }\n        self.mainDapperUtilityCoinVault = dapper.borrow\u003c\u0026DapperUtilityCoin.Vault\u003e(from: /storage/dapperUtilityCoinVault) ?? panic(\"Cannot borrow DapperUtilityCoin vault from account storage\")\n        self.balanceBeforeTransfer = self.mainDapperUtilityCoinVault.balance\n\n        self.walletReference = dapper.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n        self.requiredAmount = self.bidsReference.getBalance(id)\n    }\n\n    pre{\n        self.walletReference.balance \u003e self.requiredAmount : \"Your wallet does not have enough funds to pay for this item\"\n        self.requiredAmount == amount : \"Amount needed to fulfill is \".concat(self.requiredAmount.toString()).concat(\" you sent in \").concat(amount.toString())\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount) \n        self.bidsReference.fulfillAuction(id: id, vault: \u003c- vault)\n    }\n\n    // Check that all dapperUtilityCoin was routed back to Dapper\n    post {\n        self.mainDapperUtilityCoinVault.balance == self.balanceBeforeTransfer: \"DapperUtilityCoin leakage\"\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "fulfillMarketDirectOfferEscrowed": {
               "code": "import FindMarketDirectOfferEscrow from 0x097bafa4e0b48eef\nimport NonFungibleToken from 0x1d7e57aa55817448\nimport MetadataViews from 0x1d7e57aa55817448\nimport FindViews from 0x097bafa4e0b48eef\nimport NFTCatalog from 0x49a7cda3a1eecc29\nimport FINDNFTCatalog from 0x097bafa4e0b48eef\nimport FindMarket from 0x097bafa4e0b48eef\n\ntransaction(marketplace:Address, id: UInt64) {\n\n    let market : \u0026FindMarketDirectOfferEscrow.SaleItemCollection?\n    let pointer : FindViews.AuthNFTPointer\n\n    prepare(account: AuthAccount) {\n\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e())\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e())\n\n        let item = FindMarket.assertOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: id)\n\n        let nftIdentifier = item.getItemType().identifier\n        let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier)) \n        let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n        let nft = collection.collectionData\n\n    \n        var providerCap=account.getCapability\u003c\u0026{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e(nft.privatePath)\n\n        /* Ben : Question -\u003e Either client will have to provide the path here or agree that we set it up for the user */\n        if !providerCap.check() {\n            let newCap = account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                    nft.privatePath,\n                    target: nft.storagePath\n            )\n            if newCap == nil {\n                // If linking is not successful, we link it using finds custom link \n                let pathIdentifier = nft.privatePath.toString()\n                let findPath = PrivatePath(identifier: pathIdentifier.slice(from: \"/private/\".length , upTo: pathIdentifier.length).concat(\"_FIND\"))!\n                account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                    findPath,\n                    target: nft.storagePath\n                )\n                providerCap = account.getCapability\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(findPath)\n            }\n        }\n\n        self.pointer= FindViews.AuthNFTPointer(cap: providerCap, id: item.getItemID())\n        self.market = account.borrow\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection\u003e(from: storagePath)\n\n    }\n\n    pre{\n        self.market != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        self.market!.acceptDirectOffer(self.pointer)\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "fulfillMarketDirectOfferSoft": {
               "code": "import FindMarketDirectOfferSoft from 0x097bafa4e0b48eef\nimport FungibleToken from 0xf233dcee88fe0abe\nimport FTRegistry from 0x097bafa4e0b48eef\nimport FindMarket from 0x097bafa4e0b48eef\n\ntransaction(marketplace:Address, id: UInt64, amount:UFix64) {\n\n    let walletReference : \u0026FungibleToken.Vault\n    let bidsReference: \u0026FindMarketDirectOfferSoft.MarketBidCollection\n    let requiredAmount:UFix64\n\n    prepare(account: AuthAccount) {\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n        self.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"Cannot borrow direct offer soft bid collection\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n        let item = FindMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: id)\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n\n      self.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n\n        self.requiredAmount = self.bidsReference.getBalance(id)\n    }\n\n    pre {\n        self.walletReference.balance \u003e self.requiredAmount : \"Your wallet does not have enough funds to pay for this item\"\n        self.requiredAmount == amount : \"Amount needed to fulfill is \".concat(amount.toString())\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount) \n        self.bidsReference.fulfillDirectOffer(id: id, vault: \u003c- vault)\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "fulfillMarketDirectOfferSoftDUC": {
               "code": "import FindMarketDirectOfferSoft from 0x097bafa4e0b48eef\nimport FungibleToken from 0xf233dcee88fe0abe\nimport FTRegistry from 0x097bafa4e0b48eef\nimport FindMarket from 0x097bafa4e0b48eef\nimport DapperUtilityCoin from 0xead892083b3e2c6c\n\ntransaction(marketplace:Address, id: UInt64, amount:UFix64) {\n\n    let walletReference : \u0026FungibleToken.Vault\n    let bidsReference: \u0026FindMarketDirectOfferSoft.MarketBidCollection\n    let requiredAmount:UFix64\n    let mainDapperUtilityCoinVault: \u0026DapperUtilityCoin.Vault\n    let balanceBeforeTransfer: UFix64\n\n    prepare(dapper: AuthAccount, account: AuthAccount) {\n\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n        self.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"Cannot borrow direct offer soft bid collection\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n        let item = FindMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: id)\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n\n        // There should be no need to assert this, there will be no listing in other tokens for Dapper wallet.\n        // if ft.type != Type\u003c@DapperUtilityCoin.Vault\u003e(){\n        //     panic(\"This item is not listed for Dapper Wallets. Please fulfill in with other wallets.\")\n        // }\n        self.mainDapperUtilityCoinVault = dapper.borrow\u003c\u0026DapperUtilityCoin.Vault\u003e(from: /storage/dapperUtilityCoinVault) ?? panic(\"Cannot borrow DapperUtilityCoin vault from account storage\")\n        self.balanceBeforeTransfer = self.mainDapperUtilityCoinVault.balance\n\n          self.walletReference = dapper.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n\n        self.requiredAmount = self.bidsReference.getBalance(id)\n    }\n\n    pre {\n        self.walletReference.balance \u003e self.requiredAmount : \"Your wallet does not have enough funds to pay for this item\"\n        self.requiredAmount == amount : \"Amount needed to fulfill is \".concat(amount.toString())\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount) \n        self.bidsReference.fulfillDirectOffer(id: id, vault: \u003c- vault)\n    }\n\n    // Check that all dapperUtilityCoin was routed back to Dapper\n    post {\n        self.mainDapperUtilityCoinVault.balance == self.balanceBeforeTransfer: \"DapperUtilityCoin leakage\"\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "fulfillMultipleMarketDirectOfferEscrowed": {
               "code": "import FindMarketDirectOfferEscrow from 0x097bafa4e0b48eef\nimport NonFungibleToken from 0x1d7e57aa55817448\nimport MetadataViews from 0x1d7e57aa55817448\nimport FindViews from 0x097bafa4e0b48eef\nimport NFTCatalog from 0x49a7cda3a1eecc29\nimport FINDNFTCatalog from 0x097bafa4e0b48eef\nimport FindMarket from 0x097bafa4e0b48eef\n\ntransaction(marketplace:Address, ids: [UInt64]) {\n\n    let market : \u0026FindMarketDirectOfferEscrow.SaleItemCollection?\n    let pointer : [FindViews.AuthNFTPointer]\n\n    prepare(account: AuthAccount) {\n\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e())\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e())\n        self.market = account.borrow\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection\u003e(from: storagePath)\n        self.pointer = []\n\n        let nfts : {String : NFTCatalog.NFTCollectionData} = {}\n        var counter = 0\n        while counter \u003c ids.length {\n            let item = FindMarket.assertOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: ids[counter])\n\n            var nft : NFTCatalog.NFTCollectionData? = nil\n            let nftIdentifier = item.getItemType().identifier\n\n            if nfts[nftIdentifier] != nil {\n                nft = nfts[nftIdentifier]\n            } else {\n                let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier)) \n                let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n                nft = collection.collectionData\n                nfts[nftIdentifier] = nft\n            }\n        \n            var providerCap=account.getCapability\u003c\u0026{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e(nft!.privatePath)\n\n            /* Ben : Question -\u003e Either client will have to provide the path here or agree that we set it up for the user */\n            if !providerCap.check() {\n                let newCap = account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                        nft!.privatePath,\n                        target: nft!.storagePath\n                )\n                if newCap == nil {\n                    // If linking is not successful, we link it using finds custom link \n                    let pathIdentifier = nft!.privatePath.toString()\n                    let findPath = PrivatePath(identifier: pathIdentifier.slice(from: \"/private/\".length , upTo: pathIdentifier.length).concat(\"_FIND\"))!\n                    account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                        findPath,\n                        target: nft!.storagePath\n                    )\n                    providerCap = account.getCapability\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(findPath)\n                }\n            }\n\n            let pointer= FindViews.AuthNFTPointer(cap: providerCap, id: item.getItemID())\n            self.pointer.append(pointer)\n            counter = counter + 1\n        }\n\n    }\n\n    pre{\n        self.market != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        var counter = 0\n        while counter \u003c ids.length {\n            self.market!.acceptDirectOffer(self.pointer[counter])\n            counter = counter + 1\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "ids"
                  ],
                  "parameters": {
                     "ids": "[UInt64]",
                     "marketplace": "Address"
                  }
               }
            },
            "fulfillMultipleMarketDirectOfferSoft": {
               "code": "import FindMarketDirectOfferSoft from 0x097bafa4e0b48eef\nimport FungibleToken from 0xf233dcee88fe0abe\nimport FTRegistry from 0x097bafa4e0b48eef\nimport FindMarket from 0x097bafa4e0b48eef\n\ntransaction(marketplace:Address, ids: [UInt64], amounts:[UFix64]) {\n\n    let walletReference : [\u0026FungibleToken.Vault]\n    let bidsReference: \u0026FindMarketDirectOfferSoft.MarketBidCollection\n    let requiredAmount: [UFix64]\n\n    prepare(account: AuthAccount) {\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n        self.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"Cannot borrow direct offer soft bid collection\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n\n        var counter = 0\n        self.requiredAmount = []\n        self.walletReference = []\n        let fts : {String : FTRegistry.FTInfo} = {}\n        let vaultRefs : {StoragePath : \u0026FungibleToken.Vault} = {}\n\n\n        while counter \u003c ids.length {\n            let item = FindMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: ids[counter])\n\n            var ft : FTRegistry.FTInfo? = nil\n            let ftIdentifier = item.getFtType().identifier\n            if fts[ftIdentifier] != nil {\n                ft = fts[ftIdentifier]\n            } else {\n                ft = FTRegistry.getFTInfoByTypeIdentifier(ftIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftIdentifier))\n                fts[ftIdentifier] = ft\n            }\n\n            if vaultRefs[ft!.vaultPath] != nil {\n                self.walletReference.append(vaultRefs[ft!.vaultPath]!)\n            } else {\n                let walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft!.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n                vaultRefs[ft!.vaultPath] = walletReference\n                self.walletReference.append(walletReference)\n            }\n            let requiredAmount = self.bidsReference.getBalance(ids[counter])\n            self.requiredAmount.append(requiredAmount)\n            counter = counter + 1\n        }\n    }\n\n    execute {\n        var counter = 0\n        while counter \u003c ids.length {\n            if self.walletReference[counter].balance \u003c self.requiredAmount[counter] {\n                panic(\"Your wallet does not have enough funds to pay for this item. Item ID: \".concat(ids[counter].toString()))\n            }\n            if self.requiredAmount[counter] != amounts[counter] {\n                panic(\"Amount needed to fulfill is \".concat(amounts[counter].toString()))\n            }\n            let vault \u003c- self.walletReference[counter].withdraw(amount: amounts[counter]) \n            self.bidsReference.fulfillDirectOffer(id: ids[counter], vault: \u003c- vault)\n            counter = counter + 1\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "ids",
                     "amounts"
                  ],
                  "parameters": {
                     "amounts": "[UFix64]",
                     "ids": "[UInt64]",
                     "marketplace": "Address"
                  }
               }
            },
            "fulfillMultipleMarketDirectOfferSoftDUC": {
               "code": "import FindMarketDirectOfferSoft from 0x097bafa4e0b48eef\nimport FungibleToken from 0xf233dcee88fe0abe\nimport FTRegistry from 0x097bafa4e0b48eef\nimport FindMarket from 0x097bafa4e0b48eef\nimport DapperUtilityCoin from 0xead892083b3e2c6c\n\ntransaction(marketplace:Address, ids: [UInt64], amounts:[UFix64]) {\n\n    let walletReference : \u0026FungibleToken.Vault\n    let bidsReference: \u0026FindMarketDirectOfferSoft.MarketBidCollection\n    var requiredAmount:UFix64\n    let balanceBeforeTransfer: UFix64\n    var totalAmount: UFix64\n\n    prepare(dapper: AuthAccount, account: AuthAccount) {\n\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n        self.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"Cannot borrow direct offer soft bid collection\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n          self.walletReference = dapper.borrow\u003c\u0026DapperUtilityCoin.Vault\u003e(from: /storage/dapperUtilityCoinVault) ?? panic(\"Cannot borrow DapperUtilityCoin vault from account storage\")\n        self.balanceBeforeTransfer = self.walletReference.balance\n\n        var counter = 0\n        self.totalAmount = 0.0\n        self.requiredAmount = 0.0\n        while counter \u003c ids.length {\n            let item = FindMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: ids[counter])\n            self.requiredAmount = self.requiredAmount + self.bidsReference.getBalance(ids[counter])\n            self.totalAmount = self.totalAmount + amounts[counter]\n            counter = counter + 1\n        }\n    }\n\n    pre {\n        self.walletReference.balance \u003e self.requiredAmount : \"Your wallet does not have enough funds to pay for this item\"\n        self.requiredAmount == self.totalAmount : \"Amount needed to fulfill is \".concat(self.totalAmount.toString())\n    }\n\n    execute {\n        var counter = 0\n        while counter \u003c ids.length {\n            let vault \u003c- self.walletReference.withdraw(amount: amounts[counter]) \n            self.bidsReference.fulfillDirectOffer(id: ids[counter], vault: \u003c- vault)\n            counter = counter + 1 \n        }\n    }\n\n    // Check that all dapperUtilityCoin was routed back to Dapper\n    post {\n        self.walletReference.balance == self.balanceBeforeTransfer: \"DapperUtilityCoin leakage\"\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "ids",
                     "amounts"
                  ],
                  "parameters": {
                     "amounts": "[UFix64]",
                     "ids": "[UInt64]",
                     "marketplace": "Address"
                  }
               }
            },
            "fulfillName": {
               "code": "import FIND from 0x097bafa4e0b48eef\nimport Profile from 0x097bafa4e0b48eef\n\ntransaction(name: String) {\n\n    let finLeases : \u0026FIND.LeaseCollection?\n\n    prepare(account: AuthAccount) {\n        self.finLeases= account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath) \n    }\n\n    pre{\n        self.finLeases != nil : \"Cannot borrow reference to find lease collection\"\n    }\n\n    execute{\n        self.finLeases!.fulfill(name)\n    }\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "fulfillNameAuction": {
               "code": "import FIND from 0x097bafa4e0b48eef\nimport Profile from 0x097bafa4e0b48eef\n\ntransaction(owner: Address, name: String) {\n\n    let leases : \u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}?\n\n    prepare(account: AuthAccount) {\n        self.leases = getAccount(owner).getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath).borrow()\n    }\n\n    pre{\n        self.leases != nil : \"Cannot borrow reference to lease collection reference. Account address: \".concat(owner.toString())\n    }\n\n    execute{\n        self.leases!.fulfillAuction(name)\n    }\n}",
               "spec": {
                  "order": [
                     "owner",
                     "name"
                  ],
                  "parameters": {
                     "name": "String",
                     "owner": "Address"
                  }
               }
            },
            "fulfillNameAuctionBidder": {
               "code": "import FIND from 0x097bafa4e0b48eef\nimport FungibleToken from 0xf233dcee88fe0abe\nimport FUSD from 0x3c5959b568896393\nimport Profile from 0x097bafa4e0b48eef\n\ntransaction(owner: Address, name: String) {\n\n    let leaseCollectionOwner : \u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}?\n\n    prepare(account: AuthAccount) {\n\n\n    //Add exising FUSD or create a new one and add it\n        let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n        if !fusdReceiver.check() {\n            let fusd \u003c- FUSD.createEmptyVault()\n            account.save(\u003c- fusd, to: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n\n            let fusdWallet=Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), tags: [\"fusd\", \"stablecoin\"])\n\n            profile.addWallet(fusdWallet)\n\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n        }\n\n        self.leaseCollectionOwner = getAccount(owner).getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath).borrow()\n\n    }\n\n    pre{\n        self.leaseCollectionOwner != nil : \"Cannot borrow reference to find lease collection. Account address: \".concat(owner.toString())\n    }\n\n    execute {\n        self.leaseCollectionOwner!.fulfillAuction(name)\n    }\n}",
               "spec": {
                  "order": [
                     "owner",
                     "name"
                  ],
                  "parameters": {
                     "name": "String",
                     "owner": "Address"
                  }
               }
            },
            "increaseBidLeaseMarketAuctionSoft": {
               "code": "import FindLeaseMarketAuctionSoft from 0x097bafa4e0b48eef\nimport FungibleToken from 0xf233dcee88fe0abe\nimport FTRegistry from 0x097bafa4e0b48eef\nimport FindMarket from 0x097bafa4e0b48eef\nimport FindLeaseMarket from 0x097bafa4e0b48eef\n\ntransaction(leaseName: String, amount: UFix64) {\n\n    let bidsReference: \u0026FindLeaseMarketAuctionSoft.MarketBidCollection\n\n    prepare(account: AuthAccount) {\n        let marketplace = FindMarket.getTenantAddress(\"findLease\")!\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e())\n        self.bidsReference= account.borrow\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"Bid resource does not exist\")\n        // get Bidding Fungible Token Vault\n          let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e())\n        let item = FindLeaseMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, name: leaseName)\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n\n        let walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) \n        if ft.alias != \"DUC\" \u0026\u0026 walletReference == nil {\n            panic(\"No suitable wallet linked for this account\")\n        }\n    }\n\n    execute {\n        self.bidsReference.increaseBid(name: leaseName, increaseBy: amount)\n    }\n\n}",
               "spec": {
                  "order": [
                     "leaseName",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "leaseName": "String"
                  }
               }
            },
            "increaseBidLeaseMarketDirectOfferSoft": {
               "code": "import FindLeaseMarketDirectOfferSoft from 0x097bafa4e0b48eef\nimport FindMarket from 0x097bafa4e0b48eef\nimport FindLeaseMarket from 0x097bafa4e0b48eef\n\ntransaction(leaseName: String, amount: UFix64) {\n\n    let bidsReference: \u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection\n\n    prepare(account: AuthAccount) {\n        let marketplace = FindMarket.getTenantAddress(\"findLease\")!\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e())\n        self.bidsReference= account.borrow\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"Bid resource does not exist\")\n        // get Bidding Fungible Token Vault\n          let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e())\n        let item = FindLeaseMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, name: leaseName)\n    }\n\n    execute {\n        self.bidsReference.increaseBid(name: leaseName, increaseBy: amount)\n    }\n}",
               "spec": {
                  "order": [
                     "leaseName",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "leaseName": "String"
                  }
               }
            },
            "increaseBidMarketAuctionEscrowed": {
               "code": "import FindMarketAuctionEscrow from 0x097bafa4e0b48eef\nimport FungibleToken from 0xf233dcee88fe0abe\nimport FTRegistry from 0x097bafa4e0b48eef\nimport FindMarket from 0x097bafa4e0b48eef\n\ntransaction(marketplace:Address, id: UInt64, amount: UFix64) {\n\n    let walletReference : \u0026FungibleToken.Vault\n    let bidsReference: \u0026FindMarketAuctionEscrow.MarketBidCollection\n    let balanceBeforeBid: UFix64\n\n    prepare(account: AuthAccount) {\n\n        // Get the accepted vault type from BidInfo\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e())\n        self.bidsReference= account.borrow\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection\u003e(from: storagePath) ?? panic(\"This account does not have a bid collection\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e())\n        let item = FindMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: id)\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n        self.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n        self.balanceBeforeBid = self.walletReference.balance\n    }\n\n    pre {\n        self.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount) \n        self.bidsReference.increaseBid(id: id, vault: \u003c- vault)\n    }\n\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "increaseBidMarketAuctionSoft": {
               "code": "import FindMarketAuctionSoft from 0x097bafa4e0b48eef\nimport FungibleToken from 0xf233dcee88fe0abe\nimport FTRegistry from 0x097bafa4e0b48eef\nimport FindMarket from 0x097bafa4e0b48eef\n\ntransaction(marketplace:Address, id: UInt64, amount: UFix64) {\n\n    let bidsReference: \u0026FindMarketAuctionSoft.MarketBidCollection\n\n\n    prepare(account: AuthAccount) {\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e())\n        self.bidsReference= account.borrow\u003c\u0026FindMarketAuctionSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"Bid resource does not exist\")\n        // get Bidding Fungible Token Vault\n          let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e())\n        let item = FindMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: id)\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n\n        let walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath)\n        if ft.alias != \"DUC\" \u0026\u0026 walletReference == nil {\n            panic(\"No suitable wallet linked for this account\")\n        }\n    }\n\n    execute {\n        self.bidsReference.increaseBid(id: id, increaseBy: amount)\n    }\n\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "increaseBidMarketDirectOfferEscrowed": {
               "code": "import FindMarketDirectOfferEscrow from 0x097bafa4e0b48eef\nimport FungibleToken from 0xf233dcee88fe0abe\nimport FTRegistry from 0x097bafa4e0b48eef\nimport FindMarket from 0x097bafa4e0b48eef\n\ntransaction(marketplace:Address, id: UInt64, amount: UFix64) {\n\n    let walletReference : \u0026FungibleToken.Vault\n    let bidsReference: \u0026FindMarketDirectOfferEscrow.MarketBidCollection\n    let balanceBeforeBid: UFix64\n\n    prepare(account: AuthAccount) {\n        let tenant=FindMarket.getTenantCapability(marketplace)!.borrow() ?? panic(\"Cannot borrow reference to tenant\")\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e())\n        self.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection\u003e(from: storagePath) ?? panic(\"This account does not have a bid collection\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e())\n        let item = FindMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: id)\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n        self.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n        self.balanceBeforeBid=self.walletReference.balance\n    }\n\n    pre {\n        self.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount) \n        self.bidsReference!.increaseBid(id: id, vault: \u003c- vault)\n    }\n\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "increaseBidMarketDirectOfferSoft": {
               "code": "import FindMarketDirectOfferSoft from 0x097bafa4e0b48eef\nimport FindMarket from 0x097bafa4e0b48eef\n\ntransaction(marketplace: Address, id: UInt64, amount: UFix64) {\n\n    let bidsReference: \u0026FindMarketDirectOfferSoft.MarketBidCollection\n\n    prepare(account: AuthAccount) {\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n        self.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"Bid resource does not exist\")\n        // get Bidding Fungible Token Vault\n          let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n        let item = FindMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: id)\n    }\n\n    execute {\n        self.bidsReference.increaseBid(id: id, increaseBy: amount)\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "increaseNameBid": {
               "code": "import FIND from 0x097bafa4e0b48eef\nimport FungibleToken from 0xf233dcee88fe0abe\nimport FUSD from 0x3c5959b568896393\n\ntransaction(name: String, amount: UFix64) {\n\n    let vaultRef : \u0026FUSD.Vault?\n    let bids : \u0026FIND.BidCollection?\n\n    prepare(account: AuthAccount) {\n\n        \n        let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        self.vaultRef = account.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault)\n        self.bids = account.borrow\u003c\u0026FIND.BidCollection\u003e(from: FIND.BidStoragePath)\n    }\n\n    pre{\n        self.vaultRef != nil : \"Could not borrow reference to the fusdVault!\"\n        self.bids != nil : \"Could not borrow reference to bid collection\"\n    }\n\n    execute{\n        let vault \u003c- self.vaultRef!.withdraw(amount: amount) as! @FUSD.Vault\n        self.bids!.increaseBid(name: name, vault: \u003c- vault)\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "name": "String"
                  }
               }
            },
            "listLeaseForAuctionSoft": {
               "code": "import FindMarket from 0x097bafa4e0b48eef\nimport FindMarketSale from 0x097bafa4e0b48eef\nimport FindMarketAuctionEscrow from 0x097bafa4e0b48eef\nimport FindMarketAuctionSoft from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferEscrow from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferSoft from 0x097bafa4e0b48eef\nimport NonFungibleToken from 0x1d7e57aa55817448\nimport MetadataViews from 0x1d7e57aa55817448\nimport FindViews from 0x097bafa4e0b48eef\nimport FTRegistry from 0x097bafa4e0b48eef\nimport FungibleToken from 0xf233dcee88fe0abe\nimport FUSD from 0x3c5959b568896393\nimport FiatToken from 0xb19436aae4d94622\nimport FlowToken from 0x1654653399040a61\nimport FIND from 0x097bafa4e0b48eef\nimport Dandy from 0x097bafa4e0b48eef\nimport Profile from 0x097bafa4e0b48eef\nimport FindLeaseMarketSale from 0x097bafa4e0b48eef\nimport FindLeaseMarketAuctionSoft from 0x097bafa4e0b48eef\n// import FindLeaseMarketAuctionEscrow from \"../contracts/FindLeaseMarketAuctionEscrow.cdc\"\nimport FindLeaseMarketDirectOfferSoft from 0x097bafa4e0b48eef\n// import FindLeaseMarketDirectOfferEscrow from \"../contracts/FindLeaseMarketDirectOfferEscrow.cdc\"\nimport FindLeaseMarket from 0x097bafa4e0b48eef\n\ntransaction(leaseName: String, ftAliasOrIdentifier:String, price:UFix64, auctionReservePrice: UFix64, auctionDuration: UFix64, auctionExtensionOnLateBid: UFix64, minimumBidIncrement: UFix64, auctionValidUntil: UFix64?) {\n    \n    let saleItems : \u0026FindLeaseMarketAuctionSoft.SaleItemCollection?\n    let pointer : FindLeaseMarket.AuthLeasePointer\n    let vaultType : Type\n    \n    prepare(account: AuthAccount) {\n\n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n        //SYNC with register\n        //Add exising FUSD or create a new one and add it\n        let name = account.address.toString()\n        let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n        if !fusdReceiver.check() {\n            let fusd \u003c- FUSD.createEmptyVault()\n            account.save(\u003c- fusd, to: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n        }\n\n        let usdcCap = account.getCapability\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e(FiatToken.VaultReceiverPubPath)\n        if !usdcCap.check() {\n                account.save( \u003c-FiatToken.createEmptyVault(), to: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e( FiatToken.VaultReceiverPubPath, target: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FiatToken.ResourceId}\u003e( FiatToken.VaultUUIDPubPath, target: FiatToken.VaultStoragePath)\n                account.link\u003c\u0026FiatToken.Vault{FungibleToken.Balance}\u003e( FiatToken.VaultBalancePubPath, target:FiatToken.VaultStoragePath)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let dandyCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        let dandyCapPrivate= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPrivatePath)\n        if !dandyCapPrivate.check() {\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        var created=false\n        var updated=false\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        if !profile.hasWallet(\"Flow\") {\n            let flowWallet=Profile.Wallet( name:\"Flow\", receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), tags: [\"flow\"])\n    \n            profile.addWallet(flowWallet)\n            updated=true\n        }\n        if !profile.hasWallet(\"FUSD\") {\n            profile.addWallet(Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), tags: [\"fusd\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if !profile.hasWallet(\"USDC\") {\n            profile.addWallet(Profile.Wallet( name:\"USDC\", receiver:usdcCap, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(FiatToken.VaultBalancePubPath), accept: Type\u003c@FiatToken.Vault\u003e(), tags: [\"usdc\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else if updated {\n            profile.emitUpdatedEvent()\n        }\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        let doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        let doeSalePublicPath=FindMarket.getPublicPath(doeSaleType, name: tenant.name)\n        let doeSaleStoragePath= FindMarket.getStoragePath(doeSaleType, name:tenant.name)\n        let doeSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n        if !doeSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n        }\n\n        let doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        let doeBidPublicPath=FindMarket.getPublicPath(doeBidType, name: tenant.name)\n        let doeBidStoragePath= FindMarket.getStoragePath(doeBidType, name:tenant.name)\n        let doeBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n        if !doeBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n        }\n\n        /// auctions that escrow ft\n        let aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        let aeSalePublicPath=FindMarket.getPublicPath(aeSaleType, name: tenant.name)\n        let aeSaleStoragePath= FindMarket.getStoragePath(aeSaleType, name:tenant.name)\n        let aeSaleCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n        if !aeSaleCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n        }\n\n        let dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\n        let dosSalePublicPath=FindMarket.getPublicPath(dosSaleType, name: tenant.name)\n        let dosSaleStoragePath= FindMarket.getStoragePath(dosSaleType, name:tenant.name)\n\n        let dosSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n        if !dosSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n        }\n\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n        if !dosBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n        }\n\n        let aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\n        let aeBidPublicPath=FindMarket.getPublicPath(aeBidType, name: tenant.name)\n        let aeBidStoragePath= FindMarket.getStoragePath(aeBidType, name:tenant.name)\n        let aeBidCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n        if !aeBidCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n        }\n\n     /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n        }\n\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n        if !asBidCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n        }\n\n        let leaseTenantCapability= FindMarket.getTenantCapability(FindMarket.getTenantAddress(\"findLease\")!)!\n\n        let leaseSaleItemType= Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()\n        let leasePublicPath=FindMarket.getPublicPath(leaseSaleItemType, name: \"findLease\")\n        let leaseStoragePath= FindMarket.getStoragePath(leaseSaleItemType, name:\"findLease\")\n        let leaseSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath) \n        if !leaseSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketSale.SaleItemCollection\u003e(\u003c- FindLeaseMarketSale.createEmptySaleItemCollection(leaseTenantCapability), to: leaseStoragePath)\n            account.link\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath, target: leaseStoragePath)\n        }\n\n        let leaseASSaleItemType= Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e()\n        let leaseASPublicPath=FindMarket.getPublicPath(leaseASSaleItemType, name: \"findLease\")\n        let leaseASStoragePath= FindMarket.getStoragePath(leaseASSaleItemType, name:\"findLease\")\n        let leaseASSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath) \n        if !leaseASSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseASStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath, target: leaseASStoragePath)\n        }\n\n\n        let leaseASBidType= Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e()\n        let leaseASBidPublicPath=FindMarket.getPublicPath(leaseASBidType, name: \"findLease\")\n        let leaseASBidStoragePath= FindMarket.getStoragePath(leaseASBidType, name: \"findLease\")\n        let leaseASBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath) \n        if !leaseASBidCap.check() {\n            account.save\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseASBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath, target: leaseASBidStoragePath)\n        }\n\n        // let leaseAESaleItemType= Type\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e()\n        // let leaseAEPublicPath=FindMarket.getPublicPath(leaseAESaleItemType, name: \"findLease\")\n        // let leaseAEStoragePath= FindMarket.getStoragePath(leaseAESaleItemType, name:\"findLease\")\n        // let leaseAESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath) \n        // if !leaseAESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseAEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath, target: leaseAEStoragePath)\n        // }\n\n        // let leaseAEBidType= Type\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e()\n        // let leaseAEBidPublicPath=FindMarket.getPublicPath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidStoragePath= FindMarket.getStoragePath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath) \n        // if !leaseAEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseAEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath, target: leaseAEBidStoragePath)\n        // }\n\n        let leaseDOSSaleItemType= Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e()\n        let leaseDOSPublicPath=FindMarket.getPublicPath(leaseDOSSaleItemType, name: \"findLease\")\n        let leaseDOSStoragePath= FindMarket.getStoragePath(leaseDOSSaleItemType, name:\"findLease\")\n        let leaseDOSSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath) \n        if !leaseDOSSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOSStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath, target: leaseDOSStoragePath)\n        }\n\n        let leaseDOSBidType= Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let leaseDOSBidPublicPath=FindMarket.getPublicPath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidStoragePath= FindMarket.getStoragePath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath) \n        if !leaseDOSBidCap.check() {\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOSBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath, target: leaseDOSBidStoragePath)\n        }\n\n        // let leaseDOESaleItemType= Type\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        // let leaseDOEPublicPath=FindMarket.getPublicPath(leaseDOESaleItemType, name: \"findLease\")\n        // let leaseDOEStoragePath= FindMarket.getStoragePath(leaseDOESaleItemType, name:\"findLease\")\n        // let leaseDOESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath) \n        // if !leaseDOESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath, target: leaseDOEStoragePath)\n        // }\n\n        // let leaseDOEBidType= Type\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        // let leaseDOEBidPublicPath=FindMarket.getPublicPath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidStoragePath= FindMarket.getStoragePath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath) \n        // if !leaseDOEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath, target: leaseDOEBidStoragePath)\n        // }\n        //SYNC with register\n\n        // Get supported NFT and FT Information from Registries from input alias\n        let ft = FTRegistry.getFTInfo(ftAliasOrIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftAliasOrIdentifier))\n        \n        let leaseTenant = leaseTenantCapability.borrow()!\n        self.saleItems= account.borrow\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(from: leaseTenant.getStoragePath(Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e()))\n        let ref = account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from: FIND.LeaseStoragePath)!\n        self.pointer= FindLeaseMarket.AuthLeasePointer(ref: ref, name: leaseName)\n        self.vaultType= ft.type\n\n    }\n\n    pre{\n        // Ben : panic on some unreasonable inputs in trxn \n        minimumBidIncrement \u003e 0.0 :\"Minimum bid increment should be larger than 0.\"\n        (auctionReservePrice - auctionReservePrice) % minimumBidIncrement == 0.0 : \"Acution ReservePrice should be in step of minimum bid increment.\" \n        auctionDuration \u003e 0.0 : \"Auction Duration should be greater than 0.\"\n        auctionExtensionOnLateBid \u003e 0.0 : \"Auction Duration should be greater than 0.\"\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        self.saleItems!.listForAuction(pointer: self.pointer, vaultType: self.vaultType, auctionStartPrice: price, auctionReservePrice: auctionReservePrice, auctionDuration: auctionDuration, auctionExtensionOnLateBid: auctionExtensionOnLateBid, minimumBidIncrement: minimumBidIncrement, auctionValidUntil: auctionValidUntil, saleItemExtraField: {})\n\n    }\n}",
               "spec": {
                  "order": [
                     "leaseName",
                     "ftAliasOrIdentifier",
                     "price",
                     "auctionReservePrice",
                     "auctionDuration",
                     "auctionExtensionOnLateBid",
                     "minimumBidIncrement",
                     "auctionValidUntil"
                  ],
                  "parameters": {
                     "auctionDuration": "UFix64",
                     "auctionExtensionOnLateBid": "UFix64",
                     "auctionReservePrice": "UFix64",
                     "auctionValidUntil": "UFix64?",
                     "ftAliasOrIdentifier": "String",
                     "leaseName": "String",
                     "minimumBidIncrement": "UFix64",
                     "price": "UFix64"
                  }
               }
            },
            "listLeaseForAuctionSoftDUC": {
               "code": "import FindMarket from 0x097bafa4e0b48eef\nimport FindMarketSale from 0x097bafa4e0b48eef\nimport FindMarketAuctionEscrow from 0x097bafa4e0b48eef\nimport FindMarketAuctionSoft from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferEscrow from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferSoft from 0x097bafa4e0b48eef\nimport NonFungibleToken from 0x1d7e57aa55817448\nimport MetadataViews from 0x1d7e57aa55817448\nimport FindViews from 0x097bafa4e0b48eef\nimport FTRegistry from 0x097bafa4e0b48eef\nimport FungibleToken from 0xf233dcee88fe0abe\nimport FlowToken from 0x1654653399040a61\nimport TokenForwarding from 0xe544175ee0461c4b\nimport DapperUtilityCoin from 0xead892083b3e2c6c\nimport FIND from 0x097bafa4e0b48eef\nimport Dandy from 0x097bafa4e0b48eef\nimport Profile from 0x097bafa4e0b48eef\nimport FindLeaseMarketSale from 0x097bafa4e0b48eef\nimport FindLeaseMarketAuctionSoft from 0x097bafa4e0b48eef\n// import FindLeaseMarketAuctionEscrow from \"../contracts/FindLeaseMarketAuctionEscrow.cdc\"\nimport FindLeaseMarketDirectOfferSoft from 0x097bafa4e0b48eef\n// import FindLeaseMarketDirectOfferEscrow from \"../contracts/FindLeaseMarketDirectOfferEscrow.cdc\"\nimport FindLeaseMarket from 0x097bafa4e0b48eef\n\ntransaction(dapperAddress: Address, leaseName: String, price:UFix64, auctionReservePrice: UFix64, auctionDuration: UFix64, auctionExtensionOnLateBid: UFix64, minimumBidIncrement: UFix64, auctionValidUntil: UFix64?) {\n    \n    let saleItems : \u0026FindLeaseMarketAuctionSoft.SaleItemCollection?\n    let pointer : FindLeaseMarket.AuthLeasePointer\n    let vaultType : Type\n    \n    prepare(account: AuthAccount) {\n\n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n        //SYNC with register\n        //Add exising FUSD or create a new one and add it\n        let name = account.address.toString()\n        let ducReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver)\n        if !ducReceiver.check() {\n            let dapper = getAccount(dapperAddress)\n            // Create a new Forwarder resource for DUC and store it in the new account's storage\n            let ducForwarder \u003c- TokenForwarding.createNewForwarder(recipient: dapper.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver))\n            account.save(\u003c-ducForwarder, to: /storage/dapperUtilityCoinReceiver)\n            // Publish a Receiver capability for the new account, which is linked to the DUC Forwarder\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver,target: /storage/dapperUtilityCoinReceiver)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: ducReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let dandyCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        let dandyCapPrivate= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPrivatePath)\n        if !dandyCapPrivate.check() {\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        var created=false\n        var updated=false\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        if !profile.hasWallet(\"Flow\") {\n            let flowWallet=Profile.Wallet( name:\"Flow\", receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), tags: [\"flow\"])\n    \n            profile.addWallet(flowWallet)\n            updated=true\n        }\n        if !profile.hasWallet(\"DUC\") {\n            profile.addWallet(Profile.Wallet( name:\"DUC\", receiver:ducReceiver, balance:getAccount(dapperAddress).getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/dapperUtilityCoinBalance), accept: Type\u003c@DapperUtilityCoin.Vault\u003e(), tags: [\"duc\", \"dapperUtilityCoin\",\"dapper\"]))\n            updated=true\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else {\n            profile.emitUpdatedEvent()\n        }\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        let doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        let doeSalePublicPath=FindMarket.getPublicPath(doeSaleType, name: tenant.name)\n        let doeSaleStoragePath= FindMarket.getStoragePath(doeSaleType, name:tenant.name)\n        let doeSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n        if !doeSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n        }\n\n        let doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        let doeBidPublicPath=FindMarket.getPublicPath(doeBidType, name: tenant.name)\n        let doeBidStoragePath= FindMarket.getStoragePath(doeBidType, name:tenant.name)\n        let doeBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n        if !doeBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n        }\n\n        /// auctions that escrow ft\n        let aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        let aeSalePublicPath=FindMarket.getPublicPath(aeSaleType, name: tenant.name)\n        let aeSaleStoragePath= FindMarket.getStoragePath(aeSaleType, name:tenant.name)\n        let aeSaleCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n        if !aeSaleCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n        }\n\n        let dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\n        let dosSalePublicPath=FindMarket.getPublicPath(dosSaleType, name: tenant.name)\n        let dosSaleStoragePath= FindMarket.getStoragePath(dosSaleType, name:tenant.name)\n\n        let dosSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n        if !dosSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n        }\n\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n        if !dosBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n        }\n\n        let aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\n        let aeBidPublicPath=FindMarket.getPublicPath(aeBidType, name: tenant.name)\n        let aeBidStoragePath= FindMarket.getStoragePath(aeBidType, name:tenant.name)\n        let aeBidCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n        if !aeBidCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n        }\n\n     /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n        }\n\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n        if !asBidCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n        }\n\n        let leaseTenantCapability= FindMarket.getTenantCapability(FindMarket.getTenantAddress(\"findLease\")!)!\n\n        let leaseSaleItemType= Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()\n        let leasePublicPath=FindMarket.getPublicPath(leaseSaleItemType, name: \"findLease\")\n        let leaseStoragePath= FindMarket.getStoragePath(leaseSaleItemType, name:\"findLease\")\n        let leaseSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath) \n        if !leaseSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketSale.SaleItemCollection\u003e(\u003c- FindLeaseMarketSale.createEmptySaleItemCollection(leaseTenantCapability), to: leaseStoragePath)\n            account.link\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath, target: leaseStoragePath)\n        }\n\n        let leaseASSaleItemType= Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e()\n        let leaseASPublicPath=FindMarket.getPublicPath(leaseASSaleItemType, name: \"findLease\")\n        let leaseASStoragePath= FindMarket.getStoragePath(leaseASSaleItemType, name:\"findLease\")\n        let leaseASSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath) \n        if !leaseASSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseASStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath, target: leaseASStoragePath)\n        }\n\n\n        let leaseASBidType= Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e()\n        let leaseASBidPublicPath=FindMarket.getPublicPath(leaseASBidType, name: \"findLease\")\n        let leaseASBidStoragePath= FindMarket.getStoragePath(leaseASBidType, name: \"findLease\")\n        let leaseASBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath) \n        if !leaseASBidCap.check() {\n            account.save\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseASBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath, target: leaseASBidStoragePath)\n        }\n\n        // let leaseAESaleItemType= Type\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e()\n        // let leaseAEPublicPath=FindMarket.getPublicPath(leaseAESaleItemType, name: \"findLease\")\n        // let leaseAEStoragePath= FindMarket.getStoragePath(leaseAESaleItemType, name:\"findLease\")\n        // let leaseAESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath) \n        // if !leaseAESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseAEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath, target: leaseAEStoragePath)\n        // }\n\n        // let leaseAEBidType= Type\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e()\n        // let leaseAEBidPublicPath=FindMarket.getPublicPath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidStoragePath= FindMarket.getStoragePath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath) \n        // if !leaseAEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseAEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath, target: leaseAEBidStoragePath)\n        // }\n\n        let leaseDOSSaleItemType= Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e()\n        let leaseDOSPublicPath=FindMarket.getPublicPath(leaseDOSSaleItemType, name: \"findLease\")\n        let leaseDOSStoragePath= FindMarket.getStoragePath(leaseDOSSaleItemType, name:\"findLease\")\n        let leaseDOSSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath) \n        if !leaseDOSSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOSStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath, target: leaseDOSStoragePath)\n        }\n\n        let leaseDOSBidType= Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let leaseDOSBidPublicPath=FindMarket.getPublicPath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidStoragePath= FindMarket.getStoragePath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath) \n        if !leaseDOSBidCap.check() {\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOSBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath, target: leaseDOSBidStoragePath)\n        }\n\n        // let leaseDOESaleItemType= Type\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        // let leaseDOEPublicPath=FindMarket.getPublicPath(leaseDOESaleItemType, name: \"findLease\")\n        // let leaseDOEStoragePath= FindMarket.getStoragePath(leaseDOESaleItemType, name:\"findLease\")\n        // let leaseDOESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath) \n        // if !leaseDOESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath, target: leaseDOEStoragePath)\n        // }\n\n        // let leaseDOEBidType= Type\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        // let leaseDOEBidPublicPath=FindMarket.getPublicPath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidStoragePath= FindMarket.getStoragePath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath) \n        // if !leaseDOEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath, target: leaseDOEBidStoragePath)\n        // }\n        //SYNC with register\n\n        // Get supported NFT and FT Information from Registries from input alias\n        let ft = FTRegistry.getFTInfo(Type\u003c@DapperUtilityCoin.Vault\u003e().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(Type\u003c@DapperUtilityCoin.Vault\u003e().identifier))\n        \n        let leaseTenant = leaseTenantCapability.borrow()!\n        self.saleItems= account.borrow\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(from: leaseTenant.getStoragePath(Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e()))\n        let ref= account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from: FIND.LeaseStoragePath)!\n        self.pointer= FindLeaseMarket.AuthLeasePointer(ref: ref, name: leaseName)    \n        self.vaultType= ft.type    \n    }\n\n    pre{\n        // Ben : panic on some unreasonable inputs in trxn \n        minimumBidIncrement \u003e 0.0 :\"Minimum bid increment should be larger than 0.\"\n        (auctionReservePrice - auctionReservePrice) % minimumBidIncrement == 0.0 : \"Acution ReservePrice should be in step of minimum bid increment.\" \n        auctionDuration \u003e 0.0 : \"Auction Duration should be greater than 0.\"\n        auctionExtensionOnLateBid \u003e 0.0 : \"Auction Duration should be greater than 0.\"\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        self.saleItems!.listForAuction(pointer: self.pointer, vaultType: self.vaultType, auctionStartPrice: price, auctionReservePrice: auctionReservePrice, auctionDuration: auctionDuration, auctionExtensionOnLateBid: auctionExtensionOnLateBid, minimumBidIncrement: minimumBidIncrement, auctionValidUntil: auctionValidUntil, saleItemExtraField: {})\n\n    }\n}",
               "spec": {
                  "order": [
                     "dapperAddress",
                     "leaseName",
                     "price",
                     "auctionReservePrice",
                     "auctionDuration",
                     "auctionExtensionOnLateBid",
                     "minimumBidIncrement",
                     "auctionValidUntil"
                  ],
                  "parameters": {
                     "auctionDuration": "UFix64",
                     "auctionExtensionOnLateBid": "UFix64",
                     "auctionReservePrice": "UFix64",
                     "auctionValidUntil": "UFix64?",
                     "dapperAddress": "Address",
                     "leaseName": "String",
                     "minimumBidIncrement": "UFix64",
                     "price": "UFix64"
                  }
               }
            },
            "listLeaseForSale": {
               "code": "import FindMarket from 0x097bafa4e0b48eef\nimport FindMarketSale from 0x097bafa4e0b48eef\nimport FindMarketAuctionEscrow from 0x097bafa4e0b48eef\nimport FindMarketAuctionSoft from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferEscrow from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferSoft from 0x097bafa4e0b48eef\nimport FungibleToken from 0xf233dcee88fe0abe\nimport FUSD from 0x3c5959b568896393\nimport FlowToken from 0x1654653399040a61\nimport FiatToken from 0xb19436aae4d94622\nimport FIND from 0x097bafa4e0b48eef\nimport Dandy from 0x097bafa4e0b48eef\nimport Profile from 0x097bafa4e0b48eef\nimport NonFungibleToken from 0x1d7e57aa55817448\nimport MetadataViews from 0x1d7e57aa55817448\nimport FindViews from 0x097bafa4e0b48eef\nimport FTRegistry from 0x097bafa4e0b48eef\nimport FindLeaseMarketSale from 0x097bafa4e0b48eef\nimport FindLeaseMarketAuctionSoft from 0x097bafa4e0b48eef\n// import FindLeaseMarketAuctionEscrow from \"../contracts/FindLeaseMarketAuctionEscrow.cdc\"\nimport FindLeaseMarketDirectOfferSoft from 0x097bafa4e0b48eef\n// import FindLeaseMarketDirectOfferEscrow from \"../contracts/FindLeaseMarketDirectOfferEscrow.cdc\"\nimport FindLeaseMarket from 0x097bafa4e0b48eef\n\ntransaction(leaseName: String, ftAliasOrIdentifier: String, directSellPrice:UFix64, validUntil: UFix64?) {\n\n    let saleItems : \u0026FindLeaseMarketSale.SaleItemCollection?\n    let pointer : FindLeaseMarket.AuthLeasePointer\n    let vaultType : Type\n\n    prepare(account: AuthAccount) {\n\n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n        //SYNC with register\n        //Add exising FUSD or create a new one and add it\n        let name = account.address.toString()\n        let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n        if !fusdReceiver.check() {\n            let fusd \u003c- FUSD.createEmptyVault()\n            account.save(\u003c- fusd, to: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n        }\n\n        let usdcCap = account.getCapability\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e(FiatToken.VaultReceiverPubPath)\n        if !usdcCap.check() {\n                account.save( \u003c-FiatToken.createEmptyVault(), to: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e( FiatToken.VaultReceiverPubPath, target: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FiatToken.ResourceId}\u003e( FiatToken.VaultUUIDPubPath, target: FiatToken.VaultStoragePath)\n                account.link\u003c\u0026FiatToken.Vault{FungibleToken.Balance}\u003e( FiatToken.VaultBalancePubPath, target:FiatToken.VaultStoragePath)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let dandyCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        let dandyCapPrivate= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPrivatePath)\n        if !dandyCapPrivate.check() {\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        var created=false\n        var updated=false\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        if !profile.hasWallet(\"Flow\") {\n            let flowWallet=Profile.Wallet( name:\"Flow\", receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), tags: [\"flow\"])\n    \n            profile.addWallet(flowWallet)\n            updated=true\n        }\n        if !profile.hasWallet(\"FUSD\") {\n            profile.addWallet(Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), tags: [\"fusd\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if !profile.hasWallet(\"USDC\") {\n            profile.addWallet(Profile.Wallet( name:\"USDC\", receiver:usdcCap, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(FiatToken.VaultBalancePubPath), accept: Type\u003c@FiatToken.Vault\u003e(), tags: [\"usdc\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else if updated {\n            profile.emitUpdatedEvent()\n        }\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let market = FindMarket.getFindTenantAddress()\n        let tenantCapability= FindMarket.getTenantCapability(market)!\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        let doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        let doeSalePublicPath=FindMarket.getPublicPath(doeSaleType, name: tenant.name)\n        let doeSaleStoragePath= FindMarket.getStoragePath(doeSaleType, name:tenant.name)\n        let doeSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n        if !doeSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n        }\n\n        let doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        let doeBidPublicPath=FindMarket.getPublicPath(doeBidType, name: tenant.name)\n        let doeBidStoragePath= FindMarket.getStoragePath(doeBidType, name:tenant.name)\n        let doeBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n        if !doeBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n        }\n\n        /// auctions that escrow ft\n        let aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        let aeSalePublicPath=FindMarket.getPublicPath(aeSaleType, name: tenant.name)\n        let aeSaleStoragePath= FindMarket.getStoragePath(aeSaleType, name:tenant.name)\n        let aeSaleCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n        if !aeSaleCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n        }\n\n        let dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\n        let dosSalePublicPath=FindMarket.getPublicPath(dosSaleType, name: tenant.name)\n        let dosSaleStoragePath= FindMarket.getStoragePath(dosSaleType, name:tenant.name)\n\n        let dosSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n        if !dosSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n        }\n\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n        if !dosBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n        }\n\n        let aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\n        let aeBidPublicPath=FindMarket.getPublicPath(aeBidType, name: tenant.name)\n        let aeBidStoragePath= FindMarket.getStoragePath(aeBidType, name:tenant.name)\n        let aeBidCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n        if !aeBidCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n        }\n\n     /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n        }\n\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n        if !asBidCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n        }\n\n        let leaseTenantCapability= FindMarket.getTenantCapability(FindMarket.getTenantAddress(\"findLease\")!)!\n\n        let leaseSaleItemType= Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()\n        let leasePublicPath=FindMarket.getPublicPath(leaseSaleItemType, name: \"findLease\")\n        let leaseStoragePath= FindMarket.getStoragePath(leaseSaleItemType, name:\"findLease\")\n        let leaseSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath) \n        if !leaseSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketSale.SaleItemCollection\u003e(\u003c- FindLeaseMarketSale.createEmptySaleItemCollection(leaseTenantCapability), to: leaseStoragePath)\n            account.link\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath, target: leaseStoragePath)\n        }\n\n        let leaseASSaleItemType= Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e()\n        let leaseASPublicPath=FindMarket.getPublicPath(leaseASSaleItemType, name: \"findLease\")\n        let leaseASStoragePath= FindMarket.getStoragePath(leaseASSaleItemType, name:\"findLease\")\n        let leaseASSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath) \n        if !leaseASSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseASStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath, target: leaseASStoragePath)\n        }\n\n\n        let leaseASBidType= Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e()\n        let leaseASBidPublicPath=FindMarket.getPublicPath(leaseASBidType, name: \"findLease\")\n        let leaseASBidStoragePath= FindMarket.getStoragePath(leaseASBidType, name: \"findLease\")\n        let leaseASBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath) \n        if !leaseASBidCap.check() {\n            account.save\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseASBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath, target: leaseASBidStoragePath)\n        }\n\n        // let leaseAESaleItemType= Type\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e()\n        // let leaseAEPublicPath=FindMarket.getPublicPath(leaseAESaleItemType, name: \"findLease\")\n        // let leaseAEStoragePath= FindMarket.getStoragePath(leaseAESaleItemType, name:\"findLease\")\n        // let leaseAESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath) \n        // if !leaseAESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseAEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath, target: leaseAEStoragePath)\n        // }\n\n        // let leaseAEBidType= Type\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e()\n        // let leaseAEBidPublicPath=FindMarket.getPublicPath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidStoragePath= FindMarket.getStoragePath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath) \n        // if !leaseAEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseAEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath, target: leaseAEBidStoragePath)\n        // }\n\n        let leaseDOSSaleItemType= Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e()\n        let leaseDOSPublicPath=FindMarket.getPublicPath(leaseDOSSaleItemType, name: \"findLease\")\n        let leaseDOSStoragePath= FindMarket.getStoragePath(leaseDOSSaleItemType, name:\"findLease\")\n        let leaseDOSSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath) \n        if !leaseDOSSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOSStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath, target: leaseDOSStoragePath)\n        }\n\n        let leaseDOSBidType= Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let leaseDOSBidPublicPath=FindMarket.getPublicPath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidStoragePath= FindMarket.getStoragePath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath) \n        if !leaseDOSBidCap.check() {\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOSBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath, target: leaseDOSBidStoragePath)\n        }\n\n        // let leaseDOESaleItemType= Type\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        // let leaseDOEPublicPath=FindMarket.getPublicPath(leaseDOESaleItemType, name: \"findLease\")\n        // let leaseDOEStoragePath= FindMarket.getStoragePath(leaseDOESaleItemType, name:\"findLease\")\n        // let leaseDOESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath) \n        // if !leaseDOESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath, target: leaseDOEStoragePath)\n        // }\n\n        // let leaseDOEBidType= Type\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        // let leaseDOEBidPublicPath=FindMarket.getPublicPath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidStoragePath= FindMarket.getStoragePath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath) \n        // if !leaseDOEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath, target: leaseDOEBidStoragePath)\n        // }\n        //SYNC with register\n\n        // Get the salesItemRef from tenant\n        let leaseTenant = leaseTenantCapability.borrow()!\n        self.saleItems= account.borrow\u003c\u0026FindLeaseMarketSale.SaleItemCollection\u003e(from: leaseTenant.getStoragePath(Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()))!\n\n        // Get supported NFT and FT Information from Registries from input alias\n        let ft = FTRegistry.getFTInfo(ftAliasOrIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftAliasOrIdentifier))\n        self.vaultType= ft.type\n\n        let lease=account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from: FIND.LeaseStoragePath)!\n\n\n        self.pointer= FindLeaseMarket.AuthLeasePointer(ref:lease, name: leaseName)\n\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        self.saleItems!.listForSale(pointer: self.pointer, vaultType: self.vaultType, directSellPrice: directSellPrice, validUntil: validUntil, extraField: {})\n    }\n}",
               "spec": {
                  "order": [
                     "leaseName",
                     "ftAliasOrIdentifier",
                     "directSellPrice",
                     "validUntil"
                  ],
                  "parameters": {
                     "directSellPrice": "UFix64",
                     "ftAliasOrIdentifier": "String",
                     "leaseName": "String",
                     "validUntil": "UFix64?"
                  }
               }
            },
            "listLeaseForSaleDUC": {
               "code": "import FindMarket from 0x097bafa4e0b48eef\nimport FindMarketSale from 0x097bafa4e0b48eef\nimport FindMarketAuctionEscrow from 0x097bafa4e0b48eef\nimport FindMarketAuctionSoft from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferEscrow from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferSoft from 0x097bafa4e0b48eef\nimport FungibleToken from 0xf233dcee88fe0abe\nimport DapperUtilityCoin from 0xead892083b3e2c6c\nimport TokenForwarding from 0xe544175ee0461c4b\nimport FlowToken from 0x1654653399040a61\nimport FIND from 0x097bafa4e0b48eef\nimport Dandy from 0x097bafa4e0b48eef\nimport Profile from 0x097bafa4e0b48eef\nimport NonFungibleToken from 0x1d7e57aa55817448\nimport MetadataViews from 0x1d7e57aa55817448\nimport FindViews from 0x097bafa4e0b48eef\nimport FTRegistry from 0x097bafa4e0b48eef\nimport FindLeaseMarketSale from 0x097bafa4e0b48eef\nimport FindLeaseMarketAuctionSoft from 0x097bafa4e0b48eef\n// import FindLeaseMarketAuctionEscrow from \"../contracts/FindLeaseMarketAuctionEscrow.cdc\"\nimport FindLeaseMarketDirectOfferSoft from 0x097bafa4e0b48eef\n// import FindLeaseMarketDirectOfferEscrow from \"../contracts/FindLeaseMarketDirectOfferEscrow.cdc\"\nimport FindLeaseMarket from 0x097bafa4e0b48eef\n\ntransaction(dapperAddress: Address, leaseName: String, directSellPrice:UFix64, validUntil: UFix64?) {\n\n    let saleItems : \u0026FindLeaseMarketSale.SaleItemCollection?\n    let pointer : FindLeaseMarket.AuthLeasePointer\n    let vaultType : Type\n\n    prepare(account: AuthAccount) {\n\n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n        //SYNC with register\n        //Add exising FUSD or create a new one and add it\n        let name = account.address.toString()\n        let ducReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver)\n        if !ducReceiver.check() {\n            let dapper = getAccount(dapperAddress)\n            // Create a new Forwarder resource for DUC and store it in the new account's storage\n            let ducForwarder \u003c- TokenForwarding.createNewForwarder(recipient: dapper.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver))\n            account.save(\u003c-ducForwarder, to: /storage/dapperUtilityCoinReceiver)\n            // Publish a Receiver capability for the new account, which is linked to the DUC Forwarder\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver,target: /storage/dapperUtilityCoinReceiver)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: ducReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let dandyCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        let dandyCapPrivate= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPrivatePath)\n        if !dandyCapPrivate.check() {\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        var created=false\n        var updated=false\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        if !profile.hasWallet(\"Flow\") {\n            let flowWallet=Profile.Wallet( name:\"Flow\", receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), tags: [\"flow\"])\n    \n            profile.addWallet(flowWallet)\n            updated=true\n        }\n        if !profile.hasWallet(\"DUC\") {\n            profile.addWallet(Profile.Wallet( name:\"DUC\", receiver:ducReceiver, balance:getAccount(dapperAddress).getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/dapperUtilityCoinBalance), accept: Type\u003c@DapperUtilityCoin.Vault\u003e(), tags: [\"duc\", \"dapperUtilityCoin\",\"dapper\"]))\n            updated=true\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else {\n            profile.emitUpdatedEvent()\n        }\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        let doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        let doeSalePublicPath=FindMarket.getPublicPath(doeSaleType, name: tenant.name)\n        let doeSaleStoragePath= FindMarket.getStoragePath(doeSaleType, name:tenant.name)\n        let doeSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n        if !doeSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n        }\n\n        let doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        let doeBidPublicPath=FindMarket.getPublicPath(doeBidType, name: tenant.name)\n        let doeBidStoragePath= FindMarket.getStoragePath(doeBidType, name:tenant.name)\n        let doeBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n        if !doeBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n        }\n\n        /// auctions that escrow ft\n        let aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        let aeSalePublicPath=FindMarket.getPublicPath(aeSaleType, name: tenant.name)\n        let aeSaleStoragePath= FindMarket.getStoragePath(aeSaleType, name:tenant.name)\n        let aeSaleCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n        if !aeSaleCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n        }\n\n        let dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\n        let dosSalePublicPath=FindMarket.getPublicPath(dosSaleType, name: tenant.name)\n        let dosSaleStoragePath= FindMarket.getStoragePath(dosSaleType, name:tenant.name)\n\n        let dosSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n        if !dosSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n        }\n\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n        if !dosBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n        }\n\n        let aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\n        let aeBidPublicPath=FindMarket.getPublicPath(aeBidType, name: tenant.name)\n        let aeBidStoragePath= FindMarket.getStoragePath(aeBidType, name:tenant.name)\n        let aeBidCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n        if !aeBidCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n        }\n\n     /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n        }\n\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n        if !asBidCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n        }\n\n        let leaseTenantCapability= FindMarket.getTenantCapability(FindMarket.getTenantAddress(\"findLease\")!)!\n\n        let leaseSaleItemType= Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()\n        let leasePublicPath=FindMarket.getPublicPath(leaseSaleItemType, name: \"findLease\")\n        let leaseStoragePath= FindMarket.getStoragePath(leaseSaleItemType, name:\"findLease\")\n        let leaseSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath) \n        if !leaseSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketSale.SaleItemCollection\u003e(\u003c- FindLeaseMarketSale.createEmptySaleItemCollection(leaseTenantCapability), to: leaseStoragePath)\n            account.link\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath, target: leaseStoragePath)\n        }\n\n        let leaseASSaleItemType= Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e()\n        let leaseASPublicPath=FindMarket.getPublicPath(leaseASSaleItemType, name: \"findLease\")\n        let leaseASStoragePath= FindMarket.getStoragePath(leaseASSaleItemType, name:\"findLease\")\n        let leaseASSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath) \n        if !leaseASSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseASStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath, target: leaseASStoragePath)\n        }\n\n\n        let leaseASBidType= Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e()\n        let leaseASBidPublicPath=FindMarket.getPublicPath(leaseASBidType, name: \"findLease\")\n        let leaseASBidStoragePath= FindMarket.getStoragePath(leaseASBidType, name: \"findLease\")\n        let leaseASBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath) \n        if !leaseASBidCap.check() {\n            account.save\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseASBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath, target: leaseASBidStoragePath)\n        }\n\n        // let leaseAESaleItemType= Type\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e()\n        // let leaseAEPublicPath=FindMarket.getPublicPath(leaseAESaleItemType, name: \"findLease\")\n        // let leaseAEStoragePath= FindMarket.getStoragePath(leaseAESaleItemType, name:\"findLease\")\n        // let leaseAESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath) \n        // if !leaseAESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseAEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath, target: leaseAEStoragePath)\n        // }\n\n        // let leaseAEBidType= Type\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e()\n        // let leaseAEBidPublicPath=FindMarket.getPublicPath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidStoragePath= FindMarket.getStoragePath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath) \n        // if !leaseAEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseAEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath, target: leaseAEBidStoragePath)\n        // }\n\n        let leaseDOSSaleItemType= Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e()\n        let leaseDOSPublicPath=FindMarket.getPublicPath(leaseDOSSaleItemType, name: \"findLease\")\n        let leaseDOSStoragePath= FindMarket.getStoragePath(leaseDOSSaleItemType, name:\"findLease\")\n        let leaseDOSSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath) \n        if !leaseDOSSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOSStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath, target: leaseDOSStoragePath)\n        }\n\n        let leaseDOSBidType= Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let leaseDOSBidPublicPath=FindMarket.getPublicPath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidStoragePath= FindMarket.getStoragePath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath) \n        if !leaseDOSBidCap.check() {\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOSBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath, target: leaseDOSBidStoragePath)\n        }\n\n        // let leaseDOESaleItemType= Type\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        // let leaseDOEPublicPath=FindMarket.getPublicPath(leaseDOESaleItemType, name: \"findLease\")\n        // let leaseDOEStoragePath= FindMarket.getStoragePath(leaseDOESaleItemType, name:\"findLease\")\n        // let leaseDOESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath) \n        // if !leaseDOESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath, target: leaseDOEStoragePath)\n        // }\n\n        // let leaseDOEBidType= Type\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        // let leaseDOEBidPublicPath=FindMarket.getPublicPath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidStoragePath= FindMarket.getStoragePath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath) \n        // if !leaseDOEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath, target: leaseDOEBidStoragePath)\n        // }\n        //SYNC with register\n\n        // Get the salesItemRef from tenant\n        let leaseTenant = leaseTenantCapability.borrow()!\n        self.saleItems= account.borrow\u003c\u0026FindLeaseMarketSale.SaleItemCollection\u003e(from: leaseTenant.getStoragePath(Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()))\n\n        // Get supported NFT and FT Information from Registries from input alias\n        let ft = FTRegistry.getFTInfo(Type\u003c@DapperUtilityCoin.Vault\u003e().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(Type\u003c@DapperUtilityCoin.Vault\u003e().identifier))\n        self.vaultType= ft.type\n\n        let ref=account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from: FIND.LeaseStoragePath)!\n\n        self.pointer= FindLeaseMarket.AuthLeasePointer(ref: ref, name: leaseName)\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        self.saleItems!.listForSale(pointer: self.pointer, vaultType: self.vaultType, directSellPrice: directSellPrice, validUntil: validUntil, extraField: {})\n\n    }\n\n}",
               "spec": {
                  "order": [
                     "dapperAddress",
                     "leaseName",
                     "directSellPrice",
                     "validUntil"
                  ],
                  "parameters": {
                     "dapperAddress": "Address",
                     "directSellPrice": "UFix64",
                     "leaseName": "String",
                     "validUntil": "UFix64?"
                  }
               }
            },
            "listMultipleNFTForSale": {
               "code": "import FindMarket from 0x097bafa4e0b48eef\nimport FindMarketSale from 0x097bafa4e0b48eef\nimport FindMarketAuctionEscrow from 0x097bafa4e0b48eef\nimport FindMarketAuctionSoft from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferEscrow from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferSoft from 0x097bafa4e0b48eef\nimport FungibleToken from 0xf233dcee88fe0abe\nimport FUSD from 0x3c5959b568896393\nimport FlowToken from 0x1654653399040a61\nimport FiatToken from 0xb19436aae4d94622\nimport FIND from 0x097bafa4e0b48eef\nimport Dandy from 0x097bafa4e0b48eef\nimport Profile from 0x097bafa4e0b48eef\nimport NonFungibleToken from 0x1d7e57aa55817448\nimport MetadataViews from 0x1d7e57aa55817448\nimport FindViews from 0x097bafa4e0b48eef\nimport NFTCatalog from 0x49a7cda3a1eecc29\nimport FINDNFTCatalog from 0x097bafa4e0b48eef\nimport FTRegistry from 0x097bafa4e0b48eef\n\ntransaction(marketplace:Address, nftAliasOrIdentifiers: [String], ids: [UInt64], ftAliasOrIdentifiers: [String], directSellPrices:[UFix64], validUntil: UFix64?) {\n    \n    let saleItems : \u0026FindMarketSale.SaleItemCollection?\n    let pointers : [FindViews.AuthNFTPointer]\n    let vaultTypes : [Type]\n\n    prepare(account: AuthAccount) {\n\n        if nftAliasOrIdentifiers.length != ids.length {\n            panic(\"The length of arrays passed in has to be the same\")\n        } else if nftAliasOrIdentifiers.length != ftAliasOrIdentifiers.length {\n            panic(\"The length of arrays passed in has to be the same\")\n        } else if nftAliasOrIdentifiers.length != directSellPrices.length {\n            panic(\"The length of arrays passed in has to be the same\")\n        }\n\n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n        //SYNC with register\n        //Add exising FUSD or create a new one and add it\n        let name = account.address.toString()\n        let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n        if !fusdReceiver.check() {\n            let fusd \u003c- FUSD.createEmptyVault()\n            account.save(\u003c- fusd, to: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n        }\n\n        let usdcCap = account.getCapability\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e(FiatToken.VaultReceiverPubPath)\n        if !usdcCap.check() {\n                account.save( \u003c-FiatToken.createEmptyVault(), to: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e( FiatToken.VaultReceiverPubPath, target: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FiatToken.ResourceId}\u003e( FiatToken.VaultUUIDPubPath, target: FiatToken.VaultStoragePath)\n                account.link\u003c\u0026FiatToken.Vault{FungibleToken.Balance}\u003e( FiatToken.VaultBalancePubPath, target:FiatToken.VaultStoragePath)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let dandyCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        let dandyCapPrivate= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPrivatePath)\n        if !dandyCapPrivate.check() {\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        var created=false\n        var updated=false\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        if !profile.hasWallet(\"Flow\") {\n            let flowWallet=Profile.Wallet( name:\"Flow\", receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), tags: [\"flow\"])\n    \n            profile.addWallet(flowWallet)\n            updated=true\n        }\n        if !profile.hasWallet(\"FUSD\") {\n            profile.addWallet(Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), tags: [\"fusd\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if !profile.hasWallet(\"USDC\") {\n            profile.addWallet(Profile.Wallet( name:\"USDC\", receiver:usdcCap, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(FiatToken.VaultBalancePubPath), accept: Type\u003c@FiatToken.Vault\u003e(), tags: [\"usdc\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else if updated {\n            profile.emitUpdatedEvent()\n        }\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        let doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        let doeSalePublicPath=FindMarket.getPublicPath(doeSaleType, name: tenant.name)\n        let doeSaleStoragePath= FindMarket.getStoragePath(doeSaleType, name:tenant.name)\n        let doeSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n        if !doeSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n        }\n\n        let doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        let doeBidPublicPath=FindMarket.getPublicPath(doeBidType, name: tenant.name)\n        let doeBidStoragePath= FindMarket.getStoragePath(doeBidType, name:tenant.name)\n        let doeBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n        if !doeBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n        }\n\n        /// auctions that escrow ft\n        let aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        let aeSalePublicPath=FindMarket.getPublicPath(aeSaleType, name: tenant.name)\n        let aeSaleStoragePath= FindMarket.getStoragePath(aeSaleType, name:tenant.name)\n        let aeSaleCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n        if !aeSaleCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n        }\n\n        let dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\n        let dosSalePublicPath=FindMarket.getPublicPath(dosSaleType, name: tenant.name)\n        let dosSaleStoragePath= FindMarket.getStoragePath(dosSaleType, name:tenant.name)\n\n        let dosSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n        if !dosSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n        }\n\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n        if !dosBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n        }\n\n        let aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\n        let aeBidPublicPath=FindMarket.getPublicPath(aeBidType, name: tenant.name)\n        let aeBidStoragePath= FindMarket.getStoragePath(aeBidType, name:tenant.name)\n        let aeBidCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n        if !aeBidCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n        }\n\n     /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n        }\n\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n        if !asBidCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n        }\n        //SYNC with register\n\n        self.saleItems= account.borrow\u003c\u0026FindMarketSale.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketSale.SaleItemCollection\u003e()))\n        self.vaultTypes= []\n        self.pointers= []\n\n        var counter = 0\n\n        let nfts : {String : NFTCatalog.NFTCollectionData} = {}\n        let fts : {String : FTRegistry.FTInfo} = {}\n\n        while counter \u003c ids.length {\n            // Get supported NFT and FT Information from Registries from input alias\n            var nft : NFTCatalog.NFTCollectionData? = nil\n            var ft : FTRegistry.FTInfo? = nil\n\n            if nfts[nftAliasOrIdentifiers[counter]] != nil {\n                nft = nfts[nftAliasOrIdentifiers[counter]]\n            } else {\n                let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftAliasOrIdentifiers[counter])?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftAliasOrIdentifiers[counter])) \n                let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n                nft = collection.collectionData\n                nfts[nftAliasOrIdentifiers[counter]] = nft\n            }\n\n            if fts[ftAliasOrIdentifiers[counter]] != nil {\n                ft = fts[ftAliasOrIdentifiers[counter]]\n            } else {\n                ft = FTRegistry.getFTInfo(ftAliasOrIdentifiers[counter]) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftAliasOrIdentifiers[counter]))\n                fts[ftAliasOrIdentifiers[counter]] = ft \n            }\n\n            var providerCap=account.getCapability\u003c\u0026{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e(nft!.privatePath)\n\n            /* Ben : Question -\u003e Either client will have to provide the path here or agree that we set it up for the user */\n            if !providerCap.check() {\n                let newCap = account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                        nft!.privatePath,\n                        target: nft!.storagePath\n                )\n                if newCap == nil {\n                    // If linking is not successful, we link it using finds custom link \n                    let pathIdentifier = nft!.privatePath.toString()\n                    let findPath = PrivatePath(identifier: pathIdentifier.slice(from: \"/private/\".length , upTo: pathIdentifier.length).concat(\"_FIND\"))!\n                    account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                        findPath,\n                        target: nft!.storagePath\n                    )\n                    providerCap = account.getCapability\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(findPath)\n                }\n            }\n            // Get the salesItemRef from tenant\n            self.pointers.append(FindViews.AuthNFTPointer(cap: providerCap, id: ids[counter]))\n            self.vaultTypes.append(ft!.type)\n            counter = counter + 1\n        }\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        var counter = 0\n        while counter \u003c ids.length {\n            self.saleItems!.listForSale(pointer: self.pointers[counter], vaultType: self.vaultTypes[counter], directSellPrice: directSellPrices[counter], validUntil: validUntil, extraField: {})\n            counter = counter + 1\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "nftAliasOrIdentifiers",
                     "ids",
                     "ftAliasOrIdentifiers",
                     "directSellPrices",
                     "validUntil"
                  ],
                  "parameters": {
                     "directSellPrices": "[UFix64]",
                     "ftAliasOrIdentifiers": "[String]",
                     "ids": "[UInt64]",
                     "marketplace": "Address",
                     "nftAliasOrIdentifiers": "[String]",
                     "validUntil": "UFix64?"
                  }
               }
            },
            "listMultipleNFTForSaleDUC": {
               "code": "import FindMarket from 0x097bafa4e0b48eef\nimport FindMarketSale from 0x097bafa4e0b48eef\nimport FindMarketAuctionEscrow from 0x097bafa4e0b48eef\nimport FindMarketAuctionSoft from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferEscrow from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferSoft from 0x097bafa4e0b48eef\nimport FungibleToken from 0xf233dcee88fe0abe\nimport DapperUtilityCoin from 0xead892083b3e2c6c\nimport TokenForwarding from 0xe544175ee0461c4b\nimport FlowToken from 0x1654653399040a61\nimport FIND from 0x097bafa4e0b48eef\nimport Dandy from 0x097bafa4e0b48eef\nimport Profile from 0x097bafa4e0b48eef\nimport NonFungibleToken from 0x1d7e57aa55817448\nimport MetadataViews from 0x1d7e57aa55817448\nimport FindViews from 0x097bafa4e0b48eef\nimport NFTCatalog from 0x49a7cda3a1eecc29\nimport FINDNFTCatalog from 0x097bafa4e0b48eef\nimport FTRegistry from 0x097bafa4e0b48eef\n\ntransaction(dapperAddress: Address, marketplace:Address, nftAliasOrIdentifiers: [String], ids: [UInt64], directSellPrices:[UFix64], validUntil: UFix64?) {\n    \n    let saleItems : \u0026FindMarketSale.SaleItemCollection?\n    let pointers : [FindViews.AuthNFTPointer]\n    \n    prepare(account: AuthAccount) {\n\n        if nftAliasOrIdentifiers.length != ids.length {\n            panic(\"The length of arrays passed in has to be the same\")\n        } else if nftAliasOrIdentifiers.length != directSellPrices.length {\n            panic(\"The length of arrays passed in has to be the same\")\n        }\n\n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n        //SYNC with register\n        //Add exising FUSD or create a new one and add it\n        let name = account.address.toString()\n        let ducReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver)\n        if !ducReceiver.check() {\n            let dapper = getAccount(dapperAddress)\n            // Create a new Forwarder resource for DUC and store it in the new account's storage\n            let ducForwarder \u003c- TokenForwarding.createNewForwarder(recipient: dapper.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver))\n            account.save(\u003c-ducForwarder, to: /storage/dapperUtilityCoinReceiver)\n            // Publish a Receiver capability for the new account, which is linked to the DUC Forwarder\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver,target: /storage/dapperUtilityCoinReceiver)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: ducReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let dandyCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        let dandyCapPrivate= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPrivatePath)\n        if !dandyCapPrivate.check() {\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        var created=false\n        var updated=false\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        if !profile.hasWallet(\"Flow\") {\n            let flowWallet=Profile.Wallet( name:\"Flow\", receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), tags: [\"flow\"])\n    \n            profile.addWallet(flowWallet)\n            updated=true\n        }\n        if !profile.hasWallet(\"DUC\") {\n            profile.addWallet(Profile.Wallet( name:\"DUC\", receiver:ducReceiver, balance:getAccount(dapperAddress).getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/dapperUtilityCoinBalance), accept: Type\u003c@DapperUtilityCoin.Vault\u003e(), tags: [\"duc\", \"dapperUtilityCoin\",\"dapper\"]))\n            updated=true\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else {\n            profile.emitUpdatedEvent()\n        }\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        let doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        let doeSalePublicPath=FindMarket.getPublicPath(doeSaleType, name: tenant.name)\n        let doeSaleStoragePath= FindMarket.getStoragePath(doeSaleType, name:tenant.name)\n        let doeSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n        if !doeSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n        }\n\n        let doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        let doeBidPublicPath=FindMarket.getPublicPath(doeBidType, name: tenant.name)\n        let doeBidStoragePath= FindMarket.getStoragePath(doeBidType, name:tenant.name)\n        let doeBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n        if !doeBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n        }\n\n        /// auctions that escrow ft\n        let aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        let aeSalePublicPath=FindMarket.getPublicPath(aeSaleType, name: tenant.name)\n        let aeSaleStoragePath= FindMarket.getStoragePath(aeSaleType, name:tenant.name)\n        let aeSaleCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n        if !aeSaleCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n        }\n\n        let dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\n        let dosSalePublicPath=FindMarket.getPublicPath(dosSaleType, name: tenant.name)\n        let dosSaleStoragePath= FindMarket.getStoragePath(dosSaleType, name:tenant.name)\n\n        let dosSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n        if !dosSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n        }\n\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n        if !dosBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n        }\n\n        let aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\n        let aeBidPublicPath=FindMarket.getPublicPath(aeBidType, name: tenant.name)\n        let aeBidStoragePath= FindMarket.getStoragePath(aeBidType, name:tenant.name)\n        let aeBidCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n        if !aeBidCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n        }\n\n     /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n        }\n\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n        if !asBidCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n        }\n        //SYNC with register\n\n        self.saleItems= account.borrow\u003c\u0026FindMarketSale.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketSale.SaleItemCollection\u003e()))\n        self.pointers= []\n\n        let nfts : {String : NFTCatalog.NFTCollectionData} = {}\n\n        var counter = 0\n        while counter \u003c ids.length {\n            // Get supported NFT and FT Information from Registries from input alias\n            var nft : NFTCatalog.NFTCollectionData? = nil\n            var ft : FTRegistry.FTInfo? = nil\n\n            if nfts[nftAliasOrIdentifiers[counter]] != nil {\n                nft = nfts[nftAliasOrIdentifiers[counter]]\n            } else {\n                let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftAliasOrIdentifiers[counter])?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftAliasOrIdentifiers[counter])) \n                let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n                nft = collection.collectionData\n                nfts[nftAliasOrIdentifiers[counter]] = nft\n            }\n\n            var providerCap=account.getCapability\u003c\u0026{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e(nft!.privatePath)\n\n            /* Ben : Question -\u003e Either client will have to provide the path here or agree that we set it up for the user */\n            if !providerCap.check() {\n                let newCap = account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                        nft!.privatePath,\n                        target: nft!.storagePath\n                )\n                if newCap == nil {\n                    // If linking is not successful, we link it using finds custom link \n                    let pathIdentifier = nft!.privatePath.toString()\n                    let findPath = PrivatePath(identifier: pathIdentifier.slice(from: \"/private/\".length , upTo: pathIdentifier.length).concat(\"_FIND\"))!\n                    account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                        findPath,\n                        target: nft!.storagePath\n                    )\n                    providerCap = account.getCapability\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(findPath)\n                }\n            }\n            // Get the salesItemRef from tenant\n            self.pointers.append(FindViews.AuthNFTPointer(cap: providerCap, id: ids[counter]))\n            counter = counter + 1\n        }\n\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        var counter = 0\n        while counter \u003c ids.length {\n            self.saleItems!.listForSale(pointer: self.pointers[counter], vaultType: Type\u003c@DapperUtilityCoin.Vault\u003e(), directSellPrice: directSellPrices[counter], validUntil: validUntil, extraField: {})\n            counter = counter + 1\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "dapperAddress",
                     "marketplace",
                     "nftAliasOrIdentifiers",
                     "ids",
                     "directSellPrices",
                     "validUntil"
                  ],
                  "parameters": {
                     "dapperAddress": "Address",
                     "directSellPrices": "[UFix64]",
                     "ids": "[UInt64]",
                     "marketplace": "Address",
                     "nftAliasOrIdentifiers": "[String]",
                     "validUntil": "UFix64?"
                  }
               }
            },
            "listNFTForAuctionEscrowed": {
               "code": "import FindMarket from 0x097bafa4e0b48eef\nimport FindMarketSale from 0x097bafa4e0b48eef\nimport FindMarketAuctionEscrow from 0x097bafa4e0b48eef\nimport FindMarketAuctionSoft from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferEscrow from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferSoft from 0x097bafa4e0b48eef\nimport NonFungibleToken from 0x1d7e57aa55817448\nimport MetadataViews from 0x1d7e57aa55817448\nimport FindViews from 0x097bafa4e0b48eef\nimport NFTCatalog from 0x49a7cda3a1eecc29\nimport FINDNFTCatalog from 0x097bafa4e0b48eef\nimport FTRegistry from 0x097bafa4e0b48eef\nimport FungibleToken from 0xf233dcee88fe0abe\nimport FUSD from 0x3c5959b568896393\nimport FiatToken from 0xb19436aae4d94622\nimport FlowToken from 0x1654653399040a61\nimport FIND from 0x097bafa4e0b48eef\nimport Dandy from 0x097bafa4e0b48eef\nimport Profile from 0x097bafa4e0b48eef\nimport FindLeaseMarketSale from 0x097bafa4e0b48eef\nimport FindLeaseMarketAuctionSoft from 0x097bafa4e0b48eef\n// import FindLeaseMarketAuctionEscrow from \"../contracts/FindLeaseMarketAuctionEscrow.cdc\"\nimport FindLeaseMarketDirectOfferSoft from 0x097bafa4e0b48eef\n// import FindLeaseMarketDirectOfferEscrow from \"../contracts/FindLeaseMarketDirectOfferEscrow.cdc\"\nimport FindLeaseMarket from 0x097bafa4e0b48eef\n\ntransaction(marketplace:Address, nftAliasOrIdentifier:String, id: UInt64, ftAliasOrIdentifier:String, price:UFix64, auctionReservePrice: UFix64, auctionDuration: UFix64, auctionExtensionOnLateBid: UFix64, minimumBidIncrement: UFix64, auctionValidUntil: UFix64?) {\n    \n    let saleItems : \u0026FindMarketAuctionEscrow.SaleItemCollection?\n    let vaultType : Type\n    let pointer : FindViews.AuthNFTPointer\n    \n    prepare(account: AuthAccount) {\n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n        //SYNC with register\n        //Add exising FUSD or create a new one and add it\n        let name = account.address.toString()\n        let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n        if !fusdReceiver.check() {\n            let fusd \u003c- FUSD.createEmptyVault()\n            account.save(\u003c- fusd, to: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n        }\n\n        let usdcCap = account.getCapability\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e(FiatToken.VaultReceiverPubPath)\n        if !usdcCap.check() {\n                account.save( \u003c-FiatToken.createEmptyVault(), to: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e( FiatToken.VaultReceiverPubPath, target: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FiatToken.ResourceId}\u003e( FiatToken.VaultUUIDPubPath, target: FiatToken.VaultStoragePath)\n                account.link\u003c\u0026FiatToken.Vault{FungibleToken.Balance}\u003e( FiatToken.VaultBalancePubPath, target:FiatToken.VaultStoragePath)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let dandyCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        let dandyCapPrivate= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPrivatePath)\n        if !dandyCapPrivate.check() {\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        var created=false\n        var updated=false\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        if !profile.hasWallet(\"Flow\") {\n            let flowWallet=Profile.Wallet( name:\"Flow\", receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), tags: [\"flow\"])\n    \n            profile.addWallet(flowWallet)\n            updated=true\n        }\n        if !profile.hasWallet(\"FUSD\") {\n            profile.addWallet(Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), tags: [\"fusd\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if !profile.hasWallet(\"USDC\") {\n            profile.addWallet(Profile.Wallet( name:\"USDC\", receiver:usdcCap, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(FiatToken.VaultBalancePubPath), accept: Type\u003c@FiatToken.Vault\u003e(), tags: [\"usdc\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else if updated {\n            profile.emitUpdatedEvent()\n        }\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        let doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        let doeSalePublicPath=FindMarket.getPublicPath(doeSaleType, name: tenant.name)\n        let doeSaleStoragePath= FindMarket.getStoragePath(doeSaleType, name:tenant.name)\n        let doeSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n        if !doeSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n        }\n\n        let doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        let doeBidPublicPath=FindMarket.getPublicPath(doeBidType, name: tenant.name)\n        let doeBidStoragePath= FindMarket.getStoragePath(doeBidType, name:tenant.name)\n        let doeBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n        if !doeBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n        }\n\n        /// auctions that escrow ft\n        let aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        let aeSalePublicPath=FindMarket.getPublicPath(aeSaleType, name: tenant.name)\n        let aeSaleStoragePath= FindMarket.getStoragePath(aeSaleType, name:tenant.name)\n        let aeSaleCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n        if !aeSaleCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n        }\n\n        let dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\n        let dosSalePublicPath=FindMarket.getPublicPath(dosSaleType, name: tenant.name)\n        let dosSaleStoragePath= FindMarket.getStoragePath(dosSaleType, name:tenant.name)\n\n        let dosSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n        if !dosSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n        }\n\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n        if !dosBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n        }\n\n        let aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\n        let aeBidPublicPath=FindMarket.getPublicPath(aeBidType, name: tenant.name)\n        let aeBidStoragePath= FindMarket.getStoragePath(aeBidType, name:tenant.name)\n        let aeBidCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n        if !aeBidCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n        }\n\n     /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n        }\n\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n        if !asBidCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n        }\n\n        let leaseTenantCapability= FindMarket.getTenantCapability(FindMarket.getTenantAddress(\"findLease\")!)!\n\n        let leaseSaleItemType= Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()\n        let leasePublicPath=FindMarket.getPublicPath(leaseSaleItemType, name: \"findLease\")\n        let leaseStoragePath= FindMarket.getStoragePath(leaseSaleItemType, name:\"findLease\")\n        let leaseSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath) \n        if !leaseSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketSale.SaleItemCollection\u003e(\u003c- FindLeaseMarketSale.createEmptySaleItemCollection(leaseTenantCapability), to: leaseStoragePath)\n            account.link\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath, target: leaseStoragePath)\n        }\n\n        let leaseASSaleItemType= Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e()\n        let leaseASPublicPath=FindMarket.getPublicPath(leaseASSaleItemType, name: \"findLease\")\n        let leaseASStoragePath= FindMarket.getStoragePath(leaseASSaleItemType, name:\"findLease\")\n        let leaseASSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath) \n        if !leaseASSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseASStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath, target: leaseASStoragePath)\n        }\n\n\n        let leaseASBidType= Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e()\n        let leaseASBidPublicPath=FindMarket.getPublicPath(leaseASBidType, name: \"findLease\")\n        let leaseASBidStoragePath= FindMarket.getStoragePath(leaseASBidType, name: \"findLease\")\n        let leaseASBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath) \n        if !leaseASBidCap.check() {\n            account.save\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseASBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath, target: leaseASBidStoragePath)\n        }\n\n        // let leaseAESaleItemType= Type\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e()\n        // let leaseAEPublicPath=FindMarket.getPublicPath(leaseAESaleItemType, name: \"findLease\")\n        // let leaseAEStoragePath= FindMarket.getStoragePath(leaseAESaleItemType, name:\"findLease\")\n        // let leaseAESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath) \n        // if !leaseAESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseAEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath, target: leaseAEStoragePath)\n        // }\n\n        // let leaseAEBidType= Type\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e()\n        // let leaseAEBidPublicPath=FindMarket.getPublicPath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidStoragePath= FindMarket.getStoragePath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath) \n        // if !leaseAEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseAEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath, target: leaseAEBidStoragePath)\n        // }\n\n        let leaseDOSSaleItemType= Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e()\n        let leaseDOSPublicPath=FindMarket.getPublicPath(leaseDOSSaleItemType, name: \"findLease\")\n        let leaseDOSStoragePath= FindMarket.getStoragePath(leaseDOSSaleItemType, name:\"findLease\")\n        let leaseDOSSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath) \n        if !leaseDOSSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOSStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath, target: leaseDOSStoragePath)\n        }\n\n        let leaseDOSBidType= Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let leaseDOSBidPublicPath=FindMarket.getPublicPath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidStoragePath= FindMarket.getStoragePath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath) \n        if !leaseDOSBidCap.check() {\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOSBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath, target: leaseDOSBidStoragePath)\n        }\n\n        // let leaseDOESaleItemType= Type\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        // let leaseDOEPublicPath=FindMarket.getPublicPath(leaseDOESaleItemType, name: \"findLease\")\n        // let leaseDOEStoragePath= FindMarket.getStoragePath(leaseDOESaleItemType, name:\"findLease\")\n        // let leaseDOESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath) \n        // if !leaseDOESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath, target: leaseDOEStoragePath)\n        // }\n\n        // let leaseDOEBidType= Type\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        // let leaseDOEBidPublicPath=FindMarket.getPublicPath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidStoragePath= FindMarket.getStoragePath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath) \n        // if !leaseDOEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath, target: leaseDOEBidStoragePath)\n        // }\n        //SYNC with register\n\n        let path=FindMarket.getStoragePath(Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(), name: tenant.name)\n\n\n        // Get supported NFT and FT Information from Registries from input alias\n        let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftAliasOrIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftAliasOrIdentifier)) \n        let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n        let nft = collection.collectionData\n\n        let ft = FTRegistry.getFTInfo(ftAliasOrIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftAliasOrIdentifier))\n\n        var providerCap=account.getCapability\u003c\u0026{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e(nft.privatePath)\n        \n        /* Ben : Question -\u003e Either client will have to provide the path here or agree that we set it up for the user */\n        if !providerCap.check() {\n            let newCap = account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                    nft.privatePath,\n                    target: nft.storagePath\n            )\n            if newCap == nil {\n                // If linking is not successful, we link it using finds custom link \n                let pathIdentifier = nft.privatePath.toString()\n                let findPath = PrivatePath(identifier: pathIdentifier.slice(from: \"/private/\".length , upTo: pathIdentifier.length).concat(\"_FIND\"))!\n                account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                    findPath,\n                    target: nft.storagePath\n                )\n                providerCap = account.getCapability\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(findPath)\n            }\n        }\n\n        self.saleItems= account.borrow\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection\u003e(from: path)\n        self.pointer= FindViews.AuthNFTPointer(cap: providerCap, id: id)\n        self.vaultType= ft.type\n    }\n\n    pre{\n        // Ben : panic on some unreasonable inputs in trxn \n        minimumBidIncrement \u003e 0.0 : \"Minimum bid increment should be larger than 0.\"\n        (auctionReservePrice - auctionReservePrice) % minimumBidIncrement == 0.0 : \"Acution ReservePrice should be in step of minimum bid increment.\" \n        auctionDuration \u003e 0.0 : \"Auction Duration should be greater than 0.\"\n        auctionExtensionOnLateBid \u003e 0.0 : \"Auction Duration should be greater than 0.\"\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute {\n        self.saleItems!.listForAuction(pointer: self.pointer, vaultType: self.vaultType, auctionStartPrice: price, auctionReservePrice: auctionReservePrice, auctionDuration: auctionDuration, auctionExtensionOnLateBid: auctionExtensionOnLateBid, minimumBidIncrement: minimumBidIncrement, auctionValidUntil:auctionValidUntil, saleItemExtraField: {})\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "nftAliasOrIdentifier",
                     "id",
                     "ftAliasOrIdentifier",
                     "price",
                     "auctionReservePrice",
                     "auctionDuration",
                     "auctionExtensionOnLateBid",
                     "minimumBidIncrement",
                     "auctionValidUntil"
                  ],
                  "parameters": {
                     "auctionDuration": "UFix64",
                     "auctionExtensionOnLateBid": "UFix64",
                     "auctionReservePrice": "UFix64",
                     "auctionValidUntil": "UFix64?",
                     "ftAliasOrIdentifier": "String",
                     "id": "UInt64",
                     "marketplace": "Address",
                     "minimumBidIncrement": "UFix64",
                     "nftAliasOrIdentifier": "String",
                     "price": "UFix64"
                  }
               }
            },
            "listNFTForAuctionSoft": {
               "code": "import FindMarket from 0x097bafa4e0b48eef\nimport FindMarketSale from 0x097bafa4e0b48eef\nimport FindMarketAuctionEscrow from 0x097bafa4e0b48eef\nimport FindMarketAuctionSoft from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferEscrow from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferSoft from 0x097bafa4e0b48eef\nimport NonFungibleToken from 0x1d7e57aa55817448\nimport MetadataViews from 0x1d7e57aa55817448\nimport FindViews from 0x097bafa4e0b48eef\nimport FTRegistry from 0x097bafa4e0b48eef\nimport NFTCatalog from 0x49a7cda3a1eecc29\nimport FINDNFTCatalog from 0x097bafa4e0b48eef\nimport FungibleToken from 0xf233dcee88fe0abe\nimport FUSD from 0x3c5959b568896393\nimport FiatToken from 0xb19436aae4d94622\nimport FlowToken from 0x1654653399040a61\nimport FIND from 0x097bafa4e0b48eef\nimport Dandy from 0x097bafa4e0b48eef\nimport Profile from 0x097bafa4e0b48eef\nimport FindLeaseMarketSale from 0x097bafa4e0b48eef\nimport FindLeaseMarketAuctionSoft from 0x097bafa4e0b48eef\n// import FindLeaseMarketAuctionEscrow from \"../contracts/FindLeaseMarketAuctionEscrow.cdc\"\nimport FindLeaseMarketDirectOfferSoft from 0x097bafa4e0b48eef\n// import FindLeaseMarketDirectOfferEscrow from \"../contracts/FindLeaseMarketDirectOfferEscrow.cdc\"\nimport FindLeaseMarket from 0x097bafa4e0b48eef\n\ntransaction(marketplace:Address, nftAliasOrIdentifier:String, id: UInt64, ftAliasOrIdentifier:String, price:UFix64, auctionReservePrice: UFix64, auctionDuration: UFix64, auctionExtensionOnLateBid: UFix64, minimumBidIncrement: UFix64, auctionValidUntil: UFix64?) {\n    \n    let saleItems : \u0026FindMarketAuctionSoft.SaleItemCollection?\n    let pointer : FindViews.AuthNFTPointer\n    let vaultType : Type\n    \n    prepare(account: AuthAccount) {\n\n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n        //SYNC with register\n        //Add exising FUSD or create a new one and add it\n        let name = account.address.toString()\n        let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n        if !fusdReceiver.check() {\n            let fusd \u003c- FUSD.createEmptyVault()\n            account.save(\u003c- fusd, to: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n        }\n\n        let usdcCap = account.getCapability\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e(FiatToken.VaultReceiverPubPath)\n        if !usdcCap.check() {\n                account.save( \u003c-FiatToken.createEmptyVault(), to: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e( FiatToken.VaultReceiverPubPath, target: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FiatToken.ResourceId}\u003e( FiatToken.VaultUUIDPubPath, target: FiatToken.VaultStoragePath)\n                account.link\u003c\u0026FiatToken.Vault{FungibleToken.Balance}\u003e( FiatToken.VaultBalancePubPath, target:FiatToken.VaultStoragePath)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let dandyCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        let dandyCapPrivate= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPrivatePath)\n        if !dandyCapPrivate.check() {\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        var created=false\n        var updated=false\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        if !profile.hasWallet(\"Flow\") {\n            let flowWallet=Profile.Wallet( name:\"Flow\", receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), tags: [\"flow\"])\n    \n            profile.addWallet(flowWallet)\n            updated=true\n        }\n        if !profile.hasWallet(\"FUSD\") {\n            profile.addWallet(Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), tags: [\"fusd\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if !profile.hasWallet(\"USDC\") {\n            profile.addWallet(Profile.Wallet( name:\"USDC\", receiver:usdcCap, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(FiatToken.VaultBalancePubPath), accept: Type\u003c@FiatToken.Vault\u003e(), tags: [\"usdc\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else if updated {\n            profile.emitUpdatedEvent()\n        }\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        let doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        let doeSalePublicPath=FindMarket.getPublicPath(doeSaleType, name: tenant.name)\n        let doeSaleStoragePath= FindMarket.getStoragePath(doeSaleType, name:tenant.name)\n        let doeSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n        if !doeSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n        }\n\n        let doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        let doeBidPublicPath=FindMarket.getPublicPath(doeBidType, name: tenant.name)\n        let doeBidStoragePath= FindMarket.getStoragePath(doeBidType, name:tenant.name)\n        let doeBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n        if !doeBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n        }\n\n        /// auctions that escrow ft\n        let aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        let aeSalePublicPath=FindMarket.getPublicPath(aeSaleType, name: tenant.name)\n        let aeSaleStoragePath= FindMarket.getStoragePath(aeSaleType, name:tenant.name)\n        let aeSaleCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n        if !aeSaleCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n        }\n\n        let dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\n        let dosSalePublicPath=FindMarket.getPublicPath(dosSaleType, name: tenant.name)\n        let dosSaleStoragePath= FindMarket.getStoragePath(dosSaleType, name:tenant.name)\n\n        let dosSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n        if !dosSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n        }\n\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n        if !dosBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n        }\n\n        let aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\n        let aeBidPublicPath=FindMarket.getPublicPath(aeBidType, name: tenant.name)\n        let aeBidStoragePath= FindMarket.getStoragePath(aeBidType, name:tenant.name)\n        let aeBidCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n        if !aeBidCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n        }\n\n     /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n        }\n\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n        if !asBidCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n        }\n\n        let leaseTenantCapability= FindMarket.getTenantCapability(FindMarket.getTenantAddress(\"findLease\")!)!\n\n        let leaseSaleItemType= Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()\n        let leasePublicPath=FindMarket.getPublicPath(leaseSaleItemType, name: \"findLease\")\n        let leaseStoragePath= FindMarket.getStoragePath(leaseSaleItemType, name:\"findLease\")\n        let leaseSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath) \n        if !leaseSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketSale.SaleItemCollection\u003e(\u003c- FindLeaseMarketSale.createEmptySaleItemCollection(leaseTenantCapability), to: leaseStoragePath)\n            account.link\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath, target: leaseStoragePath)\n        }\n\n        let leaseASSaleItemType= Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e()\n        let leaseASPublicPath=FindMarket.getPublicPath(leaseASSaleItemType, name: \"findLease\")\n        let leaseASStoragePath= FindMarket.getStoragePath(leaseASSaleItemType, name:\"findLease\")\n        let leaseASSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath) \n        if !leaseASSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseASStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath, target: leaseASStoragePath)\n        }\n\n\n        let leaseASBidType= Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e()\n        let leaseASBidPublicPath=FindMarket.getPublicPath(leaseASBidType, name: \"findLease\")\n        let leaseASBidStoragePath= FindMarket.getStoragePath(leaseASBidType, name: \"findLease\")\n        let leaseASBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath) \n        if !leaseASBidCap.check() {\n            account.save\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseASBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath, target: leaseASBidStoragePath)\n        }\n\n        // let leaseAESaleItemType= Type\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e()\n        // let leaseAEPublicPath=FindMarket.getPublicPath(leaseAESaleItemType, name: \"findLease\")\n        // let leaseAEStoragePath= FindMarket.getStoragePath(leaseAESaleItemType, name:\"findLease\")\n        // let leaseAESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath) \n        // if !leaseAESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseAEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath, target: leaseAEStoragePath)\n        // }\n\n        // let leaseAEBidType= Type\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e()\n        // let leaseAEBidPublicPath=FindMarket.getPublicPath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidStoragePath= FindMarket.getStoragePath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath) \n        // if !leaseAEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseAEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath, target: leaseAEBidStoragePath)\n        // }\n\n        let leaseDOSSaleItemType= Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e()\n        let leaseDOSPublicPath=FindMarket.getPublicPath(leaseDOSSaleItemType, name: \"findLease\")\n        let leaseDOSStoragePath= FindMarket.getStoragePath(leaseDOSSaleItemType, name:\"findLease\")\n        let leaseDOSSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath) \n        if !leaseDOSSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOSStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath, target: leaseDOSStoragePath)\n        }\n\n        let leaseDOSBidType= Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let leaseDOSBidPublicPath=FindMarket.getPublicPath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidStoragePath= FindMarket.getStoragePath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath) \n        if !leaseDOSBidCap.check() {\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOSBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath, target: leaseDOSBidStoragePath)\n        }\n\n        // let leaseDOESaleItemType= Type\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        // let leaseDOEPublicPath=FindMarket.getPublicPath(leaseDOESaleItemType, name: \"findLease\")\n        // let leaseDOEStoragePath= FindMarket.getStoragePath(leaseDOESaleItemType, name:\"findLease\")\n        // let leaseDOESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath) \n        // if !leaseDOESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath, target: leaseDOEStoragePath)\n        // }\n\n        // let leaseDOEBidType= Type\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        // let leaseDOEBidPublicPath=FindMarket.getPublicPath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidStoragePath= FindMarket.getStoragePath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath) \n        // if !leaseDOEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath, target: leaseDOEBidStoragePath)\n        // }\n        //SYNC with register\n\n        // Get supported NFT and FT Information from Registries from input alias\n        let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftAliasOrIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftAliasOrIdentifier)) \n        let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n        let nft = collection.collectionData\n\n        let ft = FTRegistry.getFTInfo(ftAliasOrIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftAliasOrIdentifier))\n\n        var providerCap = account.getCapability\u003c\u0026{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e(nft.privatePath)\n\n        /* Ben : Question -\u003e Either client will have to provide the path here or agree that we set it up for the user */\n        if !providerCap.check() {\n            let newCap = account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                    nft.privatePath,\n                    target: nft.storagePath\n            )\n            if newCap == nil {\n                // If linking is not successful, we link it using finds custom link \n                let pathIdentifier = nft.privatePath.toString()\n                let findPath = PrivatePath(identifier: pathIdentifier.slice(from: \"/private/\".length , upTo: pathIdentifier.length).concat(\"_FIND\"))!\n                account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                    findPath,\n                    target: nft.storagePath\n                )\n                providerCap = account.getCapability\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(findPath)\n            }\n        }\n        \n        self.saleItems= account.borrow\u003c\u0026FindMarketAuctionSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()))\n        self.pointer= FindViews.AuthNFTPointer(cap: providerCap, id: id)\n        self.vaultType= ft.type\n\n        \n\n    }\n\n    pre{\n        // Ben : panic on some unreasonable inputs in trxn \n        minimumBidIncrement \u003e 0.0 :\"Minimum bid increment should be larger than 0.\"\n        (auctionReservePrice - auctionReservePrice) % minimumBidIncrement == 0.0 : \"Acution ReservePrice should be in step of minimum bid increment.\" \n        auctionDuration \u003e 0.0 : \"Auction Duration should be greater than 0.\"\n        auctionExtensionOnLateBid \u003e 0.0 : \"Auction Duration should be greater than 0.\"\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        self.saleItems!.listForAuction(pointer: self.pointer, vaultType: self.vaultType, auctionStartPrice: price, auctionReservePrice: auctionReservePrice, auctionDuration: auctionDuration, auctionExtensionOnLateBid: auctionExtensionOnLateBid, minimumBidIncrement: minimumBidIncrement, auctionValidUntil: auctionValidUntil, saleItemExtraField: {})\n\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "nftAliasOrIdentifier",
                     "id",
                     "ftAliasOrIdentifier",
                     "price",
                     "auctionReservePrice",
                     "auctionDuration",
                     "auctionExtensionOnLateBid",
                     "minimumBidIncrement",
                     "auctionValidUntil"
                  ],
                  "parameters": {
                     "auctionDuration": "UFix64",
                     "auctionExtensionOnLateBid": "UFix64",
                     "auctionReservePrice": "UFix64",
                     "auctionValidUntil": "UFix64?",
                     "ftAliasOrIdentifier": "String",
                     "id": "UInt64",
                     "marketplace": "Address",
                     "minimumBidIncrement": "UFix64",
                     "nftAliasOrIdentifier": "String",
                     "price": "UFix64"
                  }
               }
            },
            "listNFTForAuctionSoftDUC": {
               "code": "import FindMarket from 0x097bafa4e0b48eef\nimport FindMarketSale from 0x097bafa4e0b48eef\nimport FindMarketAuctionEscrow from 0x097bafa4e0b48eef\nimport FindMarketAuctionSoft from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferEscrow from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferSoft from 0x097bafa4e0b48eef\nimport NonFungibleToken from 0x1d7e57aa55817448\nimport MetadataViews from 0x1d7e57aa55817448\nimport FindViews from 0x097bafa4e0b48eef\nimport NFTCatalog from 0x49a7cda3a1eecc29\nimport FINDNFTCatalog from 0x097bafa4e0b48eef\nimport FTRegistry from 0x097bafa4e0b48eef\nimport FungibleToken from 0xf233dcee88fe0abe\nimport FlowToken from 0x1654653399040a61\nimport TokenForwarding from 0xe544175ee0461c4b\nimport DapperUtilityCoin from 0xead892083b3e2c6c\nimport FIND from 0x097bafa4e0b48eef\nimport Dandy from 0x097bafa4e0b48eef\nimport Profile from 0x097bafa4e0b48eef\nimport FindLeaseMarketSale from 0x097bafa4e0b48eef\nimport FindLeaseMarketAuctionSoft from 0x097bafa4e0b48eef\n// import FindLeaseMarketAuctionEscrow from \"../contracts/FindLeaseMarketAuctionEscrow.cdc\"\nimport FindLeaseMarketDirectOfferSoft from 0x097bafa4e0b48eef\n// import FindLeaseMarketDirectOfferEscrow from \"../contracts/FindLeaseMarketDirectOfferEscrow.cdc\"\nimport FindLeaseMarket from 0x097bafa4e0b48eef\n\ntransaction(dapperAddress: Address, marketplace:Address, nftAliasOrIdentifier:String, id: UInt64, price:UFix64, auctionReservePrice: UFix64, auctionDuration: UFix64, auctionExtensionOnLateBid: UFix64, minimumBidIncrement: UFix64, auctionValidUntil: UFix64?) {\n    \n    let saleItems : \u0026FindMarketAuctionSoft.SaleItemCollection?\n    let pointer : FindViews.AuthNFTPointer\n    let vaultType : Type\n    \n    prepare(account: AuthAccount) {\n\n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n        //SYNC with register\n        //Add exising FUSD or create a new one and add it\n        let name = account.address.toString()\n        let ducReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver)\n        if !ducReceiver.check() {\n            let dapper = getAccount(dapperAddress)\n            // Create a new Forwarder resource for DUC and store it in the new account's storage\n            let ducForwarder \u003c- TokenForwarding.createNewForwarder(recipient: dapper.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver))\n            account.save(\u003c-ducForwarder, to: /storage/dapperUtilityCoinReceiver)\n            // Publish a Receiver capability for the new account, which is linked to the DUC Forwarder\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver,target: /storage/dapperUtilityCoinReceiver)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: ducReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let dandyCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        let dandyCapPrivate= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPrivatePath)\n        if !dandyCapPrivate.check() {\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        var created=false\n        var updated=false\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        if !profile.hasWallet(\"Flow\") {\n            let flowWallet=Profile.Wallet( name:\"Flow\", receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), tags: [\"flow\"])\n    \n            profile.addWallet(flowWallet)\n            updated=true\n        }\n        if !profile.hasWallet(\"DUC\") {\n            profile.addWallet(Profile.Wallet( name:\"DUC\", receiver:ducReceiver, balance:getAccount(dapperAddress).getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/dapperUtilityCoinBalance), accept: Type\u003c@DapperUtilityCoin.Vault\u003e(), tags: [\"duc\", \"dapperUtilityCoin\",\"dapper\"]))\n            updated=true\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else {\n            profile.emitUpdatedEvent()\n        }\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        let doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        let doeSalePublicPath=FindMarket.getPublicPath(doeSaleType, name: tenant.name)\n        let doeSaleStoragePath= FindMarket.getStoragePath(doeSaleType, name:tenant.name)\n        let doeSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n        if !doeSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n        }\n\n        let doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        let doeBidPublicPath=FindMarket.getPublicPath(doeBidType, name: tenant.name)\n        let doeBidStoragePath= FindMarket.getStoragePath(doeBidType, name:tenant.name)\n        let doeBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n        if !doeBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n        }\n\n        /// auctions that escrow ft\n        let aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        let aeSalePublicPath=FindMarket.getPublicPath(aeSaleType, name: tenant.name)\n        let aeSaleStoragePath= FindMarket.getStoragePath(aeSaleType, name:tenant.name)\n        let aeSaleCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n        if !aeSaleCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n        }\n\n        let dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\n        let dosSalePublicPath=FindMarket.getPublicPath(dosSaleType, name: tenant.name)\n        let dosSaleStoragePath= FindMarket.getStoragePath(dosSaleType, name:tenant.name)\n\n        let dosSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n        if !dosSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n        }\n\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n        if !dosBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n        }\n\n        let aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\n        let aeBidPublicPath=FindMarket.getPublicPath(aeBidType, name: tenant.name)\n        let aeBidStoragePath= FindMarket.getStoragePath(aeBidType, name:tenant.name)\n        let aeBidCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n        if !aeBidCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n        }\n\n     /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n        }\n\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n        if !asBidCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n        }\n\n        let leaseTenantCapability= FindMarket.getTenantCapability(FindMarket.getTenantAddress(\"findLease\")!)!\n\n        let leaseSaleItemType= Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()\n        let leasePublicPath=FindMarket.getPublicPath(leaseSaleItemType, name: \"findLease\")\n        let leaseStoragePath= FindMarket.getStoragePath(leaseSaleItemType, name:\"findLease\")\n        let leaseSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath) \n        if !leaseSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketSale.SaleItemCollection\u003e(\u003c- FindLeaseMarketSale.createEmptySaleItemCollection(leaseTenantCapability), to: leaseStoragePath)\n            account.link\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath, target: leaseStoragePath)\n        }\n\n        let leaseASSaleItemType= Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e()\n        let leaseASPublicPath=FindMarket.getPublicPath(leaseASSaleItemType, name: \"findLease\")\n        let leaseASStoragePath= FindMarket.getStoragePath(leaseASSaleItemType, name:\"findLease\")\n        let leaseASSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath) \n        if !leaseASSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseASStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath, target: leaseASStoragePath)\n        }\n\n\n        let leaseASBidType= Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e()\n        let leaseASBidPublicPath=FindMarket.getPublicPath(leaseASBidType, name: \"findLease\")\n        let leaseASBidStoragePath= FindMarket.getStoragePath(leaseASBidType, name: \"findLease\")\n        let leaseASBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath) \n        if !leaseASBidCap.check() {\n            account.save\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseASBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath, target: leaseASBidStoragePath)\n        }\n\n        // let leaseAESaleItemType= Type\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e()\n        // let leaseAEPublicPath=FindMarket.getPublicPath(leaseAESaleItemType, name: \"findLease\")\n        // let leaseAEStoragePath= FindMarket.getStoragePath(leaseAESaleItemType, name:\"findLease\")\n        // let leaseAESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath) \n        // if !leaseAESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseAEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath, target: leaseAEStoragePath)\n        // }\n\n        // let leaseAEBidType= Type\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e()\n        // let leaseAEBidPublicPath=FindMarket.getPublicPath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidStoragePath= FindMarket.getStoragePath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath) \n        // if !leaseAEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseAEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath, target: leaseAEBidStoragePath)\n        // }\n\n        let leaseDOSSaleItemType= Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e()\n        let leaseDOSPublicPath=FindMarket.getPublicPath(leaseDOSSaleItemType, name: \"findLease\")\n        let leaseDOSStoragePath= FindMarket.getStoragePath(leaseDOSSaleItemType, name:\"findLease\")\n        let leaseDOSSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath) \n        if !leaseDOSSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOSStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath, target: leaseDOSStoragePath)\n        }\n\n        let leaseDOSBidType= Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let leaseDOSBidPublicPath=FindMarket.getPublicPath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidStoragePath= FindMarket.getStoragePath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath) \n        if !leaseDOSBidCap.check() {\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOSBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath, target: leaseDOSBidStoragePath)\n        }\n\n        // let leaseDOESaleItemType= Type\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        // let leaseDOEPublicPath=FindMarket.getPublicPath(leaseDOESaleItemType, name: \"findLease\")\n        // let leaseDOEStoragePath= FindMarket.getStoragePath(leaseDOESaleItemType, name:\"findLease\")\n        // let leaseDOESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath) \n        // if !leaseDOESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath, target: leaseDOEStoragePath)\n        // }\n\n        // let leaseDOEBidType= Type\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        // let leaseDOEBidPublicPath=FindMarket.getPublicPath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidStoragePath= FindMarket.getStoragePath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath) \n        // if !leaseDOEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath, target: leaseDOEBidStoragePath)\n        // }\n        //SYNC with register\n\n        // Get supported NFT and FT Information from Registries from input alias\n        let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftAliasOrIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftAliasOrIdentifier)) \n        let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n        let nft = collection.collectionData\n\n        let ft = FTRegistry.getFTInfo(Type\u003c@DapperUtilityCoin.Vault\u003e().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(Type\u003c@DapperUtilityCoin.Vault\u003e().identifier))\n\n        var providerCap = account.getCapability\u003c\u0026{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e(nft.privatePath)\n\n        /* Ben : Question -\u003e Either client will have to provide the path here or agree that we set it up for the user */\n        if !providerCap.check() {\n            let newCap = account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                    nft.privatePath,\n                    target: nft.storagePath\n            )\n            if newCap == nil {\n                // If linking is not successful, we link it using finds custom link \n                let pathIdentifier = nft.privatePath.toString()\n                let findPath = PrivatePath(identifier: pathIdentifier.slice(from: \"/private/\".length , upTo: pathIdentifier.length).concat(\"_FIND\"))!\n                account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                    findPath,\n                    target: nft.storagePath\n                )\n                providerCap = account.getCapability\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(findPath)\n            }\n        }\n        \n        self.saleItems= account.borrow\u003c\u0026FindMarketAuctionSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()))\n        self.pointer= FindViews.AuthNFTPointer(cap: providerCap, id: id)    \n        self.vaultType= ft.type    \n    }\n\n    pre{\n        // Ben : panic on some unreasonable inputs in trxn \n        minimumBidIncrement \u003e 0.0 :\"Minimum bid increment should be larger than 0.\"\n        (auctionReservePrice - auctionReservePrice) % minimumBidIncrement == 0.0 : \"Acution ReservePrice should be in step of minimum bid increment.\" \n        auctionDuration \u003e 0.0 : \"Auction Duration should be greater than 0.\"\n        auctionExtensionOnLateBid \u003e 0.0 : \"Auction Duration should be greater than 0.\"\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        self.saleItems!.listForAuction(pointer: self.pointer, vaultType: self.vaultType, auctionStartPrice: price, auctionReservePrice: auctionReservePrice, auctionDuration: auctionDuration, auctionExtensionOnLateBid: auctionExtensionOnLateBid, minimumBidIncrement: minimumBidIncrement, auctionValidUntil: auctionValidUntil, saleItemExtraField: {})\n\n    }\n}",
               "spec": {
                  "order": [
                     "dapperAddress",
                     "marketplace",
                     "nftAliasOrIdentifier",
                     "id",
                     "price",
                     "auctionReservePrice",
                     "auctionDuration",
                     "auctionExtensionOnLateBid",
                     "minimumBidIncrement",
                     "auctionValidUntil"
                  ],
                  "parameters": {
                     "auctionDuration": "UFix64",
                     "auctionExtensionOnLateBid": "UFix64",
                     "auctionReservePrice": "UFix64",
                     "auctionValidUntil": "UFix64?",
                     "dapperAddress": "Address",
                     "id": "UInt64",
                     "marketplace": "Address",
                     "minimumBidIncrement": "UFix64",
                     "nftAliasOrIdentifier": "String",
                     "price": "UFix64"
                  }
               }
            },
            "listNFTForSale": {
               "code": "import FindMarket from 0x097bafa4e0b48eef\nimport FindMarketSale from 0x097bafa4e0b48eef\nimport FindMarketAuctionEscrow from 0x097bafa4e0b48eef\nimport FindMarketAuctionSoft from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferEscrow from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferSoft from 0x097bafa4e0b48eef\nimport FungibleToken from 0xf233dcee88fe0abe\nimport FUSD from 0x3c5959b568896393\nimport FlowToken from 0x1654653399040a61\nimport FiatToken from 0xb19436aae4d94622\nimport FIND from 0x097bafa4e0b48eef\nimport Dandy from 0x097bafa4e0b48eef\nimport Profile from 0x097bafa4e0b48eef\nimport NonFungibleToken from 0x1d7e57aa55817448\nimport MetadataViews from 0x1d7e57aa55817448\nimport FindViews from 0x097bafa4e0b48eef\nimport NFTCatalog from 0x49a7cda3a1eecc29\nimport FINDNFTCatalog from 0x097bafa4e0b48eef\nimport FTRegistry from 0x097bafa4e0b48eef\nimport FindLeaseMarketSale from 0x097bafa4e0b48eef\nimport FindLeaseMarketAuctionSoft from 0x097bafa4e0b48eef\nimport FindLeaseMarketDirectOfferSoft from 0x097bafa4e0b48eef\nimport FindLeaseMarket from 0x097bafa4e0b48eef\n\ntransaction(marketplace:Address, nftAliasOrIdentifier: String, id: UInt64, ftAliasOrIdentifier: String, directSellPrice:UFix64, validUntil: UFix64?) {\n    \n    let saleItems : \u0026FindMarketSale.SaleItemCollection?\n    let pointer : FindViews.AuthNFTPointer\n    let vaultType : Type\n\n    prepare(account: AuthAccount) {\n\n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n        //SYNC with register\n        //Add exising FUSD or create a new one and add it\n        let name = account.address.toString()\n        let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n        if !fusdReceiver.check() {\n            let fusd \u003c- FUSD.createEmptyVault()\n            account.save(\u003c- fusd, to: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n        }\n\n        let usdcCap = account.getCapability\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e(FiatToken.VaultReceiverPubPath)\n        if !usdcCap.check() {\n                account.save( \u003c-FiatToken.createEmptyVault(), to: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e( FiatToken.VaultReceiverPubPath, target: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FiatToken.ResourceId}\u003e( FiatToken.VaultUUIDPubPath, target: FiatToken.VaultStoragePath)\n                account.link\u003c\u0026FiatToken.Vault{FungibleToken.Balance}\u003e( FiatToken.VaultBalancePubPath, target:FiatToken.VaultStoragePath)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let dandyCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        let dandyCapPrivate= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPrivatePath)\n        if !dandyCapPrivate.check() {\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        var created=false\n        var updated=false\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        if !profile.hasWallet(\"Flow\") {\n            let flowWallet=Profile.Wallet( name:\"Flow\", receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), tags: [\"flow\"])\n    \n            profile.addWallet(flowWallet)\n            updated=true\n        }\n        if !profile.hasWallet(\"FUSD\") {\n            profile.addWallet(Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), tags: [\"fusd\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if !profile.hasWallet(\"USDC\") {\n            profile.addWallet(Profile.Wallet( name:\"USDC\", receiver:usdcCap, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(FiatToken.VaultBalancePubPath), accept: Type\u003c@FiatToken.Vault\u003e(), tags: [\"usdc\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else if updated {\n            profile.emitUpdatedEvent()\n        }\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        let doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        let doeSalePublicPath=FindMarket.getPublicPath(doeSaleType, name: tenant.name)\n        let doeSaleStoragePath= FindMarket.getStoragePath(doeSaleType, name:tenant.name)\n        let doeSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n        if !doeSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n        }\n\n        let doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        let doeBidPublicPath=FindMarket.getPublicPath(doeBidType, name: tenant.name)\n        let doeBidStoragePath= FindMarket.getStoragePath(doeBidType, name:tenant.name)\n        let doeBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n        if !doeBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n        }\n\n        /// auctions that escrow ft\n        let aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        let aeSalePublicPath=FindMarket.getPublicPath(aeSaleType, name: tenant.name)\n        let aeSaleStoragePath= FindMarket.getStoragePath(aeSaleType, name:tenant.name)\n        let aeSaleCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n        if !aeSaleCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n        }\n\n        let dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\n        let dosSalePublicPath=FindMarket.getPublicPath(dosSaleType, name: tenant.name)\n        let dosSaleStoragePath= FindMarket.getStoragePath(dosSaleType, name:tenant.name)\n\n        let dosSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n        if !dosSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n        }\n\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n        if !dosBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n        }\n\n        let aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\n        let aeBidPublicPath=FindMarket.getPublicPath(aeBidType, name: tenant.name)\n        let aeBidStoragePath= FindMarket.getStoragePath(aeBidType, name:tenant.name)\n        let aeBidCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n        if !aeBidCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n        }\n\n     /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n        }\n\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n        if !asBidCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n        }\n\n        let leaseTenantCapability= FindMarket.getTenantCapability(FindMarket.getTenantAddress(\"findLease\")!)!\n\n        let leaseSaleItemType= Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()\n        let leasePublicPath=FindMarket.getPublicPath(leaseSaleItemType, name: \"findLease\")\n        let leaseStoragePath= FindMarket.getStoragePath(leaseSaleItemType, name:\"findLease\")\n        let leaseSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath) \n        if !leaseSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketSale.SaleItemCollection\u003e(\u003c- FindLeaseMarketSale.createEmptySaleItemCollection(leaseTenantCapability), to: leaseStoragePath)\n            account.link\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath, target: leaseStoragePath)\n        }\n\n        let leaseASSaleItemType= Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e()\n        let leaseASPublicPath=FindMarket.getPublicPath(leaseASSaleItemType, name: \"findLease\")\n        let leaseASStoragePath= FindMarket.getStoragePath(leaseASSaleItemType, name:\"findLease\")\n        let leaseASSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath) \n        if !leaseASSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseASStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath, target: leaseASStoragePath)\n        }\n\n\n        let leaseASBidType= Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e()\n        let leaseASBidPublicPath=FindMarket.getPublicPath(leaseASBidType, name: \"findLease\")\n        let leaseASBidStoragePath= FindMarket.getStoragePath(leaseASBidType, name: \"findLease\")\n        let leaseASBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath) \n        if !leaseASBidCap.check() {\n            account.save\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseASBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath, target: leaseASBidStoragePath)\n        }\n\n        // let leaseAESaleItemType= Type\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e()\n        // let leaseAEPublicPath=FindMarket.getPublicPath(leaseAESaleItemType, name: \"findLease\")\n        // let leaseAEStoragePath= FindMarket.getStoragePath(leaseAESaleItemType, name:\"findLease\")\n        // let leaseAESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath) \n        // if !leaseAESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseAEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath, target: leaseAEStoragePath)\n        // }\n\n        // let leaseAEBidType= Type\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e()\n        // let leaseAEBidPublicPath=FindMarket.getPublicPath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidStoragePath= FindMarket.getStoragePath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath) \n        // if !leaseAEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseAEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath, target: leaseAEBidStoragePath)\n        // }\n\n        let leaseDOSSaleItemType= Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e()\n        let leaseDOSPublicPath=FindMarket.getPublicPath(leaseDOSSaleItemType, name: \"findLease\")\n        let leaseDOSStoragePath= FindMarket.getStoragePath(leaseDOSSaleItemType, name:\"findLease\")\n        let leaseDOSSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath) \n        if !leaseDOSSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOSStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath, target: leaseDOSStoragePath)\n        }\n\n        let leaseDOSBidType= Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let leaseDOSBidPublicPath=FindMarket.getPublicPath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidStoragePath= FindMarket.getStoragePath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath) \n        if !leaseDOSBidCap.check() {\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOSBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath, target: leaseDOSBidStoragePath)\n        }\n\n        // let leaseDOESaleItemType= Type\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        // let leaseDOEPublicPath=FindMarket.getPublicPath(leaseDOESaleItemType, name: \"findLease\")\n        // let leaseDOEStoragePath= FindMarket.getStoragePath(leaseDOESaleItemType, name:\"findLease\")\n        // let leaseDOESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath) \n        // if !leaseDOESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath, target: leaseDOEStoragePath)\n        // }\n\n        // let leaseDOEBidType= Type\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        // let leaseDOEBidPublicPath=FindMarket.getPublicPath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidStoragePath= FindMarket.getStoragePath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath) \n        // if !leaseDOEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath, target: leaseDOEBidStoragePath)\n        // }\n        //SYNC with register\n\n        // Get supported NFT and FT Information from Registries from input alias\n    let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier:nftAliasOrIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftAliasOrIdentifier)) \n    let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n    let nft = collection.collectionData\n\n        let ft = FTRegistry.getFTInfo(ftAliasOrIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftAliasOrIdentifier))\n\n        var providerCap=account.getCapability\u003c\u0026{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e(nft.privatePath)\n\n        /* Ben : Question -\u003e Either client will have to provide the path here or agree that we set it up for the user */\n        if !providerCap.check() {\n            let newCap = account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                nft.privatePath,\n                target: nft.storagePath\n            )\n            if newCap == nil {\n                // If linking is not successful, we link it using finds custom link \n                let pathIdentifier = nft.privatePath.toString()\n                let findPath = PrivatePath(identifier: pathIdentifier.slice(from: \"/private/\".length , upTo: pathIdentifier.length).concat(\"_FIND\"))!\n                account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                    findPath,\n                    target: nft.storagePath\n                )\n                providerCap = account.getCapability\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(findPath)\n            }\n        }\n        // Get the salesItemRef from tenant\n        self.saleItems= account.borrow\u003c\u0026FindMarketSale.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketSale.SaleItemCollection\u003e()))\n        self.pointer= FindViews.AuthNFTPointer(cap: providerCap, id: id)\n        self.vaultType= ft.type\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        self.saleItems!.listForSale(pointer: self.pointer, vaultType: self.vaultType, directSellPrice: directSellPrice, validUntil: validUntil, extraField: {})\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "nftAliasOrIdentifier",
                     "id",
                     "ftAliasOrIdentifier",
                     "directSellPrice",
                     "validUntil"
                  ],
                  "parameters": {
                     "directSellPrice": "UFix64",
                     "ftAliasOrIdentifier": "String",
                     "id": "UInt64",
                     "marketplace": "Address",
                     "nftAliasOrIdentifier": "String",
                     "validUntil": "UFix64?"
                  }
               }
            },
            "listNFTForSaleDUC": {
               "code": "import FindMarket from 0x097bafa4e0b48eef\nimport Profile from 0x097bafa4e0b48eef\nimport FindMarketSale from 0x097bafa4e0b48eef\nimport NFTCatalog from 0x49a7cda3a1eecc29\nimport FINDNFTCatalog from 0x097bafa4e0b48eef\nimport FTRegistry from 0x097bafa4e0b48eef\nimport FindViews from 0x097bafa4e0b48eef\n\nimport FungibleToken from 0xf233dcee88fe0abe\nimport DapperUtilityCoin from 0xead892083b3e2c6c\nimport TokenForwarding from 0xe544175ee0461c4b\nimport NonFungibleToken from 0x1d7e57aa55817448\nimport MetadataViews from 0x1d7e57aa55817448\n\ntransaction(dapperAddress:Address, marketplace:Address, nftAliasOrIdentifier: String, id: UInt64, directSellPrice:UFix64, validUntil: UFix64?) {\n    \n    let saleItems : \u0026FindMarketSale.SaleItemCollection?\n    let pointer : FindViews.AuthNFTPointer\n    let vaultType : Type\n    \n    prepare(account: AuthAccount) {\n\n        let name = account.address.toString()\n        let ducReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver)\n        if !ducReceiver.check() {\n            let dapper = getAccount(dapperAddress)\n            let ducForwarder \u003c- TokenForwarding.createNewForwarder(recipient: dapper.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver))\n            account.save(\u003c-ducForwarder, to: /storage/dapperUtilityCoinReceiver)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver,target: /storage/dapperUtilityCoinReceiver)\n        }\n\n        var created=false\n        var updated=false\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            created=true\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"onefootball\")\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        if !profile.hasWallet(\"DUC\") {\n            updated=true\n            profile.addWallet(Profile.Wallet( name:\"DUC\", receiver:ducReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/dapperUtilityCoinBalance), accept: Type\u003c@DapperUtilityCoin.Vault\u003e(), tags: [\"duc\", \"dapperUtilityCoin\",\"dapper\"]))\n            updated=true\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else {\n            profile.emitUpdatedEvent()\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else if updated {\n            profile.emitUpdatedEvent()\n        }\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n        //end initializtion\n\n        // Get supported NFT and FT Information from Registries from input alias\n        let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftAliasOrIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftAliasOrIdentifier)) \n        let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n        let nft = collection.collectionData\n\n        let ft = FTRegistry.getFTInfo(Type\u003c@DapperUtilityCoin.Vault\u003e().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(Type\u003c@DapperUtilityCoin.Vault\u003e().identifier))\n\n        let providerCap=account.getCapability\u003c\u0026{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e(nft.privatePath)\n\n        if !providerCap.check() {\n            account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                nft.privatePath,\n                target: nft.storagePath\n            )\n        }\n        // Get the salesItemRef from tenant\n        self.saleItems= account.borrow\u003c\u0026FindMarketSale.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketSale.SaleItemCollection\u003e()))\n        self.pointer= FindViews.AuthNFTPointer(cap: providerCap, id: id)\n        self.vaultType= ft.type\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        self.saleItems!.listForSale(pointer: self.pointer, vaultType: self.vaultType, directSellPrice: directSellPrice, validUntil: validUntil, extraField: {})\n\n    }\n}",
               "spec": {
                  "order": [
                     "dapperAddress",
                     "marketplace",
                     "nftAliasOrIdentifier",
                     "id",
                     "directSellPrice",
                     "validUntil"
                  ],
                  "parameters": {
                     "dapperAddress": "Address",
                     "directSellPrice": "UFix64",
                     "id": "UInt64",
                     "marketplace": "Address",
                     "nftAliasOrIdentifier": "String",
                     "validUntil": "UFix64?"
                  }
               }
            },
            "listNameForAuction": {
               "code": "import FIND from 0x097bafa4e0b48eef\n\ntransaction(name: String, auctionStartPrice: UFix64, auctionReservePrice: UFix64, auctionDuration: UFix64, auctionExtensionOnLateBid: UFix64) {\n    \n    let finLeases : \u0026FIND.LeaseCollection?\n\n    prepare(acct: AuthAccount) {\n        self.finLeases= acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)\n    }\n\n    pre{\n        self.finLeases != nil : \"Cannot borrow reference to find lease collection\"\n    }\n\n    execute{\n        self.finLeases!.listForAuction(name: name, auctionStartPrice: auctionStartPrice, auctionReservePrice: auctionReservePrice, auctionDuration: auctionDuration,  auctionExtensionOnLateBid: auctionExtensionOnLateBid)\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "auctionStartPrice",
                     "auctionReservePrice",
                     "auctionDuration",
                     "auctionExtensionOnLateBid"
                  ],
                  "parameters": {
                     "auctionDuration": "UFix64",
                     "auctionExtensionOnLateBid": "UFix64",
                     "auctionReservePrice": "UFix64",
                     "auctionStartPrice": "UFix64",
                     "name": "String"
                  }
               }
            },
            "listNameForSale": {
               "code": "import FIND from 0x097bafa4e0b48eef\n\ntransaction(name: String, directSellPrice:UFix64) {\n\n    let finLeases : \u0026FIND.LeaseCollection?\n\n    prepare(acct: AuthAccount) {\n        self.finLeases= acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)\n    }\n\n    pre{\n        self.finLeases != nil : \"Cannot borrow reference to find lease collection\"\n    }\n\n    execute{\n        self.finLeases!.listForSale(name: name,  directSellPrice:directSellPrice)\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "directSellPrice"
                  ],
                  "parameters": {
                     "directSellPrice": "UFix64",
                     "name": "String"
                  }
               }
            },
            "moveNameTO": {
               "code": "import Profile from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\n\n\ntransaction(name: String, receiver:String) {\n\n\n    let receiverAddress:Address?\n    let sender : \u0026FIND.LeaseCollection\n\n    prepare(acct: AuthAccount) {\n        self.sender= acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n        self.receiverAddress=FIND.resolve(receiver)\n    } \n\n    pre{\n        self.receiverAddress != nil : \"The input pass in is not a valid name or address. Input : \".concat(receiver)\n    }\n\n    execute {\n        let receiver=getAccount(self.receiverAddress!)\n        let receiverLease = receiver.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        let receiverProfile = receiver.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\n        if !receiverLease.check() || !receiverProfile.check() {\n            panic(\"Not a valid FIND user\")\n        }\n\n        self.sender.move(name:name, profile:receiverProfile, to: receiverLease)\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "receiver"
                  ],
                  "parameters": {
                     "name": "String",
                     "receiver": "String"
                  }
               }
            },
            "openBl0xPack": {
               "code": "import Bl0x from 0x7620acf6d7f2468a\nimport Bl0xPack from 0x7620acf6d7f2468a\nimport FungibleToken from 0xf233dcee88fe0abe\nimport NonFungibleToken from 0x1d7e57aa55817448\nimport MetadataViews from 0x1d7e57aa55817448\n\n/// A transaction to open a pack with a given id\n/// @param packId: The id of the pack to open\ntransaction(packId:UInt64) {\n\n    let packs: \u0026Bl0xPack.Collection\n    var receiver: Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e\n\n    prepare(account: AuthAccount) {\n        self.packs=account.borrow\u003c\u0026Bl0xPack.Collection\u003e(from: Bl0xPack.CollectionStoragePath)!\n        self.receiver = account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(Bl0x.CollectionPublicPath)\n        if !self.receiver.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Bl0x.createEmptyCollection(), to: Bl0x.CollectionStoragePath)\n            account.link\u003c\u0026Bl0x.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                Bl0x.CollectionPublicPath,\n                target: Bl0x.CollectionStoragePath\n            )\n            account.link\u003c\u0026Bl0x.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                Bl0x.CollectionPrivatePath,\n                target: Bl0x.CollectionStoragePath\n            )\n\n            self.receiver = account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(Bl0x.CollectionPublicPath)\n        }\n\n    }\n\n    pre {\n        self.receiver.check() : \"The receiver collection for the packs is not set up properly\"\n    }\n    execute {\n        self.packs.open(packId: packId, receiverCap:self.receiver)\n    }\n\n    post {\n        !self.packs.getIDs().contains(packId) : \"The pack is still present in the users collection\"\n    }\n}",
               "spec": {
                  "order": [
                     "packId"
                  ],
                  "parameters": {
                     "packId": "UInt64"
                  }
               }
            },
            "redeemAllLostAndFoundNFTs": {
               "code": "import FindLostAndFoundWrapper from 0x097bafa4e0b48eef\nimport LostAndFound from 0x473d6a2c37eab5be\nimport FINDNFTCatalog from 0x097bafa4e0b48eef\nimport NFTCatalog from 0x49a7cda3a1eecc29\nimport NonFungibleToken from 0x1d7e57aa55817448\nimport MetadataViews from 0x1d7e57aa55817448\nimport FIND from 0x097bafa4e0b48eef\nimport Bl0xPack from 0x7620acf6d7f2468a\n\n//IMPORT\n\ntransaction() {\n\n    let ids : {String : [UInt64]}\n    let nftInfos : {String : NFTCatalog.NFTCollectionData}\n    let receiverAddress : Address\n\n    prepare(account: AuthAccount){\n\n        //LINK\n\n        let findPackCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Bl0xPack.CollectionPublicPath)\n        if !findPackCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e( \u003c- Bl0xPack.createEmptyCollection(), to: Bl0xPack.CollectionStoragePath)\n            account.link\u003c\u0026Bl0xPack.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                Bl0xPack.CollectionPublicPath,\n                target: Bl0xPack.CollectionStoragePath\n            )\n        }\n\n        self.nftInfos = {}\n        self.ids = FindLostAndFoundWrapper.getTicketIDs(user: account.address, specificType: Type\u003c@NonFungibleToken.NFT\u003e())\n\n        for type in self.ids.keys{ \n            if self.nftInfos[type] == nil {\n                let collections = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: type) ?? panic(\"NFT type is not supported at the moment. Type : \".concat(type))\n                self.nftInfos[type] = FINDNFTCatalog.getCatalogEntry(collectionIdentifier: collections.keys[0])!.collectionData\n            }\n        }\n\n        self.receiverAddress = account.address\n    }\n\n    execute{\n        for type in self.ids.keys{ \n            let path = self.nftInfos[type]!.publicPath\n            for id in self.ids[type]! {\n                FindLostAndFoundWrapper.redeemNFT(type: CompositeType(type)!, ticketID: id, receiverAddress: self.receiverAddress, collectionPublicPath: path)\n            }\n        }\n    }\n}",
               "spec": {
                  "order": [],
                  "parameters": {}
               }
            },
            "redeemAllLostAndFoundNFTsOnBehalf": {
               "code": "import FindLostAndFoundWrapper from 0x097bafa4e0b48eef\nimport LostAndFound from 0x473d6a2c37eab5be\nimport FINDNFTCatalog from 0x097bafa4e0b48eef\nimport NFTCatalog from 0x49a7cda3a1eecc29\nimport NonFungibleToken from 0x1d7e57aa55817448\nimport MetadataViews from 0x1d7e57aa55817448\nimport FIND from 0x097bafa4e0b48eef\n\n//IMPORT\n\ntransaction(receiverAddress: Address) {\n\n    let ids : {String : [UInt64]}\n    let nftInfos : {String : NFTCatalog.NFTCollectionData}\n    let receiverAddress : Address\n\n    prepare(account: AuthAccount){\n        self.receiverAddress = receiverAddress\n\n        self.nftInfos = {}\n        self.ids = FindLostAndFoundWrapper.getTicketIDs(user: receiverAddress, specificType: Type\u003c@NonFungibleToken.NFT\u003e())\n\n        for type in self.ids.keys{ \n            if self.nftInfos[type] == nil {\n                let collections = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: type) ?? panic(\"NFT type is not supported at the moment. Type : \".concat(type))\n                self.nftInfos[type] = FINDNFTCatalog.getCatalogEntry(collectionIdentifier: collections.keys[0])!.collectionData\n            }\n        }\n\n    }\n\n    execute{\n        for type in self.ids.keys{ \n            let path = self.nftInfos[type]!.publicPath\n            for id in self.ids[type]! {\n                FindLostAndFoundWrapper.redeemNFT(type: CompositeType(type)!, ticketID: id, receiverAddress: self.receiverAddress, collectionPublicPath: path)\n            }\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "receiverAddress"
                  ],
                  "parameters": {
                     "receiverAddress": "Address"
                  }
               }
            },
            "redeemLostAndFoundNFTs": {
               "code": "import FindLostAndFoundWrapper from 0x097bafa4e0b48eef\nimport LostAndFound from 0x473d6a2c37eab5be\nimport FINDNFTCatalog from 0x097bafa4e0b48eef\nimport NFTCatalog from 0x49a7cda3a1eecc29\nimport NonFungibleToken from 0x1d7e57aa55817448\nimport MetadataViews from 0x1d7e57aa55817448\nimport FindViews from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\nimport Bl0xPack from 0x7620acf6d7f2468a\n\n//IMPORT\n\ntransaction(ids: {String : [UInt64]}) {\n\n    let nftInfos : {String : NFTCatalog.NFTCollectionData}\n    let receiverAddress : Address\n\n    prepare(account: AuthAccount){\n\n        //LINK\n\n        let findPackCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Bl0xPack.CollectionPublicPath)\n        if !findPackCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e( \u003c- Bl0xPack.createEmptyCollection(), to: Bl0xPack.CollectionStoragePath)\n            account.link\u003c\u0026Bl0xPack.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                Bl0xPack.CollectionPublicPath,\n                target: Bl0xPack.CollectionStoragePath\n            )\n        }\n\n        self.nftInfos = {}\n\n        for type in ids.keys{ \n            if self.nftInfos[type] == nil {\n                let collections = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: type) ?? panic(\"NFT type is not supported at the moment. Type : \".concat(type))\n                self.nftInfos[type] = FINDNFTCatalog.getCatalogEntry(collectionIdentifier: collections.keys[0])!.collectionData\n            }\n        }\n\n        self.receiverAddress = account.address\n    }\n\n    execute{\n        for type in ids.keys{ \n            let path = self.nftInfos[type]!.publicPath\n            for id in ids[type]! {\n                FindLostAndFoundWrapper.redeemNFT(type: CompositeType(type)!, ticketID: id, receiverAddress:self.receiverAddress, collectionPublicPath: path)\n            }\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "ids"
                  ],
                  "parameters": {
                     "ids": "{String: [UInt64]}"
                  }
               }
            },
            "redeemLostAndFoundNFTsOnBehalf": {
               "code": "import FindLostAndFoundWrapper from 0x097bafa4e0b48eef\nimport LostAndFound from 0x473d6a2c37eab5be\nimport FINDNFTCatalog from 0x097bafa4e0b48eef\nimport NFTCatalog from 0x49a7cda3a1eecc29\nimport NonFungibleToken from 0x1d7e57aa55817448\nimport MetadataViews from 0x1d7e57aa55817448\nimport FindViews from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\nimport Bl0xPack from 0x7620acf6d7f2468a\n\n//IMPORT\n\ntransaction(receiverAddress: Address, ids: {String : [UInt64]}) {\n\n    let nftInfos : {String : NFTCatalog.NFTCollectionData}\n    let receiverAddress : Address\n\n    prepare(account: AuthAccount){\n\n        self.receiverAddress = receiverAddress\n\n        self.nftInfos = {}\n\n        for type in ids.keys{ \n            if self.nftInfos[type] == nil {\n                let collections = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: type) ?? panic(\"NFT type is not supported at the moment. Type : \".concat(type))\n                self.nftInfos[type] = FINDNFTCatalog.getCatalogEntry(collectionIdentifier: collections.keys[0])!.collectionData\n            }\n        }\n\n    }\n\n    execute{\n        for type in ids.keys{ \n            let path = self.nftInfos[type]!.publicPath\n            for id in ids[type]! {\n                FindLostAndFoundWrapper.redeemNFT(type: CompositeType(type)!, ticketID: id, receiverAddress:self.receiverAddress, collectionPublicPath: path)\n            }\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "receiverAddress",
                     "ids"
                  ],
                  "parameters": {
                     "ids": "{String: [UInt64]}",
                     "receiverAddress": "Address"
                  }
               }
            },
            "register": {
               "code": "import FungibleToken from 0xf233dcee88fe0abe\nimport FUSD from 0x3c5959b568896393\nimport FiatToken from 0xb19436aae4d94622\nimport FlowToken from 0x1654653399040a61\nimport Profile from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\nimport FindMarketSale from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferEscrow from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferSoft from 0x097bafa4e0b48eef\nimport FindMarketAuctionEscrow from 0x097bafa4e0b48eef\nimport FindMarketAuctionSoft from 0x097bafa4e0b48eef\nimport FindMarket from 0x097bafa4e0b48eef\nimport NonFungibleToken from 0x1d7e57aa55817448\nimport MetadataViews from 0x1d7e57aa55817448\nimport Dandy from 0x097bafa4e0b48eef\nimport FindLeaseMarketSale from 0x097bafa4e0b48eef\nimport FindLeaseMarketAuctionSoft from 0x097bafa4e0b48eef\n// import FindLeaseMarketAuctionEscrow from \"../contracts/FindLeaseMarketAuctionEscrow.cdc\"\nimport FindLeaseMarketDirectOfferSoft from 0x097bafa4e0b48eef\n// import FindLeaseMarketDirectOfferEscrow from \"../contracts/FindLeaseMarketDirectOfferEscrow.cdc\"\nimport FindLeaseMarket from 0x097bafa4e0b48eef\n\ntransaction(name: String, amount: UFix64) {\n\n    let vaultRef : \u0026FUSD.Vault?\n    let leases : \u0026FIND.LeaseCollection?\n    let price : UFix64\n\n    prepare(account: AuthAccount) {\n\n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n        //SYNC with register\n        //Add exising FUSD or create a new one and add it\n        let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n        if !fusdReceiver.check() {\n            let fusd \u003c- FUSD.createEmptyVault()\n            account.save(\u003c- fusd, to: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n        }\n\n        let usdcCap = account.getCapability\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e(FiatToken.VaultReceiverPubPath)\n        if !usdcCap.check() {\n            account.save( \u003c-FiatToken.createEmptyVault(), to: FiatToken.VaultStoragePath)\n            account.link\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e( FiatToken.VaultReceiverPubPath, target: FiatToken.VaultStoragePath)\n            account.link\u003c\u0026FiatToken.Vault{FiatToken.ResourceId}\u003e( FiatToken.VaultUUIDPubPath, target: FiatToken.VaultStoragePath)\n            account.link\u003c\u0026FiatToken.Vault{FungibleToken.Balance}\u003e( FiatToken.VaultBalancePubPath, target:FiatToken.VaultStoragePath)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let dandyCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        let dandyCapPrivate= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPrivatePath)\n        if !dandyCapPrivate.check() {\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        var created=false\n        var updated=false\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        if !profile.hasWallet(\"Flow\") {\n            let flowWallet=Profile.Wallet( name:\"Flow\", receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), tags: [\"flow\"])\n    \n            profile.addWallet(flowWallet)\n            updated=true\n        }\n        if !profile.hasWallet(\"FUSD\") {\n            profile.addWallet(Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), tags: [\"fusd\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if !profile.hasWallet(\"USDC\") {\n            profile.addWallet(Profile.Wallet( name:\"USDC\", receiver:usdcCap, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(FiatToken.VaultBalancePubPath), accept: Type\u003c@FiatToken.Vault\u003e(), tags: [\"usdc\", \"stablecoin\"]))\n            updated=true\n        }\n\n          //If find name not set and we have a profile set it.\n        if profile.getFindName() == \"\" {\n            profile.setFindName(name)\n            // If name is set, it will emit Updated Event, there is no need to emit another update event below. \n            updated=false\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else if updated {\n            profile.emitUpdatedEvent()\n        }\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let tenantCapability= FindMarket.getTenantCapability(FindMarket.getFindTenantAddress())!\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        let doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        let doeSalePublicPath=FindMarket.getPublicPath(doeSaleType, name: tenant.name)\n        let doeSaleStoragePath= FindMarket.getStoragePath(doeSaleType, name:tenant.name)\n        let doeSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n        if !doeSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n        }\n\n        let doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        let doeBidPublicPath=FindMarket.getPublicPath(doeBidType, name: tenant.name)\n        let doeBidStoragePath= FindMarket.getStoragePath(doeBidType, name:tenant.name)\n        let doeBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n        if !doeBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n        }\n\n        /// auctions that escrow ft\n        let aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        let aeSalePublicPath=FindMarket.getPublicPath(aeSaleType, name: tenant.name)\n        let aeSaleStoragePath= FindMarket.getStoragePath(aeSaleType, name:tenant.name)\n        let aeSaleCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n        if !aeSaleCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n        }\n\n        let dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\n        let dosSalePublicPath=FindMarket.getPublicPath(dosSaleType, name: tenant.name)\n        let dosSaleStoragePath= FindMarket.getStoragePath(dosSaleType, name:tenant.name)\n\n        let dosSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n        if !dosSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n        }\n\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n        if !dosBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n        }\n\n        let aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\n        let aeBidPublicPath=FindMarket.getPublicPath(aeBidType, name: tenant.name)\n        let aeBidStoragePath= FindMarket.getStoragePath(aeBidType, name:tenant.name)\n        let aeBidCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n        if !aeBidCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n        }\n\n     /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n        }\n\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n        if !asBidCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n        }\n\n        let leaseTenantCapability= FindMarket.getTenantCapability(FindMarket.getTenantAddress(\"findLease\")!)!\n\n        let leaseSaleItemType= Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()\n        let leasePublicPath=FindMarket.getPublicPath(leaseSaleItemType, name: \"findLease\")\n        let leaseStoragePath= FindMarket.getStoragePath(leaseSaleItemType, name:\"findLease\")\n        let leaseSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath) \n        if !leaseSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketSale.SaleItemCollection\u003e(\u003c- FindLeaseMarketSale.createEmptySaleItemCollection(leaseTenantCapability), to: leaseStoragePath)\n            account.link\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath, target: leaseStoragePath)\n        }\n\n        let leaseASSaleItemType= Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e()\n        let leaseASPublicPath=FindMarket.getPublicPath(leaseASSaleItemType, name: \"findLease\")\n        let leaseASStoragePath= FindMarket.getStoragePath(leaseASSaleItemType, name:\"findLease\")\n        let leaseASSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath) \n        if !leaseASSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseASStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath, target: leaseASStoragePath)\n        }\n\n\n        let leaseASBidType= Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e()\n        let leaseASBidPublicPath=FindMarket.getPublicPath(leaseASBidType, name: \"findLease\")\n        let leaseASBidStoragePath= FindMarket.getStoragePath(leaseASBidType, name: \"findLease\")\n        let leaseASBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath) \n        if !leaseASBidCap.check() {\n            account.save\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseASBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath, target: leaseASBidStoragePath)\n        }\n\n        // let leaseAESaleItemType= Type\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e()\n        // let leaseAEPublicPath=FindMarket.getPublicPath(leaseAESaleItemType, name: \"findLease\")\n        // let leaseAEStoragePath= FindMarket.getStoragePath(leaseAESaleItemType, name:\"findLease\")\n        // let leaseAESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath) \n        // if !leaseAESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseAEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath, target: leaseAEStoragePath)\n        // }\n\n        // let leaseAEBidType= Type\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e()\n        // let leaseAEBidPublicPath=FindMarket.getPublicPath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidStoragePath= FindMarket.getStoragePath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath) \n        // if !leaseAEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseAEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath, target: leaseAEBidStoragePath)\n        // }\n\n        let leaseDOSSaleItemType= Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e()\n        let leaseDOSPublicPath=FindMarket.getPublicPath(leaseDOSSaleItemType, name: \"findLease\")\n        let leaseDOSStoragePath= FindMarket.getStoragePath(leaseDOSSaleItemType, name:\"findLease\")\n        let leaseDOSSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath) \n        if !leaseDOSSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOSStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath, target: leaseDOSStoragePath)\n        }\n\n        let leaseDOSBidType= Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let leaseDOSBidPublicPath=FindMarket.getPublicPath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidStoragePath= FindMarket.getStoragePath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath) \n        if !leaseDOSBidCap.check() {\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOSBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath, target: leaseDOSBidStoragePath)\n        }\n\n        // let leaseDOESaleItemType= Type\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        // let leaseDOEPublicPath=FindMarket.getPublicPath(leaseDOESaleItemType, name: \"findLease\")\n        // let leaseDOEStoragePath= FindMarket.getStoragePath(leaseDOESaleItemType, name:\"findLease\")\n        // let leaseDOESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath) \n        // if !leaseDOESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath, target: leaseDOEStoragePath)\n        // }\n\n        // let leaseDOEBidType= Type\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        // let leaseDOEBidPublicPath=FindMarket.getPublicPath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidStoragePath= FindMarket.getStoragePath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath) \n        // if !leaseDOEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath, target: leaseDOEBidStoragePath)\n        // }\n        //SYNC with register\n\n        self.price=FIND.calculateCost(name)\n        log(\"The cost for registering this name is \".concat(self.price.toString()))\n        self.vaultRef = account.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault)\n        self.leases=account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from: FIND.LeaseStoragePath)\n    }\n\n    pre{\n        self.vaultRef != nil : \"Could not borrow reference to the fusdVault!\"\n        self.leases != nil : \"Could not borrow reference to find lease collection\"\n        self.price == amount : \"Calculated cost : \".concat(self.price.toString()).concat(\" does not match expected cost : \").concat(amount.toString())\n    }\n\n    execute{\n        let payVault \u003c- self.vaultRef!.withdraw(amount: self.price) as! @FUSD.Vault\n        self.leases!.register(name: name, vault: \u003c- payVault)\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "name": "String"
                  }
               }
            },
            "registerGift": {
               "code": "import FUSD from 0x3c5959b568896393\nimport Profile from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\n\ntransaction(name: String, amount: UFix64, recipient: String) {\n\n    let price : UFix64 \n    let vaultRef : \u0026FUSD.Vault? \n    let receiverLease : Capability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e\n    let receiverProfile : Capability\u003c\u0026{Profile.Public}\u003e\n    let leases : \u0026FIND.LeaseCollection?\n\n    prepare(acct: AuthAccount) {\n\n        let resolveAddress = FIND.resolve(recipient)\n        if resolveAddress == nil {panic(\"The input pass in is not a valid name or address. Input : \".concat(recipient))}\n        let address = resolveAddress!\n\n        self.price=FIND.calculateCost(name)\n        log(\"The cost for registering this name is \".concat(self.price.toString()))\n\n        self.vaultRef = acct.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault)\n\n        self.leases=acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from: FIND.LeaseStoragePath)\n\n        let receiver = getAccount(address)\n        self.receiverLease = receiver.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        self.receiverProfile = receiver.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\n    }\n\n    pre{\n        self.price == amount : \"Calculated cost : \".concat(self.price.toString()).concat(\" does not match expected cost\").concat(amount.toString())\n        self.vaultRef != nil : \"Cannot borrow reference to fusd Vault!\"\n        self.receiverLease.check() : \"Lease capability is invalid\"\n        self.receiverProfile.check() : \"Profile capability is invalid\"\n        self.leases != nil : \"Cannot borrow refernce to find lease collection\"\n    }\n\n    execute{\n        let payVault \u003c- self.vaultRef!.withdraw(amount: self.price) as! @FUSD.Vault\n        self.leases!.register(name: name, vault: \u003c- payVault)\n        self.leases!.move(name: name, profile: self.receiverProfile, to: self.receiverLease)\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "amount",
                     "recipient"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "name": "String",
                     "recipient": "String"
                  }
               }
            },
            "rejectNameDirectOffer": {
               "code": "import FIND from 0x097bafa4e0b48eef\n\ntransaction(names: [String]) {\n\n    let finLeases : \u0026FIND.LeaseCollection? \n\n    prepare(account: AuthAccount) {\n        self.finLeases= account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)\n    }\n\n    pre{\n        self.finLeases != nil : \"Cannot borrow reference to find lease collection\"\n    }\n\n    execute{\n        for name in names {\n            self.finLeases!.cancel(name)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "names"
                  ],
                  "parameters": {
                     "names": "[String]"
                  }
               }
            },
            "relistMarketListings": {
               "code": "import FindMarket from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferEscrow from 0x097bafa4e0b48eef\nimport FindMarketAuctionEscrow from 0x097bafa4e0b48eef\nimport FindMarketAuctionSoft from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferSoft from 0x097bafa4e0b48eef\nimport FindMarketSale from 0x097bafa4e0b48eef\n\ntransaction(marketplace:Address, ids: {String : [UInt64]}) {\n    prepare(account: AuthAccount) {\n\n        let tenant=FindMarket.getTenant(marketplace)\n\n        var saleType = Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        if let ids = ids[FindMarket.getMarketOptionFromType(saleType)] {\n            let saleItems= account.borrow\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection\u003e(from: tenant.getStoragePath(saleType))!\n            for id in ids {\n                saleItems.relist(id)\n            }\n        }\n\n        saleType = Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        if let ids = ids[FindMarket.getMarketOptionFromType(saleType)] {\n            let saleItems= account.borrow\u003c\u0026FindMarketAuctionSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(saleType))!\n            for id in ids {\n                saleItems.relist(id)\n            }\n        }\n\n        saleType = Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        if let ids = ids[FindMarket.getMarketOptionFromType(saleType)] {\n            let saleItems= account.borrow\u003c\u0026FindMarketSale.SaleItemCollection\u003e(from: tenant.getStoragePath(saleType))!\n            for id in ids {\n                saleItems.relist(id)\n            }\n        }\n\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "ids"
                  ],
                  "parameters": {
                     "ids": "{String: [UInt64]}",
                     "marketplace": "Address"
                  }
               }
            },
            "removeCurratedCollection": {
               "code": "transaction(name: String) {\n    prepare(account: AuthAccount) {\n\n        let path=/storage/FindCuratedCollections\n        let publicPath=/public/FindCuratedCollections\n\n        var collections : {String: [String]} = {}\n        if account.borrow\u003c\u0026{String: [String]}\u003e(from:path) != nil {\n             collections=account.load\u003c{String: [String]}\u003e(from:path)!\n        }\n        collections.remove(key: name)\n        account.save(collections, to: path)\n        let link = account.getCapability\u003c\u0026{String: [String]}\u003e(publicPath)\n        if !link.check() {\n            account.link\u003c\u0026{String: [String]}\u003e( publicPath, target: path)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "removeMarketOption": {
               "code": "import FindMarket from 0x097bafa4e0b48eef\n\ntransaction(saleItemName: String){\n    \n    prepare(account: AuthAccount){\n        let path = FindMarket.TenantClientStoragePath\n        let tenantRef = account.borrow\u003c\u0026FindMarket.TenantClient\u003e(from: path) ?? panic(\"Cannot borrow Reference.\")\n\n        tenantRef.removeMarketOption(name: saleItemName)\n    }\n}",
               "spec": {
                  "order": [
                     "saleItemName"
                  ],
                  "parameters": {
                     "saleItemName": "String"
                  }
               }
            },
            "removeRelatedAccount": {
               "code": "import RelatedAccounts from 0x097bafa4e0b48eef\n\ntransaction(name: String){\n\n    var relatedAccounts : \u0026RelatedAccounts.Accounts?\n\n    prepare(account: AuthAccount) {\n\n        self.relatedAccounts= account.borrow\u003c\u0026RelatedAccounts.Accounts\u003e(from:RelatedAccounts.storagePath)\n        if self.relatedAccounts == nil {\n            let relatedAccounts \u003c- RelatedAccounts.createEmptyAccounts()\n            account.save(\u003c- relatedAccounts, to: RelatedAccounts.storagePath)\n            account.link\u003c\u0026RelatedAccounts.Accounts{RelatedAccounts.Public}\u003e(RelatedAccounts.publicPath, target: RelatedAccounts.storagePath)\n            self.relatedAccounts= account.borrow\u003c\u0026RelatedAccounts.Accounts\u003e(from:RelatedAccounts.storagePath)\n        }\n\n        let cap = account.getCapability\u003c\u0026RelatedAccounts.Accounts{RelatedAccounts.Public}\u003e(RelatedAccounts.publicPath)\n        if !cap.check() {\n            account.unlink(RelatedAccounts.publicPath)\n            account.link\u003c\u0026RelatedAccounts.Accounts{RelatedAccounts.Public}\u003e(RelatedAccounts.publicPath, target: RelatedAccounts.storagePath)\n        }\n\n    }\n\n    execute{\n        self.relatedAccounts!.deleteAccount(name: name)\n    }\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "removeTenantRule": {
               "code": "import FindMarket from 0x097bafa4e0b48eef\n\ntransaction(optionName: String, tenantRuleName: String){\n    prepare(account: AuthAccount){\n        let path = FindMarket.TenantClientStoragePath\n        let tenantRef = account.borrow\u003c\u0026FindMarket.TenantClient\u003e(from: path) ?? panic(\"Cannot borrow Reference.\")\n\n        tenantRef.removeTenantRule(optionName: optionName, tenantRuleName: tenantRuleName)\n    }\n}",
               "spec": {
                  "order": [
                     "optionName",
                     "tenantRuleName"
                  ],
                  "parameters": {
                     "optionName": "String",
                     "tenantRuleName": "String"
                  }
               }
            },
            "renewName": {
               "code": "import FUSD from 0x3c5959b568896393\nimport FIND from 0x097bafa4e0b48eef\n\ntransaction(name: String, amount: UFix64) {\n\n    let price : UFix64\n    let vaultRef : \u0026FUSD.Vault? \n    let finLeases : \u0026FIND.LeaseCollection? \n\n    prepare(acct: AuthAccount) {\n        self.price=FIND.calculateCost(name)\n        self.vaultRef = acct.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault)\n        self.finLeases= acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)\n    }\n\n    pre{\n        self.price == amount : \"expected renew cost : \".concat(self.price.toString()).concat(\" is not the same as calculated renew cost : \").concat(amount.toString())\n        self.vaultRef != nil : \"Could not borrow reference to the fusdVault!\"\n        self.finLeases != nil : \"Could not borrow reference to find lease collection\"\n    }\n\n    execute{\n        let payVault \u003c- self.vaultRef!.withdraw(amount: self.price) as! @FUSD.Vault\n        let finToken= self.finLeases!.borrow(name)\n        finToken.extendLease(\u003c- payVault)\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "name": "String"
                  }
               }
            },
            "retractOfferLeaseMarketDirectOfferSoft": {
               "code": "import FindMarket from 0x097bafa4e0b48eef\nimport FindLeaseMarketDirectOfferSoft from 0x097bafa4e0b48eef\n\ntransaction(leaseName: String) {\n    let bidsReference: \u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection?\n\n    prepare(account: AuthAccount) {\n        let marketplace = FindMarket.getTenantAddress(\"findLease\")!\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e())\n        self.bidsReference= account.borrow\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(from: storagePath) \n    }\n\n    pre{\n        self.bidsReference != nil : \"Bid resource does not exist\"\n    }\n\n    execute {\n        self.bidsReference!.cancelBid(leaseName)\n    }\n}",
               "spec": {
                  "order": [
                     "leaseName"
                  ],
                  "parameters": {
                     "leaseName": "String"
                  }
               }
            },
            "retractOfferMarketDirectOfferEscrowed": {
               "code": "import FindMarket from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferEscrow from 0x097bafa4e0b48eef\n\ntransaction(marketplace:Address, id: UInt64) {\n    let bidsReference: \u0026FindMarketDirectOfferEscrow.MarketBidCollection? \n\n    prepare(account: AuthAccount) {\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e())\n        self.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection\u003e(from: storagePath) \n    }\n\n    pre{\n        self.bidsReference != nil : \"This account does not have a bid collection\"\n    }\n\n    execute {\n        self.bidsReference!.cancelBid(id)\n    }\n\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "retractOfferMarketDirectOfferSoft": {
               "code": "import FindMarket from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferSoft from 0x097bafa4e0b48eef\n\ntransaction(marketplace:Address, id: UInt64) {\n    let bidsReference: \u0026FindMarketDirectOfferSoft.MarketBidCollection?\n\n    prepare(account: AuthAccount) {\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n        self.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection\u003e(from: storagePath) \n    }\n\n    pre{\n        self.bidsReference != nil : \"Bid resource does not exist\"\n    }\n\n    execute {\n        self.bidsReference!.cancelBid(id)\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "sendCharity": {
               "code": "import NonFungibleToken from 0x1d7e57aa55817448\nimport CharityNFT from 0x097bafa4e0b48eef\n\n//mint an art and add it to a users collection\ntransaction(\n    id: UInt64,\n    recipient: Address\n) {\n    let receiverCap: Capability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e\n    let charityCollection: \u0026NonFungibleToken.Collection\n\n    prepare(account: AuthAccount) {\n        self.charityCollection =account.borrow\u003c\u0026NonFungibleToken.Collection\u003e(from: CharityNFT.CollectionStoragePath)!\n        self.receiverCap= getAccount(recipient).getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath)\n    }\n\n    pre{\n        self.receiverCap.check() : \"Receiver doesn't have receiving vault set up properly.\"\n    }\n\n    execute {\n        let nft \u003c- self.charityCollection.withdraw(withdrawID: id)\n        self.receiverCap.borrow()!.deposit(token: \u003c- nft)\n    }\n}",
               "spec": {
                  "order": [
                     "id",
                     "recipient"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "recipient": "Address"
                  }
               }
            },
            "sendDandy": {
               "code": "import FIND from 0x097bafa4e0b48eef\nimport NonFungibleToken from 0x1d7e57aa55817448\nimport Dandy from 0x097bafa4e0b48eef\n\ntransaction(user: String, id: UInt64) {\n\n    let address : Address\n    let cap : Capability\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic}\u003e\n    let senderRef : \u0026Dandy.Collection\n\n    prepare(account: AuthAccount) {\n        self.address = FIND.resolve(user) ?? panic(\"Cannot find user with this name / address\")\n        self.cap = getAccount(self.address).getCapability\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n\n        self.senderRef = account.borrow\u003c\u0026Dandy.Collection\u003e(from: Dandy.CollectionStoragePath) ?? panic(\"Cannot borrow reference to sender Collection.\")\n    }\n\n    pre{\n        self.cap.check() : \"Cannot borrow reference to receiver Collection. Receiver account : \".concat(self.address.toString())\n        self.senderRef != nil : \"Cannot borrow reference to sender Collection.\"\n    }\n\n    execute{\n        self.cap.borrow()!.deposit(token: \u003c- self.senderRef!.withdraw(withdrawID: id))\n    }\n}",
               "spec": {
                  "order": [
                     "user",
                     "id"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "user": "String"
                  }
               }
            },
            "sendFT": {
               "code": "import FungibleToken from 0xf233dcee88fe0abe\nimport Sender from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\nimport FTRegistry from 0x097bafa4e0b48eef\n\n\ntransaction(name: String, amount: UFix64, ftAliasOrIdentifier: String, tag: String, message:String) {\n\n    var token : \u0026Sender.Token\n    let walletReference : \u0026FungibleToken.Vault? \n\n    prepare(account: AuthAccount) {\n\n        let ft = FTRegistry.getFTInfo(ftAliasOrIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftAliasOrIdentifier))\n        self.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath)\n\n        if account.borrow\u003c\u0026Sender.Token\u003e(from: Sender.storagePath) == nil {\n            account.save(\u003c- Sender.create(), to: Sender.storagePath)\n        }\n\n        self.token =account.borrow\u003c\u0026Sender.Token\u003e(from: Sender.storagePath)!\n    }\n\n    pre{\n        self.walletReference != nil : \"No suitable wallet linked for this account\"\n    }\n\n    execute{\n        let vault \u003c- self.walletReference!.withdraw(amount: amount)\n        FIND.depositWithTagAndMessage(to: name, message: message, tag: tag, vault: \u003c- vault, from: self.token)\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "amount",
                     "ftAliasOrIdentifier",
                     "tag",
                     "message"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "ftAliasOrIdentifier": "String",
                     "message": "String",
                     "name": "String",
                     "tag": "String"
                  }
               }
            },
            "sendFTWithTag": {
               "code": "import NonFungibleToken from 0x1d7e57aa55817448\nimport MetadataViews from 0x1d7e57aa55817448\nimport FlowToken from 0x1654653399040a61\nimport FungibleToken from 0xf233dcee88fe0abe\nimport FUSD from 0x3c5959b568896393\nimport Profile from 0x097bafa4e0b48eef\nimport Sender from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\nimport CharityNFT from 0x097bafa4e0b48eef\n\n\ntransaction(name: String, amount: UFix64, type: String, tag:String) {\n\n    prepare(account: AuthAccount) {\n\n        let stdCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath)\n        if !stdCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- CharityNFT.createEmptyCollection(), to: CharityNFT.CollectionStoragePath)\n            account.link\u003c\u0026{NonFungibleToken.CollectionPublic, MetadataViews.ResolverCollection}\u003e(CharityNFT.CollectionPublicPath, target: CharityNFT.CollectionStoragePath)\n        }\n\n        let charityCap = account.getCapability\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection)\n        if !charityCap.check() {\n            account.link\u003c\u0026{CharityNFT.CollectionPublic, MetadataViews.ResolverCollection}\u003e(/public/findCharityNFTCollection, target: CharityNFT.CollectionStoragePath)\n        }\n\n      let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n        if !fusdReceiver.check() {\n            let fusd \u003c- FUSD.createEmptyVault()\n            account.save(\u003c- fusd, to: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profileName = account.address.toString()\n\n            let profile \u003c-Profile.createUser(name:profileName, createdAt: \"find\")\n\n            let fusdWallet=Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), names: [\"fusd\", \"stablecoin\"])\n\n            profile.addWallet(fusdWallet)\n\n            let flowWallet=Profile.Wallet(\n                name:\"Flow\", \n                receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver),\n                balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance),\n                accept: Type\u003c@FlowToken.Vault\u003e(),\n                names: [\"flow\"]\n            )\n    \n            profile.addWallet(flowWallet)\n            profile.addCollection(Profile.ResourceCollection(\"FINDLeases\",leaseCollection, Type\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(), [\"find\", \"leases\"]))\n            profile.addCollection(Profile.ResourceCollection(\"FINDBids\", bidCollection, Type\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(), [\"find\", \"bids\"]))\n\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n        }\n\n        if account.borrow\u003c\u0026Sender.Token\u003e(from: Sender.storagePath) == nil {\n            account.save(\u003c- Sender.create(), to: Sender.storagePath)\n        }\n\n        let token =account.borrow\u003c\u0026Sender.Token\u003e(from: Sender.storagePath)!\n\n\n        if type == \"fusd\" {\n            let vaultRef = account.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault) ?? panic(\"Could not borrow reference to the fusdVault!\")\n            let vault \u003c- vaultRef.withdraw(amount: amount)\n            FIND.depositWithTagAndMessage(to: name, message: \"\", tag: tag, vault: \u003c- vault, from: token)\n            return \n        }\n\n        let vaultRef = account.borrow\u003c\u0026FlowToken.Vault\u003e(from: /storage/flowTokenVault) ?? panic(\"Could not borrow reference to the fusdVault!\")\n        let vault \u003c- vaultRef.withdraw(amount: amount)\n        FIND.depositWithTagAndMessage(to: name, message: \"\", tag: tag, vault: \u003c- vault, from: token)\n    }\n\n}",
               "spec": {
                  "order": [
                     "name",
                     "amount",
                     "type",
                     "tag"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "name": "String",
                     "tag": "String",
                     "type": "String"
                  }
               }
            },
            "sendNFTs": {
               "code": "import FINDNFTCatalog from 0x097bafa4e0b48eef\nimport NFTCatalog from 0x49a7cda3a1eecc29\nimport FindViews from 0x097bafa4e0b48eef\nimport NonFungibleToken from 0x1d7e57aa55817448\nimport MetadataViews from 0x1d7e57aa55817448\nimport FungibleToken from 0xf233dcee88fe0abe\nimport FlowToken from 0x1654653399040a61\nimport FIND from 0x097bafa4e0b48eef\nimport FindLostAndFoundWrapper from 0x097bafa4e0b48eef\n\ntransaction(nftIdentifiers: [String], allReceivers: [String] , ids:[UInt64], memos: [String]) {\n\n    let pointers : [FindViews.AuthNFTPointer]\n    let nftInfos : [NFTCatalog.NFTCollectionData]\n    let flowVault : \u0026FungibleToken.Vault\n    let flowTokenRepayment : Capability\u003c\u0026FlowToken.Vault{FungibleToken.Receiver}\u003e\n\n    prepare(account: AuthAccount){\n\n        if allReceivers.length != nftIdentifiers.length || allReceivers.length != ids.length || allReceivers.length != memos.length {\n            panic(\"The length of arrays passed in are not equal\")\n        }\n\n        let pointers : [FindViews.AuthNFTPointer] = []\n        let nftInfos : {String : NFTCatalog.NFTCollectionData} = {}\n        self.nftInfos = []\n        let providerCaps : {String : Capability\u003c\u0026{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e} = {}\n\n\n        for i, id in ids {\n            if nftInfos[nftIdentifiers[i]] == nil {\n                let collections = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifiers[i]) ?? panic(\"NFT type is not supported at the moment. Type : \".concat(nftIdentifiers[i]))\n                nftInfos[nftIdentifiers[i]] = FINDNFTCatalog.getCatalogEntry(collectionIdentifier: collections.keys[0])!.collectionData\n            }\n            self.nftInfos.append(nftInfos[nftIdentifiers[i]]!)\n\n            if providerCaps[nftIdentifiers[i]] == nil {\n                // Initialize the providerCap if the user doesn't have one\n                var providerCap=account.getCapability\u003c\u0026{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e(self.nftInfos[i].privatePath)\n\n                if !providerCap.check() {\n                    let newCap = account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                        self.nftInfos[i].privatePath,\n                        target: self.nftInfos[i].storagePath\n                    )\n                    if newCap == nil {\n                        // If linking is not successful, we link it using finds custom link \n                        let pathIdentifier = self.nftInfos[i].privatePath.toString()\n                        let findPath = PrivatePath(identifier: pathIdentifier.slice(from: \"/private/\".length , upTo: pathIdentifier.length).concat(\"_FIND\"))!\n                        account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                            findPath,\n                            target: self.nftInfos[i].storagePath\n                        )\n                        providerCap = account.getCapability\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(findPath)\n                    }\n                }\n                providerCaps[nftIdentifiers[i]] = providerCap\n            }\n\n            let providerCap = providerCaps[nftIdentifiers[i]]!\n\n            pointers.append(FindViews.AuthNFTPointer(cap: providerCap, id: id))\n        }\n        self.pointers = pointers\n\n        // Get Vault for paying flow storage fee\n        self.flowVault = account.borrow\u003c\u0026FlowToken.Vault\u003e(from: /storage/flowTokenVault) ?? panic(\"Cannot borrow reference to sender's flow vault\")\n        self.flowTokenRepayment = account.getCapability\u003c\u0026FlowToken.Vault{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver) \n    }\n\n    execute{\n\n        for i , receiver in allReceivers {\n            FindLostAndFoundWrapper.depositNFT(\n                receiver: receiver,\n                collectionPublicPath: self.nftInfos[i].publicPath ,\n                item: self.pointers[i],\n                memo: memos[i],\n                storagePayment: self.flowVault,\n                flowTokenRepayment: self.flowTokenRepayment\n            )\n        }\n    \n    }\n\n\n}",
               "spec": {
                  "order": [
                     "nftIdentifiers",
                     "allReceivers",
                     "ids",
                     "memos"
                  ],
                  "parameters": {
                     "allReceivers": "[String]",
                     "ids": "[UInt64]",
                     "memos": "[String]",
                     "nftIdentifiers": "[String]"
                  }
               }
            },
            "setMainName": {
               "code": "import Profile from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\n\n\ntransaction(name: String) {\n\n    let leaseCollectionOwner : Capability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e\n    let profile : \u0026Profile.User\n\n    prepare(acct: AuthAccount) {\n        self.leaseCollectionOwner = acct.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        self.profile =acct.borrow\u003c\u0026Profile.User\u003e(from:Profile.storagePath)!\n    }\n\n    pre{\n        self.leaseCollectionOwner.check() : \"Not a find user\"\n        self.leaseCollectionOwner.borrow()!.getLease(name) != nil : \"You do not own this lease so you cannot set it as main name\"\n    }\n\n    execute{\n        self.profile.setFindName(name)\n    }\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "setMarketOptionFlowDandy": {
               "code": "import FindMarket from 0x097bafa4e0b48eef\nimport FlowToken from 0x1654653399040a61\nimport Dandy from 0x097bafa4e0b48eef\n\ntransaction(){\n    prepare(account: AuthAccount){\n        let path = FindMarket.TenantClientStoragePath\n        let tenantRef = account.borrow\u003c\u0026FindMarket.TenantClient\u003e(from: path) ?? panic(\"Cannot borrow Reference.\")\n\n        tenantRef.setMarketOption(name:\"FlowDandy\", cut: nil, rules:[\n            FindMarket.TenantRule(name:\"Flow\", types:[Type\u003c@FlowToken.Vault\u003e()], ruleType: \"ft\", allow: true),\n            FindMarket.TenantRule(name:\"Dandy\", types:[ Type\u003c@Dandy.NFT\u003e()], ruleType: \"nft\", allow: true)\n            ]\n        )\n    }\n}",
               "spec": {
                  "order": [],
                  "parameters": {}
               }
            },
            "setPrivateMode": {
               "code": "import Profile from 0x097bafa4e0b48eef\n\ntransaction(mode: Bool) {\n\n    let profile : \u0026Profile.User?\n\n    prepare(acct: AuthAccount) {\n        self.profile =acct.borrow\u003c\u0026Profile.User\u003e(from:Profile.storagePath)\n    }\n\n    pre{\n        self.profile != nil : \"Cannot borrow reference to profile\"\n    }\n\n    execute{\n        self.profile!.setPrivateMode(mode)\n        self.profile!.emitUpdatedEvent()\n    }\n}",
               "spec": {
                  "order": [
                     "mode"
                  ],
                  "parameters": {
                     "mode": "Bool"
                  }
               }
            },
            "setProfile": {
               "code": "import Profile from 0x097bafa4e0b48eef\n\ntransaction(avatar: String) {\n\n    let profile : \u0026Profile.User?\n\n    prepare(acct: AuthAccount) {\n        self.profile =acct.borrow\u003c\u0026Profile.User\u003e(from:Profile.storagePath)\n    }\n\n    pre{\n        self.profile != nil : \"Cannot borrow reference to profile\"\n    }\n\n    execute{\n        self.profile!.setAvatar(avatar)\n        self.profile!.emitUpdatedEvent()\n    }\n}",
               "spec": {
                  "order": [
                     "avatar"
                  ],
                  "parameters": {
                     "avatar": "String"
                  }
               }
            },
            "setRelatedAccount": {
               "code": "import RelatedAccounts from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\n\ntransaction(name: String, target: String) {\n\n    var relatedAccounts : \u0026RelatedAccounts.Accounts?\n    let address : Address?\n\n    prepare(account: AuthAccount) {\n\n\n        self.address = FIND.resolve(target)\n\n        self.relatedAccounts= account.borrow\u003c\u0026RelatedAccounts.Accounts\u003e(from:RelatedAccounts.storagePath)\n        if self.relatedAccounts == nil {\n            let relatedAccounts \u003c- RelatedAccounts.createEmptyAccounts()\n            account.save(\u003c- relatedAccounts, to: RelatedAccounts.storagePath)\n            account.link\u003c\u0026RelatedAccounts.Accounts{RelatedAccounts.Public}\u003e(RelatedAccounts.publicPath, target: RelatedAccounts.storagePath)\n            self.relatedAccounts= account.borrow\u003c\u0026RelatedAccounts.Accounts\u003e(from:RelatedAccounts.storagePath)\n        }\n\n        let cap = account.getCapability\u003c\u0026RelatedAccounts.Accounts{RelatedAccounts.Public}\u003e(RelatedAccounts.publicPath)\n        if !cap.check() {\n            account.unlink(RelatedAccounts.publicPath)\n            account.link\u003c\u0026RelatedAccounts.Accounts{RelatedAccounts.Public}\u003e(RelatedAccounts.publicPath, target: RelatedAccounts.storagePath)\n        }\n    }\n\n    pre{\n        self.address != nil : \"The input pass in is not a valid name or address. Input : \".concat(target)\n    }\n\n    execute{\n        self.relatedAccounts!.setFlowAccount(name: name, address: self.address!)\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "target"
                  ],
                  "parameters": {
                     "name": "String",
                     "target": "String"
                  }
               }
            },
            "setSellDandyRules": {
               "code": "import FindMarket from 0x097bafa4e0b48eef\nimport FlowToken from 0x1654653399040a61\nimport FUSD from 0x3c5959b568896393\nimport Dandy from 0x097bafa4e0b48eef\n\ntransaction(){\n    prepare(account: AuthAccount){\n        let path = FindMarket.TenantClientStoragePath\n        let tenantRef = account.borrow\u003c\u0026FindMarket.TenantClient\u003e(from: path) ?? panic(\"Cannot borrow Reference.\")\n\n        tenantRef.setMarketOption(name:\"FUSDDandy\", cut: nil, rules:[\n            FindMarket.TenantRule(name:\"FUSD\", types:[Type\u003c@FUSD.Vault\u003e()], ruleType: \"ft\", allow: true),\n            FindMarket.TenantRule(name:\"Dandy\", types:[ Type\u003c@Dandy.NFT\u003e()], ruleType: \"nft\", allow: true)\n            ]\n        )\n\n        tenantRef.setMarketOption(name:\"FlowDandy\", cut: nil, rules:[\n            FindMarket.TenantRule(name:\"Flow\", types:[Type\u003c@FlowToken.Vault\u003e()], ruleType: \"ft\", allow: true),\n            FindMarket.TenantRule(name:\"Dandy\", types:[ Type\u003c@Dandy.NFT\u003e()], ruleType: \"nft\", allow: true)\n            ]\n        )\n\n    }\n}",
               "spec": {
                  "order": [],
                  "parameters": {}
               }
            },
            "setTenantRuleFUSD": {
               "code": "import FindMarket from 0x097bafa4e0b48eef\nimport FUSD from 0x3c5959b568896393\n\ntransaction(optionName: String){\n    prepare(account: AuthAccount){\n        let path = FindMarket.TenantClientStoragePath\n        let tenantRef = account.borrow\u003c\u0026FindMarket.TenantClient\u003e(from: path) ?? panic(\"Cannot borrow Reference.\")\n\n        tenantRef.setTenantRule(optionName: optionName, tenantRule:\n            FindMarket.TenantRule(name:\"FUSD\", types:[Type\u003c@FUSD.Vault\u003e()], ruleType: \"ft\", allow: true)\n        )\n    }\n}",
               "spec": {
                  "order": [
                     "optionName"
                  ],
                  "parameters": {
                     "optionName": "String"
                  }
               }
            },
            "startNameAuction": {
               "code": "import FIND from 0x097bafa4e0b48eef\n\ntransaction(name: String) {\n\n    let finLeases : \u0026FIND.LeaseCollection?\n\n    prepare(account: AuthAccount) {\n        self.finLeases= account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)\n    }\n\n    pre{\n        self.finLeases != nil : \"Cannot borrow reference to find lease collection\"\n    }\n\n    execute{\n        self.finLeases!.startAuction(name)\n    }\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "storeCuratedCollections": {
               "code": "transaction(collections: {String :  [String]}) {\n    prepare(account: AuthAccount) {\n\n        let path=/storage/FindCuratedCollections\n        let publicPath=/public/FindCuratedCollections\n\n        if account.borrow\u003c\u0026{String: [String]}\u003e(from:path) != nil {\n             account.load\u003c{String: [String]}\u003e(from:path)\n        }\n        account.save(collections, to: path)\n\n        let link = account.getCapability\u003c\u0026{String: [String]}\u003e(publicPath)\n        if !link.check() {\n            account.link\u003c\u0026{String: [String]}\u003e( publicPath, target: path)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "collections"
                  ],
                  "parameters": {
                     "collections": "{String: [String]}"
                  }
               }
            }
         }
      },
      "testnet": {
         "scripts": {
            "getCatalog": {
               "code": "import NFTCatalog from 0x324c34e1c517e4db\nimport FINDNFTCatalog from 0x35717efbbce11c74\n\npub fun main() : {String : NFTCatalog.NFTCatalogMetadata} {\n    return FINDNFTCatalog.getCatalog() \n}",
               "spec": {
                  "order": [],
                  "parameters": {}
               }
            },
            "getCatalogCollectionDisplay": {
               "code": "import MetadataViews from 0x631e88ae7f1d7c20\nimport NFTCatalog from 0x324c34e1c517e4db\nimport FINDNFTCatalog from 0x35717efbbce11c74\n\npub fun main(collectionIdentifier : String) : NFTCatalogMetadata? {\n    if let catalog = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier) {\n        return NFTCatalogMetadata(\n            contractName : catalog.contractName, \n            contractAddress : catalog.contractAddress, \n            nftType: catalog.nftType, \n            collectionDisplay : catalog.collectionDisplay\n        )\n    }\n    return nil\n}\n\npub struct NFTCatalogMetadata {\n    pub let contractName : String\n    pub let contractAddress : Address\n    pub let nftType: String\n    pub let collectionDisplay: MetadataViews.NFTCollectionDisplay\n\n    init (contractName : String, contractAddress : Address, nftType: Type, collectionDisplay : MetadataViews.NFTCollectionDisplay) {\n        self.contractName = contractName\n        self.contractAddress = contractAddress\n        self.nftType = nftType.identifier\n        self.collectionDisplay = collectionDisplay\n    }\n}",
               "spec": {
                  "order": [
                     "collectionIdentifier"
                  ],
                  "parameters": {
                     "collectionIdentifier": "String"
                  }
               }
            },
            "getCatalogEntry": {
               "code": "import NFTCatalog from 0x324c34e1c517e4db\nimport FINDNFTCatalog from 0x35717efbbce11c74\n\npub fun main(collectionIdentifier : String) : NFTCatalog.NFTCatalogMetadata? {\n    return FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier) \n}",
               "spec": {
                  "order": [
                     "collectionIdentifier"
                  ],
                  "parameters": {
                     "collectionIdentifier": "String"
                  }
               }
            },
            "getCatalogTypeData": {
               "code": "import NFTCatalog from 0x324c34e1c517e4db\nimport FINDNFTCatalog from 0x35717efbbce11c74\n\npub fun main() : {String : {String : Bool}} {\n    return FINDNFTCatalog.getCatalogTypeData() \n}",
               "spec": {
                  "order": [],
                  "parameters": {}
               }
            },
            "getCheckRoyalty": {
               "code": "import MetadataViews from 0x631e88ae7f1d7c20\nimport FIND from 0x35717efbbce11c74\nimport FINDNFTCatalog from 0x35717efbbce11c74\n\npub fun main(name: String, id: UInt64, nftAliasOrIdentifier: String, viewIdentifier: String) : AnyStruct? {\n\n    let address =FIND.resolve(name)!\n\n    // Get collection public path from NFT Registry\n    let collectionPublicPath = getPublicPath(nftAliasOrIdentifier)\n    let collection= getAuthAccount(address).borrow\u003c\u0026{MetadataViews.ResolverCollection}\u003e(from: collectionPublicPath)!\n\n    // let nft=collection.borrowViewResolver(id: id)\n    let nft=collection.borrowViewResolver(id: collection.getIDs()[0])\n    for v in nft.getViews() {\n        if v.identifier== viewIdentifier {\n            return nft.resolveView(v)\n        }\n    }\n    return nil\n}\n\npub fun getPublicPath(_ nftIdentifier: String) : StoragePath {\n    let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier)) \n    let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n    return collection.collectionData.storagePath\n}",
               "spec": {
                  "order": [
                     "name",
                     "id",
                     "nftAliasOrIdentifier",
                     "viewIdentifier"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "name": "String",
                     "nftAliasOrIdentifier": "String",
                     "viewIdentifier": "String"
                  }
               }
            },
            "getCollectionForType": {
               "code": "import NFTCatalog from 0x324c34e1c517e4db\nimport FINDNFTCatalog from 0x35717efbbce11c74\n\npub fun main(nftTypeIdentifier : String) : {String : Bool}? {\n    return FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftTypeIdentifier)\n}",
               "spec": {
                  "order": [
                     "nftTypeIdentifier"
                  ],
                  "parameters": {
                     "nftTypeIdentifier": "String"
                  }
               }
            },
            "getCollectionIndex": {
               "code": "import MetadataViews from 0x631e88ae7f1d7c20\nimport FINDNFTCatalog from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\n\npub fun main(user: String) : {String : [UInt64]} {\n\n    if let address = FIND.resolve(user) {\n        var resultMap : {String : [UInt64]} = {}\n        let account = getAccount(address)\n        for nftInfo in FINDNFTCatalog.getCatalog().values {\n            let publicPath = nftInfo.collectionData.publicPath\n\n            if let subCollections = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftInfo.nftType.identifier) {\n                if subCollections.length \u003c 1 {\n                    continue\n                } else if subCollections.length == 1 {\n                    let collection = nftInfo.nftType.identifier\n                    let resolverCollectionCap= account.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(publicPath)\n                    if resolverCollectionCap.check() {\n                        let collection = resolverCollectionCap.borrow()!\n                        resultMap[nftInfo.collectionDisplay.name] = collection.getIDs()\n                    }\n                } else {\n                    let collection = nftInfo.nftType.identifier\n                    let resolverCollectionCap= account.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(publicPath)\n\n                    let array : [UInt64] = []\n                    if resolverCollectionCap.check() {\n                        let collection = resolverCollectionCap.borrow()!\n                        for id in collection.getIDs() {\n                            let vr = collection.borrowViewResolver(id: id)\n                            if let sc = vr.resolveView(Type\u003cMetadataViews.NFTCollectionDisplay\u003e()) {\n                                let scv = sc as! MetadataViews.NFTCollectionDisplay\n                                if scv.name == nftInfo.collectionDisplay.name {\n                                    array.append(id)\n                                }\n                            }\n                        }\n                    }\n                    resultMap[nftInfo.collectionDisplay.name] = array\n                }\n            } \n\n        }\n\n        return resultMap\n    }\n    return {}\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "getCuratedCollections": {
               "code": "pub fun main(address: Address) : \u0026{String: [String]}? {\n    let account=getAccount(address)\n\n    if account.balance == 0.0 {\n        return nil\n    }\n\n    let publicPath=/public/FindCuratedCollections\n    let link = account.getCapability\u003c\u0026{String: [String]}\u003e(publicPath)\n    if link.check() {\n        return link.borrow()\n    }\n    return nil\n}",
               "spec": {
                  "order": [
                     "address"
                  ],
                  "parameters": {
                     "address": "Address"
                  }
               }
            },
            "getDandiesIDsFor": {
               "code": "import Dandy from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\n\npub fun main(user: String, minter: String) : [UInt64] {\n    let address = FIND.resolve(user)\n    if address == nil {\n        return []\n    }\n    let account = getAccount(address!)\n    if account.balance == 0.0 {\n        return []\n    }\n    let cap = account.getCapability\u003c\u0026Dandy.Collection{Dandy.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n    let ref = cap.borrow() ?? panic(\"Cannot borrow reference to Dandy Collection. Account address : \".concat(address!.toString()))\n\n    return ref.getIDsFor(minter: minter)\n}",
               "spec": {
                  "order": [
                     "user",
                     "minter"
                  ],
                  "parameters": {
                     "minter": "String",
                     "user": "String"
                  }
               }
            },
            "getDandiesMinters": {
               "code": "import Dandy from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\n\npub fun main(user: String) : [String] {\n    let address = FIND.resolve(user)\n    if address == nil {\n        return []\n    }\n    let account = getAccount(address!)\n    if account.balance == 0.0 {\n        return []\n    }\n    let cap = account.getCapability\u003c\u0026Dandy.Collection{Dandy.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n    let ref = cap.borrow() ?? panic(\"Cannot borrow reference to Dandy Collection. Account address : \".concat(address!.toString()))\n\n    return ref.getMinters()\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "getFTInfo": {
               "code": "import FTRegistry from 0x35717efbbce11c74\n\npub fun main(aliasOrIdentifier: String) : FTRegistry.FTInfo?{\n\n    return FTRegistry.getFTInfo(aliasOrIdentifier)\n\n}",
               "spec": {
                  "order": [
                     "aliasOrIdentifier"
                  ],
                  "parameters": {
                     "aliasOrIdentifier": "String"
                  }
               }
            },
            "getFTInfoAll": {
               "code": "import FTRegistry from 0x35717efbbce11c74\n\npub fun main() : {String: FTRegistry.FTInfo}{\n\n    return FTRegistry.getFTInfoAll()\n\n}",
               "spec": {
                  "order": [],
                  "parameters": {}
               }
            },
            "getItem": {
               "code": "import MetadataViews from 0x631e88ae7f1d7c20\nimport FIND from 0x35717efbbce11c74\nimport FINDNFTCatalog from 0x35717efbbce11c74\n\npub struct MetadataCollectionItem {\n    pub let id:UInt64\n    pub let uuid:UInt64\n    pub let name: String\n    pub let description: String?\n    pub let image: String\n    pub let url: String\n    pub let contentType:String\n    pub let rarity:String\n    pub let minter:String?\n    pub let type:Type\n\n\n    init(id:UInt64, uuid:UInt64, name:String, description:String?, image:String, url:String, contentType: String, rarity: String, minter:String?, type:Type) {\n        self.id=id\n        self.uuid=uuid\n        self.name=name\n        self.description=description\n        self.minter=minter\n        self.url=url\n        self.type=type\n        self.image=image\n        self.contentType=contentType\n        self.rarity=rarity\n    }\n}\n\n\npub fun main(user: String, aliasOrIdentifier: String, id:UInt64) : MetadataCollectionItem?{\n\n    let publicPath = getPublicPath(aliasOrIdentifier)\n\n    let resolveAddress = FIND.resolve(user) \n    if resolveAddress == nil {return nil}\n    let address = resolveAddress!\n    let account=getAccount(address)\n    if account.balance == 0.0 {\n        return nil\n    }\n    let resolverCollectionCap= account.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(publicPath)\n    if !resolverCollectionCap.check() {\n        return nil\n    }\n\n    let collection = resolverCollectionCap.borrow()!\n    let nft = collection.borrowViewResolver(id: id)!\n\n    if let displayView = nft.resolveView(Type\u003cMetadataViews.Display\u003e()) {\n        let display = displayView as! MetadataViews.Display\n\n        var externalUrl=\"\"\n        if let externalUrlView = nft.resolveView(Type\u003cMetadataViews.ExternalURL\u003e()) {\n            let edvu= externalUrlView as! MetadataViews.ExternalURL\n            externalUrl=edvu.url\n        }\n        let item = MetadataCollectionItem(\n            id: id,\n            uuid: nft.uuid,\n            name: display.name,\n            description:display.description,\n            image: display.thumbnail.uri(),\n            url: externalUrl,\n            contentType: \"image\",\n            rarity: \"\",\n            minter: \"\",\n            type: nft.getType()\n        )\n        return item\n    }\n    return nil\n}\n\npub fun getPublicPath(_ nftIdentifier: String) : PublicPath {\n    let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier)) \n    let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n    return collection.collectionData.publicPath\n}",
               "spec": {
                  "order": [
                     "user",
                     "aliasOrIdentifier",
                     "id"
                  ],
                  "parameters": {
                     "aliasOrIdentifier": "String",
                     "id": "UInt64",
                     "user": "String"
                  }
               }
            },
            "getLeases": {
               "code": "import FIND from 0x35717efbbce11c74\n\npub fun main() : [FIND.NetworkLease] {\n    return FIND.getLeases()\n}",
               "spec": {
                  "order": [],
                  "parameters": {}
               }
            },
            "getListings": {
               "code": "import FindMarket from 0x35717efbbce11c74 \nimport FIND from 0x35717efbbce11c74 \n\npub fun main(marketplace:Address, user: String) : {String : FindMarket.SaleItemCollectionReport} {\n    let resolveAddress = FIND.resolve(user)\n    if resolveAddress == nil { return {}}\n    let address = resolveAddress!\n        return FindMarket.getSaleItemReport(tenant:marketplace, address: address, getNFTInfo:false)\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "user"
                  ],
                  "parameters": {
                     "marketplace": "Address",
                     "user": "String"
                  }
               }
            },
            "getLostAndFoundNFTs": {
               "code": "import LostAndFoundHelper from 0xbe4635353f55bbd4\nimport FindLostAndFoundWrapper from 0x82836e61c008d6d1\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport FIND from 0x35717efbbce11c74\nimport FINDNFTCatalog from 0x35717efbbce11c74\n\npub fun main(user: String) : Report {\n\n    if let address = FIND.resolve(user) {\n        let runTimeType = Type\u003c@NonFungibleToken.NFT\u003e()\n\n        let ticketsInfo = FindLostAndFoundWrapper.getTickets(user: address, specificType: runTimeType)\n\n        let ticketIds : {String : [UInt64]} = {}\n        let NFTCatalogTicketInfo : {String : [LostAndFoundHelper.Ticket]} = {}\n        for type in ticketsInfo.keys {\n            // check if this type is in NFTCatalog\n            let nftCatalog = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: type)\n            var inNFTCatalog : Bool = true \n            if nftCatalog == nil {\n                inNFTCatalog = false\n            }\n\n            // append id in array\n            let id : [UInt64] = []\n            for ticket in ticketsInfo[type]! {\n                if ticket.ticketID != nil {\n                    id.append(ticket.ticketID!)\n                }\n            }\n            ticketIds[type] = id\n\n            // If it is in NFT Catalog, add it in NFTCatalogTicketInfo\n            if inNFTCatalog {\n                NFTCatalogTicketInfo[type] = ticketsInfo.remove(key: type)\n            }\n        }\n\n        return Report(nftCatalogTicketInfo : NFTCatalogTicketInfo, ticketInfo : ticketsInfo, ticketIds : ticketIds, error: nil)\n    }\n    return logErr(\"Cannot resolve user. User : \".concat(user))\n}\n\n\npub struct Report {\n\n    pub let nftCatalogTicketInfo : {String : [LostAndFoundHelper.Ticket]}\n    pub let ticketInfo : {String : [LostAndFoundHelper.Ticket]}\n    pub let ticketIds : {String : [UInt64]}\n    pub let error : String?\n\n    init(nftCatalogTicketInfo : {String : [LostAndFoundHelper.Ticket]}, ticketInfo : {String : [LostAndFoundHelper.Ticket]}, ticketIds : {String : [UInt64]}, error: String?) {\n        self.nftCatalogTicketInfo = nftCatalogTicketInfo\n        self.ticketInfo = ticketInfo\n        self.ticketIds = ticketIds\n        self.error = error\n    }\n}\n\npub fun logErr(_ err: String) : Report {\n    return Report(nftCatalogTicketInfo: {}, ticketInfo : {}, ticketIds : {} , error: err)\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "getLostAndFoundRedeemableNFTTypes": {
               "code": "import FindLostAndFoundWrapper from 0x82836e61c008d6d1\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport FIND from 0x35717efbbce11c74\n\npub fun main(user: String) : Report {\n\n    if let address = FIND.resolve(user){\n        let type : Type = Type\u003c@NonFungibleToken.NFT\u003e()\n        return Report(nftTypes: typeToStringArray(FindLostAndFoundWrapper.getSpecificRedeemableTypes(user: address, specificType: type)), err: nil)\n    }\n    return logErr(\"cannot resolve user\")\n\n}\n\npub fun typeToStringArray(_ array: [Type]) : [String] {\n    let res : [String] = []\n    for type in array {\n        res.append(type.identifier)\n    }\n    return res\n}\n\npub struct Report {\n    pub let nftTypes : [String]\n    pub let err : String? \n\n    init(nftTypes : [String] , err : String? ) {\n        self.nftTypes = nftTypes\n        self.err = err\n    }\n}\n\npub fun logErr(_ err: String) : Report{\n    return Report(nftTypes: [], err: err)\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "getLostAndFoundRequiredStorageType": {
               "code": "import FindLostAndFoundWrapper from 0x82836e61c008d6d1\nimport FINDNFTCatalog from 0x35717efbbce11c74\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FIND from 0x35717efbbce11c74\n\npub fun main(user: String) : Report {\n\n    if let address = FIND.resolve(user){\n        let runTimeType : Type = Type\u003c@NonFungibleToken.NFT\u003e()\n\n        let types = FindLostAndFoundWrapper.getSpecificRedeemableTypes(user: address, specificType: runTimeType)\n\n        let account = getAuthAccount(address)\n\n        let initiableStorage : [String] = []\n        let relinkableStorage : [String] = []\n        let initiatedStorage : [String] = []\n        let problematicStorage : [String] = []\n        let notSupportedType : [String] = []\n        for type in types {\n\n            let nftInfo = FINDNFTCatalog.getCollectionDataForType(nftTypeIdentifier: type.identifier)\n\n            if nftInfo == nil {\n                initiableStorage.append(type.identifier)\n                continue\n            }\n\n            let storageType = account.type(at: nftInfo!.storagePath)\n            if storageType == nil {\n                initiableStorage.append(type.identifier)\n                continue\n            } \n            \n            let storageTypeIdentifier = storageType!.identifier.slice(from: 0 , upTo: storageType!.identifier.length - \".Collection\".length)\n            let typeIdentifier = type.identifier.slice(from: 0 , upTo: type.identifier.length - \".NFT\".length)\n            if storageTypeIdentifier != typeIdentifier {\n                problematicStorage.append(type.identifier)\n            } else {\n\n                // check if relink needed\n                if account.getCapability\u003c\u0026{NonFungibleToken.Receiver, NonFungibleToken.CollectionPublic, MetadataViews.ResolverCollection}\u003e(nftInfo!.publicPath).check() {\n                    initiatedStorage.append(type.identifier)\n                } else {\n                    relinkableStorage.append(type.identifier)\n                }\n\n            }\n        }\n        return Report(initiableStorage: initiableStorage, relinkableStorage: relinkableStorage ,initiatedStorage: initiatedStorage, problematicStorage: problematicStorage, notSupportedType: notSupportedType, err: nil)\n    }\n    return logErr(\"cannot resolve user\")\n\n}\n\npub struct Report {\n\n    pub let initiableStorage : [String] \n    pub let relinkableStorage : [String]\n    pub let initiatedStorage : [String] \n    pub let problematicStorage : [String] \n    pub let notSupportedType : [String] \n\n    pub let err : String? \n\n    init(initiableStorage : [String] , relinkableStorage : [String] , initiatedStorage : [String], problematicStorage : [String] , notSupportedType : [String] , err : String? ) {\n        self.initiableStorage = initiableStorage\n        self.relinkableStorage = relinkableStorage\n        self.initiatedStorage = initiatedStorage\n        self.problematicStorage = problematicStorage\n        self.notSupportedType = notSupportedType\n        self.err = err\n    }\n\n}\n\npub fun logErr(_ err: String) : Report {\n    return Report(initiableStorage: [] , relinkableStorage : [] , initiatedStorage : [] , problematicStorage: [], notSupportedType: [], err: err)\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "getMarketBlockedNFT": {
               "code": "import FindMarket from 0x35717efbbce11c74 \n\npub fun main() : {String : [String] } {\n    let mapping : {String : [String] } = {}\n\n    let findAddress=FindMarket.getFindTenantAddress()\n    let tenantCap = FindMarket.getTenantCapability(findAddress)!\n    let tenantRef = tenantCap.borrow() ?? panic(\"This tenant is not set up. Tenant : \".concat(tenantCap.address.toString()))\n    let marketTypes = FindMarket.getSaleItemTypes()\n    for marketType in marketTypes {\n        let list : [String] = []\n        for type in tenantRef.getBlockedNFT(marketType: marketType) {\n            list.append(type.identifier)\n        }\n        mapping[FindMarket.getMarketOptionFromType(marketType)] = list\n    }\n\nreturn mapping\n}",
               "spec": {
                  "order": [],
                  "parameters": {}
               }
            },
            "getMetadataForSaleItem": {
               "code": "import FindMarketSale from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\n\npub struct PurchaseData {\n    pub let id: UInt64\n    pub let name: String\n    pub let amount: UFix64\n    pub let description: String\n    pub let imageURL: String\n\n    init(id: UInt64, name: String, amount: UFix64, description: String, imageURL: String) {\n        self.id = id\n        self.name = name\n        self.amount = amount\n        self.description = description\n        self.imageURL = imageURL\n    }\n}\npub fun main(merchantAddress: Address, marketplace:Address, address: Address, id: UInt64, amount: UFix64) : PurchaseData{\n    let saleItemsCap= FindMarketSale.getSaleItemCapability(marketplace: marketplace, user:address) ?? panic(\"cannot find sale item cap\")\n    let saleItemCollection = saleItemsCap.borrow()!\n    let item = saleItemCollection.borrowSaleItem(id)\n\n    let display = item.getDisplay()\n\n    var thumbnail = replacePrefix(display.thumbnail.uri(), prefix: \"ipfs://\", replace:\"https://nftstorage.link/ipfs/\")\n    return PurchaseData(\n        id: id, \n        name: display.name, \n        amount: amount,\n        description: display.description, \n        imageURL: thumbnail\n    )\n}\n\npub fun replacePrefix(_ original: String, prefix:String, replace:String) : String {\n    if original.length \u003c prefix.length  {\n        return original\n    }\n    let oprefix = original.slice(from:0, upTo:prefix.length)\n    if oprefix != prefix {\n        return original\n    }\n    let rest = original.slice(from:prefix.length, upTo: original.length)\n    return replace.concat(rest)\n}",
               "spec": {
                  "order": [
                     "merchantAddress",
                     "marketplace",
                     "address",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "address": "Address",
                     "amount": "UFix64",
                     "id": "UInt64",
                     "marketplace": "Address",
                     "merchantAddress": "Address"
                  }
               }
            },
            "getNFTCatalogIDs": {
               "code": "import MetadataViews from 0x631e88ae7f1d7c20\nimport FIND from 0x35717efbbce11c74\nimport FINDNFTCatalog from 0x35717efbbce11c74\n\npub fun main(user: String, collections: [String]) : {String : ItemReport} {\n    return fetchNFTCatalog(user: user, targetCollections:collections)\n}\n\npub struct ItemReport {\n    pub let length : Int // mapping of collection to no. of ids \n    pub let extraIDs : [UInt64]\n    pub let shard : String \n    pub let extraIDsIdentifier : String \n\n    init(length : Int, extraIDs :[UInt64] , shard: String, extraIDsIdentifier: String) {\n        self.length=length \n        self.extraIDs=extraIDs\n        self.shard=shard\n        self.extraIDsIdentifier=extraIDsIdentifier\n    }\n}\n\n    pub struct NFTView {\n        pub let id: UInt64\n        pub let display: MetadataViews.Display?\n        pub let editions: MetadataViews.Editions?\n        pub let collectionDisplay: MetadataViews.NFTCollectionDisplay?\n        pub let nftType: Type\n\n        init(\n            id : UInt64,\n            display : MetadataViews.Display?,\n            editions : MetadataViews.Editions?,\n            collectionDisplay: MetadataViews.NFTCollectionDisplay?,\n            nftType: Type\n        ) {\n            self.id = id\n            self.display = display\n            self.editions = editions\n            self.collectionDisplay = collectionDisplay\n            self.nftType = nftType\n        }\n    }\n\n// Helper function \n\npub fun resolveAddress(user: String) : Address? {\n    return FIND.resolve(user)\n}\n\npub fun getNFTIDs(ownerAddress: Address) : {String:[UInt64]} {\n\n    let account = getAuthAccount(ownerAddress)\n\n    if account.balance == 0.0 {\n        return {}\n    }\n\n    let inventory : {String:[UInt64]}={}\n    let types = FINDNFTCatalog.getCatalogTypeData()\n    for nftType in types.keys {\n\n        let typeData=types[nftType]!\n        let collectionKey=typeData.keys[0]\n        let catalogEntry = FINDNFTCatalog.getCatalogEntry(collectionIdentifier:collectionKey)!\n        let storagePath = catalogEntry.collectionData.storagePath\n        let ref= account.borrow\u003c\u0026{MetadataViews.ResolverCollection}\u003e(from: storagePath)\n        if ref != nil {\n            inventory[collectionKey] = ref!.getIDs()\n        }\n\n    }\n    return inventory\n}\n\npub fun fetchNFTCatalog(user: String, targetCollections: [String]) : {String : ItemReport} {\n    let source = \"NFTCatalog\"\n    let account = resolveAddress(user: user)\n    if account == nil { return {} }\n\n\n    let extraIDs = getNFTIDs(ownerAddress: account!)\n    let inventory : {String : ItemReport} = {}\n    var fetchedCount : Int = 0\n\n    for project in extraIDs.keys {\n\n        let catalogEntry = FINDNFTCatalog.getCatalogEntry(collectionIdentifier:project)!\n        let projectName = catalogEntry.contractName\n\n        if extraIDs[project]! == nil || extraIDs[project]!.length \u003c 1{\n            extraIDs.remove(key: project)\n            continue\n        }\n        \n        let collectionLength = extraIDs[project]!.length\n\n        // by pass if this is not the target collection\n        if targetCollections.length \u003e 0 \u0026\u0026 !targetCollections.contains(project) {\n            // inventory[project] = ItemReport(length : collectionLength, extraIDs :extraIDs[project]! , shard: source)\n            continue\n        }\n\n        inventory[catalogEntry.contractName] = ItemReport(length : collectionLength, extraIDs :extraIDs[project] ?? [] , shard: source, extraIDsIdentifier: project)\n\n    }\n\n    return inventory\n\n}",
               "spec": {
                  "order": [
                     "user",
                     "collections"
                  ],
                  "parameters": {
                     "collections": "[String]",
                     "user": "String"
                  }
               }
            },
            "getNFTCatalogItems": {
               "code": "import MetadataViews from 0x631e88ae7f1d7c20\nimport FIND from 0x35717efbbce11c74\n\nimport FINDNFTCatalog from 0x35717efbbce11c74\n\npub fun main(user: String, collectionIDs: {String : [UInt64]}) : {String : [MetadataCollectionItem]} {\n    return fetchNFTCatalog(user: user, collectionIDs: collectionIDs)\n}\n\npub struct NFTView {\n    pub let id: UInt64\n    pub let display: MetadataViews.Display?\n    pub let editions: MetadataViews.Editions?\n    pub let collectionDisplay: MetadataViews.NFTCollectionDisplay?\n    pub let nftType: Type\n\n    init(\n        id : UInt64,\n        display : MetadataViews.Display?,\n        editions : MetadataViews.Editions?,\n        collectionDisplay: MetadataViews.NFTCollectionDisplay?,\n        nftType: Type\n    ) {\n        self.id = id\n        self.display = display\n        self.editions = editions\n        self.collectionDisplay = collectionDisplay\n        self.nftType = nftType\n    }\n}\n\npub fun getNFTs(ownerAddress: Address, ids: {String : [UInt64]}) : [NFTView] {\n\n    let account = getAuthAccount(ownerAddress)\n\n    if account.balance == 0.0 {\n        return []\n    }\n\n    let results : [NFTView] = []\n    for collectionKey in ids.keys {\n        let catalogEntry = FINDNFTCatalog.getCatalogEntry(collectionIdentifier:collectionKey)!\n        let storagePath = catalogEntry.collectionData.storagePath\n        let ref= account.borrow\u003c\u0026{MetadataViews.ResolverCollection}\u003e(from: storagePath)\n        if ref != nil{\n            for id in ids[collectionKey]! {\n                // results.append(MetadataViews.getNFTView(id:id, viewResolver: ref!.borrowViewResolver(id:id)!))\n                let viewResolver = ref!.borrowViewResolver(id:id)!\n                results.append(\n                    NFTView(\n                        id : id,\n                        display: MetadataViews.getDisplay(viewResolver),\n                        editions : MetadataViews.getEditions(viewResolver),\n                        collectionDisplay : MetadataViews.getNFTCollectionDisplay(viewResolver),\n                        nftType : viewResolver.getType()\n                    )\n                )\n            }\n        }\n    }\n    return results\n}\n\npub struct CollectionReport {\n    pub let items : {String : [MetadataCollectionItem]} \n    pub let collections : {String : Int} // mapping of collection to no. of ids \n    pub let extraIDs : {String : [UInt64]} \n\n    init(items: {String : [MetadataCollectionItem]},  collections : {String : Int}, extraIDs : {String : [UInt64]} ) {\n        self.items=items \n        self.collections=collections \n        self.extraIDs=extraIDs\n    }\n}\n\npub struct MetadataCollectionItem {\n    pub let id:UInt64\n    pub let name: String\n    pub let collection: String // \u003c- This will be Alias unless they want something else\n    pub let subCollection: String? // \u003c- This will be Alias unless they want something else\n    pub let nftDetailIdentifier: String\n\n    pub let media  : String\n    pub let mediaType : String \n    pub let source : String \n\n    init(id:UInt64, name: String, collection: String, subCollection: String?, media  : String, mediaType : String, source : String, nftDetailIdentifier: String) {\n        self.id=id\n        self.name=name \n        self.collection=collection \n        self.subCollection=subCollection \n        self.media=media \n        self.mediaType=mediaType \n        self.source=source\n        self.nftDetailIdentifier=nftDetailIdentifier\n    }\n}\n\n// Helper function \n\npub fun resolveAddress(user: String) : PublicAccount? {\n    let address = FIND.resolve(user)\n    if address == nil {\n        return nil\n    }\n    return getAccount(address!)\n}\n\n\n//////////////////////////////////////////////////////////////\n// Fetch Specific Collections in Shard 1\n//////////////////////////////////////////////////////////////\npub fun fetchNFTCatalog(user: String, collectionIDs: {String : [UInt64]}) : {String : [MetadataCollectionItem]} {\n    let source = \"NFTCatalog\"\n    let account = resolveAddress(user: user)\n    if account == nil { return {} }\n\n    let items : {String : [MetadataCollectionItem]} = {}\n\n    let fetchingIDs = collectionIDs\n\n\n    for project in fetchingIDs.keys {\n\n        let catalogEntry = FINDNFTCatalog.getCatalogEntry(collectionIdentifier:project)!\n        let projectName = catalogEntry.contractName\n\n        let returnedNFTs = getNFTs(ownerAddress: account!.address, ids: {project : fetchingIDs[project]!})\n\n        var collectionItems : [MetadataCollectionItem] = []\n        for nft in returnedNFTs {\n            if nft == nil {\n                continue\n            }\n\n            var subCollection = \"\"\n            if project != nft!.collectionDisplay!.name {\n             subCollection = nft!.collectionDisplay!.name\n            }\n\n            var name = nft!.display!.name \n            if name == \"\" {\n                name = projectName\n            }\n\n            if nft.editions != nil \u0026\u0026 nft.editions!.infoList.length \u003e 0 {\n                let edition = nft.editions!.infoList[0].number.toString()\n                // check if the name ends with \"editionNumber\"\n                // If the name ends with \"editionNumber\", we do not concat the edition\n                if name.length \u003e edition.length \u0026\u0026 name.slice(from: name.length - edition.length, upTo: name.length) != edition {\n                    name = name.concat(\"#\").concat(nft.editions!.infoList[0].number.toString())\n                }\n            }\n            \n            let item = MetadataCollectionItem(\n                id: nft!.id,\n                name: name,\n                collection: project,\n                subCollection: subCollection, \n                media: nft!.display!.thumbnail.uri(),\n                mediaType: \"image/png\",\n                source: source, \n                nftDetailIdentifier: nft!.nftType.identifier\n            )\n            collectionItems.append(item)\n        }\n\n        if collectionItems.length \u003e 0 {\n            items[project] = collectionItems\n        }\n    }\n    return items\n}",
               "spec": {
                  "order": [
                     "user",
                     "collectionIDs"
                  ],
                  "parameters": {
                     "collectionIDs": "{String: [UInt64]}",
                     "user": "String"
                  }
               }
            },
            "getNFTCatalogItemsWithMetadata": {
               "code": "import MetadataViews from 0x631e88ae7f1d7c20\nimport FIND from 0x35717efbbce11c74\n\nimport FINDNFTCatalog from 0x35717efbbce11c74\n\npub fun main(user: String, collectionIDs: {String : [UInt64]}) : {String : [MetadataCollectionItem]} {\n    return fetchNFTCatalog(user: user, collectionIDs: collectionIDs)\n}\n\npub struct NFTView {\n    pub let id: UInt64\n    pub let display: MetadataViews.Display?\n    pub let collectionDisplay: MetadataViews.NFTCollectionDisplay?\n    pub var rarity:MetadataViews.Rarity?\n    pub var editions: MetadataViews.Editions?\n    pub var serial: UInt64?\n    pub var traits: MetadataViews.Traits?\n    pub let nftType: Type\n\n    init(\n        id : UInt64,\n        display : MetadataViews.Display?,\n        editions : MetadataViews.Editions?,\n        rarity:MetadataViews.Rarity?,\n        serial: UInt64?,\n        traits: MetadataViews.Traits?,\n        collectionDisplay: MetadataViews.NFTCollectionDisplay?,\n        nftType: Type\n    ) {\n        self.id = id\n        self.display = display\n        self.editions = editions\n        self.rarity = rarity\n        self.serial = serial\n        self.traits = traits\n        self.collectionDisplay = collectionDisplay\n        self.nftType = nftType\n    }\n}\n\npub fun getNFTs(ownerAddress: Address, ids: {String : [UInt64]}) : [NFTView] {\n\n    let account = getAuthAccount(ownerAddress)\n\n    if account.balance == 0.0 {\n        return []\n    }\n\n    let results : [NFTView] = []\n    for collectionKey in ids.keys {\n        let catalogEntry = FINDNFTCatalog.getCatalogEntry(collectionIdentifier:collectionKey)!\n        let storagePath = catalogEntry.collectionData.storagePath\n        let ref= account.borrow\u003c\u0026{MetadataViews.ResolverCollection}\u003e(from: storagePath)\n        if ref != nil{\n            for id in ids[collectionKey]! {\n                // results.append(MetadataViews.getNFTView(id:id, viewResolver: ref!.borrowViewResolver(id:id)!))\n                let viewResolver = ref!.borrowViewResolver(id:id)!\n\n                var traitsStruct : MetadataViews.Traits? = nil \n\n                if let traits = MetadataViews.getTraits(viewResolver) {\n                    if let trait = getTrait(viewResolver) {\n                        var check = false \n                        for item in traits.traits {\n                            if item.name == trait.name {\n                                check = true \n                                break\n                            }\n                            if !check {\n                                let array = traits.traits\n                                array.append(trait)\n\n                                traitsStruct = cleanUpTraits(array)\n                            }\n                        }\n                    } else {\n                        traitsStruct = cleanUpTraits(traits.traits)\n                    }\n                } else {\n                    if let trait = getTrait(viewResolver) {\n                        traitsStruct = cleanUpTraits([trait])\n                    }\n                }\n\n                var editionStruct : MetadataViews.Editions? = nil \n\n                if let editions = MetadataViews.getEditions(viewResolver) {\n                    if let edition = getEdition(viewResolver) {\n                        var check = false\n                        for item in editions.infoList {\n                            if item.name == edition.name \u0026\u0026 item.number == edition.number \u0026\u0026 item.max == edition.max {\n                                check = true\n                                break\n                            }\n                        }\n                        // If the edition does not exist in editions, add it in\n                        if !check {\n                            let array = editions.infoList \n                            array.append(edition)\n                            editionStruct = MetadataViews.Editions(array)\n                        }\n                    } else {\n                    // If edition does not exist OR edition is already in editions , append it to views and continue\n                        editionStruct = editions\n                    }\n                } else if let edition = getEdition(viewResolver) {\n                        editionStruct = MetadataViews.Editions([edition])\n                }\n\n                results.append(\n                    NFTView(\n                        id : id,\n                        display: MetadataViews.getDisplay(viewResolver),\n                        editions : editionStruct,\n                        rarity : MetadataViews.getRarity(viewResolver),\n                        serial :  MetadataViews.getSerial(viewResolver)?.number,\n                        traits : traitsStruct,\n                        collectionDisplay : MetadataViews.getNFTCollectionDisplay(viewResolver),\n                        nftType : viewResolver.getType()\n                    )\n                )\n            }\n        }\n    }\n    return results\n}\n\npub struct CollectionReport {\n    pub let items : {String : [MetadataCollectionItem]} \n    pub let collections : {String : Int} // mapping of collection to no. of ids \n    pub let extraIDs : {String : [UInt64]} \n\n    init(items: {String : [MetadataCollectionItem]},  collections : {String : Int}, extraIDs : {String : [UInt64]} ) {\n        self.items=items \n        self.collections=collections \n        self.extraIDs=extraIDs\n    }\n}\n\npub struct MetadataCollectionItem {\n    pub let id:UInt64\n    pub let name: String\n    pub let collection: String // \u003c- This will be Alias unless they want something else\n    pub let subCollection: String? // \u003c- This will be Alias unless they want something else\n    pub let nftDetailIdentifier: String\n\n    pub let media  : String\n    pub let mediaType : String \n    pub let source : String \n\n    pub var rarity:MetadataViews.Rarity?\n    pub var editions: MetadataViews.Editions?\n    pub var serial: UInt64?\n    pub var traits: MetadataViews.Traits?\n\n    init(id:UInt64, \n         name: String, \n         collection: String, \n         subCollection: String?, \n         media  : String, \n         mediaType : String, \n         source : String, \n         nftDetailIdentifier: String, \n         editions : MetadataViews.Editions?,\n         rarity:MetadataViews.Rarity?,\n         serial: UInt64?,\n         traits: MetadataViews.Traits?,\n         ) {\n        self.id=id\n        self.name=name \n        self.collection=collection \n        self.subCollection=subCollection \n        self.media=media \n        self.mediaType=mediaType \n        self.source=source\n        self.nftDetailIdentifier=nftDetailIdentifier\n        self.editions=editions\n        self.rarity=rarity\n        self.serial=serial\n        self.traits=traits\n    }\n}\n\n// Helper function \n\npub fun resolveAddress(user: String) : PublicAccount? {\n    let address = FIND.resolve(user)\n    if address == nil {\n        return nil\n    }\n    return getAccount(address!)\n}\n\n\n//////////////////////////////////////////////////////////////\n// Fetch Specific Collections in Shard 1\n//////////////////////////////////////////////////////////////\npub fun fetchNFTCatalog(user: String, collectionIDs: {String : [UInt64]}) : {String : [MetadataCollectionItem]} {\n    let source = \"NFTCatalog\"\n    let account = resolveAddress(user: user)\n    if account == nil { return {} }\n\n    let items : {String : [MetadataCollectionItem]} = {}\n\n    let fetchingIDs = collectionIDs\n\n\n    for project in fetchingIDs.keys {\n\n        let catalogEntry = FINDNFTCatalog.getCatalogEntry(collectionIdentifier:project)!\n        let projectName = catalogEntry.contractName\n\n        let returnedNFTs = getNFTs(ownerAddress: account!.address, ids: {project : fetchingIDs[project]!})\n\n        var collectionItems : [MetadataCollectionItem] = []\n        for nft in returnedNFTs {\n            if nft == nil {\n                continue\n            }\n\n            var subCollection = \"\"\n            if project != nft!.collectionDisplay!.name {\n             subCollection = nft!.collectionDisplay!.name\n            }\n\n            var name = nft!.display!.name \n            if name == \"\" {\n                name = projectName\n            }\n\n            if nft.editions != nil \u0026\u0026 nft.editions!.infoList.length \u003e 0 {\n                let edition = nft.editions!.infoList[0].number.toString()\n                // check if the name ends with \"editionNumber\"\n                // If the name ends with \"editionNumber\", we do not concat the edition\n                if name.length \u003e edition.length \u0026\u0026 name.slice(from: name.length - edition.length, upTo: name.length) != edition {\n                    name = name.concat(\"#\").concat(nft.editions!.infoList[0].number.toString())\n                }\n            }\n            \n            let item = MetadataCollectionItem(\n                id: nft!.id,\n                name: name,\n                collection: project,\n                subCollection: subCollection, \n                media: nft!.display!.thumbnail.uri(),\n                mediaType: \"image/png\",\n                source: source, \n                nftDetailIdentifier: nft!.nftType.identifier, \n                editions : nft!.editions,\n                rarity: nft!.rarity,\n                serial: nft!.serial,\n                traits: nft!.traits,\n            )\n            collectionItems.append(item)\n        }\n\n        if collectionItems.length \u003e 0 {\n            items[project] = collectionItems\n        }\n    }\n    return items\n}\n\npub fun cleanUpTraits(_ traits: [MetadataViews.Trait]) : MetadataViews.Traits {\n    let dateValues  = {\"Date\" : true, \"Numeric\":false, \"Number\":false, \"date\":true, \"numeric\":false, \"number\":false}\n\n    let array : [MetadataViews.Trait] = []\n\n    for i , trait in traits {\n        let displayType = trait.displayType ?? \"string\"\n        if let isDate = dateValues[displayType] {\n            if isDate {\n                array.append(MetadataViews.Trait(name: trait.name, value: trait.value, displayType: \"Date\", rarity: trait.rarity))\n            } else {\n                array.append(MetadataViews.Trait(name: trait.name, value: trait.value, displayType: \"Numeric\", rarity: trait.rarity))\n            }\n        } else {\n            if let value = trait.value as? Bool {\n                if value {\n                    array.append(MetadataViews.Trait(name: trait.name, value: trait.value, displayType: \"Bool\", rarity: trait.rarity))\n                }else {\n                    array.append(MetadataViews.Trait(name: trait.name, value: trait.value, displayType: \"Bool\", rarity: trait.rarity))\n                }\n            } else if let value = trait.value as? String {\n                array.append(MetadataViews.Trait(name: trait.name, value: trait.value, displayType: \"String\", rarity: trait.rarity))\n            } else {\n                array.append(MetadataViews.Trait(name: trait.name, value: trait.value, displayType: \"String\", rarity: trait.rarity))\n            }\n        }\n    }\n    return MetadataViews.Traits(array)\n}\n\npub fun getTrait(_ viewResolver: \u0026{MetadataViews.Resolver}) : MetadataViews.Trait? {\n    if let view = viewResolver.resolveView(Type\u003cMetadataViews.Trait\u003e()) {\n        if let v = view as? MetadataViews.Trait {\n            return v\n        }\n    }\n    return nil\n}\n\npub fun getEdition(_ viewResolver: \u0026{MetadataViews.Resolver}) : MetadataViews.Edition? {\n    if let view = viewResolver.resolveView(Type\u003cMetadataViews.Edition\u003e()) {\n        if let v = view as? MetadataViews.Edition {\n            return v\n        }\n    }\n    return nil\n}",
               "spec": {
                  "order": [
                     "user",
                     "collectionIDs"
                  ],
                  "parameters": {
                     "collectionIDs": "{String: [UInt64]}",
                     "user": "String"
                  }
               }
            },
            "getNFTDetailsNFTCatalog": {
               "code": "import FindMarket from 0x35717efbbce11c74 \nimport FindViews from 0x35717efbbce11c74 \nimport FIND from 0x35717efbbce11c74 \nimport MetadataViews from 0x631e88ae7f1d7c20\n//import NFTStorefront from \"../contracts/standard/NFTStorefront.cdc\"\nimport FINDNFTCatalog from 0x35717efbbce11c74\nimport FTRegistry from 0x35717efbbce11c74\n\npub struct NFTDetailReport {\n    pub let findMarket: {String : FindMarket.SaleItemInformation}\n    pub let storefront: StorefrontListing?\n    pub let nftDetail: NFTDetail?\n    pub let allowedListingActions: {String : ListingTypeReport}\n    pub let linkedForMarket : Bool?\n\n    init(findMarket:{String : FindMarket.SaleItemInformation}, storefront: StorefrontListing?, nftDetail: NFTDetail?, allowedListingActions: {String : ListingTypeReport}, linkedForMarket : Bool?) {\n        self.findMarket=findMarket\n        self.storefront=storefront\n        self.nftDetail=nftDetail\n        self.allowedListingActions=allowedListingActions\n        self.linkedForMarket = linkedForMarket\n    }\n}\n\n\npub struct ListingTypeReport {\n    pub let ftAlias: [String] \n    pub let ftIdentifiers: [String]\n    pub let listingType: String \n    pub let status: String \n    pub let ListingDetails: [ListingRoyalties]\n\n    init(listingType: String, ftAlias: [String], ftIdentifiers: [String],  status: String , ListingDetails: [ListingRoyalties]) {\n        self.listingType=listingType \n        self.status=status\n        self.ListingDetails=ListingDetails\n        self.ftAlias=ftAlias \n        self.ftIdentifiers=ftIdentifiers\n    }\n}\n\npub struct NFTDetail {\n    pub let id: UInt64 \n    pub let uuid: UInt64 \n    pub let name:String\n    pub let description:String\n    pub let thumbnail:String\n    pub let type: String\n    pub var externalViewURL: String?\n    pub var rarity:MetadataViews.Rarity?\n    pub var editions: [MetadataViews.Edition]\n    pub var serial: UInt64?\n    pub var traits: [MetadataViews.Trait]\n    pub var media : {String: String} //url to mediaType\n    pub var collection : NFTCollectionDisplay?\n    pub var license : String? \n    pub var data: {String : AnyStruct?}\n    pub var views :[String]\n\n    init(_ pointer: FindViews.ViewReadPointer, views: {String : AnyStruct}, resolvedViews: [Type]){\n\n        self.type=pointer.itemType.identifier\n        self.id=pointer.id\n        self.uuid=pointer.getUUID()\n\n        // Display \n        let display = views[\"Display\"] ?? panic(\"Could not find display\")\n        let d = display as! MetadataViews.Display\n        self.name=d.name\n        self.description=d.description\n        self.thumbnail=d.thumbnail.uri()\n        views.remove(key: \"Display\")\n\n        // External URL \n        self.externalViewURL = nil \n        if let externalURL = views[\"ExternalURL\"] {\n            if let e = externalURL as? MetadataViews.ExternalURL {\n                self.externalViewURL = e.url\n            }\n        }\n        views.remove(key: \"ExternalURL\")\n\n        // Edition\n        self.editions=[] \n        if let editions = views[\"Editions\"] {\n            if let e = editions as? MetadataViews.Editions {\n                if e.infoList.length \u003e 0 {\n                    self.editions=e.infoList\n                }\n            }\n        }\n        views.remove(key: \"Editions\")\n\n        // Serial\n        self.serial=nil\n        if let serial = views[\"Serial\"] {\n            if let s = serial as? MetadataViews.Serial {\n                self.serial=s.number\n            }\n        }\n        views.remove(key: \"Serial\")\n\n        // subCollection\n        self.collection=nil\n        if let grouping = views[\"NFTCollectionDisplay\"] {\n            if let sc = grouping as? MetadataViews.NFTCollectionDisplay {\n                self.collection=NFTCollectionDisplay(sc)\n            }\n        }\n        views.remove(key: \"NFTCollectionDisplay\")\n\n        // Medias \n        self.media={}\n        if let medias= views[\"Medias\"] {\n            if let ms = medias as? MetadataViews.Medias {\n                for m in ms.items {\n                    let url = m.file.uri() \n                    let type = m.mediaType\n                    self.media[url] = type\n                }\n            }\n        }\n        views.remove(key: \"Medias\")\n\n        // Rarity \n        self.rarity=nil\n        if let rarity= views[\"Rarity\"] {\n            if let r = rarity as? MetadataViews.Rarity {\n                self.rarity = r\n            }\n        }\n        views.remove(key: \"Rarity\")\n\n        // Traits\n        self.traits=[] \n        if let traits = views[\"Traits\"] {\n            if let t = traits as? MetadataViews.Traits {\n                if t.traits.length \u003e 0 {\n                    self.traits=t.traits\n                }\n            }\n        }\n        views.remove(key: \"Traits\")\n\n        // License \n        self.license= nil \n        if let license= views[\"License\"] {\n            if let l = license as? MetadataViews.License {\n                self.license = l.spdxIdentifier\n            }\n        }\n        views.remove(key: \"License\")\n\n        self.views=[]\n\n        for view in pointer.getViews() {\n            if defaultViews().contains(view) {\n                continue\n            }\n            if resolvedViews.contains(view) {\n                continue\n            }\n            self.views.append(view.identifier)\n        }\n        self.data=views\n\n    }\n}\n\n\npub struct StoreFrontCut {\n\n    pub let amount:UFix64\n    pub let address: Address\n    pub let findName:String?\n\n    init(amount:UFix64, address:Address){\n        self.amount=amount\n        self.address=address\n        self.findName= reverseLookup(address)\n    }\n}\n\npub struct ListingRoyalties {\n\n    pub let ftAlias: String?\n    pub let ftIdentifier: String\n    pub let royalties: [Royalties]\n\n    init(ftAlias: String?, ftIdentifier: String, royalties: [Royalties]) {\n        self.ftAlias=ftAlias \n        self.ftIdentifier=ftIdentifier\n        self.royalties=royalties \n    }\n}\n\npub struct Royalties {\n\n    pub let royaltyName: String \n    pub let address: Address \n    pub let findName: String? \n    pub let cut: UFix64 \n\n    init(royaltyName: String , address: Address, findName: String?, cut: UFix64) {\n        self.royaltyName=royaltyName \n        self.address=address \n        self.findName=findName \n        self.cut=cut\n    }\n}\n\n\npub struct StorefrontListing {\n    pub let foo:String\n\n    init() {\n\n        self.foo =\"bar\"\n    }\n}\n\npub struct NFTCollectionDisplay {\n    // Name that should be used when displaying this NFT collection.\n    pub let name: String\n\n    // Description that should be used to give an overview of this collection.\n    pub let description: String\n\n    // External link to a URL to view more information about this collection.\n    pub let externalURL: String\n\n    // Square-sized image to represent this collection.\n    pub let squareImage: {String : String}\n\n    // Banner-sized image for this collection, recommended to have a size near 1200x630.\n    pub let bannerImage: {String : String}\n\n    // Social links to reach this collection's social homepages.\n    // Possible keys may be \"instagram\", \"twitter\", \"discord\", etc.\n    pub let socials: {String: String}\n\n    init(\n        _ nftCD : MetadataViews.NFTCollectionDisplay\n    ) {\n        self.name = nftCD.name\n        self.description = nftCD.description\n        self.externalURL = nftCD.externalURL.url\n\n        let squareImage = {nftCD.squareImage.file.uri() : nftCD.squareImage.mediaType}\n        self.squareImage = squareImage\n\n        let bannerImage = {nftCD.bannerImage.file.uri() : nftCD.bannerImage.mediaType}\n        self.bannerImage = bannerImage\n\n        let socials : {String : String} = {}\n        for key in nftCD.socials.keys{\n            socials[key] = nftCD.socials[key]!.url\n        }\n        self.socials = socials\n    }\n}\n\n/*\npub struct StorefrontListing {\n    pub let nftID:UInt64\n    pub let nftIdentifier: String\n    pub let saleCut: [StoreFrontCut]\n    pub let amount:UFix64\n    pub let ftTypeIdentifier:String\n    pub let storefront:UInt64\n    pub let listingID:UInt64\n\n    init(listingId:UInt64, details: NFTStorefront.ListingDetails) {\n\n        self.saleCut=[]\n        self.nftID=details.nftID\n        self.nftIdentifier=details.nftType.identifier\n        for cutDetails in details.saleCuts {\n            self.saleCut.append(StoreFrontCut(amount:cutDetails.amount, address:cutDetails.receiver.address))\n        }\n        self.amount=details.salePrice\n        self.ftTypeIdentifier=details.salePaymentVaultType.identifier\n        self.storefront=details.storefrontID\n        self.listingID=listingId\n    }\n}\n*/\n\npub var counter = 0\n\npub fun main(user: String, project:String, id: UInt64, views: [String]) : NFTDetailReport?{\n    let resolveAddress = FIND.resolve(user) \n    if resolveAddress == nil {\n        return nil\n    }\n    let address = resolveAddress!\n\n    let account = getAuthAccount(address) \n\n    if account.balance \u003e 0.0 {\n        // check link for market\n        let linkedForMarket = account.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(getPublicPath(project)).check()\n\n        let storagePath = getStoragePath(project)\n        let publicPath = PublicPath(identifier: \"find_temp_path_\".concat(counter.toString()))!\n        counter = counter + 1\n        account.link\u003c\u0026{MetadataViews.ResolverCollection}\u003e(publicPath, target: storagePath)\n        let cap = account.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(publicPath)\n        if !cap.check() {\n            panic(\"The user does not set up collection correctly.\")\n        }\n        let pointer = FindViews.ViewReadPointer(cap: cap, id: id)\n\n        let nftDetail = getNFTDetail(pointer:pointer, views: views)\n        if nftDetail == nil {\n            return nil\n        }\n\n\n        let findAddress=FindMarket.getFindTenantAddress()\n        let findMarket=FindMarket.getNFTListing(tenant:findAddress, address: address, id: nftDetail!.uuid, getNFTInfo:false)\n\n        /*\n        var listings : StorefrontListing? = nil\n        let storefrontCap = account.getCapability\u003c\u0026NFTStorefront.Storefront{NFTStorefront.StorefrontPublic}\u003e(NFTStorefront.StorefrontPublicPath)\n\n        if storefrontCap.check() {\n            let storefrontRef=storefrontCap.borrow()!\n            for listingId in storefrontRef.getListingIDs() {\n                let listing = storefrontRef.borrowListing(listingResourceID: listingId)!\n                let nft=listing.borrowNFT()\n                if nft.id==id \u0026\u0026 !listing.getDetails().purchased {\n                    listings = StorefrontListing(listingId: listingId, details: listing.getDetails())\n                }\n            }\n        }\n        */\n\n        var report : {String : ListingTypeReport} = {}\n\n        // check if that's soulBound, if yes, the report will be nil\n        if !pointer.checkSoulBound() {\n            let tenantCap = FindMarket.getTenantCapability(findAddress)!\n            let tenantRef = tenantCap.borrow() ?? panic(\"This tenant is not set up. Tenant : \".concat(tenantCap.address.toString()))\n\n            let marketTypes = FindMarket.getSaleItemTypes()\n\n            for marketType in marketTypes {\n                if let allowedListing = tenantRef.getAllowedListings(nftType: pointer.getItemType(), marketType: marketType) {\n                    report[FindMarket.getMarketOptionFromType(marketType)] = createListingTypeReport(allowedListing, pointer: pointer, tenantRef: tenantRef)\n                }\n            }\n        }\n        return NFTDetailReport(findMarket:findMarket, storefront:nil, nftDetail: nftDetail, allowedListingActions: report, linkedForMarket : linkedForMarket)\n    }\n    return nil\n\n}\n\npub let resolvedAddresses : {Address : String} = {}\n\npub var nftRoyalties : [Royalties]? = nil\n\npub fun reverseLookup(_ addr: Address) : String? {\n\n    if let name = resolvedAddresses[addr] {\n        if name == \"\" {\n            return nil\n        } else {\n            return name\n        }\n    }\n    let name = FIND.reverseLookup(addr) \n    if name == nil {\n        resolvedAddresses[addr] = \"\"\n    } else {\n        resolvedAddresses[addr] = name\n    }\n    return name\n\n}\n\npub fun getNFTDetail(pointer: FindViews.ViewReadPointer, views: [String]) : NFTDetail? {\n\n    if !pointer.valid() {\n        return nil\n    }\n\n    var nftViews: {String : AnyStruct} = {}\n    var resolvedViews: [Type] = []\n    let viewResolver = pointer.getViewResolver()\n\n    let defaultViews = defaultViews()\n    for view in views {\n        if let runTimeType = CompositeType(view) {\n            if !defaultViews.contains(runTimeType) {\n                defaultViews.append(runTimeType)\n            }\n        }\n    }\n\n\n    for runTimeType in defaultViews {\n        // Resolve arrayed views to ensure we didn't miss any stuff \n        if runTimeType == Type\u003cMetadataViews.Editions\u003e() {\n            if let editions = MetadataViews.getEditions(viewResolver) {\n                if let edition = getEdition(viewResolver) {\n                    var check = false\n                    for item in editions.infoList {\n                        if item.name == edition.name \u0026\u0026 item.number == edition.number \u0026\u0026 item.max == edition.max {\n                            check = true\n                            break\n                        }\n                    }\n                    // If the edition does not exist in editions, add it in\n                    if !check {\n                        let array = editions.infoList \n                        array.append(edition)\n                        nftViews[\"Editions\"] = MetadataViews.Editions(array)\n                        resolvedViews.append(runTimeType)\n                        continue\n                    }\n                } \n                // If edition does not exist OR edition is already in editions , append it to views and continue\n                nftViews[\"Editions\"] = editions\n                resolvedViews.append(runTimeType)\n                continue\n            }\n        }\n\n        if runTimeType == Type\u003cMetadataViews.Edition\u003e() {\n            // If the editions does not exist, check if there is edition, if there is, add it in as editions\n            if nftViews[\"Editions\"] == nil {\n                if let edition = getEdition(viewResolver) {\n                    nftViews[\"Editions\"] = MetadataViews.Editions([edition])\n                    resolvedViews.append(runTimeType)\n                }\n            } \n            continue\n        }\n\n        if runTimeType == Type\u003cMetadataViews.Medias\u003e() {\n            if let medias = MetadataViews.getMedias(viewResolver) {\n                if let media = getMedia(viewResolver) {\n                    var check = false \n                    let uri = media.file.uri()\n                    for item in medias.items {\n                        if item.file.uri() == uri {\n                            check = true \n                            break\n                        }\n                        if !check {\n                            let array = medias.items\n                            array.append(media)\n                            nftViews[\"Medias\"] = MetadataViews.Medias(array)\n                            resolvedViews.append(runTimeType)\n                            continue\n                        }\n                    }\n                } \n                nftViews[\"Medias\"] = medias\n                resolvedViews.append(runTimeType)\n                continue\n            }\n        }\n\n        if runTimeType == Type\u003cMetadataViews.Media\u003e() {\n            if nftViews[\"Medias\"] == nil {\n                if let media = getMedia(viewResolver) {\n                    nftViews[\"Medias\"] = MetadataViews.Medias([media])\n                    resolvedViews.append(runTimeType)\n                }\n            }\n            continue\n        }\n\n        if runTimeType == Type\u003cMetadataViews.Traits\u003e() {\n            if let traits = MetadataViews.getTraits(viewResolver) {\n                if let trait = getTrait(viewResolver) {\n                    var check = false \n                    for item in traits.traits {\n                        if item.name == trait.name {\n                            check = true \n                            break\n                        }\n                        if !check {\n                            let array = traits.traits\n                            array.append(trait)\n\n                            nftViews[\"Traits\"] = cleanUpTraits(array)\n                            resolvedViews.append(runTimeType)\n                            continue\n                        }\n                    }\n                } \n                nftViews[\"Traits\"] = cleanUpTraits(traits.traits)\n                resolvedViews.append(runTimeType)\n                continue\n            }\n        }\n\n        if runTimeType == Type\u003cMetadataViews.Trait\u003e() {\n            if nftViews[\"Traits\"] == nil {\n                if let trait = getTrait(viewResolver) {\n                    nftViews[\"Traits\"] = MetadataViews.Traits([trait])\n                    resolvedViews.append(runTimeType)\n                }\n            } \n            continue\n        }\n\n        if let view = pointer.resolveView(runTimeType) {\n            nftViews[runTimeType.identifier.slice(from: \"A.1d7e57aa55817448.MetadataViews.\".length, upTo: runTimeType.identifier.length)] = view\n            resolvedViews.append(runTimeType)\n        }\n    }\n    \n    return NFTDetail(pointer, views: nftViews, resolvedViews: resolvedViews)\n\n\n}\n\npub fun getEdition(_ viewResolver: \u0026{MetadataViews.Resolver}) : MetadataViews.Edition? {\n    if let view = viewResolver.resolveView(Type\u003cMetadataViews.Edition\u003e()) {\n        if let v = view as? MetadataViews.Edition {\n            return v\n        }\n    }\n    return nil\n}\n\npub fun getMedia(_ viewResolver: \u0026{MetadataViews.Resolver}) : MetadataViews.Media? {\n    if let view = viewResolver.resolveView(Type\u003cMetadataViews.Media\u003e()) {\n        if let v = view as? MetadataViews.Media {\n            return v\n        }\n    }\n    return nil\n}\n\npub fun getTrait(_ viewResolver: \u0026{MetadataViews.Resolver}) : MetadataViews.Trait? {\n    if let view = viewResolver.resolveView(Type\u003cMetadataViews.Trait\u003e()) {\n        if let v = view as? MetadataViews.Trait {\n            return v\n        }\n    }\n    return nil\n}\n\n/* Helper Function */\npub fun resolveRoyalties(_ pointer: FindViews.ViewReadPointer) : [Royalties] {\n    let array : [Royalties] = []\n    for royalty in pointer.getRoyalty().getRoyalties() {\n        let address = royalty.receiver.address\n        array.append(Royalties(royaltyName: royalty.description, address: address, findName: reverseLookup(address), cut: royalty.cut))\n    }\n\n    return array\n}\n\npub fun resolveFindRoyalties(tenantRef: \u0026FindMarket.Tenant{FindMarket.TenantPublic}, listing: Type, nft: Type, ft: Type) : [Royalties] {\n\n    let cuts = tenantRef.getTenantCut(name:\"\", listingType: listing, nftType:nft, ftType:ft)\n\n    let royalties :[Royalties] = []\n    if cuts.findCut != nil {\n        royalties.append(Royalties(royaltyName: cuts.findCut!.description, address: cuts.findCut!.receiver.address, findName: reverseLookup(cuts.findCut!.receiver.address), cut: cuts.findCut!.cut))\n    }\n\n    if cuts.tenantCut != nil {\n        royalties.append(Royalties(royaltyName: cuts.tenantCut!.description, address: cuts.tenantCut!.receiver.address, findName: reverseLookup(cuts.tenantCut!.receiver.address), cut: cuts.tenantCut!.cut))\n    }\n    \n    return royalties\n}\n\npub fun createListingTypeReport(_ allowedListing: FindMarket.AllowedListing, pointer: FindViews.ViewReadPointer, tenantRef: \u0026FindMarket.Tenant{FindMarket.TenantPublic}) : ListingTypeReport {\n    let listingType = allowedListing.listingType.identifier\n    var ftAlias : [String] = []\n    var ftIdentifier : [String] = []\n    var listingDetails : [ListingRoyalties] = []\n    for ft in allowedListing.ftTypes {\n        ftIdentifier.append(ft.identifier)\n        var alias : String? = nil\n        if let ftInfo = FTRegistry.getFTInfo(ft.identifier) {\n            alias = ftInfo.alias\n            ftAlias.append(ftInfo.alias)\n        }\n\n        // getRoyalties \n        var nftR = nftRoyalties \n        if nftR == nil {\n            nftRoyalties = resolveRoyalties(pointer)\n            nftR = nftRoyalties\n        }\n\n        let findR = resolveFindRoyalties(tenantRef: tenantRef, listing: allowedListing.listingType , nft: pointer.getItemType(), ft: ft)\n        findR.appendAll(nftR!)\n\n        listingDetails.append(ListingRoyalties(ftAlias: alias, ftIdentifier: ft.identifier, royalties: findR))\n    }\n    \n    return ListingTypeReport(listingType: listingType, ftAlias: ftAlias, ftIdentifiers: ftIdentifier,  status: allowedListing.status , ListingDetails: listingDetails)\n}\n\npub fun defaultViews() : [Type] {\n    return [\n    Type\u003cMetadataViews.Display\u003e() ,\n    Type\u003cMetadataViews.Editions\u003e() , \n    Type\u003cMetadataViews.Edition\u003e() ,\n    Type\u003cMetadataViews.Serial\u003e() , \n    Type\u003cMetadataViews.Medias\u003e() ,\n    Type\u003cMetadataViews.Media\u003e() ,\n    Type\u003cMetadataViews.License\u003e() , \n    Type\u003cMetadataViews.ExternalURL\u003e() , \n    Type\u003cMetadataViews.NFTCollectionDisplay\u003e() , \n    Type\u003cMetadataViews.Traits\u003e() , \n    Type\u003cMetadataViews.Trait\u003e() ,\n    Type\u003cMetadataViews.Rarity\u003e() \n    ]\n}\n\npub fun getStoragePath(_ nftIdentifier: String) : StoragePath {\n    if let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys {\n        let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n        return collection.collectionData.storagePath\n    }\n\n    if let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier :nftIdentifier) {\n        return collection.collectionData.storagePath\n    }\n    panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier)) \n}\n\npub fun getPublicPath(_ nftIdentifier: String) : PublicPath {\n    if let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys {\n        let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n        return collection.collectionData.publicPath\n    }\n\n    if let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier :nftIdentifier) {\n        return collection.collectionData.publicPath\n    }\n    panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier)) \n}\n\npub fun cleanUpTraits(_ traits: [MetadataViews.Trait]) : MetadataViews.Traits {\n    let dateValues  = {\"Date\" : true, \"Numeric\":false, \"Number\":false, \"date\":true, \"numeric\":false, \"number\":false}\n\n    let array : [MetadataViews.Trait] = []\n\n    for i , trait in traits {\n        let displayType = trait.displayType ?? \"string\"\n        if let isDate = dateValues[displayType] {\n            if isDate {\n                array.append(MetadataViews.Trait(name: trait.name, value: trait.value, displayType: \"Date\", rarity: trait.rarity))\n            } else {\n                array.append(MetadataViews.Trait(name: trait.name, value: trait.value, displayType: \"Numeric\", rarity: trait.rarity))\n            }\n        } else {\n            if let value = trait.value as? Bool {\n                if value {\n                    array.append(MetadataViews.Trait(name: trait.name, value: trait.value, displayType: \"Bool\", rarity: trait.rarity))\n                }else {\n                    array.append(MetadataViews.Trait(name: trait.name, value: trait.value, displayType: \"Bool\", rarity: trait.rarity))\n                }\n            } else if let value = trait.value as? String {\n                array.append(MetadataViews.Trait(name: trait.name, value: trait.value, displayType: \"String\", rarity: trait.rarity))\n            } else {\n                array.append(MetadataViews.Trait(name: trait.name, value: trait.value, displayType: \"String\", rarity: trait.rarity))\n            }\n        }\n    }\n    return MetadataViews.Traits(array)\n}",
               "spec": {
                  "order": [
                     "user",
                     "project",
                     "id",
                     "views"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "project": "String",
                     "user": "String",
                     "views": "[String]"
                  }
               }
            },
            "getNFTView": {
               "code": "import MetadataViews from 0x631e88ae7f1d7c20\nimport FINDNFTCatalog from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\n\n//Fetch a single view from a nft on a given path\npub fun main(user: String, aliasOrIdentifier:String, id: UInt64, identifier: String) : AnyStruct? {\n\n    let publicPath = getPublicPath(aliasOrIdentifier)\n    let resolveAddress = FIND.resolve(user) \n    if resolveAddress == nil {return []}\n    let address = resolveAddress!\n\n    let pp = publicPath\n    let account = getAccount(address)\n    if account.balance == 0.0 {\n        return nil\n    }\n    let collection= account.getCapability(pp).borrow\u003c\u0026{MetadataViews.ResolverCollection}\u003e()!\n\n    let nft=collection.borrowViewResolver(id: id)\n    for v in nft.getViews() {\n        if v.identifier== identifier {\n            return nft.resolveView(v)\n        }\n    }\n    return nil\n}\n\npub fun getPublicPath(_ nftIdentifier: String) : PublicPath {\n    let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier)) \n    let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n    return collection.collectionData.publicPath\n}",
               "spec": {
                  "order": [
                     "user",
                     "aliasOrIdentifier",
                     "id",
                     "identifier"
                  ],
                  "parameters": {
                     "aliasOrIdentifier": "String",
                     "id": "UInt64",
                     "identifier": "String",
                     "user": "String"
                  }
               }
            },
            "getNFTViews": {
               "code": "import MetadataViews from 0x631e88ae7f1d7c20\nimport NFTCatalog from 0x324c34e1c517e4db\nimport FINDNFTCatalog from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\n\n//get all the views for an nft and address/path/id\npub fun main(user: String, aliasOrIdentifier:String, id: UInt64) : [String] {\n    let nftInfo = getCollectionData(aliasOrIdentifier) \n\n    let resolveAddress = FIND.resolve(user) \n    if resolveAddress == nil {return []}\n    let address = resolveAddress!\n    let pp = nftInfo.publicPath\n    let collection= getAccount(address).getCapability(pp).borrow\u003c\u0026{MetadataViews.ResolverCollection}\u003e()!\n    let nft=collection.borrowViewResolver(id: id)\n    let views:[String]=[]\n    for v in nft.getViews() {\n        views.append(v.identifier)\n    }\n    return views\n}\n\npub fun getCollectionData(_ nftIdentifier: String) : NFTCatalog.NFTCollectionData {\n    let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier)) \n    let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n    return collection.collectionData\n}",
               "spec": {
                  "order": [
                     "user",
                     "aliasOrIdentifier",
                     "id"
                  ],
                  "parameters": {
                     "aliasOrIdentifier": "String",
                     "id": "UInt64",
                     "user": "String"
                  }
               }
            },
            "getName": {
               "code": "import FIND from 0x35717efbbce11c74\n\npub fun main(address: Address) : String?{\n    return FIND.reverseLookup(address)\n}",
               "spec": {
                  "order": [
                     "address"
                  ],
                  "parameters": {
                     "address": "Address"
                  }
               }
            },
            "getNameDetails": {
               "code": "import FIND from 0x35717efbbce11c74\nimport Profile from 0x35717efbbce11c74\nimport RelatedAccounts from 0x35717efbbce11c74\n\npub struct FINDReport {\n    pub let profile:Profile.UserReport?\n    pub let bids: [FIND.BidInfo]\n    pub let relatedAccounts: { String: Address}\n    pub let leases: [FIND.LeaseInformation]\n    pub let privateMode: Bool\n    pub let activatedAccount: Bool \n\n\n    init(profile: Profile.UserReport?, relatedAccounts: {String: Address}, bids: [FIND.BidInfo], leases : [FIND.LeaseInformation], privateMode: Bool, activatedAccount: Bool ) {\n        self.profile=profile\n        self.bids=bids\n        self.leases=leases\n        self.relatedAccounts=relatedAccounts\n        self.privateMode=privateMode\n        self.activatedAccount=activatedAccount\n    }\n}\n\npub struct NameReport {\n    pub let status: String\n    pub let cost: UFix64 \n    pub let leaseStatus: FIND.LeaseInformation?\n    pub let userReport: FINDReport? \n\n    init(status: String, cost: UFix64, leaseStatus: FIND.LeaseInformation?, userReport: FINDReport? ) {\n        self.status=status \n        self.cost=cost \n        self.leaseStatus=leaseStatus\n        self.userReport=userReport\n    }\n}\n\npub fun main(user: String) : NameReport? {\n\n    var findReport: FINDReport? = nil\n    var nameLease: FIND.LeaseInformation? = nil\n    if let address=FIND.resolve(user) {\n        let account=getAccount(address)\n        if account.balance != 0.0 {\n            let bidCap = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n            let leaseCap = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n            let profile=account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath).borrow()\n\n            var profileReport = profile?.asReport() \n            if profileReport != nil \u0026\u0026 profileReport!.findName != FIND.reverseLookup(address) {\n                profileReport = Profile.UserReport(\n                    findName: \"\",\n                    address: profileReport!.address,\n                    name: profileReport!.name,\n                    gender: profileReport!.gender,\n                    description: profileReport!.description,\n                    tags: profileReport!.tags,\n                    avatar: profileReport!.avatar,\n                    links: profileReport!.links,\n                    wallets: profileReport!.wallets, \n                    following: profileReport!.following,\n                    followers: profileReport!.followers,\n                    allowStoringFollowers: profileReport!.allowStoringFollowers,\n                    createdAt: profileReport!.createdAt\n                )\n            }\n\n            findReport = FINDReport(\n                profile: profileReport,\n                relatedAccounts: RelatedAccounts.findRelatedFlowAccounts(address:address),\n                bids: bidCap.borrow()?.getBids() ?? [],\n                leases: leaseCap.borrow()?.getLeaseInformation() ?? [],\n                privateMode: profile?.isPrivateModeEnabled() ?? false, \n                activatedAccount: true\n            )\n            if FIND.validateFindName(user) \u0026\u0026 findReport != nil {\n                for lease in findReport!.leases {\n                    if lease.name == user {\n                        nameLease = lease\n                        break\n                    }\n                }\n            }\n        } else {\n            findReport = FINDReport(\n                profile: nil,\n                relatedAccounts: {},\n                bids: [],\n                leases: [],\n                privateMode: false, \n                activatedAccount: false\n            )\n        }\n        \n    }\n\n    var nameReport : NameReport? = nil \n    if FIND.validateFindName(user) {\n        let status = FIND.status(user)\n        let cost=FIND.calculateCost(user)\n        var s=\"TAKEN\"    \n        if status.status == FIND.LeaseStatus.FREE {\n            s=\"FREE\"\n        } else if status.status == FIND.LeaseStatus.LOCKED {\n            s=\"LOCKED\"\n        }\n        nameReport = NameReport(status: s, cost: cost, leaseStatus: nameLease, userReport: findReport)\n    }\n    \n\n    return nameReport\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "getNameStatus": {
               "code": "import FIND from 0x35717efbbce11c74\nimport Profile from 0x35717efbbce11c74\n\npub fun main(name: String) :  \u0026{Profile.Public}? {\n    return FIND.lookup(name)\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "getNames": {
               "code": "import FIND from 0x35717efbbce11c74\n\npub fun main(address: [Address]) : { Address:String}{\n\n    let items : {Address:String} = {}\n    for a in address {\n        if let name= FIND.reverseLookup(a) {\n            items[a]=name\n        }\n    }\n    return items\n}",
               "spec": {
                  "order": [
                     "address"
                  ],
                  "parameters": {
                     "address": "[Address]"
                  }
               }
            },
            "getNamesWithBids": {
               "code": "import FIND from 0x35717efbbce11c74\n\npub fun main(user: String) : [FIND.LeaseInformation] {\n\n    let resolveAddress = FIND.resolve(user) \n    if resolveAddress == nil {return []}\n    let address = resolveAddress!\n    let account=getAccount(address)\n\n    if account.balance == 0.0 {\n        return []\n    }\n\n    let leaseCap = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\n    let leases=leaseCap.borrow()?.getLeaseInformation() ?? []\n\n    var leasesWithBids :[FIND.LeaseInformation] =[]\n    for lease in leases {\n        if lease.latestBidBy != nil {\n            leasesWithBids.append(lease)\n        }\n    }\n\n    return leasesWithBids\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "getNamesWithoutBids": {
               "code": "import FIND from 0x35717efbbce11c74\n\n\npub fun main(user: String) : [String] {\n\n    let resolveAddress = FIND.resolve(user) \n    if resolveAddress == nil {return []}\n    let address = resolveAddress!\n    let account=getAccount(address)\n\n    if account.balance == 0.0 {\n        return []\n    }\n\n    let leaseCap = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\n    let leases=leaseCap.borrow()?.getLeaseInformation() ?? []\n\n    var leasesWithBids :[String] =[]\n    for lease in leases {\n        if lease.latestBidBy == nil {\n            leasesWithBids.append(lease.name)\n        }\n    }\n\n    return leasesWithBids\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "getProfile": {
               "code": "import Profile from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\n\npub fun main(user: String) :  Profile.UserReport? {\n    let resolveAddress = FIND.resolve(user) \n    if resolveAddress == nil {return nil}\n    let address = resolveAddress!\n    let account = getAccount(address)\n    if account.balance == 0.0 {\n        return nil\n    }\n\n    var profileReport = account\n        .getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        .borrow()?.asReport()\n\n    if profileReport != nil \u0026\u0026 profileReport!.findName != FIND.reverseLookup(address) {\n        profileReport = Profile.UserReport(\n            findName: \"\",\n            address: profileReport!.address,\n            name: profileReport!.name,\n            gender: profileReport!.gender,\n            description: profileReport!.description,\n            tags: profileReport!.tags,\n            avatar: profileReport!.avatar,\n            links: profileReport!.links,\n            wallets: profileReport!.wallets, \n            following: profileReport!.following,\n            followers: profileReport!.followers,\n            allowStoringFollowers: profileReport!.allowStoringFollowers,\n            createdAt: profileReport!.createdAt\n        )\n    }\n\n    return profileReport\n\n\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "getRoyaltyChangedIds": {
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\n\npub fun main(marketplace: Address, user: String) : {String : [UInt64]} {\n    if let address = FIND.resolve(user){\n        return FindMarket.getRoyaltiesChangedIds(tenant:marketplace, address: address)\n    }\n    return {}\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "user"
                  ],
                  "parameters": {
                     "marketplace": "Address",
                     "user": "String"
                  }
               }
            },
            "getRoyaltyChangedItems": {
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\n\npub fun main(marketplace: Address, user: String) : {String : FindMarket.SaleItemCollectionReport} {\n    if let address = FIND.resolve(user){\n        return FindMarket.getRoyaltiesChangedItems(tenant:marketplace, address: address)\n    }\n    return {}\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "user"
                  ],
                  "parameters": {
                     "marketplace": "Address",
                     "user": "String"
                  }
               }
            },
            "getShardCollectionsNFTCatalog": {
               "code": "import NonFungibleToken from 0x631e88ae7f1d7c20\nimport FIND from 0x35717efbbce11c74\nimport FINDNFTCatalog from 0x35717efbbce11c74\n\npub fun main(user: String) : {String : CollectionLength} {\n\n    if let address = FIND.resolve(user) {\n\n        return getNFTIDs_Catalog(ownerAddress: address, cacheCollections: {})\n\n    }\n    return {}\n\n}\n\npub struct CollectionLength {\n    pub let shard : String \n    pub let length : Int \n    init(shard : String, length : Int ) {\n        self.shard=shard \n        self.length=length\n    }\n}\n\n// Helper function \n\npub fun resolveAddress(user: String) : Address? {\n    return FIND.resolve(user)\n}\n\npub fun getNFTIDs_Catalog(ownerAddress: Address, cacheCollections: {String:CollectionLength}) : {String:CollectionLength} {\n\n    let account = getAuthAccount(ownerAddress)\n\n    let types = FINDNFTCatalog.getCatalogTypeData()\n    for nftType in types.keys {\n\n        let typeData=types[nftType]!\n        let collectionKey=typeData.keys[0]\n        let catalogEntry = FINDNFTCatalog.getCatalogEntry(collectionIdentifier:collectionKey)!\n        let tempPathStr = \"catalog\".concat(collectionKey)\n        let tempPublicPath = PublicPath(identifier: tempPathStr)!\n        account.link\u003c\u0026NonFungibleToken.Collection\u003e(tempPublicPath, target: catalogEntry.collectionData.storagePath)\n        let cap= account.getCapability\u003c\u0026NonFungibleToken.Collection\u003e(tempPublicPath)\n        if cap.check(){\n            let collection = cap.borrow()!\n            let length = collection.ownedNFTs.length\n            if length == 0 {\n                continue\n            }\n            cacheCollections[collectionKey] = CollectionLength(shard: \"NFTCatalog\", length: length)\n        }\n    }\n    return cacheCollections\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "getStatus": {
               "code": "import FIND from 0x35717efbbce11c74\nimport Profile from 0x35717efbbce11c74\nimport RelatedAccounts from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\nimport FindLeaseMarket from 0x35717efbbce11c74\nimport FINDNFTCatalog from 0x35717efbbce11c74\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport FindLostAndFoundWrapper from 0x82836e61c008d6d1\nimport NFTCatalog from 0x324c34e1c517e4db\nimport EmeraldIdentity from 0xfe433270356d985c\nimport EmeraldIdentityDapper from 0xc9d218cc626cd7f5\nimport EmeraldIdentityLilico from 0xc9d218cc626cd7f5\n\npub struct FINDReport{\n    pub let profile:Profile.UserReport?\n    pub let bids: [FIND.BidInfo]\n    pub let relatedAccounts: { String: Address}\n    pub let leases: [FIND.LeaseInformation]\n    pub let privateMode: Bool\n    pub let leasesForSale: {String : FindLeaseMarket.SaleItemCollectionReport}\n    pub let leasesBids: {String : FindLeaseMarket.BidItemCollectionReport}\n    pub let itemsForSale: {String : FindMarket.SaleItemCollectionReport}\n    pub let marketBids: {String : FindMarket.BidItemCollectionReport}\n    pub let activatedAccount: Bool \n\n    // NFT Catalog outputs\n    pub let lostAndFoundTypes: {String : NFTCatalog.NFTCollectionData}\n\n    // EmeraldID Account Linkage \n    pub let emeraldIDAccounts : {String : Address}\n\n\n    init(profile: Profile.UserReport?, \n         relatedAccounts: {String: Address}, \n         bids: [FIND.BidInfo], \n         leases : [FIND.LeaseInformation], \n         privateMode: Bool, \n         leasesForSale: {String : FindLeaseMarket.SaleItemCollectionReport}, \n         leasesBids: {String : FindLeaseMarket.BidItemCollectionReport}, \n         itemsForSale: {String : FindMarket.SaleItemCollectionReport}, \n         marketBids: {String : FindMarket.BidItemCollectionReport}, \n         activatedAccount: Bool, \n         lostAndFoundTypes: {String : NFTCatalog.NFTCollectionData}, \n         emeraldIDAccounts : {String : Address}\n         ) {\n\n        self.profile=profile\n        self.bids=bids\n        self.leases=leases\n        self.relatedAccounts=relatedAccounts\n        self.privateMode=privateMode\n        self.leasesForSale=leasesForSale\n        self.leasesBids=leasesBids\n        self.itemsForSale=itemsForSale\n        self.marketBids=marketBids\n        self.activatedAccount=activatedAccount\n        self.lostAndFoundTypes=lostAndFoundTypes\n        self.emeraldIDAccounts=emeraldIDAccounts\n    }\n}\n\npub struct NameReport {\n    pub let status: String \n    pub let cost: UFix64 \n\n    init(status: String, cost: UFix64) {\n        self.status=status \n        self.cost=cost\n    }\n}\n\npub struct Report {\n    pub let FINDReport: FINDReport?\n    pub let NameReport: NameReport?\n\n    init(FINDReport: FINDReport?, NameReport: NameReport?) {\n        self.FINDReport=FINDReport \n        self.NameReport=NameReport\n    }\n}\n\npub fun main(user: String) : Report? {\n\n    var findReport: FINDReport? = nil\n    if let address=FIND.resolve(user) {\n        let account=getAccount(address)\n        if account.balance \u003e 0.0 {\n            let bidCap = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n            let leaseCap = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n            let profile=account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath).borrow()\n\n            let find= FindMarket.getFindTenantAddress()\n            let findLease= FindMarket.getTenantAddress(\"findLease\")!\n            let items : {String : FindMarket.SaleItemCollectionReport} = FindMarket.getSaleItemReport(tenant:find, address: address, getNFTInfo:true)\n\n            let marketBids : {String : FindMarket.BidItemCollectionReport} = FindMarket.getBidsReport(tenant:find, address: address, getNFTInfo:true)\n\n            let leasesSale : {String : FindLeaseMarket.SaleItemCollectionReport} = FindLeaseMarket.getSaleItemReport(tenant:findLease, address: address, getLeaseInfo:true)\n\n            let leasesBids : {String : FindLeaseMarket.BidItemCollectionReport} = FindLeaseMarket.getBidsReport(tenant:findLease, address: address, getLeaseInfo:true)\n\n            var profileReport = profile?.asReport() \n            if profileReport != nil \u0026\u0026 profileReport!.findName != FIND.reverseLookup(address) {\n                profileReport = Profile.UserReport(\n                    findName: \"\",\n                    address: profileReport!.address,\n                    name: profileReport!.name,\n                    gender: profileReport!.gender,\n                    description: profileReport!.description,\n                    tags: profileReport!.tags,\n                    avatar: profileReport!.avatar,\n                    links: profileReport!.links,\n                    wallets: profileReport!.wallets, \n                    following: profileReport!.following,\n                    followers: profileReport!.followers,\n                    allowStoringFollowers: profileReport!.allowStoringFollowers,\n                    createdAt: profileReport!.createdAt\n                )\n            }\n\n            // NFTCatalog Output \n            let nftCatalogTypes = FINDNFTCatalog.getCatalogTypeData()\n            let types : {String : NFTCatalog.NFTCollectionData} = {}\n            for type in FindLostAndFoundWrapper.getSpecificRedeemableTypes(user: address, specificType: Type\u003c@NonFungibleToken.NFT\u003e()) {\n                types[type.identifier] = FINDNFTCatalog.getCollectionDataForType(nftTypeIdentifier: type.identifier)\n            }\n\n            let discordID = EmeraldIdentity.getDiscordFromAccount(account: address) \n                                    ?? EmeraldIdentityDapper.getDiscordFromAccount(account: address) \n                                    ?? EmeraldIdentityLilico.getDiscordFromAccount(account: address)\n                                    ?? \"\"\n\n            let emeraldIDAccounts : {String : Address} = {}\n            emeraldIDAccounts[\"blocto\"] = EmeraldIdentity.getAccountFromDiscord(discordID: discordID)\n            emeraldIDAccounts[\"lilico\"] = EmeraldIdentityLilico.getAccountFromDiscord(discordID: discordID)\n            emeraldIDAccounts[\"dapper\"] = EmeraldIdentityDapper.getAccountFromDiscord(discordID: discordID)\n            \n            findReport = FINDReport(\n                profile: profileReport,\n                relatedAccounts: RelatedAccounts.findRelatedFlowAccounts(address:address),\n                bids: bidCap.borrow()?.getBids() ?? [],\n                leases: leaseCap.borrow()?.getLeaseInformation() ?? [],\n                privateMode: profile?.isPrivateModeEnabled() ?? false,\n                leasesForSale: leasesSale, \n                leasesBids: leasesBids,\n                itemsForSale: items,\n                marketBids: marketBids,\n                activatedAccount: true, \n                lostAndFoundTypes: types, \n                emeraldIDAccounts: emeraldIDAccounts\n            )\n        } else {\n            findReport = FINDReport(\n                profile: nil,\n                relatedAccounts: {},\n                bids: [],\n                leases: [],\n                privateMode: false,\n                leasesForSale: {}, \n                leasesBids: {},\n                itemsForSale: {},\n                marketBids: {},\n                activatedAccount: false, \n                lostAndFoundTypes: {}, \n                emeraldIDAccounts: {}\n            )\n        }\n    }\n\n    var nameReport : NameReport? = nil \n    if FIND.validateFindName(user) {\n        let status = FIND.status(user)\n        let cost=FIND.calculateCost(user)\n        var s=\"TAKEN\"    \n        if status.status == FIND.LeaseStatus.FREE {\n            s=\"FREE\"\n        } else if status.status == FIND.LeaseStatus.LOCKED {\n            s=\"LOCKED\"\n        }\n        nameReport = NameReport(status: s, cost: cost)\n    }\n    \n\n    return Report(FINDReport: findReport, NameReport: nameReport)\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "getTenantSaleItem": {
               "code": "import FindMarket from 0x35717efbbce11c74\n\npub fun main(tenant: Address) : TenantSaleItems {\n    let tenantCap = FindMarket.getTenantCapability(tenant) ?? panic(\"No tenant capability is set up. Tenant Address : \".concat(tenant.toString()))\n    let tenantRef = tenantCap.borrow() ?? panic(\"Cannot borrow tenant reference. Tenant Address : \".concat(tenant.toString()))\n    let saleItems = tenantRef.getSaleItems()\n    return TenantSaleItems(findSaleItems: saleItems[\"findSaleItems\"]! ,\n                           tenantSaleItems: saleItems[\"tenantSaleItems\"]! ,\n                           findCuts: saleItems[\"findCuts\"]! )\n\n}\n\npub struct TenantSaleItems {\n    pub let findSaleItems : {String : FindMarket.TenantSaleItem}\n    pub let tenantSaleItems : {String : FindMarket.TenantSaleItem}\n    pub let findCuts : {String : FindMarket.TenantSaleItem} \n\n    init(findSaleItems : {String : FindMarket.TenantSaleItem}, \n         tenantSaleItems : {String : FindMarket.TenantSaleItem},\n         findCuts : {String : FindMarket.TenantSaleItem}) {\n             self.findSaleItems = findSaleItems\n             self.tenantSaleItems = tenantSaleItems \n             self.findCuts = findCuts \n         }\n}",
               "spec": {
                  "order": [
                     "tenant"
                  ],
                  "parameters": {
                     "tenant": "Address"
                  }
               }
            },
            "hasCharity": {
               "code": "import CharityNFT from 0x35717efbbce11c74\n\npub fun main(user: Address) : Bool {\n    let account=getAccount(user)\n    if account.balance == 0.0 {\n        return false\n    }\n    let charityCap = account.getCapability\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection)\n    return charityCap.check()\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "Address"
                  }
               }
            },
            "isFindUser": {
               "code": "import Profile from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\n\npub fun main(user: Address) : Bool {\n\n    let account=getAccount(user)\n    if account.balance == 0.0 {\n        return false\n    }\n    let leaseCap=account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n    let profileCap=account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\n    return leaseCap.check() \u0026\u0026 profileCap.check()\n\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "Address"
                  }
               }
            },
            "resolve": {
               "code": "import FIND from 0x35717efbbce11c74\n\npub fun main(input:String) : Address?{\n    return FIND.resolve(input)\n}",
               "spec": {
                  "order": [
                     "input"
                  ],
                  "parameters": {
                     "input": "String"
                  }
               }
            }
         },
         "transactions": {
            "acceptDirectOfferSoft": {
               "code": "import FindMarketDirectOfferSoft from 0x35717efbbce11c74\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FindViews from 0x35717efbbce11c74\nimport FINDNFTCatalog from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\n\ntransaction(marketplace:Address, id: UInt64) {\n\n    let market : \u0026FindMarketDirectOfferSoft.SaleItemCollection\n    let pointer : FindViews.AuthNFTPointer\n\n    prepare(account: AuthAccount) {\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e())\n        self.market = account.borrow\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection\u003e(from: storagePath)!\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e())\n        let item = FindMarket.assertOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: id)\n        let nftIdentifier = item.getItemType().identifier\n\n        //If this is nil, there must be something wrong with FIND setup\n        // let privatePath = getPrivatePath(nftIdentifier)\n\n        let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier)) \n        let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n        let privatePath = collection.collectionData.privatePath\n\n\n        let providerCap=account.getCapability\u003c\u0026{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e(privatePath)\n        self.pointer= FindViews.AuthNFTPointer(cap: providerCap, id: item.getItemID())\n    }\n\n    execute {\n        self.market.acceptOffer(self.pointer)\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "acceptDirectOfferSoftDUC": {
               "code": "import FindMarketDirectOfferSoft from 0x35717efbbce11c74\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FindViews from 0x35717efbbce11c74\nimport NFTCatalog from 0x324c34e1c517e4db\nimport FINDNFTCatalog from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport TokenForwarding from 0x51ea0e37c27a1f1a\nimport DapperUtilityCoin from 0x82ec283f88a62e65\nimport Profile from 0x35717efbbce11c74\n\ntransaction(dapperAddress: Address, marketplace:Address, id: UInt64) {\n\n    let market : \u0026FindMarketDirectOfferSoft.SaleItemCollection\n    let pointer : FindViews.AuthNFTPointer\n\n    prepare(account: AuthAccount) {\n\n        let ducReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver)\n        if !ducReceiver.check() {\n            let dapper = getAccount(dapperAddress)\n            // Create a new Forwarder resource for DUC and store it in the new account's storage\n            let ducForwarder \u003c- TokenForwarding.createNewForwarder(recipient: dapper.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver))\n            account.save(\u003c-ducForwarder, to: /storage/dapperUtilityCoinReceiver)\n            // Publish a Receiver capability for the new account, which is linked to the DUC Forwarder\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver,target: /storage/dapperUtilityCoinReceiver)\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n        if !profile.hasWallet(\"DUC\") {\n            profile.addWallet(Profile.Wallet( name:\"DUC\", receiver:ducReceiver, balance:getAccount(dapperAddress).getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/dapperUtilityCoinBalance), accept: Type\u003c@DapperUtilityCoin.Vault\u003e(), tags: [\"duc\", \"dapperUtilityCoin\",\"dapper\"]))\n            profile.emitUpdatedEvent()\n        }\n\n\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e())\n        self.market = account.borrow\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection\u003e(from: storagePath)!\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e())\n        let item = FindMarket.assertOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: id)\n        let nftIdentifier = item.getItemType().identifier\n\n        //If this is nil, there must be something wrong with FIND setup\n        // let nft = getCollectionData(nftIdentifier)\n        let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier)) \n        let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n        let nft = collection.collectionData\n\n        let providerCap=account.getCapability\u003c\u0026{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e(nft.privatePath)\n        self.pointer= FindViews.AuthNFTPointer(cap: providerCap, id: item.getItemID())\n\n    }\n\n    execute {\n        self.market.acceptOffer(self.pointer)\n    }\n    \n}",
               "spec": {
                  "order": [
                     "dapperAddress",
                     "marketplace",
                     "id"
                  ],
                  "parameters": {
                     "dapperAddress": "Address",
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "acceptLeaseDirectOfferSoft": {
               "code": "import FindLeaseMarketDirectOfferSoft from 0x35717efbbce11c74\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FindViews from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\nimport FindLeaseMarket from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\n\ntransaction(leaseName: String) {\n\n    let market : \u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection\n    let pointer : FindLeaseMarket.AuthLeasePointer\n\n    prepare(account: AuthAccount) {\n        let marketplace = FindMarket.getTenantAddress(\"findLease\")!\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e())\n        self.market = account.borrow\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(from: storagePath)!\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e())\n        let item = FindLeaseMarket.assertOperationValid(tenant: marketplace, name: leaseName, marketOption: marketOption)\n        let ref = account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from: FIND.LeaseStoragePath) ?? panic(\"Cannot borrow reference to find lease collection. Account : \".concat(account.address.toString()))\n        self.pointer= FindLeaseMarket.AuthLeasePointer(ref: ref, name: leaseName)\n    }\n\n    execute {\n        self.market.acceptOffer(self.pointer)\n    }\n}",
               "spec": {
                  "order": [
                     "leaseName"
                  ],
                  "parameters": {
                     "leaseName": "String"
                  }
               }
            },
            "acceptLeaseDirectOfferSoftDUC": {
               "code": "import FindLeaseMarketDirectOfferSoft from 0x35717efbbce11c74\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FindViews from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\nimport FindLeaseMarket from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport TokenForwarding from 0x51ea0e37c27a1f1a\nimport DapperUtilityCoin from 0x82ec283f88a62e65\nimport Profile from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\n\ntransaction(dapperAddress: Address, leaseName: String) {\n\n    let market : \u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection\n    let pointer : FindLeaseMarket.AuthLeasePointer\n\n    prepare(account: AuthAccount) {\n\n        let ducReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver)\n        if !ducReceiver.check() {\n            let dapper = getAccount(dapperAddress)\n            // Create a new Forwarder resource for DUC and store it in the new account's storage\n            let ducForwarder \u003c- TokenForwarding.createNewForwarder(recipient: dapper.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver))\n            account.save(\u003c-ducForwarder, to: /storage/dapperUtilityCoinReceiver)\n            // Publish a Receiver capability for the new account, which is linked to the DUC Forwarder\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver,target: /storage/dapperUtilityCoinReceiver)\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n        if !profile.hasWallet(\"DUC\") {\n            profile.addWallet(Profile.Wallet( name:\"DUC\", receiver:ducReceiver, balance:getAccount(dapperAddress).getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/dapperUtilityCoinBalance), accept: Type\u003c@DapperUtilityCoin.Vault\u003e(), tags: [\"duc\", \"dapperUtilityCoin\",\"dapper\"]))\n            profile.emitUpdatedEvent()\n        }\n\n        let marketplace = FindMarket.getTenantAddress(\"findLease\")!\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e())\n        self.market = account.borrow\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(from: storagePath)!\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e())\n        let item = FindLeaseMarket.assertOperationValid(tenant: marketplace, name: leaseName, marketOption: marketOption)\n\n        let ref = account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from: FIND.LeaseStoragePath) ?? panic(\"Cannot borrow reference to Find lease collection. Account : \".concat(account.address.toString()))\n        self.pointer= FindLeaseMarket.AuthLeasePointer(ref: ref, name: leaseName)\n\n    }\n\n    execute {\n        self.market.acceptOffer(self.pointer)\n    }\n    \n}",
               "spec": {
                  "order": [
                     "dapperAddress",
                     "leaseName"
                  ],
                  "parameters": {
                     "dapperAddress": "Address",
                     "leaseName": "String"
                  }
               }
            },
            "acceptMultipleDirectOfferSoft": {
               "code": "import FindMarketDirectOfferSoft from 0x35717efbbce11c74\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FindViews from 0x35717efbbce11c74\nimport NFTCatalog from 0x324c34e1c517e4db\nimport FINDNFTCatalog from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\n\ntransaction(marketplace:Address, ids: [UInt64]) {\n\n    let market : \u0026FindMarketDirectOfferSoft.SaleItemCollection\n    let pointer : [FindViews.AuthNFTPointer]\n\n    prepare(account: AuthAccount) {\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e())\n        self.market = account.borrow\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection\u003e(from: storagePath)!\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e())\n\n        var counter = 0\n        self.pointer = []\n        let nfts : {String : NFTCatalog.NFTCollectionData} = {}\n\n        while counter \u003c ids.length {\n            let item = FindMarket.assertOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: ids[counter])\n            var nft : NFTCatalog.NFTCollectionData? = nil\n            let nftIdentifier = item.getItemType().identifier\n\n            if nfts[nftIdentifier] != nil {\n                nft = nfts[nftIdentifier]\n            } else {\n                // nft = getCollectionData(nftIdentifier) \n                let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier)) \n                let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n                nft = collection.collectionData\n                nfts[nftIdentifier] = nft\n            }\n\n            let providerCap=account.getCapability\u003c\u0026{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e(nft!.privatePath)\n            let pointer= FindViews.AuthNFTPointer(cap: providerCap, id: item.getItemID())\n            self.pointer.append(pointer)\n            counter = counter + 1\n        }\n    }\n\n    execute {\n        var counter = 0\n        while counter \u003c ids.length {\n            self.market.acceptOffer(self.pointer[counter])\n            counter = counter + 1\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "ids"
                  ],
                  "parameters": {
                     "ids": "[UInt64]",
                     "marketplace": "Address"
                  }
               }
            },
            "acceptMultipleDirectOfferSoftDUC": {
               "code": "import FindMarketDirectOfferSoft from 0x35717efbbce11c74\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FindViews from 0x35717efbbce11c74\nimport NFTCatalog from 0x324c34e1c517e4db\nimport FINDNFTCatalog from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport TokenForwarding from 0x51ea0e37c27a1f1a\nimport DapperUtilityCoin from 0x82ec283f88a62e65\nimport Profile from 0x35717efbbce11c74\n\ntransaction(dapperAddress: Address, marketplace:Address, ids: [UInt64]) {\n\n    let market : \u0026FindMarketDirectOfferSoft.SaleItemCollection\n    let pointer : [FindViews.AuthNFTPointer]\n\n    prepare(account: AuthAccount) {\n\n        let ducReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver)\n        if !ducReceiver.check() {\n            let dapper = getAccount(dapperAddress)\n            // Create a new Forwarder resource for DUC and store it in the new account's storage\n            let ducForwarder \u003c- TokenForwarding.createNewForwarder(recipient: dapper.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver))\n            account.save(\u003c-ducForwarder, to: /storage/dapperUtilityCoinReceiver)\n            // Publish a Receiver capability for the new account, which is linked to the DUC Forwarder\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver,target: /storage/dapperUtilityCoinReceiver)\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n        if !profile.hasWallet(\"DUC\") {\n            profile.addWallet(Profile.Wallet( name:\"DUC\", receiver:ducReceiver, balance:getAccount(dapperAddress).getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/dapperUtilityCoinBalance), accept: Type\u003c@DapperUtilityCoin.Vault\u003e(), tags: [\"duc\", \"dapperUtilityCoin\",\"dapper\"]))\n            profile.emitUpdatedEvent()\n        }\n\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e())\n        self.market = account.borrow\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection\u003e(from: storagePath)!\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e())\n\n        var counter = 0\n        self.pointer = []\n        let nfts : {String : NFTCatalog.NFTCollectionData} = {}\n\n        while counter \u003c ids.length {\n            let item = FindMarket.assertOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: ids[counter])\n            var nft : NFTCatalog.NFTCollectionData? = nil\n            let nftIdentifier = item.getItemType().identifier\n            let ftType = item.getFtType()\n\n            if nfts[nftIdentifier] != nil {\n                nft = nfts[nftIdentifier]\n            } else {\n                // nft = getCollectionData(nftIdentifier) \n                let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier)) \n                let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n                nft = collection.collectionData\n                nfts[nftIdentifier] = nft\n            }\n\n            let providerCap=account.getCapability\u003c\u0026{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e(nft!.privatePath)\n            let pointer= FindViews.AuthNFTPointer(cap: providerCap, id: item.getItemID())\n            self.pointer.append(pointer)\n            counter = counter + 1\n        }\n\n    }\n\n    execute {\n        var counter = 0\n        while counter \u003c ids.length {\n            self.market.acceptOffer(self.pointer[counter])\n            counter = counter + 1\n        }\n    }\n    \n}",
               "spec": {
                  "order": [
                     "dapperAddress",
                     "marketplace",
                     "ids"
                  ],
                  "parameters": {
                     "dapperAddress": "Address",
                     "ids": "[UInt64]",
                     "marketplace": "Address"
                  }
               }
            },
            "addCuratedCollection": {
               "code": "transaction(name: String, items: [String]) {\n    prepare(account: AuthAccount) {\n\n        let path=/storage/FindCuratedCollections\n        let publicPath=/public/FindCuratedCollections\n\n        var collections : {String: [String]} = {}\n        if account.borrow\u003c\u0026{String: [String]}\u003e(from:path) != nil {\n             collections=account.load\u003c{String: [String]}\u003e(from:path)!\n        }\n        collections[name] = items\n        account.save(collections, to: path)\n        let link = account.getCapability\u003c\u0026{String: [String]}\u003e(publicPath)\n        if !link.check() {\n            account.link\u003c\u0026{String: [String]}\u003e( publicPath, target: path)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "items"
                  ],
                  "parameters": {
                     "items": "[String]",
                     "name": "String"
                  }
               }
            },
            "adminAddForge": {
               "code": "import Admin from 0x35717efbbce11c74\n\ntransaction(name: String, type: String) {\n\n    prepare(admin:AuthAccount) {\n\n        let client= admin.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath)!\n\n        client.addPrivateForgeType(name: name, forgeType: CompositeType(type)!)\n\n    }\n\n}",
               "spec": {
                  "order": [
                     "name",
                     "type"
                  ],
                  "parameters": {
                     "name": "String",
                     "type": "String"
                  }
               }
            },
            "adminAddNFTCatalog": {
               "code": "import MetadataViews from 0x631e88ae7f1d7c20\nimport FINDNFTCatalog from 0x35717efbbce11c74\nimport NFTCatalog from 0x324c34e1c517e4db\nimport FINDNFTCatalogAdmin from 0x35717efbbce11c74\n\ntransaction(\n    collectionIdentifier : String,\n    contractName: String,\n    contractAddress: Address,\n    addressWithNFT: Address,\n    nftID: UInt64,\n    publicPathIdentifier: String\n) {\n    \n    let adminResource: \u0026FINDNFTCatalogAdmin.Admin\n    \n    prepare(acct: AuthAccount) {\n        self.adminResource = acct.borrow\u003c\u0026FINDNFTCatalogAdmin.Admin\u003e(from: FINDNFTCatalogAdmin.AdminStoragePath)!\n    }\n    \n    execute {\n        let nftAccount = getAccount(addressWithNFT)\n        let pubPath = PublicPath(identifier: publicPathIdentifier)!\n        let collectionCap = nftAccount.getCapability\u003c\u0026AnyResource{MetadataViews.ResolverCollection}\u003e(pubPath)\n        assert(collectionCap.check(), message: \"MetadataViews Collection is not set up properly, ensure the Capability was created/linked correctly.\")\n        let collectionRef = collectionCap.borrow()!\n        assert(collectionRef.getIDs().length \u003e 0, message: \"No NFTs exist in this collection.\")\n        let nftResolver = collectionRef.borrowViewResolver(id: nftID)\n        \n        let metadataCollectionData = MetadataViews.getNFTCollectionData(nftResolver)!\n        \n        let collectionData = NFTCatalog.NFTCollectionData(\n            storagePath: metadataCollectionData.storagePath,\n            publicPath: metadataCollectionData.publicPath,\n            privatePath: metadataCollectionData.providerPath,\n            publicLinkedType : metadataCollectionData.publicLinkedType,\n            privateLinkedType : metadataCollectionData.providerLinkedType\n        )\n\n        let collectionDisplay = MetadataViews.getNFTCollectionDisplay(nftResolver)!\n\n        let catalogData = NFTCatalog.NFTCatalogMetadata(\n            contractName: contractName,\n            contractAddress: contractAddress,\n            nftType: nftResolver.getType(),\n            collectionData: collectionData,\n            collectionDisplay : collectionDisplay\n        )\n\n        self.adminResource.addCatalogEntry(collectionIdentifier : collectionIdentifier, metadata : catalogData)\n    }\n}",
               "spec": {
                  "order": [
                     "collectionIdentifier",
                     "contractName",
                     "contractAddress",
                     "addressWithNFT",
                     "nftID",
                     "publicPathIdentifier"
                  ],
                  "parameters": {
                     "addressWithNFT": "Address",
                     "collectionIdentifier": "String",
                     "contractAddress": "Address",
                     "contractName": "String",
                     "nftID": "UInt64",
                     "publicPathIdentifier": "String"
                  }
               }
            },
            "adminAddNFTCatalogDirect": {
               "code": "import MetadataViews from 0x631e88ae7f1d7c20\nimport FINDNFTCatalog from 0x35717efbbce11c74\nimport NFTCatalog from 0x324c34e1c517e4db\nimport FINDNFTCatalogAdmin from 0x35717efbbce11c74\n\ntransaction(\n    collectionIdentifier : String,\n    contractName: String,\n    contractAddress: Address,\n    nftTypeIdentifer: String,\n    storagePathIdentifier: String,\n    publicPathIdentifier: String,\n    privatePathIdentifier: String,\n    publicLinkedTypeIdentifier : String,\n    publicLinkedTypeRestrictions : [String],\n    privateLinkedTypeIdentifier : String,\n    privateLinkedTypeRestrictions : [String],\n    collectionName : String,\n    collectionDescription: String,\n    externalURL : String,\n    squareImageMediaURL : String,\n    squareImageMediaType : String,\n    bannerImageMediaURL : String,\n    bannerImageMediaType : String,\n    socials: {String : String},\n) {\n    \n    let adminResource: \u0026FINDNFTCatalogAdmin.Admin\n    \n    prepare(acct: AuthAccount) {\n        self.adminResource = acct.borrow\u003c\u0026FINDNFTCatalogAdmin.Admin\u003e(from: FINDNFTCatalogAdmin.AdminStoragePath)!\n    }\n    \n    execute {\n        let collectionData = NFTCatalog.NFTCollectionData(\n            storagePath: StoragePath(identifier: storagePathIdentifier)!,\n            publicPath: PublicPath(identifier : publicPathIdentifier)!,\n            privatePath: PrivatePath(identifier: privatePathIdentifier)!,\n            publicLinkedType : RestrictedType(identifier : publicLinkedTypeIdentifier, restrictions: publicLinkedTypeRestrictions)!,\n            privateLinkedType : RestrictedType(identifier : privateLinkedTypeIdentifier, restrictions: privateLinkedTypeRestrictions)!\n        )\n\n        let squareMedia = MetadataViews.Media(\n                        file: MetadataViews.HTTPFile(\n                            url: squareImageMediaURL\n                        ),\n                        mediaType: squareImageMediaURL\n                    )\n        \n        let bannerMedia = MetadataViews.Media(\n                        file: MetadataViews.HTTPFile(\n                            url: bannerImageMediaURL\n                        ),\n                        mediaType: bannerImageMediaURL\n                    )\n\n        let socialsStruct : {String : MetadataViews.ExternalURL} = {}\n        for key in socials.keys {\n            socialsStruct[key] =  MetadataViews.ExternalURL(socials[key]!)\n        }\n        \n        let collectionDisplay = MetadataViews.NFTCollectionDisplay(\n            name: collectionName,\n            description: collectionDescription,\n            externalURL: MetadataViews.ExternalURL(externalURL),\n            squareImage: squareMedia,\n            bannerImage: bannerMedia,\n            socials: socialsStruct\n        )\n\n        let catalogData = NFTCatalog.NFTCatalogMetadata(\n            contractName: contractName,\n            contractAddress: contractAddress,\n            nftType: CompositeType(nftTypeIdentifer)!,\n            collectionData: collectionData,\n            collectionDisplay : collectionDisplay\n        )\n\n        self.adminResource.addCatalogEntry(collectionIdentifier : collectionIdentifier, metadata : catalogData)\n    }\n}",
               "spec": {
                  "order": [
                     "collectionIdentifier",
                     "contractName",
                     "contractAddress",
                     "nftTypeIdentifer",
                     "storagePathIdentifier",
                     "publicPathIdentifier",
                     "privatePathIdentifier",
                     "publicLinkedTypeIdentifier",
                     "publicLinkedTypeRestrictions",
                     "privateLinkedTypeIdentifier",
                     "privateLinkedTypeRestrictions",
                     "collectionName",
                     "collectionDescription",
                     "externalURL",
                     "squareImageMediaURL",
                     "squareImageMediaType",
                     "bannerImageMediaURL",
                     "bannerImageMediaType",
                     "socials"
                  ],
                  "parameters": {
                     "bannerImageMediaType": "String",
                     "bannerImageMediaURL": "String",
                     "collectionDescription": "String",
                     "collectionIdentifier": "String",
                     "collectionName": "String",
                     "contractAddress": "Address",
                     "contractName": "String",
                     "externalURL": "String",
                     "nftTypeIdentifer": "String",
                     "privateLinkedTypeIdentifier": "String",
                     "privateLinkedTypeRestrictions": "[String]",
                     "privatePathIdentifier": "String",
                     "publicLinkedTypeIdentifier": "String",
                     "publicLinkedTypeRestrictions": "[String]",
                     "publicPathIdentifier": "String",
                     "socials": "{String: String}",
                     "squareImageMediaType": "String",
                     "squareImageMediaURL": "String",
                     "storagePathIdentifier": "String"
                  }
               }
            },
            "adminInitDUC": {
               "code": "import FungibleToken from 0x9a0766d93b6608b7\nimport DapperUtilityCoin from 0x82ec283f88a62e65\nimport TokenForwarding from 0x51ea0e37c27a1f1a\n\n\ntransaction(dapperAddress:Address) {\n\n    prepare(acct: AuthAccount) {\n        // Get a Receiver reference for the Dapper account that will be the recipient of the forwarded DUC\n        let dapper = getAccount(dapperAddress)\n      let dapperDUCReceiver = dapper.getCapability(/public/dapperUtilityCoinReceiver)\n\n      // Create a new Forwarder resource for DUC and store it in the new account's storage\n      let ducForwarder \u003c- TokenForwarding.createNewForwarder(recipient: dapperDUCReceiver)\n      acct.save(\u003c-ducForwarder, to: /storage/dapperUtilityCoinReceiver)\n\n      // Publish a Receiver capability for the new account, which is linked to the DUC Forwarder\n      acct.link\u003c\u0026{FungibleToken.Receiver}\u003e(\n      /public/dapperUtilityCoinReceiver,\n      target: /storage/dapperUtilityCoinReceiver\n      )\n    }\n}",
               "spec": {
                  "order": [
                     "dapperAddress"
                  ],
                  "parameters": {
                     "dapperAddress": "Address"
                  }
               }
            },
            "adminMainnetAddItem": {
               "code": "import Admin from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\nimport FlowToken from 0x7e60df042a9c0868\n\ntransaction(tenant: Address, ftName: String, ftTypes: [String] , nftName: String, nftTypes: [String], listingName: String, listingTypes: [String]) {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n        \n    }\n    execute{\n\n        let ft : [Type] = []\n        for type in ftTypes {\n            ft.append(CompositeType(type)!)\n        }\n\n        let nft : [Type] = []\n        for type in nftTypes {\n            nft.append(CompositeType(type)!)\n        }\n\n        let listing : [Type] = []\n        for type in listingTypes {\n            listing.append(CompositeType(type)!)\n        }\n\n        let rules : [FindMarket.TenantRule] = []\n        if listing.length \u003e 0 {\n            rules.append(FindMarket.TenantRule(name:listingName, types:listing, ruleType: \"listing\", allow: true))\n        }\n\n        if ft.length \u003e 0 {\n            rules.append(FindMarket.TenantRule(name:ftName, types:ft, ruleType: \"ft\", allow: true))\n        }\n\n        if nft.length \u003e 0 {\n            rules.append(FindMarket.TenantRule(name:nftName, types:nft, ruleType: \"nft\", allow: true))\n        }\n        \n\n        let tenantSaleItem = FindMarket.TenantSaleItem(\n            name: listingName.concat(ftName).concat(nftName), \n            cut: nil, \n            rules: rules, \n            status:\"active\"\n        )\n\n        self.adminRef.setMarketOption(tenant: tenant, saleItem: tenantSaleItem)\n        \n    }\n}",
               "spec": {
                  "order": [
                     "tenant",
                     "ftName",
                     "ftTypes",
                     "nftName",
                     "nftTypes",
                     "listingName",
                     "listingTypes"
                  ],
                  "parameters": {
                     "ftName": "String",
                     "ftTypes": "[String]",
                     "listingName": "String",
                     "listingTypes": "[String]",
                     "nftName": "String",
                     "nftTypes": "[String]",
                     "tenant": "Address"
                  }
               }
            },
            "adminMintCharity": {
               "code": "import NonFungibleToken from 0x631e88ae7f1d7c20\nimport CharityNFT from 0x35717efbbce11c74\nimport Admin from 0x35717efbbce11c74\n\n//mint an art and add it to a users collection\ntransaction(\n    name: String,\n    image: String,\n    thumbnail: String,\n    originUrl: String,\n    description: String,\n    recipient: Address\n) {\n    let receiverCap: Capability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e\n    let client: \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount) {\n        self.client= account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath)!\n        self.receiverCap= getAccount(recipient).getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath)\n    }\n\n    execute {\n        let metadata = {\"name\" : name, \"image\" : image, \"thumbnail\": thumbnail, \"originUrl\": originUrl, \"description\":description}\n        self.client.mintCharity(metadata: metadata, recipient: self.receiverCap)\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "image",
                     "thumbnail",
                     "originUrl",
                     "description",
                     "recipient"
                  ],
                  "parameters": {
                     "description": "String",
                     "image": "String",
                     "name": "String",
                     "originUrl": "String",
                     "recipient": "Address",
                     "thumbnail": "String"
                  }
               }
            },
            "adminMintFindDandy": {
               "code": "import FIND from 0x35717efbbce11c74\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport Dandy from 0x35717efbbce11c74\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FindForge from 0x35717efbbce11c74\n\ntransaction(name: String, maxEdition:UInt64, nftName:String, nftDescription:String, folderHash:String) {\n    prepare(account: AuthAccount) {\n\n        let finLeases= account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n        let lease=finLeases.borrow(name)\n        let forgeType = Dandy.getForgeType()\n\n        let dandyCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        let thumbNail=MetadataViews.IPFSFile(cid:folderHash, path: \"thumbnail.webp\")\n        let fullsize=MetadataViews.IPFSFile(cid:folderHash, path: \"fullsize.webp\")\n        let mediaFullsize=MetadataViews.Media(file: fullsize, mediaType: \"image/webp\")\n        let mediaThumbnail=MetadataViews.Media(file: thumbNail, mediaType: \"image/webp\")\n\n        let nftReceiver=account.getCapability\u003c\u0026{NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(Dandy.CollectionPublicPath).borrow() ?? panic(\"Cannot borrow reference to Dandy collection.\")\n\n        let traits = MetadataViews.Traits([])\n        traits.addTrait(MetadataViews.Trait(name: \"Creator\", value: \".find\", displayType:\"Author\", rarity:nil))\n\n        let collection=dandyCap.borrow()!\n        var i:UInt64=1\n\n        while i \u003c= maxEdition {\n\n            let editioned= MetadataViews.Edition(name: nil, number:i, max:maxEdition)\n            let set= MetadataViews.Edition(name: \"set\", number:i, max:maxEdition)\n            let editions = MetadataViews.Editions([editioned, set])\n\n            let schemas: [AnyStruct] = [ editions, MetadataViews.Medias([mediaFullsize, mediaThumbnail]), traits ]\n            \n            let mintData = Dandy.DandyInfo(name: nftName, \n                                                description: nftDescription, \n                                                thumbnail: mediaThumbnail, \n                                                schemas: schemas, \n                                                externalUrlPrefix:\"https://find.xyz/\".concat(name).concat(\"/collection/Dandy\"))\n            \n            FindForge.mint(lease: lease, forgeType: forgeType, data: mintData, receiver: nftReceiver)\n        \n            i=i+1\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "maxEdition",
                     "nftName",
                     "nftDescription",
                     "folderHash"
                  ],
                  "parameters": {
                     "folderHash": "String",
                     "maxEdition": "UInt64",
                     "name": "String",
                     "nftDescription": "String",
                     "nftName": "String"
                  }
               }
            },
            "adminRecreateDandy": {
               "code": "import NonFungibleToken from 0x631e88ae7f1d7c20\nimport Dandy from 0x35717efbbce11c74\nimport MetadataViews from 0x631e88ae7f1d7c20\n\ntransaction {\n    prepare(account: AuthAccount) {\n        account.unlink(Dandy.CollectionPrivatePath)\n        account.unlink(Dandy.CollectionPublicPath)\n        destroy \u003c- account.load\u003c@NonFungibleToken.Collection\u003e(from:Dandy.CollectionStoragePath)\n\n        let dandyCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n    }\n}",
               "spec": {
                  "order": [],
                  "parameters": {}
               }
            },
            "adminRegisterName": {
               "code": "import FIND from 0x35717efbbce11c74\nimport Admin from 0x35717efbbce11c74\nimport Profile from 0x35717efbbce11c74\n\ntransaction(names: [String], user: Address) {\n\n    prepare(account: AuthAccount) {\n\n        let userAccount=getAccount(user)\n        let profileCap = userAccount.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        let leaseCollectionCap=userAccount.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        let adminClient=account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath)!\n\n        for name in names {\n            adminClient.register(name: name,  profile: profileCap, leases: leaseCollectionCap)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "names",
                     "user"
                  ],
                  "parameters": {
                     "names": "[String]",
                     "user": "Address"
                  }
               }
            },
            "adminRemoveFTInfoByAlias": {
               "code": "import Admin from 0x35717efbbce11c74\n\ntransaction(alias: String) {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n        \n    }\n\n    execute{\n\n        self.adminRef.removeFTInfoByAlias(alias)\n\n    }\n}",
               "spec": {
                  "order": [
                     "alias"
                  ],
                  "parameters": {
                     "alias": "String"
                  }
               }
            },
            "adminRemoveFTInfoByTypeIdentifier": {
               "code": "import Admin from 0x35717efbbce11c74\n\ntransaction(typeIdentifier: String) {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n        \n    }\n\n    execute{\n\n        self.adminRef.removeFTInfoByTypeIdentifier(typeIdentifier) \n       \n    }\n}",
               "spec": {
                  "order": [
                     "typeIdentifier"
                  ],
                  "parameters": {
                     "typeIdentifier": "String"
                  }
               }
            },
            "adminRemoveForge": {
               "code": "import Admin from 0x35717efbbce11c74\n\ntransaction(type: String) {\n\n    prepare(admin:AuthAccount) {\n\n        let client= admin.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath)!\n\n        client.removeForgeType(CompositeType(type)!)\n\n    }\n\n}",
               "spec": {
                  "order": [
                     "type"
                  ],
                  "parameters": {
                     "type": "String"
                  }
               }
            },
            "adminRemoveNFTCatalog": {
               "code": "import MetadataViews from 0x631e88ae7f1d7c20\nimport FINDNFTCatalog from 0x35717efbbce11c74\nimport FINDNFTCatalogAdmin from 0x35717efbbce11c74\n\ntransaction(\n    collectionIdentifier : String\n) {\n    let adminProxyResource : \u0026FINDNFTCatalogAdmin.Admin\n\n    prepare(acct: AuthAccount) { \n        self.adminProxyResource = acct.borrow\u003c\u0026FINDNFTCatalogAdmin.Admin\u003e(from : FINDNFTCatalogAdmin.AdminStoragePath)!\n    }\n\n    execute {     \n        self.adminProxyResource.removeCatalogEntry(collectionIdentifier : collectionIdentifier)\n    }\n}",
               "spec": {
                  "order": [
                     "collectionIdentifier"
                  ],
                  "parameters": {
                     "collectionIdentifier": "String"
                  }
               }
            },
            "adminRemoveNFTInfoByAlias": {
               "code": "import Admin from 0x35717efbbce11c74\n\ntransaction(alias: String) {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n        \n    }\n\n    execute{\n\n        self.adminRef.removeNFTInfoByAlias(alias)\n        \n    }\n}",
               "spec": {
                  "order": [
                     "alias"
                  ],
                  "parameters": {
                     "alias": "String"
                  }
               }
            },
            "adminRemoveNFTInfoByTypeIdentifier": {
               "code": "import Admin from 0x35717efbbce11c74\n\ntransaction(typeIdentifier: String) {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n        \n    }\n\n    execute{\n\n        self.adminRef.removeNFTInfoByTypeIdentifier(typeIdentifier) \n       \n    }\n}",
               "spec": {
                  "order": [
                     "typeIdentifier"
                  ],
                  "parameters": {
                     "typeIdentifier": "String"
                  }
               }
            },
            "adminRemoveProfileBan": {
               "code": "import Profile from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\n\ntransaction(user: String) {\n    prepare(acct: AuthAccount) {\n        let profile =acct.borrow\u003c\u0026Profile.User\u003e(from:Profile.storagePath)!\n        let address =FIND.resolve(user) ?? panic(\"Not a registered name or valid address.\")\n        profile.removeBan(address)\n    }\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "adminSendFUSD": {
               "code": "import FungibleToken from 0x9a0766d93b6608b7\nimport FUSD from 0xe223d8a629e49c68\n\ntransaction(receiver: Address, amount:UFix64) {\n    prepare(acct: AuthAccount) {\n        let receiver = getAccount(receiver).getCapability\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e(/public/fusdReceiver).borrow() ?? panic(\"Cannot borrow FUSD receiver\")\n\n        let sender = acct.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault)\n            ?? panic(\"Cannot borrow FUSD vault from authAcct storage\")\n\n        receiver.deposit(from: \u003c- sender.withdraw(amount:amount))\n    }\n}",
               "spec": {
                  "order": [
                     "receiver",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "receiver": "Address"
                  }
               }
            },
            "adminSetAddonPrice": {
               "code": "import Admin from 0x35717efbbce11c74\n\ntransaction(addon:String, price:UFix64) {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n        \n    }\n    execute{\n        self.adminRef.setAddonPrice(name: addon, price: price)\n    }\n}",
               "spec": {
                  "order": [
                     "addon",
                     "price"
                  ],
                  "parameters": {
                     "addon": "String",
                     "price": "UFix64"
                  }
               }
            },
            "adminSetFTInfo_duc": {
               "code": "import Admin from 0x35717efbbce11c74\nimport DapperUtilityCoin from 0x82ec283f88a62e65\n\ntransaction() {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n    }\n\n    execute{\n        let type: Type = Type\u003c@DapperUtilityCoin.Vault\u003e()\n        self.adminRef.setFTInfo(alias: \"DUC\", type: type, tag:[\"dapper utility coin\"] , icon: \"https://assets.website-files.com/5bf4437b68f8b29e67b7ebdc/61a159f8899a41507bc46bcb_feature%20image%20dapper%20post.png\", receiverPath: /public/dapperUtilityCoinReceiver, balancePath: /public/dapperUtilityCoinBalance, vaultPath: /storage/dapperUtilityCoinVault)\n    }\n}",
               "spec": {
                  "order": [],
                  "parameters": {}
               }
            },
            "adminSetFTInfo_flow": {
               "code": "import Admin from 0x35717efbbce11c74\nimport FlowToken from 0x7e60df042a9c0868\n\ntransaction() {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n    }\n\n    execute{\n        let type: Type = Type\u003c@FlowToken.Vault\u003e()\n        self.adminRef.setFTInfo(alias: \"Flow\", type: type, tag:[\"utility coin\"] , icon: \"https://static.flowscan.org/mainnet/icons/A.1654653399040a61.FlowToken.png\", receiverPath: /public/flowTokenReceiver, balancePath: /public/flowTokenBalance, vaultPath: /storage/flowTokenVault)\n    }\n}",
               "spec": {
                  "order": [],
                  "parameters": {}
               }
            },
            "adminSetFTInfo_fusd": {
               "code": "import Admin from 0x35717efbbce11c74\nimport FUSD from 0xe223d8a629e49c68\n\ntransaction() {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n    }\n\n    execute{\n        let type: Type = Type\u003c@FUSD.Vault\u003e()\n        self.adminRef.setFTInfo(alias: \"FUSD\", type: type, tag:[\"stablecoin\"], icon: \"https://static.flowscan.org/mainnet/icons/A.3c5959b568896393.FUSD.png\", receiverPath: /public/fusdReceiver, balancePath: /public/fusdBalance, vaultPath: /storage/fusdVault)\n    }\n}",
               "spec": {
                  "order": [],
                  "parameters": {}
               }
            },
            "adminSetFTInfo_usdc": {
               "code": "import Admin from 0x35717efbbce11c74\nimport FiatToken from 0xa983fecbed621163\n\ntransaction() {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n    }\n\n    execute{\n        let type: Type = Type\u003c@FiatToken.Vault\u003e()\n        self.adminRef.setFTInfo(alias: \"USDC\", type: type, tag:[\"stablecoin\"] , icon: \"https://static.flowscan.org/mainnet/icons/A.b19436aae4d94622.FiatToken.png\", receiverPath: FiatToken.VaultReceiverPubPath, balancePath: FiatToken.VaultBalancePubPath, vaultPath: FiatToken.VaultStoragePath)\n    }\n}",
               "spec": {
                  "order": [],
                  "parameters": {}
               }
            },
            "adminSetFindCut": {
               "code": "import Admin from 0x35717efbbce11c74\n\ntransaction(tenant: Address, cut: UFix64){\n    prepare(account: AuthAccount){\n        let adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n\n        adminRef.setFindCut(tenant: tenant, saleItemName:\"findRoyalty\", cut: cut, rules: nil, status: \"active\")\n    }\n}",
               "spec": {
                  "order": [
                     "tenant",
                     "cut"
                  ],
                  "parameters": {
                     "cut": "UFix64",
                     "tenant": "Address"
                  }
               }
            },
            "adminSetNFTInfo_Dandy": {
               "code": "import Admin from 0x35717efbbce11c74\nimport Dandy from 0x35717efbbce11c74\n\ntransaction() {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n        \n    }\n    execute{\n        let type: Type = Type\u003c@Dandy.NFT\u003e()\n        self.adminRef.setNFTInfo(alias: \"Dandy\", type: type, icon: nil, providerPath: Dandy.CollectionPrivatePath, publicPath: Dandy.CollectionPublicPath, storagePath: Dandy.CollectionStoragePath, allowedFTTypes: nil, address: 0xf8d6e0586b0a20c7, externalFixedUrl: \"find.xyz\")\n\n    }\n}",
               "spec": {
                  "order": [],
                  "parameters": {}
               }
            },
            "adminSetNFTInfo_FLOAT": {
               "code": "import Admin from 0x35717efbbce11c74\n\ntransaction() {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n\n    }\n    execute{\n        if let type = CompositeType(\"A.0afe396ebc8eee65.FLOAT.NFT\") { // Testnet Address \n            self.adminRef.setNFTInfo(alias: \"FLOAT\", type: type, icon: \"https://testnet.floats.city/floatlogowebpage.png\", providerPath: /private/FLOATCollectionPublicPath, publicPath: /public/FLOATCollectionPublicPath, storagePath: /storage/FLOATCollectionStoragePath, allowedFTTypes: nil, address: 0x0afe396ebc8eee65, externalFixedUrl: \"testnet.floats.city\")\n            \n        } else if let type = CompositeType(\"A.2d4c3caffbeab845.FLOAT.NFT\") {\n            self.adminRef.setNFTInfo(alias: \"FLOAT\", type: type, icon: \"https://floats.city/floatlogowebpage.png\", providerPath: /private/FLOATCollectionPublicPath, publicPath: /public/FLOATCollectionPublicPath, storagePath: /storage/FLOATCollectionStoragePath, allowedFTTypes: nil, address: 0x2d4c3caffbeab845, externalFixedUrl: \"floats.city\")\n        }\n\n    }\n}",
               "spec": {
                  "order": [],
                  "parameters": {}
               }
            },
            "adminSetNFTInfo_Neo": {
               "code": "import Admin from 0x35717efbbce11c74\nimport NeoVoucher from 0xd6b39e5b5b367aad\n\ntransaction() {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n        \n    }\n    execute{\n\n        self.adminRef.setNFTInfo(alias: \"NeoVoucher\", type: Type\u003c@NeoVoucher.NFT\u003e(), icon: \"https://test.neocollectibles.xyz/pages/images/neo-collectibles-logo.webp\", providerPath: /private/neoVoucherCollection, publicPath: NeoVoucher.CollectionPublicPath, storagePath: NeoVoucher.CollectionStoragePath, allowedFTTypes: nil, address: 0xd6b39e5b5b367aad, externalFixedUrl: \"test.neocollectibles.xyx\")\n\n    }\n}",
               "spec": {
                  "order": [],
                  "parameters": {}
               }
            },
            "adminSetProfileBan": {
               "code": "import Profile from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\n\ntransaction(user: String) {\n    prepare(acct: AuthAccount) {\n        let profile =acct.borrow\u003c\u0026Profile.User\u003e(from:Profile.storagePath)!\n        let address =FIND.resolve(user) ?? panic(\"Not a registered name or valid address.\")\n        profile.addBan(address)\n    }\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "adminSetSellDUCLeaseRules": {
               "code": "import FindMarket from 0x35717efbbce11c74\nimport Admin from 0x35717efbbce11c74\nimport DapperUtilityCoin from 0x82ec283f88a62e65\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FIND from 0x35717efbbce11c74\n\ntransaction(tenant: Address) {\n    prepare(account: AuthAccount){\n        let adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n\n        let rules = [\n            FindMarket.TenantRule(name:\"DUC\", types:[Type\u003c@DapperUtilityCoin.Vault\u003e()], ruleType: \"ft\", allow: true),\n            FindMarket.TenantRule(name:\"Lease\", types:[ Type\u003c@FIND.Lease\u003e()], ruleType: \"nft\", allow: true)\n            ]\n\n        let ducExample = FindMarket.TenantSaleItem(name:\"DUCLease\", cut: nil, rules:rules, status: \"active\" )\n\n        adminRef.setMarketOption(tenant: tenant, saleItem: ducExample)\n\n        let cap = getAccount(account.address).getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver)\n        adminRef.addFindCut(tenant: tenant, FindCutName: \"findDapperRoyalty\", rayalty: MetadataViews.Royalty(receiver: cap, cut: 0.02, description: \"find\"), rules: rules, status: \"active\")\n\n    }\n}",
               "spec": {
                  "order": [
                     "tenant"
                  ],
                  "parameters": {
                     "tenant": "Address"
                  }
               }
            },
            "adminSetSellDandyForFUSD": {
               "code": "import FindMarket from 0x35717efbbce11c74\nimport Admin from 0x35717efbbce11c74\nimport FUSD from 0xe223d8a629e49c68\nimport Dandy from 0x35717efbbce11c74\nimport FindMarketSale from 0x35717efbbce11c74\nimport FindMarketAuctionEscrow from 0x35717efbbce11c74\nimport FindMarketAuctionSoft from 0x35717efbbce11c74\nimport FindMarketDirectOfferEscrow from 0x35717efbbce11c74\nimport FindMarketDirectOfferSoft from 0x35717efbbce11c74\n\n\ntransaction(tenant: Address, market: String){\n    prepare(account: AuthAccount){\n        let adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n\n        var marketType : [Type] = [Type\u003c@FindMarketSale.SaleItem\u003e()]\n        switch market {\n            case \"AuctionEscrow\" :\n                marketType = [Type\u003c@FindMarketAuctionEscrow.SaleItem\u003e()]\n\n            case \"AuctionSoft\" :\n                marketType = [Type\u003c@FindMarketAuctionSoft.SaleItem\u003e()]\n\n            case \"DirectOfferEscrow\" :\n                marketType = [Type\u003c@FindMarketDirectOfferEscrow.SaleItem\u003e()]\n\n            case \"DirectOfferSoft\" :\n                marketType = [Type\u003c@FindMarketDirectOfferSoft.SaleItem\u003e()]\n\n        }\n\n        let saleItem = FindMarket.TenantSaleItem(name:\"FlowDandy\".concat(market), cut: nil, rules:[\n            FindMarket.TenantRule(name:\"Flow\", types:[Type\u003c@FUSD.Vault\u003e()], ruleType: \"ft\", allow: true),\n            FindMarket.TenantRule(name:\"Dandy\", types:[Type\u003c@Dandy.NFT\u003e()], ruleType: \"nft\", allow: true),\n            FindMarket.TenantRule(name: market, types:marketType, ruleType: \"listing\", allow: true)\n            ], \n            status: \"active\"\n        )\n\n        adminRef.setMarketOption(tenant: tenant, saleItem: saleItem)\n    }\n}",
               "spec": {
                  "order": [
                     "tenant",
                     "market"
                  ],
                  "parameters": {
                     "market": "String",
                     "tenant": "Address"
                  }
               }
            },
            "adminSetSellDandyForFlow": {
               "code": "import FindMarket from 0x35717efbbce11c74\nimport Admin from 0x35717efbbce11c74\nimport FlowToken from 0x7e60df042a9c0868\nimport Dandy from 0x35717efbbce11c74\nimport FindMarketSale from 0x35717efbbce11c74\nimport FindMarketAuctionEscrow from 0x35717efbbce11c74\nimport FindMarketAuctionSoft from 0x35717efbbce11c74\nimport FindMarketDirectOfferEscrow from 0x35717efbbce11c74\nimport FindMarketDirectOfferSoft from 0x35717efbbce11c74\n\n\ntransaction(tenant: Address, market: String){\n    prepare(account: AuthAccount){\n        let adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n\n        var marketType : [Type] = [Type\u003c@FindMarketSale.SaleItem\u003e()]\n        switch market {\n            case \"AuctionEscrow\" :\n                marketType = [Type\u003c@FindMarketAuctionEscrow.SaleItem\u003e()]\n\n            case \"AuctionSoft\" :\n                marketType = [Type\u003c@FindMarketAuctionSoft.SaleItem\u003e()]\n\n            case \"DirectOfferEscrow\" :\n                marketType = [Type\u003c@FindMarketDirectOfferEscrow.SaleItem\u003e()]\n\n            case \"DirectOfferSoft\" :\n                marketType = [Type\u003c@FindMarketDirectOfferSoft.SaleItem\u003e()]\n\n        }\n\n        let saleItem = FindMarket.TenantSaleItem(name:\"FlowDandy\".concat(market), cut: nil, rules:[\n            FindMarket.TenantRule(name:\"Flow\", types:[Type\u003c@FlowToken.Vault\u003e()], ruleType: \"ft\", allow: true),\n            FindMarket.TenantRule(name:\"Dandy\", types:[Type\u003c@Dandy.NFT\u003e()], ruleType: \"nft\", allow: true),\n            FindMarket.TenantRule(name: market, types:marketType, ruleType: \"listing\", allow: true)\n            ], \n            status: \"active\"\n        )\n\n        adminRef.setMarketOption(tenant: tenant, saleItem: saleItem)\n    }\n}",
               "spec": {
                  "order": [
                     "tenant",
                     "market"
                  ],
                  "parameters": {
                     "market": "String",
                     "tenant": "Address"
                  }
               }
            },
            "adminSetSellDandyRules": {
               "code": "import FindMarket from 0x35717efbbce11c74\nimport Admin from 0x35717efbbce11c74\nimport FlowToken from 0x7e60df042a9c0868\nimport FUSD from 0xe223d8a629e49c68\nimport Dandy from 0x35717efbbce11c74\n\ntransaction(tenant: Address) {\n    prepare(account: AuthAccount){\n        let adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n\n        let fusdDandy = FindMarket.TenantSaleItem(name:\"FUSDDandy\", cut: nil, rules:[\n            FindMarket.TenantRule(name:\"FUSD\", types:[Type\u003c@FUSD.Vault\u003e()], ruleType: \"ft\", allow: true),\n            FindMarket.TenantRule(name:\"Dandy\", types:[ Type\u003c@Dandy.NFT\u003e()], ruleType: \"nft\", allow: true)\n            ], \n            status: \"active\"\n        )\n\n        let flowDandy = FindMarket.TenantSaleItem(name:\"FlowDandy\", cut: nil, rules:[\n            FindMarket.TenantRule(name:\"Flow\", types:[Type\u003c@FlowToken.Vault\u003e()], ruleType: \"ft\", allow: true),\n            FindMarket.TenantRule(name:\"Dandy\", types:[ Type\u003c@Dandy.NFT\u003e()], ruleType: \"nft\", allow: true)\n            ], \n            status: \"active\"\n        )\n\n        adminRef.setMarketOption(tenant: tenant, saleItem: fusdDandy)\n        adminRef.setMarketOption(tenant: tenant, saleItem: flowDandy)\n\n    }\n}",
               "spec": {
                  "order": [
                     "tenant"
                  ],
                  "parameters": {
                     "tenant": "Address"
                  }
               }
            },
            "adminSetSellLeaseForFlow": {
               "code": "import FindMarket from 0x35717efbbce11c74\nimport Admin from 0x35717efbbce11c74\nimport FlowToken from 0x7e60df042a9c0868\nimport FIND from 0x35717efbbce11c74\nimport FindLeaseMarketSale from 0x35717efbbce11c74\nimport FindLeaseMarketAuctionSoft from 0x35717efbbce11c74\nimport FindLeaseMarketDirectOfferSoft from 0x35717efbbce11c74\n\ntransaction(tenant: Address, market: String){\n    prepare(account: AuthAccount){\n        let adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n\n        var marketType : [Type] = [Type\u003c@FindLeaseMarketSale.SaleItem\u003e()]\n        switch market {\n            // case \"AuctionEscrow\" :\n            //     marketType = [Type\u003c@FindLeaseMarketAuctionEscrow.SaleItem\u003e()]\n\n            case \"AuctionSoft\" :\n                marketType = [Type\u003c@FindLeaseMarketAuctionSoft.SaleItem\u003e()]\n\n            // case \"DirectOfferEscrow\" :\n            //     marketType = [Type\u003c@FindLeaseMarketDirectOfferEscrow.SaleItem\u003e()]\n\n            case \"DirectOfferSoft\" :\n                marketType = [Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItem\u003e()]\n\n        }\n\n        let saleItem = FindMarket.TenantSaleItem(name:\"FlowLease\".concat(market), cut: nil, rules:[\n            FindMarket.TenantRule(name:\"Flow\", types:[Type\u003c@FlowToken.Vault\u003e()], ruleType: \"ft\", allow: true),\n            FindMarket.TenantRule(name:\"Lease\", types:[Type\u003c@FIND.Lease\u003e()], ruleType: \"nft\", allow: true),\n            FindMarket.TenantRule(name: market, types:marketType, ruleType: \"listing\", allow: true)\n            ], \n            status: \"active\"\n        )\n\n        adminRef.setMarketOption(tenant: tenant, saleItem: saleItem)\n    }\n}",
               "spec": {
                  "order": [
                     "tenant",
                     "market"
                  ],
                  "parameters": {
                     "market": "String",
                     "tenant": "Address"
                  }
               }
            },
            "adminTestnetAddBeam": {
               "code": "import Admin from 0x35717efbbce11c74\n// import Beam from 0x6085ae87e78e1433\nimport FindMarket from 0x35717efbbce11c74\nimport FlowToken from 0x7e60df042a9c0868\n\ntransaction(tenant:Address) {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n        \n    }\n    execute{\n        let nftType = CompositeType(\"A.6085ae87e78e1433.Beam.NFT\")!\n        self.adminRef.setNFTInfo(alias: \"Beam\", type: nftType, icon: \"https://frightclub.niftory.com/fc_black_logo_round.svg\", providerPath: /private/BeamCollection001, publicPath: /public/BeamCollection001, storagePath: /storage/BeamCollection001, allowedFTTypes: nil, address: 0x6085ae87e78e1433, externalFixedUrl: \"frightclub.niftory.com\")\n\n        let rules = [\n            FindMarket.TenantRule(name:\"Flow\", types:[Type\u003c@FlowToken.Vault\u003e()], ruleType: \"ft\", allow: true),\n            FindMarket.TenantRule(name:\"Beam\", types:[nftType], ruleType: \"nft\", allow: true)\n        ]\n\n        let tenantSaleItem = FindMarket.TenantSaleItem(\n            name: \"FlowBeam\", \n            cut: nil, \n            rules: rules, \n            status:\"active\"\n        )\n\n        self.adminRef.setMarketOption(tenant: tenant, saleItem: tenantSaleItem)\n \n    }\n}",
               "spec": {
                  "order": [
                     "tenant"
                  ],
                  "parameters": {
                     "tenant": "Address"
                  }
               }
            },
            "adminTestnetAddBl0x": {
               "code": "import Admin from 0x35717efbbce11c74\nimport Bl0x from 0xe8124d8428980aa6\nimport FindMarket from 0x35717efbbce11c74\nimport FlowToken from 0x7e60df042a9c0868\n\ntransaction(tenant: Address) {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n        \n    }\n    execute{\n        self.adminRef.setNFTInfo(\n            alias: \"Bl0x\", \n            type: Type\u003c@Bl0x.NFT\u003e(), \n            icon: \"https://global-uploads.webflow.com/60f008ba9757da0940af288e/626e4af22f80f09e2783df44_blox.jpg\", \n            providerPath: Bl0x.CollectionPrivatePath, \n            publicPath: Bl0x.CollectionPublicPath, \n            storagePath: Bl0x.CollectionStoragePath, \n            allowedFTTypes: nil, \n            address:0xe8124d8428980aa6, externalFixedUrl: \"bl0x-5ccsb92pb-findonflow.vercel.app\")\n\n        let rules = [\n            FindMarket.TenantRule(name:\"Flow\", types:[Type\u003c@FlowToken.Vault\u003e()], ruleType: \"ft\", allow: true),\n            FindMarket.TenantRule(name:\"Bl0x\", types:[Type\u003c@Bl0x.NFT\u003e()], ruleType: \"nft\", allow: true)\n        ]\n\n        let tenantSaleItem = FindMarket.TenantSaleItem(\n            name: \"FlowBl0x\", \n            cut: nil, \n            rules: rules, \n            status:\"active\"\n        )\n\n        self.adminRef.setMarketOption(tenant: tenant, saleItem: tenantSaleItem)\n        \n    }\n}",
               "spec": {
                  "order": [
                     "tenant"
                  ],
                  "parameters": {
                     "tenant": "Address"
                  }
               }
            },
            "adminTestnetAddFlovatar": {
               "code": "import Admin from 0x35717efbbce11c74\nimport Flovatar from 0x9392a4a7c3f49a0b\nimport FindMarket from 0x35717efbbce11c74\nimport FlowToken from 0x7e60df042a9c0868\n\ntransaction(tenant:Address) {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n        \n    }\n    execute{\n\n        self.adminRef.setNFTInfo(alias: \"Flovatar\", type: Type\u003c@Flovatar.NFT\u003e(), icon: \"https://styles.redditmedia.com/t5_5ikf79/styles/communityIcon_fraplt3tgk681.jpg\", providerPath: /private/FlovatarCollection, publicPath: Flovatar.CollectionPublicPath, storagePath: Flovatar.CollectionStoragePath, allowedFTTypes: nil, address: 0x9392a4a7c3f49a0b, externalFixedUrl: \"flovatar.com\")\n\n        let rules = [\n            FindMarket.TenantRule(name:\"Flow\", types:[Type\u003c@FlowToken.Vault\u003e()], ruleType: \"ft\", allow: true),\n            FindMarket.TenantRule(name:\"Flovatar\", types:[Type\u003c@Flovatar.NFT\u003e()], ruleType: \"nft\", allow: true)\n        ]\n\n        let tenantSaleItem = FindMarket.TenantSaleItem(\n            name: \"FlowFLovatar\", \n            cut: nil, \n            rules: rules, \n            status:\"active\"\n        )\n\n        self.adminRef.setMarketOption(tenant: tenant, saleItem: tenantSaleItem)\n \n    }\n}",
               "spec": {
                  "order": [
                     "tenant"
                  ],
                  "parameters": {
                     "tenant": "Address"
                  }
               }
            },
            "adminTestnetAddVersus": {
               "code": "import Admin from 0x35717efbbce11c74\nimport Art from 0x99ca04281098b33d\nimport FindMarket from 0x35717efbbce11c74\nimport FlowToken from 0x7e60df042a9c0868\n\ntransaction(tenant: Address) {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n        \n    }\n    execute{\n        self.adminRef.setNFTInfo(\n            alias: \"Versus\", \n            type: Type\u003c@Art.NFT\u003e(), \n            icon: \"https://global-uploads.webflow.com/60f008ba9757da0940af288e/60f02cad72175a774926125f_flow%20versus%20twitter%20lgoo.jpg\",\n            providerPath: /private/versusArtCollection,\n            publicPath: Art.CollectionPublicPath, \n            storagePath: Art.CollectionStoragePath, \n            allowedFTTypes: nil, \n                        address:0x99ca04281098b33d, externalFixedUrl: \"https://versus.auction\")\n\n        let rules = [\n            FindMarket.TenantRule(name:\"Flow\", types:[Type\u003c@FlowToken.Vault\u003e()], ruleType: \"ft\", allow: true),\n            FindMarket.TenantRule(name:\"Versus\", types:[Type\u003c@Art.NFT\u003e()], ruleType: \"nft\", allow: true)\n        ]\n\n        let tenantSaleItem = FindMarket.TenantSaleItem(\n            name: \"FlowVersus\", \n            cut: nil, \n            rules: rules, \n            status:\"active\"\n        )\n\n        self.adminRef.setMarketOption(tenant: tenant, saleItem: tenantSaleItem)\n    }\n}",
               "spec": {
                  "order": [
                     "tenant"
                  ],
                  "parameters": {
                     "tenant": "Address"
                  }
               }
            },
            "adminTransferAllFusd": {
               "code": "// Mainnet\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FUSD from 0xe223d8a629e49c68\n\n// Testnet\n// import FungibleToken from 0x9a0766d93b6608b7\n// import FUSD from 0xe223d8a629e49c68\n\ntransaction(recipient: Address) {\n\n  // The Vault resource that holds the tokens that are being transfered\n  let sentVault: @FungibleToken.Vault\n\n  prepare(signer: AuthAccount) {\n    // Get a reference to the signer's stored vault\n    let vaultRef = signer.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault)\n      ?? panic(\"Could not borrow reference to the owner's Vault!\")\n\n    // Withdraw tokens from the signer's stored vault\n    self.sentVault \u003c- vaultRef.withdraw(amount: vaultRef.balance)\n  }\n\n  execute {\n    // Get the recipient's public account object\n    let recipientAccount = getAccount(recipient)\n\n    // Get a reference to the recipient's Receiver\n    let receiverRef = recipientAccount.getCapability(/public/fusdReceiver)!\n      .borrow\u003c\u0026{FungibleToken.Receiver}\u003e()\n      ?? panic(\"Could not borrow receiver reference to the recipient's Vault\")\n\n    // Deposit the withdrawn tokens in the recipient's receiver\n    receiverRef.deposit(from: \u003c-self.sentVault)\n  }\n}",
               "spec": {
                  "order": [
                     "recipient"
                  ],
                  "parameters": {
                     "recipient": "Address"
                  }
               }
            },
            "alterMarketOption": {
               "code": "import FindMarket from 0x35717efbbce11c74\n\ntransaction(marketRule: String , action: String ){\n    prepare(account: AuthAccount){\n        let path = FindMarket.TenantClientStoragePath\n        let tenantRef = account.borrow\u003c\u0026FindMarket.TenantClient\u003e(from: path) ?? panic(\"Cannot borrow Reference.\")\n\n\n        switch action {\n            case \"enable\" :\n                tenantRef.enableMarketOption(marketRule)\n\n            case \"deprecate\" :\n                tenantRef.deprecateMarketOption(marketRule)\n\n            case \"stop\" :\n                tenantRef.stopMarketOption(marketRule)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "marketRule",
                     "action"
                  ],
                  "parameters": {
                     "action": "String",
                     "marketRule": "String"
                  }
               }
            },
            "bidLeaseMarketAuctionSoft": {
               "code": "import FindMarketSale from 0x35717efbbce11c74\nimport FindMarketAuctionEscrow from 0x35717efbbce11c74\nimport FindMarketAuctionSoft from 0x35717efbbce11c74\nimport FindMarketDirectOfferEscrow from 0x35717efbbce11c74\nimport FindMarketDirectOfferSoft from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FindViews from 0x35717efbbce11c74\nimport FTRegistry from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\nimport FUSD from 0xe223d8a629e49c68\nimport FiatToken from 0xa983fecbed621163\nimport FlowToken from 0x7e60df042a9c0868\nimport Dandy from 0x35717efbbce11c74\nimport Profile from 0x35717efbbce11c74\nimport FindLeaseMarketSale from 0x35717efbbce11c74\nimport FindLeaseMarketAuctionSoft from 0x35717efbbce11c74\n// import FindLeaseMarketAuctionEscrow from \"../contracts/FindLeaseMarketAuctionEscrow.cdc\"\nimport FindLeaseMarketDirectOfferSoft from 0x35717efbbce11c74\n// import FindLeaseMarketDirectOfferEscrow from \"../contracts/FindLeaseMarketDirectOfferEscrow.cdc\"\nimport FindLeaseMarket from 0x35717efbbce11c74\n\ntransaction(leaseName: String, amount: UFix64) {\n\n    let saleItemsCap: Capability\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic}\u003e \n    let walletReference : \u0026FungibleToken.Vault\n    let bidsReference: \u0026FindLeaseMarketAuctionSoft.MarketBidCollection?\n    let balanceBeforeBid: UFix64\n    let ftVaultType: Type\n\n    prepare(account: AuthAccount) {\n\n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n        //SYNC with register\n        //Add exising FUSD or create a new one and add it\n        let name = account.address.toString()\n        let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n        if !fusdReceiver.check() {\n            let fusd \u003c- FUSD.createEmptyVault()\n            account.save(\u003c- fusd, to: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n        }\n\n        let usdcCap = account.getCapability\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e(FiatToken.VaultReceiverPubPath)\n        if !usdcCap.check() {\n                account.save( \u003c-FiatToken.createEmptyVault(), to: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e( FiatToken.VaultReceiverPubPath, target: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FiatToken.ResourceId}\u003e( FiatToken.VaultUUIDPubPath, target: FiatToken.VaultStoragePath)\n                account.link\u003c\u0026FiatToken.Vault{FungibleToken.Balance}\u003e( FiatToken.VaultBalancePubPath, target:FiatToken.VaultStoragePath)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let dandyCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        let dandyCapPrivate= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPrivatePath)\n        if !dandyCapPrivate.check() {\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        var created=false\n        var updated=false\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        if !profile.hasWallet(\"Flow\") {\n            let flowWallet=Profile.Wallet( name:\"Flow\", receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), tags: [\"flow\"])\n    \n            profile.addWallet(flowWallet)\n            updated=true\n        }\n        if !profile.hasWallet(\"FUSD\") {\n            profile.addWallet(Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), tags: [\"fusd\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if !profile.hasWallet(\"USDC\") {\n            profile.addWallet(Profile.Wallet( name:\"USDC\", receiver:usdcCap, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(FiatToken.VaultBalancePubPath), accept: Type\u003c@FiatToken.Vault\u003e(), tags: [\"usdc\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else if updated {\n            profile.emitUpdatedEvent()\n        }\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        let doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        let doeSalePublicPath=FindMarket.getPublicPath(doeSaleType, name: tenant.name)\n        let doeSaleStoragePath= FindMarket.getStoragePath(doeSaleType, name:tenant.name)\n        let doeSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n        if !doeSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n        }\n\n        let doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        let doeBidPublicPath=FindMarket.getPublicPath(doeBidType, name: tenant.name)\n        let doeBidStoragePath= FindMarket.getStoragePath(doeBidType, name:tenant.name)\n        let doeBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n        if !doeBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n        }\n\n        /// auctions that escrow ft\n        let aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        let aeSalePublicPath=FindMarket.getPublicPath(aeSaleType, name: tenant.name)\n        let aeSaleStoragePath= FindMarket.getStoragePath(aeSaleType, name:tenant.name)\n        let aeSaleCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n        if !aeSaleCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n        }\n\n        let dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\n        let dosSalePublicPath=FindMarket.getPublicPath(dosSaleType, name: tenant.name)\n        let dosSaleStoragePath= FindMarket.getStoragePath(dosSaleType, name:tenant.name)\n\n        let dosSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n        if !dosSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n        }\n\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n        if !dosBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n        }\n\n        let aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\n        let aeBidPublicPath=FindMarket.getPublicPath(aeBidType, name: tenant.name)\n        let aeBidStoragePath= FindMarket.getStoragePath(aeBidType, name:tenant.name)\n        let aeBidCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n        if !aeBidCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n        }\n\n     /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n        }\n\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n        if !asBidCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n        }\n\n        let leaseTenantCapability= FindMarket.getTenantCapability(FindMarket.getTenantAddress(\"findLease\")!)!\n\n        let leaseSaleItemType= Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()\n        let leasePublicPath=FindMarket.getPublicPath(leaseSaleItemType, name: \"findLease\")\n        let leaseStoragePath= FindMarket.getStoragePath(leaseSaleItemType, name:\"findLease\")\n        let leaseSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath) \n        if !leaseSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketSale.SaleItemCollection\u003e(\u003c- FindLeaseMarketSale.createEmptySaleItemCollection(leaseTenantCapability), to: leaseStoragePath)\n            account.link\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath, target: leaseStoragePath)\n        }\n\n        let leaseASSaleItemType= Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e()\n        let leaseASPublicPath=FindMarket.getPublicPath(leaseASSaleItemType, name: \"findLease\")\n        let leaseASStoragePath= FindMarket.getStoragePath(leaseASSaleItemType, name:\"findLease\")\n        let leaseASSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath) \n        if !leaseASSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseASStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath, target: leaseASStoragePath)\n        }\n\n\n        let leaseASBidType= Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e()\n        let leaseASBidPublicPath=FindMarket.getPublicPath(leaseASBidType, name: \"findLease\")\n        let leaseASBidStoragePath= FindMarket.getStoragePath(leaseASBidType, name: \"findLease\")\n        let leaseASBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath) \n        if !leaseASBidCap.check() {\n            account.save\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseASBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath, target: leaseASBidStoragePath)\n        }\n\n        // let leaseAESaleItemType= Type\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e()\n        // let leaseAEPublicPath=FindMarket.getPublicPath(leaseAESaleItemType, name: \"findLease\")\n        // let leaseAEStoragePath= FindMarket.getStoragePath(leaseAESaleItemType, name:\"findLease\")\n        // let leaseAESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath) \n        // if !leaseAESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseAEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath, target: leaseAEStoragePath)\n        // }\n\n        // let leaseAEBidType= Type\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e()\n        // let leaseAEBidPublicPath=FindMarket.getPublicPath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidStoragePath= FindMarket.getStoragePath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath) \n        // if !leaseAEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseAEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath, target: leaseAEBidStoragePath)\n        // }\n\n        let leaseDOSSaleItemType= Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e()\n        let leaseDOSPublicPath=FindMarket.getPublicPath(leaseDOSSaleItemType, name: \"findLease\")\n        let leaseDOSStoragePath= FindMarket.getStoragePath(leaseDOSSaleItemType, name:\"findLease\")\n        let leaseDOSSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath) \n        if !leaseDOSSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOSStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath, target: leaseDOSStoragePath)\n        }\n\n        let leaseDOSBidType= Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let leaseDOSBidPublicPath=FindMarket.getPublicPath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidStoragePath= FindMarket.getStoragePath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath) \n        if !leaseDOSBidCap.check() {\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOSBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath, target: leaseDOSBidStoragePath)\n        }\n\n        // let leaseDOESaleItemType= Type\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        // let leaseDOEPublicPath=FindMarket.getPublicPath(leaseDOESaleItemType, name: \"findLease\")\n        // let leaseDOEStoragePath= FindMarket.getStoragePath(leaseDOESaleItemType, name:\"findLease\")\n        // let leaseDOESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath) \n        // if !leaseDOESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath, target: leaseDOEStoragePath)\n        // }\n\n        // let leaseDOEBidType= Type\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        // let leaseDOEBidPublicPath=FindMarket.getPublicPath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidStoragePath= FindMarket.getStoragePath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath) \n        // if !leaseDOEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath, target: leaseDOEBidStoragePath)\n        // }\n        //SYNC with register\n\n        let resolveAddress = FIND.resolve(leaseName)\n        if resolveAddress == nil {panic(\"The address input is not a valid name nor address. Input : \".concat(leaseName))}\n        let address = resolveAddress!\n\n        let leaseMarketplace = FindMarket.getTenantAddress(\"findLease\")!\n        let leaseTenant = leaseTenantCapability.borrow()!\n        self.saleItemsCap= FindLeaseMarketAuctionSoft.getSaleItemCapability(marketplace:leaseMarketplace, user:address) ?? panic(\"cannot find sale item cap\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e())\n\n        let item = FindLeaseMarket.assertOperationValid(tenant: leaseMarketplace, name: leaseName, marketOption: marketOption)\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n        \n        self.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account. Account address : \".concat(account.address.toString()))\n        self.ftVaultType = ft.type\n\n        let bidStoragePath=leaseTenant.getStoragePath(Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e())\n\n        self.bidsReference= account.borrow\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(from: bidStoragePath)\n        self.balanceBeforeBid=self.walletReference.balance\n    }\n\n    pre {\n        self.bidsReference != nil : \"This account does not have a bid collection\"\n        self.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n    }\n\n    execute {\n        self.bidsReference!.bid(name:leaseName, amount: amount, vaultType: self.ftVaultType, bidExtraField: {})\n    }\n}",
               "spec": {
                  "order": [
                     "leaseName",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "leaseName": "String"
                  }
               }
            },
            "bidLeaseMarketAuctionSoftDUC": {
               "code": "import FindMarketSale from 0x35717efbbce11c74\nimport FindMarketAuctionEscrow from 0x35717efbbce11c74\nimport FindMarketAuctionSoft from 0x35717efbbce11c74\nimport FindMarketDirectOfferEscrow from 0x35717efbbce11c74\nimport FindMarketDirectOfferSoft from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FindViews from 0x35717efbbce11c74\nimport FTRegistry from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\nimport TokenForwarding from 0x51ea0e37c27a1f1a\nimport DapperUtilityCoin from 0x82ec283f88a62e65\nimport FlowToken from 0x7e60df042a9c0868\nimport Dandy from 0x35717efbbce11c74\nimport Profile from 0x35717efbbce11c74\nimport FindLeaseMarketSale from 0x35717efbbce11c74\nimport FindLeaseMarketAuctionSoft from 0x35717efbbce11c74\n// import FindLeaseMarketAuctionEscrow from \"../contracts/FindLeaseMarketAuctionEscrow.cdc\"\nimport FindLeaseMarketDirectOfferSoft from 0x35717efbbce11c74\n// import FindLeaseMarketDirectOfferEscrow from \"../contracts/FindLeaseMarketDirectOfferEscrow.cdc\"\nimport FindLeaseMarket from 0x35717efbbce11c74\n\ntransaction(dapperAddress: Address, leaseName: String, amount: UFix64) {\n\n    let saleItemsCap: Capability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic}\u003e \n    let bidsReference: \u0026FindLeaseMarketAuctionSoft.MarketBidCollection?\n    let ftVaultType: Type\n\n    prepare(account: AuthAccount) {\n\n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n        //SYNC with register\n        //Add exising FUSD or create a new one and add it\n        let name = account.address.toString()\n        let ducReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver)\n        if !ducReceiver.check() {\n            let dapper = getAccount(dapperAddress)\n            // Create a new Forwarder resource for DUC and store it in the new account's storage\n            let ducForwarder \u003c- TokenForwarding.createNewForwarder(recipient: dapper.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver))\n            account.save(\u003c-ducForwarder, to: /storage/dapperUtilityCoinReceiver)\n            // Publish a Receiver capability for the new account, which is linked to the DUC Forwarder\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver,target: /storage/dapperUtilityCoinReceiver)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: ducReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let dandyCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        let dandyCapPrivate= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPrivatePath)\n        if !dandyCapPrivate.check() {\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        var created=false\n        var updated=false\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        if !profile.hasWallet(\"Flow\") {\n            let flowWallet=Profile.Wallet( name:\"Flow\", receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), tags: [\"flow\"])\n    \n            profile.addWallet(flowWallet)\n            updated=true\n        }\n        if !profile.hasWallet(\"DUC\") {\n            profile.addWallet(Profile.Wallet( name:\"DUC\", receiver:ducReceiver, balance:getAccount(dapperAddress).getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/dapperUtilityCoinBalance), accept: Type\u003c@DapperUtilityCoin.Vault\u003e(), tags: [\"duc\", \"dapperUtilityCoin\",\"dapper\"]))\n            updated=true\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else {\n            profile.emitUpdatedEvent()\n        }\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        let doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        let doeSalePublicPath=FindMarket.getPublicPath(doeSaleType, name: tenant.name)\n        let doeSaleStoragePath= FindMarket.getStoragePath(doeSaleType, name:tenant.name)\n        let doeSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n        if !doeSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n        }\n\n        let doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        let doeBidPublicPath=FindMarket.getPublicPath(doeBidType, name: tenant.name)\n        let doeBidStoragePath= FindMarket.getStoragePath(doeBidType, name:tenant.name)\n        let doeBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n        if !doeBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n        }\n\n        /// auctions that escrow ft\n        let aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        let aeSalePublicPath=FindMarket.getPublicPath(aeSaleType, name: tenant.name)\n        let aeSaleStoragePath= FindMarket.getStoragePath(aeSaleType, name:tenant.name)\n        let aeSaleCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n        if !aeSaleCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n        }\n\n        let dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\n        let dosSalePublicPath=FindMarket.getPublicPath(dosSaleType, name: tenant.name)\n        let dosSaleStoragePath= FindMarket.getStoragePath(dosSaleType, name:tenant.name)\n\n        let dosSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n        if !dosSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n        }\n\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n        if !dosBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n        }\n\n        let aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\n        let aeBidPublicPath=FindMarket.getPublicPath(aeBidType, name: tenant.name)\n        let aeBidStoragePath= FindMarket.getStoragePath(aeBidType, name:tenant.name)\n        let aeBidCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n        if !aeBidCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n        }\n\n     /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n        }\n\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n        if !asBidCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n        }\n\n        let leaseTenantCapability= FindMarket.getTenantCapability(FindMarket.getTenantAddress(\"findLease\")!)!\n\n        let leaseSaleItemType= Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()\n        let leasePublicPath=FindMarket.getPublicPath(leaseSaleItemType, name: \"findLease\")\n        let leaseStoragePath= FindMarket.getStoragePath(leaseSaleItemType, name:\"findLease\")\n        let leaseSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath) \n        if !leaseSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketSale.SaleItemCollection\u003e(\u003c- FindLeaseMarketSale.createEmptySaleItemCollection(leaseTenantCapability), to: leaseStoragePath)\n            account.link\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath, target: leaseStoragePath)\n        }\n\n        let leaseASSaleItemType= Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e()\n        let leaseASPublicPath=FindMarket.getPublicPath(leaseASSaleItemType, name: \"findLease\")\n        let leaseASStoragePath= FindMarket.getStoragePath(leaseASSaleItemType, name:\"findLease\")\n        let leaseASSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath) \n        if !leaseASSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseASStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath, target: leaseASStoragePath)\n        }\n\n\n        let leaseASBidType= Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e()\n        let leaseASBidPublicPath=FindMarket.getPublicPath(leaseASBidType, name: \"findLease\")\n        let leaseASBidStoragePath= FindMarket.getStoragePath(leaseASBidType, name: \"findLease\")\n        let leaseASBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath) \n        if !leaseASBidCap.check() {\n            account.save\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseASBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath, target: leaseASBidStoragePath)\n        }\n\n        // let leaseAESaleItemType= Type\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e()\n        // let leaseAEPublicPath=FindMarket.getPublicPath(leaseAESaleItemType, name: \"findLease\")\n        // let leaseAEStoragePath= FindMarket.getStoragePath(leaseAESaleItemType, name:\"findLease\")\n        // let leaseAESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath) \n        // if !leaseAESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseAEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath, target: leaseAEStoragePath)\n        // }\n\n        // let leaseAEBidType= Type\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e()\n        // let leaseAEBidPublicPath=FindMarket.getPublicPath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidStoragePath= FindMarket.getStoragePath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath) \n        // if !leaseAEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseAEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath, target: leaseAEBidStoragePath)\n        // }\n\n        let leaseDOSSaleItemType= Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e()\n        let leaseDOSPublicPath=FindMarket.getPublicPath(leaseDOSSaleItemType, name: \"findLease\")\n        let leaseDOSStoragePath= FindMarket.getStoragePath(leaseDOSSaleItemType, name:\"findLease\")\n        let leaseDOSSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath) \n        if !leaseDOSSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOSStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath, target: leaseDOSStoragePath)\n        }\n\n        let leaseDOSBidType= Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let leaseDOSBidPublicPath=FindMarket.getPublicPath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidStoragePath= FindMarket.getStoragePath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath) \n        if !leaseDOSBidCap.check() {\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOSBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath, target: leaseDOSBidStoragePath)\n        }\n\n        // let leaseDOESaleItemType= Type\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        // let leaseDOEPublicPath=FindMarket.getPublicPath(leaseDOESaleItemType, name: \"findLease\")\n        // let leaseDOEStoragePath= FindMarket.getStoragePath(leaseDOESaleItemType, name:\"findLease\")\n        // let leaseDOESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath) \n        // if !leaseDOESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath, target: leaseDOEStoragePath)\n        // }\n\n        // let leaseDOEBidType= Type\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        // let leaseDOEBidPublicPath=FindMarket.getPublicPath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidStoragePath= FindMarket.getStoragePath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath) \n        // if !leaseDOEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath, target: leaseDOEBidStoragePath)\n        // }\n        //SYNC with register\n\n        let resolveAddress = FIND.resolve(leaseName)\n        if resolveAddress == nil {panic(\"The address input is not a valid name nor address. Input : \".concat(leaseName))}\n        let address = resolveAddress!\n\n        let leaseMarketplace = FindMarket.getTenantAddress(\"findLease\")!\n        let leaseTenant = leaseTenantCapability.borrow()!\n\n        self.saleItemsCap= FindMarketAuctionSoft.getSaleItemCapability(marketplace:leaseMarketplace, user:address) ?? panic(\"cannot find sale item cap\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e())\n\n        let item = FindLeaseMarket.assertOperationValid(tenant: leaseMarketplace, name: leaseName, marketOption: marketOption)\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n        \n        self.ftVaultType = ft.type\n\n        let bidStoragePath=leaseTenant.getStoragePath(Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e())\n\n        self.bidsReference= account.borrow\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(from: bidStoragePath)\n    }\n\n    pre {\n        self.bidsReference != nil : \"This account does not have a bid collection\"\n    }\n\n    execute {\n        self.bidsReference!.bid(name:leaseName, amount: amount, vaultType: self.ftVaultType, bidExtraField: {})\n    }\n}",
               "spec": {
                  "order": [
                     "dapperAddress",
                     "leaseName",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "dapperAddress": "Address",
                     "leaseName": "String"
                  }
               }
            },
            "bidLeaseMarketDirectOfferSoft": {
               "code": "import FindMarketSale from 0x35717efbbce11c74\nimport FindMarketAuctionEscrow from 0x35717efbbce11c74\nimport FindMarketAuctionSoft from 0x35717efbbce11c74\nimport FindMarketDirectOfferEscrow from 0x35717efbbce11c74\nimport FindMarketDirectOfferSoft from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FindViews from 0x35717efbbce11c74\nimport FTRegistry from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\nimport FUSD from 0xe223d8a629e49c68\nimport FiatToken from 0xa983fecbed621163\nimport FlowToken from 0x7e60df042a9c0868\nimport Dandy from 0x35717efbbce11c74\nimport Profile from 0x35717efbbce11c74\nimport FindLeaseMarketSale from 0x35717efbbce11c74\nimport FindLeaseMarketAuctionSoft from 0x35717efbbce11c74\n// import FindLeaseMarketAuctionEscrow from \"../contracts/FindLeaseMarketAuctionEscrow.cdc\"\nimport FindLeaseMarketDirectOfferSoft from 0x35717efbbce11c74\n// import FindLeaseMarketDirectOfferEscrow from \"../contracts/FindLeaseMarketDirectOfferEscrow.cdc\"\nimport FindLeaseMarket from 0x35717efbbce11c74\n\ntransaction(leaseName: String, ftAliasOrIdentifier:String, amount: UFix64, validUntil: UFix64?) {\n\n    let bidsReference: \u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection?\n    let ftVaultType: Type\n\n    prepare(account: AuthAccount) {\n        \n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n        //SYNC with register\n        //Add exising FUSD or create a new one and add it\n        let name = account.address.toString()\n        let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n        if !fusdReceiver.check() {\n            let fusd \u003c- FUSD.createEmptyVault()\n            account.save(\u003c- fusd, to: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n        }\n\n        let usdcCap = account.getCapability\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e(FiatToken.VaultReceiverPubPath)\n        if !usdcCap.check() {\n                account.save( \u003c-FiatToken.createEmptyVault(), to: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e( FiatToken.VaultReceiverPubPath, target: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FiatToken.ResourceId}\u003e( FiatToken.VaultUUIDPubPath, target: FiatToken.VaultStoragePath)\n                account.link\u003c\u0026FiatToken.Vault{FungibleToken.Balance}\u003e( FiatToken.VaultBalancePubPath, target:FiatToken.VaultStoragePath)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let dandyCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        let dandyCapPrivate= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPrivatePath)\n        if !dandyCapPrivate.check() {\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        var created=false\n        var updated=false\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        if !profile.hasWallet(\"Flow\") {\n            let flowWallet=Profile.Wallet( name:\"Flow\", receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), tags: [\"flow\"])\n    \n            profile.addWallet(flowWallet)\n            updated=true\n        }\n        if !profile.hasWallet(\"FUSD\") {\n            profile.addWallet(Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), tags: [\"fusd\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if !profile.hasWallet(\"USDC\") {\n            profile.addWallet(Profile.Wallet( name:\"USDC\", receiver:usdcCap, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(FiatToken.VaultBalancePubPath), accept: Type\u003c@FiatToken.Vault\u003e(), tags: [\"usdc\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else if updated {\n            profile.emitUpdatedEvent()\n        }\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        let doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        let doeSalePublicPath=FindMarket.getPublicPath(doeSaleType, name: tenant.name)\n        let doeSaleStoragePath= FindMarket.getStoragePath(doeSaleType, name:tenant.name)\n        let doeSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n        if !doeSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n        }\n\n        let doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        let doeBidPublicPath=FindMarket.getPublicPath(doeBidType, name: tenant.name)\n        let doeBidStoragePath= FindMarket.getStoragePath(doeBidType, name:tenant.name)\n        let doeBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n        if !doeBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n        }\n\n        /// auctions that escrow ft\n        let aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        let aeSalePublicPath=FindMarket.getPublicPath(aeSaleType, name: tenant.name)\n        let aeSaleStoragePath= FindMarket.getStoragePath(aeSaleType, name:tenant.name)\n        let aeSaleCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n        if !aeSaleCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n        }\n\n        let dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\n        let dosSalePublicPath=FindMarket.getPublicPath(dosSaleType, name: tenant.name)\n        let dosSaleStoragePath= FindMarket.getStoragePath(dosSaleType, name:tenant.name)\n\n        let dosSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n        if !dosSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n        }\n\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n        if !dosBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n        }\n\n        let aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\n        let aeBidPublicPath=FindMarket.getPublicPath(aeBidType, name: tenant.name)\n        let aeBidStoragePath= FindMarket.getStoragePath(aeBidType, name:tenant.name)\n        let aeBidCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n        if !aeBidCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n        }\n\n     /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n        }\n\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n        if !asBidCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n        }\n\n        let leaseTenantCapability= FindMarket.getTenantCapability(FindMarket.getTenantAddress(\"findLease\")!)!\n\n        let leaseSaleItemType= Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()\n        let leasePublicPath=FindMarket.getPublicPath(leaseSaleItemType, name: \"findLease\")\n        let leaseStoragePath= FindMarket.getStoragePath(leaseSaleItemType, name:\"findLease\")\n        let leaseSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath) \n        if !leaseSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketSale.SaleItemCollection\u003e(\u003c- FindLeaseMarketSale.createEmptySaleItemCollection(leaseTenantCapability), to: leaseStoragePath)\n            account.link\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath, target: leaseStoragePath)\n        }\n\n        let leaseASSaleItemType= Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e()\n        let leaseASPublicPath=FindMarket.getPublicPath(leaseASSaleItemType, name: \"findLease\")\n        let leaseASStoragePath= FindMarket.getStoragePath(leaseASSaleItemType, name:\"findLease\")\n        let leaseASSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath) \n        if !leaseASSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseASStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath, target: leaseASStoragePath)\n        }\n\n\n        let leaseASBidType= Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e()\n        let leaseASBidPublicPath=FindMarket.getPublicPath(leaseASBidType, name: \"findLease\")\n        let leaseASBidStoragePath= FindMarket.getStoragePath(leaseASBidType, name: \"findLease\")\n        let leaseASBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath) \n        if !leaseASBidCap.check() {\n            account.save\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseASBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath, target: leaseASBidStoragePath)\n        }\n\n        // let leaseAESaleItemType= Type\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e()\n        // let leaseAEPublicPath=FindMarket.getPublicPath(leaseAESaleItemType, name: \"findLease\")\n        // let leaseAEStoragePath= FindMarket.getStoragePath(leaseAESaleItemType, name:\"findLease\")\n        // let leaseAESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath) \n        // if !leaseAESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseAEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath, target: leaseAEStoragePath)\n        // }\n\n        // let leaseAEBidType= Type\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e()\n        // let leaseAEBidPublicPath=FindMarket.getPublicPath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidStoragePath= FindMarket.getStoragePath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath) \n        // if !leaseAEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseAEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath, target: leaseAEBidStoragePath)\n        // }\n\n        let leaseDOSSaleItemType= Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e()\n        let leaseDOSPublicPath=FindMarket.getPublicPath(leaseDOSSaleItemType, name: \"findLease\")\n        let leaseDOSStoragePath= FindMarket.getStoragePath(leaseDOSSaleItemType, name:\"findLease\")\n        let leaseDOSSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath) \n        if !leaseDOSSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOSStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath, target: leaseDOSStoragePath)\n        }\n\n        let leaseDOSBidType= Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let leaseDOSBidPublicPath=FindMarket.getPublicPath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidStoragePath= FindMarket.getStoragePath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath) \n        if !leaseDOSBidCap.check() {\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOSBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath, target: leaseDOSBidStoragePath)\n        }\n\n        // let leaseDOESaleItemType= Type\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        // let leaseDOEPublicPath=FindMarket.getPublicPath(leaseDOESaleItemType, name: \"findLease\")\n        // let leaseDOEStoragePath= FindMarket.getStoragePath(leaseDOESaleItemType, name:\"findLease\")\n        // let leaseDOESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath) \n        // if !leaseDOESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath, target: leaseDOEStoragePath)\n        // }\n\n        // let leaseDOEBidType= Type\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        // let leaseDOEBidPublicPath=FindMarket.getPublicPath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidStoragePath= FindMarket.getStoragePath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath) \n        // if !leaseDOEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath, target: leaseDOEBidStoragePath)\n        // }\n        //SYNC with register\n\n        let resolveAddress = FIND.resolve(leaseName)\n        if resolveAddress == nil {panic(\"The address input is not a valid name nor address. Input : \".concat(leaseName))}\n        let address = resolveAddress!\n\n        let ft = FTRegistry.getFTInfo(ftAliasOrIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftAliasOrIdentifier))\n\n        self.ftVaultType = ft.type\n\n        let walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n        assert(walletReference.balance \u003e amount , message: \"Bidder has to have enough balance in wallet\")\n\n\n        let leaseTenant = leaseTenantCapability.borrow()!\n        let bidStoragePath=leaseTenant.getStoragePath(Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e())!\n        self.bidsReference= account.borrow\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(from: bidStoragePath)\n\n    }\n\n    pre {\n        self.bidsReference != nil : \"This account does not have a bid collection\"\n    }\n\n    execute {\n        self.bidsReference!.bid(name:leaseName, amount: amount, vaultType: self.ftVaultType, validUntil: validUntil, saleItemExtraField: {}, bidExtraField: {})\n    }\n}",
               "spec": {
                  "order": [
                     "leaseName",
                     "ftAliasOrIdentifier",
                     "amount",
                     "validUntil"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "ftAliasOrIdentifier": "String",
                     "leaseName": "String",
                     "validUntil": "UFix64?"
                  }
               }
            },
            "bidLeaseMarketDirectOfferSoftDUC": {
               "code": "import FindMarketSale from 0x35717efbbce11c74\nimport FindMarketAuctionEscrow from 0x35717efbbce11c74\nimport FindMarketAuctionSoft from 0x35717efbbce11c74\nimport FindMarketDirectOfferEscrow from 0x35717efbbce11c74\nimport FindMarketDirectOfferSoft from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FindViews from 0x35717efbbce11c74\nimport FTRegistry from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\nimport FlowToken from 0x7e60df042a9c0868\nimport TokenForwarding from 0x51ea0e37c27a1f1a\nimport DapperUtilityCoin from 0x82ec283f88a62e65\nimport Dandy from 0x35717efbbce11c74\nimport Profile from 0x35717efbbce11c74\nimport FindLeaseMarketSale from 0x35717efbbce11c74\nimport FindLeaseMarketAuctionSoft from 0x35717efbbce11c74\n// import FindLeaseMarketAuctionEscrow from \"../contracts/FindLeaseMarketAuctionEscrow.cdc\"\nimport FindLeaseMarketDirectOfferSoft from 0x35717efbbce11c74\n// import FindLeaseMarketDirectOfferEscrow from \"../contracts/FindLeaseMarketDirectOfferEscrow.cdc\"\nimport FindLeaseMarket from 0x35717efbbce11c74\n\ntransaction(dapperAddress: Address, leaseName: String, amount: UFix64, validUntil: UFix64?) {\n\n    let bidsReference: \u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection?\n    let ftVaultType: Type\n\n    prepare(account: AuthAccount) {\n        \n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n        //SYNC with register\n        //Add exising FUSD or create a new one and add it\n        let name = account.address.toString()\n        let ducReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver)\n        if !ducReceiver.check() {\n            let dapper = getAccount(dapperAddress)\n            // Create a new Forwarder resource for DUC and store it in the new account's storage\n            let ducForwarder \u003c- TokenForwarding.createNewForwarder(recipient: dapper.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver))\n            account.save(\u003c-ducForwarder, to: /storage/dapperUtilityCoinReceiver)\n            // Publish a Receiver capability for the new account, which is linked to the DUC Forwarder\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver,target: /storage/dapperUtilityCoinReceiver)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: ducReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let dandyCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        let dandyCapPrivate= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPrivatePath)\n        if !dandyCapPrivate.check() {\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        var created=false\n        var updated=false\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        if !profile.hasWallet(\"Flow\") {\n            let flowWallet=Profile.Wallet( name:\"Flow\", receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), tags: [\"flow\"])\n    \n            profile.addWallet(flowWallet)\n            updated=true\n        }\n        if !profile.hasWallet(\"DUC\") {\n            profile.addWallet(Profile.Wallet( name:\"DUC\", receiver:ducReceiver, balance:getAccount(dapperAddress).getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/dapperUtilityCoinBalance), accept: Type\u003c@DapperUtilityCoin.Vault\u003e(), tags: [\"duc\", \"dapperUtilityCoin\",\"dapper\"]))\n            updated=true\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else {\n            profile.emitUpdatedEvent()\n        }\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        let doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        let doeSalePublicPath=FindMarket.getPublicPath(doeSaleType, name: tenant.name)\n        let doeSaleStoragePath= FindMarket.getStoragePath(doeSaleType, name:tenant.name)\n        let doeSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n        if !doeSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n        }\n\n        let doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        let doeBidPublicPath=FindMarket.getPublicPath(doeBidType, name: tenant.name)\n        let doeBidStoragePath= FindMarket.getStoragePath(doeBidType, name:tenant.name)\n        let doeBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n        if !doeBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n        }\n\n        /// auctions that escrow ft\n        let aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        let aeSalePublicPath=FindMarket.getPublicPath(aeSaleType, name: tenant.name)\n        let aeSaleStoragePath= FindMarket.getStoragePath(aeSaleType, name:tenant.name)\n        let aeSaleCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n        if !aeSaleCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n        }\n\n        let dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\n        let dosSalePublicPath=FindMarket.getPublicPath(dosSaleType, name: tenant.name)\n        let dosSaleStoragePath= FindMarket.getStoragePath(dosSaleType, name:tenant.name)\n\n        let dosSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n        if !dosSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n        }\n\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n        if !dosBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n        }\n\n        let aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\n        let aeBidPublicPath=FindMarket.getPublicPath(aeBidType, name: tenant.name)\n        let aeBidStoragePath= FindMarket.getStoragePath(aeBidType, name:tenant.name)\n        let aeBidCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n        if !aeBidCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n        }\n\n     /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n        }\n\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n        if !asBidCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n        }\n\n        let leaseTenantCapability= FindMarket.getTenantCapability(FindMarket.getTenantAddress(\"findLease\")!)!\n\n        let leaseSaleItemType= Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()\n        let leasePublicPath=FindMarket.getPublicPath(leaseSaleItemType, name: \"findLease\")\n        let leaseStoragePath= FindMarket.getStoragePath(leaseSaleItemType, name:\"findLease\")\n        let leaseSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath) \n        if !leaseSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketSale.SaleItemCollection\u003e(\u003c- FindLeaseMarketSale.createEmptySaleItemCollection(leaseTenantCapability), to: leaseStoragePath)\n            account.link\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath, target: leaseStoragePath)\n        }\n\n        let leaseASSaleItemType= Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e()\n        let leaseASPublicPath=FindMarket.getPublicPath(leaseASSaleItemType, name: \"findLease\")\n        let leaseASStoragePath= FindMarket.getStoragePath(leaseASSaleItemType, name:\"findLease\")\n        let leaseASSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath) \n        if !leaseASSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseASStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath, target: leaseASStoragePath)\n        }\n\n\n        let leaseASBidType= Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e()\n        let leaseASBidPublicPath=FindMarket.getPublicPath(leaseASBidType, name: \"findLease\")\n        let leaseASBidStoragePath= FindMarket.getStoragePath(leaseASBidType, name: \"findLease\")\n        let leaseASBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath) \n        if !leaseASBidCap.check() {\n            account.save\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseASBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath, target: leaseASBidStoragePath)\n        }\n\n        // let leaseAESaleItemType= Type\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e()\n        // let leaseAEPublicPath=FindMarket.getPublicPath(leaseAESaleItemType, name: \"findLease\")\n        // let leaseAEStoragePath= FindMarket.getStoragePath(leaseAESaleItemType, name:\"findLease\")\n        // let leaseAESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath) \n        // if !leaseAESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseAEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath, target: leaseAEStoragePath)\n        // }\n\n        // let leaseAEBidType= Type\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e()\n        // let leaseAEBidPublicPath=FindMarket.getPublicPath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidStoragePath= FindMarket.getStoragePath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath) \n        // if !leaseAEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseAEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath, target: leaseAEBidStoragePath)\n        // }\n\n        let leaseDOSSaleItemType= Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e()\n        let leaseDOSPublicPath=FindMarket.getPublicPath(leaseDOSSaleItemType, name: \"findLease\")\n        let leaseDOSStoragePath= FindMarket.getStoragePath(leaseDOSSaleItemType, name:\"findLease\")\n        let leaseDOSSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath) \n        if !leaseDOSSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOSStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath, target: leaseDOSStoragePath)\n        }\n\n        let leaseDOSBidType= Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let leaseDOSBidPublicPath=FindMarket.getPublicPath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidStoragePath= FindMarket.getStoragePath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath) \n        if !leaseDOSBidCap.check() {\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOSBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath, target: leaseDOSBidStoragePath)\n        }\n\n        // let leaseDOESaleItemType= Type\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        // let leaseDOEPublicPath=FindMarket.getPublicPath(leaseDOESaleItemType, name: \"findLease\")\n        // let leaseDOEStoragePath= FindMarket.getStoragePath(leaseDOESaleItemType, name:\"findLease\")\n        // let leaseDOESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath) \n        // if !leaseDOESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath, target: leaseDOEStoragePath)\n        // }\n\n        // let leaseDOEBidType= Type\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        // let leaseDOEBidPublicPath=FindMarket.getPublicPath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidStoragePath= FindMarket.getStoragePath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath) \n        // if !leaseDOEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath, target: leaseDOEBidStoragePath)\n        // }\n        //SYNC with register\n\n        let ft = FTRegistry.getFTInfo(Type\u003c@DapperUtilityCoin.Vault\u003e().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(Type\u003c@DapperUtilityCoin.Vault\u003e().identifier))\n\n        self.ftVaultType = ft.type\n\n        let leaseTenant = leaseTenantCapability.borrow()!\n        let bidStoragePath=leaseTenant.getStoragePath(Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e())!\n        self.bidsReference= account.borrow\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(from: bidStoragePath)\n\n    }\n\n    pre {\n        self.bidsReference != nil : \"This account does not have a bid collection\"\n    }\n\n    execute {\n        self.bidsReference!.bid(name:leaseName, amount: amount, vaultType: self.ftVaultType, validUntil: validUntil, saleItemExtraField: {}, bidExtraField: {})\n    }\n}",
               "spec": {
                  "order": [
                     "dapperAddress",
                     "leaseName",
                     "amount",
                     "validUntil"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "dapperAddress": "Address",
                     "leaseName": "String",
                     "validUntil": "UFix64?"
                  }
               }
            },
            "bidMarketAuctionEscrowed": {
               "code": "import FindMarketSale from 0x35717efbbce11c74\nimport FindMarketAuctionEscrow from 0x35717efbbce11c74\nimport FindMarketAuctionSoft from 0x35717efbbce11c74\nimport FindMarketDirectOfferEscrow from 0x35717efbbce11c74\nimport FindMarketDirectOfferSoft from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FindViews from 0x35717efbbce11c74\nimport NFTCatalog from 0x324c34e1c517e4db\nimport FINDNFTCatalog from 0x35717efbbce11c74\nimport FTRegistry from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\nimport FUSD from 0xe223d8a629e49c68\nimport FiatToken from 0xa983fecbed621163\nimport FlowToken from 0x7e60df042a9c0868\nimport Dandy from 0x35717efbbce11c74\nimport Profile from 0x35717efbbce11c74\nimport FindLeaseMarketSale from 0x35717efbbce11c74\nimport FindLeaseMarketAuctionSoft from 0x35717efbbce11c74\n// import FindLeaseMarketAuctionEscrow from \"../contracts/FindLeaseMarketAuctionEscrow.cdc\"\nimport FindLeaseMarketDirectOfferSoft from 0x35717efbbce11c74\n// import FindLeaseMarketDirectOfferEscrow from \"../contracts/FindLeaseMarketDirectOfferEscrow.cdc\"\nimport FindLeaseMarket from 0x35717efbbce11c74\n\ntransaction(marketplace:Address, user: String, id: UInt64, amount: UFix64) {\n\n    let saleItemsCap: Capability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic}\u003e \n    var targetCapability : Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e\n    let walletReference : \u0026FungibleToken.Vault\n    let bidsReference: \u0026FindMarketAuctionEscrow.MarketBidCollection?\n    let balanceBeforeBid: UFix64\n    let pointer: FindViews.ViewReadPointer\n\n    prepare(account: AuthAccount) {\n\n\n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n        //SYNC with register\n        //Add exising FUSD or create a new one and add it\n        let name = account.address.toString()\n        let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n        if !fusdReceiver.check() {\n            let fusd \u003c- FUSD.createEmptyVault()\n            account.save(\u003c- fusd, to: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n        }\n\n        let usdcCap = account.getCapability\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e(FiatToken.VaultReceiverPubPath)\n        if !usdcCap.check() {\n                account.save( \u003c-FiatToken.createEmptyVault(), to: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e( FiatToken.VaultReceiverPubPath, target: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FiatToken.ResourceId}\u003e( FiatToken.VaultUUIDPubPath, target: FiatToken.VaultStoragePath)\n                account.link\u003c\u0026FiatToken.Vault{FungibleToken.Balance}\u003e( FiatToken.VaultBalancePubPath, target:FiatToken.VaultStoragePath)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let dandyCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        let dandyCapPrivate= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPrivatePath)\n        if !dandyCapPrivate.check() {\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        var created=false\n        var updated=false\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        if !profile.hasWallet(\"Flow\") {\n            let flowWallet=Profile.Wallet( name:\"Flow\", receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), tags: [\"flow\"])\n    \n            profile.addWallet(flowWallet)\n            updated=true\n        }\n        if !profile.hasWallet(\"FUSD\") {\n            profile.addWallet(Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), tags: [\"fusd\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if !profile.hasWallet(\"USDC\") {\n            profile.addWallet(Profile.Wallet( name:\"USDC\", receiver:usdcCap, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(FiatToken.VaultBalancePubPath), accept: Type\u003c@FiatToken.Vault\u003e(), tags: [\"usdc\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else if updated {\n            profile.emitUpdatedEvent()\n        }\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        let doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        let doeSalePublicPath=FindMarket.getPublicPath(doeSaleType, name: tenant.name)\n        let doeSaleStoragePath= FindMarket.getStoragePath(doeSaleType, name:tenant.name)\n        let doeSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n        if !doeSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n        }\n\n        let doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        let doeBidPublicPath=FindMarket.getPublicPath(doeBidType, name: tenant.name)\n        let doeBidStoragePath= FindMarket.getStoragePath(doeBidType, name:tenant.name)\n        let doeBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n        if !doeBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n        }\n\n        /// auctions that escrow ft\n        let aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        let aeSalePublicPath=FindMarket.getPublicPath(aeSaleType, name: tenant.name)\n        let aeSaleStoragePath= FindMarket.getStoragePath(aeSaleType, name:tenant.name)\n        let aeSaleCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n        if !aeSaleCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n        }\n\n        let dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\n        let dosSalePublicPath=FindMarket.getPublicPath(dosSaleType, name: tenant.name)\n        let dosSaleStoragePath= FindMarket.getStoragePath(dosSaleType, name:tenant.name)\n\n        let dosSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n        if !dosSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n        }\n\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n        if !dosBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n        }\n\n        let aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\n        let aeBidPublicPath=FindMarket.getPublicPath(aeBidType, name: tenant.name)\n        let aeBidStoragePath= FindMarket.getStoragePath(aeBidType, name:tenant.name)\n        let aeBidCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n        if !aeBidCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n        }\n\n     /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n        }\n\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n        if !asBidCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n        }\n\n        let leaseTenantCapability= FindMarket.getTenantCapability(FindMarket.getTenantAddress(\"findLease\")!)!\n\n        let leaseSaleItemType= Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()\n        let leasePublicPath=FindMarket.getPublicPath(leaseSaleItemType, name: \"findLease\")\n        let leaseStoragePath= FindMarket.getStoragePath(leaseSaleItemType, name:\"findLease\")\n        let leaseSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath) \n        if !leaseSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketSale.SaleItemCollection\u003e(\u003c- FindLeaseMarketSale.createEmptySaleItemCollection(leaseTenantCapability), to: leaseStoragePath)\n            account.link\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath, target: leaseStoragePath)\n        }\n\n        let leaseASSaleItemType= Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e()\n        let leaseASPublicPath=FindMarket.getPublicPath(leaseASSaleItemType, name: \"findLease\")\n        let leaseASStoragePath= FindMarket.getStoragePath(leaseASSaleItemType, name:\"findLease\")\n        let leaseASSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath) \n        if !leaseASSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseASStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath, target: leaseASStoragePath)\n        }\n\n\n        let leaseASBidType= Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e()\n        let leaseASBidPublicPath=FindMarket.getPublicPath(leaseASBidType, name: \"findLease\")\n        let leaseASBidStoragePath= FindMarket.getStoragePath(leaseASBidType, name: \"findLease\")\n        let leaseASBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath) \n        if !leaseASBidCap.check() {\n            account.save\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseASBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath, target: leaseASBidStoragePath)\n        }\n\n        // let leaseAESaleItemType= Type\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e()\n        // let leaseAEPublicPath=FindMarket.getPublicPath(leaseAESaleItemType, name: \"findLease\")\n        // let leaseAEStoragePath= FindMarket.getStoragePath(leaseAESaleItemType, name:\"findLease\")\n        // let leaseAESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath) \n        // if !leaseAESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseAEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath, target: leaseAEStoragePath)\n        // }\n\n        // let leaseAEBidType= Type\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e()\n        // let leaseAEBidPublicPath=FindMarket.getPublicPath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidStoragePath= FindMarket.getStoragePath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath) \n        // if !leaseAEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseAEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath, target: leaseAEBidStoragePath)\n        // }\n\n        let leaseDOSSaleItemType= Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e()\n        let leaseDOSPublicPath=FindMarket.getPublicPath(leaseDOSSaleItemType, name: \"findLease\")\n        let leaseDOSStoragePath= FindMarket.getStoragePath(leaseDOSSaleItemType, name:\"findLease\")\n        let leaseDOSSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath) \n        if !leaseDOSSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOSStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath, target: leaseDOSStoragePath)\n        }\n\n        let leaseDOSBidType= Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let leaseDOSBidPublicPath=FindMarket.getPublicPath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidStoragePath= FindMarket.getStoragePath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath) \n        if !leaseDOSBidCap.check() {\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOSBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath, target: leaseDOSBidStoragePath)\n        }\n\n        // let leaseDOESaleItemType= Type\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        // let leaseDOEPublicPath=FindMarket.getPublicPath(leaseDOESaleItemType, name: \"findLease\")\n        // let leaseDOEStoragePath= FindMarket.getStoragePath(leaseDOESaleItemType, name:\"findLease\")\n        // let leaseDOESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath) \n        // if !leaseDOESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath, target: leaseDOEStoragePath)\n        // }\n\n        // let leaseDOEBidType= Type\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        // let leaseDOEBidPublicPath=FindMarket.getPublicPath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidStoragePath= FindMarket.getStoragePath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath) \n        // if !leaseDOEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath, target: leaseDOEBidStoragePath)\n        // }\n        //SYNC with register\n\n        let resolveAddress = FIND.resolve(user)\n        if resolveAddress == nil {panic(\"The address input is not a valid name nor address. Input : \".concat(user))}\n        let address = resolveAddress!\n\n        self.saleItemsCap= FindMarketAuctionEscrow.getSaleItemCapability(marketplace:marketplace, user:address) ?? panic(\"cannot find sale item cap. User address : \".concat(address.toString()))\n\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e())\n        let item = FindMarket.assertOperationValid(tenant: marketplace, address: address, marketOption: marketOption, id: id)\n\n        let nftIdentifier = item.getItemType().identifier\n        let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier)) \n        let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n        let nft = collection.collectionData\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n    \n        self.targetCapability= account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(nft.publicPath)\n        /* Check for nftCapability */\n        if !self.targetCapability.check() {\n            let cd = item.getNFTCollectionData()\n            // should use account.type here instead\n            if account.type(at: cd.storagePath) != nil {\n                let pathIdentifier = nft.publicPath.toString()\n                let findPath = PublicPath(identifier: pathIdentifier.slice(from: \"/public/\".length , upTo: pathIdentifier.length).concat(\"_FIND\"))!\n                account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                    findPath,\n                    target: nft.storagePath\n                )\n                self.targetCapability = account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(findPath)\n            } else {\n                account.save(\u003c- cd.createEmptyCollection(), to: cd.storagePath)\n                account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.publicPath, target: cd.storagePath)\n                account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.providerPath, target: cd.storagePath)\n            }\n\n        }\n        \n        self.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n\n        let bidSstoragePath=tenant.getStoragePath(Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e())!\n\n        self.bidsReference= account.borrow\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection\u003e(from: bidSstoragePath)\n        self.balanceBeforeBid=self.walletReference.balance\n        self.pointer= FindViews.createViewReadPointer(address: address, path:nft.publicPath, id: item.getItemID())\n    }\n\n    pre {\n        self.bidsReference != nil : \"This account does not have a bid collection\"\n        self.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount) \n        self.bidsReference!.bid(item:self.pointer, vault: \u003c- vault, nftCap: self.targetCapability, bidExtraField: {})\n    }\n\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "user",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64",
                     "marketplace": "Address",
                     "user": "String"
                  }
               }
            },
            "bidMarketAuctionSoft": {
               "code": "import FindMarketSale from 0x35717efbbce11c74\nimport FindMarketAuctionEscrow from 0x35717efbbce11c74\nimport FindMarketAuctionSoft from 0x35717efbbce11c74\nimport FindMarketDirectOfferEscrow from 0x35717efbbce11c74\nimport FindMarketDirectOfferSoft from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FindViews from 0x35717efbbce11c74\nimport FTRegistry from 0x35717efbbce11c74\nimport NFTCatalog from 0x324c34e1c517e4db\nimport FINDNFTCatalog from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\nimport FUSD from 0xe223d8a629e49c68\nimport FiatToken from 0xa983fecbed621163\nimport FlowToken from 0x7e60df042a9c0868\nimport Dandy from 0x35717efbbce11c74\nimport Profile from 0x35717efbbce11c74\nimport FindLeaseMarketSale from 0x35717efbbce11c74\nimport FindLeaseMarketAuctionSoft from 0x35717efbbce11c74\n// import FindLeaseMarketAuctionEscrow from \"../contracts/FindLeaseMarketAuctionEscrow.cdc\"\nimport FindLeaseMarketDirectOfferSoft from 0x35717efbbce11c74\n// import FindLeaseMarketDirectOfferEscrow from \"../contracts/FindLeaseMarketDirectOfferEscrow.cdc\"\nimport FindLeaseMarket from 0x35717efbbce11c74\n\ntransaction(marketplace:Address, user: String, id: UInt64, amount: UFix64) {\n\n    let saleItemsCap: Capability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic}\u003e \n    var targetCapability : Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e\n    let walletReference : \u0026FungibleToken.Vault\n    let bidsReference: \u0026FindMarketAuctionSoft.MarketBidCollection?\n    let balanceBeforeBid: UFix64\n    let pointer: FindViews.ViewReadPointer\n    let ftVaultType: Type\n\n    prepare(account: AuthAccount) {\n\n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n        //SYNC with register\n        //Add exising FUSD or create a new one and add it\n        let name = account.address.toString()\n        let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n        if !fusdReceiver.check() {\n            let fusd \u003c- FUSD.createEmptyVault()\n            account.save(\u003c- fusd, to: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n        }\n\n        let usdcCap = account.getCapability\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e(FiatToken.VaultReceiverPubPath)\n        if !usdcCap.check() {\n                account.save( \u003c-FiatToken.createEmptyVault(), to: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e( FiatToken.VaultReceiverPubPath, target: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FiatToken.ResourceId}\u003e( FiatToken.VaultUUIDPubPath, target: FiatToken.VaultStoragePath)\n                account.link\u003c\u0026FiatToken.Vault{FungibleToken.Balance}\u003e( FiatToken.VaultBalancePubPath, target:FiatToken.VaultStoragePath)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let dandyCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        let dandyCapPrivate= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPrivatePath)\n        if !dandyCapPrivate.check() {\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        var created=false\n        var updated=false\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        if !profile.hasWallet(\"Flow\") {\n            let flowWallet=Profile.Wallet( name:\"Flow\", receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), tags: [\"flow\"])\n    \n            profile.addWallet(flowWallet)\n            updated=true\n        }\n        if !profile.hasWallet(\"FUSD\") {\n            profile.addWallet(Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), tags: [\"fusd\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if !profile.hasWallet(\"USDC\") {\n            profile.addWallet(Profile.Wallet( name:\"USDC\", receiver:usdcCap, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(FiatToken.VaultBalancePubPath), accept: Type\u003c@FiatToken.Vault\u003e(), tags: [\"usdc\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else if updated {\n            profile.emitUpdatedEvent()\n        }\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        let doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        let doeSalePublicPath=FindMarket.getPublicPath(doeSaleType, name: tenant.name)\n        let doeSaleStoragePath= FindMarket.getStoragePath(doeSaleType, name:tenant.name)\n        let doeSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n        if !doeSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n        }\n\n        let doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        let doeBidPublicPath=FindMarket.getPublicPath(doeBidType, name: tenant.name)\n        let doeBidStoragePath= FindMarket.getStoragePath(doeBidType, name:tenant.name)\n        let doeBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n        if !doeBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n        }\n\n        /// auctions that escrow ft\n        let aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        let aeSalePublicPath=FindMarket.getPublicPath(aeSaleType, name: tenant.name)\n        let aeSaleStoragePath= FindMarket.getStoragePath(aeSaleType, name:tenant.name)\n        let aeSaleCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n        if !aeSaleCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n        }\n\n        let dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\n        let dosSalePublicPath=FindMarket.getPublicPath(dosSaleType, name: tenant.name)\n        let dosSaleStoragePath= FindMarket.getStoragePath(dosSaleType, name:tenant.name)\n\n        let dosSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n        if !dosSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n        }\n\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n        if !dosBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n        }\n\n        let aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\n        let aeBidPublicPath=FindMarket.getPublicPath(aeBidType, name: tenant.name)\n        let aeBidStoragePath= FindMarket.getStoragePath(aeBidType, name:tenant.name)\n        let aeBidCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n        if !aeBidCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n        }\n\n     /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n        }\n\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n        if !asBidCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n        }\n\n        let leaseTenantCapability= FindMarket.getTenantCapability(FindMarket.getTenantAddress(\"findLease\")!)!\n\n        let leaseSaleItemType= Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()\n        let leasePublicPath=FindMarket.getPublicPath(leaseSaleItemType, name: \"findLease\")\n        let leaseStoragePath= FindMarket.getStoragePath(leaseSaleItemType, name:\"findLease\")\n        let leaseSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath) \n        if !leaseSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketSale.SaleItemCollection\u003e(\u003c- FindLeaseMarketSale.createEmptySaleItemCollection(leaseTenantCapability), to: leaseStoragePath)\n            account.link\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath, target: leaseStoragePath)\n        }\n\n        let leaseASSaleItemType= Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e()\n        let leaseASPublicPath=FindMarket.getPublicPath(leaseASSaleItemType, name: \"findLease\")\n        let leaseASStoragePath= FindMarket.getStoragePath(leaseASSaleItemType, name:\"findLease\")\n        let leaseASSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath) \n        if !leaseASSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseASStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath, target: leaseASStoragePath)\n        }\n\n\n        let leaseASBidType= Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e()\n        let leaseASBidPublicPath=FindMarket.getPublicPath(leaseASBidType, name: \"findLease\")\n        let leaseASBidStoragePath= FindMarket.getStoragePath(leaseASBidType, name: \"findLease\")\n        let leaseASBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath) \n        if !leaseASBidCap.check() {\n            account.save\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseASBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath, target: leaseASBidStoragePath)\n        }\n\n        // let leaseAESaleItemType= Type\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e()\n        // let leaseAEPublicPath=FindMarket.getPublicPath(leaseAESaleItemType, name: \"findLease\")\n        // let leaseAEStoragePath= FindMarket.getStoragePath(leaseAESaleItemType, name:\"findLease\")\n        // let leaseAESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath) \n        // if !leaseAESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseAEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath, target: leaseAEStoragePath)\n        // }\n\n        // let leaseAEBidType= Type\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e()\n        // let leaseAEBidPublicPath=FindMarket.getPublicPath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidStoragePath= FindMarket.getStoragePath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath) \n        // if !leaseAEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseAEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath, target: leaseAEBidStoragePath)\n        // }\n\n        let leaseDOSSaleItemType= Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e()\n        let leaseDOSPublicPath=FindMarket.getPublicPath(leaseDOSSaleItemType, name: \"findLease\")\n        let leaseDOSStoragePath= FindMarket.getStoragePath(leaseDOSSaleItemType, name:\"findLease\")\n        let leaseDOSSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath) \n        if !leaseDOSSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOSStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath, target: leaseDOSStoragePath)\n        }\n\n        let leaseDOSBidType= Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let leaseDOSBidPublicPath=FindMarket.getPublicPath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidStoragePath= FindMarket.getStoragePath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath) \n        if !leaseDOSBidCap.check() {\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOSBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath, target: leaseDOSBidStoragePath)\n        }\n\n        // let leaseDOESaleItemType= Type\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        // let leaseDOEPublicPath=FindMarket.getPublicPath(leaseDOESaleItemType, name: \"findLease\")\n        // let leaseDOEStoragePath= FindMarket.getStoragePath(leaseDOESaleItemType, name:\"findLease\")\n        // let leaseDOESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath) \n        // if !leaseDOESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath, target: leaseDOEStoragePath)\n        // }\n\n        // let leaseDOEBidType= Type\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        // let leaseDOEBidPublicPath=FindMarket.getPublicPath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidStoragePath= FindMarket.getStoragePath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath) \n        // if !leaseDOEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath, target: leaseDOEBidStoragePath)\n        // }\n        //SYNC with register\n\n        let resolveAddress = FIND.resolve(user)\n        if resolveAddress == nil {panic(\"The address input is not a valid name nor address. Input : \".concat(user))}\n        let address = resolveAddress!\n\n        self.saleItemsCap= FindMarketAuctionSoft.getSaleItemCapability(marketplace:marketplace, user:address) ?? panic(\"cannot find sale item cap\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e())\n\n        let item = FindMarket.assertOperationValid(tenant: marketplace, address: address, marketOption: marketOption, id: id)\n\n        let nftIdentifier = item.getItemType().identifier\n        let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier)) \n        let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n        let nft = collection.collectionData\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n    \n        self.targetCapability= account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(nft.publicPath)\n        /* Check for nftCapability */\n        if !self.targetCapability.check() {\n            let cd = item.getNFTCollectionData()\n            // should use account.type here instead\n            if account.type(at: cd.storagePath) != nil {\n                let pathIdentifier = nft.publicPath.toString()\n                let findPath = PublicPath(identifier: pathIdentifier.slice(from: \"/public/\".length , upTo: pathIdentifier.length).concat(\"_FIND\"))!\n                account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                    findPath,\n                    target: nft.storagePath\n                )\n                self.targetCapability = account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(findPath)\n            } else {\n                account.save(\u003c- cd.createEmptyCollection(), to: cd.storagePath)\n                account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.publicPath, target: cd.storagePath)\n                account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.providerPath, target: cd.storagePath)\n            }\n\n        }\n        \n        self.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account. Account address : \".concat(account.address.toString()))\n        self.ftVaultType = ft.type\n\n        let bidStoragePath=tenant.getStoragePath(Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e())\n\n        self.bidsReference= account.borrow\u003c\u0026FindMarketAuctionSoft.MarketBidCollection\u003e(from: bidStoragePath)\n        self.balanceBeforeBid=self.walletReference.balance\n        self.pointer= FindViews.createViewReadPointer(address: address, path:nft.publicPath, id: item.getItemID())\n    }\n\n    pre {\n        self.bidsReference != nil : \"This account does not have a bid collection\"\n        self.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n    }\n\n    execute {\n        self.bidsReference!.bid(item:self.pointer, amount: amount, vaultType: self.ftVaultType, nftCap: self.targetCapability, bidExtraField: {})\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "user",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64",
                     "marketplace": "Address",
                     "user": "String"
                  }
               }
            },
            "bidMarketAuctionSoftDUC": {
               "code": "import FindMarketSale from 0x35717efbbce11c74\nimport FindMarketAuctionEscrow from 0x35717efbbce11c74\nimport FindMarketAuctionSoft from 0x35717efbbce11c74\nimport FindMarketDirectOfferEscrow from 0x35717efbbce11c74\nimport FindMarketDirectOfferSoft from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FindViews from 0x35717efbbce11c74\nimport FTRegistry from 0x35717efbbce11c74\nimport NFTCatalog from 0x324c34e1c517e4db\nimport FINDNFTCatalog from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\nimport TokenForwarding from 0x51ea0e37c27a1f1a\nimport DapperUtilityCoin from 0x82ec283f88a62e65\nimport FlowToken from 0x7e60df042a9c0868\nimport Dandy from 0x35717efbbce11c74\nimport Profile from 0x35717efbbce11c74\nimport FindLeaseMarketSale from 0x35717efbbce11c74\nimport FindLeaseMarketAuctionSoft from 0x35717efbbce11c74\n// import FindLeaseMarketAuctionEscrow from \"../contracts/FindLeaseMarketAuctionEscrow.cdc\"\nimport FindLeaseMarketDirectOfferSoft from 0x35717efbbce11c74\n// import FindLeaseMarketDirectOfferEscrow from \"../contracts/FindLeaseMarketDirectOfferEscrow.cdc\"\nimport FindLeaseMarket from 0x35717efbbce11c74\n\ntransaction(dapperAddress: Address, marketplace:Address, user: String, id: UInt64, amount: UFix64) {\n\n    let saleItemsCap: Capability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic}\u003e \n    var targetCapability : Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e\n    let bidsReference: \u0026FindMarketAuctionSoft.MarketBidCollection?\n    let pointer: FindViews.ViewReadPointer\n    let ftVaultType: Type\n\n    prepare(account: AuthAccount) {\n\n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n        //SYNC with register\n        //Add exising FUSD or create a new one and add it\n        let name = account.address.toString()\n        let ducReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver)\n        if !ducReceiver.check() {\n            let dapper = getAccount(dapperAddress)\n            // Create a new Forwarder resource for DUC and store it in the new account's storage\n            let ducForwarder \u003c- TokenForwarding.createNewForwarder(recipient: dapper.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver))\n            account.save(\u003c-ducForwarder, to: /storage/dapperUtilityCoinReceiver)\n            // Publish a Receiver capability for the new account, which is linked to the DUC Forwarder\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver,target: /storage/dapperUtilityCoinReceiver)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: ducReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let dandyCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        let dandyCapPrivate= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPrivatePath)\n        if !dandyCapPrivate.check() {\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        var created=false\n        var updated=false\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        if !profile.hasWallet(\"Flow\") {\n            let flowWallet=Profile.Wallet( name:\"Flow\", receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), tags: [\"flow\"])\n    \n            profile.addWallet(flowWallet)\n            updated=true\n        }\n        if !profile.hasWallet(\"DUC\") {\n            profile.addWallet(Profile.Wallet( name:\"DUC\", receiver:ducReceiver, balance:getAccount(dapperAddress).getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/dapperUtilityCoinBalance), accept: Type\u003c@DapperUtilityCoin.Vault\u003e(), tags: [\"duc\", \"dapperUtilityCoin\",\"dapper\"]))\n            updated=true\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else {\n            profile.emitUpdatedEvent()\n        }\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        let doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        let doeSalePublicPath=FindMarket.getPublicPath(doeSaleType, name: tenant.name)\n        let doeSaleStoragePath= FindMarket.getStoragePath(doeSaleType, name:tenant.name)\n        let doeSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n        if !doeSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n        }\n\n        let doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        let doeBidPublicPath=FindMarket.getPublicPath(doeBidType, name: tenant.name)\n        let doeBidStoragePath= FindMarket.getStoragePath(doeBidType, name:tenant.name)\n        let doeBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n        if !doeBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n        }\n\n        /// auctions that escrow ft\n        let aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        let aeSalePublicPath=FindMarket.getPublicPath(aeSaleType, name: tenant.name)\n        let aeSaleStoragePath= FindMarket.getStoragePath(aeSaleType, name:tenant.name)\n        let aeSaleCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n        if !aeSaleCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n        }\n\n        let dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\n        let dosSalePublicPath=FindMarket.getPublicPath(dosSaleType, name: tenant.name)\n        let dosSaleStoragePath= FindMarket.getStoragePath(dosSaleType, name:tenant.name)\n\n        let dosSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n        if !dosSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n        }\n\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n        if !dosBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n        }\n\n        let aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\n        let aeBidPublicPath=FindMarket.getPublicPath(aeBidType, name: tenant.name)\n        let aeBidStoragePath= FindMarket.getStoragePath(aeBidType, name:tenant.name)\n        let aeBidCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n        if !aeBidCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n        }\n\n     /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n        }\n\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n        if !asBidCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n        }\n\n        let leaseTenantCapability= FindMarket.getTenantCapability(FindMarket.getTenantAddress(\"findLease\")!)!\n\n        let leaseSaleItemType= Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()\n        let leasePublicPath=FindMarket.getPublicPath(leaseSaleItemType, name: \"findLease\")\n        let leaseStoragePath= FindMarket.getStoragePath(leaseSaleItemType, name:\"findLease\")\n        let leaseSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath) \n        if !leaseSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketSale.SaleItemCollection\u003e(\u003c- FindLeaseMarketSale.createEmptySaleItemCollection(leaseTenantCapability), to: leaseStoragePath)\n            account.link\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath, target: leaseStoragePath)\n        }\n\n        let leaseASSaleItemType= Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e()\n        let leaseASPublicPath=FindMarket.getPublicPath(leaseASSaleItemType, name: \"findLease\")\n        let leaseASStoragePath= FindMarket.getStoragePath(leaseASSaleItemType, name:\"findLease\")\n        let leaseASSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath) \n        if !leaseASSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseASStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath, target: leaseASStoragePath)\n        }\n\n\n        let leaseASBidType= Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e()\n        let leaseASBidPublicPath=FindMarket.getPublicPath(leaseASBidType, name: \"findLease\")\n        let leaseASBidStoragePath= FindMarket.getStoragePath(leaseASBidType, name: \"findLease\")\n        let leaseASBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath) \n        if !leaseASBidCap.check() {\n            account.save\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseASBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath, target: leaseASBidStoragePath)\n        }\n\n        // let leaseAESaleItemType= Type\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e()\n        // let leaseAEPublicPath=FindMarket.getPublicPath(leaseAESaleItemType, name: \"findLease\")\n        // let leaseAEStoragePath= FindMarket.getStoragePath(leaseAESaleItemType, name:\"findLease\")\n        // let leaseAESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath) \n        // if !leaseAESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseAEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath, target: leaseAEStoragePath)\n        // }\n\n        // let leaseAEBidType= Type\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e()\n        // let leaseAEBidPublicPath=FindMarket.getPublicPath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidStoragePath= FindMarket.getStoragePath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath) \n        // if !leaseAEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseAEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath, target: leaseAEBidStoragePath)\n        // }\n\n        let leaseDOSSaleItemType= Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e()\n        let leaseDOSPublicPath=FindMarket.getPublicPath(leaseDOSSaleItemType, name: \"findLease\")\n        let leaseDOSStoragePath= FindMarket.getStoragePath(leaseDOSSaleItemType, name:\"findLease\")\n        let leaseDOSSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath) \n        if !leaseDOSSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOSStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath, target: leaseDOSStoragePath)\n        }\n\n        let leaseDOSBidType= Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let leaseDOSBidPublicPath=FindMarket.getPublicPath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidStoragePath= FindMarket.getStoragePath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath) \n        if !leaseDOSBidCap.check() {\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOSBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath, target: leaseDOSBidStoragePath)\n        }\n\n        // let leaseDOESaleItemType= Type\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        // let leaseDOEPublicPath=FindMarket.getPublicPath(leaseDOESaleItemType, name: \"findLease\")\n        // let leaseDOEStoragePath= FindMarket.getStoragePath(leaseDOESaleItemType, name:\"findLease\")\n        // let leaseDOESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath) \n        // if !leaseDOESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath, target: leaseDOEStoragePath)\n        // }\n\n        // let leaseDOEBidType= Type\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        // let leaseDOEBidPublicPath=FindMarket.getPublicPath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidStoragePath= FindMarket.getStoragePath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath) \n        // if !leaseDOEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath, target: leaseDOEBidStoragePath)\n        // }\n        //SYNC with register\n\n        let resolveAddress = FIND.resolve(user)\n        if resolveAddress == nil {panic(\"The address input is not a valid name nor address. Input : \".concat(user))}\n        let address = resolveAddress!\n\n        self.saleItemsCap= FindMarketAuctionSoft.getSaleItemCapability(marketplace:marketplace, user:address) ?? panic(\"cannot find sale item cap\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e())\n\n        let item = FindMarket.assertOperationValid(tenant: marketplace, address: address, marketOption: marketOption, id: id)\n\n        let nftIdentifier = item.getItemType().identifier\n        let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier)) \n        let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n        let nft = collection.collectionData\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n    \n        self.targetCapability= account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(nft.publicPath)\n        /* Check for nftCapability */\n        if !self.targetCapability.check() {\n            let cd = item.getNFTCollectionData()\n            // should use account.type here instead\n            if account.type(at: cd.storagePath) != nil {\n                let pathIdentifier = nft.publicPath.toString()\n                let findPath = PublicPath(identifier: pathIdentifier.slice(from: \"/public/\".length , upTo: pathIdentifier.length).concat(\"_FIND\"))!\n                account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                    findPath,\n                    target: nft.storagePath\n                )\n                self.targetCapability = account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(findPath)\n            } else {\n                account.save(\u003c- cd.createEmptyCollection(), to: cd.storagePath)\n                account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.publicPath, target: cd.storagePath)\n                account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.providerPath, target: cd.storagePath)\n            }\n\n        }\n        \n        self.ftVaultType = ft.type\n\n        let bidStoragePath=tenant.getStoragePath(Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e())\n\n        self.bidsReference= account.borrow\u003c\u0026FindMarketAuctionSoft.MarketBidCollection\u003e(from: bidStoragePath)\n        self.pointer= FindViews.createViewReadPointer(address: address, path:nft.publicPath, id: item.getItemID())\n    }\n\n    pre {\n        self.bidsReference != nil : \"This account does not have a bid collection\"\n    }\n\n    execute {\n        self.bidsReference!.bid(item:self.pointer, amount: amount, vaultType: self.ftVaultType, nftCap: self.targetCapability, bidExtraField: {})\n    }\n}",
               "spec": {
                  "order": [
                     "dapperAddress",
                     "marketplace",
                     "user",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "dapperAddress": "Address",
                     "id": "UInt64",
                     "marketplace": "Address",
                     "user": "String"
                  }
               }
            },
            "bidMarketDirectOfferEscrowed": {
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FindMarketSale from 0x35717efbbce11c74\nimport FindMarketAuctionEscrow from 0x35717efbbce11c74\nimport FindMarketAuctionSoft from 0x35717efbbce11c74\nimport FindMarketDirectOfferEscrow from 0x35717efbbce11c74\nimport FindMarketDirectOfferSoft from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FindViews from 0x35717efbbce11c74\nimport FTRegistry from 0x35717efbbce11c74\nimport NFTCatalog from 0x324c34e1c517e4db\nimport FINDNFTCatalog from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\nimport FUSD from 0xe223d8a629e49c68\nimport FiatToken from 0xa983fecbed621163\nimport FlowToken from 0x7e60df042a9c0868\nimport Dandy from 0x35717efbbce11c74\nimport Profile from 0x35717efbbce11c74\nimport FindLeaseMarketSale from 0x35717efbbce11c74\nimport FindLeaseMarketAuctionSoft from 0x35717efbbce11c74\n// import FindLeaseMarketAuctionEscrow from \"../contracts/FindLeaseMarketAuctionEscrow.cdc\"\nimport FindLeaseMarketDirectOfferSoft from 0x35717efbbce11c74\n// import FindLeaseMarketDirectOfferEscrow from \"../contracts/FindLeaseMarketDirectOfferEscrow.cdc\"\nimport FindLeaseMarket from 0x35717efbbce11c74\n\ntransaction(marketplace:Address, user: String, nftAliasOrIdentifier: String, id: UInt64, ftAliasOrIdentifier:String, amount: UFix64, validUntil: UFix64?) {\n\n    var targetCapability : Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e\n    let walletReference : \u0026FungibleToken.Vault\n    let bidsReference: \u0026FindMarketDirectOfferEscrow.MarketBidCollection?\n    let pointer: FindViews.ViewReadPointer\n\n    prepare(account: AuthAccount) {\n\n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n        //SYNC with register\n        //Add exising FUSD or create a new one and add it\n        let name = account.address.toString()\n        let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n        if !fusdReceiver.check() {\n            let fusd \u003c- FUSD.createEmptyVault()\n            account.save(\u003c- fusd, to: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n        }\n\n        let usdcCap = account.getCapability\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e(FiatToken.VaultReceiverPubPath)\n        if !usdcCap.check() {\n                account.save( \u003c-FiatToken.createEmptyVault(), to: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e( FiatToken.VaultReceiverPubPath, target: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FiatToken.ResourceId}\u003e( FiatToken.VaultUUIDPubPath, target: FiatToken.VaultStoragePath)\n                account.link\u003c\u0026FiatToken.Vault{FungibleToken.Balance}\u003e( FiatToken.VaultBalancePubPath, target:FiatToken.VaultStoragePath)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let dandyCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        let dandyCapPrivate= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPrivatePath)\n        if !dandyCapPrivate.check() {\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        var created=false\n        var updated=false\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        if !profile.hasWallet(\"Flow\") {\n            let flowWallet=Profile.Wallet( name:\"Flow\", receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), tags: [\"flow\"])\n    \n            profile.addWallet(flowWallet)\n            updated=true\n        }\n        if !profile.hasWallet(\"FUSD\") {\n            profile.addWallet(Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), tags: [\"fusd\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if !profile.hasWallet(\"USDC\") {\n            profile.addWallet(Profile.Wallet( name:\"USDC\", receiver:usdcCap, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(FiatToken.VaultBalancePubPath), accept: Type\u003c@FiatToken.Vault\u003e(), tags: [\"usdc\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else if updated {\n            profile.emitUpdatedEvent()\n        }\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        let doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        let doeSalePublicPath=FindMarket.getPublicPath(doeSaleType, name: tenant.name)\n        let doeSaleStoragePath= FindMarket.getStoragePath(doeSaleType, name:tenant.name)\n        let doeSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n        if !doeSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n        }\n\n        let doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        let doeBidPublicPath=FindMarket.getPublicPath(doeBidType, name: tenant.name)\n        let doeBidStoragePath= FindMarket.getStoragePath(doeBidType, name:tenant.name)\n        let doeBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n        if !doeBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n        }\n\n        /// auctions that escrow ft\n        let aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        let aeSalePublicPath=FindMarket.getPublicPath(aeSaleType, name: tenant.name)\n        let aeSaleStoragePath= FindMarket.getStoragePath(aeSaleType, name:tenant.name)\n        let aeSaleCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n        if !aeSaleCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n        }\n\n        let dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\n        let dosSalePublicPath=FindMarket.getPublicPath(dosSaleType, name: tenant.name)\n        let dosSaleStoragePath= FindMarket.getStoragePath(dosSaleType, name:tenant.name)\n\n        let dosSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n        if !dosSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n        }\n\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n        if !dosBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n        }\n\n        let aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\n        let aeBidPublicPath=FindMarket.getPublicPath(aeBidType, name: tenant.name)\n        let aeBidStoragePath= FindMarket.getStoragePath(aeBidType, name:tenant.name)\n        let aeBidCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n        if !aeBidCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n        }\n\n     /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n        }\n\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n        if !asBidCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n        }\n\n        let leaseTenantCapability= FindMarket.getTenantCapability(FindMarket.getTenantAddress(\"findLease\")!)!\n\n        let leaseSaleItemType= Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()\n        let leasePublicPath=FindMarket.getPublicPath(leaseSaleItemType, name: \"findLease\")\n        let leaseStoragePath= FindMarket.getStoragePath(leaseSaleItemType, name:\"findLease\")\n        let leaseSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath) \n        if !leaseSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketSale.SaleItemCollection\u003e(\u003c- FindLeaseMarketSale.createEmptySaleItemCollection(leaseTenantCapability), to: leaseStoragePath)\n            account.link\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath, target: leaseStoragePath)\n        }\n\n        let leaseASSaleItemType= Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e()\n        let leaseASPublicPath=FindMarket.getPublicPath(leaseASSaleItemType, name: \"findLease\")\n        let leaseASStoragePath= FindMarket.getStoragePath(leaseASSaleItemType, name:\"findLease\")\n        let leaseASSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath) \n        if !leaseASSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseASStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath, target: leaseASStoragePath)\n        }\n\n\n        let leaseASBidType= Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e()\n        let leaseASBidPublicPath=FindMarket.getPublicPath(leaseASBidType, name: \"findLease\")\n        let leaseASBidStoragePath= FindMarket.getStoragePath(leaseASBidType, name: \"findLease\")\n        let leaseASBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath) \n        if !leaseASBidCap.check() {\n            account.save\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseASBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath, target: leaseASBidStoragePath)\n        }\n\n        // let leaseAESaleItemType= Type\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e()\n        // let leaseAEPublicPath=FindMarket.getPublicPath(leaseAESaleItemType, name: \"findLease\")\n        // let leaseAEStoragePath= FindMarket.getStoragePath(leaseAESaleItemType, name:\"findLease\")\n        // let leaseAESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath) \n        // if !leaseAESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseAEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath, target: leaseAEStoragePath)\n        // }\n\n        // let leaseAEBidType= Type\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e()\n        // let leaseAEBidPublicPath=FindMarket.getPublicPath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidStoragePath= FindMarket.getStoragePath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath) \n        // if !leaseAEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseAEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath, target: leaseAEBidStoragePath)\n        // }\n\n        let leaseDOSSaleItemType= Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e()\n        let leaseDOSPublicPath=FindMarket.getPublicPath(leaseDOSSaleItemType, name: \"findLease\")\n        let leaseDOSStoragePath= FindMarket.getStoragePath(leaseDOSSaleItemType, name:\"findLease\")\n        let leaseDOSSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath) \n        if !leaseDOSSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOSStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath, target: leaseDOSStoragePath)\n        }\n\n        let leaseDOSBidType= Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let leaseDOSBidPublicPath=FindMarket.getPublicPath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidStoragePath= FindMarket.getStoragePath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath) \n        if !leaseDOSBidCap.check() {\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOSBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath, target: leaseDOSBidStoragePath)\n        }\n\n        // let leaseDOESaleItemType= Type\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        // let leaseDOEPublicPath=FindMarket.getPublicPath(leaseDOESaleItemType, name: \"findLease\")\n        // let leaseDOEStoragePath= FindMarket.getStoragePath(leaseDOESaleItemType, name:\"findLease\")\n        // let leaseDOESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath) \n        // if !leaseDOESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath, target: leaseDOEStoragePath)\n        // }\n\n        // let leaseDOEBidType= Type\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        // let leaseDOEBidPublicPath=FindMarket.getPublicPath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidStoragePath= FindMarket.getStoragePath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath) \n        // if !leaseDOEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath, target: leaseDOEBidStoragePath)\n        // }\n        //SYNC with register\n\n        let resolveAddress = FIND.resolve(user)\n        if resolveAddress == nil {panic(\"The address input is not a valid name nor address. Input : \".concat(user))}\n        let address = resolveAddress!\n\n        let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftAliasOrIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftAliasOrIdentifier)) \n        let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n        let nft = collection.collectionData\n\n        let ft = FTRegistry.getFTInfo(ftAliasOrIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftAliasOrIdentifier))\n        \n        self.targetCapability= account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(nft.publicPath)\n        self.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n\n        let bidStoragePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e())!\n\n        self.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection\u003e(from: bidStoragePath)\n        self.pointer= FindViews.createViewReadPointer(address: address, path:nft.publicPath, id: id)\n\n        /* Check for nftCapability */\n        if !self.targetCapability.check() {\n            let cd = self.pointer.getNFTCollectionData()\n            // should use account.type here instead\n            if account.type(at: cd.storagePath) != nil {\n                let pathIdentifier = nft.publicPath.toString()\n                let findPath = PublicPath(identifier: pathIdentifier.slice(from: \"/public/\".length , upTo: pathIdentifier.length).concat(\"_FIND\"))!\n                account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                    findPath,\n                    target: nft.storagePath\n                )\n                self.targetCapability = account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(findPath)\n            } else {\n                account.save(\u003c- cd.createEmptyCollection(), to: cd.storagePath)\n                account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.publicPath, target: cd.storagePath)\n                account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.providerPath, target: cd.storagePath)\n            }\n\n        }\n    }\n\n    pre {\n        self.bidsReference != nil : \"This account does not have a bid collection\"\n        self.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount) \n        self.bidsReference!.bid(item:self.pointer, vault: \u003c- vault, nftCap: self.targetCapability, validUntil: validUntil, saleItemExtraField: {}, bidExtraField: {})\n    }\n\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "user",
                     "nftAliasOrIdentifier",
                     "id",
                     "ftAliasOrIdentifier",
                     "amount",
                     "validUntil"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "ftAliasOrIdentifier": "String",
                     "id": "UInt64",
                     "marketplace": "Address",
                     "nftAliasOrIdentifier": "String",
                     "user": "String",
                     "validUntil": "UFix64?"
                  }
               }
            },
            "bidMarketDirectOfferSoft": {
               "code": "import FindMarketSale from 0x35717efbbce11c74\nimport FindMarketAuctionEscrow from 0x35717efbbce11c74\nimport FindMarketAuctionSoft from 0x35717efbbce11c74\nimport FindMarketDirectOfferEscrow from 0x35717efbbce11c74\nimport FindMarketDirectOfferSoft from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FindViews from 0x35717efbbce11c74\nimport FTRegistry from 0x35717efbbce11c74\nimport NFTCatalog from 0x324c34e1c517e4db\nimport FINDNFTCatalog from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\nimport FUSD from 0xe223d8a629e49c68\nimport FiatToken from 0xa983fecbed621163\nimport FlowToken from 0x7e60df042a9c0868\nimport Dandy from 0x35717efbbce11c74\nimport Profile from 0x35717efbbce11c74\nimport FindLeaseMarketSale from 0x35717efbbce11c74\nimport FindLeaseMarketAuctionSoft from 0x35717efbbce11c74\n// import FindLeaseMarketAuctionEscrow from \"../contracts/FindLeaseMarketAuctionEscrow.cdc\"\nimport FindLeaseMarketDirectOfferSoft from 0x35717efbbce11c74\n// import FindLeaseMarketDirectOfferEscrow from \"../contracts/FindLeaseMarketDirectOfferEscrow.cdc\"\nimport FindLeaseMarket from 0x35717efbbce11c74\n\ntransaction(marketplace:Address, user: String, nftAliasOrIdentifier: String, id: UInt64, ftAliasOrIdentifier:String, amount: UFix64, validUntil: UFix64?) {\n\n    var targetCapability : Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e\n    let walletReference : \u0026FungibleToken.Vault\n    let bidsReference: \u0026FindMarketDirectOfferSoft.MarketBidCollection?\n    let balanceBeforeBid: UFix64\n    let pointer: FindViews.ViewReadPointer\n    let ftVaultType: Type\n\n    prepare(account: AuthAccount) {\n        \n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n        //SYNC with register\n        //Add exising FUSD or create a new one and add it\n        let name = account.address.toString()\n        let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n        if !fusdReceiver.check() {\n            let fusd \u003c- FUSD.createEmptyVault()\n            account.save(\u003c- fusd, to: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n        }\n\n        let usdcCap = account.getCapability\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e(FiatToken.VaultReceiverPubPath)\n        if !usdcCap.check() {\n                account.save( \u003c-FiatToken.createEmptyVault(), to: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e( FiatToken.VaultReceiverPubPath, target: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FiatToken.ResourceId}\u003e( FiatToken.VaultUUIDPubPath, target: FiatToken.VaultStoragePath)\n                account.link\u003c\u0026FiatToken.Vault{FungibleToken.Balance}\u003e( FiatToken.VaultBalancePubPath, target:FiatToken.VaultStoragePath)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let dandyCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        let dandyCapPrivate= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPrivatePath)\n        if !dandyCapPrivate.check() {\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        var created=false\n        var updated=false\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        if !profile.hasWallet(\"Flow\") {\n            let flowWallet=Profile.Wallet( name:\"Flow\", receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), tags: [\"flow\"])\n    \n            profile.addWallet(flowWallet)\n            updated=true\n        }\n        if !profile.hasWallet(\"FUSD\") {\n            profile.addWallet(Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), tags: [\"fusd\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if !profile.hasWallet(\"USDC\") {\n            profile.addWallet(Profile.Wallet( name:\"USDC\", receiver:usdcCap, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(FiatToken.VaultBalancePubPath), accept: Type\u003c@FiatToken.Vault\u003e(), tags: [\"usdc\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else if updated {\n            profile.emitUpdatedEvent()\n        }\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        let doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        let doeSalePublicPath=FindMarket.getPublicPath(doeSaleType, name: tenant.name)\n        let doeSaleStoragePath= FindMarket.getStoragePath(doeSaleType, name:tenant.name)\n        let doeSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n        if !doeSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n        }\n\n        let doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        let doeBidPublicPath=FindMarket.getPublicPath(doeBidType, name: tenant.name)\n        let doeBidStoragePath= FindMarket.getStoragePath(doeBidType, name:tenant.name)\n        let doeBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n        if !doeBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n        }\n\n        /// auctions that escrow ft\n        let aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        let aeSalePublicPath=FindMarket.getPublicPath(aeSaleType, name: tenant.name)\n        let aeSaleStoragePath= FindMarket.getStoragePath(aeSaleType, name:tenant.name)\n        let aeSaleCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n        if !aeSaleCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n        }\n\n        let dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\n        let dosSalePublicPath=FindMarket.getPublicPath(dosSaleType, name: tenant.name)\n        let dosSaleStoragePath= FindMarket.getStoragePath(dosSaleType, name:tenant.name)\n\n        let dosSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n        if !dosSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n        }\n\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n        if !dosBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n        }\n\n        let aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\n        let aeBidPublicPath=FindMarket.getPublicPath(aeBidType, name: tenant.name)\n        let aeBidStoragePath= FindMarket.getStoragePath(aeBidType, name:tenant.name)\n        let aeBidCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n        if !aeBidCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n        }\n\n     /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n        }\n\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n        if !asBidCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n        }\n\n        let leaseTenantCapability= FindMarket.getTenantCapability(FindMarket.getTenantAddress(\"findLease\")!)!\n\n        let leaseSaleItemType= Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()\n        let leasePublicPath=FindMarket.getPublicPath(leaseSaleItemType, name: \"findLease\")\n        let leaseStoragePath= FindMarket.getStoragePath(leaseSaleItemType, name:\"findLease\")\n        let leaseSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath) \n        if !leaseSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketSale.SaleItemCollection\u003e(\u003c- FindLeaseMarketSale.createEmptySaleItemCollection(leaseTenantCapability), to: leaseStoragePath)\n            account.link\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath, target: leaseStoragePath)\n        }\n\n        let leaseASSaleItemType= Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e()\n        let leaseASPublicPath=FindMarket.getPublicPath(leaseASSaleItemType, name: \"findLease\")\n        let leaseASStoragePath= FindMarket.getStoragePath(leaseASSaleItemType, name:\"findLease\")\n        let leaseASSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath) \n        if !leaseASSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseASStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath, target: leaseASStoragePath)\n        }\n\n\n        let leaseASBidType= Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e()\n        let leaseASBidPublicPath=FindMarket.getPublicPath(leaseASBidType, name: \"findLease\")\n        let leaseASBidStoragePath= FindMarket.getStoragePath(leaseASBidType, name: \"findLease\")\n        let leaseASBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath) \n        if !leaseASBidCap.check() {\n            account.save\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseASBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath, target: leaseASBidStoragePath)\n        }\n\n        // let leaseAESaleItemType= Type\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e()\n        // let leaseAEPublicPath=FindMarket.getPublicPath(leaseAESaleItemType, name: \"findLease\")\n        // let leaseAEStoragePath= FindMarket.getStoragePath(leaseAESaleItemType, name:\"findLease\")\n        // let leaseAESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath) \n        // if !leaseAESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseAEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath, target: leaseAEStoragePath)\n        // }\n\n        // let leaseAEBidType= Type\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e()\n        // let leaseAEBidPublicPath=FindMarket.getPublicPath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidStoragePath= FindMarket.getStoragePath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath) \n        // if !leaseAEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseAEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath, target: leaseAEBidStoragePath)\n        // }\n\n        let leaseDOSSaleItemType= Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e()\n        let leaseDOSPublicPath=FindMarket.getPublicPath(leaseDOSSaleItemType, name: \"findLease\")\n        let leaseDOSStoragePath= FindMarket.getStoragePath(leaseDOSSaleItemType, name:\"findLease\")\n        let leaseDOSSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath) \n        if !leaseDOSSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOSStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath, target: leaseDOSStoragePath)\n        }\n\n        let leaseDOSBidType= Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let leaseDOSBidPublicPath=FindMarket.getPublicPath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidStoragePath= FindMarket.getStoragePath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath) \n        if !leaseDOSBidCap.check() {\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOSBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath, target: leaseDOSBidStoragePath)\n        }\n\n        // let leaseDOESaleItemType= Type\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        // let leaseDOEPublicPath=FindMarket.getPublicPath(leaseDOESaleItemType, name: \"findLease\")\n        // let leaseDOEStoragePath= FindMarket.getStoragePath(leaseDOESaleItemType, name:\"findLease\")\n        // let leaseDOESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath) \n        // if !leaseDOESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath, target: leaseDOEStoragePath)\n        // }\n\n        // let leaseDOEBidType= Type\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        // let leaseDOEBidPublicPath=FindMarket.getPublicPath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidStoragePath= FindMarket.getStoragePath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath) \n        // if !leaseDOEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath, target: leaseDOEBidStoragePath)\n        // }\n        //SYNC with register\n\n        let resolveAddress = FIND.resolve(user)\n        if resolveAddress == nil {panic(\"The address input is not a valid name nor address. Input : \".concat(user))}\n        let address = resolveAddress!\n\n        let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftAliasOrIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftAliasOrIdentifier)) \n        let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n        let nft = collection.collectionData\n\n        let ft = FTRegistry.getFTInfo(ftAliasOrIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftAliasOrIdentifier))\n\n        self.ftVaultType = ft.type\n\n        self.targetCapability= account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(nft.publicPath)\n        self.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n\n        let bidStoragePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())!\n        self.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection\u003e(from: bidStoragePath)\n        self.balanceBeforeBid=self.walletReference.balance\n        self.pointer= FindViews.createViewReadPointer(address: address, path:nft.publicPath, id: id)\n\n        /* Check for nftCapability */\n        if !self.targetCapability.check() {\n            let cd = self.pointer.getNFTCollectionData()\n            // should use account.type here instead\n            if account.type(at: cd.storagePath) != nil {\n                let pathIdentifier = nft.publicPath.toString()\n                let findPath = PublicPath(identifier: pathIdentifier.slice(from: \"/public/\".length , upTo: pathIdentifier.length).concat(\"_FIND\"))!\n                account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                    findPath,\n                    target: nft.storagePath\n                )\n                self.targetCapability = account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(findPath)\n            } else {\n                account.save(\u003c- cd.createEmptyCollection(), to: cd.storagePath)\n                account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.publicPath, target: cd.storagePath)\n                account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.providerPath, target: cd.storagePath)\n            }\n\n        }\n    }\n\n    pre {\n        self.bidsReference != nil : \"This account does not have a bid collection\"\n        self.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n    }\n\n    execute {\n        self.bidsReference!.bid(item:self.pointer, amount: amount, vaultType: self.ftVaultType, nftCap: self.targetCapability, validUntil: validUntil, saleItemExtraField: {}, bidExtraField: {})\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "user",
                     "nftAliasOrIdentifier",
                     "id",
                     "ftAliasOrIdentifier",
                     "amount",
                     "validUntil"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "ftAliasOrIdentifier": "String",
                     "id": "UInt64",
                     "marketplace": "Address",
                     "nftAliasOrIdentifier": "String",
                     "user": "String",
                     "validUntil": "UFix64?"
                  }
               }
            },
            "bidMarketDirectOfferSoftDUC": {
               "code": "import FindMarketSale from 0x35717efbbce11c74\nimport FindMarketAuctionEscrow from 0x35717efbbce11c74\nimport FindMarketAuctionSoft from 0x35717efbbce11c74\nimport FindMarketDirectOfferEscrow from 0x35717efbbce11c74\nimport FindMarketDirectOfferSoft from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FindViews from 0x35717efbbce11c74\nimport NFTCatalog from 0x324c34e1c517e4db\nimport FINDNFTCatalog from 0x35717efbbce11c74\nimport FTRegistry from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\nimport FlowToken from 0x7e60df042a9c0868\nimport TokenForwarding from 0x51ea0e37c27a1f1a\nimport DapperUtilityCoin from 0x82ec283f88a62e65\nimport Dandy from 0x35717efbbce11c74\nimport Profile from 0x35717efbbce11c74\nimport FindLeaseMarketSale from 0x35717efbbce11c74\nimport FindLeaseMarketAuctionSoft from 0x35717efbbce11c74\n// import FindLeaseMarketAuctionEscrow from \"../contracts/FindLeaseMarketAuctionEscrow.cdc\"\nimport FindLeaseMarketDirectOfferSoft from 0x35717efbbce11c74\n// import FindLeaseMarketDirectOfferEscrow from \"../contracts/FindLeaseMarketDirectOfferEscrow.cdc\"\nimport FindLeaseMarket from 0x35717efbbce11c74\n\ntransaction(dapperAddress: Address, marketplace:Address, user: String, nftAliasOrIdentifier: String, id: UInt64, amount: UFix64, validUntil: UFix64?) {\n\n    var targetCapability : Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e\n    let bidsReference: \u0026FindMarketDirectOfferSoft.MarketBidCollection?\n    let pointer: FindViews.ViewReadPointer\n    let ftVaultType: Type\n\n    prepare(account: AuthAccount) {\n        \n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n        //SYNC with register\n        //Add exising FUSD or create a new one and add it\n        let name = account.address.toString()\n        let ducReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver)\n        if !ducReceiver.check() {\n            let dapper = getAccount(dapperAddress)\n            // Create a new Forwarder resource for DUC and store it in the new account's storage\n            let ducForwarder \u003c- TokenForwarding.createNewForwarder(recipient: dapper.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver))\n            account.save(\u003c-ducForwarder, to: /storage/dapperUtilityCoinReceiver)\n            // Publish a Receiver capability for the new account, which is linked to the DUC Forwarder\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver,target: /storage/dapperUtilityCoinReceiver)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: ducReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let dandyCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        let dandyCapPrivate= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPrivatePath)\n        if !dandyCapPrivate.check() {\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        var created=false\n        var updated=false\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        if !profile.hasWallet(\"Flow\") {\n            let flowWallet=Profile.Wallet( name:\"Flow\", receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), tags: [\"flow\"])\n    \n            profile.addWallet(flowWallet)\n            updated=true\n        }\n        if !profile.hasWallet(\"DUC\") {\n            profile.addWallet(Profile.Wallet( name:\"DUC\", receiver:ducReceiver, balance:getAccount(dapperAddress).getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/dapperUtilityCoinBalance), accept: Type\u003c@DapperUtilityCoin.Vault\u003e(), tags: [\"duc\", \"dapperUtilityCoin\",\"dapper\"]))\n            updated=true\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else {\n            profile.emitUpdatedEvent()\n        }\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        let doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        let doeSalePublicPath=FindMarket.getPublicPath(doeSaleType, name: tenant.name)\n        let doeSaleStoragePath= FindMarket.getStoragePath(doeSaleType, name:tenant.name)\n        let doeSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n        if !doeSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n        }\n\n        let doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        let doeBidPublicPath=FindMarket.getPublicPath(doeBidType, name: tenant.name)\n        let doeBidStoragePath= FindMarket.getStoragePath(doeBidType, name:tenant.name)\n        let doeBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n        if !doeBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n        }\n\n        /// auctions that escrow ft\n        let aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        let aeSalePublicPath=FindMarket.getPublicPath(aeSaleType, name: tenant.name)\n        let aeSaleStoragePath= FindMarket.getStoragePath(aeSaleType, name:tenant.name)\n        let aeSaleCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n        if !aeSaleCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n        }\n\n        let dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\n        let dosSalePublicPath=FindMarket.getPublicPath(dosSaleType, name: tenant.name)\n        let dosSaleStoragePath= FindMarket.getStoragePath(dosSaleType, name:tenant.name)\n\n        let dosSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n        if !dosSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n        }\n\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n        if !dosBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n        }\n\n        let aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\n        let aeBidPublicPath=FindMarket.getPublicPath(aeBidType, name: tenant.name)\n        let aeBidStoragePath= FindMarket.getStoragePath(aeBidType, name:tenant.name)\n        let aeBidCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n        if !aeBidCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n        }\n\n     /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n        }\n\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n        if !asBidCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n        }\n\n        let leaseTenantCapability= FindMarket.getTenantCapability(FindMarket.getTenantAddress(\"findLease\")!)!\n\n        let leaseSaleItemType= Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()\n        let leasePublicPath=FindMarket.getPublicPath(leaseSaleItemType, name: \"findLease\")\n        let leaseStoragePath= FindMarket.getStoragePath(leaseSaleItemType, name:\"findLease\")\n        let leaseSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath) \n        if !leaseSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketSale.SaleItemCollection\u003e(\u003c- FindLeaseMarketSale.createEmptySaleItemCollection(leaseTenantCapability), to: leaseStoragePath)\n            account.link\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath, target: leaseStoragePath)\n        }\n\n        let leaseASSaleItemType= Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e()\n        let leaseASPublicPath=FindMarket.getPublicPath(leaseASSaleItemType, name: \"findLease\")\n        let leaseASStoragePath= FindMarket.getStoragePath(leaseASSaleItemType, name:\"findLease\")\n        let leaseASSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath) \n        if !leaseASSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseASStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath, target: leaseASStoragePath)\n        }\n\n\n        let leaseASBidType= Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e()\n        let leaseASBidPublicPath=FindMarket.getPublicPath(leaseASBidType, name: \"findLease\")\n        let leaseASBidStoragePath= FindMarket.getStoragePath(leaseASBidType, name: \"findLease\")\n        let leaseASBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath) \n        if !leaseASBidCap.check() {\n            account.save\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseASBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath, target: leaseASBidStoragePath)\n        }\n\n        // let leaseAESaleItemType= Type\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e()\n        // let leaseAEPublicPath=FindMarket.getPublicPath(leaseAESaleItemType, name: \"findLease\")\n        // let leaseAEStoragePath= FindMarket.getStoragePath(leaseAESaleItemType, name:\"findLease\")\n        // let leaseAESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath) \n        // if !leaseAESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseAEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath, target: leaseAEStoragePath)\n        // }\n\n        // let leaseAEBidType= Type\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e()\n        // let leaseAEBidPublicPath=FindMarket.getPublicPath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidStoragePath= FindMarket.getStoragePath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath) \n        // if !leaseAEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseAEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath, target: leaseAEBidStoragePath)\n        // }\n\n        let leaseDOSSaleItemType= Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e()\n        let leaseDOSPublicPath=FindMarket.getPublicPath(leaseDOSSaleItemType, name: \"findLease\")\n        let leaseDOSStoragePath= FindMarket.getStoragePath(leaseDOSSaleItemType, name:\"findLease\")\n        let leaseDOSSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath) \n        if !leaseDOSSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOSStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath, target: leaseDOSStoragePath)\n        }\n\n        let leaseDOSBidType= Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let leaseDOSBidPublicPath=FindMarket.getPublicPath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidStoragePath= FindMarket.getStoragePath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath) \n        if !leaseDOSBidCap.check() {\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOSBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath, target: leaseDOSBidStoragePath)\n        }\n\n        // let leaseDOESaleItemType= Type\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        // let leaseDOEPublicPath=FindMarket.getPublicPath(leaseDOESaleItemType, name: \"findLease\")\n        // let leaseDOEStoragePath= FindMarket.getStoragePath(leaseDOESaleItemType, name:\"findLease\")\n        // let leaseDOESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath) \n        // if !leaseDOESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath, target: leaseDOEStoragePath)\n        // }\n\n        // let leaseDOEBidType= Type\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        // let leaseDOEBidPublicPath=FindMarket.getPublicPath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidStoragePath= FindMarket.getStoragePath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath) \n        // if !leaseDOEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath, target: leaseDOEBidStoragePath)\n        // }\n        //SYNC with register\n\n        let resolveAddress = FIND.resolve(user)\n        if resolveAddress == nil {panic(\"The address input is not a valid name nor address. Input : \".concat(user))}\n        let address = resolveAddress!\n\n        let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftAliasOrIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftAliasOrIdentifier)) \n        let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n        let nft = collection.collectionData\n\n        let ft = FTRegistry.getFTInfo(Type\u003c@DapperUtilityCoin.Vault\u003e().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(Type\u003c@DapperUtilityCoin.Vault\u003e().identifier))\n\n        self.ftVaultType = ft.type\n\n        self.targetCapability= account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(nft.publicPath)\n\n        let bidStoragePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())!\n        self.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection\u003e(from: bidStoragePath)\n        self.pointer= FindViews.createViewReadPointer(address: address, path:nft.publicPath, id: id)\n\n        /* Check for nftCapability */\n        if !self.targetCapability.check() {\n            let cd = self.pointer.getNFTCollectionData()\n            // should use account.type here instead\n            if account.type(at: cd.storagePath) != nil {\n                let pathIdentifier = nft.publicPath.toString()\n                let findPath = PublicPath(identifier: pathIdentifier.slice(from: \"/public/\".length , upTo: pathIdentifier.length).concat(\"_FIND\"))!\n                account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                    findPath,\n                    target: nft.storagePath\n                )\n                self.targetCapability = account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(findPath)\n            } else {\n                account.save(\u003c- cd.createEmptyCollection(), to: cd.storagePath)\n                account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.publicPath, target: cd.storagePath)\n                account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.providerPath, target: cd.storagePath)\n            }\n\n        }\n    }\n\n    pre {\n        self.bidsReference != nil : \"This account does not have a bid collection\"\n    }\n\n    execute {\n        self.bidsReference!.bid(item:self.pointer, amount: amount, vaultType: self.ftVaultType, nftCap: self.targetCapability, validUntil: validUntil, saleItemExtraField: {}, bidExtraField: {})\n    }\n}",
               "spec": {
                  "order": [
                     "dapperAddress",
                     "marketplace",
                     "user",
                     "nftAliasOrIdentifier",
                     "id",
                     "amount",
                     "validUntil"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "dapperAddress": "Address",
                     "id": "UInt64",
                     "marketplace": "Address",
                     "nftAliasOrIdentifier": "String",
                     "user": "String",
                     "validUntil": "UFix64?"
                  }
               }
            },
            "bidMultipleMarketDirectOfferEscrowed": {
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FindMarketSale from 0x35717efbbce11c74\nimport FindMarketAuctionEscrow from 0x35717efbbce11c74\nimport FindMarketAuctionSoft from 0x35717efbbce11c74\nimport FindMarketDirectOfferEscrow from 0x35717efbbce11c74\nimport FindMarketDirectOfferSoft from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FindViews from 0x35717efbbce11c74\nimport FTRegistry from 0x35717efbbce11c74\nimport NFTCatalog from 0x324c34e1c517e4db\nimport FINDNFTCatalog from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\nimport FUSD from 0xe223d8a629e49c68\nimport FiatToken from 0xa983fecbed621163\nimport FlowToken from 0x7e60df042a9c0868\nimport Dandy from 0x35717efbbce11c74\nimport Profile from 0x35717efbbce11c74\n\ntransaction(marketplace:Address, users: [String], nftAliasOrIdentifiers: [String], ids: [UInt64], ftAliasOrIdentifiers:[String], amounts: [UFix64], validUntil: UFix64?) {\n\n    let targetCapability : [Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e]\n    let walletReference : [\u0026FungibleToken.Vault]\n    let bidsReference: \u0026FindMarketDirectOfferEscrow.MarketBidCollection?\n    let pointer: [FindViews.ViewReadPointer]\n\n    prepare(account: AuthAccount) {\n\n        if nftAliasOrIdentifiers.length != users.length {\n            panic(\"The length of arrays passed in has to be the same\")\n        } else if nftAliasOrIdentifiers.length != ids.length {\n            panic(\"The length of arrays passed in has to be the same\")\n        } else if nftAliasOrIdentifiers.length != ftAliasOrIdentifiers.length {\n            panic(\"The length of arrays passed in has to be the same\")\n        } else if nftAliasOrIdentifiers.length != amounts.length {\n            panic(\"The length of arrays passed in has to be the same\")\n        }\n\n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n        //SYNC with register\n        //Add exising FUSD or create a new one and add it\n        let name = account.address.toString()\n        let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n        if !fusdReceiver.check() {\n            let fusd \u003c- FUSD.createEmptyVault()\n            account.save(\u003c- fusd, to: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n        }\n\n        let usdcCap = account.getCapability\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e(FiatToken.VaultReceiverPubPath)\n        if !usdcCap.check() {\n                account.save( \u003c-FiatToken.createEmptyVault(), to: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e( FiatToken.VaultReceiverPubPath, target: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FiatToken.ResourceId}\u003e( FiatToken.VaultUUIDPubPath, target: FiatToken.VaultStoragePath)\n                account.link\u003c\u0026FiatToken.Vault{FungibleToken.Balance}\u003e( FiatToken.VaultBalancePubPath, target:FiatToken.VaultStoragePath)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let dandyCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        let dandyCapPrivate= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPrivatePath)\n        if !dandyCapPrivate.check() {\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        var created=false\n        var updated=false\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        if !profile.hasWallet(\"Flow\") {\n            let flowWallet=Profile.Wallet( name:\"Flow\", receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), tags: [\"flow\"])\n    \n            profile.addWallet(flowWallet)\n            updated=true\n        }\n        if !profile.hasWallet(\"FUSD\") {\n            profile.addWallet(Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), tags: [\"fusd\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if !profile.hasWallet(\"USDC\") {\n            profile.addWallet(Profile.Wallet( name:\"USDC\", receiver:usdcCap, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(FiatToken.VaultBalancePubPath), accept: Type\u003c@FiatToken.Vault\u003e(), tags: [\"usdc\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else if updated {\n            profile.emitUpdatedEvent()\n        }\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        let doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        let doeSalePublicPath=FindMarket.getPublicPath(doeSaleType, name: tenant.name)\n        let doeSaleStoragePath= FindMarket.getStoragePath(doeSaleType, name:tenant.name)\n        let doeSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n        if !doeSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n        }\n\n        let doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        let doeBidPublicPath=FindMarket.getPublicPath(doeBidType, name: tenant.name)\n        let doeBidStoragePath= FindMarket.getStoragePath(doeBidType, name:tenant.name)\n        let doeBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n        if !doeBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n        }\n\n        /// auctions that escrow ft\n        let aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        let aeSalePublicPath=FindMarket.getPublicPath(aeSaleType, name: tenant.name)\n        let aeSaleStoragePath= FindMarket.getStoragePath(aeSaleType, name:tenant.name)\n        let aeSaleCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n        if !aeSaleCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n        }\n\n        let dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\n        let dosSalePublicPath=FindMarket.getPublicPath(dosSaleType, name: tenant.name)\n        let dosSaleStoragePath= FindMarket.getStoragePath(dosSaleType, name:tenant.name)\n\n        let dosSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n        if !dosSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n        }\n\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n        if !dosBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n        }\n\n        let aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\n        let aeBidPublicPath=FindMarket.getPublicPath(aeBidType, name: tenant.name)\n        let aeBidStoragePath= FindMarket.getStoragePath(aeBidType, name:tenant.name)\n        let aeBidCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n        if !aeBidCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n        }\n\n     /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n        }\n\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n        if !asBidCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n        }\n        //SYNC with register\n\n        let addresses : {String : Address} = {}\n        let nfts : {String : NFTCatalog.NFTCollectionData} = {}\n        let fts : {String : FTRegistry.FTInfo} = {}\n\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketSale.SaleItemCollection\u003e())\n        let vaultRefs : {StoragePath : \u0026FungibleToken.Vault} = {}\n\n        let bidStoragePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e())!\n\n        self.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection\u003e(from: bidStoragePath)\n        self.walletReference = []\n        self.pointer = []\n        self.targetCapability = []\n\n        var counter = 0\n        while counter \u003c users.length {\n            var resolveAddress : Address? = nil\n            if addresses[users[counter]] != nil {\n                resolveAddress = addresses[users[counter]]!\n            } else {\n                let address = FIND.resolve(users[counter])\n                if address == nil {\n                    panic(\"The address input is not a valid name nor address. Input : \".concat(users[counter]))\n                }\n                addresses[users[counter]] = address!\n                resolveAddress = address!\n            }\n            let address = resolveAddress!\n\n            var nft : NFTCatalog.NFTCollectionData? = nil\n            var ft : FTRegistry.FTInfo? = nil\n            let nftIdentifier = nftAliasOrIdentifiers[counter]\n            let ftIdentifier = ftAliasOrIdentifiers[counter]\n\n            if nfts[nftIdentifier] != nil {\n                nft = nfts[nftIdentifier]\n            } else {\n                let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier)) \n                let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n                nft =  collection.collectionData\n\n                nfts[nftIdentifier] = nft\n            }\n\n            if fts[ftIdentifier] != nil {\n                ft = fts[ftIdentifier]\n            } else {\n                ft = FTRegistry.getFTInfo(ftIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftIdentifier))\n                fts[ftIdentifier] = ft \n            }\n        \n            if vaultRefs[ft!.vaultPath] != nil {\n                self.walletReference.append(vaultRefs[ft!.vaultPath]!)\n            } else {\n                let walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft!.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n                vaultRefs[ft!.vaultPath] = walletReference\n                self.walletReference.append(walletReference)\n            }\n\n            let pointer= FindViews.createViewReadPointer(address: address, path:nft!.publicPath, id: ids[counter])\n            self.pointer.append(pointer)\n\n            var targetCapability= account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(nft!.publicPath)\n            /* Check for nftCapability */\n            if !targetCapability.check() {\n                let cd = pointer.getNFTCollectionData()\n                // should use account.type here instead\n                if account.type(at: cd.storagePath) != nil {\n                    let pathIdentifier = nft!.publicPath.toString()\n                    let findPath = PublicPath(identifier: pathIdentifier.slice(from: \"/public/\".length , upTo: pathIdentifier.length).concat(\"_FIND\"))!\n                    account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                        findPath,\n                        target: nft!.storagePath\n                    )\n                    targetCapability = account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(findPath)\n                } else {\n                    account.save(\u003c- cd.createEmptyCollection(), to: cd.storagePath)\n                    account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.publicPath, target: cd.storagePath)\n                    account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.providerPath, target: cd.storagePath)\n                }\n\n            }\n            self.targetCapability.append(targetCapability)\n            counter = counter + 1\n        }\n    }\n\n    pre {\n        self.bidsReference != nil : \"This account does not have a bid collection\"\n    }\n\n    execute {\n        var counter = 0\n        while counter \u003c ids.length {\n            if self.walletReference[counter].balance \u003c amounts[counter] {\n                panic(\"Your wallet does not have enough funds to pay for this item. Fund Type : \".concat(ftAliasOrIdentifiers[counter]).concat(\"Required Amount : \").concat(amounts[counter].toString()))\n            }\n            let vault \u003c- self.walletReference[counter].withdraw(amount: amounts[counter]) \n            self.bidsReference!.bid(item:self.pointer[counter], vault: \u003c- vault, nftCap: self.targetCapability[counter], validUntil: validUntil, saleItemExtraField: {}, bidExtraField: {})\n            counter = counter + 1\n        }\n    }\n\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "users",
                     "nftAliasOrIdentifiers",
                     "ids",
                     "ftAliasOrIdentifiers",
                     "amounts",
                     "validUntil"
                  ],
                  "parameters": {
                     "amounts": "[UFix64]",
                     "ftAliasOrIdentifiers": "[String]",
                     "ids": "[UInt64]",
                     "marketplace": "Address",
                     "nftAliasOrIdentifiers": "[String]",
                     "users": "[String]",
                     "validUntil": "UFix64?"
                  }
               }
            },
            "bidMultipleMarketDirectOfferSoft": {
               "code": "import FindMarketSale from 0x35717efbbce11c74\nimport FindMarketAuctionEscrow from 0x35717efbbce11c74\nimport FindMarketAuctionSoft from 0x35717efbbce11c74\nimport FindMarketDirectOfferEscrow from 0x35717efbbce11c74\nimport FindMarketDirectOfferSoft from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FindViews from 0x35717efbbce11c74\nimport FTRegistry from 0x35717efbbce11c74\nimport NFTCatalog from 0x324c34e1c517e4db\nimport FINDNFTCatalog from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\nimport FUSD from 0xe223d8a629e49c68\nimport FiatToken from 0xa983fecbed621163\nimport FlowToken from 0x7e60df042a9c0868\nimport Dandy from 0x35717efbbce11c74\nimport Profile from 0x35717efbbce11c74\n\ntransaction(marketplace:Address, users: [String], nftAliasOrIdentifiers: [String], ids: [UInt64], ftAliasOrIdentifiers:[String], amounts: [UFix64], validUntil: UFix64?) {\n\n    let targetCapability : [Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e]\n    let walletReference : [\u0026FungibleToken.Vault]\n    let bidsReference: \u0026FindMarketDirectOfferSoft.MarketBidCollection?\n    let pointer: [FindViews.ViewReadPointer]\n    let ftVaultType: [Type]\n    let totalPrice : {String : UFix64}\n\n    prepare(account: AuthAccount) {\n\n        if nftAliasOrIdentifiers.length != users.length {\n            panic(\"The length of arrays passed in has to be the same\")\n        } else if nftAliasOrIdentifiers.length != ids.length {\n            panic(\"The length of arrays passed in has to be the same\")\n        } else if nftAliasOrIdentifiers.length != ftAliasOrIdentifiers.length {\n            panic(\"The length of arrays passed in has to be the same\")\n        } else if nftAliasOrIdentifiers.length != amounts.length {\n            panic(\"The length of arrays passed in has to be the same\")\n        }\n        \n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n        //SYNC with register\n        //Add exising FUSD or create a new one and add it\n        let name = account.address.toString()\n        let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n        if !fusdReceiver.check() {\n            let fusd \u003c- FUSD.createEmptyVault()\n            account.save(\u003c- fusd, to: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n        }\n\n        let usdcCap = account.getCapability\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e(FiatToken.VaultReceiverPubPath)\n        if !usdcCap.check() {\n                account.save( \u003c-FiatToken.createEmptyVault(), to: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e( FiatToken.VaultReceiverPubPath, target: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FiatToken.ResourceId}\u003e( FiatToken.VaultUUIDPubPath, target: FiatToken.VaultStoragePath)\n                account.link\u003c\u0026FiatToken.Vault{FungibleToken.Balance}\u003e( FiatToken.VaultBalancePubPath, target:FiatToken.VaultStoragePath)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let dandyCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        let dandyCapPrivate= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPrivatePath)\n        if !dandyCapPrivate.check() {\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        var created=false\n        var updated=false\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        if !profile.hasWallet(\"Flow\") {\n            let flowWallet=Profile.Wallet( name:\"Flow\", receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), tags: [\"flow\"])\n    \n            profile.addWallet(flowWallet)\n            updated=true\n        }\n        if !profile.hasWallet(\"FUSD\") {\n            profile.addWallet(Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), tags: [\"fusd\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if !profile.hasWallet(\"USDC\") {\n            profile.addWallet(Profile.Wallet( name:\"USDC\", receiver:usdcCap, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(FiatToken.VaultBalancePubPath), accept: Type\u003c@FiatToken.Vault\u003e(), tags: [\"usdc\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else if updated {\n            profile.emitUpdatedEvent()\n        }\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        let doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        let doeSalePublicPath=FindMarket.getPublicPath(doeSaleType, name: tenant.name)\n        let doeSaleStoragePath= FindMarket.getStoragePath(doeSaleType, name:tenant.name)\n        let doeSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n        if !doeSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n        }\n\n        let doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        let doeBidPublicPath=FindMarket.getPublicPath(doeBidType, name: tenant.name)\n        let doeBidStoragePath= FindMarket.getStoragePath(doeBidType, name:tenant.name)\n        let doeBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n        if !doeBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n        }\n\n        /// auctions that escrow ft\n        let aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        let aeSalePublicPath=FindMarket.getPublicPath(aeSaleType, name: tenant.name)\n        let aeSaleStoragePath= FindMarket.getStoragePath(aeSaleType, name:tenant.name)\n        let aeSaleCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n        if !aeSaleCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n        }\n\n        let dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\n        let dosSalePublicPath=FindMarket.getPublicPath(dosSaleType, name: tenant.name)\n        let dosSaleStoragePath= FindMarket.getStoragePath(dosSaleType, name:tenant.name)\n\n        let dosSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n        if !dosSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n        }\n\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n        if !dosBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n        }\n\n        let aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\n        let aeBidPublicPath=FindMarket.getPublicPath(aeBidType, name: tenant.name)\n        let aeBidStoragePath= FindMarket.getStoragePath(aeBidType, name:tenant.name)\n        let aeBidCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n        if !aeBidCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n        }\n\n     /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n        }\n\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n        if !asBidCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n        }\n        //SYNC with register\n\n        let addresses : {String : Address} = {}\n        let nfts : {String : NFTCatalog.NFTCollectionData} = {}\n        let fts : {String : FTRegistry.FTInfo} = {}\n        let vaultRefs : {StoragePath : \u0026FungibleToken.Vault} = {}\n        \n\n        let bidStoragePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())!\n        self.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection\u003e(from: bidStoragePath)\n        self.walletReference = []\n        self.pointer = []\n        self.targetCapability = []\n        self.ftVaultType = []\n        self.totalPrice = {}\n\n        var counter = 0\n        while counter \u003c users.length {\n            var resolveAddress : Address? = nil\n            if addresses[users[counter]] != nil {\n                resolveAddress = addresses[users[counter]]!\n            } else {\n                let address = FIND.resolve(users[counter])\n                if address == nil {\n                    panic(\"The address input is not a valid name nor address. Input : \".concat(users[counter]))\n                }\n                addresses[users[counter]] = address!\n                resolveAddress = address!\n            }\n            let address = resolveAddress!\n\n            var nft : NFTCatalog.NFTCollectionData? = nil\n            var ft : FTRegistry.FTInfo? = nil\n            let nftIdentifier = nftAliasOrIdentifiers[counter]\n            let ftIdentifier = ftAliasOrIdentifiers[counter]\n\n            if nfts[nftIdentifier] != nil {\n                nft = nfts[nftIdentifier]\n            } else {\n                let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier)) \n                let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n                nft = collection.collectionData\n                nfts[nftIdentifier] = nft\n            }\n\n            if fts[ftIdentifier] != nil {\n                ft = fts[ftIdentifier]\n            } else {\n                ft = FTRegistry.getFTInfo(ftIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftIdentifier))\n                fts[ftIdentifier] = ft \n            }\n        \n            if vaultRefs[ft!.vaultPath] != nil {\n                self.walletReference.append(vaultRefs[ft!.vaultPath]!)\n                self.ftVaultType.append(vaultRefs[ft!.vaultPath]!.getType())\n            } else {\n                let walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft!.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n                vaultRefs[ft!.vaultPath] = walletReference\n                self.walletReference.append(walletReference)\n                self.ftVaultType.append(ft!.type)\n            }\n\n            if self.totalPrice[ftIdentifier] == nil {\n                self.totalPrice[ftIdentifier] = amounts[counter]\n            } else {\n                self.totalPrice[ftIdentifier] = self.totalPrice[ftIdentifier]! + amounts[counter]\n            }\n\n            let pointer= FindViews.createViewReadPointer(address: address, path:nft!.publicPath, id: ids[counter])\n            self.pointer.append(pointer)\n\n            var targetCapability= account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(nft!.publicPath)\n\n            /* Check for nftCapability */\n            if !targetCapability.check() {\n                let cd = pointer.getNFTCollectionData()\n                // should use account.type here instead\n                if account.type(at: cd.storagePath) != nil {\n                    let pathIdentifier = nft!.publicPath.toString()\n                    let findPath = PublicPath(identifier: pathIdentifier.slice(from: \"/public/\".length , upTo: pathIdentifier.length).concat(\"_FIND\"))!\n                    account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                        findPath,\n                        target: nft!.storagePath\n                    )\n                    targetCapability = account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(findPath)\n                } else {\n                    account.save(\u003c- cd.createEmptyCollection(), to: cd.storagePath)\n                    account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.publicPath, target: cd.storagePath)\n                    account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.providerPath, target: cd.storagePath)\n                }\n\n            }\n            self.targetCapability.append(targetCapability)\n            counter = counter + 1\n        }\n    }\n\n    pre {\n        self.bidsReference != nil : \"This account does not have a bid collection\"\n    }\n\n    execute {\n        var counter = 0\n        while counter \u003c ids.length {\n            if self.walletReference[counter].balance \u003c self.totalPrice[ftAliasOrIdentifiers[counter]]! {\n                panic(\"Your wallet does not have enough funds to pay for this item. Vault Type : \".concat(self.ftVaultType[counter].getType().identifier).concat(\" . Required : \".concat(self.totalPrice[ftAliasOrIdentifiers[counter]]!.toString())))\n            }    \n            self.bidsReference!.bid(item:self.pointer[counter], amount: amounts[counter], vaultType: self.ftVaultType[counter], nftCap: self.targetCapability[counter], validUntil: validUntil, saleItemExtraField: {}, bidExtraField: {})\n            counter = counter + 1 \n        }\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "users",
                     "nftAliasOrIdentifiers",
                     "ids",
                     "ftAliasOrIdentifiers",
                     "amounts",
                     "validUntil"
                  ],
                  "parameters": {
                     "amounts": "[UFix64]",
                     "ftAliasOrIdentifiers": "[String]",
                     "ids": "[UInt64]",
                     "marketplace": "Address",
                     "nftAliasOrIdentifiers": "[String]",
                     "users": "[String]",
                     "validUntil": "UFix64?"
                  }
               }
            },
            "bidMultipleMarketDirectOfferSoftDUC": {
               "code": "import FindMarketSale from 0x35717efbbce11c74\nimport FindMarketAuctionEscrow from 0x35717efbbce11c74\nimport FindMarketAuctionSoft from 0x35717efbbce11c74\nimport FindMarketDirectOfferEscrow from 0x35717efbbce11c74\nimport FindMarketDirectOfferSoft from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FindViews from 0x35717efbbce11c74\nimport NFTCatalog from 0x324c34e1c517e4db\nimport FINDNFTCatalog from 0x35717efbbce11c74\nimport FTRegistry from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\nimport FlowToken from 0x7e60df042a9c0868\nimport TokenForwarding from 0x51ea0e37c27a1f1a\nimport DapperUtilityCoin from 0x82ec283f88a62e65\nimport Dandy from 0x35717efbbce11c74\nimport Profile from 0x35717efbbce11c74\n\ntransaction(dapperAddress: Address, marketplace:Address, users: [String], nftAliasOrIdentifiers: [String], ids: [UInt64], amounts: [UFix64], validUntil: UFix64?) {\n\n    let targetCapability : [Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e]\n    let bidsReference: \u0026FindMarketDirectOfferSoft.MarketBidCollection?\n    let pointer: [FindViews.ViewReadPointer]\n\n    prepare(account: AuthAccount) {\n\n        if nftAliasOrIdentifiers.length != users.length {\n            panic(\"The length of arrays passed in has to be the same\")\n        } else if nftAliasOrIdentifiers.length != ids.length {\n            panic(\"The length of arrays passed in has to be the same\")\n        } else if nftAliasOrIdentifiers.length != amounts.length {\n            panic(\"The length of arrays passed in has to be the same\")\n        }\n        \n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n        //SYNC with register\n        //Add exising FUSD or create a new one and add it\n        let name = account.address.toString()\n        let ducReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver)\n        if !ducReceiver.check() {\n            let dapper = getAccount(dapperAddress)\n            // Create a new Forwarder resource for DUC and store it in the new account's storage\n            let ducForwarder \u003c- TokenForwarding.createNewForwarder(recipient: dapper.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver))\n            account.save(\u003c-ducForwarder, to: /storage/dapperUtilityCoinReceiver)\n            // Publish a Receiver capability for the new account, which is linked to the DUC Forwarder\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver,target: /storage/dapperUtilityCoinReceiver)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: ducReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let dandyCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        let dandyCapPrivate= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPrivatePath)\n        if !dandyCapPrivate.check() {\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        var created=false\n        var updated=false\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        if !profile.hasWallet(\"Flow\") {\n            let flowWallet=Profile.Wallet( name:\"Flow\", receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), tags: [\"flow\"])\n    \n            profile.addWallet(flowWallet)\n            updated=true\n        }\n        if !profile.hasWallet(\"DUC\") {\n            profile.addWallet(Profile.Wallet( name:\"DUC\", receiver:ducReceiver, balance:getAccount(dapperAddress).getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/dapperUtilityCoinBalance), accept: Type\u003c@DapperUtilityCoin.Vault\u003e(), tags: [\"duc\", \"dapperUtilityCoin\",\"dapper\"]))\n            updated=true\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else {\n            profile.emitUpdatedEvent()\n        }\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        let doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        let doeSalePublicPath=FindMarket.getPublicPath(doeSaleType, name: tenant.name)\n        let doeSaleStoragePath= FindMarket.getStoragePath(doeSaleType, name:tenant.name)\n        let doeSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n        if !doeSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n        }\n\n        let doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        let doeBidPublicPath=FindMarket.getPublicPath(doeBidType, name: tenant.name)\n        let doeBidStoragePath= FindMarket.getStoragePath(doeBidType, name:tenant.name)\n        let doeBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n        if !doeBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n        }\n\n        /// auctions that escrow ft\n        let aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        let aeSalePublicPath=FindMarket.getPublicPath(aeSaleType, name: tenant.name)\n        let aeSaleStoragePath= FindMarket.getStoragePath(aeSaleType, name:tenant.name)\n        let aeSaleCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n        if !aeSaleCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n        }\n\n        let dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\n        let dosSalePublicPath=FindMarket.getPublicPath(dosSaleType, name: tenant.name)\n        let dosSaleStoragePath= FindMarket.getStoragePath(dosSaleType, name:tenant.name)\n\n        let dosSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n        if !dosSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n        }\n\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n        if !dosBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n        }\n\n        let aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\n        let aeBidPublicPath=FindMarket.getPublicPath(aeBidType, name: tenant.name)\n        let aeBidStoragePath= FindMarket.getStoragePath(aeBidType, name:tenant.name)\n        let aeBidCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n        if !aeBidCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n        }\n\n     /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n        }\n\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n        if !asBidCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n        }\n        //SYNC with register\n\n        let addresses : {String : Address} = {}\n        let nfts : {String : NFTCatalog.NFTCollectionData} = {}\n        let fts : {String : FTRegistry.FTInfo} = {}\n\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketSale.SaleItemCollection\u003e())\n        let vaultRefs : {StoragePath : \u0026FungibleToken.Vault} = {}\n\n\n        let bidStoragePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())!\n        self.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection\u003e(from: bidStoragePath)\n        \n        self.pointer = []\n        self.targetCapability = []\n\n        var counter = 0\n        while counter \u003c users.length {\n            var resolveAddress : Address? = nil\n            if addresses[users[counter]] != nil {\n                resolveAddress = addresses[users[counter]]!\n            } else {\n                let address = FIND.resolve(users[counter])\n                if address == nil {\n                    panic(\"The address input is not a valid name nor address. Input : \".concat(users[counter]))\n                }\n                addresses[users[counter]] = address!\n                resolveAddress = address!\n            }\n            let address = resolveAddress!\n\n            var nft : NFTCatalog.NFTCollectionData? = nil\n            let nftIdentifier = nftAliasOrIdentifiers[counter]\n\n            if nfts[nftIdentifier] != nil {\n                nft = nfts[nftIdentifier]\n            } else {\n                let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier)) \n                let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n                nft = collection.collectionData\n                nfts[nftIdentifier] = nft\n            }\n\n\n            let pointer= FindViews.createViewReadPointer(address: address, path:nft!.publicPath, id: ids[counter])\n            self.pointer.append(pointer)\n\n            var targetCapability= account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(nft!.publicPath)\n\n            /* Check for nftCapability */\n            if !targetCapability.check() {\n                let cd = pointer.getNFTCollectionData()\n                // should use account.type here instead\n                if account.type(at: cd.storagePath) != nil {\n                    let pathIdentifier = nft!.publicPath.toString()\n                    let findPath = PublicPath(identifier: pathIdentifier.slice(from: \"/public/\".length , upTo: pathIdentifier.length).concat(\"_FIND\"))!\n                    account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                        findPath,\n                        target: nft!.storagePath\n                    )\n                    targetCapability = account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(findPath)\n                } else {\n                    account.save(\u003c- cd.createEmptyCollection(), to: cd.storagePath)\n                    account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.publicPath, target: cd.storagePath)\n                    account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.providerPath, target: cd.storagePath)\n                }\n\n            }\n            self.targetCapability.append(targetCapability)\n            counter = counter + 1\n        }\n    }\n\n    pre {\n        self.bidsReference != nil : \"This account does not have a bid collection\"\n    }\n\n    execute {\n        var counter = 0\n        while counter \u003c ids.length {\n            self.bidsReference!.bid(item:self.pointer[counter], amount: amounts[counter], vaultType: Type\u003c@DapperUtilityCoin.Vault\u003e(), nftCap: self.targetCapability[counter], validUntil: validUntil, saleItemExtraField: {}, bidExtraField: {})\n            counter = counter + 1\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "dapperAddress",
                     "marketplace",
                     "users",
                     "nftAliasOrIdentifiers",
                     "ids",
                     "amounts",
                     "validUntil"
                  ],
                  "parameters": {
                     "amounts": "[UFix64]",
                     "dapperAddress": "Address",
                     "ids": "[UInt64]",
                     "marketplace": "Address",
                     "nftAliasOrIdentifiers": "[String]",
                     "users": "[String]",
                     "validUntil": "UFix64?"
                  }
               }
            },
            "bidName": {
               "code": "import FungibleToken from 0x9a0766d93b6608b7\nimport FUSD from 0xe223d8a629e49c68\nimport FiatToken from 0xa983fecbed621163\nimport FlowToken from 0x7e60df042a9c0868\nimport Profile from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\nimport Dandy from 0x35717efbbce11c74\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FindMarketSale from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\nimport FindMarketDirectOfferEscrow from 0x35717efbbce11c74\nimport FindMarketDirectOfferSoft from 0x35717efbbce11c74\nimport FindMarketAuctionEscrow from 0x35717efbbce11c74\nimport FindMarketAuctionSoft from 0x35717efbbce11c74\nimport FindLeaseMarketSale from 0x35717efbbce11c74\nimport FindLeaseMarketAuctionSoft from 0x35717efbbce11c74\n// import FindLeaseMarketAuctionEscrow from \"../contracts/FindLeaseMarketAuctionEscrow.cdc\"\nimport FindLeaseMarketDirectOfferSoft from 0x35717efbbce11c74\n// import FindLeaseMarketDirectOfferEscrow from \"../contracts/FindLeaseMarketDirectOfferEscrow.cdc\"\nimport FindLeaseMarket from 0x35717efbbce11c74\n\ntransaction(name: String, amount: UFix64) {\n\n    let vaultRef : \u0026FUSD.Vault?\n    let bidRef : \u0026FIND.BidCollection?\n\n    prepare(account: AuthAccount) {\n\n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n        //SYNC with register\n        //Add exising FUSD or create a new one and add it\n        let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n        if !fusdReceiver.check() {\n            let fusd \u003c- FUSD.createEmptyVault()\n            account.save(\u003c- fusd, to: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n        }\n\n        let usdcCap = account.getCapability\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e(FiatToken.VaultReceiverPubPath)\n        if !usdcCap.check() {\n                account.save( \u003c-FiatToken.createEmptyVault(), to: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e( FiatToken.VaultReceiverPubPath, target: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FiatToken.ResourceId}\u003e( FiatToken.VaultUUIDPubPath, target: FiatToken.VaultStoragePath)\n                account.link\u003c\u0026FiatToken.Vault{FungibleToken.Balance}\u003e( FiatToken.VaultBalancePubPath, target:FiatToken.VaultStoragePath)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let dandyCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        var created=false\n        var updated=true\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        if !profile.hasWallet(\"Flow\") {\n            let flowWallet=Profile.Wallet( name:\"Flow\", receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), tags: [\"flow\"])\n    \n            profile.addWallet(flowWallet)\n            updated=true\n        }\n        if !profile.hasWallet(\"FUSD\") {\n            profile.addWallet(Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), tags: [\"fusd\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if !profile.hasWallet(\"USDC\") {\n            profile.addWallet(Profile.Wallet( name:\"USDC\", receiver:usdcCap, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(FiatToken.VaultBalancePubPath), accept: Type\u003c@FiatToken.Vault\u003e(), tags: [\"usdc\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else if updated {\n            profile.emitUpdatedEvent()\n        }\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let tenantCapability= FindMarket.getTenantCapability(FindMarket.getFindTenantAddress())!\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        let doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        let doeSalePublicPath=FindMarket.getPublicPath(doeSaleType, name: tenant.name)\n        let doeSaleStoragePath= FindMarket.getStoragePath(doeSaleType, name:tenant.name)\n        let doeSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n        if !doeSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n        }\n\n        let doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        let doeBidPublicPath=FindMarket.getPublicPath(doeBidType, name: tenant.name)\n        let doeBidStoragePath= FindMarket.getStoragePath(doeBidType, name:tenant.name)\n        let doeBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n        if !doeBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n        }\n\n        /// auctions that escrow ft\n        let aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        let aeSalePublicPath=FindMarket.getPublicPath(aeSaleType, name: tenant.name)\n        let aeSaleStoragePath= FindMarket.getStoragePath(aeSaleType, name:tenant.name)\n        let aeSaleCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n        if !aeSaleCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n        }\n\n        let dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\n        let dosSalePublicPath=FindMarket.getPublicPath(dosSaleType, name: tenant.name)\n        let dosSaleStoragePath= FindMarket.getStoragePath(dosSaleType, name:tenant.name)\n\n        let dosSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n        if !dosSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n        }\n\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n        if !dosBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n        }\n\n        let aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\n        let aeBidPublicPath=FindMarket.getPublicPath(aeBidType, name: tenant.name)\n        let aeBidStoragePath= FindMarket.getStoragePath(aeBidType, name:tenant.name)\n        let aeBidCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n        if !aeBidCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n        }\n\n     /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n        }\n\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n        if !asBidCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n        }\n\n        let leaseTenantCapability= FindMarket.getTenantCapability(FindMarket.getTenantAddress(\"findLease\")!)!\n\n        let leaseSaleItemType= Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()\n        let leasePublicPath=FindMarket.getPublicPath(leaseSaleItemType, name: \"findLease\")\n        let leaseStoragePath= FindMarket.getStoragePath(leaseSaleItemType, name:\"findLease\")\n        let leaseSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath) \n        if !leaseSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketSale.SaleItemCollection\u003e(\u003c- FindLeaseMarketSale.createEmptySaleItemCollection(leaseTenantCapability), to: leaseStoragePath)\n            account.link\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath, target: leaseStoragePath)\n        }\n\n        let leaseASSaleItemType= Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e()\n        let leaseASPublicPath=FindMarket.getPublicPath(leaseASSaleItemType, name: \"findLease\")\n        let leaseASStoragePath= FindMarket.getStoragePath(leaseASSaleItemType, name:\"findLease\")\n        let leaseASSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath) \n        if !leaseASSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseASStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath, target: leaseASStoragePath)\n        }\n\n\n        let leaseASBidType= Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e()\n        let leaseASBidPublicPath=FindMarket.getPublicPath(leaseASBidType, name: \"findLease\")\n        let leaseASBidStoragePath= FindMarket.getStoragePath(leaseASBidType, name: \"findLease\")\n        let leaseASBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath) \n        if !leaseASBidCap.check() {\n            account.save\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseASBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath, target: leaseASBidStoragePath)\n        }\n\n        // let leaseAESaleItemType= Type\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e()\n        // let leaseAEPublicPath=FindMarket.getPublicPath(leaseAESaleItemType, name: \"findLease\")\n        // let leaseAEStoragePath= FindMarket.getStoragePath(leaseAESaleItemType, name:\"findLease\")\n        // let leaseAESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath) \n        // if !leaseAESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseAEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath, target: leaseAEStoragePath)\n        // }\n\n        // let leaseAEBidType= Type\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e()\n        // let leaseAEBidPublicPath=FindMarket.getPublicPath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidStoragePath= FindMarket.getStoragePath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath) \n        // if !leaseAEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseAEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath, target: leaseAEBidStoragePath)\n        // }\n\n        let leaseDOSSaleItemType= Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e()\n        let leaseDOSPublicPath=FindMarket.getPublicPath(leaseDOSSaleItemType, name: \"findLease\")\n        let leaseDOSStoragePath= FindMarket.getStoragePath(leaseDOSSaleItemType, name:\"findLease\")\n        let leaseDOSSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath) \n        if !leaseDOSSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOSStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath, target: leaseDOSStoragePath)\n        }\n\n        let leaseDOSBidType= Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let leaseDOSBidPublicPath=FindMarket.getPublicPath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidStoragePath= FindMarket.getStoragePath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath) \n        if !leaseDOSBidCap.check() {\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOSBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath, target: leaseDOSBidStoragePath)\n        }\n\n        // let leaseDOESaleItemType= Type\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        // let leaseDOEPublicPath=FindMarket.getPublicPath(leaseDOESaleItemType, name: \"findLease\")\n        // let leaseDOEStoragePath= FindMarket.getStoragePath(leaseDOESaleItemType, name:\"findLease\")\n        // let leaseDOESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath) \n        // if !leaseDOESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath, target: leaseDOEStoragePath)\n        // }\n\n        // let leaseDOEBidType= Type\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        // let leaseDOEBidPublicPath=FindMarket.getPublicPath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidStoragePath= FindMarket.getStoragePath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath) \n        // if !leaseDOEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath, target: leaseDOEBidStoragePath)\n        // }\n        //SYNC with register\n\n        self.vaultRef = account.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault)\n        self.bidRef = account.borrow\u003c\u0026FIND.BidCollection\u003e(from: FIND.BidStoragePath)\n    }\n\n    pre{\n        self.vaultRef != nil : \"Could not borrow reference to the fusdVault!\" \n        self.bidRef != nil : \"Could not borrow reference to the bid collection!\" \n    }\n\n    execute {\n        let vault \u003c- self.vaultRef!.withdraw(amount: amount) as! @FUSD.Vault\n        self.bidRef!.bid(name: name, vault: \u003c- vault)\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "name": "String"
                  }
               }
            },
            "buyAddon": {
               "code": "import FUSD from 0xe223d8a629e49c68\nimport FIND from 0x35717efbbce11c74\n\n\ntransaction(name: String, addon:String, amount:UFix64) {\n\n    let leases : \u0026FIND.LeaseCollection?\n    let vaultRef : \u0026FUSD.Vault? \n\n    prepare(account: AuthAccount) {\n\n        self.leases= account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)\n        self.vaultRef = account.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault)\n\n    }\n\n    pre{\n        self.leases != nil : \"Could not borrow reference to the leases collection\"\n        self.vaultRef != nil : \"Could not borrow reference to the fusdVault!\"\n    }\n\n    execute {\n        let vault \u003c- self.vaultRef!.withdraw(amount: amount) as! @FUSD.Vault\n        self.leases!.buyAddon(name: name, addon: addon, vault: \u003c- vault)\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "addon",
                     "amount"
                  ],
                  "parameters": {
                     "addon": "String",
                     "amount": "UFix64",
                     "name": "String"
                  }
               }
            },
            "buyLeaseForSale": {
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FindMarketSale from 0x35717efbbce11c74\nimport FindMarketAuctionEscrow from 0x35717efbbce11c74\nimport FindMarketAuctionSoft from 0x35717efbbce11c74\nimport FindMarketDirectOfferEscrow from 0x35717efbbce11c74\nimport FindMarketDirectOfferSoft from 0x35717efbbce11c74\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FTRegistry from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FUSD from 0xe223d8a629e49c68\nimport FiatToken from 0xa983fecbed621163\nimport FlowToken from 0x7e60df042a9c0868\nimport FIND from 0x35717efbbce11c74\nimport Dandy from 0x35717efbbce11c74\nimport Profile from 0x35717efbbce11c74\nimport FindLeaseMarketSale from 0x35717efbbce11c74\nimport FindLeaseMarketAuctionSoft from 0x35717efbbce11c74\n// import FindLeaseMarketAuctionEscrow from \"../contracts/FindLeaseMarketAuctionEscrow.cdc\"\nimport FindLeaseMarketDirectOfferSoft from 0x35717efbbce11c74\n// import FindLeaseMarketDirectOfferEscrow from \"../contracts/FindLeaseMarketDirectOfferEscrow.cdc\"\nimport FindLeaseMarket from 0x35717efbbce11c74\n\ntransaction(leaseName: String, amount: UFix64) {\n\n    let targetCapability : Capability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e\n    let walletReference : \u0026FungibleToken.Vault\n\n    let saleItemsCap: Capability\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e\n    let buyer: Address\n\n    prepare(account: AuthAccount) {\n\n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n        //SYNC with register\n        //Add exising FUSD or create a new one and add it\n        let name = account.address.toString()\n        let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n        if !fusdReceiver.check() {\n            let fusd \u003c- FUSD.createEmptyVault()\n            account.save(\u003c- fusd, to: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n        }\n\n        let usdcCap = account.getCapability\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e(FiatToken.VaultReceiverPubPath)\n        if !usdcCap.check() {\n            account.save( \u003c-FiatToken.createEmptyVault(), to: FiatToken.VaultStoragePath)\n            account.link\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e( FiatToken.VaultReceiverPubPath, target: FiatToken.VaultStoragePath)\n            account.link\u003c\u0026FiatToken.Vault{FiatToken.ResourceId}\u003e( FiatToken.VaultUUIDPubPath, target: FiatToken.VaultStoragePath)\n            account.link\u003c\u0026FiatToken.Vault{FungibleToken.Balance}\u003e( FiatToken.VaultBalancePubPath, target:FiatToken.VaultStoragePath)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let dandyCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        let dandyCapPrivate= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPrivatePath)\n        if !dandyCapPrivate.check() {\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        var created=false\n        var updated=false\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        if !profile.hasWallet(\"Flow\") {\n            let flowWallet=Profile.Wallet( name:\"Flow\", receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), tags: [\"flow\"])\n    \n            profile.addWallet(flowWallet)\n            updated=true\n        }\n        if !profile.hasWallet(\"FUSD\") {\n            profile.addWallet(Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), tags: [\"fusd\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if !profile.hasWallet(\"USDC\") {\n            profile.addWallet(Profile.Wallet( name:\"USDC\", receiver:usdcCap, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(FiatToken.VaultBalancePubPath), accept: Type\u003c@FiatToken.Vault\u003e(), tags: [\"usdc\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else if updated {\n            profile.emitUpdatedEvent()\n        }\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let tenantCapability= FindMarket.getTenantCapability(FindMarket.getFindTenantAddress())!\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        let doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        let doeSalePublicPath=FindMarket.getPublicPath(doeSaleType, name: tenant.name)\n        let doeSaleStoragePath= FindMarket.getStoragePath(doeSaleType, name:tenant.name)\n        let doeSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n        if !doeSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n        }\n\n        let doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        let doeBidPublicPath=FindMarket.getPublicPath(doeBidType, name: tenant.name)\n        let doeBidStoragePath= FindMarket.getStoragePath(doeBidType, name:tenant.name)\n        let doeBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n        if !doeBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n        }\n\n        /// auctions that escrow ft\n        let aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        let aeSalePublicPath=FindMarket.getPublicPath(aeSaleType, name: tenant.name)\n        let aeSaleStoragePath= FindMarket.getStoragePath(aeSaleType, name:tenant.name)\n        let aeSaleCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n        if !aeSaleCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n        }\n\n        let dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\n        let dosSalePublicPath=FindMarket.getPublicPath(dosSaleType, name: tenant.name)\n        let dosSaleStoragePath= FindMarket.getStoragePath(dosSaleType, name:tenant.name)\n\n        let dosSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n        if !dosSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n        }\n\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n        if !dosBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n        }\n\n        let aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\n        let aeBidPublicPath=FindMarket.getPublicPath(aeBidType, name: tenant.name)\n        let aeBidStoragePath= FindMarket.getStoragePath(aeBidType, name:tenant.name)\n        let aeBidCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n        if !aeBidCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n        }\n\n     /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n        }\n\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n        if !asBidCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n        }\n\n        let leaseTenantCapability= FindMarket.getTenantCapability(FindMarket.getTenantAddress(\"findLease\")!)!\n\n        let leaseSaleItemType= Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()\n        let leasePublicPath=FindMarket.getPublicPath(leaseSaleItemType, name: \"findLease\")\n        let leaseStoragePath= FindMarket.getStoragePath(leaseSaleItemType, name:\"findLease\")\n        let leaseSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath) \n        if !leaseSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketSale.SaleItemCollection\u003e(\u003c- FindLeaseMarketSale.createEmptySaleItemCollection(leaseTenantCapability), to: leaseStoragePath)\n            account.link\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath, target: leaseStoragePath)\n        }\n\n        let leaseASSaleItemType= Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e()\n        let leaseASPublicPath=FindMarket.getPublicPath(leaseASSaleItemType, name: \"findLease\")\n        let leaseASStoragePath= FindMarket.getStoragePath(leaseASSaleItemType, name:\"findLease\")\n        let leaseASSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath) \n        if !leaseASSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseASStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath, target: leaseASStoragePath)\n        }\n\n\n        let leaseASBidType= Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e()\n        let leaseASBidPublicPath=FindMarket.getPublicPath(leaseASBidType, name: \"findLease\")\n        let leaseASBidStoragePath= FindMarket.getStoragePath(leaseASBidType, name: \"findLease\")\n        let leaseASBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath) \n        if !leaseASBidCap.check() {\n            account.save\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseASBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath, target: leaseASBidStoragePath)\n        }\n\n        // let leaseAESaleItemType= Type\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e()\n        // let leaseAEPublicPath=FindMarket.getPublicPath(leaseAESaleItemType, name: \"findLease\")\n        // let leaseAEStoragePath= FindMarket.getStoragePath(leaseAESaleItemType, name:\"findLease\")\n        // let leaseAESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath) \n        // if !leaseAESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseAEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath, target: leaseAEStoragePath)\n        // }\n\n        // let leaseAEBidType= Type\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e()\n        // let leaseAEBidPublicPath=FindMarket.getPublicPath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidStoragePath= FindMarket.getStoragePath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath) \n        // if !leaseAEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseAEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath, target: leaseAEBidStoragePath)\n        // }\n\n        let leaseDOSSaleItemType= Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e()\n        let leaseDOSPublicPath=FindMarket.getPublicPath(leaseDOSSaleItemType, name: \"findLease\")\n        let leaseDOSStoragePath= FindMarket.getStoragePath(leaseDOSSaleItemType, name:\"findLease\")\n        let leaseDOSSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath) \n        if !leaseDOSSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOSStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath, target: leaseDOSStoragePath)\n        }\n\n        let leaseDOSBidType= Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let leaseDOSBidPublicPath=FindMarket.getPublicPath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidStoragePath= FindMarket.getStoragePath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath) \n        if !leaseDOSBidCap.check() {\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOSBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath, target: leaseDOSBidStoragePath)\n        }\n\n        // let leaseDOESaleItemType= Type\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        // let leaseDOEPublicPath=FindMarket.getPublicPath(leaseDOESaleItemType, name: \"findLease\")\n        // let leaseDOEStoragePath= FindMarket.getStoragePath(leaseDOESaleItemType, name:\"findLease\")\n        // let leaseDOESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath) \n        // if !leaseDOESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath, target: leaseDOEStoragePath)\n        // }\n\n        // let leaseDOEBidType= Type\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        // let leaseDOEBidPublicPath=FindMarket.getPublicPath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidStoragePath= FindMarket.getStoragePath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath) \n        // if !leaseDOEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath, target: leaseDOEBidStoragePath)\n        // }\n        //SYNC with register\n\n        let resolveAddress = FIND.resolve(leaseName)\n        if resolveAddress == nil {\n            panic(\"The address input is not a valid name nor address. Input : \".concat(leaseName))\n        }\n        let address = resolveAddress!\n        let leaseMarketplace = FindMarket.getTenantAddress(\"findLease\")!\n        self.saleItemsCap= FindLeaseMarketSale.getSaleItemCapability(marketplace: leaseMarketplace, user:address) ?? panic(\"cannot find lease sale item cap\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e())\n\n        let item= FindLeaseMarket.assertOperationValid(tenant: leaseMarketplace, name: leaseName, marketOption: marketOption)\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n    \n        self.targetCapability= account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\n        self.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n        self.buyer = account.address\n    }\n\n    pre {\n        self.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount) \n        self.saleItemsCap.borrow()!.buy(name:leaseName, vault: \u003c- vault, to: self.buyer)\n    }\n}",
               "spec": {
                  "order": [
                     "leaseName",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "leaseName": "String"
                  }
               }
            },
            "buyLeaseForSaleDUC": {
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FindMarketSale from 0x35717efbbce11c74\nimport FindMarketAuctionEscrow from 0x35717efbbce11c74\nimport FindMarketAuctionSoft from 0x35717efbbce11c74\nimport FindMarketDirectOfferEscrow from 0x35717efbbce11c74\nimport FindMarketDirectOfferSoft from 0x35717efbbce11c74\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FTRegistry from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FIND from 0x35717efbbce11c74\nimport Dandy from 0x35717efbbce11c74\nimport Profile from 0x35717efbbce11c74\nimport TokenForwarding from 0x51ea0e37c27a1f1a\nimport DapperUtilityCoin from 0x82ec283f88a62e65\nimport FlowToken from 0x7e60df042a9c0868\nimport FindLeaseMarketSale from 0x35717efbbce11c74\nimport FindLeaseMarketAuctionSoft from 0x35717efbbce11c74\n// import FindLeaseMarketAuctionEscrow from \"../contracts/FindLeaseMarketAuctionEscrow.cdc\"\nimport FindLeaseMarketDirectOfferSoft from 0x35717efbbce11c74\n// import FindLeaseMarketDirectOfferEscrow from \"../contracts/FindLeaseMarketDirectOfferEscrow.cdc\"\nimport FindLeaseMarket from 0x35717efbbce11c74\n\ntransaction(dapperAddress: Address, leaseName: String, amount: UFix64) {\n\n    let to : Address\n    let walletReference : \u0026FungibleToken.Vault\n\n    let saleItemsCap: Capability\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e\n    let mainDapperUtilityCoinVault: \u0026DapperUtilityCoin.Vault\n    let balanceBeforeTransfer: UFix64\n\n    prepare(dapper: AuthAccount, account: AuthAccount) {\n\n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n        //SYNC with register\n        //Add exising FUSD or create a new one and add it\n        let name = account.address.toString()\n        let ducReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver)\n        if !ducReceiver.check() {\n            let dapper = getAccount(dapperAddress)\n            // Create a new Forwarder resource for DUC and store it in the new account's storage\n            let ducForwarder \u003c- TokenForwarding.createNewForwarder(recipient: dapper.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver))\n            account.save(\u003c-ducForwarder, to: /storage/dapperUtilityCoinReceiver)\n            // Publish a Receiver capability for the new account, which is linked to the DUC Forwarder\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver,target: /storage/dapperUtilityCoinReceiver)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: ducReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let dandyCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        let dandyCapPrivate= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPrivatePath)\n        if !dandyCapPrivate.check() {\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        var created=false\n        var updated=false\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        if !profile.hasWallet(\"Flow\") {\n            let flowWallet=Profile.Wallet( name:\"Flow\", receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), tags: [\"flow\"])\n    \n            profile.addWallet(flowWallet)\n            updated=true\n        }\n        if !profile.hasWallet(\"DUC\") {\n            profile.addWallet(Profile.Wallet( name:\"DUC\", receiver:ducReceiver, balance:getAccount(dapperAddress).getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/dapperUtilityCoinBalance), accept: Type\u003c@DapperUtilityCoin.Vault\u003e(), tags: [\"duc\", \"dapperUtilityCoin\",\"dapper\"]))\n            updated=true\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else {\n            profile.emitUpdatedEvent()\n        }\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        let doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        let doeSalePublicPath=FindMarket.getPublicPath(doeSaleType, name: tenant.name)\n        let doeSaleStoragePath= FindMarket.getStoragePath(doeSaleType, name:tenant.name)\n        let doeSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n        if !doeSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n        }\n\n        let doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        let doeBidPublicPath=FindMarket.getPublicPath(doeBidType, name: tenant.name)\n        let doeBidStoragePath= FindMarket.getStoragePath(doeBidType, name:tenant.name)\n        let doeBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n        if !doeBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n        }\n\n        /// auctions that escrow ft\n        let aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        let aeSalePublicPath=FindMarket.getPublicPath(aeSaleType, name: tenant.name)\n        let aeSaleStoragePath= FindMarket.getStoragePath(aeSaleType, name:tenant.name)\n        let aeSaleCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n        if !aeSaleCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n        }\n\n        let dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\n        let dosSalePublicPath=FindMarket.getPublicPath(dosSaleType, name: tenant.name)\n        let dosSaleStoragePath= FindMarket.getStoragePath(dosSaleType, name:tenant.name)\n\n        let dosSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n        if !dosSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n        }\n\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n        if !dosBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n        }\n\n        let aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\n        let aeBidPublicPath=FindMarket.getPublicPath(aeBidType, name: tenant.name)\n        let aeBidStoragePath= FindMarket.getStoragePath(aeBidType, name:tenant.name)\n        let aeBidCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n        if !aeBidCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n        }\n\n     /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n        }\n\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n        if !asBidCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n        }\n\n        let leaseTenantCapability= FindMarket.getTenantCapability(FindMarket.getTenantAddress(\"findLease\")!)!\n\n        let leaseSaleItemType= Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()\n        let leasePublicPath=FindMarket.getPublicPath(leaseSaleItemType, name: \"findLease\")\n        let leaseStoragePath= FindMarket.getStoragePath(leaseSaleItemType, name:\"findLease\")\n        let leaseSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath) \n        if !leaseSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketSale.SaleItemCollection\u003e(\u003c- FindLeaseMarketSale.createEmptySaleItemCollection(leaseTenantCapability), to: leaseStoragePath)\n            account.link\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath, target: leaseStoragePath)\n        }\n\n        let leaseASSaleItemType= Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e()\n        let leaseASPublicPath=FindMarket.getPublicPath(leaseASSaleItemType, name: \"findLease\")\n        let leaseASStoragePath= FindMarket.getStoragePath(leaseASSaleItemType, name:\"findLease\")\n        let leaseASSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath) \n        if !leaseASSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseASStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath, target: leaseASStoragePath)\n        }\n\n\n        let leaseASBidType= Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e()\n        let leaseASBidPublicPath=FindMarket.getPublicPath(leaseASBidType, name: \"findLease\")\n        let leaseASBidStoragePath= FindMarket.getStoragePath(leaseASBidType, name: \"findLease\")\n        let leaseASBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath) \n        if !leaseASBidCap.check() {\n            account.save\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseASBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath, target: leaseASBidStoragePath)\n        }\n\n        // let leaseAESaleItemType= Type\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e()\n        // let leaseAEPublicPath=FindMarket.getPublicPath(leaseAESaleItemType, name: \"findLease\")\n        // let leaseAEStoragePath= FindMarket.getStoragePath(leaseAESaleItemType, name:\"findLease\")\n        // let leaseAESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath) \n        // if !leaseAESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseAEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath, target: leaseAEStoragePath)\n        // }\n\n        // let leaseAEBidType= Type\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e()\n        // let leaseAEBidPublicPath=FindMarket.getPublicPath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidStoragePath= FindMarket.getStoragePath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath) \n        // if !leaseAEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseAEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath, target: leaseAEBidStoragePath)\n        // }\n\n        let leaseDOSSaleItemType= Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e()\n        let leaseDOSPublicPath=FindMarket.getPublicPath(leaseDOSSaleItemType, name: \"findLease\")\n        let leaseDOSStoragePath= FindMarket.getStoragePath(leaseDOSSaleItemType, name:\"findLease\")\n        let leaseDOSSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath) \n        if !leaseDOSSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOSStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath, target: leaseDOSStoragePath)\n        }\n\n        let leaseDOSBidType= Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let leaseDOSBidPublicPath=FindMarket.getPublicPath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidStoragePath= FindMarket.getStoragePath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath) \n        if !leaseDOSBidCap.check() {\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOSBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath, target: leaseDOSBidStoragePath)\n        }\n\n        // let leaseDOESaleItemType= Type\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        // let leaseDOEPublicPath=FindMarket.getPublicPath(leaseDOESaleItemType, name: \"findLease\")\n        // let leaseDOEStoragePath= FindMarket.getStoragePath(leaseDOESaleItemType, name:\"findLease\")\n        // let leaseDOESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath) \n        // if !leaseDOESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath, target: leaseDOEStoragePath)\n        // }\n\n        // let leaseDOEBidType= Type\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        // let leaseDOEBidPublicPath=FindMarket.getPublicPath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidStoragePath= FindMarket.getStoragePath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath) \n        // if !leaseDOEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath, target: leaseDOEBidStoragePath)\n        // }\n        //SYNC with register\n\n        let resolveAddress = FIND.resolve(leaseName)\n        if resolveAddress == nil {\n            panic(\"The address input is not a valid name nor address. Input : \".concat(leaseName))\n        }\n        let address = resolveAddress!\n        let leaseMarketplace = FindMarket.getTenantAddress(\"findLease\")!\n        self.saleItemsCap= FindLeaseMarketSale.getSaleItemCapability(marketplace: leaseMarketplace, user:address) ?? panic(\"cannot find sale item cap\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e())\n\n        let item= FindLeaseMarket.assertOperationValid(tenant: leaseMarketplace, name: leaseName, marketOption: marketOption)\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n    \n        if ft.type != Type\u003c@DapperUtilityCoin.Vault\u003e() {\n            panic(\"This item is not listed for Dapper Wallets. Please buy in with other wallets.\")\n        }\n\n        self.mainDapperUtilityCoinVault = dapper.borrow\u003c\u0026DapperUtilityCoin.Vault\u003e(from: /storage/dapperUtilityCoinVault) ?? panic(\"Cannot borrow DapperUtilityCoin vault from account storage\".concat(dapper.address.toString()))\n        self.balanceBeforeTransfer = self.mainDapperUtilityCoinVault.balance\n\n        self.to= account.address\n\n        self.walletReference = dapper.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n    }\n\n    pre {\n        self.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount) \n        self.saleItemsCap.borrow()!.buy(name:leaseName, vault: \u003c- vault, to: self.to)\n    }\n\n    // Check that all dapperUtilityCoin was routed back to Dapper\n    post {\n        self.mainDapperUtilityCoinVault.balance == self.balanceBeforeTransfer: \"DapperUtilityCoin leakage\"\n    }\n}",
               "spec": {
                  "order": [
                     "dapperAddress",
                     "leaseName",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "dapperAddress": "Address",
                     "leaseName": "String"
                  }
               }
            },
            "buyMultipleNFTForSale": {
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FindMarketSale from 0x35717efbbce11c74\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport NFTCatalog from 0x324c34e1c517e4db\nimport FINDNFTCatalog from 0x35717efbbce11c74\nimport FTRegistry from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\n\ntransaction(marketplace:Address, users: [Address], ids: [UInt64], amounts: [UFix64]) {\n\n    let targetCapability : [Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e]\n    var walletReference : [\u0026FungibleToken.Vault]\n\n    let saleItems: [\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}]\n    var totalPrice : UFix64\n    let prices : [UFix64]\n    prepare(account: AuthAccount) {\n\n        if users.length != ids.length {\n            panic(\"The array length of users and ids should be the same\")\n        }\n\n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n\n        var counter = 0\n        self.walletReference= []\n        self.targetCapability = []\n\n        self.saleItems = []\n        let nfts : {String : NFTCatalog.NFTCollectionData} = {}\n        let fts : {String : FTRegistry.FTInfo} = {}\n        let saleItems : {Address : \u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}} = {}\n\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketSale.SaleItemCollection\u003e())\n\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(Type\u003c@FindMarketSale.SaleItemCollection\u003e(), name: tenant.name)\n        var vaultType : Type? = nil\n\n        self.totalPrice = 0.0\n        self.prices = []\n\n        while counter \u003c users.length {\n\n            let address=users[counter]\n\n            if saleItems[address] == nil {\n                let saleItem = getAccount(address).getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath).borrow() ?? panic(\"cannot find sale item cap\")\n                self.saleItems.append(saleItem)\n                saleItems[address] = saleItem \n            } else {\n                self.saleItems.append(saleItems[address]!)\n            }\n\n\n            // let item= FindMarket.assertOperationValid(tenant: marketplace, address: address, marketOption: marketOption, id: ids[counter])\n            let item=saleItems[address]!.borrowSaleItem(ids[counter])\n\n            self.prices.append(item.getBalance())\n            self.totalPrice = self.totalPrice + self.prices[counter]\n\n            var nft : NFTCatalog.NFTCollectionData? = nil\n            var ft : FTRegistry.FTInfo? = nil\n            let nftIdentifier = item.getItemType().identifier\n            let ftIdentifier = item.getFtType().identifier\n\n            if nfts[nftIdentifier] != nil {\n                nft = nfts[nftIdentifier]\n            } else {\n                let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier)) \n                let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n                nft = collection.collectionData\n                nfts[nftIdentifier] = nft\n            }\n\n            if fts[ftIdentifier] != nil {\n                ft = fts[ftIdentifier]\n            } else {\n                ft = FTRegistry.getFTInfo(ftIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftIdentifier))\n                fts[ftIdentifier] = ft \n            }\n\n            self.walletReference.append(\n                account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft!.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n            )\n\n            var targetCapability= account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(nft!.publicPath)\n            /* Check for nftCapability */\n            if !targetCapability.check() {\n                let cd = item.getNFTCollectionData()\n                // should use account.type here instead\n                if account.type(at: cd.storagePath) != nil {\n                    let pathIdentifier = nft!.publicPath.toString()\n                    let findPath = PublicPath(identifier: pathIdentifier.slice(from: \"/public/\".length , upTo: pathIdentifier.length).concat(\"_FIND\"))!\n                    account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                        findPath,\n                        target: nft!.storagePath\n                    )\n                    targetCapability = account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(findPath)\n                } else {\n                    account.save(\u003c- cd.createEmptyCollection(), to: cd.storagePath)\n                    account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.publicPath, target: cd.storagePath)\n                    account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.providerPath, target: cd.storagePath)\n                }\n\n            }\n            self.targetCapability.append(targetCapability)\n            counter = counter + 1\n        }\n\n\n    }\n\n    execute {\n        var counter = 0\n        while counter \u003c users.length {\n            if self.prices[counter] != amounts[counter] {\n                panic(\"Please pass in the correct price of the buy items. Required : \".concat(self.prices[counter].toString()).concat(\" . saleItem ID : \".concat(ids[counter].toString())))\n            }\n            if self.walletReference[counter].balance \u003c amounts[counter] {\n                panic(\"Your wallet does not have enough funds to pay for this item. Required : \".concat(self.prices[counter].toString()).concat(\" . saleItem ID : \".concat(ids[counter].toString())))\n            }\n\n            self.saleItems[counter].buy(id:ids[counter], vault: \u003c- self.walletReference[counter].withdraw(amount: amounts[counter]) \n            , nftCap: self.targetCapability[counter])\n            counter = counter + 1\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "users",
                     "ids",
                     "amounts"
                  ],
                  "parameters": {
                     "amounts": "[UFix64]",
                     "ids": "[UInt64]",
                     "marketplace": "Address",
                     "users": "[Address]"
                  }
               }
            },
            "buyMultipleNFTForSaleDUC": {
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FindMarketSale from 0x35717efbbce11c74\nimport FindMarketAuctionEscrow from 0x35717efbbce11c74\nimport FindMarketAuctionSoft from 0x35717efbbce11c74\nimport FindMarketDirectOfferEscrow from 0x35717efbbce11c74\nimport FindMarketDirectOfferSoft from 0x35717efbbce11c74\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport NFTCatalog from 0x324c34e1c517e4db\nimport FINDNFTCatalog from 0x35717efbbce11c74\nimport FTRegistry from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FIND from 0x35717efbbce11c74\nimport Dandy from 0x35717efbbce11c74\nimport Profile from 0x35717efbbce11c74\nimport TokenForwarding from 0x51ea0e37c27a1f1a\nimport DapperUtilityCoin from 0x82ec283f88a62e65\nimport FlowToken from 0x7e60df042a9c0868\n\ntransaction(dapperAddress: Address, marketplace:Address, users: [String], ids: [UInt64], amounts: [UFix64]) {\n\n    let targetCapability : [Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e]\n    var walletReference : \u0026FungibleToken.Vault\n\n    let saleItemsCap: [Capability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic}\u003e ]\n    let balanceBeforeTransfer: UFix64\n\n    var totalPrice : UFix64 \n    let prices : [UFix64]\n\n    prepare(dapper: AuthAccount, account: AuthAccount) {\n\n        if users.length != ids.length {\n            panic(\"The array length of users and ids should be the same\")\n        }\n\n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n        //SYNC with register\n        //Add exising FUSD or create a new one and add it\n        let name = account.address.toString()\n        let ducReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver)\n        if !ducReceiver.check() {\n            let dapper = getAccount(dapperAddress)\n            // Create a new Forwarder resource for DUC and store it in the new account's storage\n            let ducForwarder \u003c- TokenForwarding.createNewForwarder(recipient: dapper.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver))\n            account.save(\u003c-ducForwarder, to: /storage/dapperUtilityCoinReceiver)\n            // Publish a Receiver capability for the new account, which is linked to the DUC Forwarder\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver,target: /storage/dapperUtilityCoinReceiver)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: ducReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let dandyCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        let dandyCapPrivate= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPrivatePath)\n        if !dandyCapPrivate.check() {\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        var created=false\n        var updated=false\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        if !profile.hasWallet(\"Flow\") {\n            let flowWallet=Profile.Wallet( name:\"Flow\", receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), tags: [\"flow\"])\n    \n            profile.addWallet(flowWallet)\n            updated=true\n        }\n        if !profile.hasWallet(\"DUC\") {\n            profile.addWallet(Profile.Wallet( name:\"DUC\", receiver:ducReceiver, balance:getAccount(dapperAddress).getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/dapperUtilityCoinBalance), accept: Type\u003c@DapperUtilityCoin.Vault\u003e(), tags: [\"duc\", \"dapperUtilityCoin\",\"dapper\"]))\n            updated=true\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else {\n            profile.emitUpdatedEvent()\n        }\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        let doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        let doeSalePublicPath=FindMarket.getPublicPath(doeSaleType, name: tenant.name)\n        let doeSaleStoragePath= FindMarket.getStoragePath(doeSaleType, name:tenant.name)\n        let doeSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n        if !doeSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n        }\n\n        let doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        let doeBidPublicPath=FindMarket.getPublicPath(doeBidType, name: tenant.name)\n        let doeBidStoragePath= FindMarket.getStoragePath(doeBidType, name:tenant.name)\n        let doeBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n        if !doeBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n        }\n\n        /// auctions that escrow ft\n        let aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        let aeSalePublicPath=FindMarket.getPublicPath(aeSaleType, name: tenant.name)\n        let aeSaleStoragePath= FindMarket.getStoragePath(aeSaleType, name:tenant.name)\n        let aeSaleCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n        if !aeSaleCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n        }\n\n        let dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\n        let dosSalePublicPath=FindMarket.getPublicPath(dosSaleType, name: tenant.name)\n        let dosSaleStoragePath= FindMarket.getStoragePath(dosSaleType, name:tenant.name)\n\n        let dosSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n        if !dosSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n        }\n\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n        if !dosBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n        }\n\n        let aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\n        let aeBidPublicPath=FindMarket.getPublicPath(aeBidType, name: tenant.name)\n        let aeBidStoragePath= FindMarket.getStoragePath(aeBidType, name:tenant.name)\n        let aeBidCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n        if !aeBidCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n        }\n\n     /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n        }\n\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n        if !asBidCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n        }\n        //SYNC with register\n\n        var counter = 0\n        self.targetCapability = []\n        self.walletReference = dapper.borrow\u003c\u0026DapperUtilityCoin.Vault\u003e(from: /storage/dapperUtilityCoinVault) ?? panic(\"Cannot borrow DapperUtilityCoin vault from account storage\".concat(dapper.address.toString()))\n        self.balanceBeforeTransfer = self.walletReference.balance\n\n        self.saleItemsCap = []\n        let addresses : {String : Address} = {}\n        let nfts : {String : NFTCatalog.NFTCollectionData} = {}\n\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketSale.SaleItemCollection\u003e())\n\n        self.totalPrice = 0.0\n        self.prices = []\n\n        while counter \u003c users.length {\n            var resolveAddress : Address? = nil\n            if addresses[users[counter]] != nil {\n                resolveAddress = addresses[users[counter]]!\n            } else {\n                let address = FIND.resolve(users[counter])\n                if address == nil {\n                    panic(\"The address input is not a valid name nor address. Input : \".concat(users[counter]))\n                }\n                addresses[users[counter]] = address!\n                resolveAddress = address!\n            }\n            let address = resolveAddress!\n            let saleItemCap = FindMarketSale.getSaleItemCapability(marketplace: marketplace, user:address) ?? panic(\"cannot find sale item cap\")\n            self.saleItemsCap.append(saleItemCap)\n\n            let item= FindMarket.assertOperationValid(tenant: marketplace, address: address, marketOption: marketOption, id: ids[counter])\n\n            self.prices.append(item.getBalance())\n            if self.prices[counter] != amounts[counter] {\n                panic(\"Please pass in the correct amount for item. saleID : \".concat(ids[counter].toString()).concat(\" . Required : \".concat(self.prices[counter].toString())))\n            }\n\n            var nft : NFTCatalog.NFTCollectionData? = nil\n            let nftIdentifier = item.getItemType().identifier\n            let ftType = item.getFtType()\n\n            if nfts[nftIdentifier] != nil {\n                nft = nfts[nftIdentifier]\n            } else {\n                let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier)) \n                let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n                nft =  collection.collectionData\n                nfts[nftIdentifier] = nft\n            }\n            \n            if ftType != Type\u003c@DapperUtilityCoin.Vault\u003e() {\n                panic(\"This item is not listed for Dapper Wallets. Please buy in with other wallets.\")\n            }\n\n            var targetCapability= account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(nft!.publicPath)\n            /* Check for nftCapability */\n            if !targetCapability.check() {\n                let cd = item.getNFTCollectionData()\n                // should use account.type here instead\n                if account.type(at: cd.storagePath) != nil {\n                    let pathIdentifier = nft!.publicPath.toString()\n                    let findPath = PublicPath(identifier: pathIdentifier.slice(from: \"/public/\".length , upTo: pathIdentifier.length).concat(\"_FIND\"))!\n                    account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                        findPath,\n                        target: nft!.storagePath\n                    )\n                    targetCapability = account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(findPath)\n                } else {\n                    account.save(\u003c- cd.createEmptyCollection(), to: cd.storagePath)\n                    account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.publicPath, target: cd.storagePath)\n                    account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.providerPath, target: cd.storagePath)\n                }\n\n            }\n            self.targetCapability.append(targetCapability)\n            counter = counter + 1\n        }\n    }\n\n    execute {\n        var counter = 0 \n        while counter \u003c ids.length {\n            if self.walletReference!.balance \u003c amounts[counter] {\n                panic(\"Your wallet does not have enough funds to pay for this item. Required : \".concat(self.totalPrice.toString()))\n            }\n            let vault \u003c- self.walletReference!.withdraw(amount: self.prices[counter]) \n            self.saleItemsCap[counter].borrow()!.buy(id:ids[counter], vault: \u003c- vault, nftCap: self.targetCapability[counter])\n            counter = counter + 1\n        }\n    }\n\n    // Check that all dapperUtilityCoin was routed back to Dapper\n    post {\n        self.walletReference.balance == self.balanceBeforeTransfer: \"DapperUtilityCoin leakage\"\n    }\n}",
               "spec": {
                  "order": [
                     "dapperAddress",
                     "marketplace",
                     "users",
                     "ids",
                     "amounts"
                  ],
                  "parameters": {
                     "amounts": "[UFix64]",
                     "dapperAddress": "Address",
                     "ids": "[UInt64]",
                     "marketplace": "Address",
                     "users": "[String]"
                  }
               }
            },
            "buyNFTForSale": {
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FindMarketSale from 0x35717efbbce11c74\nimport FindMarketAuctionEscrow from 0x35717efbbce11c74\nimport FindMarketAuctionSoft from 0x35717efbbce11c74\nimport FindMarketDirectOfferEscrow from 0x35717efbbce11c74\nimport FindMarketDirectOfferSoft from 0x35717efbbce11c74\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport NFTCatalog from 0x324c34e1c517e4db\nimport FINDNFTCatalog from 0x35717efbbce11c74\nimport FTRegistry from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FUSD from 0xe223d8a629e49c68\nimport FiatToken from 0xa983fecbed621163\nimport FlowToken from 0x7e60df042a9c0868\nimport FIND from 0x35717efbbce11c74\nimport Dandy from 0x35717efbbce11c74\nimport Profile from 0x35717efbbce11c74\nimport FindLeaseMarketSale from 0x35717efbbce11c74\nimport FindLeaseMarketAuctionSoft from 0x35717efbbce11c74\n// import FindLeaseMarketAuctionEscrow from \"../contracts/FindLeaseMarketAuctionEscrow.cdc\"\nimport FindLeaseMarketDirectOfferSoft from 0x35717efbbce11c74\n// import FindLeaseMarketDirectOfferEscrow from \"../contracts/FindLeaseMarketDirectOfferEscrow.cdc\"\nimport FindLeaseMarket from 0x35717efbbce11c74\n\ntransaction(marketplace:Address, user: String, id: UInt64, amount: UFix64) {\n\n    var targetCapability : Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e\n    let walletReference : \u0026FungibleToken.Vault\n\n    let saleItemsCap: Capability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic}\u003e \n\n    prepare(account: AuthAccount) {\n\n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n        //SYNC with register\n        //Add exising FUSD or create a new one and add it\n        let name = account.address.toString()\n        let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n        if !fusdReceiver.check() {\n            let fusd \u003c- FUSD.createEmptyVault()\n            account.save(\u003c- fusd, to: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n        }\n\n        let usdcCap = account.getCapability\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e(FiatToken.VaultReceiverPubPath)\n        if !usdcCap.check() {\n                account.save( \u003c-FiatToken.createEmptyVault(), to: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e( FiatToken.VaultReceiverPubPath, target: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FiatToken.ResourceId}\u003e( FiatToken.VaultUUIDPubPath, target: FiatToken.VaultStoragePath)\n                account.link\u003c\u0026FiatToken.Vault{FungibleToken.Balance}\u003e( FiatToken.VaultBalancePubPath, target:FiatToken.VaultStoragePath)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let dandyCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        let dandyCapPrivate= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPrivatePath)\n        if !dandyCapPrivate.check() {\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        var created=false\n        var updated=false\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        if !profile.hasWallet(\"Flow\") {\n            let flowWallet=Profile.Wallet( name:\"Flow\", receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), tags: [\"flow\"])\n    \n            profile.addWallet(flowWallet)\n            updated=true\n        }\n        if !profile.hasWallet(\"FUSD\") {\n            profile.addWallet(Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), tags: [\"fusd\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if !profile.hasWallet(\"USDC\") {\n            profile.addWallet(Profile.Wallet( name:\"USDC\", receiver:usdcCap, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(FiatToken.VaultBalancePubPath), accept: Type\u003c@FiatToken.Vault\u003e(), tags: [\"usdc\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else if updated {\n            profile.emitUpdatedEvent()\n        }\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        let doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        let doeSalePublicPath=FindMarket.getPublicPath(doeSaleType, name: tenant.name)\n        let doeSaleStoragePath= FindMarket.getStoragePath(doeSaleType, name:tenant.name)\n        let doeSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n        if !doeSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n        }\n\n        let doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        let doeBidPublicPath=FindMarket.getPublicPath(doeBidType, name: tenant.name)\n        let doeBidStoragePath= FindMarket.getStoragePath(doeBidType, name:tenant.name)\n        let doeBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n        if !doeBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n        }\n\n        /// auctions that escrow ft\n        let aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        let aeSalePublicPath=FindMarket.getPublicPath(aeSaleType, name: tenant.name)\n        let aeSaleStoragePath= FindMarket.getStoragePath(aeSaleType, name:tenant.name)\n        let aeSaleCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n        if !aeSaleCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n        }\n\n        let dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\n        let dosSalePublicPath=FindMarket.getPublicPath(dosSaleType, name: tenant.name)\n        let dosSaleStoragePath= FindMarket.getStoragePath(dosSaleType, name:tenant.name)\n\n        let dosSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n        if !dosSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n        }\n\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n        if !dosBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n        }\n\n        let aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\n        let aeBidPublicPath=FindMarket.getPublicPath(aeBidType, name: tenant.name)\n        let aeBidStoragePath= FindMarket.getStoragePath(aeBidType, name:tenant.name)\n        let aeBidCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n        if !aeBidCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n        }\n\n     /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n        }\n\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n        if !asBidCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n        }\n\n        let leaseTenantCapability= FindMarket.getTenantCapability(FindMarket.getTenantAddress(\"findLease\")!)!\n\n        let leaseSaleItemType= Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()\n        let leasePublicPath=FindMarket.getPublicPath(leaseSaleItemType, name: \"findLease\")\n        let leaseStoragePath= FindMarket.getStoragePath(leaseSaleItemType, name:\"findLease\")\n        let leaseSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath) \n        if !leaseSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketSale.SaleItemCollection\u003e(\u003c- FindLeaseMarketSale.createEmptySaleItemCollection(leaseTenantCapability), to: leaseStoragePath)\n            account.link\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath, target: leaseStoragePath)\n        }\n\n        let leaseASSaleItemType= Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e()\n        let leaseASPublicPath=FindMarket.getPublicPath(leaseASSaleItemType, name: \"findLease\")\n        let leaseASStoragePath= FindMarket.getStoragePath(leaseASSaleItemType, name:\"findLease\")\n        let leaseASSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath) \n        if !leaseASSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseASStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath, target: leaseASStoragePath)\n        }\n\n\n        let leaseASBidType= Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e()\n        let leaseASBidPublicPath=FindMarket.getPublicPath(leaseASBidType, name: \"findLease\")\n        let leaseASBidStoragePath= FindMarket.getStoragePath(leaseASBidType, name: \"findLease\")\n        let leaseASBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath) \n        if !leaseASBidCap.check() {\n            account.save\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseASBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath, target: leaseASBidStoragePath)\n        }\n\n        // let leaseAESaleItemType= Type\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e()\n        // let leaseAEPublicPath=FindMarket.getPublicPath(leaseAESaleItemType, name: \"findLease\")\n        // let leaseAEStoragePath= FindMarket.getStoragePath(leaseAESaleItemType, name:\"findLease\")\n        // let leaseAESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath) \n        // if !leaseAESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseAEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath, target: leaseAEStoragePath)\n        // }\n\n        // let leaseAEBidType= Type\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e()\n        // let leaseAEBidPublicPath=FindMarket.getPublicPath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidStoragePath= FindMarket.getStoragePath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath) \n        // if !leaseAEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseAEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath, target: leaseAEBidStoragePath)\n        // }\n\n        let leaseDOSSaleItemType= Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e()\n        let leaseDOSPublicPath=FindMarket.getPublicPath(leaseDOSSaleItemType, name: \"findLease\")\n        let leaseDOSStoragePath= FindMarket.getStoragePath(leaseDOSSaleItemType, name:\"findLease\")\n        let leaseDOSSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath) \n        if !leaseDOSSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOSStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath, target: leaseDOSStoragePath)\n        }\n\n        let leaseDOSBidType= Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let leaseDOSBidPublicPath=FindMarket.getPublicPath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidStoragePath= FindMarket.getStoragePath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath) \n        if !leaseDOSBidCap.check() {\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOSBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath, target: leaseDOSBidStoragePath)\n        }\n\n        // let leaseDOESaleItemType= Type\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        // let leaseDOEPublicPath=FindMarket.getPublicPath(leaseDOESaleItemType, name: \"findLease\")\n        // let leaseDOEStoragePath= FindMarket.getStoragePath(leaseDOESaleItemType, name:\"findLease\")\n        // let leaseDOESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath) \n        // if !leaseDOESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath, target: leaseDOEStoragePath)\n        // }\n\n        // let leaseDOEBidType= Type\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        // let leaseDOEBidPublicPath=FindMarket.getPublicPath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidStoragePath= FindMarket.getStoragePath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath) \n        // if !leaseDOEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath, target: leaseDOEBidStoragePath)\n        // }\n        //SYNC with register\n\n        let resolveAddress = FIND.resolve(user)\n        if resolveAddress == nil {\n            panic(\"The address input is not a valid name nor address. Input : \".concat(user))\n        }\n        let address = resolveAddress!\n        self.saleItemsCap= FindMarketSale.getSaleItemCapability(marketplace: marketplace, user:address) ?? panic(\"cannot find sale item cap\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketSale.SaleItemCollection\u003e())\n\n        let item= FindMarket.assertOperationValid(tenant: marketplace, address: address, marketOption: marketOption, id: id)\n\n        let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: item.getItemType().identifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(item.getItemType().identifier)) \n        let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n        let nft = collection.collectionData\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n    \n        self.targetCapability= account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(nft.publicPath)\n        /* Check for nftCapability */\n        if !self.targetCapability.check() {\n            let cd = item.getNFTCollectionData()\n            // should use account.type here instead\n            if account.type(at: cd.storagePath) != nil {\n                let pathIdentifier = nft.publicPath.toString()\n                let findPath = PublicPath(identifier: pathIdentifier.slice(from: \"/public/\".length , upTo: pathIdentifier.length).concat(\"_FIND\"))!\n                account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                    findPath,\n                    target: nft.storagePath\n                )\n                self.targetCapability = account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(findPath)\n            } else {\n                account.save(\u003c- cd.createEmptyCollection(), to: cd.storagePath)\n                account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.publicPath, target: cd.storagePath)\n                account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.providerPath, target: cd.storagePath)\n            }\n\n        }\n\n        self.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n    }\n\n    pre {\n        self.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount) \n        self.saleItemsCap.borrow()!.buy(id:id, vault: \u003c- vault, nftCap: self.targetCapability)\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "user",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64",
                     "marketplace": "Address",
                     "user": "String"
                  }
               }
            },
            "buyNFTForSaleDUC": {
               "code": "import FindMarket from 0x35717efbbce11c74\nimport Profile from 0x35717efbbce11c74\nimport FindMarketSale from 0x35717efbbce11c74\nimport NFTCatalog from 0x324c34e1c517e4db\nimport FINDNFTCatalog from 0x35717efbbce11c74\nimport FTRegistry from 0x35717efbbce11c74\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FungibleToken from 0x9a0766d93b6608b7\nimport TokenForwarding from 0x51ea0e37c27a1f1a\nimport DapperUtilityCoin from 0x82ec283f88a62e65\n\n//first argument is the address to the merchant that gets the funds\ntransaction(merchantAddress: Address, marketplace:Address, address: Address, id: UInt64, amount: UFix64) {\n\n    let targetCapability : Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e\n    let walletReference : \u0026FungibleToken.Vault\n\n    let saleItemsCap: Capability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic}\u003e \n    let balanceBeforeTransfer: UFix64\n    prepare(dapper: AuthAccount, account: AuthAccount) {\n\n        let name = account.address.toString()\n        let ducReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver)\n        if !ducReceiver.check() {\n            // Create a new Forwarder resource for DUC and store it in the new account's storage\n            let ducForwarder \u003c- TokenForwarding.createNewForwarder(recipient: dapper.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver))\n            account.save(\u003c-ducForwarder, to: /storage/dapperUtilityCoinReceiver)\n            // Publish a Receiver capability for the new account, which is linked to the DUC Forwarder\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver,target: /storage/dapperUtilityCoinReceiver)\n        }\n        \n        var created=false\n        var updated=false\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        if !profile.hasWallet(\"DUC\") {\n            updated=true\n            profile.addWallet(Profile.Wallet( name:\"DUC\", receiver:ducReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/dapperUtilityCoinBalance), accept: Type\u003c@DapperUtilityCoin.Vault\u003e(), tags: [\"duc\", \"dapperUtilityCoin\",\"dapper\"]))\n            updated=true\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else {\n            profile.emitUpdatedEvent()\n        }\n\n\n        if created {\n            profile.emitCreatedEvent()\n        } else if updated {\n            profile.emitUpdatedEvent()\n        }\n\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        self.saleItemsCap= FindMarketSale.getSaleItemCapability(marketplace: marketplace, user:address) ?? panic(\"cannot find sale item cap\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketSale.SaleItemCollection\u003e())\n    \n        //we do some security check to verify that this tenant can do this operation. This will ensure that the onefootball tenant can only sell using DUC and not some other token. But we can change this with transactions later and not have to modify code/transactions\n        let item= FindMarket.assertOperationValid(tenant: marketplace, address: address, marketOption: marketOption, id: id)\n   let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: item.getItemType().identifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(item.getItemType().identifier))\n        let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n        let nft = collection.collectionData\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n    \n        if ft.type != Type\u003c@DapperUtilityCoin.Vault\u003e() {\n            panic(\"This item is not listed for Dapper Wallets. Please buy in with other wallets.\")\n        }\n\n\n        self.targetCapability= account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(nft.publicPath)\n\n        if !self.targetCapability.check() {\n            let cd = item.getNFTCollectionData()\n            if account.borrow\u003c\u0026AnyResource\u003e(from: cd.storagePath) != nil {\n                panic(\"This collection public link is not set up properly.\")\n            }\n            account.save(\u003c- cd.createEmptyCollection(), to: cd.storagePath)\n            account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.publicPath, target: cd.storagePath)\n            account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.providerPath, target: cd.storagePath)\n        }\n\n        self.walletReference = dapper.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n        self.balanceBeforeTransfer = self.walletReference.balance\n    }\n\n    pre {\n        self.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount) \n        self.saleItemsCap.borrow()!.buy(id:id, vault: \u003c- vault, nftCap: self.targetCapability)\n    }\n\n    // Check that all dapperUtilityCoin was routed back to Dapper\n    post {\n        self.walletReference.balance == self.balanceBeforeTransfer: \"DapperUtilityCoin leakage\"\n    }\n}",
               "spec": {
                  "order": [
                     "merchantAddress",
                     "marketplace",
                     "address",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "address": "Address",
                     "amount": "UFix64",
                     "id": "UInt64",
                     "marketplace": "Address",
                     "merchantAddress": "Address"
                  }
               }
            },
            "cancelAllLeaseMarketAuctionSoft": {
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FindLeaseMarketAuctionSoft from 0x35717efbbce11c74\n\ntransaction() {\n\n    let saleItems : \u0026FindLeaseMarketAuctionSoft.SaleItemCollection?\n\n    prepare(account: AuthAccount) {\n        let leaseMarketplace = FindMarket.getTenantAddress(\"findLease\")!\n        let tenant = FindMarket.getTenant(leaseMarketplace)\n        self.saleItems= account.borrow\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e()))\n\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to the saleItem.\"\n    }\n\n    execute {\n        let leaseNames = self.saleItems!.getNameSales()\n        for lease in leaseNames {\n            self.saleItems!.cancel(lease)\n        }\n    }\n}",
               "spec": {
                  "order": [],
                  "parameters": {}
               }
            },
            "cancelAllLeaseMarketDirectOfferSoft": {
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FindLeaseMarketDirectOfferSoft from 0x35717efbbce11c74\n\ntransaction() {\n\n    let saleItems : \u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection?\n\n    prepare(account: AuthAccount) {\n\n        let marketplace = FindMarket.getTenantAddress(\"findLease\")!\n        let tenant=FindMarket.getTenant(marketplace)\n        self.saleItems= account.borrow\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e()))\n\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to saleItem.\"\n    }\n\n    execute{\n        let nameLeases = self.saleItems!.getNameSales()\n        for nameLease in nameLeases {\n            self.saleItems!.cancel(nameLease)\n        }\n    }\n\n}",
               "spec": {
                  "order": [],
                  "parameters": {}
               }
            },
            "cancelAllMarketAuctionEscrowed": {
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FindMarketAuctionEscrow from 0x35717efbbce11c74\n\ntransaction(marketplace:Address) {\n\n    let saleItems : \u0026FindMarketAuctionEscrow.SaleItemCollection?\n\n    prepare(account: AuthAccount) {\n        let tenant = FindMarket.getTenant(marketplace)\n        self.saleItems= account.borrow\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()))\n\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to the saleItem capability.\"\n    }\n\n    execute {\n        let ids = self.saleItems!.getIds()\n        for id in ids {\n            self.saleItems!.cancel(id)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace"
                  ],
                  "parameters": {
                     "marketplace": "Address"
                  }
               }
            },
            "cancelAllMarketAuctionSoft": {
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FindMarketAuctionSoft from 0x35717efbbce11c74\n\ntransaction(marketplace:Address) {\n\n    let saleItems : \u0026FindMarketAuctionSoft.SaleItemCollection?\n\n    prepare(account: AuthAccount) {\n        let tenant = FindMarket.getTenant(marketplace)\n        self.saleItems= account.borrow\u003c\u0026FindMarketAuctionSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()))\n\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to the saleItem.\"\n    }\n\n    execute {\n        let ids = self.saleItems!.getIds()\n        for id in ids {\n            self.saleItems!.cancel(id)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace"
                  ],
                  "parameters": {
                     "marketplace": "Address"
                  }
               }
            },
            "cancelAllMarketDirectOfferEscrowed": {
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FindMarketDirectOfferEscrow from 0x35717efbbce11c74\n\ntransaction(marketplace:Address) {\n\n    let saleItems : \u0026FindMarketDirectOfferEscrow.SaleItemCollection?\n\n    prepare(account: AuthAccount) {\n\n        let tenant=FindMarket.getTenant(marketplace)\n        self.saleItems= account.borrow\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()))\n\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to saleItem.\"\n    }\n\n    execute{\n        let ids = self.saleItems!.getIds()\n        for id in ids {\n            self.saleItems!.cancel(id)\n        }\n    }\n\n}",
               "spec": {
                  "order": [
                     "marketplace"
                  ],
                  "parameters": {
                     "marketplace": "Address"
                  }
               }
            },
            "cancelAllMarketDirectOfferSoft": {
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FindMarketDirectOfferSoft from 0x35717efbbce11c74\n\ntransaction(marketplace:Address) {\n\n    let saleItems : \u0026FindMarketDirectOfferSoft.SaleItemCollection?\n\n    prepare(account: AuthAccount) {\n\n        let tenant=FindMarket.getTenant(marketplace)\n        self.saleItems= account.borrow\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()))\n\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to saleItem.\"\n    }\n\n    execute{\n        let ids = self.saleItems!.getIds()\n        for id in ids {\n            self.saleItems!.cancel(id)\n        }\n    }\n\n}",
               "spec": {
                  "order": [
                     "marketplace"
                  ],
                  "parameters": {
                     "marketplace": "Address"
                  }
               }
            },
            "cancelAllMarketListings": {
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FindMarketDirectOfferEscrow from 0x35717efbbce11c74\nimport FindMarketAuctionEscrow from 0x35717efbbce11c74\nimport FindMarketAuctionSoft from 0x35717efbbce11c74\nimport FindMarketDirectOfferSoft from 0x35717efbbce11c74\nimport FindMarketSale from 0x35717efbbce11c74\n\ntransaction(marketplace:Address) {\n    prepare(account: AuthAccount) {\n\n        let tenant=FindMarket.getTenant(marketplace)\n\n        let saleItems= account.borrow\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()))!\n        var ids = saleItems.getIds()\n        for id in ids {\n            saleItems.cancel(id)\n        }\n\n        let saleItem2= account.borrow\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()))!\n        ids = saleItem2.getIds()\n        for id in ids {\n            saleItem2.cancel(id)\n        }\n\n        let saleItems3= account.borrow\u003c\u0026FindMarketAuctionSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()))!\n        ids = saleItems3.getIds()\n        for id in ids {\n            saleItems3.cancel(id)\n        }\n\n        let saleItems4= account.borrow\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()))!\n        ids = saleItems4.getIds()\n        for id in ids {\n            saleItems4.cancel(id)\n        }\n\n        let saleItems5= account.borrow\u003c\u0026FindMarketSale.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketSale.SaleItemCollection\u003e()))!\n        ids = saleItems5.getIds()\n        for id in ids {\n            saleItems5.delist(id)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace"
                  ],
                  "parameters": {
                     "marketplace": "Address"
                  }
               }
            },
            "cancelLeaseMarketAuctionSoft": {
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FindLeaseMarketAuctionSoft from 0x35717efbbce11c74\n\ntransaction(leaseNames: [String]) {\n\n    let saleItems : \u0026FindLeaseMarketAuctionSoft.SaleItemCollection?\n\n    prepare(account: AuthAccount) {\n        let marketplace = FindMarket.getTenantAddress(\"findLease\")!\n        let tenant=FindMarket.getTenant(marketplace)\n        self.saleItems= account.borrow\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e()))\n    }\n\n    pre{\n        self.saleItems != nil \n    }\n\n    execute{\n        for leaseName in leaseNames {\n            self.saleItems!.cancel(leaseName)\n        }\n    }\n\n}",
               "spec": {
                  "order": [
                     "leaseNames"
                  ],
                  "parameters": {
                     "leaseNames": "[String]"
                  }
               }
            },
            "cancelLeaseMarketDirectOfferSoft": {
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FindLeaseMarketDirectOfferSoft from 0x35717efbbce11c74\n\ntransaction(leaseNames: [String]) {\n\n    let saleItems : \u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection?\n\n    prepare(account: AuthAccount) {\n        let marketplace = FindMarket.getTenantAddress(\"findLease\")!\n        let tenant=FindMarket.getTenant(marketplace)\n        self.saleItems= account.borrow\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e()))\n\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute {\n        for leaseName in leaseNames {\n            self.saleItems!.cancel(leaseName)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "leaseNames"
                  ],
                  "parameters": {
                     "leaseNames": "[String]"
                  }
               }
            },
            "cancelMarketAuctionEscrowed": {
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FindMarketAuctionEscrow from 0x35717efbbce11c74\n\ntransaction(marketplace:Address, ids: [UInt64]) {\n\n    let saleItems : \u0026FindMarketAuctionEscrow.SaleItemCollection?\n\n    prepare(account: AuthAccount) {\n\n        let tenant=FindMarket.getTenant(marketplace)\n        self.saleItems= account.borrow\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()))\n\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        for id in ids {\n            self.saleItems!.cancel(id)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "ids"
                  ],
                  "parameters": {
                     "ids": "[UInt64]",
                     "marketplace": "Address"
                  }
               }
            },
            "cancelMarketAuctionSoft": {
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FindMarketAuctionSoft from 0x35717efbbce11c74\n\ntransaction(marketplace:Address, ids: [UInt64]) {\n\n    let saleItems : \u0026FindMarketAuctionSoft.SaleItemCollection?\n\n    prepare(account: AuthAccount) {\n        let tenant=FindMarket.getTenant(marketplace)\n        self.saleItems= account.borrow\u003c\u0026FindMarketAuctionSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()))\n    }\n\n    pre{\n        self.saleItems != nil \n    }\n\n    execute{\n        for id in ids {\n            self.saleItems!.cancel(id)\n        }\n    }\n\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "ids"
                  ],
                  "parameters": {
                     "ids": "[UInt64]",
                     "marketplace": "Address"
                  }
               }
            },
            "cancelMarketDirectOfferEscrowed": {
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FindMarketDirectOfferEscrow from 0x35717efbbce11c74\n\ntransaction(marketplace:Address, ids: [UInt64]) {\n\n    let saleItems : \u0026FindMarketDirectOfferEscrow.SaleItemCollection?\n\n    prepare(account: AuthAccount) {\n\n        let tenant=FindMarket.getTenant(marketplace)\n        self.saleItems= account.borrow\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()))\n\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        for id in ids {\n            self.saleItems!.cancel(id)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "ids"
                  ],
                  "parameters": {
                     "ids": "[UInt64]",
                     "marketplace": "Address"
                  }
               }
            },
            "cancelMarketDirectOfferSoft": {
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FindMarketDirectOfferSoft from 0x35717efbbce11c74\n\ntransaction(marketplace:Address, ids: [UInt64]) {\n\n    let saleItems : \u0026FindMarketDirectOfferSoft.SaleItemCollection?\n\n    prepare(account: AuthAccount) {\n\n        let tenant=FindMarket.getTenant(marketplace)\n        self.saleItems= account.borrow\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()))\n\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute {\n        for id in ids {\n            self.saleItems!.cancel(id)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "ids"
                  ],
                  "parameters": {
                     "ids": "[UInt64]",
                     "marketplace": "Address"
                  }
               }
            },
            "cancelMarketListings": {
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FindMarketDirectOfferEscrow from 0x35717efbbce11c74\nimport FindMarketAuctionEscrow from 0x35717efbbce11c74\nimport FindMarketAuctionSoft from 0x35717efbbce11c74\nimport FindMarketDirectOfferSoft from 0x35717efbbce11c74\nimport FindMarketSale from 0x35717efbbce11c74\n\ntransaction(marketplace:Address, ids: {String : [UInt64]}) {\n    prepare(account: AuthAccount) {\n\n        let tenant=FindMarket.getTenant(marketplace)\n\n        var saleType = Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        if let ids = ids[FindMarket.getMarketOptionFromType(saleType)] {\n            let saleItems= account.borrow\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection\u003e(from: tenant.getStoragePath(saleType))!\n            for id in ids {\n                saleItems.cancel(id)\n            }\n        }\n\n        saleType = Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        if let ids = ids[FindMarket.getMarketOptionFromType(saleType)] {\n            let saleItems= account.borrow\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection\u003e(from: tenant.getStoragePath(saleType))!\n            for id in ids {\n                saleItems.cancel(id)\n            }\n        }\n\n        saleType = Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        if let ids = ids[FindMarket.getMarketOptionFromType(saleType)] {\n            let saleItems= account.borrow\u003c\u0026FindMarketAuctionSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(saleType))!\n            for id in ids {\n                saleItems.cancel(id)\n            }\n        }\n\n        saleType = Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n        if let ids = ids[FindMarket.getMarketOptionFromType(saleType)] {\n            let saleItems= account.borrow\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(saleType))!\n            for id in ids {\n                saleItems.cancel(id)\n            }\n        }\n\n        saleType = Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        if let ids = ids[FindMarket.getMarketOptionFromType(saleType)] {\n            let saleItems= account.borrow\u003c\u0026FindMarketSale.SaleItemCollection\u003e(from: tenant.getStoragePath(saleType))!\n            for id in ids {\n                saleItems.delist(id)\n            }\n        }\n\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "ids"
                  ],
                  "parameters": {
                     "ids": "{String: [UInt64]}",
                     "marketplace": "Address"
                  }
               }
            },
            "cancelNameAuction": {
               "code": "import FIND from 0x35717efbbce11c74\n\ntransaction(names: [String]) {\n\n    let finLeases : \u0026FIND.LeaseCollection?\n\n    prepare(account: AuthAccount) {\n        self.finLeases= account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)\n    }\n\n    pre{\n        self.finLeases != nil : \"Cannot borrow reference to find leases collection\"\n    }\n\n    execute {\n        for name in names {\n            self.finLeases!.cancel(name)\n            self.finLeases!.delistAuction(name)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "names"
                  ],
                  "parameters": {
                     "names": "[String]"
                  }
               }
            },
            "cancelNameBid": {
               "code": "import FIND from 0x35717efbbce11c74\n\ntransaction(names: [String]) {\n\n    let bids : \u0026FIND.BidCollection?\n\n    prepare(account: AuthAccount) {\n        self.bids = account.borrow\u003c\u0026FIND.BidCollection\u003e(from: FIND.BidStoragePath)\n    }\n\n    pre{\n        self.bids != nil : \"Cannot borrow reference to find bid collection\"\n    }\n\n    execute {\n        for name in names {\n            self.bids!.cancelBid(name)\n        }\n    }\n\n}",
               "spec": {
                  "order": [
                     "names"
                  ],
                  "parameters": {
                     "names": "[String]"
                  }
               }
            },
            "createCharity": {
               "code": "import NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport CharityNFT from 0x35717efbbce11c74\n\n//This transaction will prepare the art collection\ntransaction() {\n    prepare(account: AuthAccount) {\n\n        let stdCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath)\n        if !stdCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- CharityNFT.createEmptyCollection(), to: CharityNFT.CollectionStoragePath)\n            account.link\u003c\u0026{NonFungibleToken.CollectionPublic, MetadataViews.ResolverCollection}\u003e(CharityNFT.CollectionPublicPath, target: CharityNFT.CollectionStoragePath)\n        }\n\n        let charityCap = account.getCapability\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection)\n        if !charityCap.check() {\n            account.link\u003c\u0026{CharityNFT.CollectionPublic, MetadataViews.ResolverCollection}\u003e(/public/findCharityNFTCollection, target: CharityNFT.CollectionStoragePath)\n        }\n    }\n}",
               "spec": {
                  "order": [],
                  "parameters": {}
               }
            },
            "createProfile": {
               "code": "import FungibleToken from 0x9a0766d93b6608b7\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport FUSD from 0xe223d8a629e49c68\nimport FiatToken from 0xa983fecbed621163\nimport FlowToken from 0x7e60df042a9c0868\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FIND from 0x35717efbbce11c74\nimport Profile from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\nimport FindMarketSale from 0x35717efbbce11c74\nimport FindMarketDirectOfferEscrow from 0x35717efbbce11c74\nimport FindMarketDirectOfferSoft from 0x35717efbbce11c74\nimport FindMarketAuctionEscrow from 0x35717efbbce11c74\nimport FindMarketAuctionSoft from 0x35717efbbce11c74\nimport Dandy from 0x35717efbbce11c74\nimport FindLeaseMarketSale from 0x35717efbbce11c74\nimport FindLeaseMarketAuctionSoft from 0x35717efbbce11c74\n// import FindLeaseMarketAuctionEscrow from \"../contracts/FindLeaseMarketAuctionEscrow.cdc\"\nimport FindLeaseMarketDirectOfferSoft from 0x35717efbbce11c74\n// import FindLeaseMarketDirectOfferEscrow from \"../contracts/FindLeaseMarketDirectOfferEscrow.cdc\"\nimport FindLeaseMarket from 0x35717efbbce11c74\n\ntransaction(name: String) {\n    prepare(account: AuthAccount) {\n        //if we do not have a profile it might be stored under a different address so we will just remove it\n        let profileCapFirst = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if profileCapFirst.check() {\n            return \n        }\n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n        //SYNC with register\n        //Add exising FUSD or create a new one and add it\n        let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n        if !fusdReceiver.check() {\n            let fusd \u003c- FUSD.createEmptyVault()\n            account.save(\u003c- fusd, to: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n        }\n\n        let usdcCap = account.getCapability\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e(FiatToken.VaultReceiverPubPath)\n        if !usdcCap.check() {\n                account.save( \u003c-FiatToken.createEmptyVault(), to: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e( FiatToken.VaultReceiverPubPath, target: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FiatToken.ResourceId}\u003e( FiatToken.VaultUUIDPubPath, target: FiatToken.VaultStoragePath)\n                account.link\u003c\u0026FiatToken.Vault{FungibleToken.Balance}\u003e( FiatToken.VaultBalancePubPath, target:FiatToken.VaultStoragePath)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let dandyCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        var created=false\n        var updated=false\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        if !profile.hasWallet(\"Flow\") {\n            let flowWallet=Profile.Wallet( name:\"Flow\", receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), tags: [\"flow\"])\n    \n            profile.addWallet(flowWallet)\n            updated=true\n        }\n        if !profile.hasWallet(\"FUSD\") {\n            profile.addWallet(Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), tags: [\"fusd\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if !profile.hasWallet(\"USDC\") {\n            profile.addWallet(Profile.Wallet( name:\"USDC\", receiver:usdcCap, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(FiatToken.VaultBalancePubPath), accept: Type\u003c@FiatToken.Vault\u003e(), tags: [\"usdc\", \"stablecoin\"]))\n            updated=true\n        }\n\n         //If find name not set and we have a profile set it.\n        if profile.getFindName() == \"\" {\n            if let findName = FIND.reverseLookup(account.address) {\n                profile.setFindName(findName)\n                // If name is set, it will emit Updated Event, there is no need to emit another update event below. \n                updated=false\n            }\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else if updated {\n            profile.emitUpdatedEvent()\n        }\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let tenantCapability= FindMarket.getTenantCapability(FindMarket.getFindTenantAddress())!\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        let doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        let doeSalePublicPath=FindMarket.getPublicPath(doeSaleType, name: tenant.name)\n        let doeSaleStoragePath= FindMarket.getStoragePath(doeSaleType, name:tenant.name)\n        let doeSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n        if !doeSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n        }\n\n        let doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        let doeBidPublicPath=FindMarket.getPublicPath(doeBidType, name: tenant.name)\n        let doeBidStoragePath= FindMarket.getStoragePath(doeBidType, name:tenant.name)\n        let doeBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n        if !doeBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n        }\n\n        /// auctions that escrow ft\n        let aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        let aeSalePublicPath=FindMarket.getPublicPath(aeSaleType, name: tenant.name)\n        let aeSaleStoragePath= FindMarket.getStoragePath(aeSaleType, name:tenant.name)\n        let aeSaleCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n        if !aeSaleCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n        }\n\n        let dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\n        let dosSalePublicPath=FindMarket.getPublicPath(dosSaleType, name: tenant.name)\n        let dosSaleStoragePath= FindMarket.getStoragePath(dosSaleType, name:tenant.name)\n\n        let dosSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n        if !dosSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n        }\n\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n        if !dosBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n        }\n\n        let aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\n        let aeBidPublicPath=FindMarket.getPublicPath(aeBidType, name: tenant.name)\n        let aeBidStoragePath= FindMarket.getStoragePath(aeBidType, name:tenant.name)\n        let aeBidCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n        if !aeBidCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n        }\n\n     /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n        }\n\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n        if !asBidCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n        }\n\n        let leaseTenantCapability= FindMarket.getTenantCapability(FindMarket.getTenantAddress(\"findLease\")!)!\n\n        let leaseSaleItemType= Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()\n        let leasePublicPath=FindMarket.getPublicPath(leaseSaleItemType, name: \"findLease\")\n        let leaseStoragePath= FindMarket.getStoragePath(leaseSaleItemType, name:\"findLease\")\n        let leaseSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath) \n        if !leaseSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketSale.SaleItemCollection\u003e(\u003c- FindLeaseMarketSale.createEmptySaleItemCollection(leaseTenantCapability), to: leaseStoragePath)\n            account.link\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath, target: leaseStoragePath)\n        }\n\n        let leaseASSaleItemType= Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e()\n        let leaseASPublicPath=FindMarket.getPublicPath(leaseASSaleItemType, name: \"findLease\")\n        let leaseASStoragePath= FindMarket.getStoragePath(leaseASSaleItemType, name:\"findLease\")\n        let leaseASSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath) \n        if !leaseASSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseASStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath, target: leaseASStoragePath)\n        }\n\n\n        let leaseASBidType= Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e()\n        let leaseASBidPublicPath=FindMarket.getPublicPath(leaseASBidType, name: \"findLease\")\n        let leaseASBidStoragePath= FindMarket.getStoragePath(leaseASBidType, name: \"findLease\")\n        let leaseASBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath) \n        if !leaseASBidCap.check() {\n            account.save\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseASBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath, target: leaseASBidStoragePath)\n        }\n\n        // let leaseAESaleItemType= Type\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e()\n        // let leaseAEPublicPath=FindMarket.getPublicPath(leaseAESaleItemType, name: \"findLease\")\n        // let leaseAEStoragePath= FindMarket.getStoragePath(leaseAESaleItemType, name:\"findLease\")\n        // let leaseAESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath) \n        // if !leaseAESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseAEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath, target: leaseAEStoragePath)\n        // }\n\n        // let leaseAEBidType= Type\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e()\n        // let leaseAEBidPublicPath=FindMarket.getPublicPath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidStoragePath= FindMarket.getStoragePath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath) \n        // if !leaseAEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseAEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath, target: leaseAEBidStoragePath)\n        // }\n\n        let leaseDOSSaleItemType= Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e()\n        let leaseDOSPublicPath=FindMarket.getPublicPath(leaseDOSSaleItemType, name: \"findLease\")\n        let leaseDOSStoragePath= FindMarket.getStoragePath(leaseDOSSaleItemType, name:\"findLease\")\n        let leaseDOSSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath) \n        if !leaseDOSSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOSStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath, target: leaseDOSStoragePath)\n        }\n\n        let leaseDOSBidType= Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let leaseDOSBidPublicPath=FindMarket.getPublicPath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidStoragePath= FindMarket.getStoragePath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath) \n        if !leaseDOSBidCap.check() {\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOSBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath, target: leaseDOSBidStoragePath)\n        }\n\n        // let leaseDOESaleItemType= Type\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        // let leaseDOEPublicPath=FindMarket.getPublicPath(leaseDOESaleItemType, name: \"findLease\")\n        // let leaseDOEStoragePath= FindMarket.getStoragePath(leaseDOESaleItemType, name:\"findLease\")\n        // let leaseDOESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath) \n        // if !leaseDOESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath, target: leaseDOEStoragePath)\n        // }\n\n        // let leaseDOEBidType= Type\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        // let leaseDOEBidPublicPath=FindMarket.getPublicPath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidStoragePath= FindMarket.getStoragePath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath) \n        // if !leaseDOEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath, target: leaseDOEBidStoragePath)\n        // }\n        //SYNC with register\n\n    }\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "delistAllLeaseSale": {
               "code": "import FindLeaseMarketSale from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\nimport FindLeaseMarket from 0x35717efbbce11c74\n\ntransaction() {\n    prepare(account: AuthAccount) {\n        // Get all the saleItems Id\n\n        let tenant = FindMarket.getTenant(FindMarket.getTenantAddress(\"findLease\")!)\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindLeaseMarketSale.SaleItem\u003e())\n        let cap = FindLeaseMarket.getSaleItemCollectionCapability(tenantRef: tenant, marketOption: marketOption, address: account.address)\n        let ref = cap.borrow() ?? panic(\"Cannot borrow reference to the capability.\")\n\n        let listingType=Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()\n        let saleItems= account.borrow\u003c\u0026FindLeaseMarketSale.SaleItemCollection\u003e(from: tenant.getStoragePath(listingType))!\n        let leases = ref.getNameSales()\n        for lease in leases {\n            saleItems.delist(lease)\n        }\n    }\n}",
               "spec": {
                  "order": [],
                  "parameters": {}
               }
            },
            "delistAllNFTSale": {
               "code": "import FindMarketSale from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\n\ntransaction(marketplace:Address) {\n\n    let saleItems : \u0026FindMarketSale.SaleItemCollection?\n\n    prepare(account: AuthAccount) {\n        let tenant = FindMarket.getTenant(marketplace)\n        self.saleItems= account.borrow\u003c\u0026FindMarketSale.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketSale.SaleItemCollection\u003e())) \n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        let ids = self.saleItems!.getIds()\n        for id in ids {\n            self.saleItems!.delist(id)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace"
                  ],
                  "parameters": {
                     "marketplace": "Address"
                  }
               }
            },
            "delistAllNameSale": {
               "code": "import FIND from 0x35717efbbce11c74\n\ntransaction() {\n\n    let finLeases : \u0026FIND.LeaseCollection?\n\n    prepare(acct: AuthAccount) {\n        self.finLeases= acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)\n\n    }\n\n    pre{\n        self.finLeases != nil : \"Cannot borrow reference to find lease collection\"\n    }\n\n    execute{\n        let leases = self.finLeases!.getLeaseInformation()\n        for lease in leases {\n            if lease.salePrice != nil {\n                self.finLeases!.delistSale(lease.name)\n            }\n        }\n    }\n}",
               "spec": {
                  "order": [],
                  "parameters": {}
               }
            },
            "delistLeaseSale": {
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FindLeaseMarketSale from 0x35717efbbce11c74\n\ntransaction(leases: [String]) {\n    let saleItems : \u0026FindLeaseMarketSale.SaleItemCollection?\n\n    prepare(account: AuthAccount) {\n\n        let tenant=FindMarket.getTenant(FindMarket.getTenantAddress(\"findLease\")!)\n        self.saleItems= account.borrow\u003c\u0026FindLeaseMarketSale.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()))\n\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        for lease in leases {\n            self.saleItems!.delist(lease)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "leases"
                  ],
                  "parameters": {
                     "leases": "[String]"
                  }
               }
            },
            "delistNFTSale": {
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FindMarketSale from 0x35717efbbce11c74\n\ntransaction(marketplace:Address, ids: [UInt64]) {\n\n    let saleItems : \u0026FindMarketSale.SaleItemCollection?\n\n    prepare(account: AuthAccount) {\n\n        let tenant=FindMarket.getTenant(marketplace)\n        self.saleItems= account.borrow\u003c\u0026FindMarketSale.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketSale.SaleItemCollection\u003e()))\n\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        for id in ids {\n            self.saleItems!.delist(id)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "ids"
                  ],
                  "parameters": {
                     "ids": "[UInt64]",
                     "marketplace": "Address"
                  }
               }
            },
            "delistNameSale": {
               "code": "import FIND from 0x35717efbbce11c74\n\ntransaction(names: [String]) {\n\n    let finLeases : \u0026FIND.LeaseCollection?\n\n    prepare(acct: AuthAccount) {\n        self.finLeases= acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)\n    }\n\n    pre{\n        self.finLeases != nil : \"Cannot borrow reference to find lease collection\"\n    }\n\n    execute{\n        for name in names {\n            self.finLeases!.delistSale(name)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "names"
                  ],
                  "parameters": {
                     "names": "[String]"
                  }
               }
            },
            "editProfile": {
               "code": "import FungibleToken from 0x9a0766d93b6608b7\nimport FUSD from 0xe223d8a629e49c68\nimport FlowToken from 0x7e60df042a9c0868\nimport FIND from 0x35717efbbce11c74\nimport Profile from 0x35717efbbce11c74\n\ntransaction(name:String, description: String, avatar: String, tags:[String], allowStoringFollowers: Bool, linkTitles : {String: String}, linkTypes: {String:String}, linkUrls : {String:String}, removeLinks : [String]) {\n    \n    let profile : \u0026Profile.User\n\n    prepare(account: AuthAccount) {\n\n        self.profile =account.borrow\u003c\u0026Profile.User\u003e(from:Profile.storagePath) ?? panic(\"Cannot borrow reference to profile\")\n\n        //Add exising FUSD or create a new one and add it\n        let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n        if !fusdReceiver.check() {\n            let fusd \u003c- FUSD.createEmptyVault()\n            account.save(\u003c- fusd, to: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n        }\n\n\n        var hasFusdWallet=false\n        var hasFlowWallet=false\n        let wallets=self.profile.getWallets()\n        for wallet in wallets {\n            if wallet.name==\"FUSD\" {\n                hasFusdWallet=true\n            }\n\n            if wallet.name ==\"Flow\" {\n                hasFlowWallet=true\n            }\n        }\n\n        if !hasFlowWallet {\n            let flowWallet=Profile.Wallet(\n                name:\"Flow\", \n                receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver),\n                balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance),\n                accept: Type\u003c@FlowToken.Vault\u003e(),\n                tags: [\"flow\"]\n            )\n            self.profile.addWallet(flowWallet)\n        }\n\n        if !hasFusdWallet {\n            let fusdWallet=Profile.Wallet(\n                name:\"FUSD\", \n                receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver),\n                balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance),\n                accept: Type\u003c@FUSD.Vault\u003e(),\n                tags: [\"fusd\", \"stablecoin\"]\n            )\n            self.profile.addWallet(fusdWallet)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n    }\n\n    execute{\n        self.profile!.setName(name)\n        self.profile!.setDescription(description)\n        self.profile!.setAvatar(avatar)\n        self.profile!.setTags(tags)\n\n        for link in removeLinks {\n            self.profile!.removeLink(link)\n        }\n\n        for titleName in linkTitles.keys {\n            let title=linkTitles[titleName]!\n            let url = linkUrls[titleName]!\n            let type = linkTypes[titleName]!\n\n            self.profile!.addLinkWithName(name:titleName, link: Profile.Link(title: title, type: type, url: url))\n        }\n        self.profile!.emitUpdatedEvent()\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "description",
                     "avatar",
                     "tags",
                     "allowStoringFollowers",
                     "linkTitles",
                     "linkTypes",
                     "linkUrls",
                     "removeLinks"
                  ],
                  "parameters": {
                     "allowStoringFollowers": "Bool",
                     "avatar": "String",
                     "description": "String",
                     "linkTitles": "{String: String}",
                     "linkTypes": "{String: String}",
                     "linkUrls": "{String: String}",
                     "name": "String",
                     "removeLinks": "[String]",
                     "tags": "[String]"
                  }
               }
            },
            "fulfillLeaseMarketAuctionSoft": {
               "code": "import FindLeaseMarketAuctionSoft from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FTRegistry from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\nimport FindLeaseMarket from 0x35717efbbce11c74\n\ntransaction(leaseName: String, amount:UFix64) {\n\n    let walletReference : \u0026FungibleToken.Vault\n    let bidsReference: \u0026FindLeaseMarketAuctionSoft.MarketBidCollection\n    let requiredAmount: UFix64\n\n    prepare(account: AuthAccount) {\n        let marketplace = FindMarket.getTenantAddress(\"findLease\")!\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e())\n\n        self.bidsReference= account.borrow\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"This account does not have a bid collection\")\n\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e())\n        let item = FindLeaseMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, name: leaseName)\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n    \n        self.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n        self.requiredAmount = self.bidsReference.getBalance(leaseName)\n    }\n\n    pre{\n        self.walletReference.balance \u003e self.requiredAmount : \"Your wallet does not have enough funds to pay for this item\"\n        self.requiredAmount == amount : \"Amount needed to fulfill is \".concat(self.requiredAmount.toString()).concat(\" you sent in \").concat(amount.toString())\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount) \n        self.bidsReference.fulfillAuction(name: leaseName, vault: \u003c- vault)\n    }\n}",
               "spec": {
                  "order": [
                     "leaseName",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "leaseName": "String"
                  }
               }
            },
            "fulfillLeaseMarketAuctionSoftDUC": {
               "code": "import FindLeaseMarketAuctionSoft from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FTRegistry from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\nimport FindLeaseMarket from 0x35717efbbce11c74\nimport DapperUtilityCoin from 0x82ec283f88a62e65\n\ntransaction(leaseName: String, amount:UFix64) {\n\n    let walletReference : \u0026FungibleToken.Vault\n    let bidsReference: \u0026FindLeaseMarketAuctionSoft.MarketBidCollection\n    let requiredAmount: UFix64\n    let mainDapperUtilityCoinVault: \u0026DapperUtilityCoin.Vault\n    let balanceBeforeTransfer: UFix64\n\n    prepare(dapper: AuthAccount, account: AuthAccount) {\n        let marketplace = FindMarket.getTenantAddress(\"findLease\")!\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e())\n\n        self.bidsReference= account.borrow\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"This account does not have a bid collection\")\n\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e())\n        let item = FindLeaseMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, name: leaseName)\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n    \n        // There should be no need to assert this, there will be no listing in other tokens for Dapper wallet.\n        // if ft.type != Type\u003c@DapperUtilityCoin.Vault\u003e(){\n        //     panic(\"This item is not listed for Dapper Wallets. Please fulfill in with other wallets.\")\n        // }\n        self.mainDapperUtilityCoinVault = dapper.borrow\u003c\u0026DapperUtilityCoin.Vault\u003e(from: /storage/dapperUtilityCoinVault) ?? panic(\"Cannot borrow DapperUtilityCoin vault from account storage\")\n        self.balanceBeforeTransfer = self.mainDapperUtilityCoinVault.balance\n\n        self.walletReference = dapper.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n        self.requiredAmount = self.bidsReference.getBalance(leaseName)\n    }\n\n    pre{\n        self.walletReference.balance \u003e self.requiredAmount : \"Your wallet does not have enough funds to pay for this item\"\n        self.requiredAmount == amount : \"Amount needed to fulfill is \".concat(self.requiredAmount.toString()).concat(\" you sent in \").concat(amount.toString())\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount) \n        self.bidsReference.fulfillAuction(name: leaseName, vault: \u003c- vault)\n    }\n\n    // Check that all dapperUtilityCoin was routed back to Dapper\n    post {\n        self.mainDapperUtilityCoinVault.balance == self.balanceBeforeTransfer: \"DapperUtilityCoin leakage\"\n    }\n}",
               "spec": {
                  "order": [
                     "leaseName",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "leaseName": "String"
                  }
               }
            },
            "fulfillLeaseMarketDirectOfferSoft": {
               "code": "import FindLeaseMarketDirectOfferSoft from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FTRegistry from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\nimport FindLeaseMarket from 0x35717efbbce11c74\n\ntransaction(leaseName: String, amount:UFix64) {\n\n    let walletReference : \u0026FungibleToken.Vault\n    let bidsReference: \u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection\n    let requiredAmount:UFix64\n\n    prepare(account: AuthAccount) {\n        let marketplace = FindMarket.getTenantAddress(\"findLease\")!\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e())\n        self.bidsReference= account.borrow\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"Cannot borrow direct offer soft bid collection\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e())\n        let item = FindLeaseMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, name: leaseName)\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n\n          self.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n\n        self.requiredAmount = self.bidsReference.getBalance(leaseName)\n    }\n\n    pre {\n        self.walletReference.balance \u003e self.requiredAmount : \"Your wallet does not have enough funds to pay for this item\"\n        self.requiredAmount == amount : \"Amount needed to fulfill is \".concat(amount.toString())\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount) \n        self.bidsReference.fulfillDirectOffer(name: leaseName, vault: \u003c- vault)\n    }\n}",
               "spec": {
                  "order": [
                     "leaseName",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "leaseName": "String"
                  }
               }
            },
            "fulfillLeaseMarketDirectOfferSoftDUC": {
               "code": "import FindLeaseMarketDirectOfferSoft from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FTRegistry from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\nimport FindLeaseMarket from 0x35717efbbce11c74\nimport DapperUtilityCoin from 0x82ec283f88a62e65\n\ntransaction(leaseName: String, amount:UFix64) {\n\n    let walletReference : \u0026FungibleToken.Vault\n    let bidsReference: \u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection\n    let requiredAmount:UFix64\n    let mainDapperUtilityCoinVault: \u0026DapperUtilityCoin.Vault\n    let balanceBeforeTransfer: UFix64\n\n    prepare(dapper: AuthAccount, account: AuthAccount) {\n        let marketplace = FindMarket.getTenantAddress(\"findLease\")!\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e())\n        self.bidsReference= account.borrow\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"Cannot borrow direct offer soft bid collection\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e())\n        let item = FindLeaseMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, name: leaseName)\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n\n        // There should be no need to assert this, there will be no listing in other tokens for Dapper wallet.\n        // if ft.type != Type\u003c@DapperUtilityCoin.Vault\u003e(){\n        //     panic(\"This item is not listed for Dapper Wallets. Please fulfill in with other wallets.\")\n        // }\n        self.mainDapperUtilityCoinVault = dapper.borrow\u003c\u0026DapperUtilityCoin.Vault\u003e(from: /storage/dapperUtilityCoinVault) ?? panic(\"Cannot borrow DapperUtilityCoin vault from account storage\")\n        self.balanceBeforeTransfer = self.mainDapperUtilityCoinVault.balance\n\n          self.walletReference = dapper.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n\n        self.requiredAmount = self.bidsReference.getBalance(leaseName)\n    }\n\n    pre {\n        self.walletReference.balance \u003e self.requiredAmount : \"Your wallet does not have enough funds to pay for this item\"\n        self.requiredAmount == amount : \"Amount needed to fulfill is \".concat(amount.toString())\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount) \n        self.bidsReference.fulfillDirectOffer(name: leaseName, vault: \u003c- vault)\n    }\n\n    // Check that all dapperUtilityCoin was routed back to Dapper\n    post {\n        self.mainDapperUtilityCoinVault.balance == self.balanceBeforeTransfer: \"DapperUtilityCoin leakage\"\n    }\n}",
               "spec": {
                  "order": [
                     "leaseName",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "leaseName": "String"
                  }
               }
            },
            "fulfillMarketAuctionEscrowed": {
               "code": "import FindMarketAuctionEscrow from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\n\ntransaction(marketplace:Address, owner: String, id: UInt64) {\n\n    let saleItem : Capability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic}\u003e?\n\n    prepare(account: AuthAccount) {\n        let resolveAddress = FIND.resolve(owner)\n        if resolveAddress == nil { \n            panic(\"The address input is not a valid name nor address. Input : \".concat(owner))\n        }\n        let address = resolveAddress!\n        self.saleItem = FindMarketAuctionEscrow.getSaleItemCapability(marketplace:marketplace, user:address)\n\n    }\n\n    pre{\n        self.saleItem != nil : \"This saleItem capability does not exist. Sale item ID: \".concat(id.toString())\n        self.saleItem!.check() : \"Cannot borrow reference to saleItem. Sale item ID: \".concat(id.toString())\n    }\n\n    execute {\n        self.saleItem!.borrow()!.fulfillAuction(id)\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "owner",
                     "id"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "marketplace": "Address",
                     "owner": "String"
                  }
               }
            },
            "fulfillMarketAuctionEscrowedFromBidder": {
               "code": "import FindMarketAuctionEscrow from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\n\ntransaction(marketplace:Address, id: UInt64) {\n\n    let bidsReference : \u0026FindMarketAuctionEscrow.MarketBidCollection?\n\n    prepare(account: AuthAccount) {\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e())\n        self.bidsReference= account.borrow\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection\u003e(from: storagePath)\n\n        \n    }\n\n    pre{\n        self.bidsReference != nil : \"Cannot borrow reference to bid collection.\"\n    }\n\n    execute{\n        self.bidsReference!.fulfillAuction(id)\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "fulfillMarketAuctionSoft": {
               "code": "import FindMarketAuctionSoft from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FTRegistry from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\n\ntransaction(marketplace:Address, id: UInt64, amount:UFix64) {\n\n    let walletReference : \u0026FungibleToken.Vault\n    let bidsReference: \u0026FindMarketAuctionSoft.MarketBidCollection\n    let requiredAmount: UFix64\n\n    prepare(account: AuthAccount) {\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e())\n\n        self.bidsReference= account.borrow\u003c\u0026FindMarketAuctionSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"This account does not have a bid collection\")\n\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e())\n        let item = FindMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: id)\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n    \n        self.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n        self.requiredAmount = self.bidsReference.getBalance(id)\n    }\n\n    pre{\n        self.walletReference.balance \u003e self.requiredAmount : \"Your wallet does not have enough funds to pay for this item\"\n        self.requiredAmount == amount : \"Amount needed to fulfill is \".concat(self.requiredAmount.toString()).concat(\" you sent in \").concat(amount.toString())\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount) \n        self.bidsReference.fulfillAuction(id: id, vault: \u003c- vault)\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "fulfillMarketAuctionSoftDUC": {
               "code": "import FindMarketAuctionSoft from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FTRegistry from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\nimport DapperUtilityCoin from 0x82ec283f88a62e65\n\ntransaction(marketplace:Address, id: UInt64, amount:UFix64) {\n\n    let walletReference : \u0026FungibleToken.Vault\n    let bidsReference: \u0026FindMarketAuctionSoft.MarketBidCollection\n    let requiredAmount: UFix64\n    let mainDapperUtilityCoinVault: \u0026DapperUtilityCoin.Vault\n    let balanceBeforeTransfer: UFix64\n\n    prepare(dapper: AuthAccount, account: AuthAccount) {\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e())\n\n        self.bidsReference= account.borrow\u003c\u0026FindMarketAuctionSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"This account does not have a bid collection\")\n\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e())\n        let item = FindMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: id)\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n    \n        // There should be no need to assert this, there will be no listing in other tokens for Dapper wallet.\n        // if ft.type != Type\u003c@DapperUtilityCoin.Vault\u003e(){\n        //     panic(\"This item is not listed for Dapper Wallets. Please fulfill in with other wallets.\")\n        // }\n        self.mainDapperUtilityCoinVault = dapper.borrow\u003c\u0026DapperUtilityCoin.Vault\u003e(from: /storage/dapperUtilityCoinVault) ?? panic(\"Cannot borrow DapperUtilityCoin vault from account storage\")\n        self.balanceBeforeTransfer = self.mainDapperUtilityCoinVault.balance\n\n        self.walletReference = dapper.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n        self.requiredAmount = self.bidsReference.getBalance(id)\n    }\n\n    pre{\n        self.walletReference.balance \u003e self.requiredAmount : \"Your wallet does not have enough funds to pay for this item\"\n        self.requiredAmount == amount : \"Amount needed to fulfill is \".concat(self.requiredAmount.toString()).concat(\" you sent in \").concat(amount.toString())\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount) \n        self.bidsReference.fulfillAuction(id: id, vault: \u003c- vault)\n    }\n\n    // Check that all dapperUtilityCoin was routed back to Dapper\n    post {\n        self.mainDapperUtilityCoinVault.balance == self.balanceBeforeTransfer: \"DapperUtilityCoin leakage\"\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "fulfillMarketDirectOfferEscrowed": {
               "code": "import FindMarketDirectOfferEscrow from 0x35717efbbce11c74\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FindViews from 0x35717efbbce11c74\nimport NFTCatalog from 0x324c34e1c517e4db\nimport FINDNFTCatalog from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\n\ntransaction(marketplace:Address, id: UInt64) {\n\n    let market : \u0026FindMarketDirectOfferEscrow.SaleItemCollection?\n    let pointer : FindViews.AuthNFTPointer\n\n    prepare(account: AuthAccount) {\n\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e())\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e())\n\n        let item = FindMarket.assertOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: id)\n\n        let nftIdentifier = item.getItemType().identifier\n        let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier)) \n        let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n        let nft = collection.collectionData\n\n    \n        var providerCap=account.getCapability\u003c\u0026{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e(nft.privatePath)\n\n        /* Ben : Question -\u003e Either client will have to provide the path here or agree that we set it up for the user */\n        if !providerCap.check() {\n            let newCap = account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                    nft.privatePath,\n                    target: nft.storagePath\n            )\n            if newCap == nil {\n                // If linking is not successful, we link it using finds custom link \n                let pathIdentifier = nft.privatePath.toString()\n                let findPath = PrivatePath(identifier: pathIdentifier.slice(from: \"/private/\".length , upTo: pathIdentifier.length).concat(\"_FIND\"))!\n                account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                    findPath,\n                    target: nft.storagePath\n                )\n                providerCap = account.getCapability\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(findPath)\n            }\n        }\n\n        self.pointer= FindViews.AuthNFTPointer(cap: providerCap, id: item.getItemID())\n        self.market = account.borrow\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection\u003e(from: storagePath)\n\n    }\n\n    pre{\n        self.market != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        self.market!.acceptDirectOffer(self.pointer)\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "fulfillMarketDirectOfferSoft": {
               "code": "import FindMarketDirectOfferSoft from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FTRegistry from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\n\ntransaction(marketplace:Address, id: UInt64, amount:UFix64) {\n\n    let walletReference : \u0026FungibleToken.Vault\n    let bidsReference: \u0026FindMarketDirectOfferSoft.MarketBidCollection\n    let requiredAmount:UFix64\n\n    prepare(account: AuthAccount) {\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n        self.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"Cannot borrow direct offer soft bid collection\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n        let item = FindMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: id)\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n\n      self.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n\n        self.requiredAmount = self.bidsReference.getBalance(id)\n    }\n\n    pre {\n        self.walletReference.balance \u003e self.requiredAmount : \"Your wallet does not have enough funds to pay for this item\"\n        self.requiredAmount == amount : \"Amount needed to fulfill is \".concat(amount.toString())\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount) \n        self.bidsReference.fulfillDirectOffer(id: id, vault: \u003c- vault)\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "fulfillMarketDirectOfferSoftDUC": {
               "code": "import FindMarketDirectOfferSoft from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FTRegistry from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\nimport DapperUtilityCoin from 0x82ec283f88a62e65\n\ntransaction(marketplace:Address, id: UInt64, amount:UFix64) {\n\n    let walletReference : \u0026FungibleToken.Vault\n    let bidsReference: \u0026FindMarketDirectOfferSoft.MarketBidCollection\n    let requiredAmount:UFix64\n    let mainDapperUtilityCoinVault: \u0026DapperUtilityCoin.Vault\n    let balanceBeforeTransfer: UFix64\n\n    prepare(dapper: AuthAccount, account: AuthAccount) {\n\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n        self.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"Cannot borrow direct offer soft bid collection\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n        let item = FindMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: id)\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n\n        // There should be no need to assert this, there will be no listing in other tokens for Dapper wallet.\n        // if ft.type != Type\u003c@DapperUtilityCoin.Vault\u003e(){\n        //     panic(\"This item is not listed for Dapper Wallets. Please fulfill in with other wallets.\")\n        // }\n        self.mainDapperUtilityCoinVault = dapper.borrow\u003c\u0026DapperUtilityCoin.Vault\u003e(from: /storage/dapperUtilityCoinVault) ?? panic(\"Cannot borrow DapperUtilityCoin vault from account storage\")\n        self.balanceBeforeTransfer = self.mainDapperUtilityCoinVault.balance\n\n          self.walletReference = dapper.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n\n        self.requiredAmount = self.bidsReference.getBalance(id)\n    }\n\n    pre {\n        self.walletReference.balance \u003e self.requiredAmount : \"Your wallet does not have enough funds to pay for this item\"\n        self.requiredAmount == amount : \"Amount needed to fulfill is \".concat(amount.toString())\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount) \n        self.bidsReference.fulfillDirectOffer(id: id, vault: \u003c- vault)\n    }\n\n    // Check that all dapperUtilityCoin was routed back to Dapper\n    post {\n        self.mainDapperUtilityCoinVault.balance == self.balanceBeforeTransfer: \"DapperUtilityCoin leakage\"\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "fulfillMultipleMarketDirectOfferEscrowed": {
               "code": "import FindMarketDirectOfferEscrow from 0x35717efbbce11c74\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FindViews from 0x35717efbbce11c74\nimport NFTCatalog from 0x324c34e1c517e4db\nimport FINDNFTCatalog from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\n\ntransaction(marketplace:Address, ids: [UInt64]) {\n\n    let market : \u0026FindMarketDirectOfferEscrow.SaleItemCollection?\n    let pointer : [FindViews.AuthNFTPointer]\n\n    prepare(account: AuthAccount) {\n\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e())\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e())\n        self.market = account.borrow\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection\u003e(from: storagePath)\n        self.pointer = []\n\n        let nfts : {String : NFTCatalog.NFTCollectionData} = {}\n        var counter = 0\n        while counter \u003c ids.length {\n            let item = FindMarket.assertOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: ids[counter])\n\n            var nft : NFTCatalog.NFTCollectionData? = nil\n            let nftIdentifier = item.getItemType().identifier\n\n            if nfts[nftIdentifier] != nil {\n                nft = nfts[nftIdentifier]\n            } else {\n                let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier)) \n                let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n                nft = collection.collectionData\n                nfts[nftIdentifier] = nft\n            }\n        \n            var providerCap=account.getCapability\u003c\u0026{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e(nft!.privatePath)\n\n            /* Ben : Question -\u003e Either client will have to provide the path here or agree that we set it up for the user */\n            if !providerCap.check() {\n                let newCap = account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                        nft!.privatePath,\n                        target: nft!.storagePath\n                )\n                if newCap == nil {\n                    // If linking is not successful, we link it using finds custom link \n                    let pathIdentifier = nft!.privatePath.toString()\n                    let findPath = PrivatePath(identifier: pathIdentifier.slice(from: \"/private/\".length , upTo: pathIdentifier.length).concat(\"_FIND\"))!\n                    account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                        findPath,\n                        target: nft!.storagePath\n                    )\n                    providerCap = account.getCapability\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(findPath)\n                }\n            }\n\n            let pointer= FindViews.AuthNFTPointer(cap: providerCap, id: item.getItemID())\n            self.pointer.append(pointer)\n            counter = counter + 1\n        }\n\n    }\n\n    pre{\n        self.market != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        var counter = 0\n        while counter \u003c ids.length {\n            self.market!.acceptDirectOffer(self.pointer[counter])\n            counter = counter + 1\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "ids"
                  ],
                  "parameters": {
                     "ids": "[UInt64]",
                     "marketplace": "Address"
                  }
               }
            },
            "fulfillMultipleMarketDirectOfferSoft": {
               "code": "import FindMarketDirectOfferSoft from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FTRegistry from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\n\ntransaction(marketplace:Address, ids: [UInt64], amounts:[UFix64]) {\n\n    let walletReference : [\u0026FungibleToken.Vault]\n    let bidsReference: \u0026FindMarketDirectOfferSoft.MarketBidCollection\n    let requiredAmount: [UFix64]\n\n    prepare(account: AuthAccount) {\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n        self.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"Cannot borrow direct offer soft bid collection\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n\n        var counter = 0\n        self.requiredAmount = []\n        self.walletReference = []\n        let fts : {String : FTRegistry.FTInfo} = {}\n        let vaultRefs : {StoragePath : \u0026FungibleToken.Vault} = {}\n\n\n        while counter \u003c ids.length {\n            let item = FindMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: ids[counter])\n\n            var ft : FTRegistry.FTInfo? = nil\n            let ftIdentifier = item.getFtType().identifier\n            if fts[ftIdentifier] != nil {\n                ft = fts[ftIdentifier]\n            } else {\n                ft = FTRegistry.getFTInfoByTypeIdentifier(ftIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftIdentifier))\n                fts[ftIdentifier] = ft\n            }\n\n            if vaultRefs[ft!.vaultPath] != nil {\n                self.walletReference.append(vaultRefs[ft!.vaultPath]!)\n            } else {\n                let walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft!.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n                vaultRefs[ft!.vaultPath] = walletReference\n                self.walletReference.append(walletReference)\n            }\n            let requiredAmount = self.bidsReference.getBalance(ids[counter])\n            self.requiredAmount.append(requiredAmount)\n            counter = counter + 1\n        }\n    }\n\n    execute {\n        var counter = 0\n        while counter \u003c ids.length {\n            if self.walletReference[counter].balance \u003c self.requiredAmount[counter] {\n                panic(\"Your wallet does not have enough funds to pay for this item. Item ID: \".concat(ids[counter].toString()))\n            }\n            if self.requiredAmount[counter] != amounts[counter] {\n                panic(\"Amount needed to fulfill is \".concat(amounts[counter].toString()))\n            }\n            let vault \u003c- self.walletReference[counter].withdraw(amount: amounts[counter]) \n            self.bidsReference.fulfillDirectOffer(id: ids[counter], vault: \u003c- vault)\n            counter = counter + 1\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "ids",
                     "amounts"
                  ],
                  "parameters": {
                     "amounts": "[UFix64]",
                     "ids": "[UInt64]",
                     "marketplace": "Address"
                  }
               }
            },
            "fulfillMultipleMarketDirectOfferSoftDUC": {
               "code": "import FindMarketDirectOfferSoft from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FTRegistry from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\nimport DapperUtilityCoin from 0x82ec283f88a62e65\n\ntransaction(marketplace:Address, ids: [UInt64], amounts:[UFix64]) {\n\n    let walletReference : \u0026FungibleToken.Vault\n    let bidsReference: \u0026FindMarketDirectOfferSoft.MarketBidCollection\n    var requiredAmount:UFix64\n    let balanceBeforeTransfer: UFix64\n    var totalAmount: UFix64\n\n    prepare(dapper: AuthAccount, account: AuthAccount) {\n\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n        self.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"Cannot borrow direct offer soft bid collection\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n          self.walletReference = dapper.borrow\u003c\u0026DapperUtilityCoin.Vault\u003e(from: /storage/dapperUtilityCoinVault) ?? panic(\"Cannot borrow DapperUtilityCoin vault from account storage\")\n        self.balanceBeforeTransfer = self.walletReference.balance\n\n        var counter = 0\n        self.totalAmount = 0.0\n        self.requiredAmount = 0.0\n        while counter \u003c ids.length {\n            let item = FindMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: ids[counter])\n            self.requiredAmount = self.requiredAmount + self.bidsReference.getBalance(ids[counter])\n            self.totalAmount = self.totalAmount + amounts[counter]\n            counter = counter + 1\n        }\n    }\n\n    pre {\n        self.walletReference.balance \u003e self.requiredAmount : \"Your wallet does not have enough funds to pay for this item\"\n        self.requiredAmount == self.totalAmount : \"Amount needed to fulfill is \".concat(self.totalAmount.toString())\n    }\n\n    execute {\n        var counter = 0\n        while counter \u003c ids.length {\n            let vault \u003c- self.walletReference.withdraw(amount: amounts[counter]) \n            self.bidsReference.fulfillDirectOffer(id: ids[counter], vault: \u003c- vault)\n            counter = counter + 1 \n        }\n    }\n\n    // Check that all dapperUtilityCoin was routed back to Dapper\n    post {\n        self.walletReference.balance == self.balanceBeforeTransfer: \"DapperUtilityCoin leakage\"\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "ids",
                     "amounts"
                  ],
                  "parameters": {
                     "amounts": "[UFix64]",
                     "ids": "[UInt64]",
                     "marketplace": "Address"
                  }
               }
            },
            "fulfillName": {
               "code": "import FIND from 0x35717efbbce11c74\nimport Profile from 0x35717efbbce11c74\n\ntransaction(name: String) {\n\n    let finLeases : \u0026FIND.LeaseCollection?\n\n    prepare(account: AuthAccount) {\n        self.finLeases= account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath) \n    }\n\n    pre{\n        self.finLeases != nil : \"Cannot borrow reference to find lease collection\"\n    }\n\n    execute{\n        self.finLeases!.fulfill(name)\n    }\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "fulfillNameAuction": {
               "code": "import FIND from 0x35717efbbce11c74\nimport Profile from 0x35717efbbce11c74\n\ntransaction(owner: Address, name: String) {\n\n    let leases : \u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}?\n\n    prepare(account: AuthAccount) {\n        self.leases = getAccount(owner).getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath).borrow()\n    }\n\n    pre{\n        self.leases != nil : \"Cannot borrow reference to lease collection reference. Account address: \".concat(owner.toString())\n    }\n\n    execute{\n        self.leases!.fulfillAuction(name)\n    }\n}",
               "spec": {
                  "order": [
                     "owner",
                     "name"
                  ],
                  "parameters": {
                     "name": "String",
                     "owner": "Address"
                  }
               }
            },
            "fulfillNameAuctionBidder": {
               "code": "import FIND from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FUSD from 0xe223d8a629e49c68\nimport Profile from 0x35717efbbce11c74\n\ntransaction(owner: Address, name: String) {\n\n    let leaseCollectionOwner : \u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}?\n\n    prepare(account: AuthAccount) {\n\n\n    //Add exising FUSD or create a new one and add it\n        let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n        if !fusdReceiver.check() {\n            let fusd \u003c- FUSD.createEmptyVault()\n            account.save(\u003c- fusd, to: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n\n            let fusdWallet=Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), tags: [\"fusd\", \"stablecoin\"])\n\n            profile.addWallet(fusdWallet)\n\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n        }\n\n        self.leaseCollectionOwner = getAccount(owner).getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath).borrow()\n\n    }\n\n    pre{\n        self.leaseCollectionOwner != nil : \"Cannot borrow reference to find lease collection. Account address: \".concat(owner.toString())\n    }\n\n    execute {\n        self.leaseCollectionOwner!.fulfillAuction(name)\n    }\n}",
               "spec": {
                  "order": [
                     "owner",
                     "name"
                  ],
                  "parameters": {
                     "name": "String",
                     "owner": "Address"
                  }
               }
            },
            "increaseBidLeaseMarketAuctionSoft": {
               "code": "import FindLeaseMarketAuctionSoft from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FTRegistry from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\nimport FindLeaseMarket from 0x35717efbbce11c74\n\ntransaction(leaseName: String, amount: UFix64) {\n\n    let bidsReference: \u0026FindLeaseMarketAuctionSoft.MarketBidCollection\n\n    prepare(account: AuthAccount) {\n        let marketplace = FindMarket.getTenantAddress(\"findLease\")!\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e())\n        self.bidsReference= account.borrow\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"Bid resource does not exist\")\n        // get Bidding Fungible Token Vault\n          let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e())\n        let item = FindLeaseMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, name: leaseName)\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n\n        let walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) \n        if ft.alias != \"DUC\" \u0026\u0026 walletReference == nil {\n            panic(\"No suitable wallet linked for this account\")\n        }\n    }\n\n    execute {\n        self.bidsReference.increaseBid(name: leaseName, increaseBy: amount)\n    }\n\n}",
               "spec": {
                  "order": [
                     "leaseName",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "leaseName": "String"
                  }
               }
            },
            "increaseBidLeaseMarketDirectOfferSoft": {
               "code": "import FindLeaseMarketDirectOfferSoft from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\nimport FindLeaseMarket from 0x35717efbbce11c74\n\ntransaction(leaseName: String, amount: UFix64) {\n\n    let bidsReference: \u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection\n\n    prepare(account: AuthAccount) {\n        let marketplace = FindMarket.getTenantAddress(\"findLease\")!\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e())\n        self.bidsReference= account.borrow\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"Bid resource does not exist\")\n        // get Bidding Fungible Token Vault\n          let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e())\n        let item = FindLeaseMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, name: leaseName)\n    }\n\n    execute {\n        self.bidsReference.increaseBid(name: leaseName, increaseBy: amount)\n    }\n}",
               "spec": {
                  "order": [
                     "leaseName",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "leaseName": "String"
                  }
               }
            },
            "increaseBidMarketAuctionEscrowed": {
               "code": "import FindMarketAuctionEscrow from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FTRegistry from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\n\ntransaction(marketplace:Address, id: UInt64, amount: UFix64) {\n\n    let walletReference : \u0026FungibleToken.Vault\n    let bidsReference: \u0026FindMarketAuctionEscrow.MarketBidCollection\n    let balanceBeforeBid: UFix64\n\n    prepare(account: AuthAccount) {\n\n        // Get the accepted vault type from BidInfo\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e())\n        self.bidsReference= account.borrow\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection\u003e(from: storagePath) ?? panic(\"This account does not have a bid collection\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e())\n        let item = FindMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: id)\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n        self.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n        self.balanceBeforeBid = self.walletReference.balance\n    }\n\n    pre {\n        self.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount) \n        self.bidsReference.increaseBid(id: id, vault: \u003c- vault)\n    }\n\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "increaseBidMarketAuctionSoft": {
               "code": "import FindMarketAuctionSoft from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FTRegistry from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\n\ntransaction(marketplace:Address, id: UInt64, amount: UFix64) {\n\n    let bidsReference: \u0026FindMarketAuctionSoft.MarketBidCollection\n\n\n    prepare(account: AuthAccount) {\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e())\n        self.bidsReference= account.borrow\u003c\u0026FindMarketAuctionSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"Bid resource does not exist\")\n        // get Bidding Fungible Token Vault\n          let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e())\n        let item = FindMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: id)\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n\n        let walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath)\n        if ft.alias != \"DUC\" \u0026\u0026 walletReference == nil {\n            panic(\"No suitable wallet linked for this account\")\n        }\n    }\n\n    execute {\n        self.bidsReference.increaseBid(id: id, increaseBy: amount)\n    }\n\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "increaseBidMarketDirectOfferEscrowed": {
               "code": "import FindMarketDirectOfferEscrow from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FTRegistry from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\n\ntransaction(marketplace:Address, id: UInt64, amount: UFix64) {\n\n    let walletReference : \u0026FungibleToken.Vault\n    let bidsReference: \u0026FindMarketDirectOfferEscrow.MarketBidCollection\n    let balanceBeforeBid: UFix64\n\n    prepare(account: AuthAccount) {\n        let tenant=FindMarket.getTenantCapability(marketplace)!.borrow() ?? panic(\"Cannot borrow reference to tenant\")\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e())\n        self.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection\u003e(from: storagePath) ?? panic(\"This account does not have a bid collection\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e())\n        let item = FindMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: id)\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n        self.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n        self.balanceBeforeBid=self.walletReference.balance\n    }\n\n    pre {\n        self.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount) \n        self.bidsReference!.increaseBid(id: id, vault: \u003c- vault)\n    }\n\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "increaseBidMarketDirectOfferSoft": {
               "code": "import FindMarketDirectOfferSoft from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\n\ntransaction(marketplace: Address, id: UInt64, amount: UFix64) {\n\n    let bidsReference: \u0026FindMarketDirectOfferSoft.MarketBidCollection\n\n    prepare(account: AuthAccount) {\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n        self.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"Bid resource does not exist\")\n        // get Bidding Fungible Token Vault\n          let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n        let item = FindMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: id)\n    }\n\n    execute {\n        self.bidsReference.increaseBid(id: id, increaseBy: amount)\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "increaseNameBid": {
               "code": "import FIND from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FUSD from 0xe223d8a629e49c68\n\ntransaction(name: String, amount: UFix64) {\n\n    let vaultRef : \u0026FUSD.Vault?\n    let bids : \u0026FIND.BidCollection?\n\n    prepare(account: AuthAccount) {\n\n        \n        let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        self.vaultRef = account.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault)\n        self.bids = account.borrow\u003c\u0026FIND.BidCollection\u003e(from: FIND.BidStoragePath)\n    }\n\n    pre{\n        self.vaultRef != nil : \"Could not borrow reference to the fusdVault!\"\n        self.bids != nil : \"Could not borrow reference to bid collection\"\n    }\n\n    execute{\n        let vault \u003c- self.vaultRef!.withdraw(amount: amount) as! @FUSD.Vault\n        self.bids!.increaseBid(name: name, vault: \u003c- vault)\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "name": "String"
                  }
               }
            },
            "listLeaseForAuctionSoft": {
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FindMarketSale from 0x35717efbbce11c74\nimport FindMarketAuctionEscrow from 0x35717efbbce11c74\nimport FindMarketAuctionSoft from 0x35717efbbce11c74\nimport FindMarketDirectOfferEscrow from 0x35717efbbce11c74\nimport FindMarketDirectOfferSoft from 0x35717efbbce11c74\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FindViews from 0x35717efbbce11c74\nimport FTRegistry from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FUSD from 0xe223d8a629e49c68\nimport FiatToken from 0xa983fecbed621163\nimport FlowToken from 0x7e60df042a9c0868\nimport FIND from 0x35717efbbce11c74\nimport Dandy from 0x35717efbbce11c74\nimport Profile from 0x35717efbbce11c74\nimport FindLeaseMarketSale from 0x35717efbbce11c74\nimport FindLeaseMarketAuctionSoft from 0x35717efbbce11c74\n// import FindLeaseMarketAuctionEscrow from \"../contracts/FindLeaseMarketAuctionEscrow.cdc\"\nimport FindLeaseMarketDirectOfferSoft from 0x35717efbbce11c74\n// import FindLeaseMarketDirectOfferEscrow from \"../contracts/FindLeaseMarketDirectOfferEscrow.cdc\"\nimport FindLeaseMarket from 0x35717efbbce11c74\n\ntransaction(leaseName: String, ftAliasOrIdentifier:String, price:UFix64, auctionReservePrice: UFix64, auctionDuration: UFix64, auctionExtensionOnLateBid: UFix64, minimumBidIncrement: UFix64, auctionValidUntil: UFix64?) {\n    \n    let saleItems : \u0026FindLeaseMarketAuctionSoft.SaleItemCollection?\n    let pointer : FindLeaseMarket.AuthLeasePointer\n    let vaultType : Type\n    \n    prepare(account: AuthAccount) {\n\n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n        //SYNC with register\n        //Add exising FUSD or create a new one and add it\n        let name = account.address.toString()\n        let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n        if !fusdReceiver.check() {\n            let fusd \u003c- FUSD.createEmptyVault()\n            account.save(\u003c- fusd, to: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n        }\n\n        let usdcCap = account.getCapability\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e(FiatToken.VaultReceiverPubPath)\n        if !usdcCap.check() {\n                account.save( \u003c-FiatToken.createEmptyVault(), to: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e( FiatToken.VaultReceiverPubPath, target: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FiatToken.ResourceId}\u003e( FiatToken.VaultUUIDPubPath, target: FiatToken.VaultStoragePath)\n                account.link\u003c\u0026FiatToken.Vault{FungibleToken.Balance}\u003e( FiatToken.VaultBalancePubPath, target:FiatToken.VaultStoragePath)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let dandyCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        let dandyCapPrivate= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPrivatePath)\n        if !dandyCapPrivate.check() {\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        var created=false\n        var updated=false\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        if !profile.hasWallet(\"Flow\") {\n            let flowWallet=Profile.Wallet( name:\"Flow\", receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), tags: [\"flow\"])\n    \n            profile.addWallet(flowWallet)\n            updated=true\n        }\n        if !profile.hasWallet(\"FUSD\") {\n            profile.addWallet(Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), tags: [\"fusd\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if !profile.hasWallet(\"USDC\") {\n            profile.addWallet(Profile.Wallet( name:\"USDC\", receiver:usdcCap, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(FiatToken.VaultBalancePubPath), accept: Type\u003c@FiatToken.Vault\u003e(), tags: [\"usdc\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else if updated {\n            profile.emitUpdatedEvent()\n        }\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        let doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        let doeSalePublicPath=FindMarket.getPublicPath(doeSaleType, name: tenant.name)\n        let doeSaleStoragePath= FindMarket.getStoragePath(doeSaleType, name:tenant.name)\n        let doeSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n        if !doeSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n        }\n\n        let doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        let doeBidPublicPath=FindMarket.getPublicPath(doeBidType, name: tenant.name)\n        let doeBidStoragePath= FindMarket.getStoragePath(doeBidType, name:tenant.name)\n        let doeBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n        if !doeBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n        }\n\n        /// auctions that escrow ft\n        let aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        let aeSalePublicPath=FindMarket.getPublicPath(aeSaleType, name: tenant.name)\n        let aeSaleStoragePath= FindMarket.getStoragePath(aeSaleType, name:tenant.name)\n        let aeSaleCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n        if !aeSaleCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n        }\n\n        let dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\n        let dosSalePublicPath=FindMarket.getPublicPath(dosSaleType, name: tenant.name)\n        let dosSaleStoragePath= FindMarket.getStoragePath(dosSaleType, name:tenant.name)\n\n        let dosSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n        if !dosSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n        }\n\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n        if !dosBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n        }\n\n        let aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\n        let aeBidPublicPath=FindMarket.getPublicPath(aeBidType, name: tenant.name)\n        let aeBidStoragePath= FindMarket.getStoragePath(aeBidType, name:tenant.name)\n        let aeBidCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n        if !aeBidCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n        }\n\n     /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n        }\n\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n        if !asBidCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n        }\n\n        let leaseTenantCapability= FindMarket.getTenantCapability(FindMarket.getTenantAddress(\"findLease\")!)!\n\n        let leaseSaleItemType= Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()\n        let leasePublicPath=FindMarket.getPublicPath(leaseSaleItemType, name: \"findLease\")\n        let leaseStoragePath= FindMarket.getStoragePath(leaseSaleItemType, name:\"findLease\")\n        let leaseSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath) \n        if !leaseSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketSale.SaleItemCollection\u003e(\u003c- FindLeaseMarketSale.createEmptySaleItemCollection(leaseTenantCapability), to: leaseStoragePath)\n            account.link\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath, target: leaseStoragePath)\n        }\n\n        let leaseASSaleItemType= Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e()\n        let leaseASPublicPath=FindMarket.getPublicPath(leaseASSaleItemType, name: \"findLease\")\n        let leaseASStoragePath= FindMarket.getStoragePath(leaseASSaleItemType, name:\"findLease\")\n        let leaseASSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath) \n        if !leaseASSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseASStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath, target: leaseASStoragePath)\n        }\n\n\n        let leaseASBidType= Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e()\n        let leaseASBidPublicPath=FindMarket.getPublicPath(leaseASBidType, name: \"findLease\")\n        let leaseASBidStoragePath= FindMarket.getStoragePath(leaseASBidType, name: \"findLease\")\n        let leaseASBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath) \n        if !leaseASBidCap.check() {\n            account.save\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseASBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath, target: leaseASBidStoragePath)\n        }\n\n        // let leaseAESaleItemType= Type\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e()\n        // let leaseAEPublicPath=FindMarket.getPublicPath(leaseAESaleItemType, name: \"findLease\")\n        // let leaseAEStoragePath= FindMarket.getStoragePath(leaseAESaleItemType, name:\"findLease\")\n        // let leaseAESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath) \n        // if !leaseAESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseAEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath, target: leaseAEStoragePath)\n        // }\n\n        // let leaseAEBidType= Type\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e()\n        // let leaseAEBidPublicPath=FindMarket.getPublicPath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidStoragePath= FindMarket.getStoragePath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath) \n        // if !leaseAEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseAEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath, target: leaseAEBidStoragePath)\n        // }\n\n        let leaseDOSSaleItemType= Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e()\n        let leaseDOSPublicPath=FindMarket.getPublicPath(leaseDOSSaleItemType, name: \"findLease\")\n        let leaseDOSStoragePath= FindMarket.getStoragePath(leaseDOSSaleItemType, name:\"findLease\")\n        let leaseDOSSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath) \n        if !leaseDOSSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOSStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath, target: leaseDOSStoragePath)\n        }\n\n        let leaseDOSBidType= Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let leaseDOSBidPublicPath=FindMarket.getPublicPath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidStoragePath= FindMarket.getStoragePath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath) \n        if !leaseDOSBidCap.check() {\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOSBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath, target: leaseDOSBidStoragePath)\n        }\n\n        // let leaseDOESaleItemType= Type\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        // let leaseDOEPublicPath=FindMarket.getPublicPath(leaseDOESaleItemType, name: \"findLease\")\n        // let leaseDOEStoragePath= FindMarket.getStoragePath(leaseDOESaleItemType, name:\"findLease\")\n        // let leaseDOESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath) \n        // if !leaseDOESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath, target: leaseDOEStoragePath)\n        // }\n\n        // let leaseDOEBidType= Type\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        // let leaseDOEBidPublicPath=FindMarket.getPublicPath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidStoragePath= FindMarket.getStoragePath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath) \n        // if !leaseDOEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath, target: leaseDOEBidStoragePath)\n        // }\n        //SYNC with register\n\n        // Get supported NFT and FT Information from Registries from input alias\n        let ft = FTRegistry.getFTInfo(ftAliasOrIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftAliasOrIdentifier))\n        \n        let leaseTenant = leaseTenantCapability.borrow()!\n        self.saleItems= account.borrow\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(from: leaseTenant.getStoragePath(Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e()))\n        let ref = account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from: FIND.LeaseStoragePath)!\n        self.pointer= FindLeaseMarket.AuthLeasePointer(ref: ref, name: leaseName)\n        self.vaultType= ft.type\n\n    }\n\n    pre{\n        // Ben : panic on some unreasonable inputs in trxn \n        minimumBidIncrement \u003e 0.0 :\"Minimum bid increment should be larger than 0.\"\n        (auctionReservePrice - auctionReservePrice) % minimumBidIncrement == 0.0 : \"Acution ReservePrice should be in step of minimum bid increment.\" \n        auctionDuration \u003e 0.0 : \"Auction Duration should be greater than 0.\"\n        auctionExtensionOnLateBid \u003e 0.0 : \"Auction Duration should be greater than 0.\"\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        self.saleItems!.listForAuction(pointer: self.pointer, vaultType: self.vaultType, auctionStartPrice: price, auctionReservePrice: auctionReservePrice, auctionDuration: auctionDuration, auctionExtensionOnLateBid: auctionExtensionOnLateBid, minimumBidIncrement: minimumBidIncrement, auctionValidUntil: auctionValidUntil, saleItemExtraField: {})\n\n    }\n}",
               "spec": {
                  "order": [
                     "leaseName",
                     "ftAliasOrIdentifier",
                     "price",
                     "auctionReservePrice",
                     "auctionDuration",
                     "auctionExtensionOnLateBid",
                     "minimumBidIncrement",
                     "auctionValidUntil"
                  ],
                  "parameters": {
                     "auctionDuration": "UFix64",
                     "auctionExtensionOnLateBid": "UFix64",
                     "auctionReservePrice": "UFix64",
                     "auctionValidUntil": "UFix64?",
                     "ftAliasOrIdentifier": "String",
                     "leaseName": "String",
                     "minimumBidIncrement": "UFix64",
                     "price": "UFix64"
                  }
               }
            },
            "listLeaseForAuctionSoftDUC": {
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FindMarketSale from 0x35717efbbce11c74\nimport FindMarketAuctionEscrow from 0x35717efbbce11c74\nimport FindMarketAuctionSoft from 0x35717efbbce11c74\nimport FindMarketDirectOfferEscrow from 0x35717efbbce11c74\nimport FindMarketDirectOfferSoft from 0x35717efbbce11c74\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FindViews from 0x35717efbbce11c74\nimport FTRegistry from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FlowToken from 0x7e60df042a9c0868\nimport TokenForwarding from 0x51ea0e37c27a1f1a\nimport DapperUtilityCoin from 0x82ec283f88a62e65\nimport FIND from 0x35717efbbce11c74\nimport Dandy from 0x35717efbbce11c74\nimport Profile from 0x35717efbbce11c74\nimport FindLeaseMarketSale from 0x35717efbbce11c74\nimport FindLeaseMarketAuctionSoft from 0x35717efbbce11c74\n// import FindLeaseMarketAuctionEscrow from \"../contracts/FindLeaseMarketAuctionEscrow.cdc\"\nimport FindLeaseMarketDirectOfferSoft from 0x35717efbbce11c74\n// import FindLeaseMarketDirectOfferEscrow from \"../contracts/FindLeaseMarketDirectOfferEscrow.cdc\"\nimport FindLeaseMarket from 0x35717efbbce11c74\n\ntransaction(dapperAddress: Address, leaseName: String, price:UFix64, auctionReservePrice: UFix64, auctionDuration: UFix64, auctionExtensionOnLateBid: UFix64, minimumBidIncrement: UFix64, auctionValidUntil: UFix64?) {\n    \n    let saleItems : \u0026FindLeaseMarketAuctionSoft.SaleItemCollection?\n    let pointer : FindLeaseMarket.AuthLeasePointer\n    let vaultType : Type\n    \n    prepare(account: AuthAccount) {\n\n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n        //SYNC with register\n        //Add exising FUSD or create a new one and add it\n        let name = account.address.toString()\n        let ducReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver)\n        if !ducReceiver.check() {\n            let dapper = getAccount(dapperAddress)\n            // Create a new Forwarder resource for DUC and store it in the new account's storage\n            let ducForwarder \u003c- TokenForwarding.createNewForwarder(recipient: dapper.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver))\n            account.save(\u003c-ducForwarder, to: /storage/dapperUtilityCoinReceiver)\n            // Publish a Receiver capability for the new account, which is linked to the DUC Forwarder\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver,target: /storage/dapperUtilityCoinReceiver)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: ducReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let dandyCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        let dandyCapPrivate= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPrivatePath)\n        if !dandyCapPrivate.check() {\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        var created=false\n        var updated=false\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        if !profile.hasWallet(\"Flow\") {\n            let flowWallet=Profile.Wallet( name:\"Flow\", receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), tags: [\"flow\"])\n    \n            profile.addWallet(flowWallet)\n            updated=true\n        }\n        if !profile.hasWallet(\"DUC\") {\n            profile.addWallet(Profile.Wallet( name:\"DUC\", receiver:ducReceiver, balance:getAccount(dapperAddress).getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/dapperUtilityCoinBalance), accept: Type\u003c@DapperUtilityCoin.Vault\u003e(), tags: [\"duc\", \"dapperUtilityCoin\",\"dapper\"]))\n            updated=true\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else {\n            profile.emitUpdatedEvent()\n        }\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        let doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        let doeSalePublicPath=FindMarket.getPublicPath(doeSaleType, name: tenant.name)\n        let doeSaleStoragePath= FindMarket.getStoragePath(doeSaleType, name:tenant.name)\n        let doeSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n        if !doeSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n        }\n\n        let doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        let doeBidPublicPath=FindMarket.getPublicPath(doeBidType, name: tenant.name)\n        let doeBidStoragePath= FindMarket.getStoragePath(doeBidType, name:tenant.name)\n        let doeBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n        if !doeBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n        }\n\n        /// auctions that escrow ft\n        let aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        let aeSalePublicPath=FindMarket.getPublicPath(aeSaleType, name: tenant.name)\n        let aeSaleStoragePath= FindMarket.getStoragePath(aeSaleType, name:tenant.name)\n        let aeSaleCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n        if !aeSaleCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n        }\n\n        let dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\n        let dosSalePublicPath=FindMarket.getPublicPath(dosSaleType, name: tenant.name)\n        let dosSaleStoragePath= FindMarket.getStoragePath(dosSaleType, name:tenant.name)\n\n        let dosSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n        if !dosSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n        }\n\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n        if !dosBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n        }\n\n        let aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\n        let aeBidPublicPath=FindMarket.getPublicPath(aeBidType, name: tenant.name)\n        let aeBidStoragePath= FindMarket.getStoragePath(aeBidType, name:tenant.name)\n        let aeBidCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n        if !aeBidCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n        }\n\n     /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n        }\n\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n        if !asBidCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n        }\n\n        let leaseTenantCapability= FindMarket.getTenantCapability(FindMarket.getTenantAddress(\"findLease\")!)!\n\n        let leaseSaleItemType= Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()\n        let leasePublicPath=FindMarket.getPublicPath(leaseSaleItemType, name: \"findLease\")\n        let leaseStoragePath= FindMarket.getStoragePath(leaseSaleItemType, name:\"findLease\")\n        let leaseSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath) \n        if !leaseSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketSale.SaleItemCollection\u003e(\u003c- FindLeaseMarketSale.createEmptySaleItemCollection(leaseTenantCapability), to: leaseStoragePath)\n            account.link\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath, target: leaseStoragePath)\n        }\n\n        let leaseASSaleItemType= Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e()\n        let leaseASPublicPath=FindMarket.getPublicPath(leaseASSaleItemType, name: \"findLease\")\n        let leaseASStoragePath= FindMarket.getStoragePath(leaseASSaleItemType, name:\"findLease\")\n        let leaseASSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath) \n        if !leaseASSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseASStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath, target: leaseASStoragePath)\n        }\n\n\n        let leaseASBidType= Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e()\n        let leaseASBidPublicPath=FindMarket.getPublicPath(leaseASBidType, name: \"findLease\")\n        let leaseASBidStoragePath= FindMarket.getStoragePath(leaseASBidType, name: \"findLease\")\n        let leaseASBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath) \n        if !leaseASBidCap.check() {\n            account.save\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseASBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath, target: leaseASBidStoragePath)\n        }\n\n        // let leaseAESaleItemType= Type\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e()\n        // let leaseAEPublicPath=FindMarket.getPublicPath(leaseAESaleItemType, name: \"findLease\")\n        // let leaseAEStoragePath= FindMarket.getStoragePath(leaseAESaleItemType, name:\"findLease\")\n        // let leaseAESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath) \n        // if !leaseAESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseAEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath, target: leaseAEStoragePath)\n        // }\n\n        // let leaseAEBidType= Type\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e()\n        // let leaseAEBidPublicPath=FindMarket.getPublicPath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidStoragePath= FindMarket.getStoragePath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath) \n        // if !leaseAEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseAEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath, target: leaseAEBidStoragePath)\n        // }\n\n        let leaseDOSSaleItemType= Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e()\n        let leaseDOSPublicPath=FindMarket.getPublicPath(leaseDOSSaleItemType, name: \"findLease\")\n        let leaseDOSStoragePath= FindMarket.getStoragePath(leaseDOSSaleItemType, name:\"findLease\")\n        let leaseDOSSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath) \n        if !leaseDOSSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOSStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath, target: leaseDOSStoragePath)\n        }\n\n        let leaseDOSBidType= Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let leaseDOSBidPublicPath=FindMarket.getPublicPath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidStoragePath= FindMarket.getStoragePath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath) \n        if !leaseDOSBidCap.check() {\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOSBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath, target: leaseDOSBidStoragePath)\n        }\n\n        // let leaseDOESaleItemType= Type\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        // let leaseDOEPublicPath=FindMarket.getPublicPath(leaseDOESaleItemType, name: \"findLease\")\n        // let leaseDOEStoragePath= FindMarket.getStoragePath(leaseDOESaleItemType, name:\"findLease\")\n        // let leaseDOESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath) \n        // if !leaseDOESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath, target: leaseDOEStoragePath)\n        // }\n\n        // let leaseDOEBidType= Type\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        // let leaseDOEBidPublicPath=FindMarket.getPublicPath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidStoragePath= FindMarket.getStoragePath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath) \n        // if !leaseDOEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath, target: leaseDOEBidStoragePath)\n        // }\n        //SYNC with register\n\n        // Get supported NFT and FT Information from Registries from input alias\n        let ft = FTRegistry.getFTInfo(Type\u003c@DapperUtilityCoin.Vault\u003e().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(Type\u003c@DapperUtilityCoin.Vault\u003e().identifier))\n        \n        let leaseTenant = leaseTenantCapability.borrow()!\n        self.saleItems= account.borrow\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(from: leaseTenant.getStoragePath(Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e()))\n        let ref= account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from: FIND.LeaseStoragePath)!\n        self.pointer= FindLeaseMarket.AuthLeasePointer(ref: ref, name: leaseName)    \n        self.vaultType= ft.type    \n    }\n\n    pre{\n        // Ben : panic on some unreasonable inputs in trxn \n        minimumBidIncrement \u003e 0.0 :\"Minimum bid increment should be larger than 0.\"\n        (auctionReservePrice - auctionReservePrice) % minimumBidIncrement == 0.0 : \"Acution ReservePrice should be in step of minimum bid increment.\" \n        auctionDuration \u003e 0.0 : \"Auction Duration should be greater than 0.\"\n        auctionExtensionOnLateBid \u003e 0.0 : \"Auction Duration should be greater than 0.\"\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        self.saleItems!.listForAuction(pointer: self.pointer, vaultType: self.vaultType, auctionStartPrice: price, auctionReservePrice: auctionReservePrice, auctionDuration: auctionDuration, auctionExtensionOnLateBid: auctionExtensionOnLateBid, minimumBidIncrement: minimumBidIncrement, auctionValidUntil: auctionValidUntil, saleItemExtraField: {})\n\n    }\n}",
               "spec": {
                  "order": [
                     "dapperAddress",
                     "leaseName",
                     "price",
                     "auctionReservePrice",
                     "auctionDuration",
                     "auctionExtensionOnLateBid",
                     "minimumBidIncrement",
                     "auctionValidUntil"
                  ],
                  "parameters": {
                     "auctionDuration": "UFix64",
                     "auctionExtensionOnLateBid": "UFix64",
                     "auctionReservePrice": "UFix64",
                     "auctionValidUntil": "UFix64?",
                     "dapperAddress": "Address",
                     "leaseName": "String",
                     "minimumBidIncrement": "UFix64",
                     "price": "UFix64"
                  }
               }
            },
            "listLeaseForSale": {
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FindMarketSale from 0x35717efbbce11c74\nimport FindMarketAuctionEscrow from 0x35717efbbce11c74\nimport FindMarketAuctionSoft from 0x35717efbbce11c74\nimport FindMarketDirectOfferEscrow from 0x35717efbbce11c74\nimport FindMarketDirectOfferSoft from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FUSD from 0xe223d8a629e49c68\nimport FlowToken from 0x7e60df042a9c0868\nimport FiatToken from 0xa983fecbed621163\nimport FIND from 0x35717efbbce11c74\nimport Dandy from 0x35717efbbce11c74\nimport Profile from 0x35717efbbce11c74\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FindViews from 0x35717efbbce11c74\nimport FTRegistry from 0x35717efbbce11c74\nimport FindLeaseMarketSale from 0x35717efbbce11c74\nimport FindLeaseMarketAuctionSoft from 0x35717efbbce11c74\n// import FindLeaseMarketAuctionEscrow from \"../contracts/FindLeaseMarketAuctionEscrow.cdc\"\nimport FindLeaseMarketDirectOfferSoft from 0x35717efbbce11c74\n// import FindLeaseMarketDirectOfferEscrow from \"../contracts/FindLeaseMarketDirectOfferEscrow.cdc\"\nimport FindLeaseMarket from 0x35717efbbce11c74\n\ntransaction(leaseName: String, ftAliasOrIdentifier: String, directSellPrice:UFix64, validUntil: UFix64?) {\n\n    let saleItems : \u0026FindLeaseMarketSale.SaleItemCollection?\n    let pointer : FindLeaseMarket.AuthLeasePointer\n    let vaultType : Type\n\n    prepare(account: AuthAccount) {\n\n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n        //SYNC with register\n        //Add exising FUSD or create a new one and add it\n        let name = account.address.toString()\n        let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n        if !fusdReceiver.check() {\n            let fusd \u003c- FUSD.createEmptyVault()\n            account.save(\u003c- fusd, to: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n        }\n\n        let usdcCap = account.getCapability\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e(FiatToken.VaultReceiverPubPath)\n        if !usdcCap.check() {\n                account.save( \u003c-FiatToken.createEmptyVault(), to: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e( FiatToken.VaultReceiverPubPath, target: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FiatToken.ResourceId}\u003e( FiatToken.VaultUUIDPubPath, target: FiatToken.VaultStoragePath)\n                account.link\u003c\u0026FiatToken.Vault{FungibleToken.Balance}\u003e( FiatToken.VaultBalancePubPath, target:FiatToken.VaultStoragePath)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let dandyCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        let dandyCapPrivate= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPrivatePath)\n        if !dandyCapPrivate.check() {\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        var created=false\n        var updated=false\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        if !profile.hasWallet(\"Flow\") {\n            let flowWallet=Profile.Wallet( name:\"Flow\", receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), tags: [\"flow\"])\n    \n            profile.addWallet(flowWallet)\n            updated=true\n        }\n        if !profile.hasWallet(\"FUSD\") {\n            profile.addWallet(Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), tags: [\"fusd\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if !profile.hasWallet(\"USDC\") {\n            profile.addWallet(Profile.Wallet( name:\"USDC\", receiver:usdcCap, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(FiatToken.VaultBalancePubPath), accept: Type\u003c@FiatToken.Vault\u003e(), tags: [\"usdc\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else if updated {\n            profile.emitUpdatedEvent()\n        }\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let market = FindMarket.getFindTenantAddress()\n        let tenantCapability= FindMarket.getTenantCapability(market)!\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        let doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        let doeSalePublicPath=FindMarket.getPublicPath(doeSaleType, name: tenant.name)\n        let doeSaleStoragePath= FindMarket.getStoragePath(doeSaleType, name:tenant.name)\n        let doeSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n        if !doeSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n        }\n\n        let doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        let doeBidPublicPath=FindMarket.getPublicPath(doeBidType, name: tenant.name)\n        let doeBidStoragePath= FindMarket.getStoragePath(doeBidType, name:tenant.name)\n        let doeBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n        if !doeBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n        }\n\n        /// auctions that escrow ft\n        let aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        let aeSalePublicPath=FindMarket.getPublicPath(aeSaleType, name: tenant.name)\n        let aeSaleStoragePath= FindMarket.getStoragePath(aeSaleType, name:tenant.name)\n        let aeSaleCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n        if !aeSaleCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n        }\n\n        let dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\n        let dosSalePublicPath=FindMarket.getPublicPath(dosSaleType, name: tenant.name)\n        let dosSaleStoragePath= FindMarket.getStoragePath(dosSaleType, name:tenant.name)\n\n        let dosSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n        if !dosSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n        }\n\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n        if !dosBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n        }\n\n        let aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\n        let aeBidPublicPath=FindMarket.getPublicPath(aeBidType, name: tenant.name)\n        let aeBidStoragePath= FindMarket.getStoragePath(aeBidType, name:tenant.name)\n        let aeBidCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n        if !aeBidCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n        }\n\n     /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n        }\n\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n        if !asBidCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n        }\n\n        let leaseTenantCapability= FindMarket.getTenantCapability(FindMarket.getTenantAddress(\"findLease\")!)!\n\n        let leaseSaleItemType= Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()\n        let leasePublicPath=FindMarket.getPublicPath(leaseSaleItemType, name: \"findLease\")\n        let leaseStoragePath= FindMarket.getStoragePath(leaseSaleItemType, name:\"findLease\")\n        let leaseSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath) \n        if !leaseSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketSale.SaleItemCollection\u003e(\u003c- FindLeaseMarketSale.createEmptySaleItemCollection(leaseTenantCapability), to: leaseStoragePath)\n            account.link\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath, target: leaseStoragePath)\n        }\n\n        let leaseASSaleItemType= Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e()\n        let leaseASPublicPath=FindMarket.getPublicPath(leaseASSaleItemType, name: \"findLease\")\n        let leaseASStoragePath= FindMarket.getStoragePath(leaseASSaleItemType, name:\"findLease\")\n        let leaseASSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath) \n        if !leaseASSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseASStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath, target: leaseASStoragePath)\n        }\n\n\n        let leaseASBidType= Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e()\n        let leaseASBidPublicPath=FindMarket.getPublicPath(leaseASBidType, name: \"findLease\")\n        let leaseASBidStoragePath= FindMarket.getStoragePath(leaseASBidType, name: \"findLease\")\n        let leaseASBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath) \n        if !leaseASBidCap.check() {\n            account.save\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseASBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath, target: leaseASBidStoragePath)\n        }\n\n        // let leaseAESaleItemType= Type\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e()\n        // let leaseAEPublicPath=FindMarket.getPublicPath(leaseAESaleItemType, name: \"findLease\")\n        // let leaseAEStoragePath= FindMarket.getStoragePath(leaseAESaleItemType, name:\"findLease\")\n        // let leaseAESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath) \n        // if !leaseAESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseAEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath, target: leaseAEStoragePath)\n        // }\n\n        // let leaseAEBidType= Type\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e()\n        // let leaseAEBidPublicPath=FindMarket.getPublicPath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidStoragePath= FindMarket.getStoragePath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath) \n        // if !leaseAEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseAEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath, target: leaseAEBidStoragePath)\n        // }\n\n        let leaseDOSSaleItemType= Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e()\n        let leaseDOSPublicPath=FindMarket.getPublicPath(leaseDOSSaleItemType, name: \"findLease\")\n        let leaseDOSStoragePath= FindMarket.getStoragePath(leaseDOSSaleItemType, name:\"findLease\")\n        let leaseDOSSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath) \n        if !leaseDOSSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOSStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath, target: leaseDOSStoragePath)\n        }\n\n        let leaseDOSBidType= Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let leaseDOSBidPublicPath=FindMarket.getPublicPath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidStoragePath= FindMarket.getStoragePath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath) \n        if !leaseDOSBidCap.check() {\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOSBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath, target: leaseDOSBidStoragePath)\n        }\n\n        // let leaseDOESaleItemType= Type\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        // let leaseDOEPublicPath=FindMarket.getPublicPath(leaseDOESaleItemType, name: \"findLease\")\n        // let leaseDOEStoragePath= FindMarket.getStoragePath(leaseDOESaleItemType, name:\"findLease\")\n        // let leaseDOESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath) \n        // if !leaseDOESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath, target: leaseDOEStoragePath)\n        // }\n\n        // let leaseDOEBidType= Type\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        // let leaseDOEBidPublicPath=FindMarket.getPublicPath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidStoragePath= FindMarket.getStoragePath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath) \n        // if !leaseDOEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath, target: leaseDOEBidStoragePath)\n        // }\n        //SYNC with register\n\n        // Get the salesItemRef from tenant\n        let leaseTenant = leaseTenantCapability.borrow()!\n        self.saleItems= account.borrow\u003c\u0026FindLeaseMarketSale.SaleItemCollection\u003e(from: leaseTenant.getStoragePath(Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()))!\n\n        // Get supported NFT and FT Information from Registries from input alias\n        let ft = FTRegistry.getFTInfo(ftAliasOrIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftAliasOrIdentifier))\n        self.vaultType= ft.type\n\n        let lease=account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from: FIND.LeaseStoragePath)!\n\n\n        self.pointer= FindLeaseMarket.AuthLeasePointer(ref:lease, name: leaseName)\n\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        self.saleItems!.listForSale(pointer: self.pointer, vaultType: self.vaultType, directSellPrice: directSellPrice, validUntil: validUntil, extraField: {})\n    }\n}",
               "spec": {
                  "order": [
                     "leaseName",
                     "ftAliasOrIdentifier",
                     "directSellPrice",
                     "validUntil"
                  ],
                  "parameters": {
                     "directSellPrice": "UFix64",
                     "ftAliasOrIdentifier": "String",
                     "leaseName": "String",
                     "validUntil": "UFix64?"
                  }
               }
            },
            "listLeaseForSaleDUC": {
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FindMarketSale from 0x35717efbbce11c74\nimport FindMarketAuctionEscrow from 0x35717efbbce11c74\nimport FindMarketAuctionSoft from 0x35717efbbce11c74\nimport FindMarketDirectOfferEscrow from 0x35717efbbce11c74\nimport FindMarketDirectOfferSoft from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport DapperUtilityCoin from 0x82ec283f88a62e65\nimport TokenForwarding from 0x51ea0e37c27a1f1a\nimport FlowToken from 0x7e60df042a9c0868\nimport FIND from 0x35717efbbce11c74\nimport Dandy from 0x35717efbbce11c74\nimport Profile from 0x35717efbbce11c74\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FindViews from 0x35717efbbce11c74\nimport FTRegistry from 0x35717efbbce11c74\nimport FindLeaseMarketSale from 0x35717efbbce11c74\nimport FindLeaseMarketAuctionSoft from 0x35717efbbce11c74\n// import FindLeaseMarketAuctionEscrow from \"../contracts/FindLeaseMarketAuctionEscrow.cdc\"\nimport FindLeaseMarketDirectOfferSoft from 0x35717efbbce11c74\n// import FindLeaseMarketDirectOfferEscrow from \"../contracts/FindLeaseMarketDirectOfferEscrow.cdc\"\nimport FindLeaseMarket from 0x35717efbbce11c74\n\ntransaction(dapperAddress: Address, leaseName: String, directSellPrice:UFix64, validUntil: UFix64?) {\n\n    let saleItems : \u0026FindLeaseMarketSale.SaleItemCollection?\n    let pointer : FindLeaseMarket.AuthLeasePointer\n    let vaultType : Type\n\n    prepare(account: AuthAccount) {\n\n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n        //SYNC with register\n        //Add exising FUSD or create a new one and add it\n        let name = account.address.toString()\n        let ducReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver)\n        if !ducReceiver.check() {\n            let dapper = getAccount(dapperAddress)\n            // Create a new Forwarder resource for DUC and store it in the new account's storage\n            let ducForwarder \u003c- TokenForwarding.createNewForwarder(recipient: dapper.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver))\n            account.save(\u003c-ducForwarder, to: /storage/dapperUtilityCoinReceiver)\n            // Publish a Receiver capability for the new account, which is linked to the DUC Forwarder\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver,target: /storage/dapperUtilityCoinReceiver)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: ducReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let dandyCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        let dandyCapPrivate= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPrivatePath)\n        if !dandyCapPrivate.check() {\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        var created=false\n        var updated=false\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        if !profile.hasWallet(\"Flow\") {\n            let flowWallet=Profile.Wallet( name:\"Flow\", receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), tags: [\"flow\"])\n    \n            profile.addWallet(flowWallet)\n            updated=true\n        }\n        if !profile.hasWallet(\"DUC\") {\n            profile.addWallet(Profile.Wallet( name:\"DUC\", receiver:ducReceiver, balance:getAccount(dapperAddress).getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/dapperUtilityCoinBalance), accept: Type\u003c@DapperUtilityCoin.Vault\u003e(), tags: [\"duc\", \"dapperUtilityCoin\",\"dapper\"]))\n            updated=true\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else {\n            profile.emitUpdatedEvent()\n        }\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        let doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        let doeSalePublicPath=FindMarket.getPublicPath(doeSaleType, name: tenant.name)\n        let doeSaleStoragePath= FindMarket.getStoragePath(doeSaleType, name:tenant.name)\n        let doeSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n        if !doeSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n        }\n\n        let doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        let doeBidPublicPath=FindMarket.getPublicPath(doeBidType, name: tenant.name)\n        let doeBidStoragePath= FindMarket.getStoragePath(doeBidType, name:tenant.name)\n        let doeBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n        if !doeBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n        }\n\n        /// auctions that escrow ft\n        let aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        let aeSalePublicPath=FindMarket.getPublicPath(aeSaleType, name: tenant.name)\n        let aeSaleStoragePath= FindMarket.getStoragePath(aeSaleType, name:tenant.name)\n        let aeSaleCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n        if !aeSaleCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n        }\n\n        let dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\n        let dosSalePublicPath=FindMarket.getPublicPath(dosSaleType, name: tenant.name)\n        let dosSaleStoragePath= FindMarket.getStoragePath(dosSaleType, name:tenant.name)\n\n        let dosSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n        if !dosSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n        }\n\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n        if !dosBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n        }\n\n        let aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\n        let aeBidPublicPath=FindMarket.getPublicPath(aeBidType, name: tenant.name)\n        let aeBidStoragePath= FindMarket.getStoragePath(aeBidType, name:tenant.name)\n        let aeBidCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n        if !aeBidCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n        }\n\n     /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n        }\n\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n        if !asBidCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n        }\n\n        let leaseTenantCapability= FindMarket.getTenantCapability(FindMarket.getTenantAddress(\"findLease\")!)!\n\n        let leaseSaleItemType= Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()\n        let leasePublicPath=FindMarket.getPublicPath(leaseSaleItemType, name: \"findLease\")\n        let leaseStoragePath= FindMarket.getStoragePath(leaseSaleItemType, name:\"findLease\")\n        let leaseSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath) \n        if !leaseSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketSale.SaleItemCollection\u003e(\u003c- FindLeaseMarketSale.createEmptySaleItemCollection(leaseTenantCapability), to: leaseStoragePath)\n            account.link\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath, target: leaseStoragePath)\n        }\n\n        let leaseASSaleItemType= Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e()\n        let leaseASPublicPath=FindMarket.getPublicPath(leaseASSaleItemType, name: \"findLease\")\n        let leaseASStoragePath= FindMarket.getStoragePath(leaseASSaleItemType, name:\"findLease\")\n        let leaseASSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath) \n        if !leaseASSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseASStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath, target: leaseASStoragePath)\n        }\n\n\n        let leaseASBidType= Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e()\n        let leaseASBidPublicPath=FindMarket.getPublicPath(leaseASBidType, name: \"findLease\")\n        let leaseASBidStoragePath= FindMarket.getStoragePath(leaseASBidType, name: \"findLease\")\n        let leaseASBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath) \n        if !leaseASBidCap.check() {\n            account.save\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseASBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath, target: leaseASBidStoragePath)\n        }\n\n        // let leaseAESaleItemType= Type\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e()\n        // let leaseAEPublicPath=FindMarket.getPublicPath(leaseAESaleItemType, name: \"findLease\")\n        // let leaseAEStoragePath= FindMarket.getStoragePath(leaseAESaleItemType, name:\"findLease\")\n        // let leaseAESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath) \n        // if !leaseAESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseAEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath, target: leaseAEStoragePath)\n        // }\n\n        // let leaseAEBidType= Type\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e()\n        // let leaseAEBidPublicPath=FindMarket.getPublicPath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidStoragePath= FindMarket.getStoragePath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath) \n        // if !leaseAEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseAEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath, target: leaseAEBidStoragePath)\n        // }\n\n        let leaseDOSSaleItemType= Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e()\n        let leaseDOSPublicPath=FindMarket.getPublicPath(leaseDOSSaleItemType, name: \"findLease\")\n        let leaseDOSStoragePath= FindMarket.getStoragePath(leaseDOSSaleItemType, name:\"findLease\")\n        let leaseDOSSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath) \n        if !leaseDOSSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOSStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath, target: leaseDOSStoragePath)\n        }\n\n        let leaseDOSBidType= Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let leaseDOSBidPublicPath=FindMarket.getPublicPath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidStoragePath= FindMarket.getStoragePath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath) \n        if !leaseDOSBidCap.check() {\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOSBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath, target: leaseDOSBidStoragePath)\n        }\n\n        // let leaseDOESaleItemType= Type\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        // let leaseDOEPublicPath=FindMarket.getPublicPath(leaseDOESaleItemType, name: \"findLease\")\n        // let leaseDOEStoragePath= FindMarket.getStoragePath(leaseDOESaleItemType, name:\"findLease\")\n        // let leaseDOESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath) \n        // if !leaseDOESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath, target: leaseDOEStoragePath)\n        // }\n\n        // let leaseDOEBidType= Type\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        // let leaseDOEBidPublicPath=FindMarket.getPublicPath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidStoragePath= FindMarket.getStoragePath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath) \n        // if !leaseDOEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath, target: leaseDOEBidStoragePath)\n        // }\n        //SYNC with register\n\n        // Get the salesItemRef from tenant\n        let leaseTenant = leaseTenantCapability.borrow()!\n        self.saleItems= account.borrow\u003c\u0026FindLeaseMarketSale.SaleItemCollection\u003e(from: leaseTenant.getStoragePath(Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()))\n\n        // Get supported NFT and FT Information from Registries from input alias\n        let ft = FTRegistry.getFTInfo(Type\u003c@DapperUtilityCoin.Vault\u003e().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(Type\u003c@DapperUtilityCoin.Vault\u003e().identifier))\n        self.vaultType= ft.type\n\n        let ref=account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from: FIND.LeaseStoragePath)!\n\n        self.pointer= FindLeaseMarket.AuthLeasePointer(ref: ref, name: leaseName)\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        self.saleItems!.listForSale(pointer: self.pointer, vaultType: self.vaultType, directSellPrice: directSellPrice, validUntil: validUntil, extraField: {})\n\n    }\n\n}",
               "spec": {
                  "order": [
                     "dapperAddress",
                     "leaseName",
                     "directSellPrice",
                     "validUntil"
                  ],
                  "parameters": {
                     "dapperAddress": "Address",
                     "directSellPrice": "UFix64",
                     "leaseName": "String",
                     "validUntil": "UFix64?"
                  }
               }
            },
            "listMultipleNFTForSale": {
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FindMarketSale from 0x35717efbbce11c74\nimport FindMarketAuctionEscrow from 0x35717efbbce11c74\nimport FindMarketAuctionSoft from 0x35717efbbce11c74\nimport FindMarketDirectOfferEscrow from 0x35717efbbce11c74\nimport FindMarketDirectOfferSoft from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FUSD from 0xe223d8a629e49c68\nimport FlowToken from 0x7e60df042a9c0868\nimport FiatToken from 0xa983fecbed621163\nimport FIND from 0x35717efbbce11c74\nimport Dandy from 0x35717efbbce11c74\nimport Profile from 0x35717efbbce11c74\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FindViews from 0x35717efbbce11c74\nimport NFTCatalog from 0x324c34e1c517e4db\nimport FINDNFTCatalog from 0x35717efbbce11c74\nimport FTRegistry from 0x35717efbbce11c74\n\ntransaction(marketplace:Address, nftAliasOrIdentifiers: [String], ids: [UInt64], ftAliasOrIdentifiers: [String], directSellPrices:[UFix64], validUntil: UFix64?) {\n    \n    let saleItems : \u0026FindMarketSale.SaleItemCollection?\n    let pointers : [FindViews.AuthNFTPointer]\n    let vaultTypes : [Type]\n\n    prepare(account: AuthAccount) {\n\n        if nftAliasOrIdentifiers.length != ids.length {\n            panic(\"The length of arrays passed in has to be the same\")\n        } else if nftAliasOrIdentifiers.length != ftAliasOrIdentifiers.length {\n            panic(\"The length of arrays passed in has to be the same\")\n        } else if nftAliasOrIdentifiers.length != directSellPrices.length {\n            panic(\"The length of arrays passed in has to be the same\")\n        }\n\n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n        //SYNC with register\n        //Add exising FUSD or create a new one and add it\n        let name = account.address.toString()\n        let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n        if !fusdReceiver.check() {\n            let fusd \u003c- FUSD.createEmptyVault()\n            account.save(\u003c- fusd, to: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n        }\n\n        let usdcCap = account.getCapability\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e(FiatToken.VaultReceiverPubPath)\n        if !usdcCap.check() {\n                account.save( \u003c-FiatToken.createEmptyVault(), to: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e( FiatToken.VaultReceiverPubPath, target: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FiatToken.ResourceId}\u003e( FiatToken.VaultUUIDPubPath, target: FiatToken.VaultStoragePath)\n                account.link\u003c\u0026FiatToken.Vault{FungibleToken.Balance}\u003e( FiatToken.VaultBalancePubPath, target:FiatToken.VaultStoragePath)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let dandyCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        let dandyCapPrivate= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPrivatePath)\n        if !dandyCapPrivate.check() {\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        var created=false\n        var updated=false\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        if !profile.hasWallet(\"Flow\") {\n            let flowWallet=Profile.Wallet( name:\"Flow\", receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), tags: [\"flow\"])\n    \n            profile.addWallet(flowWallet)\n            updated=true\n        }\n        if !profile.hasWallet(\"FUSD\") {\n            profile.addWallet(Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), tags: [\"fusd\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if !profile.hasWallet(\"USDC\") {\n            profile.addWallet(Profile.Wallet( name:\"USDC\", receiver:usdcCap, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(FiatToken.VaultBalancePubPath), accept: Type\u003c@FiatToken.Vault\u003e(), tags: [\"usdc\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else if updated {\n            profile.emitUpdatedEvent()\n        }\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        let doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        let doeSalePublicPath=FindMarket.getPublicPath(doeSaleType, name: tenant.name)\n        let doeSaleStoragePath= FindMarket.getStoragePath(doeSaleType, name:tenant.name)\n        let doeSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n        if !doeSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n        }\n\n        let doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        let doeBidPublicPath=FindMarket.getPublicPath(doeBidType, name: tenant.name)\n        let doeBidStoragePath= FindMarket.getStoragePath(doeBidType, name:tenant.name)\n        let doeBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n        if !doeBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n        }\n\n        /// auctions that escrow ft\n        let aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        let aeSalePublicPath=FindMarket.getPublicPath(aeSaleType, name: tenant.name)\n        let aeSaleStoragePath= FindMarket.getStoragePath(aeSaleType, name:tenant.name)\n        let aeSaleCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n        if !aeSaleCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n        }\n\n        let dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\n        let dosSalePublicPath=FindMarket.getPublicPath(dosSaleType, name: tenant.name)\n        let dosSaleStoragePath= FindMarket.getStoragePath(dosSaleType, name:tenant.name)\n\n        let dosSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n        if !dosSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n        }\n\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n        if !dosBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n        }\n\n        let aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\n        let aeBidPublicPath=FindMarket.getPublicPath(aeBidType, name: tenant.name)\n        let aeBidStoragePath= FindMarket.getStoragePath(aeBidType, name:tenant.name)\n        let aeBidCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n        if !aeBidCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n        }\n\n     /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n        }\n\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n        if !asBidCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n        }\n        //SYNC with register\n\n        self.saleItems= account.borrow\u003c\u0026FindMarketSale.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketSale.SaleItemCollection\u003e()))\n        self.vaultTypes= []\n        self.pointers= []\n\n        var counter = 0\n\n        let nfts : {String : NFTCatalog.NFTCollectionData} = {}\n        let fts : {String : FTRegistry.FTInfo} = {}\n\n        while counter \u003c ids.length {\n            // Get supported NFT and FT Information from Registries from input alias\n            var nft : NFTCatalog.NFTCollectionData? = nil\n            var ft : FTRegistry.FTInfo? = nil\n\n            if nfts[nftAliasOrIdentifiers[counter]] != nil {\n                nft = nfts[nftAliasOrIdentifiers[counter]]\n            } else {\n                let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftAliasOrIdentifiers[counter])?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftAliasOrIdentifiers[counter])) \n                let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n                nft = collection.collectionData\n                nfts[nftAliasOrIdentifiers[counter]] = nft\n            }\n\n            if fts[ftAliasOrIdentifiers[counter]] != nil {\n                ft = fts[ftAliasOrIdentifiers[counter]]\n            } else {\n                ft = FTRegistry.getFTInfo(ftAliasOrIdentifiers[counter]) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftAliasOrIdentifiers[counter]))\n                fts[ftAliasOrIdentifiers[counter]] = ft \n            }\n\n            var providerCap=account.getCapability\u003c\u0026{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e(nft!.privatePath)\n\n            /* Ben : Question -\u003e Either client will have to provide the path here or agree that we set it up for the user */\n            if !providerCap.check() {\n                let newCap = account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                        nft!.privatePath,\n                        target: nft!.storagePath\n                )\n                if newCap == nil {\n                    // If linking is not successful, we link it using finds custom link \n                    let pathIdentifier = nft!.privatePath.toString()\n                    let findPath = PrivatePath(identifier: pathIdentifier.slice(from: \"/private/\".length , upTo: pathIdentifier.length).concat(\"_FIND\"))!\n                    account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                        findPath,\n                        target: nft!.storagePath\n                    )\n                    providerCap = account.getCapability\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(findPath)\n                }\n            }\n            // Get the salesItemRef from tenant\n            self.pointers.append(FindViews.AuthNFTPointer(cap: providerCap, id: ids[counter]))\n            self.vaultTypes.append(ft!.type)\n            counter = counter + 1\n        }\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        var counter = 0\n        while counter \u003c ids.length {\n            self.saleItems!.listForSale(pointer: self.pointers[counter], vaultType: self.vaultTypes[counter], directSellPrice: directSellPrices[counter], validUntil: validUntil, extraField: {})\n            counter = counter + 1\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "nftAliasOrIdentifiers",
                     "ids",
                     "ftAliasOrIdentifiers",
                     "directSellPrices",
                     "validUntil"
                  ],
                  "parameters": {
                     "directSellPrices": "[UFix64]",
                     "ftAliasOrIdentifiers": "[String]",
                     "ids": "[UInt64]",
                     "marketplace": "Address",
                     "nftAliasOrIdentifiers": "[String]",
                     "validUntil": "UFix64?"
                  }
               }
            },
            "listMultipleNFTForSaleDUC": {
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FindMarketSale from 0x35717efbbce11c74\nimport FindMarketAuctionEscrow from 0x35717efbbce11c74\nimport FindMarketAuctionSoft from 0x35717efbbce11c74\nimport FindMarketDirectOfferEscrow from 0x35717efbbce11c74\nimport FindMarketDirectOfferSoft from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport DapperUtilityCoin from 0x82ec283f88a62e65\nimport TokenForwarding from 0x51ea0e37c27a1f1a\nimport FlowToken from 0x7e60df042a9c0868\nimport FIND from 0x35717efbbce11c74\nimport Dandy from 0x35717efbbce11c74\nimport Profile from 0x35717efbbce11c74\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FindViews from 0x35717efbbce11c74\nimport NFTCatalog from 0x324c34e1c517e4db\nimport FINDNFTCatalog from 0x35717efbbce11c74\nimport FTRegistry from 0x35717efbbce11c74\n\ntransaction(dapperAddress: Address, marketplace:Address, nftAliasOrIdentifiers: [String], ids: [UInt64], directSellPrices:[UFix64], validUntil: UFix64?) {\n    \n    let saleItems : \u0026FindMarketSale.SaleItemCollection?\n    let pointers : [FindViews.AuthNFTPointer]\n    \n    prepare(account: AuthAccount) {\n\n        if nftAliasOrIdentifiers.length != ids.length {\n            panic(\"The length of arrays passed in has to be the same\")\n        } else if nftAliasOrIdentifiers.length != directSellPrices.length {\n            panic(\"The length of arrays passed in has to be the same\")\n        }\n\n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n        //SYNC with register\n        //Add exising FUSD or create a new one and add it\n        let name = account.address.toString()\n        let ducReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver)\n        if !ducReceiver.check() {\n            let dapper = getAccount(dapperAddress)\n            // Create a new Forwarder resource for DUC and store it in the new account's storage\n            let ducForwarder \u003c- TokenForwarding.createNewForwarder(recipient: dapper.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver))\n            account.save(\u003c-ducForwarder, to: /storage/dapperUtilityCoinReceiver)\n            // Publish a Receiver capability for the new account, which is linked to the DUC Forwarder\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver,target: /storage/dapperUtilityCoinReceiver)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: ducReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let dandyCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        let dandyCapPrivate= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPrivatePath)\n        if !dandyCapPrivate.check() {\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        var created=false\n        var updated=false\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        if !profile.hasWallet(\"Flow\") {\n            let flowWallet=Profile.Wallet( name:\"Flow\", receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), tags: [\"flow\"])\n    \n            profile.addWallet(flowWallet)\n            updated=true\n        }\n        if !profile.hasWallet(\"DUC\") {\n            profile.addWallet(Profile.Wallet( name:\"DUC\", receiver:ducReceiver, balance:getAccount(dapperAddress).getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/dapperUtilityCoinBalance), accept: Type\u003c@DapperUtilityCoin.Vault\u003e(), tags: [\"duc\", \"dapperUtilityCoin\",\"dapper\"]))\n            updated=true\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else {\n            profile.emitUpdatedEvent()\n        }\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        let doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        let doeSalePublicPath=FindMarket.getPublicPath(doeSaleType, name: tenant.name)\n        let doeSaleStoragePath= FindMarket.getStoragePath(doeSaleType, name:tenant.name)\n        let doeSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n        if !doeSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n        }\n\n        let doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        let doeBidPublicPath=FindMarket.getPublicPath(doeBidType, name: tenant.name)\n        let doeBidStoragePath= FindMarket.getStoragePath(doeBidType, name:tenant.name)\n        let doeBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n        if !doeBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n        }\n\n        /// auctions that escrow ft\n        let aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        let aeSalePublicPath=FindMarket.getPublicPath(aeSaleType, name: tenant.name)\n        let aeSaleStoragePath= FindMarket.getStoragePath(aeSaleType, name:tenant.name)\n        let aeSaleCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n        if !aeSaleCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n        }\n\n        let dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\n        let dosSalePublicPath=FindMarket.getPublicPath(dosSaleType, name: tenant.name)\n        let dosSaleStoragePath= FindMarket.getStoragePath(dosSaleType, name:tenant.name)\n\n        let dosSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n        if !dosSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n        }\n\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n        if !dosBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n        }\n\n        let aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\n        let aeBidPublicPath=FindMarket.getPublicPath(aeBidType, name: tenant.name)\n        let aeBidStoragePath= FindMarket.getStoragePath(aeBidType, name:tenant.name)\n        let aeBidCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n        if !aeBidCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n        }\n\n     /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n        }\n\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n        if !asBidCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n        }\n        //SYNC with register\n\n        self.saleItems= account.borrow\u003c\u0026FindMarketSale.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketSale.SaleItemCollection\u003e()))\n        self.pointers= []\n\n        let nfts : {String : NFTCatalog.NFTCollectionData} = {}\n\n        var counter = 0\n        while counter \u003c ids.length {\n            // Get supported NFT and FT Information from Registries from input alias\n            var nft : NFTCatalog.NFTCollectionData? = nil\n            var ft : FTRegistry.FTInfo? = nil\n\n            if nfts[nftAliasOrIdentifiers[counter]] != nil {\n                nft = nfts[nftAliasOrIdentifiers[counter]]\n            } else {\n                let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftAliasOrIdentifiers[counter])?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftAliasOrIdentifiers[counter])) \n                let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n                nft = collection.collectionData\n                nfts[nftAliasOrIdentifiers[counter]] = nft\n            }\n\n            var providerCap=account.getCapability\u003c\u0026{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e(nft!.privatePath)\n\n            /* Ben : Question -\u003e Either client will have to provide the path here or agree that we set it up for the user */\n            if !providerCap.check() {\n                let newCap = account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                        nft!.privatePath,\n                        target: nft!.storagePath\n                )\n                if newCap == nil {\n                    // If linking is not successful, we link it using finds custom link \n                    let pathIdentifier = nft!.privatePath.toString()\n                    let findPath = PrivatePath(identifier: pathIdentifier.slice(from: \"/private/\".length , upTo: pathIdentifier.length).concat(\"_FIND\"))!\n                    account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                        findPath,\n                        target: nft!.storagePath\n                    )\n                    providerCap = account.getCapability\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(findPath)\n                }\n            }\n            // Get the salesItemRef from tenant\n            self.pointers.append(FindViews.AuthNFTPointer(cap: providerCap, id: ids[counter]))\n            counter = counter + 1\n        }\n\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        var counter = 0\n        while counter \u003c ids.length {\n            self.saleItems!.listForSale(pointer: self.pointers[counter], vaultType: Type\u003c@DapperUtilityCoin.Vault\u003e(), directSellPrice: directSellPrices[counter], validUntil: validUntil, extraField: {})\n            counter = counter + 1\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "dapperAddress",
                     "marketplace",
                     "nftAliasOrIdentifiers",
                     "ids",
                     "directSellPrices",
                     "validUntil"
                  ],
                  "parameters": {
                     "dapperAddress": "Address",
                     "directSellPrices": "[UFix64]",
                     "ids": "[UInt64]",
                     "marketplace": "Address",
                     "nftAliasOrIdentifiers": "[String]",
                     "validUntil": "UFix64?"
                  }
               }
            },
            "listNFTForAuctionEscrowed": {
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FindMarketSale from 0x35717efbbce11c74\nimport FindMarketAuctionEscrow from 0x35717efbbce11c74\nimport FindMarketAuctionSoft from 0x35717efbbce11c74\nimport FindMarketDirectOfferEscrow from 0x35717efbbce11c74\nimport FindMarketDirectOfferSoft from 0x35717efbbce11c74\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FindViews from 0x35717efbbce11c74\nimport NFTCatalog from 0x324c34e1c517e4db\nimport FINDNFTCatalog from 0x35717efbbce11c74\nimport FTRegistry from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FUSD from 0xe223d8a629e49c68\nimport FiatToken from 0xa983fecbed621163\nimport FlowToken from 0x7e60df042a9c0868\nimport FIND from 0x35717efbbce11c74\nimport Dandy from 0x35717efbbce11c74\nimport Profile from 0x35717efbbce11c74\nimport FindLeaseMarketSale from 0x35717efbbce11c74\nimport FindLeaseMarketAuctionSoft from 0x35717efbbce11c74\n// import FindLeaseMarketAuctionEscrow from \"../contracts/FindLeaseMarketAuctionEscrow.cdc\"\nimport FindLeaseMarketDirectOfferSoft from 0x35717efbbce11c74\n// import FindLeaseMarketDirectOfferEscrow from \"../contracts/FindLeaseMarketDirectOfferEscrow.cdc\"\nimport FindLeaseMarket from 0x35717efbbce11c74\n\ntransaction(marketplace:Address, nftAliasOrIdentifier:String, id: UInt64, ftAliasOrIdentifier:String, price:UFix64, auctionReservePrice: UFix64, auctionDuration: UFix64, auctionExtensionOnLateBid: UFix64, minimumBidIncrement: UFix64, auctionValidUntil: UFix64?) {\n    \n    let saleItems : \u0026FindMarketAuctionEscrow.SaleItemCollection?\n    let vaultType : Type\n    let pointer : FindViews.AuthNFTPointer\n    \n    prepare(account: AuthAccount) {\n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n        //SYNC with register\n        //Add exising FUSD or create a new one and add it\n        let name = account.address.toString()\n        let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n        if !fusdReceiver.check() {\n            let fusd \u003c- FUSD.createEmptyVault()\n            account.save(\u003c- fusd, to: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n        }\n\n        let usdcCap = account.getCapability\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e(FiatToken.VaultReceiverPubPath)\n        if !usdcCap.check() {\n                account.save( \u003c-FiatToken.createEmptyVault(), to: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e( FiatToken.VaultReceiverPubPath, target: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FiatToken.ResourceId}\u003e( FiatToken.VaultUUIDPubPath, target: FiatToken.VaultStoragePath)\n                account.link\u003c\u0026FiatToken.Vault{FungibleToken.Balance}\u003e( FiatToken.VaultBalancePubPath, target:FiatToken.VaultStoragePath)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let dandyCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        let dandyCapPrivate= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPrivatePath)\n        if !dandyCapPrivate.check() {\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        var created=false\n        var updated=false\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        if !profile.hasWallet(\"Flow\") {\n            let flowWallet=Profile.Wallet( name:\"Flow\", receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), tags: [\"flow\"])\n    \n            profile.addWallet(flowWallet)\n            updated=true\n        }\n        if !profile.hasWallet(\"FUSD\") {\n            profile.addWallet(Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), tags: [\"fusd\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if !profile.hasWallet(\"USDC\") {\n            profile.addWallet(Profile.Wallet( name:\"USDC\", receiver:usdcCap, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(FiatToken.VaultBalancePubPath), accept: Type\u003c@FiatToken.Vault\u003e(), tags: [\"usdc\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else if updated {\n            profile.emitUpdatedEvent()\n        }\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        let doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        let doeSalePublicPath=FindMarket.getPublicPath(doeSaleType, name: tenant.name)\n        let doeSaleStoragePath= FindMarket.getStoragePath(doeSaleType, name:tenant.name)\n        let doeSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n        if !doeSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n        }\n\n        let doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        let doeBidPublicPath=FindMarket.getPublicPath(doeBidType, name: tenant.name)\n        let doeBidStoragePath= FindMarket.getStoragePath(doeBidType, name:tenant.name)\n        let doeBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n        if !doeBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n        }\n\n        /// auctions that escrow ft\n        let aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        let aeSalePublicPath=FindMarket.getPublicPath(aeSaleType, name: tenant.name)\n        let aeSaleStoragePath= FindMarket.getStoragePath(aeSaleType, name:tenant.name)\n        let aeSaleCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n        if !aeSaleCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n        }\n\n        let dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\n        let dosSalePublicPath=FindMarket.getPublicPath(dosSaleType, name: tenant.name)\n        let dosSaleStoragePath= FindMarket.getStoragePath(dosSaleType, name:tenant.name)\n\n        let dosSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n        if !dosSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n        }\n\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n        if !dosBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n        }\n\n        let aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\n        let aeBidPublicPath=FindMarket.getPublicPath(aeBidType, name: tenant.name)\n        let aeBidStoragePath= FindMarket.getStoragePath(aeBidType, name:tenant.name)\n        let aeBidCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n        if !aeBidCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n        }\n\n     /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n        }\n\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n        if !asBidCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n        }\n\n        let leaseTenantCapability= FindMarket.getTenantCapability(FindMarket.getTenantAddress(\"findLease\")!)!\n\n        let leaseSaleItemType= Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()\n        let leasePublicPath=FindMarket.getPublicPath(leaseSaleItemType, name: \"findLease\")\n        let leaseStoragePath= FindMarket.getStoragePath(leaseSaleItemType, name:\"findLease\")\n        let leaseSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath) \n        if !leaseSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketSale.SaleItemCollection\u003e(\u003c- FindLeaseMarketSale.createEmptySaleItemCollection(leaseTenantCapability), to: leaseStoragePath)\n            account.link\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath, target: leaseStoragePath)\n        }\n\n        let leaseASSaleItemType= Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e()\n        let leaseASPublicPath=FindMarket.getPublicPath(leaseASSaleItemType, name: \"findLease\")\n        let leaseASStoragePath= FindMarket.getStoragePath(leaseASSaleItemType, name:\"findLease\")\n        let leaseASSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath) \n        if !leaseASSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseASStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath, target: leaseASStoragePath)\n        }\n\n\n        let leaseASBidType= Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e()\n        let leaseASBidPublicPath=FindMarket.getPublicPath(leaseASBidType, name: \"findLease\")\n        let leaseASBidStoragePath= FindMarket.getStoragePath(leaseASBidType, name: \"findLease\")\n        let leaseASBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath) \n        if !leaseASBidCap.check() {\n            account.save\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseASBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath, target: leaseASBidStoragePath)\n        }\n\n        // let leaseAESaleItemType= Type\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e()\n        // let leaseAEPublicPath=FindMarket.getPublicPath(leaseAESaleItemType, name: \"findLease\")\n        // let leaseAEStoragePath= FindMarket.getStoragePath(leaseAESaleItemType, name:\"findLease\")\n        // let leaseAESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath) \n        // if !leaseAESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseAEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath, target: leaseAEStoragePath)\n        // }\n\n        // let leaseAEBidType= Type\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e()\n        // let leaseAEBidPublicPath=FindMarket.getPublicPath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidStoragePath= FindMarket.getStoragePath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath) \n        // if !leaseAEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseAEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath, target: leaseAEBidStoragePath)\n        // }\n\n        let leaseDOSSaleItemType= Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e()\n        let leaseDOSPublicPath=FindMarket.getPublicPath(leaseDOSSaleItemType, name: \"findLease\")\n        let leaseDOSStoragePath= FindMarket.getStoragePath(leaseDOSSaleItemType, name:\"findLease\")\n        let leaseDOSSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath) \n        if !leaseDOSSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOSStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath, target: leaseDOSStoragePath)\n        }\n\n        let leaseDOSBidType= Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let leaseDOSBidPublicPath=FindMarket.getPublicPath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidStoragePath= FindMarket.getStoragePath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath) \n        if !leaseDOSBidCap.check() {\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOSBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath, target: leaseDOSBidStoragePath)\n        }\n\n        // let leaseDOESaleItemType= Type\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        // let leaseDOEPublicPath=FindMarket.getPublicPath(leaseDOESaleItemType, name: \"findLease\")\n        // let leaseDOEStoragePath= FindMarket.getStoragePath(leaseDOESaleItemType, name:\"findLease\")\n        // let leaseDOESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath) \n        // if !leaseDOESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath, target: leaseDOEStoragePath)\n        // }\n\n        // let leaseDOEBidType= Type\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        // let leaseDOEBidPublicPath=FindMarket.getPublicPath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidStoragePath= FindMarket.getStoragePath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath) \n        // if !leaseDOEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath, target: leaseDOEBidStoragePath)\n        // }\n        //SYNC with register\n\n        let path=FindMarket.getStoragePath(Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(), name: tenant.name)\n\n\n        // Get supported NFT and FT Information from Registries from input alias\n        let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftAliasOrIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftAliasOrIdentifier)) \n        let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n        let nft = collection.collectionData\n\n        let ft = FTRegistry.getFTInfo(ftAliasOrIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftAliasOrIdentifier))\n\n        var providerCap=account.getCapability\u003c\u0026{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e(nft.privatePath)\n        \n        /* Ben : Question -\u003e Either client will have to provide the path here or agree that we set it up for the user */\n        if !providerCap.check() {\n            let newCap = account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                    nft.privatePath,\n                    target: nft.storagePath\n            )\n            if newCap == nil {\n                // If linking is not successful, we link it using finds custom link \n                let pathIdentifier = nft.privatePath.toString()\n                let findPath = PrivatePath(identifier: pathIdentifier.slice(from: \"/private/\".length , upTo: pathIdentifier.length).concat(\"_FIND\"))!\n                account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                    findPath,\n                    target: nft.storagePath\n                )\n                providerCap = account.getCapability\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(findPath)\n            }\n        }\n\n        self.saleItems= account.borrow\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection\u003e(from: path)\n        self.pointer= FindViews.AuthNFTPointer(cap: providerCap, id: id)\n        self.vaultType= ft.type\n    }\n\n    pre{\n        // Ben : panic on some unreasonable inputs in trxn \n        minimumBidIncrement \u003e 0.0 : \"Minimum bid increment should be larger than 0.\"\n        (auctionReservePrice - auctionReservePrice) % minimumBidIncrement == 0.0 : \"Acution ReservePrice should be in step of minimum bid increment.\" \n        auctionDuration \u003e 0.0 : \"Auction Duration should be greater than 0.\"\n        auctionExtensionOnLateBid \u003e 0.0 : \"Auction Duration should be greater than 0.\"\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute {\n        self.saleItems!.listForAuction(pointer: self.pointer, vaultType: self.vaultType, auctionStartPrice: price, auctionReservePrice: auctionReservePrice, auctionDuration: auctionDuration, auctionExtensionOnLateBid: auctionExtensionOnLateBid, minimumBidIncrement: minimumBidIncrement, auctionValidUntil:auctionValidUntil, saleItemExtraField: {})\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "nftAliasOrIdentifier",
                     "id",
                     "ftAliasOrIdentifier",
                     "price",
                     "auctionReservePrice",
                     "auctionDuration",
                     "auctionExtensionOnLateBid",
                     "minimumBidIncrement",
                     "auctionValidUntil"
                  ],
                  "parameters": {
                     "auctionDuration": "UFix64",
                     "auctionExtensionOnLateBid": "UFix64",
                     "auctionReservePrice": "UFix64",
                     "auctionValidUntil": "UFix64?",
                     "ftAliasOrIdentifier": "String",
                     "id": "UInt64",
                     "marketplace": "Address",
                     "minimumBidIncrement": "UFix64",
                     "nftAliasOrIdentifier": "String",
                     "price": "UFix64"
                  }
               }
            },
            "listNFTForAuctionSoft": {
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FindMarketSale from 0x35717efbbce11c74\nimport FindMarketAuctionEscrow from 0x35717efbbce11c74\nimport FindMarketAuctionSoft from 0x35717efbbce11c74\nimport FindMarketDirectOfferEscrow from 0x35717efbbce11c74\nimport FindMarketDirectOfferSoft from 0x35717efbbce11c74\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FindViews from 0x35717efbbce11c74\nimport FTRegistry from 0x35717efbbce11c74\nimport NFTCatalog from 0x324c34e1c517e4db\nimport FINDNFTCatalog from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FUSD from 0xe223d8a629e49c68\nimport FiatToken from 0xa983fecbed621163\nimport FlowToken from 0x7e60df042a9c0868\nimport FIND from 0x35717efbbce11c74\nimport Dandy from 0x35717efbbce11c74\nimport Profile from 0x35717efbbce11c74\nimport FindLeaseMarketSale from 0x35717efbbce11c74\nimport FindLeaseMarketAuctionSoft from 0x35717efbbce11c74\n// import FindLeaseMarketAuctionEscrow from \"../contracts/FindLeaseMarketAuctionEscrow.cdc\"\nimport FindLeaseMarketDirectOfferSoft from 0x35717efbbce11c74\n// import FindLeaseMarketDirectOfferEscrow from \"../contracts/FindLeaseMarketDirectOfferEscrow.cdc\"\nimport FindLeaseMarket from 0x35717efbbce11c74\n\ntransaction(marketplace:Address, nftAliasOrIdentifier:String, id: UInt64, ftAliasOrIdentifier:String, price:UFix64, auctionReservePrice: UFix64, auctionDuration: UFix64, auctionExtensionOnLateBid: UFix64, minimumBidIncrement: UFix64, auctionValidUntil: UFix64?) {\n    \n    let saleItems : \u0026FindMarketAuctionSoft.SaleItemCollection?\n    let pointer : FindViews.AuthNFTPointer\n    let vaultType : Type\n    \n    prepare(account: AuthAccount) {\n\n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n        //SYNC with register\n        //Add exising FUSD or create a new one and add it\n        let name = account.address.toString()\n        let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n        if !fusdReceiver.check() {\n            let fusd \u003c- FUSD.createEmptyVault()\n            account.save(\u003c- fusd, to: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n        }\n\n        let usdcCap = account.getCapability\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e(FiatToken.VaultReceiverPubPath)\n        if !usdcCap.check() {\n                account.save( \u003c-FiatToken.createEmptyVault(), to: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e( FiatToken.VaultReceiverPubPath, target: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FiatToken.ResourceId}\u003e( FiatToken.VaultUUIDPubPath, target: FiatToken.VaultStoragePath)\n                account.link\u003c\u0026FiatToken.Vault{FungibleToken.Balance}\u003e( FiatToken.VaultBalancePubPath, target:FiatToken.VaultStoragePath)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let dandyCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        let dandyCapPrivate= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPrivatePath)\n        if !dandyCapPrivate.check() {\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        var created=false\n        var updated=false\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        if !profile.hasWallet(\"Flow\") {\n            let flowWallet=Profile.Wallet( name:\"Flow\", receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), tags: [\"flow\"])\n    \n            profile.addWallet(flowWallet)\n            updated=true\n        }\n        if !profile.hasWallet(\"FUSD\") {\n            profile.addWallet(Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), tags: [\"fusd\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if !profile.hasWallet(\"USDC\") {\n            profile.addWallet(Profile.Wallet( name:\"USDC\", receiver:usdcCap, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(FiatToken.VaultBalancePubPath), accept: Type\u003c@FiatToken.Vault\u003e(), tags: [\"usdc\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else if updated {\n            profile.emitUpdatedEvent()\n        }\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        let doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        let doeSalePublicPath=FindMarket.getPublicPath(doeSaleType, name: tenant.name)\n        let doeSaleStoragePath= FindMarket.getStoragePath(doeSaleType, name:tenant.name)\n        let doeSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n        if !doeSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n        }\n\n        let doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        let doeBidPublicPath=FindMarket.getPublicPath(doeBidType, name: tenant.name)\n        let doeBidStoragePath= FindMarket.getStoragePath(doeBidType, name:tenant.name)\n        let doeBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n        if !doeBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n        }\n\n        /// auctions that escrow ft\n        let aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        let aeSalePublicPath=FindMarket.getPublicPath(aeSaleType, name: tenant.name)\n        let aeSaleStoragePath= FindMarket.getStoragePath(aeSaleType, name:tenant.name)\n        let aeSaleCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n        if !aeSaleCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n        }\n\n        let dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\n        let dosSalePublicPath=FindMarket.getPublicPath(dosSaleType, name: tenant.name)\n        let dosSaleStoragePath= FindMarket.getStoragePath(dosSaleType, name:tenant.name)\n\n        let dosSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n        if !dosSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n        }\n\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n        if !dosBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n        }\n\n        let aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\n        let aeBidPublicPath=FindMarket.getPublicPath(aeBidType, name: tenant.name)\n        let aeBidStoragePath= FindMarket.getStoragePath(aeBidType, name:tenant.name)\n        let aeBidCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n        if !aeBidCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n        }\n\n     /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n        }\n\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n        if !asBidCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n        }\n\n        let leaseTenantCapability= FindMarket.getTenantCapability(FindMarket.getTenantAddress(\"findLease\")!)!\n\n        let leaseSaleItemType= Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()\n        let leasePublicPath=FindMarket.getPublicPath(leaseSaleItemType, name: \"findLease\")\n        let leaseStoragePath= FindMarket.getStoragePath(leaseSaleItemType, name:\"findLease\")\n        let leaseSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath) \n        if !leaseSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketSale.SaleItemCollection\u003e(\u003c- FindLeaseMarketSale.createEmptySaleItemCollection(leaseTenantCapability), to: leaseStoragePath)\n            account.link\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath, target: leaseStoragePath)\n        }\n\n        let leaseASSaleItemType= Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e()\n        let leaseASPublicPath=FindMarket.getPublicPath(leaseASSaleItemType, name: \"findLease\")\n        let leaseASStoragePath= FindMarket.getStoragePath(leaseASSaleItemType, name:\"findLease\")\n        let leaseASSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath) \n        if !leaseASSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseASStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath, target: leaseASStoragePath)\n        }\n\n\n        let leaseASBidType= Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e()\n        let leaseASBidPublicPath=FindMarket.getPublicPath(leaseASBidType, name: \"findLease\")\n        let leaseASBidStoragePath= FindMarket.getStoragePath(leaseASBidType, name: \"findLease\")\n        let leaseASBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath) \n        if !leaseASBidCap.check() {\n            account.save\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseASBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath, target: leaseASBidStoragePath)\n        }\n\n        // let leaseAESaleItemType= Type\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e()\n        // let leaseAEPublicPath=FindMarket.getPublicPath(leaseAESaleItemType, name: \"findLease\")\n        // let leaseAEStoragePath= FindMarket.getStoragePath(leaseAESaleItemType, name:\"findLease\")\n        // let leaseAESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath) \n        // if !leaseAESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseAEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath, target: leaseAEStoragePath)\n        // }\n\n        // let leaseAEBidType= Type\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e()\n        // let leaseAEBidPublicPath=FindMarket.getPublicPath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidStoragePath= FindMarket.getStoragePath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath) \n        // if !leaseAEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseAEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath, target: leaseAEBidStoragePath)\n        // }\n\n        let leaseDOSSaleItemType= Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e()\n        let leaseDOSPublicPath=FindMarket.getPublicPath(leaseDOSSaleItemType, name: \"findLease\")\n        let leaseDOSStoragePath= FindMarket.getStoragePath(leaseDOSSaleItemType, name:\"findLease\")\n        let leaseDOSSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath) \n        if !leaseDOSSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOSStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath, target: leaseDOSStoragePath)\n        }\n\n        let leaseDOSBidType= Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let leaseDOSBidPublicPath=FindMarket.getPublicPath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidStoragePath= FindMarket.getStoragePath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath) \n        if !leaseDOSBidCap.check() {\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOSBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath, target: leaseDOSBidStoragePath)\n        }\n\n        // let leaseDOESaleItemType= Type\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        // let leaseDOEPublicPath=FindMarket.getPublicPath(leaseDOESaleItemType, name: \"findLease\")\n        // let leaseDOEStoragePath= FindMarket.getStoragePath(leaseDOESaleItemType, name:\"findLease\")\n        // let leaseDOESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath) \n        // if !leaseDOESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath, target: leaseDOEStoragePath)\n        // }\n\n        // let leaseDOEBidType= Type\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        // let leaseDOEBidPublicPath=FindMarket.getPublicPath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidStoragePath= FindMarket.getStoragePath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath) \n        // if !leaseDOEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath, target: leaseDOEBidStoragePath)\n        // }\n        //SYNC with register\n\n        // Get supported NFT and FT Information from Registries from input alias\n        let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftAliasOrIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftAliasOrIdentifier)) \n        let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n        let nft = collection.collectionData\n\n        let ft = FTRegistry.getFTInfo(ftAliasOrIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftAliasOrIdentifier))\n\n        var providerCap = account.getCapability\u003c\u0026{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e(nft.privatePath)\n\n        /* Ben : Question -\u003e Either client will have to provide the path here or agree that we set it up for the user */\n        if !providerCap.check() {\n            let newCap = account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                    nft.privatePath,\n                    target: nft.storagePath\n            )\n            if newCap == nil {\n                // If linking is not successful, we link it using finds custom link \n                let pathIdentifier = nft.privatePath.toString()\n                let findPath = PrivatePath(identifier: pathIdentifier.slice(from: \"/private/\".length , upTo: pathIdentifier.length).concat(\"_FIND\"))!\n                account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                    findPath,\n                    target: nft.storagePath\n                )\n                providerCap = account.getCapability\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(findPath)\n            }\n        }\n        \n        self.saleItems= account.borrow\u003c\u0026FindMarketAuctionSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()))\n        self.pointer= FindViews.AuthNFTPointer(cap: providerCap, id: id)\n        self.vaultType= ft.type\n\n        \n\n    }\n\n    pre{\n        // Ben : panic on some unreasonable inputs in trxn \n        minimumBidIncrement \u003e 0.0 :\"Minimum bid increment should be larger than 0.\"\n        (auctionReservePrice - auctionReservePrice) % minimumBidIncrement == 0.0 : \"Acution ReservePrice should be in step of minimum bid increment.\" \n        auctionDuration \u003e 0.0 : \"Auction Duration should be greater than 0.\"\n        auctionExtensionOnLateBid \u003e 0.0 : \"Auction Duration should be greater than 0.\"\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        self.saleItems!.listForAuction(pointer: self.pointer, vaultType: self.vaultType, auctionStartPrice: price, auctionReservePrice: auctionReservePrice, auctionDuration: auctionDuration, auctionExtensionOnLateBid: auctionExtensionOnLateBid, minimumBidIncrement: minimumBidIncrement, auctionValidUntil: auctionValidUntil, saleItemExtraField: {})\n\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "nftAliasOrIdentifier",
                     "id",
                     "ftAliasOrIdentifier",
                     "price",
                     "auctionReservePrice",
                     "auctionDuration",
                     "auctionExtensionOnLateBid",
                     "minimumBidIncrement",
                     "auctionValidUntil"
                  ],
                  "parameters": {
                     "auctionDuration": "UFix64",
                     "auctionExtensionOnLateBid": "UFix64",
                     "auctionReservePrice": "UFix64",
                     "auctionValidUntil": "UFix64?",
                     "ftAliasOrIdentifier": "String",
                     "id": "UInt64",
                     "marketplace": "Address",
                     "minimumBidIncrement": "UFix64",
                     "nftAliasOrIdentifier": "String",
                     "price": "UFix64"
                  }
               }
            },
            "listNFTForAuctionSoftDUC": {
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FindMarketSale from 0x35717efbbce11c74\nimport FindMarketAuctionEscrow from 0x35717efbbce11c74\nimport FindMarketAuctionSoft from 0x35717efbbce11c74\nimport FindMarketDirectOfferEscrow from 0x35717efbbce11c74\nimport FindMarketDirectOfferSoft from 0x35717efbbce11c74\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FindViews from 0x35717efbbce11c74\nimport NFTCatalog from 0x324c34e1c517e4db\nimport FINDNFTCatalog from 0x35717efbbce11c74\nimport FTRegistry from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FlowToken from 0x7e60df042a9c0868\nimport TokenForwarding from 0x51ea0e37c27a1f1a\nimport DapperUtilityCoin from 0x82ec283f88a62e65\nimport FIND from 0x35717efbbce11c74\nimport Dandy from 0x35717efbbce11c74\nimport Profile from 0x35717efbbce11c74\nimport FindLeaseMarketSale from 0x35717efbbce11c74\nimport FindLeaseMarketAuctionSoft from 0x35717efbbce11c74\n// import FindLeaseMarketAuctionEscrow from \"../contracts/FindLeaseMarketAuctionEscrow.cdc\"\nimport FindLeaseMarketDirectOfferSoft from 0x35717efbbce11c74\n// import FindLeaseMarketDirectOfferEscrow from \"../contracts/FindLeaseMarketDirectOfferEscrow.cdc\"\nimport FindLeaseMarket from 0x35717efbbce11c74\n\ntransaction(dapperAddress: Address, marketplace:Address, nftAliasOrIdentifier:String, id: UInt64, price:UFix64, auctionReservePrice: UFix64, auctionDuration: UFix64, auctionExtensionOnLateBid: UFix64, minimumBidIncrement: UFix64, auctionValidUntil: UFix64?) {\n    \n    let saleItems : \u0026FindMarketAuctionSoft.SaleItemCollection?\n    let pointer : FindViews.AuthNFTPointer\n    let vaultType : Type\n    \n    prepare(account: AuthAccount) {\n\n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n        //SYNC with register\n        //Add exising FUSD or create a new one and add it\n        let name = account.address.toString()\n        let ducReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver)\n        if !ducReceiver.check() {\n            let dapper = getAccount(dapperAddress)\n            // Create a new Forwarder resource for DUC and store it in the new account's storage\n            let ducForwarder \u003c- TokenForwarding.createNewForwarder(recipient: dapper.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver))\n            account.save(\u003c-ducForwarder, to: /storage/dapperUtilityCoinReceiver)\n            // Publish a Receiver capability for the new account, which is linked to the DUC Forwarder\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver,target: /storage/dapperUtilityCoinReceiver)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: ducReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let dandyCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        let dandyCapPrivate= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPrivatePath)\n        if !dandyCapPrivate.check() {\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        var created=false\n        var updated=false\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        if !profile.hasWallet(\"Flow\") {\n            let flowWallet=Profile.Wallet( name:\"Flow\", receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), tags: [\"flow\"])\n    \n            profile.addWallet(flowWallet)\n            updated=true\n        }\n        if !profile.hasWallet(\"DUC\") {\n            profile.addWallet(Profile.Wallet( name:\"DUC\", receiver:ducReceiver, balance:getAccount(dapperAddress).getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/dapperUtilityCoinBalance), accept: Type\u003c@DapperUtilityCoin.Vault\u003e(), tags: [\"duc\", \"dapperUtilityCoin\",\"dapper\"]))\n            updated=true\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else {\n            profile.emitUpdatedEvent()\n        }\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        let doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        let doeSalePublicPath=FindMarket.getPublicPath(doeSaleType, name: tenant.name)\n        let doeSaleStoragePath= FindMarket.getStoragePath(doeSaleType, name:tenant.name)\n        let doeSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n        if !doeSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n        }\n\n        let doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        let doeBidPublicPath=FindMarket.getPublicPath(doeBidType, name: tenant.name)\n        let doeBidStoragePath= FindMarket.getStoragePath(doeBidType, name:tenant.name)\n        let doeBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n        if !doeBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n        }\n\n        /// auctions that escrow ft\n        let aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        let aeSalePublicPath=FindMarket.getPublicPath(aeSaleType, name: tenant.name)\n        let aeSaleStoragePath= FindMarket.getStoragePath(aeSaleType, name:tenant.name)\n        let aeSaleCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n        if !aeSaleCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n        }\n\n        let dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\n        let dosSalePublicPath=FindMarket.getPublicPath(dosSaleType, name: tenant.name)\n        let dosSaleStoragePath= FindMarket.getStoragePath(dosSaleType, name:tenant.name)\n\n        let dosSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n        if !dosSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n        }\n\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n        if !dosBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n        }\n\n        let aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\n        let aeBidPublicPath=FindMarket.getPublicPath(aeBidType, name: tenant.name)\n        let aeBidStoragePath= FindMarket.getStoragePath(aeBidType, name:tenant.name)\n        let aeBidCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n        if !aeBidCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n        }\n\n     /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n        }\n\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n        if !asBidCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n        }\n\n        let leaseTenantCapability= FindMarket.getTenantCapability(FindMarket.getTenantAddress(\"findLease\")!)!\n\n        let leaseSaleItemType= Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()\n        let leasePublicPath=FindMarket.getPublicPath(leaseSaleItemType, name: \"findLease\")\n        let leaseStoragePath= FindMarket.getStoragePath(leaseSaleItemType, name:\"findLease\")\n        let leaseSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath) \n        if !leaseSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketSale.SaleItemCollection\u003e(\u003c- FindLeaseMarketSale.createEmptySaleItemCollection(leaseTenantCapability), to: leaseStoragePath)\n            account.link\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath, target: leaseStoragePath)\n        }\n\n        let leaseASSaleItemType= Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e()\n        let leaseASPublicPath=FindMarket.getPublicPath(leaseASSaleItemType, name: \"findLease\")\n        let leaseASStoragePath= FindMarket.getStoragePath(leaseASSaleItemType, name:\"findLease\")\n        let leaseASSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath) \n        if !leaseASSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseASStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath, target: leaseASStoragePath)\n        }\n\n\n        let leaseASBidType= Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e()\n        let leaseASBidPublicPath=FindMarket.getPublicPath(leaseASBidType, name: \"findLease\")\n        let leaseASBidStoragePath= FindMarket.getStoragePath(leaseASBidType, name: \"findLease\")\n        let leaseASBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath) \n        if !leaseASBidCap.check() {\n            account.save\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseASBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath, target: leaseASBidStoragePath)\n        }\n\n        // let leaseAESaleItemType= Type\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e()\n        // let leaseAEPublicPath=FindMarket.getPublicPath(leaseAESaleItemType, name: \"findLease\")\n        // let leaseAEStoragePath= FindMarket.getStoragePath(leaseAESaleItemType, name:\"findLease\")\n        // let leaseAESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath) \n        // if !leaseAESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseAEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath, target: leaseAEStoragePath)\n        // }\n\n        // let leaseAEBidType= Type\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e()\n        // let leaseAEBidPublicPath=FindMarket.getPublicPath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidStoragePath= FindMarket.getStoragePath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath) \n        // if !leaseAEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseAEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath, target: leaseAEBidStoragePath)\n        // }\n\n        let leaseDOSSaleItemType= Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e()\n        let leaseDOSPublicPath=FindMarket.getPublicPath(leaseDOSSaleItemType, name: \"findLease\")\n        let leaseDOSStoragePath= FindMarket.getStoragePath(leaseDOSSaleItemType, name:\"findLease\")\n        let leaseDOSSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath) \n        if !leaseDOSSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOSStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath, target: leaseDOSStoragePath)\n        }\n\n        let leaseDOSBidType= Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let leaseDOSBidPublicPath=FindMarket.getPublicPath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidStoragePath= FindMarket.getStoragePath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath) \n        if !leaseDOSBidCap.check() {\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOSBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath, target: leaseDOSBidStoragePath)\n        }\n\n        // let leaseDOESaleItemType= Type\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        // let leaseDOEPublicPath=FindMarket.getPublicPath(leaseDOESaleItemType, name: \"findLease\")\n        // let leaseDOEStoragePath= FindMarket.getStoragePath(leaseDOESaleItemType, name:\"findLease\")\n        // let leaseDOESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath) \n        // if !leaseDOESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath, target: leaseDOEStoragePath)\n        // }\n\n        // let leaseDOEBidType= Type\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        // let leaseDOEBidPublicPath=FindMarket.getPublicPath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidStoragePath= FindMarket.getStoragePath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath) \n        // if !leaseDOEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath, target: leaseDOEBidStoragePath)\n        // }\n        //SYNC with register\n\n        // Get supported NFT and FT Information from Registries from input alias\n        let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftAliasOrIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftAliasOrIdentifier)) \n        let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n        let nft = collection.collectionData\n\n        let ft = FTRegistry.getFTInfo(Type\u003c@DapperUtilityCoin.Vault\u003e().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(Type\u003c@DapperUtilityCoin.Vault\u003e().identifier))\n\n        var providerCap = account.getCapability\u003c\u0026{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e(nft.privatePath)\n\n        /* Ben : Question -\u003e Either client will have to provide the path here or agree that we set it up for the user */\n        if !providerCap.check() {\n            let newCap = account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                    nft.privatePath,\n                    target: nft.storagePath\n            )\n            if newCap == nil {\n                // If linking is not successful, we link it using finds custom link \n                let pathIdentifier = nft.privatePath.toString()\n                let findPath = PrivatePath(identifier: pathIdentifier.slice(from: \"/private/\".length , upTo: pathIdentifier.length).concat(\"_FIND\"))!\n                account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                    findPath,\n                    target: nft.storagePath\n                )\n                providerCap = account.getCapability\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(findPath)\n            }\n        }\n        \n        self.saleItems= account.borrow\u003c\u0026FindMarketAuctionSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()))\n        self.pointer= FindViews.AuthNFTPointer(cap: providerCap, id: id)    \n        self.vaultType= ft.type    \n    }\n\n    pre{\n        // Ben : panic on some unreasonable inputs in trxn \n        minimumBidIncrement \u003e 0.0 :\"Minimum bid increment should be larger than 0.\"\n        (auctionReservePrice - auctionReservePrice) % minimumBidIncrement == 0.0 : \"Acution ReservePrice should be in step of minimum bid increment.\" \n        auctionDuration \u003e 0.0 : \"Auction Duration should be greater than 0.\"\n        auctionExtensionOnLateBid \u003e 0.0 : \"Auction Duration should be greater than 0.\"\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        self.saleItems!.listForAuction(pointer: self.pointer, vaultType: self.vaultType, auctionStartPrice: price, auctionReservePrice: auctionReservePrice, auctionDuration: auctionDuration, auctionExtensionOnLateBid: auctionExtensionOnLateBid, minimumBidIncrement: minimumBidIncrement, auctionValidUntil: auctionValidUntil, saleItemExtraField: {})\n\n    }\n}",
               "spec": {
                  "order": [
                     "dapperAddress",
                     "marketplace",
                     "nftAliasOrIdentifier",
                     "id",
                     "price",
                     "auctionReservePrice",
                     "auctionDuration",
                     "auctionExtensionOnLateBid",
                     "minimumBidIncrement",
                     "auctionValidUntil"
                  ],
                  "parameters": {
                     "auctionDuration": "UFix64",
                     "auctionExtensionOnLateBid": "UFix64",
                     "auctionReservePrice": "UFix64",
                     "auctionValidUntil": "UFix64?",
                     "dapperAddress": "Address",
                     "id": "UInt64",
                     "marketplace": "Address",
                     "minimumBidIncrement": "UFix64",
                     "nftAliasOrIdentifier": "String",
                     "price": "UFix64"
                  }
               }
            },
            "listNFTForSale": {
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FindMarketSale from 0x35717efbbce11c74\nimport FindMarketAuctionEscrow from 0x35717efbbce11c74\nimport FindMarketAuctionSoft from 0x35717efbbce11c74\nimport FindMarketDirectOfferEscrow from 0x35717efbbce11c74\nimport FindMarketDirectOfferSoft from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FUSD from 0xe223d8a629e49c68\nimport FlowToken from 0x7e60df042a9c0868\nimport FiatToken from 0xa983fecbed621163\nimport FIND from 0x35717efbbce11c74\nimport Dandy from 0x35717efbbce11c74\nimport Profile from 0x35717efbbce11c74\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FindViews from 0x35717efbbce11c74\nimport NFTCatalog from 0x324c34e1c517e4db\nimport FINDNFTCatalog from 0x35717efbbce11c74\nimport FTRegistry from 0x35717efbbce11c74\nimport FindLeaseMarketSale from 0x35717efbbce11c74\nimport FindLeaseMarketAuctionSoft from 0x35717efbbce11c74\nimport FindLeaseMarketDirectOfferSoft from 0x35717efbbce11c74\nimport FindLeaseMarket from 0x35717efbbce11c74\n\ntransaction(marketplace:Address, nftAliasOrIdentifier: String, id: UInt64, ftAliasOrIdentifier: String, directSellPrice:UFix64, validUntil: UFix64?) {\n    \n    let saleItems : \u0026FindMarketSale.SaleItemCollection?\n    let pointer : FindViews.AuthNFTPointer\n    let vaultType : Type\n\n    prepare(account: AuthAccount) {\n\n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n        //SYNC with register\n        //Add exising FUSD or create a new one and add it\n        let name = account.address.toString()\n        let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n        if !fusdReceiver.check() {\n            let fusd \u003c- FUSD.createEmptyVault()\n            account.save(\u003c- fusd, to: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n        }\n\n        let usdcCap = account.getCapability\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e(FiatToken.VaultReceiverPubPath)\n        if !usdcCap.check() {\n                account.save( \u003c-FiatToken.createEmptyVault(), to: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e( FiatToken.VaultReceiverPubPath, target: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FiatToken.ResourceId}\u003e( FiatToken.VaultUUIDPubPath, target: FiatToken.VaultStoragePath)\n                account.link\u003c\u0026FiatToken.Vault{FungibleToken.Balance}\u003e( FiatToken.VaultBalancePubPath, target:FiatToken.VaultStoragePath)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let dandyCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        let dandyCapPrivate= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPrivatePath)\n        if !dandyCapPrivate.check() {\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        var created=false\n        var updated=false\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        if !profile.hasWallet(\"Flow\") {\n            let flowWallet=Profile.Wallet( name:\"Flow\", receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), tags: [\"flow\"])\n    \n            profile.addWallet(flowWallet)\n            updated=true\n        }\n        if !profile.hasWallet(\"FUSD\") {\n            profile.addWallet(Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), tags: [\"fusd\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if !profile.hasWallet(\"USDC\") {\n            profile.addWallet(Profile.Wallet( name:\"USDC\", receiver:usdcCap, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(FiatToken.VaultBalancePubPath), accept: Type\u003c@FiatToken.Vault\u003e(), tags: [\"usdc\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else if updated {\n            profile.emitUpdatedEvent()\n        }\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        let doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        let doeSalePublicPath=FindMarket.getPublicPath(doeSaleType, name: tenant.name)\n        let doeSaleStoragePath= FindMarket.getStoragePath(doeSaleType, name:tenant.name)\n        let doeSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n        if !doeSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n        }\n\n        let doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        let doeBidPublicPath=FindMarket.getPublicPath(doeBidType, name: tenant.name)\n        let doeBidStoragePath= FindMarket.getStoragePath(doeBidType, name:tenant.name)\n        let doeBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n        if !doeBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n        }\n\n        /// auctions that escrow ft\n        let aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        let aeSalePublicPath=FindMarket.getPublicPath(aeSaleType, name: tenant.name)\n        let aeSaleStoragePath= FindMarket.getStoragePath(aeSaleType, name:tenant.name)\n        let aeSaleCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n        if !aeSaleCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n        }\n\n        let dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\n        let dosSalePublicPath=FindMarket.getPublicPath(dosSaleType, name: tenant.name)\n        let dosSaleStoragePath= FindMarket.getStoragePath(dosSaleType, name:tenant.name)\n\n        let dosSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n        if !dosSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n        }\n\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n        if !dosBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n        }\n\n        let aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\n        let aeBidPublicPath=FindMarket.getPublicPath(aeBidType, name: tenant.name)\n        let aeBidStoragePath= FindMarket.getStoragePath(aeBidType, name:tenant.name)\n        let aeBidCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n        if !aeBidCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n        }\n\n     /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n        }\n\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n        if !asBidCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n        }\n\n        let leaseTenantCapability= FindMarket.getTenantCapability(FindMarket.getTenantAddress(\"findLease\")!)!\n\n        let leaseSaleItemType= Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()\n        let leasePublicPath=FindMarket.getPublicPath(leaseSaleItemType, name: \"findLease\")\n        let leaseStoragePath= FindMarket.getStoragePath(leaseSaleItemType, name:\"findLease\")\n        let leaseSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath) \n        if !leaseSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketSale.SaleItemCollection\u003e(\u003c- FindLeaseMarketSale.createEmptySaleItemCollection(leaseTenantCapability), to: leaseStoragePath)\n            account.link\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath, target: leaseStoragePath)\n        }\n\n        let leaseASSaleItemType= Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e()\n        let leaseASPublicPath=FindMarket.getPublicPath(leaseASSaleItemType, name: \"findLease\")\n        let leaseASStoragePath= FindMarket.getStoragePath(leaseASSaleItemType, name:\"findLease\")\n        let leaseASSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath) \n        if !leaseASSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseASStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath, target: leaseASStoragePath)\n        }\n\n\n        let leaseASBidType= Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e()\n        let leaseASBidPublicPath=FindMarket.getPublicPath(leaseASBidType, name: \"findLease\")\n        let leaseASBidStoragePath= FindMarket.getStoragePath(leaseASBidType, name: \"findLease\")\n        let leaseASBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath) \n        if !leaseASBidCap.check() {\n            account.save\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseASBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath, target: leaseASBidStoragePath)\n        }\n\n        // let leaseAESaleItemType= Type\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e()\n        // let leaseAEPublicPath=FindMarket.getPublicPath(leaseAESaleItemType, name: \"findLease\")\n        // let leaseAEStoragePath= FindMarket.getStoragePath(leaseAESaleItemType, name:\"findLease\")\n        // let leaseAESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath) \n        // if !leaseAESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseAEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath, target: leaseAEStoragePath)\n        // }\n\n        // let leaseAEBidType= Type\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e()\n        // let leaseAEBidPublicPath=FindMarket.getPublicPath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidStoragePath= FindMarket.getStoragePath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath) \n        // if !leaseAEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseAEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath, target: leaseAEBidStoragePath)\n        // }\n\n        let leaseDOSSaleItemType= Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e()\n        let leaseDOSPublicPath=FindMarket.getPublicPath(leaseDOSSaleItemType, name: \"findLease\")\n        let leaseDOSStoragePath= FindMarket.getStoragePath(leaseDOSSaleItemType, name:\"findLease\")\n        let leaseDOSSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath) \n        if !leaseDOSSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOSStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath, target: leaseDOSStoragePath)\n        }\n\n        let leaseDOSBidType= Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let leaseDOSBidPublicPath=FindMarket.getPublicPath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidStoragePath= FindMarket.getStoragePath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath) \n        if !leaseDOSBidCap.check() {\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOSBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath, target: leaseDOSBidStoragePath)\n        }\n\n        // let leaseDOESaleItemType= Type\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        // let leaseDOEPublicPath=FindMarket.getPublicPath(leaseDOESaleItemType, name: \"findLease\")\n        // let leaseDOEStoragePath= FindMarket.getStoragePath(leaseDOESaleItemType, name:\"findLease\")\n        // let leaseDOESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath) \n        // if !leaseDOESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath, target: leaseDOEStoragePath)\n        // }\n\n        // let leaseDOEBidType= Type\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        // let leaseDOEBidPublicPath=FindMarket.getPublicPath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidStoragePath= FindMarket.getStoragePath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath) \n        // if !leaseDOEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath, target: leaseDOEBidStoragePath)\n        // }\n        //SYNC with register\n\n        // Get supported NFT and FT Information from Registries from input alias\n    let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier:nftAliasOrIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftAliasOrIdentifier)) \n    let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n    let nft = collection.collectionData\n\n        let ft = FTRegistry.getFTInfo(ftAliasOrIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftAliasOrIdentifier))\n\n        var providerCap=account.getCapability\u003c\u0026{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e(nft.privatePath)\n\n        /* Ben : Question -\u003e Either client will have to provide the path here or agree that we set it up for the user */\n        if !providerCap.check() {\n            let newCap = account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                nft.privatePath,\n                target: nft.storagePath\n            )\n            if newCap == nil {\n                // If linking is not successful, we link it using finds custom link \n                let pathIdentifier = nft.privatePath.toString()\n                let findPath = PrivatePath(identifier: pathIdentifier.slice(from: \"/private/\".length , upTo: pathIdentifier.length).concat(\"_FIND\"))!\n                account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                    findPath,\n                    target: nft.storagePath\n                )\n                providerCap = account.getCapability\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(findPath)\n            }\n        }\n        // Get the salesItemRef from tenant\n        self.saleItems= account.borrow\u003c\u0026FindMarketSale.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketSale.SaleItemCollection\u003e()))\n        self.pointer= FindViews.AuthNFTPointer(cap: providerCap, id: id)\n        self.vaultType= ft.type\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        self.saleItems!.listForSale(pointer: self.pointer, vaultType: self.vaultType, directSellPrice: directSellPrice, validUntil: validUntil, extraField: {})\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "nftAliasOrIdentifier",
                     "id",
                     "ftAliasOrIdentifier",
                     "directSellPrice",
                     "validUntil"
                  ],
                  "parameters": {
                     "directSellPrice": "UFix64",
                     "ftAliasOrIdentifier": "String",
                     "id": "UInt64",
                     "marketplace": "Address",
                     "nftAliasOrIdentifier": "String",
                     "validUntil": "UFix64?"
                  }
               }
            },
            "listNFTForSaleDUC": {
               "code": "import FindMarket from 0x35717efbbce11c74\nimport Profile from 0x35717efbbce11c74\nimport FindMarketSale from 0x35717efbbce11c74\nimport NFTCatalog from 0x324c34e1c517e4db\nimport FINDNFTCatalog from 0x35717efbbce11c74\nimport FTRegistry from 0x35717efbbce11c74\nimport FindViews from 0x35717efbbce11c74\n\nimport FungibleToken from 0x9a0766d93b6608b7\nimport DapperUtilityCoin from 0x82ec283f88a62e65\nimport TokenForwarding from 0x51ea0e37c27a1f1a\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\n\ntransaction(dapperAddress:Address, marketplace:Address, nftAliasOrIdentifier: String, id: UInt64, directSellPrice:UFix64, validUntil: UFix64?) {\n    \n    let saleItems : \u0026FindMarketSale.SaleItemCollection?\n    let pointer : FindViews.AuthNFTPointer\n    let vaultType : Type\n    \n    prepare(account: AuthAccount) {\n\n        let name = account.address.toString()\n        let ducReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver)\n        if !ducReceiver.check() {\n            let dapper = getAccount(dapperAddress)\n            let ducForwarder \u003c- TokenForwarding.createNewForwarder(recipient: dapper.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver))\n            account.save(\u003c-ducForwarder, to: /storage/dapperUtilityCoinReceiver)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver,target: /storage/dapperUtilityCoinReceiver)\n        }\n\n        var created=false\n        var updated=false\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            created=true\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"onefootball\")\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        if !profile.hasWallet(\"DUC\") {\n            updated=true\n            profile.addWallet(Profile.Wallet( name:\"DUC\", receiver:ducReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/dapperUtilityCoinBalance), accept: Type\u003c@DapperUtilityCoin.Vault\u003e(), tags: [\"duc\", \"dapperUtilityCoin\",\"dapper\"]))\n            updated=true\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else {\n            profile.emitUpdatedEvent()\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else if updated {\n            profile.emitUpdatedEvent()\n        }\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n        //end initializtion\n\n        // Get supported NFT and FT Information from Registries from input alias\n        let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftAliasOrIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftAliasOrIdentifier)) \n        let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n        let nft = collection.collectionData\n\n        let ft = FTRegistry.getFTInfo(Type\u003c@DapperUtilityCoin.Vault\u003e().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(Type\u003c@DapperUtilityCoin.Vault\u003e().identifier))\n\n        let providerCap=account.getCapability\u003c\u0026{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e(nft.privatePath)\n\n        if !providerCap.check() {\n            account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                nft.privatePath,\n                target: nft.storagePath\n            )\n        }\n        // Get the salesItemRef from tenant\n        self.saleItems= account.borrow\u003c\u0026FindMarketSale.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketSale.SaleItemCollection\u003e()))\n        self.pointer= FindViews.AuthNFTPointer(cap: providerCap, id: id)\n        self.vaultType= ft.type\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        self.saleItems!.listForSale(pointer: self.pointer, vaultType: self.vaultType, directSellPrice: directSellPrice, validUntil: validUntil, extraField: {})\n\n    }\n}",
               "spec": {
                  "order": [
                     "dapperAddress",
                     "marketplace",
                     "nftAliasOrIdentifier",
                     "id",
                     "directSellPrice",
                     "validUntil"
                  ],
                  "parameters": {
                     "dapperAddress": "Address",
                     "directSellPrice": "UFix64",
                     "id": "UInt64",
                     "marketplace": "Address",
                     "nftAliasOrIdentifier": "String",
                     "validUntil": "UFix64?"
                  }
               }
            },
            "listNameForAuction": {
               "code": "import FIND from 0x35717efbbce11c74\n\ntransaction(name: String, auctionStartPrice: UFix64, auctionReservePrice: UFix64, auctionDuration: UFix64, auctionExtensionOnLateBid: UFix64) {\n    \n    let finLeases : \u0026FIND.LeaseCollection?\n\n    prepare(acct: AuthAccount) {\n        self.finLeases= acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)\n    }\n\n    pre{\n        self.finLeases != nil : \"Cannot borrow reference to find lease collection\"\n    }\n\n    execute{\n        self.finLeases!.listForAuction(name: name, auctionStartPrice: auctionStartPrice, auctionReservePrice: auctionReservePrice, auctionDuration: auctionDuration,  auctionExtensionOnLateBid: auctionExtensionOnLateBid)\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "auctionStartPrice",
                     "auctionReservePrice",
                     "auctionDuration",
                     "auctionExtensionOnLateBid"
                  ],
                  "parameters": {
                     "auctionDuration": "UFix64",
                     "auctionExtensionOnLateBid": "UFix64",
                     "auctionReservePrice": "UFix64",
                     "auctionStartPrice": "UFix64",
                     "name": "String"
                  }
               }
            },
            "listNameForSale": {
               "code": "import FIND from 0x35717efbbce11c74\n\ntransaction(name: String, directSellPrice:UFix64) {\n\n    let finLeases : \u0026FIND.LeaseCollection?\n\n    prepare(acct: AuthAccount) {\n        self.finLeases= acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)\n    }\n\n    pre{\n        self.finLeases != nil : \"Cannot borrow reference to find lease collection\"\n    }\n\n    execute{\n        self.finLeases!.listForSale(name: name,  directSellPrice:directSellPrice)\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "directSellPrice"
                  ],
                  "parameters": {
                     "directSellPrice": "UFix64",
                     "name": "String"
                  }
               }
            },
            "moveNameTO": {
               "code": "import Profile from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\n\n\ntransaction(name: String, receiver:String) {\n\n\n    let receiverAddress:Address?\n    let sender : \u0026FIND.LeaseCollection\n\n    prepare(acct: AuthAccount) {\n        self.sender= acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n        self.receiverAddress=FIND.resolve(receiver)\n    } \n\n    pre{\n        self.receiverAddress != nil : \"The input pass in is not a valid name or address. Input : \".concat(receiver)\n    }\n\n    execute {\n        let receiver=getAccount(self.receiverAddress!)\n        let receiverLease = receiver.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        let receiverProfile = receiver.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\n        if !receiverLease.check() || !receiverProfile.check() {\n            panic(\"Not a valid FIND user\")\n        }\n\n        self.sender.move(name:name, profile:receiverProfile, to: receiverLease)\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "receiver"
                  ],
                  "parameters": {
                     "name": "String",
                     "receiver": "String"
                  }
               }
            },
            "openBl0xPack": {
               "code": "import Bl0x from 0xe8124d8428980aa6\nimport Bl0xPack from 0xe8124d8428980aa6\nimport FungibleToken from 0x9a0766d93b6608b7\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\n\n/// A transaction to open a pack with a given id\n/// @param packId: The id of the pack to open\ntransaction(packId:UInt64) {\n\n    let packs: \u0026Bl0xPack.Collection\n    var receiver: Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e\n\n    prepare(account: AuthAccount) {\n        self.packs=account.borrow\u003c\u0026Bl0xPack.Collection\u003e(from: Bl0xPack.CollectionStoragePath)!\n        self.receiver = account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(Bl0x.CollectionPublicPath)\n        if !self.receiver.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Bl0x.createEmptyCollection(), to: Bl0x.CollectionStoragePath)\n            account.link\u003c\u0026Bl0x.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                Bl0x.CollectionPublicPath,\n                target: Bl0x.CollectionStoragePath\n            )\n            account.link\u003c\u0026Bl0x.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                Bl0x.CollectionPrivatePath,\n                target: Bl0x.CollectionStoragePath\n            )\n\n            self.receiver = account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(Bl0x.CollectionPublicPath)\n        }\n\n    }\n\n    pre {\n        self.receiver.check() : \"The receiver collection for the packs is not set up properly\"\n    }\n    execute {\n        self.packs.open(packId: packId, receiverCap:self.receiver)\n    }\n\n    post {\n        !self.packs.getIDs().contains(packId) : \"The pack is still present in the users collection\"\n    }\n}",
               "spec": {
                  "order": [
                     "packId"
                  ],
                  "parameters": {
                     "packId": "UInt64"
                  }
               }
            },
            "redeemAllLostAndFoundNFTs": {
               "code": "import FindLostAndFoundWrapper from 0x82836e61c008d6d1\nimport LostAndFound from 0xbe4635353f55bbd4\nimport FINDNFTCatalog from 0x35717efbbce11c74\nimport NFTCatalog from 0x324c34e1c517e4db\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FIND from 0x35717efbbce11c74\nimport Bl0xPack from 0xe8124d8428980aa6\n\n//IMPORT\n\ntransaction() {\n\n    let ids : {String : [UInt64]}\n    let nftInfos : {String : NFTCatalog.NFTCollectionData}\n    let receiverAddress : Address\n\n    prepare(account: AuthAccount){\n\n        //LINK\n\n        let findPackCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Bl0xPack.CollectionPublicPath)\n        if !findPackCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e( \u003c- Bl0xPack.createEmptyCollection(), to: Bl0xPack.CollectionStoragePath)\n            account.link\u003c\u0026Bl0xPack.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                Bl0xPack.CollectionPublicPath,\n                target: Bl0xPack.CollectionStoragePath\n            )\n        }\n\n        self.nftInfos = {}\n        self.ids = FindLostAndFoundWrapper.getTicketIDs(user: account.address, specificType: Type\u003c@NonFungibleToken.NFT\u003e())\n\n        for type in self.ids.keys{ \n            if self.nftInfos[type] == nil {\n                let collections = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: type) ?? panic(\"NFT type is not supported at the moment. Type : \".concat(type))\n                self.nftInfos[type] = FINDNFTCatalog.getCatalogEntry(collectionIdentifier: collections.keys[0])!.collectionData\n            }\n        }\n\n        self.receiverAddress = account.address\n    }\n\n    execute{\n        for type in self.ids.keys{ \n            let path = self.nftInfos[type]!.publicPath\n            for id in self.ids[type]! {\n                FindLostAndFoundWrapper.redeemNFT(type: CompositeType(type)!, ticketID: id, receiverAddress: self.receiverAddress, collectionPublicPath: path)\n            }\n        }\n    }\n}",
               "spec": {
                  "order": [],
                  "parameters": {}
               }
            },
            "redeemAllLostAndFoundNFTsOnBehalf": {
               "code": "import FindLostAndFoundWrapper from 0x82836e61c008d6d1\nimport LostAndFound from 0xbe4635353f55bbd4\nimport FINDNFTCatalog from 0x35717efbbce11c74\nimport NFTCatalog from 0x324c34e1c517e4db\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FIND from 0x35717efbbce11c74\n\n//IMPORT\n\ntransaction(receiverAddress: Address) {\n\n    let ids : {String : [UInt64]}\n    let nftInfos : {String : NFTCatalog.NFTCollectionData}\n    let receiverAddress : Address\n\n    prepare(account: AuthAccount){\n        self.receiverAddress = receiverAddress\n\n        self.nftInfos = {}\n        self.ids = FindLostAndFoundWrapper.getTicketIDs(user: receiverAddress, specificType: Type\u003c@NonFungibleToken.NFT\u003e())\n\n        for type in self.ids.keys{ \n            if self.nftInfos[type] == nil {\n                let collections = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: type) ?? panic(\"NFT type is not supported at the moment. Type : \".concat(type))\n                self.nftInfos[type] = FINDNFTCatalog.getCatalogEntry(collectionIdentifier: collections.keys[0])!.collectionData\n            }\n        }\n\n    }\n\n    execute{\n        for type in self.ids.keys{ \n            let path = self.nftInfos[type]!.publicPath\n            for id in self.ids[type]! {\n                FindLostAndFoundWrapper.redeemNFT(type: CompositeType(type)!, ticketID: id, receiverAddress: self.receiverAddress, collectionPublicPath: path)\n            }\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "receiverAddress"
                  ],
                  "parameters": {
                     "receiverAddress": "Address"
                  }
               }
            },
            "redeemLostAndFoundNFTs": {
               "code": "import FindLostAndFoundWrapper from 0x82836e61c008d6d1\nimport LostAndFound from 0xbe4635353f55bbd4\nimport FINDNFTCatalog from 0x35717efbbce11c74\nimport NFTCatalog from 0x324c34e1c517e4db\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FindViews from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\nimport Bl0xPack from 0xe8124d8428980aa6\n\n//IMPORT\n\ntransaction(ids: {String : [UInt64]}) {\n\n    let nftInfos : {String : NFTCatalog.NFTCollectionData}\n    let receiverAddress : Address\n\n    prepare(account: AuthAccount){\n\n        //LINK\n\n        let findPackCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Bl0xPack.CollectionPublicPath)\n        if !findPackCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e( \u003c- Bl0xPack.createEmptyCollection(), to: Bl0xPack.CollectionStoragePath)\n            account.link\u003c\u0026Bl0xPack.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                Bl0xPack.CollectionPublicPath,\n                target: Bl0xPack.CollectionStoragePath\n            )\n        }\n\n        self.nftInfos = {}\n\n        for type in ids.keys{ \n            if self.nftInfos[type] == nil {\n                let collections = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: type) ?? panic(\"NFT type is not supported at the moment. Type : \".concat(type))\n                self.nftInfos[type] = FINDNFTCatalog.getCatalogEntry(collectionIdentifier: collections.keys[0])!.collectionData\n            }\n        }\n\n        self.receiverAddress = account.address\n    }\n\n    execute{\n        for type in ids.keys{ \n            let path = self.nftInfos[type]!.publicPath\n            for id in ids[type]! {\n                FindLostAndFoundWrapper.redeemNFT(type: CompositeType(type)!, ticketID: id, receiverAddress:self.receiverAddress, collectionPublicPath: path)\n            }\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "ids"
                  ],
                  "parameters": {
                     "ids": "{String: [UInt64]}"
                  }
               }
            },
            "redeemLostAndFoundNFTsOnBehalf": {
               "code": "import FindLostAndFoundWrapper from 0x82836e61c008d6d1\nimport LostAndFound from 0xbe4635353f55bbd4\nimport FINDNFTCatalog from 0x35717efbbce11c74\nimport NFTCatalog from 0x324c34e1c517e4db\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FindViews from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\nimport Bl0xPack from 0xe8124d8428980aa6\n\n//IMPORT\n\ntransaction(receiverAddress: Address, ids: {String : [UInt64]}) {\n\n    let nftInfos : {String : NFTCatalog.NFTCollectionData}\n    let receiverAddress : Address\n\n    prepare(account: AuthAccount){\n\n        self.receiverAddress = receiverAddress\n\n        self.nftInfos = {}\n\n        for type in ids.keys{ \n            if self.nftInfos[type] == nil {\n                let collections = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: type) ?? panic(\"NFT type is not supported at the moment. Type : \".concat(type))\n                self.nftInfos[type] = FINDNFTCatalog.getCatalogEntry(collectionIdentifier: collections.keys[0])!.collectionData\n            }\n        }\n\n    }\n\n    execute{\n        for type in ids.keys{ \n            let path = self.nftInfos[type]!.publicPath\n            for id in ids[type]! {\n                FindLostAndFoundWrapper.redeemNFT(type: CompositeType(type)!, ticketID: id, receiverAddress:self.receiverAddress, collectionPublicPath: path)\n            }\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "receiverAddress",
                     "ids"
                  ],
                  "parameters": {
                     "ids": "{String: [UInt64]}",
                     "receiverAddress": "Address"
                  }
               }
            },
            "register": {
               "code": "import FungibleToken from 0x9a0766d93b6608b7\nimport FUSD from 0xe223d8a629e49c68\nimport FiatToken from 0xa983fecbed621163\nimport FlowToken from 0x7e60df042a9c0868\nimport Profile from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\nimport FindMarketSale from 0x35717efbbce11c74\nimport FindMarketDirectOfferEscrow from 0x35717efbbce11c74\nimport FindMarketDirectOfferSoft from 0x35717efbbce11c74\nimport FindMarketAuctionEscrow from 0x35717efbbce11c74\nimport FindMarketAuctionSoft from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport Dandy from 0x35717efbbce11c74\nimport FindLeaseMarketSale from 0x35717efbbce11c74\nimport FindLeaseMarketAuctionSoft from 0x35717efbbce11c74\n// import FindLeaseMarketAuctionEscrow from \"../contracts/FindLeaseMarketAuctionEscrow.cdc\"\nimport FindLeaseMarketDirectOfferSoft from 0x35717efbbce11c74\n// import FindLeaseMarketDirectOfferEscrow from \"../contracts/FindLeaseMarketDirectOfferEscrow.cdc\"\nimport FindLeaseMarket from 0x35717efbbce11c74\n\ntransaction(name: String, amount: UFix64) {\n\n    let vaultRef : \u0026FUSD.Vault?\n    let leases : \u0026FIND.LeaseCollection?\n    let price : UFix64\n\n    prepare(account: AuthAccount) {\n\n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n        //SYNC with register\n        //Add exising FUSD or create a new one and add it\n        let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n        if !fusdReceiver.check() {\n            let fusd \u003c- FUSD.createEmptyVault()\n            account.save(\u003c- fusd, to: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n        }\n\n        let usdcCap = account.getCapability\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e(FiatToken.VaultReceiverPubPath)\n        if !usdcCap.check() {\n            account.save( \u003c-FiatToken.createEmptyVault(), to: FiatToken.VaultStoragePath)\n            account.link\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e( FiatToken.VaultReceiverPubPath, target: FiatToken.VaultStoragePath)\n            account.link\u003c\u0026FiatToken.Vault{FiatToken.ResourceId}\u003e( FiatToken.VaultUUIDPubPath, target: FiatToken.VaultStoragePath)\n            account.link\u003c\u0026FiatToken.Vault{FungibleToken.Balance}\u003e( FiatToken.VaultBalancePubPath, target:FiatToken.VaultStoragePath)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let dandyCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        let dandyCapPrivate= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPrivatePath)\n        if !dandyCapPrivate.check() {\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        var created=false\n        var updated=false\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        if !profile.hasWallet(\"Flow\") {\n            let flowWallet=Profile.Wallet( name:\"Flow\", receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), tags: [\"flow\"])\n    \n            profile.addWallet(flowWallet)\n            updated=true\n        }\n        if !profile.hasWallet(\"FUSD\") {\n            profile.addWallet(Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), tags: [\"fusd\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if !profile.hasWallet(\"USDC\") {\n            profile.addWallet(Profile.Wallet( name:\"USDC\", receiver:usdcCap, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(FiatToken.VaultBalancePubPath), accept: Type\u003c@FiatToken.Vault\u003e(), tags: [\"usdc\", \"stablecoin\"]))\n            updated=true\n        }\n\n          //If find name not set and we have a profile set it.\n        if profile.getFindName() == \"\" {\n            profile.setFindName(name)\n            // If name is set, it will emit Updated Event, there is no need to emit another update event below. \n            updated=false\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else if updated {\n            profile.emitUpdatedEvent()\n        }\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let tenantCapability= FindMarket.getTenantCapability(FindMarket.getFindTenantAddress())!\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        let doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        let doeSalePublicPath=FindMarket.getPublicPath(doeSaleType, name: tenant.name)\n        let doeSaleStoragePath= FindMarket.getStoragePath(doeSaleType, name:tenant.name)\n        let doeSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n        if !doeSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n        }\n\n        let doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        let doeBidPublicPath=FindMarket.getPublicPath(doeBidType, name: tenant.name)\n        let doeBidStoragePath= FindMarket.getStoragePath(doeBidType, name:tenant.name)\n        let doeBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n        if !doeBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n        }\n\n        /// auctions that escrow ft\n        let aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        let aeSalePublicPath=FindMarket.getPublicPath(aeSaleType, name: tenant.name)\n        let aeSaleStoragePath= FindMarket.getStoragePath(aeSaleType, name:tenant.name)\n        let aeSaleCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n        if !aeSaleCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n        }\n\n        let dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\n        let dosSalePublicPath=FindMarket.getPublicPath(dosSaleType, name: tenant.name)\n        let dosSaleStoragePath= FindMarket.getStoragePath(dosSaleType, name:tenant.name)\n\n        let dosSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n        if !dosSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n        }\n\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n        if !dosBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n        }\n\n        let aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\n        let aeBidPublicPath=FindMarket.getPublicPath(aeBidType, name: tenant.name)\n        let aeBidStoragePath= FindMarket.getStoragePath(aeBidType, name:tenant.name)\n        let aeBidCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n        if !aeBidCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n        }\n\n     /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n        }\n\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n        if !asBidCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n        }\n\n        let leaseTenantCapability= FindMarket.getTenantCapability(FindMarket.getTenantAddress(\"findLease\")!)!\n\n        let leaseSaleItemType= Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()\n        let leasePublicPath=FindMarket.getPublicPath(leaseSaleItemType, name: \"findLease\")\n        let leaseStoragePath= FindMarket.getStoragePath(leaseSaleItemType, name:\"findLease\")\n        let leaseSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath) \n        if !leaseSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketSale.SaleItemCollection\u003e(\u003c- FindLeaseMarketSale.createEmptySaleItemCollection(leaseTenantCapability), to: leaseStoragePath)\n            account.link\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath, target: leaseStoragePath)\n        }\n\n        let leaseASSaleItemType= Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e()\n        let leaseASPublicPath=FindMarket.getPublicPath(leaseASSaleItemType, name: \"findLease\")\n        let leaseASStoragePath= FindMarket.getStoragePath(leaseASSaleItemType, name:\"findLease\")\n        let leaseASSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath) \n        if !leaseASSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseASStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath, target: leaseASStoragePath)\n        }\n\n\n        let leaseASBidType= Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e()\n        let leaseASBidPublicPath=FindMarket.getPublicPath(leaseASBidType, name: \"findLease\")\n        let leaseASBidStoragePath= FindMarket.getStoragePath(leaseASBidType, name: \"findLease\")\n        let leaseASBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath) \n        if !leaseASBidCap.check() {\n            account.save\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseASBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath, target: leaseASBidStoragePath)\n        }\n\n        // let leaseAESaleItemType= Type\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e()\n        // let leaseAEPublicPath=FindMarket.getPublicPath(leaseAESaleItemType, name: \"findLease\")\n        // let leaseAEStoragePath= FindMarket.getStoragePath(leaseAESaleItemType, name:\"findLease\")\n        // let leaseAESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath) \n        // if !leaseAESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseAEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath, target: leaseAEStoragePath)\n        // }\n\n        // let leaseAEBidType= Type\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e()\n        // let leaseAEBidPublicPath=FindMarket.getPublicPath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidStoragePath= FindMarket.getStoragePath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath) \n        // if !leaseAEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseAEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath, target: leaseAEBidStoragePath)\n        // }\n\n        let leaseDOSSaleItemType= Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e()\n        let leaseDOSPublicPath=FindMarket.getPublicPath(leaseDOSSaleItemType, name: \"findLease\")\n        let leaseDOSStoragePath= FindMarket.getStoragePath(leaseDOSSaleItemType, name:\"findLease\")\n        let leaseDOSSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath) \n        if !leaseDOSSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOSStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath, target: leaseDOSStoragePath)\n        }\n\n        let leaseDOSBidType= Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let leaseDOSBidPublicPath=FindMarket.getPublicPath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidStoragePath= FindMarket.getStoragePath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath) \n        if !leaseDOSBidCap.check() {\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOSBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath, target: leaseDOSBidStoragePath)\n        }\n\n        // let leaseDOESaleItemType= Type\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        // let leaseDOEPublicPath=FindMarket.getPublicPath(leaseDOESaleItemType, name: \"findLease\")\n        // let leaseDOEStoragePath= FindMarket.getStoragePath(leaseDOESaleItemType, name:\"findLease\")\n        // let leaseDOESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath) \n        // if !leaseDOESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath, target: leaseDOEStoragePath)\n        // }\n\n        // let leaseDOEBidType= Type\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        // let leaseDOEBidPublicPath=FindMarket.getPublicPath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidStoragePath= FindMarket.getStoragePath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath) \n        // if !leaseDOEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath, target: leaseDOEBidStoragePath)\n        // }\n        //SYNC with register\n\n        self.price=FIND.calculateCost(name)\n        log(\"The cost for registering this name is \".concat(self.price.toString()))\n        self.vaultRef = account.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault)\n        self.leases=account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from: FIND.LeaseStoragePath)\n    }\n\n    pre{\n        self.vaultRef != nil : \"Could not borrow reference to the fusdVault!\"\n        self.leases != nil : \"Could not borrow reference to find lease collection\"\n        self.price == amount : \"Calculated cost : \".concat(self.price.toString()).concat(\" does not match expected cost : \").concat(amount.toString())\n    }\n\n    execute{\n        let payVault \u003c- self.vaultRef!.withdraw(amount: self.price) as! @FUSD.Vault\n        self.leases!.register(name: name, vault: \u003c- payVault)\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "name": "String"
                  }
               }
            },
            "registerGift": {
               "code": "import FUSD from 0xe223d8a629e49c68\nimport Profile from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\n\ntransaction(name: String, amount: UFix64, recipient: String) {\n\n    let price : UFix64 \n    let vaultRef : \u0026FUSD.Vault? \n    let receiverLease : Capability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e\n    let receiverProfile : Capability\u003c\u0026{Profile.Public}\u003e\n    let leases : \u0026FIND.LeaseCollection?\n\n    prepare(acct: AuthAccount) {\n\n        let resolveAddress = FIND.resolve(recipient)\n        if resolveAddress == nil {panic(\"The input pass in is not a valid name or address. Input : \".concat(recipient))}\n        let address = resolveAddress!\n\n        self.price=FIND.calculateCost(name)\n        log(\"The cost for registering this name is \".concat(self.price.toString()))\n\n        self.vaultRef = acct.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault)\n\n        self.leases=acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from: FIND.LeaseStoragePath)\n\n        let receiver = getAccount(address)\n        self.receiverLease = receiver.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        self.receiverProfile = receiver.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\n    }\n\n    pre{\n        self.price == amount : \"Calculated cost : \".concat(self.price.toString()).concat(\" does not match expected cost\").concat(amount.toString())\n        self.vaultRef != nil : \"Cannot borrow reference to fusd Vault!\"\n        self.receiverLease.check() : \"Lease capability is invalid\"\n        self.receiverProfile.check() : \"Profile capability is invalid\"\n        self.leases != nil : \"Cannot borrow refernce to find lease collection\"\n    }\n\n    execute{\n        let payVault \u003c- self.vaultRef!.withdraw(amount: self.price) as! @FUSD.Vault\n        self.leases!.register(name: name, vault: \u003c- payVault)\n        self.leases!.move(name: name, profile: self.receiverProfile, to: self.receiverLease)\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "amount",
                     "recipient"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "name": "String",
                     "recipient": "String"
                  }
               }
            },
            "rejectNameDirectOffer": {
               "code": "import FIND from 0x35717efbbce11c74\n\ntransaction(names: [String]) {\n\n    let finLeases : \u0026FIND.LeaseCollection? \n\n    prepare(account: AuthAccount) {\n        self.finLeases= account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)\n    }\n\n    pre{\n        self.finLeases != nil : \"Cannot borrow reference to find lease collection\"\n    }\n\n    execute{\n        for name in names {\n            self.finLeases!.cancel(name)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "names"
                  ],
                  "parameters": {
                     "names": "[String]"
                  }
               }
            },
            "relistMarketListings": {
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FindMarketDirectOfferEscrow from 0x35717efbbce11c74\nimport FindMarketAuctionEscrow from 0x35717efbbce11c74\nimport FindMarketAuctionSoft from 0x35717efbbce11c74\nimport FindMarketDirectOfferSoft from 0x35717efbbce11c74\nimport FindMarketSale from 0x35717efbbce11c74\n\ntransaction(marketplace:Address, ids: {String : [UInt64]}) {\n    prepare(account: AuthAccount) {\n\n        let tenant=FindMarket.getTenant(marketplace)\n\n        var saleType = Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        if let ids = ids[FindMarket.getMarketOptionFromType(saleType)] {\n            let saleItems= account.borrow\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection\u003e(from: tenant.getStoragePath(saleType))!\n            for id in ids {\n                saleItems.relist(id)\n            }\n        }\n\n        saleType = Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        if let ids = ids[FindMarket.getMarketOptionFromType(saleType)] {\n            let saleItems= account.borrow\u003c\u0026FindMarketAuctionSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(saleType))!\n            for id in ids {\n                saleItems.relist(id)\n            }\n        }\n\n        saleType = Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        if let ids = ids[FindMarket.getMarketOptionFromType(saleType)] {\n            let saleItems= account.borrow\u003c\u0026FindMarketSale.SaleItemCollection\u003e(from: tenant.getStoragePath(saleType))!\n            for id in ids {\n                saleItems.relist(id)\n            }\n        }\n\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "ids"
                  ],
                  "parameters": {
                     "ids": "{String: [UInt64]}",
                     "marketplace": "Address"
                  }
               }
            },
            "removeCurratedCollection": {
               "code": "transaction(name: String) {\n    prepare(account: AuthAccount) {\n\n        let path=/storage/FindCuratedCollections\n        let publicPath=/public/FindCuratedCollections\n\n        var collections : {String: [String]} = {}\n        if account.borrow\u003c\u0026{String: [String]}\u003e(from:path) != nil {\n             collections=account.load\u003c{String: [String]}\u003e(from:path)!\n        }\n        collections.remove(key: name)\n        account.save(collections, to: path)\n        let link = account.getCapability\u003c\u0026{String: [String]}\u003e(publicPath)\n        if !link.check() {\n            account.link\u003c\u0026{String: [String]}\u003e( publicPath, target: path)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "removeMarketOption": {
               "code": "import FindMarket from 0x35717efbbce11c74\n\ntransaction(saleItemName: String){\n    \n    prepare(account: AuthAccount){\n        let path = FindMarket.TenantClientStoragePath\n        let tenantRef = account.borrow\u003c\u0026FindMarket.TenantClient\u003e(from: path) ?? panic(\"Cannot borrow Reference.\")\n\n        tenantRef.removeMarketOption(name: saleItemName)\n    }\n}",
               "spec": {
                  "order": [
                     "saleItemName"
                  ],
                  "parameters": {
                     "saleItemName": "String"
                  }
               }
            },
            "removeRelatedAccount": {
               "code": "import RelatedAccounts from 0x35717efbbce11c74\n\ntransaction(name: String){\n\n    var relatedAccounts : \u0026RelatedAccounts.Accounts?\n\n    prepare(account: AuthAccount) {\n\n        self.relatedAccounts= account.borrow\u003c\u0026RelatedAccounts.Accounts\u003e(from:RelatedAccounts.storagePath)\n        if self.relatedAccounts == nil {\n            let relatedAccounts \u003c- RelatedAccounts.createEmptyAccounts()\n            account.save(\u003c- relatedAccounts, to: RelatedAccounts.storagePath)\n            account.link\u003c\u0026RelatedAccounts.Accounts{RelatedAccounts.Public}\u003e(RelatedAccounts.publicPath, target: RelatedAccounts.storagePath)\n            self.relatedAccounts= account.borrow\u003c\u0026RelatedAccounts.Accounts\u003e(from:RelatedAccounts.storagePath)\n        }\n\n        let cap = account.getCapability\u003c\u0026RelatedAccounts.Accounts{RelatedAccounts.Public}\u003e(RelatedAccounts.publicPath)\n        if !cap.check() {\n            account.unlink(RelatedAccounts.publicPath)\n            account.link\u003c\u0026RelatedAccounts.Accounts{RelatedAccounts.Public}\u003e(RelatedAccounts.publicPath, target: RelatedAccounts.storagePath)\n        }\n\n    }\n\n    execute{\n        self.relatedAccounts!.deleteAccount(name: name)\n    }\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "removeTenantRule": {
               "code": "import FindMarket from 0x35717efbbce11c74\n\ntransaction(optionName: String, tenantRuleName: String){\n    prepare(account: AuthAccount){\n        let path = FindMarket.TenantClientStoragePath\n        let tenantRef = account.borrow\u003c\u0026FindMarket.TenantClient\u003e(from: path) ?? panic(\"Cannot borrow Reference.\")\n\n        tenantRef.removeTenantRule(optionName: optionName, tenantRuleName: tenantRuleName)\n    }\n}",
               "spec": {
                  "order": [
                     "optionName",
                     "tenantRuleName"
                  ],
                  "parameters": {
                     "optionName": "String",
                     "tenantRuleName": "String"
                  }
               }
            },
            "renewName": {
               "code": "import FUSD from 0xe223d8a629e49c68\nimport FIND from 0x35717efbbce11c74\n\ntransaction(name: String, amount: UFix64) {\n\n    let price : UFix64\n    let vaultRef : \u0026FUSD.Vault? \n    let finLeases : \u0026FIND.LeaseCollection? \n\n    prepare(acct: AuthAccount) {\n        self.price=FIND.calculateCost(name)\n        self.vaultRef = acct.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault)\n        self.finLeases= acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)\n    }\n\n    pre{\n        self.price == amount : \"expected renew cost : \".concat(self.price.toString()).concat(\" is not the same as calculated renew cost : \").concat(amount.toString())\n        self.vaultRef != nil : \"Could not borrow reference to the fusdVault!\"\n        self.finLeases != nil : \"Could not borrow reference to find lease collection\"\n    }\n\n    execute{\n        let payVault \u003c- self.vaultRef!.withdraw(amount: self.price) as! @FUSD.Vault\n        let finToken= self.finLeases!.borrow(name)\n        finToken.extendLease(\u003c- payVault)\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "name": "String"
                  }
               }
            },
            "retractOfferLeaseMarketDirectOfferSoft": {
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FindLeaseMarketDirectOfferSoft from 0x35717efbbce11c74\n\ntransaction(leaseName: String) {\n    let bidsReference: \u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection?\n\n    prepare(account: AuthAccount) {\n        let marketplace = FindMarket.getTenantAddress(\"findLease\")!\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e())\n        self.bidsReference= account.borrow\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(from: storagePath) \n    }\n\n    pre{\n        self.bidsReference != nil : \"Bid resource does not exist\"\n    }\n\n    execute {\n        self.bidsReference!.cancelBid(leaseName)\n    }\n}",
               "spec": {
                  "order": [
                     "leaseName"
                  ],
                  "parameters": {
                     "leaseName": "String"
                  }
               }
            },
            "retractOfferMarketDirectOfferEscrowed": {
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FindMarketDirectOfferEscrow from 0x35717efbbce11c74\n\ntransaction(marketplace:Address, id: UInt64) {\n    let bidsReference: \u0026FindMarketDirectOfferEscrow.MarketBidCollection? \n\n    prepare(account: AuthAccount) {\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e())\n        self.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection\u003e(from: storagePath) \n    }\n\n    pre{\n        self.bidsReference != nil : \"This account does not have a bid collection\"\n    }\n\n    execute {\n        self.bidsReference!.cancelBid(id)\n    }\n\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "retractOfferMarketDirectOfferSoft": {
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FindMarketDirectOfferSoft from 0x35717efbbce11c74\n\ntransaction(marketplace:Address, id: UInt64) {\n    let bidsReference: \u0026FindMarketDirectOfferSoft.MarketBidCollection?\n\n    prepare(account: AuthAccount) {\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n        self.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection\u003e(from: storagePath) \n    }\n\n    pre{\n        self.bidsReference != nil : \"Bid resource does not exist\"\n    }\n\n    execute {\n        self.bidsReference!.cancelBid(id)\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "sendCharity": {
               "code": "import NonFungibleToken from 0x631e88ae7f1d7c20\nimport CharityNFT from 0x35717efbbce11c74\n\n//mint an art and add it to a users collection\ntransaction(\n    id: UInt64,\n    recipient: Address\n) {\n    let receiverCap: Capability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e\n    let charityCollection: \u0026NonFungibleToken.Collection\n\n    prepare(account: AuthAccount) {\n        self.charityCollection =account.borrow\u003c\u0026NonFungibleToken.Collection\u003e(from: CharityNFT.CollectionStoragePath)!\n        self.receiverCap= getAccount(recipient).getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath)\n    }\n\n    pre{\n        self.receiverCap.check() : \"Receiver doesn't have receiving vault set up properly.\"\n    }\n\n    execute {\n        let nft \u003c- self.charityCollection.withdraw(withdrawID: id)\n        self.receiverCap.borrow()!.deposit(token: \u003c- nft)\n    }\n}",
               "spec": {
                  "order": [
                     "id",
                     "recipient"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "recipient": "Address"
                  }
               }
            },
            "sendDandy": {
               "code": "import FIND from 0x35717efbbce11c74\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport Dandy from 0x35717efbbce11c74\n\ntransaction(user: String, id: UInt64) {\n\n    let address : Address\n    let cap : Capability\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic}\u003e\n    let senderRef : \u0026Dandy.Collection\n\n    prepare(account: AuthAccount) {\n        self.address = FIND.resolve(user) ?? panic(\"Cannot find user with this name / address\")\n        self.cap = getAccount(self.address).getCapability\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n\n        self.senderRef = account.borrow\u003c\u0026Dandy.Collection\u003e(from: Dandy.CollectionStoragePath) ?? panic(\"Cannot borrow reference to sender Collection.\")\n    }\n\n    pre{\n        self.cap.check() : \"Cannot borrow reference to receiver Collection. Receiver account : \".concat(self.address.toString())\n        self.senderRef != nil : \"Cannot borrow reference to sender Collection.\"\n    }\n\n    execute{\n        self.cap.borrow()!.deposit(token: \u003c- self.senderRef!.withdraw(withdrawID: id))\n    }\n}",
               "spec": {
                  "order": [
                     "user",
                     "id"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "user": "String"
                  }
               }
            },
            "sendFT": {
               "code": "import FungibleToken from 0x9a0766d93b6608b7\nimport Sender from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\nimport FTRegistry from 0x35717efbbce11c74\n\n\ntransaction(name: String, amount: UFix64, ftAliasOrIdentifier: String, tag: String, message:String) {\n\n    var token : \u0026Sender.Token\n    let walletReference : \u0026FungibleToken.Vault? \n\n    prepare(account: AuthAccount) {\n\n        let ft = FTRegistry.getFTInfo(ftAliasOrIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftAliasOrIdentifier))\n        self.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath)\n\n        if account.borrow\u003c\u0026Sender.Token\u003e(from: Sender.storagePath) == nil {\n            account.save(\u003c- Sender.create(), to: Sender.storagePath)\n        }\n\n        self.token =account.borrow\u003c\u0026Sender.Token\u003e(from: Sender.storagePath)!\n    }\n\n    pre{\n        self.walletReference != nil : \"No suitable wallet linked for this account\"\n    }\n\n    execute{\n        let vault \u003c- self.walletReference!.withdraw(amount: amount)\n        FIND.depositWithTagAndMessage(to: name, message: message, tag: tag, vault: \u003c- vault, from: self.token)\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "amount",
                     "ftAliasOrIdentifier",
                     "tag",
                     "message"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "ftAliasOrIdentifier": "String",
                     "message": "String",
                     "name": "String",
                     "tag": "String"
                  }
               }
            },
            "sendFTWithTag": {
               "code": "import NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FlowToken from 0x7e60df042a9c0868\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FUSD from 0xe223d8a629e49c68\nimport Profile from 0x35717efbbce11c74\nimport Sender from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\nimport CharityNFT from 0x35717efbbce11c74\n\n\ntransaction(name: String, amount: UFix64, type: String, tag:String) {\n\n    prepare(account: AuthAccount) {\n\n        let stdCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath)\n        if !stdCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- CharityNFT.createEmptyCollection(), to: CharityNFT.CollectionStoragePath)\n            account.link\u003c\u0026{NonFungibleToken.CollectionPublic, MetadataViews.ResolverCollection}\u003e(CharityNFT.CollectionPublicPath, target: CharityNFT.CollectionStoragePath)\n        }\n\n        let charityCap = account.getCapability\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection)\n        if !charityCap.check() {\n            account.link\u003c\u0026{CharityNFT.CollectionPublic, MetadataViews.ResolverCollection}\u003e(/public/findCharityNFTCollection, target: CharityNFT.CollectionStoragePath)\n        }\n\n      let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n        if !fusdReceiver.check() {\n            let fusd \u003c- FUSD.createEmptyVault()\n            account.save(\u003c- fusd, to: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profileName = account.address.toString()\n\n            let profile \u003c-Profile.createUser(name:profileName, createdAt: \"find\")\n\n            let fusdWallet=Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), names: [\"fusd\", \"stablecoin\"])\n\n            profile.addWallet(fusdWallet)\n\n            let flowWallet=Profile.Wallet(\n                name:\"Flow\", \n                receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver),\n                balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance),\n                accept: Type\u003c@FlowToken.Vault\u003e(),\n                names: [\"flow\"]\n            )\n    \n            profile.addWallet(flowWallet)\n            profile.addCollection(Profile.ResourceCollection(\"FINDLeases\",leaseCollection, Type\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(), [\"find\", \"leases\"]))\n            profile.addCollection(Profile.ResourceCollection(\"FINDBids\", bidCollection, Type\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(), [\"find\", \"bids\"]))\n\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n        }\n\n        if account.borrow\u003c\u0026Sender.Token\u003e(from: Sender.storagePath) == nil {\n            account.save(\u003c- Sender.create(), to: Sender.storagePath)\n        }\n\n        let token =account.borrow\u003c\u0026Sender.Token\u003e(from: Sender.storagePath)!\n\n\n        if type == \"fusd\" {\n            let vaultRef = account.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault) ?? panic(\"Could not borrow reference to the fusdVault!\")\n            let vault \u003c- vaultRef.withdraw(amount: amount)\n            FIND.depositWithTagAndMessage(to: name, message: \"\", tag: tag, vault: \u003c- vault, from: token)\n            return \n        }\n\n        let vaultRef = account.borrow\u003c\u0026FlowToken.Vault\u003e(from: /storage/flowTokenVault) ?? panic(\"Could not borrow reference to the fusdVault!\")\n        let vault \u003c- vaultRef.withdraw(amount: amount)\n        FIND.depositWithTagAndMessage(to: name, message: \"\", tag: tag, vault: \u003c- vault, from: token)\n    }\n\n}",
               "spec": {
                  "order": [
                     "name",
                     "amount",
                     "type",
                     "tag"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "name": "String",
                     "tag": "String",
                     "type": "String"
                  }
               }
            },
            "sendNFTs": {
               "code": "import FINDNFTCatalog from 0x35717efbbce11c74\nimport NFTCatalog from 0x324c34e1c517e4db\nimport FindViews from 0x35717efbbce11c74\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FlowToken from 0x7e60df042a9c0868\nimport FIND from 0x35717efbbce11c74\nimport FindLostAndFoundWrapper from 0x82836e61c008d6d1\n\ntransaction(nftIdentifiers: [String], allReceivers: [String] , ids:[UInt64], memos: [String]) {\n\n    let pointers : [FindViews.AuthNFTPointer]\n    let nftInfos : [NFTCatalog.NFTCollectionData]\n    let flowVault : \u0026FungibleToken.Vault\n    let flowTokenRepayment : Capability\u003c\u0026FlowToken.Vault{FungibleToken.Receiver}\u003e\n\n    prepare(account: AuthAccount){\n\n        if allReceivers.length != nftIdentifiers.length || allReceivers.length != ids.length || allReceivers.length != memos.length {\n            panic(\"The length of arrays passed in are not equal\")\n        }\n\n        let pointers : [FindViews.AuthNFTPointer] = []\n        let nftInfos : {String : NFTCatalog.NFTCollectionData} = {}\n        self.nftInfos = []\n        let providerCaps : {String : Capability\u003c\u0026{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e} = {}\n\n\n        for i, id in ids {\n            if nftInfos[nftIdentifiers[i]] == nil {\n                let collections = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifiers[i]) ?? panic(\"NFT type is not supported at the moment. Type : \".concat(nftIdentifiers[i]))\n                nftInfos[nftIdentifiers[i]] = FINDNFTCatalog.getCatalogEntry(collectionIdentifier: collections.keys[0])!.collectionData\n            }\n            self.nftInfos.append(nftInfos[nftIdentifiers[i]]!)\n\n            if providerCaps[nftIdentifiers[i]] == nil {\n                // Initialize the providerCap if the user doesn't have one\n                var providerCap=account.getCapability\u003c\u0026{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e(self.nftInfos[i].privatePath)\n\n                if !providerCap.check() {\n                    let newCap = account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                        self.nftInfos[i].privatePath,\n                        target: self.nftInfos[i].storagePath\n                    )\n                    if newCap == nil {\n                        // If linking is not successful, we link it using finds custom link \n                        let pathIdentifier = self.nftInfos[i].privatePath.toString()\n                        let findPath = PrivatePath(identifier: pathIdentifier.slice(from: \"/private/\".length , upTo: pathIdentifier.length).concat(\"_FIND\"))!\n                        account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                            findPath,\n                            target: self.nftInfos[i].storagePath\n                        )\n                        providerCap = account.getCapability\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(findPath)\n                    }\n                }\n                providerCaps[nftIdentifiers[i]] = providerCap\n            }\n\n            let providerCap = providerCaps[nftIdentifiers[i]]!\n\n            pointers.append(FindViews.AuthNFTPointer(cap: providerCap, id: id))\n        }\n        self.pointers = pointers\n\n        // Get Vault for paying flow storage fee\n        self.flowVault = account.borrow\u003c\u0026FlowToken.Vault\u003e(from: /storage/flowTokenVault) ?? panic(\"Cannot borrow reference to sender's flow vault\")\n        self.flowTokenRepayment = account.getCapability\u003c\u0026FlowToken.Vault{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver) \n    }\n\n    execute{\n\n        for i , receiver in allReceivers {\n            FindLostAndFoundWrapper.depositNFT(\n                receiver: receiver,\n                collectionPublicPath: self.nftInfos[i].publicPath ,\n                item: self.pointers[i],\n                memo: memos[i],\n                storagePayment: self.flowVault,\n                flowTokenRepayment: self.flowTokenRepayment\n            )\n        }\n    \n    }\n\n\n}",
               "spec": {
                  "order": [
                     "nftIdentifiers",
                     "allReceivers",
                     "ids",
                     "memos"
                  ],
                  "parameters": {
                     "allReceivers": "[String]",
                     "ids": "[UInt64]",
                     "memos": "[String]",
                     "nftIdentifiers": "[String]"
                  }
               }
            },
            "setMainName": {
               "code": "import Profile from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\n\n\ntransaction(name: String) {\n\n    let leaseCollectionOwner : Capability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e\n    let profile : \u0026Profile.User\n\n    prepare(acct: AuthAccount) {\n        self.leaseCollectionOwner = acct.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        self.profile =acct.borrow\u003c\u0026Profile.User\u003e(from:Profile.storagePath)!\n    }\n\n    pre{\n        self.leaseCollectionOwner.check() : \"Not a find user\"\n        self.leaseCollectionOwner.borrow()!.getLease(name) != nil : \"You do not own this lease so you cannot set it as main name\"\n    }\n\n    execute{\n        self.profile.setFindName(name)\n    }\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "setMarketOptionFlowDandy": {
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FlowToken from 0x7e60df042a9c0868\nimport Dandy from 0x35717efbbce11c74\n\ntransaction(){\n    prepare(account: AuthAccount){\n        let path = FindMarket.TenantClientStoragePath\n        let tenantRef = account.borrow\u003c\u0026FindMarket.TenantClient\u003e(from: path) ?? panic(\"Cannot borrow Reference.\")\n\n        tenantRef.setMarketOption(name:\"FlowDandy\", cut: nil, rules:[\n            FindMarket.TenantRule(name:\"Flow\", types:[Type\u003c@FlowToken.Vault\u003e()], ruleType: \"ft\", allow: true),\n            FindMarket.TenantRule(name:\"Dandy\", types:[ Type\u003c@Dandy.NFT\u003e()], ruleType: \"nft\", allow: true)\n            ]\n        )\n    }\n}",
               "spec": {
                  "order": [],
                  "parameters": {}
               }
            },
            "setPrivateMode": {
               "code": "import Profile from 0x35717efbbce11c74\n\ntransaction(mode: Bool) {\n\n    let profile : \u0026Profile.User?\n\n    prepare(acct: AuthAccount) {\n        self.profile =acct.borrow\u003c\u0026Profile.User\u003e(from:Profile.storagePath)\n    }\n\n    pre{\n        self.profile != nil : \"Cannot borrow reference to profile\"\n    }\n\n    execute{\n        self.profile!.setPrivateMode(mode)\n        self.profile!.emitUpdatedEvent()\n    }\n}",
               "spec": {
                  "order": [
                     "mode"
                  ],
                  "parameters": {
                     "mode": "Bool"
                  }
               }
            },
            "setProfile": {
               "code": "import Profile from 0x35717efbbce11c74\n\ntransaction(avatar: String) {\n\n    let profile : \u0026Profile.User?\n\n    prepare(acct: AuthAccount) {\n        self.profile =acct.borrow\u003c\u0026Profile.User\u003e(from:Profile.storagePath)\n    }\n\n    pre{\n        self.profile != nil : \"Cannot borrow reference to profile\"\n    }\n\n    execute{\n        self.profile!.setAvatar(avatar)\n        self.profile!.emitUpdatedEvent()\n    }\n}",
               "spec": {
                  "order": [
                     "avatar"
                  ],
                  "parameters": {
                     "avatar": "String"
                  }
               }
            },
            "setRelatedAccount": {
               "code": "import RelatedAccounts from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\n\ntransaction(name: String, target: String) {\n\n    var relatedAccounts : \u0026RelatedAccounts.Accounts?\n    let address : Address?\n\n    prepare(account: AuthAccount) {\n\n\n        self.address = FIND.resolve(target)\n\n        self.relatedAccounts= account.borrow\u003c\u0026RelatedAccounts.Accounts\u003e(from:RelatedAccounts.storagePath)\n        if self.relatedAccounts == nil {\n            let relatedAccounts \u003c- RelatedAccounts.createEmptyAccounts()\n            account.save(\u003c- relatedAccounts, to: RelatedAccounts.storagePath)\n            account.link\u003c\u0026RelatedAccounts.Accounts{RelatedAccounts.Public}\u003e(RelatedAccounts.publicPath, target: RelatedAccounts.storagePath)\n            self.relatedAccounts= account.borrow\u003c\u0026RelatedAccounts.Accounts\u003e(from:RelatedAccounts.storagePath)\n        }\n\n        let cap = account.getCapability\u003c\u0026RelatedAccounts.Accounts{RelatedAccounts.Public}\u003e(RelatedAccounts.publicPath)\n        if !cap.check() {\n            account.unlink(RelatedAccounts.publicPath)\n            account.link\u003c\u0026RelatedAccounts.Accounts{RelatedAccounts.Public}\u003e(RelatedAccounts.publicPath, target: RelatedAccounts.storagePath)\n        }\n    }\n\n    pre{\n        self.address != nil : \"The input pass in is not a valid name or address. Input : \".concat(target)\n    }\n\n    execute{\n        self.relatedAccounts!.setFlowAccount(name: name, address: self.address!)\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "target"
                  ],
                  "parameters": {
                     "name": "String",
                     "target": "String"
                  }
               }
            },
            "setSellDandyRules": {
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FlowToken from 0x7e60df042a9c0868\nimport FUSD from 0xe223d8a629e49c68\nimport Dandy from 0x35717efbbce11c74\n\ntransaction(){\n    prepare(account: AuthAccount){\n        let path = FindMarket.TenantClientStoragePath\n        let tenantRef = account.borrow\u003c\u0026FindMarket.TenantClient\u003e(from: path) ?? panic(\"Cannot borrow Reference.\")\n\n        tenantRef.setMarketOption(name:\"FUSDDandy\", cut: nil, rules:[\n            FindMarket.TenantRule(name:\"FUSD\", types:[Type\u003c@FUSD.Vault\u003e()], ruleType: \"ft\", allow: true),\n            FindMarket.TenantRule(name:\"Dandy\", types:[ Type\u003c@Dandy.NFT\u003e()], ruleType: \"nft\", allow: true)\n            ]\n        )\n\n        tenantRef.setMarketOption(name:\"FlowDandy\", cut: nil, rules:[\n            FindMarket.TenantRule(name:\"Flow\", types:[Type\u003c@FlowToken.Vault\u003e()], ruleType: \"ft\", allow: true),\n            FindMarket.TenantRule(name:\"Dandy\", types:[ Type\u003c@Dandy.NFT\u003e()], ruleType: \"nft\", allow: true)\n            ]\n        )\n\n    }\n}",
               "spec": {
                  "order": [],
                  "parameters": {}
               }
            },
            "setTenantRuleFUSD": {
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FUSD from 0xe223d8a629e49c68\n\ntransaction(optionName: String){\n    prepare(account: AuthAccount){\n        let path = FindMarket.TenantClientStoragePath\n        let tenantRef = account.borrow\u003c\u0026FindMarket.TenantClient\u003e(from: path) ?? panic(\"Cannot borrow Reference.\")\n\n        tenantRef.setTenantRule(optionName: optionName, tenantRule:\n            FindMarket.TenantRule(name:\"FUSD\", types:[Type\u003c@FUSD.Vault\u003e()], ruleType: \"ft\", allow: true)\n        )\n    }\n}",
               "spec": {
                  "order": [
                     "optionName"
                  ],
                  "parameters": {
                     "optionName": "String"
                  }
               }
            },
            "startNameAuction": {
               "code": "import FIND from 0x35717efbbce11c74\n\ntransaction(name: String) {\n\n    let finLeases : \u0026FIND.LeaseCollection?\n\n    prepare(account: AuthAccount) {\n        self.finLeases= account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)\n    }\n\n    pre{\n        self.finLeases != nil : \"Cannot borrow reference to find lease collection\"\n    }\n\n    execute{\n        self.finLeases!.startAuction(name)\n    }\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "storeCuratedCollections": {
               "code": "transaction(collections: {String :  [String]}) {\n    prepare(account: AuthAccount) {\n\n        let path=/storage/FindCuratedCollections\n        let publicPath=/public/FindCuratedCollections\n\n        if account.borrow\u003c\u0026{String: [String]}\u003e(from:path) != nil {\n             account.load\u003c{String: [String]}\u003e(from:path)\n        }\n        account.save(collections, to: path)\n\n        let link = account.getCapability\u003c\u0026{String: [String]}\u003e(publicPath)\n        if !link.check() {\n            account.link\u003c\u0026{String: [String]}\u003e( publicPath, target: path)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "collections"
                  ],
                  "parameters": {
                     "collections": "{String: [String]}"
                  }
               }
            }
         }
      }
   }
}
