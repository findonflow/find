{
   "networks": {
      "emulator": {
         "scripts": {
            "batchParty": {
               "code": "import MetadataViews from  0xf8d6e0586b0a20c7\nimport PartyFavorz from 0xe03daebed8ca0615\n\npub fun main(users:[Address]) : AnyStruct {\n\n    let viewType= Type\u003cMetadataViews.Display\u003e()\n\n    let addressNames : {Address : [String]} = {}\n    let addresses:  {Address: [String] }={}\n    for  user in users {\n        let account=getAccount(user)\n        let aeraCap = account.getCapability\u003c\u0026PartyFavorz.Collection{MetadataViews.ResolverCollection}\u003e(\n            PartyFavorz.CollectionPublicPath\n        )\n        if !aeraCap.check() {\n            continue\n        }\n        let ref = aeraCap.borrow()!\n        let names : [String] = []\n        for id in ref.getIDs() {\n            let resolver=ref.borrowViewResolver(id: id)\n            if let display = MetadataViews.getDisplay(resolver) {\n                names.append(display.name)\n            }\n        }\n\n        addressNames[user]=names\n    }\n    return addressNames\n}",
               "spec": {
                  "order": [
                     "users"
                  ],
                  "parameters": {
                     "users": "[Address]"
                  }
               }
            },
            "getAllFindPackSaleDetails": {
               "code": "import FindPack from 0x179b6b1cb6755e31\nimport FTRegistry from 0x179b6b1cb6755e31\nimport MetadataViews from 0xf8d6e0586b0a20c7\n\npub fun main(packTypeName: String) : {UInt64 : Report} {\n    let packs = FindPack.getMetadataByName(packTypeName: packTypeName)\n    let packData : {UInt64 : Report} = {}\n    for packTypeId in packs.keys {\n        if let metadata = FindPack.getMetadataById(packTypeName: packTypeName, typeId: packTypeId) {\n            let packsLeft = FindPack.getPacksCollection(packTypeName: packTypeName, packTypeId: packTypeId).getPacksLeft()\n            packData[packTypeId] = Report(metadata, packsLeft: packsLeft)\n        }\n    }\n    return packData\n}\n\npub struct Report {\n        pub let name: String\n        pub let description: String\n\n        pub let thumbnailHash: String?\n        pub let thumbnailUrl:String?\n\n        pub let walletType: String\n        pub let walletAlias: String?\n\n        pub let openTime: UFix64\n        pub var saleEnded: Bool\n        pub let saleInfos: [SaleInfo]\n\n        pub let storageRequirement: UInt64\n        pub let collectionDisplay: MetadataViews.NFTCollectionDisplay\n\n        pub let itemTypes: [Type]\n\n        pub let extraData : {String : AnyStruct}\n        pub let packFields: {String : String}\n        pub let requiresReservation: Bool\n\n        pub let packsLeft : Int \n\n        init(_ md: FindPack.Metadata, packsLeft: Int) {\n            self.packsLeft = packsLeft\n            self.name=md.name\n            self.description=md.description\n            self.thumbnailHash=md.thumbnailHash\n            self.thumbnailUrl=md.thumbnailUrl\n            self.walletType=md.walletType.identifier\n            self.walletAlias=FTRegistry.getFTInfoByTypeIdentifier(md.walletType.identifier)?.alias\n            self.openTime=md.openTime\n            self.storageRequirement=md.storageRequirement\n            self.itemTypes=md.itemTypes\n            self.extraData=md.extraData\n            self.packFields=md.packFields\n            self.requiresReservation=md.requiresReservation\n            self.saleInfos=convertSaleInfo(md.saleInfos)\n            self.collectionDisplay=md.collectionDisplay\n            self.saleEnded=true\n            if self.packsLeft != 0 {\n                self.saleEnded=false\n            } else {\n                let currentTime = getCurrentBlock().timestamp\n                var saleEnded = true\n                for saleInfo in self.saleInfos{\n                    if saleInfo.endTime == nil || saleInfo.endTime! \u003e currentTime {\n                        saleEnded=true\n                        break\n                    }\n                }\n            }\n        }\n}\n\npub struct SaleInfo {\n        pub let name : String\n        pub let startTime : UFix64 \n        pub let endTime : UFix64?\n        pub let price : UFix64\n        pub let purchaseLimit : UInt64?\n        pub let purchaseRecord : {Address : UInt64}\n        pub let verifiers : [String]\n        pub let verifyAll : Bool \n\n        init(_ si: FindPack.SaleInfo) {\n            self.name=si.name\n            self.startTime=si.startTime\n            self.endTime=si.endTime\n            self.price=si.price\n            self.purchaseLimit=si.purchaseLimit\n            self.purchaseRecord=si.purchaseRecord\n\n            var verifierDesc : [String] = []\n            for verifier in si.verifiers {\n                verifierDesc.append(verifier.description)\n            }\n            self.verifiers=verifierDesc\n            self.verifyAll=si.verifyAll\n        }\n}\n\npub fun convertSaleInfo(_ info: [FindPack.SaleInfo]) : [SaleInfo] {\n    let res : [SaleInfo] = []\n    for i in info {\n        res.append(SaleInfo(i))\n    }\n    return res\n}",
               "spec": {
                  "order": [
                     "packTypeName"
                  ],
                  "parameters": {
                     "packTypeName": "String"
                  }
               }
            },
            "getAllNFTViews": {
               "code": "import MetadataViews from 0xf8d6e0586b0a20c7\nimport FINDNFTCatalog from 0x179b6b1cb6755e31\nimport FIND from 0x179b6b1cb6755e31\n\n//Fetch a single view from a nft on a given path\npub fun main(user: String, aliasOrIdentifier:String, id: UInt64) : {String : AnyStruct} {\n\n    let publicPath = getPublicPath(aliasOrIdentifier)\n    let resolveAddress = FIND.resolve(user) \n    if resolveAddress == nil {return {}}\n    let address = resolveAddress!\n\n    let pp = publicPath\n    let account = getAccount(address)\n    if account.balance == 0.0 {\n        return {}\n    }\n    let collection= account.getCapability(pp).borrow\u003c\u0026{MetadataViews.ResolverCollection}\u003e()!\n\n    let nft=collection.borrowViewResolver(id: id)\n    let view : {String : AnyStruct} = {}\n    for v in nft.getViews() {\n        if v != Type\u003cMetadataViews.NFTCollectionData\u003e() {\n            view[v.identifier] = nft.resolveView(v)\n        }\n    }\n    return view\n}\n\npub fun getPublicPath(_ nftIdentifier: String) : PublicPath {\n    let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier)) \n    let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n    return collection.collectionData.publicPath\n}",
               "spec": {
                  "order": [
                     "user",
                     "aliasOrIdentifier",
                     "id"
                  ],
                  "parameters": {
                     "aliasOrIdentifier": "String",
                     "id": "UInt64",
                     "user": "String"
                  }
               }
            },
            "getAllRelatedAccounts": {
               "code": "import FindRelatedAccounts from 0x179b6b1cb6755e31\n\npub fun main(user: Address) : {String : {String : [String]}} {\n    let account = getAccount(user)\n    let cap= account.getCapability\u003c\u0026FindRelatedAccounts.Accounts{FindRelatedAccounts.Public}\u003e(FindRelatedAccounts.publicPath)\n    let ref = cap.borrow()! \n    return ref.getAllRelatedAccounts()\n\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "Address"
                  }
               }
            },
            "getCatalog": {
               "code": "import NFTCatalog from 0xf8d6e0586b0a20c7\nimport FINDNFTCatalog from 0x179b6b1cb6755e31\n\npub fun main() : {String : NFTCatalog.NFTCatalogMetadata} {\n    return FINDNFTCatalog.getCatalog() \n}",
               "spec": {
                  "order": [],
                  "parameters": {}
               }
            },
            "getCatalogCollectionDisplay": {
               "code": "import MetadataViews from 0xf8d6e0586b0a20c7\nimport NFTCatalog from 0xf8d6e0586b0a20c7\nimport FINDNFTCatalog from 0x179b6b1cb6755e31\n\npub fun main(collectionIdentifier : String, type: String?) : NFTCatalogMetadata? {\n    if let catalog = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier) {\n        return NFTCatalogMetadata(\n            contractName : catalog.contractName, \n            contractAddress : catalog.contractAddress, \n            nftType: catalog.nftType, \n            collectionDisplay : catalog.collectionDisplay\n        )\n    }\n\n    // if we have type identifier here: loop thru the items in that specific type\n    // otherwise we just loop over the entire catalog to get the collection display\n    var types : [String] = FINDNFTCatalog.getCatalogTypeData().keys \n    if type != nil {\n        types = [type!]\n    }\n\n    for identifier in types {\n        if let collections : [String] = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: identifier)?.keys {\n            for ci in collections {\n                let catalog = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : ci)! \n                if catalog.collectionDisplay.name == collectionIdentifier {\n                    return NFTCatalogMetadata(\n                        contractName : catalog.contractName, \n                        contractAddress : catalog.contractAddress, \n                        nftType: catalog.nftType, \n                        collectionDisplay : catalog.collectionDisplay\n                    )\n                }\n            }\n        }\n    }\n\n    return nil\n}\n\npub struct NFTCatalogMetadata {\n    pub let contractName : String\n    pub let contractAddress : Address\n    pub let nftType: String\n    pub let collectionDisplay: MetadataViews.NFTCollectionDisplay\n\n    init (contractName : String, contractAddress : Address, nftType: Type, collectionDisplay : MetadataViews.NFTCollectionDisplay) {\n        self.contractName = contractName\n        self.contractAddress = contractAddress\n        self.nftType = nftType.identifier\n        self.collectionDisplay = collectionDisplay\n    }\n}",
               "spec": {
                  "order": [
                     "collectionIdentifier",
                     "type"
                  ],
                  "parameters": {
                     "collectionIdentifier": "String",
                     "type": "String?"
                  }
               }
            },
            "getCatalogEntry": {
               "code": "import NFTCatalog from 0xf8d6e0586b0a20c7\nimport FINDNFTCatalog from 0x179b6b1cb6755e31\n\npub fun main(collectionIdentifier : String) : NFTCatalog.NFTCatalogMetadata? {\n    return FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier) \n}",
               "spec": {
                  "order": [
                     "collectionIdentifier"
                  ],
                  "parameters": {
                     "collectionIdentifier": "String"
                  }
               }
            },
            "getCatalogTypeData": {
               "code": "import NFTCatalog from 0xf8d6e0586b0a20c7\nimport FINDNFTCatalog from 0x179b6b1cb6755e31\n\npub fun main() : {String : {String : Bool}} {\n    return FINDNFTCatalog.getCatalogTypeData() \n}",
               "spec": {
                  "order": [],
                  "parameters": {}
               }
            },
            "getCheckRoyalty": {
               "code": "import MetadataViews from 0xf8d6e0586b0a20c7\nimport FIND from 0x179b6b1cb6755e31\nimport FINDNFTCatalog from 0x179b6b1cb6755e31\n\npub fun main(name: String, id: UInt64, nftAliasOrIdentifier: String, viewIdentifier: String) : AnyStruct? {\n\n    let address =FIND.resolve(name)!\n\n    // Get collection public path from NFT Registry\n    let collectionPublicPath = getPublicPath(nftAliasOrIdentifier)\n    let collection= getAuthAccount(address).borrow\u003c\u0026{MetadataViews.ResolverCollection}\u003e(from: collectionPublicPath)!\n\n    let nft=collection.borrowViewResolver(id: id)\n    return nft.resolveView(CompositeType(viewIdentifier)!)\n}\n\npub fun getPublicPath(_ nftIdentifier: String) : StoragePath {\n    let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier)) \n    let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n    return collection.collectionData.storagePath\n}",
               "spec": {
                  "order": [
                     "name",
                     "id",
                     "nftAliasOrIdentifier",
                     "viewIdentifier"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "name": "String",
                     "nftAliasOrIdentifier": "String",
                     "viewIdentifier": "String"
                  }
               }
            },
            "getCollectionForType": {
               "code": "import NFTCatalog from 0xf8d6e0586b0a20c7\nimport FINDNFTCatalog from 0x179b6b1cb6755e31\n\npub fun main(nftTypeIdentifier : String) : {String : Bool}? {\n    return FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftTypeIdentifier)\n}",
               "spec": {
                  "order": [
                     "nftTypeIdentifier"
                  ],
                  "parameters": {
                     "nftTypeIdentifier": "String"
                  }
               }
            },
            "getCollectionIndex": {
               "code": "import MetadataViews from 0xf8d6e0586b0a20c7\nimport FINDNFTCatalog from 0x179b6b1cb6755e31\nimport FIND from 0x179b6b1cb6755e31\n\npub fun main(user: String) : {String : [UInt64]} {\n\n    if let address = FIND.resolve(user) {\n        var resultMap : {String : [UInt64]} = {}\n        let account = getAccount(address)\n        for nftInfo in FINDNFTCatalog.getCatalog().values {\n            let publicPath = nftInfo.collectionData.publicPath\n\n            if let subCollections = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftInfo.nftType.identifier) {\n                if subCollections.length \u003c 1 {\n                    continue\n                } else if subCollections.length == 1 {\n                    let collection = nftInfo.nftType.identifier\n                    let resolverCollectionCap= account.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(publicPath)\n                    if resolverCollectionCap.check() {\n                        let collection = resolverCollectionCap.borrow()!\n                        resultMap[nftInfo.collectionDisplay.name] = collection.getIDs()\n                    }\n                } else {\n                    let collection = nftInfo.nftType.identifier\n                    let resolverCollectionCap= account.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(publicPath)\n\n                    let array : [UInt64] = []\n                    if resolverCollectionCap.check() {\n                        let collection = resolverCollectionCap.borrow()!\n                        for id in collection.getIDs() {\n                            let vr = collection.borrowViewResolver(id: id)\n                            if let sc = vr.resolveView(Type\u003cMetadataViews.NFTCollectionDisplay\u003e()) {\n                                let scv = sc as! MetadataViews.NFTCollectionDisplay\n                                if scv.name == nftInfo.collectionDisplay.name {\n                                    array.append(id)\n                                }\n                            }\n                        }\n                    }\n                    resultMap[nftInfo.collectionDisplay.name] = array\n                }\n            } \n\n        }\n\n        return resultMap\n    }\n    return {}\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "getCuratedCollections": {
               "code": "pub fun main(address: Address) : \u0026{String: [String]}? {\n    let account=getAccount(address)\n\n    if account.balance == 0.0 {\n        return nil\n    }\n\n    let publicPath=/public/FindCuratedCollections\n    let link = account.getCapability\u003c\u0026{String: [String]}\u003e(publicPath)\n    if link.check() {\n        return link.borrow()\n    }\n    return nil\n}",
               "spec": {
                  "order": [
                     "address"
                  ],
                  "parameters": {
                     "address": "Address"
                  }
               }
            },
            "getDandiesIDsFor": {
               "code": "import Dandy from 0x179b6b1cb6755e31\nimport FIND from 0x179b6b1cb6755e31\n\npub fun main(user: String, minter: String) : [UInt64] {\n    let address = FIND.resolve(user)\n    if address == nil {\n        return []\n    }\n    let account = getAccount(address!)\n    if account.balance == 0.0 {\n        return []\n    }\n    let cap = account.getCapability\u003c\u0026Dandy.Collection{Dandy.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n    let ref = cap.borrow() ?? panic(\"Cannot borrow reference to Dandy Collection. Account address : \".concat(address!.toString()))\n\n    return ref.getIDsFor(minter: minter)\n}",
               "spec": {
                  "order": [
                     "user",
                     "minter"
                  ],
                  "parameters": {
                     "minter": "String",
                     "user": "String"
                  }
               }
            },
            "getDandiesMinters": {
               "code": "import Dandy from 0x179b6b1cb6755e31\nimport FIND from 0x179b6b1cb6755e31\n\npub fun main(user: String) : [String] {\n    let address = FIND.resolve(user)\n    if address == nil {\n        return []\n    }\n    let account = getAccount(address!)\n    if account.balance == 0.0 {\n        return []\n    }\n    let cap = account.getCapability\u003c\u0026Dandy.Collection{Dandy.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n    let ref = cap.borrow() ?? panic(\"Cannot borrow reference to Dandy Collection. Account address : \".concat(address!.toString()))\n\n    return ref.getMinters()\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "getFTInfo": {
               "code": "import FTRegistry from 0x179b6b1cb6755e31\n\npub fun main(aliasOrIdentifier: String) : FTRegistry.FTInfo?{\n\n    return FTRegistry.getFTInfo(aliasOrIdentifier)\n\n}",
               "spec": {
                  "order": [
                     "aliasOrIdentifier"
                  ],
                  "parameters": {
                     "aliasOrIdentifier": "String"
                  }
               }
            },
            "getFTInfoAll": {
               "code": "import FTRegistry from 0x179b6b1cb6755e31\n\npub fun main() : {String: FTRegistry.FTInfo}{\n\n    return FTRegistry.getFTInfoAll()\n\n}",
               "spec": {
                  "order": [],
                  "parameters": {}
               }
            },
            "getFindPackSaleDetailsWithUser": {
               "code": "import FindPack from 0x179b6b1cb6755e31\nimport FTRegistry from 0x179b6b1cb6755e31\nimport FlowStorageFees from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FIND from 0x179b6b1cb6755e31\n\npub fun main(packTypeName: String, packTypeId: UInt64, user: Address) : Report? {\n    if let metadata = FindPack.getMetadataById(packTypeName: packTypeName, typeId: packTypeId) {\n        let packsLeft = FindPack.getPacksCollection(packTypeName: packTypeName, packTypeId: packTypeId).getPacksLeft()\n        return Report(metadata, user: user, packsLeft:packsLeft)\n    }\n\n    return nil\n}\n\npub struct Report {\n        pub let name: String\n        pub let description: String\n\n        pub let thumbnailHash: String?\n        pub let thumbnailUrl:String?\n\n        pub let walletType: String\n        pub let walletAlias: String?\n\n        pub let openTime: UFix64\n\n        pub let storageRequirement: UInt64\n        pub let collectionDisplay: MetadataViews.NFTCollectionDisplay\n\n        pub let itemTypes: [Type]\n\n        pub let extraData : {String : AnyStruct}\n        pub let packFields: {String : String}\n        pub let requiresReservation: Bool\n        pub let storageFlowNeeded: UFix64? \n\n        pub let userQualifiedSale : UserSaleInfo?\n        pub let saleInfos: [SaleInfo]\n        pub let packsLeft : Int \n\n        init(_ md: FindPack.Metadata, user: Address, packsLeft: Int) {\n            self.packsLeft=packsLeft\n            self.name=md.name\n            self.description=md.description\n            self.thumbnailHash=md.thumbnailHash\n            self.thumbnailUrl=md.thumbnailUrl\n            self.walletType=md.walletType.identifier\n            self.walletAlias=FTRegistry.getFTInfoByTypeIdentifier(md.walletType.identifier)?.alias\n            self.openTime=md.openTime\n            self.storageRequirement=md.storageRequirement\n            self.itemTypes=md.itemTypes\n            self.extraData=md.extraData\n            self.packFields=md.packFields\n            self.requiresReservation=md.requiresReservation\n            self.userQualifiedSale=getSoonestQualifiedSale(md.saleInfos, user: user)\n            self.storageFlowNeeded=getRequiredFlow(md.storageRequirement, user: user)\n            self.collectionDisplay=md.collectionDisplay\n            self.saleInfos=convertSaleInfo(md.saleInfos)\n        }\n}\n\npub struct UserSaleInfo {\n        pub let name : String\n        pub let startTime : UFix64 \n        pub let endTime : UFix64?\n        pub let price : UFix64\n        pub let purchaseLimit : UInt64?\n        pub let userPurchaseRecord : UInt64\n        pub let canBuyNow : Bool\n\n        init(_ si: FindPack.SaleInfo, user: Address, timeStamp: UFix64) {\n            self.name=si.name\n            self.startTime=si.startTime\n            self.endTime=si.endTime\n            self.price=si.price\n            self.purchaseLimit=si.purchaseLimit\n            self.userPurchaseRecord=si.purchaseRecord[user] ?? 0\n            self.canBuyNow= si.startTime\u003c=timeStamp\n        }\n}\n\npub fun getSoonestQualifiedSale(_ infos: [FindPack.SaleInfo], user: Address) : UserSaleInfo? {\n    let res : [UserSaleInfo] = []\n    let currentTime = getCurrentBlock().timestamp\n    var availableOption : FindPack.SaleInfo? = nil \n    var soonestOption : FindPack.SaleInfo? = nil \n\n    // check for the sale option that is available to the user, and is with the lowest price\n    for info in infos {\n        if info.checkBuyable(addr: user, time: currentTime){\n            if availableOption == nil || availableOption!.price \u003e info!.price {\n                availableOption = info\n            }\n        } else {\n            let endTime = info.endTime ?? UFix64.max\n            if currentTime \u003e endTime {\n                continue\n            }\n\n    // if there is no option available, get the soonest option available to the user, again, lowest price\n            if info.checkBuyable(addr: user, time: info.startTime) {\n                if soonestOption == nil || soonestOption!.startTime \u003e info.startTime {\n                    soonestOption = info\n                } else if soonestOption!.startTime == info.startTime \u0026\u0026 soonestOption!.price \u003e info.price {\n                    soonestOption = info\n                }\n            }\n        }\n    }\n\n    if availableOption != nil {\n        return UserSaleInfo(availableOption!, user: user, timeStamp: currentTime)\n    } else if soonestOption != nil {\n        return UserSaleInfo(soonestOption!, user: user, timeStamp: currentTime)\n    }\n    return nil\n}\n\npub fun getRequiredFlow(_ requiresReservation: UInt64, user: Address) : UFix64? {\n\n    let account = getAccount(user)\n    if account.storageCapacity \u003e account.storageUsed {\n        if account.storageCapacity - account.storageUsed \u003e requiresReservation {\n            return nil\n        }\n    }\n    return FlowStorageFees.storageCapacityToFlow(FlowStorageFees.convertUInt64StorageBytesToUFix64Megabytes(account.storageUsed + requiresReservation))\n}\n\npub struct SaleInfo {\n        pub let name : String\n        pub let startTime : UFix64 \n        pub let endTime : UFix64?\n        pub let price : UFix64\n        pub let purchaseLimit : UInt64?\n        pub let purchaseRecord : {Address : UInt64}\n        pub let verifiers : [String]\n        pub let verifyAll : Bool \n\n        init(_ si: FindPack.SaleInfo) {\n            self.name=si.name\n            self.startTime=si.startTime\n            self.endTime=si.endTime\n            self.price=si.price\n            self.purchaseLimit=si.purchaseLimit\n            self.purchaseRecord=si.purchaseRecord\n\n            var verifierDesc : [String] = []\n            for verifier in si.verifiers {\n                verifierDesc.append(verifier.description)\n            }\n            self.verifiers=verifierDesc\n            self.verifyAll=si.verifyAll\n        }\n}\n\npub fun convertSaleInfo(_ info: [FindPack.SaleInfo]) : [SaleInfo] {\n    let res : [SaleInfo] = []\n    for i in info {\n        res.append(SaleInfo(i))\n    }\n    return res\n}",
               "spec": {
                  "order": [
                     "packTypeName",
                     "packTypeId",
                     "user"
                  ],
                  "parameters": {
                     "packTypeId": "UInt64",
                     "packTypeName": "String",
                     "user": "Address"
                  }
               }
            },
            "getFindThoughts": {
               "code": "import FindThoughts from 0x179b6b1cb6755e31\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FindViews from 0x179b6b1cb6755e31\nimport FindMarket from 0x179b6b1cb6755e31\nimport Profile from 0x179b6b1cb6755e31\nimport FIND from 0x179b6b1cb6755e31\n\npub fun main(addresses: [Address], ids: [UInt64]) : [Thought] {\n    let thoughts : [Thought] = [] \n\n    for i, address in addresses {\n        let account = getAccount(address) \n        let cap = account.getCapability\u003c\u0026{FindThoughts.CollectionPublic}\u003e(FindThoughts.CollectionPublicPath) \n        if !cap.check() {\n            continue\n        }\n        let ref = cap.borrow()! \n        let t = ref.borrowThoughtPublic(ids[i]) \n        thoughts.append(getThought(t, withQuote: true))\n        \n    }\n    return thoughts\n}\n\npub struct User {\n    pub var name: String?\n    pub let address: Address \n    pub let findName: String? \n    pub var avatar: String? \n    pub let reaction: String\n\n    init(address: Address, reaction: String){\n        self.name = nil\n        self.findName = FIND.reverseLookup(address)\n        self.avatar = nil\n        self.reaction = reaction\n        self.address = address \n        let profileCap = getAccount(address).getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if profileCap.check() {\n            let p = profileCap.borrow()!\n            self.name = p.getName()\n            self.avatar = p.getAvatar()\n        }    \n    }\n}\n\npub struct Thought {\n    pub let id: UInt64 \n    pub let creator: Address \n    pub let creatorName: String? \n    pub var creatorProfileName: String? \n    pub var creatorAvatar: String? \n    pub var header: String?\n    pub var body: String?\n    pub let created: UFix64? \n    pub var lastUpdated: UFix64?\n    pub let medias: {String : String}\n    pub let nft: [FindMarket.NFTInfo]\n    pub var tags: [String]\n    pub var reacted: {String : [User]}\n    pub var reactions: {String : Int}\n    pub var reactedUsers: {String : [String]}\n    pub var quotedThought: Thought?\n    pub let hidden: Bool?\n\n    init(id: UInt64 , creator: Address , creatorName: String? , creatorProfileName: String? , creatorAvatar: String? , header: String? , body: String? , created: UFix64? , lastUpdated: UFix64?, medias: {String : String}, nft: [FindMarket.NFTInfo], tags: [String], reacted: {String : [User]}, reactions: {String : Int}, reactedUsers: {String : [String]}, quotedThought: Thought?, hidden: Bool?) {\n        self.id = id\n        self.creator = creator\n        self.creatorName = creatorName\n        self.creatorProfileName = creatorProfileName\n        self.creatorAvatar = creatorAvatar\n        self.header = header\n        self.body = body\n        self.created = created\n        self.lastUpdated = lastUpdated\n        self.medias = medias\n        self.nft = nft\n        self.tags = tags\n        self.reacted = reacted\n        self.reactions = reactions\n        self.reactedUsers = reactedUsers\n        self.quotedThought = quotedThought\n        self.hidden = hidden\n    }\n}\n\npub fun getThought(_ t: \u0026{FindThoughts.ThoughtPublic}, withQuote: Bool) : Thought {\n\n        var creatorProfileName : String? = nil\n        var creatorAvatar : String? = nil \n        let profileCap = getAccount(t.creator).getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if profileCap.check() {\n            creatorProfileName = profileCap.borrow()!.getName()\n            creatorAvatar = profileCap.borrow()!.getAvatar()\n        }\n\n        let medias : {String : String} = {}\n        for m in t.medias {\n            medias[m.file.uri()] = m.mediaType\n        }\n\n        let nft : [FindMarket.NFTInfo] = [] \n        for n in t.nft {\n            let vr = n.getViewResolver() \n            nft.append(FindMarket.NFTInfo(vr, id: n.id, detail: true))\n        }\n\n        let reacted : {String : [User]} = {}\n        let reactedUsers : {String :[String]} = {}\n        for user in t.reacted.keys {\n            let reaction = t.reacted[user]!\n            let allReacted = reacted[reaction] ?? []\n            let u = User(address: user, reaction: reaction)\n\n            allReacted.append(u)\n            reacted[reaction] = allReacted\n\n            let preReactedUser = reactedUsers[reaction] ?? []\n            preReactedUser.append(u.name ?? u.address.toString())\n            reactedUsers[reaction] = preReactedUser\n        }\n\n        var quotedThought : Thought? = nil \n        if withQuote {\n            if let p = t.getQuotedThought() {\n                if let ref = p.borrowThoughtPublic() {\n                    quotedThought = getThought(ref, withQuote: false)\n                } else {\n                    let creator = p.owner()\n                    var qCreatorProfileName : String? = nil\n                    var qCreatorAvatar : String? = nil \n                    let qProfileCap = getAccount(creator).getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n                    if qProfileCap.check() {\n                        qCreatorProfileName = qProfileCap.borrow()!.getName()\n                        qCreatorAvatar = qProfileCap.borrow()!.getAvatar()\n                    }\n\n                    quotedThought = Thought(\n                        id: p.id , \n                        creator: creator  , \n                        creatorName: FIND.reverseLookup(creator) , \n                        creatorProfileName: qCreatorProfileName , \n                        creatorAvatar: qCreatorAvatar, \n                        header: nil, \n                        body: nil , \n                        created: nil, \n                        lastUpdated: nil, \n                        medias: {}, \n                        nft: [], \n                        tags: [], \n                        reacted: {}, \n                        reactions: {}, \n                        reactedUsers: {},\n                        quotedThought: nil, \n                        hidden: nil\n                    )\n                }\n            }\n        }\n\n        return Thought(\n            id: t.id , \n            creator: t.creator  , \n            creatorName: FIND.reverseLookup(t.creator) , \n            creatorProfileName: creatorProfileName , \n            creatorAvatar: creatorAvatar, \n            header: t.header , \n            body: t.body , \n            created: t.created, \n            lastUpdated: t.lastUpdated, \n            medias: medias, \n            nft: nft, \n            tags: t.tags, \n            reacted: reacted, \n            reactions: t.reactions, \n            reactedUsers: reactedUsers,\n            quotedThought: quotedThought,\n            hidden: t.getHide()\n        )\n\n}",
               "spec": {
                  "order": [
                     "addresses",
                     "ids"
                  ],
                  "parameters": {
                     "addresses": "[Address]",
                     "ids": "[UInt64]"
                  }
               }
            },
            "getItem": {
               "code": "import MetadataViews from 0xf8d6e0586b0a20c7\nimport FIND from 0x179b6b1cb6755e31\nimport FINDNFTCatalog from 0x179b6b1cb6755e31\n\npub struct MetadataCollectionItem {\n    pub let id:UInt64\n    pub let uuid:UInt64\n    pub let name: String\n    pub let description: String?\n    pub let image: String\n    pub let url: String\n    pub let contentType:String\n    pub let rarity:String\n    pub let minter:String?\n    pub let type:Type\n\n\n    init(id:UInt64, uuid:UInt64, name:String, description:String?, image:String, url:String, contentType: String, rarity: String, minter:String?, type:Type) {\n        self.id=id\n        self.uuid=uuid\n        self.name=name\n        self.description=description\n        self.minter=minter\n        self.url=url\n        self.type=type\n        self.image=image\n        self.contentType=contentType\n        self.rarity=rarity\n    }\n}\n\n\npub fun main(user: String, aliasOrIdentifier: String, id:UInt64) : MetadataCollectionItem?{\n\n    let publicPath = getPublicPath(aliasOrIdentifier)\n\n    let resolveAddress = FIND.resolve(user) \n    if resolveAddress == nil {return nil}\n    let address = resolveAddress!\n    let account=getAccount(address)\n    if account.balance == 0.0 {\n        return nil\n    }\n    let resolverCollectionCap= account.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(publicPath)\n    if !resolverCollectionCap.check() {\n        return nil\n    }\n\n    let collection = resolverCollectionCap.borrow()!\n    let nft = collection.borrowViewResolver(id: id)!\n\n    if let displayView = nft.resolveView(Type\u003cMetadataViews.Display\u003e()) {\n        let display = displayView as! MetadataViews.Display\n\n        var externalUrl=\"\"\n        if let externalUrlView = nft.resolveView(Type\u003cMetadataViews.ExternalURL\u003e()) {\n            let edvu= externalUrlView as! MetadataViews.ExternalURL\n            externalUrl=edvu.url\n        }\n        let item = MetadataCollectionItem(\n            id: id,\n            uuid: nft.uuid,\n            name: display.name,\n            description:display.description,\n            image: display.thumbnail.uri(),\n            url: externalUrl,\n            contentType: \"image\",\n            rarity: \"\",\n            minter: \"\",\n            type: nft.getType()\n        )\n        return item\n    }\n    return nil\n}\n\npub fun getPublicPath(_ nftIdentifier: String) : PublicPath {\n    let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier)) \n    let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n    return collection.collectionData.publicPath\n}",
               "spec": {
                  "order": [
                     "user",
                     "aliasOrIdentifier",
                     "id"
                  ],
                  "parameters": {
                     "aliasOrIdentifier": "String",
                     "id": "UInt64",
                     "user": "String"
                  }
               }
            },
            "getLeases": {
               "code": "import FIND from 0x179b6b1cb6755e31\n\npub fun main() : [FIND.NetworkLease] {\n    return FIND.getLeases()\n}",
               "spec": {
                  "order": [],
                  "parameters": {}
               }
            },
            "getListings": {
               "code": "import FindMarket from 0x179b6b1cb6755e31 \nimport FIND from 0x179b6b1cb6755e31 \n\npub fun main(marketplace:Address, user: String) : {String : FindMarket.SaleItemCollectionReport} {\n    let resolveAddress = FIND.resolve(user)\n    if resolveAddress == nil { return {}}\n    let address = resolveAddress!\n        return FindMarket.getSaleItemReport(tenant:marketplace, address: address, getNFTInfo:false)\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "user"
                  ],
                  "parameters": {
                     "marketplace": "Address",
                     "user": "String"
                  }
               }
            },
            "getLostAndFoundNFTs": {
               "code": "import LostAndFoundHelper from 0xf8d6e0586b0a20c7\nimport FindLostAndFoundWrapper from 0x179b6b1cb6755e31\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport FIND from 0x179b6b1cb6755e31\nimport FINDNFTCatalog from 0x179b6b1cb6755e31\n\npub fun main(user: String) : Report {\n\n    if let address = FIND.resolve(user) {\n        let runTimeType = Type\u003c@NonFungibleToken.NFT\u003e()\n\n        let ticketsInfo = FindLostAndFoundWrapper.getTickets(user: address, specificType: runTimeType)\n\n        let ticketIds : {String : [UInt64]} = {}\n        let NFTCatalogTicketInfo : {String : [LostAndFoundHelper.Ticket]} = {}\n        for type in ticketsInfo.keys {\n            // check if this type is in NFTCatalog\n            let nftCatalog = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: type)\n            var inNFTCatalog : Bool = true \n            if nftCatalog == nil {\n                inNFTCatalog = false\n            }\n\n            // append id in array\n            let id : [UInt64] = []\n            for ticket in ticketsInfo[type]! {\n                if ticket.ticketID != nil {\n                    id.append(ticket.ticketID!)\n                }\n            }\n            ticketIds[type] = id\n\n            // If it is in NFT Catalog, add it in NFTCatalogTicketInfo\n            if inNFTCatalog {\n                NFTCatalogTicketInfo[type] = ticketsInfo.remove(key: type)\n            }\n        }\n\n        return Report(nftCatalogTicketInfo : NFTCatalogTicketInfo, ticketInfo : ticketsInfo, ticketIds : ticketIds, error: nil)\n    }\n    return logErr(\"Cannot resolve user. User : \".concat(user))\n}\n\n\npub struct Report {\n\n    pub let nftCatalogTicketInfo : {String : [LostAndFoundHelper.Ticket]}\n    pub let ticketInfo : {String : [LostAndFoundHelper.Ticket]}\n    pub let ticketIds : {String : [UInt64]}\n    pub let error : String?\n\n    init(nftCatalogTicketInfo : {String : [LostAndFoundHelper.Ticket]}, ticketInfo : {String : [LostAndFoundHelper.Ticket]}, ticketIds : {String : [UInt64]}, error: String?) {\n        self.nftCatalogTicketInfo = nftCatalogTicketInfo\n        self.ticketInfo = ticketInfo\n        self.ticketIds = ticketIds\n        self.error = error\n    }\n}\n\npub fun logErr(_ err: String) : Report {\n    return Report(nftCatalogTicketInfo: {}, ticketInfo : {}, ticketIds : {} , error: err)\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "getLostAndFoundRedeemableNFTTypes": {
               "code": "import FindLostAndFoundWrapper from 0x179b6b1cb6755e31\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport FIND from 0x179b6b1cb6755e31\n\npub fun main(user: String) : Report {\n\n    if let address = FIND.resolve(user){\n        let type : Type = Type\u003c@NonFungibleToken.NFT\u003e()\n        return Report(nftTypes: typeToStringArray(FindLostAndFoundWrapper.getSpecificRedeemableTypes(user: address, specificType: type)), err: nil)\n    }\n    return logErr(\"cannot resolve user\")\n\n}\n\npub fun typeToStringArray(_ array: [Type]) : [String] {\n    let res : [String] = []\n    for type in array {\n        res.append(type.identifier)\n    }\n    return res\n}\n\npub struct Report {\n    pub let nftTypes : [String]\n    pub let err : String? \n\n    init(nftTypes : [String] , err : String? ) {\n        self.nftTypes = nftTypes\n        self.err = err\n    }\n}\n\npub fun logErr(_ err: String) : Report{\n    return Report(nftTypes: [], err: err)\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "getLostAndFoundRequiredStorageType": {
               "code": "import FindLostAndFoundWrapper from 0x179b6b1cb6755e31\nimport FINDNFTCatalog from 0x179b6b1cb6755e31\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FIND from 0x179b6b1cb6755e31\n\npub fun main(user: String) : Report {\n\n    if let address = FIND.resolve(user){\n        let runTimeType : Type = Type\u003c@NonFungibleToken.NFT\u003e()\n\n        let types = FindLostAndFoundWrapper.getSpecificRedeemableTypes(user: address, specificType: runTimeType)\n\n        let account = getAuthAccount(address)\n\n        let initiableStorage : [String] = []\n        let relinkableStorage : [String] = []\n        let initiatedStorage : [String] = []\n        let problematicStorage : [String] = []\n        let notSupportedType : [String] = []\n        for type in types {\n\n            let nftInfo = FINDNFTCatalog.getCollectionDataForType(nftTypeIdentifier: type.identifier)\n\n            if nftInfo == nil {\n                initiableStorage.append(type.identifier)\n                continue\n            }\n\n            let storageType = account.type(at: nftInfo!.storagePath)\n            if storageType == nil {\n                initiableStorage.append(type.identifier)\n                continue\n            } \n            \n            let storageTypeIdentifier = storageType!.identifier.slice(from: 0 , upTo: storageType!.identifier.length - \".Collection\".length)\n            let typeIdentifier = type.identifier.slice(from: 0 , upTo: type.identifier.length - \".NFT\".length)\n            if storageTypeIdentifier != typeIdentifier {\n                problematicStorage.append(type.identifier)\n            } else {\n\n                // check if relink needed\n                if account.getCapability\u003c\u0026{NonFungibleToken.Receiver, NonFungibleToken.CollectionPublic, MetadataViews.ResolverCollection}\u003e(nftInfo!.publicPath).check() {\n                    initiatedStorage.append(type.identifier)\n                } else {\n                    relinkableStorage.append(type.identifier)\n                }\n\n            }\n        }\n        return Report(initiableStorage: initiableStorage, relinkableStorage: relinkableStorage ,initiatedStorage: initiatedStorage, problematicStorage: problematicStorage, notSupportedType: notSupportedType, err: nil)\n    }\n    return logErr(\"cannot resolve user\")\n\n}\n\npub struct Report {\n\n    pub let initiableStorage : [String] \n    pub let relinkableStorage : [String]\n    pub let initiatedStorage : [String] \n    pub let problematicStorage : [String] \n    pub let notSupportedType : [String] \n\n    pub let err : String? \n\n    init(initiableStorage : [String] , relinkableStorage : [String] , initiatedStorage : [String], problematicStorage : [String] , notSupportedType : [String] , err : String? ) {\n        self.initiableStorage = initiableStorage\n        self.relinkableStorage = relinkableStorage\n        self.initiatedStorage = initiatedStorage\n        self.problematicStorage = problematicStorage\n        self.notSupportedType = notSupportedType\n        self.err = err\n    }\n\n}\n\npub fun logErr(_ err: String) : Report {\n    return Report(initiableStorage: [] , relinkableStorage : [] , initiatedStorage : [] , problematicStorage: [], notSupportedType: [], err: err)\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "getMarketBlockedNFT": {
               "code": "import FindMarket from 0x179b6b1cb6755e31 \n\npub fun main() : {String : [String] } {\n    let mapping : {String : [String] } = {}\n\n    let findAddress=FindMarket.getFindTenantAddress()\n    let tenantCap = FindMarket.getTenantCapability(findAddress)!\n    let tenantRef = tenantCap.borrow() ?? panic(\"This tenant is not set up. Tenant : \".concat(tenantCap.address.toString()))\n    let marketTypes = FindMarket.getSaleItemTypes()\n    for marketType in marketTypes {\n        let list : [String] = []\n        for type in tenantRef.getBlockedNFT(marketType: marketType) {\n            list.append(type.identifier)\n        }\n        mapping[FindMarket.getMarketOptionFromType(marketType)] = list\n    }\n\nreturn mapping\n}",
               "spec": {
                  "order": [],
                  "parameters": {}
               }
            },
            "getMetadataForBuyAddonDapper": {
               "code": "import FIND from 0x179b6b1cb6755e31\n\npub fun main(merchAccount: Address, name: String, addon:String, amount:UFix64) : PurchaseData {\n    let description = \"Purchase addon \".concat(addon).concat(\" for name :\").concat(name).concat(\" for Dapper Credit \").concat(amount.toString())\n    let imageURL = \"https://i.imgur.com/8W8NoO1.png\"\n\n    return PurchaseData(\n            id: 0, \n            name: name, \n            amount: amount, \n            description: description, \n            imageURL: imageURL\n            )\n\n\n}\n\npub struct PurchaseData {\n    pub let id: UInt64\n    pub let name: String\n    pub let amount: UFix64\n    pub let description: String\n    pub let imageURL: String\n\n    init(id: UInt64, name: String, amount: UFix64, description: String, imageURL: String) {\n        self.id = id\n        self.name = name\n        self.amount = amount\n        self.description = description\n        self.imageURL = imageURL\n    }\n}",
               "spec": {
                  "order": [
                     "merchAccount",
                     "name",
                     "addon",
                     "amount"
                  ],
                  "parameters": {
                     "addon": "String",
                     "amount": "UFix64",
                     "merchAccount": "Address",
                     "name": "String"
                  }
               }
            },
            "getMetadataForBuyLeaseForSaleDapper": {
               "code": "import FindMarket from 0x179b6b1cb6755e31\nimport FIND from 0x179b6b1cb6755e31\nimport Profile from 0x179b6b1cb6755e31\nimport DapperUtilityCoin from 0x01cf0e2f2f715450\nimport FindLeaseMarketSale from 0x179b6b1cb6755e31\nimport FindLeaseMarket from 0x179b6b1cb6755e31\n\npub fun main(sellerAccount: Address, leaseName: String, amount: UFix64) :PurchaseData{\n\n    let address = FIND.resolve(leaseName) ?? panic(\"The address input is not a valid name nor address. Input : \".concat(leaseName))\n    let leaseMarketplace = FindMarket.getFindTenantAddress()\n    let leaseTenant = FindMarket.getTenant(leaseMarketplace)\n    let storagePath = leaseTenant.getStoragePath(Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e())\n    let saleItemRef = getAuthAccount(address).borrow\u003c\u0026FindLeaseMarketSale.SaleItemCollection\u003e(from: storagePath) ?? panic(\"Cannot borrow reference to sale item\")\n    let saleItem = saleItemRef.borrow(leaseName)\n\n    let description = \"Name :\".concat(leaseName).concat(\" for Dapper Credit \").concat(amount.toString())\n    let imageURL = \"https://i.imgur.com/8W8NoO1.png\"\n\n    return PurchaseData(\n            id: saleItem.getId(),\n            name: leaseName,\n            amount: amount,\n            description: description,\n            imageURL: imageURL\n            )\n}\n\npub struct PurchaseData {\n    pub let id: UInt64\n    pub let name: String\n    pub let amount: UFix64\n    pub let description: String\n    pub let imageURL: String\n\n    init(id: UInt64, name: String, amount: UFix64, description: String, imageURL: String) {\n        self.id = id\n        self.name = name\n        self.amount = amount\n        self.description = description\n        self.imageURL = imageURL\n    }\n}",
               "spec": {
                  "order": [
                     "sellerAccount",
                     "leaseName",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "leaseName": "String",
                     "sellerAccount": "Address"
                  }
               }
            },
            "getMetadataForBuyNFTForSaleDapper": {
               "code": "import FindMarket from 0x179b6b1cb6755e31\nimport FindMarketSale from 0x179b6b1cb6755e31\n\n\npub fun main(address: Address, marketplace:Address, id: UInt64, amount: UFix64) : PurchaseData {\n\n    let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketSale.SaleItemCollection\u003e())\n    let item= FindMarket.assertOperationValid(tenant: marketplace, address: address, marketOption: marketOption, id: id)\n    let display = item.getDisplay()\n    let itemID = item.getItemID()\n    let amount = item.getBalance()\n\n\n    return PurchaseData(\n        id: itemID,\n        name: display.name,\n        amount: amount,\n        description: display.description,\n        imageURL: display.thumbnail.uri()\n    )\n}\n\npub struct PurchaseData {\n    pub let id: UInt64\n    pub let name: String\n    pub let amount: UFix64\n    pub let description: String\n    pub let imageURL: String\n\n    init(id: UInt64, name: String, amount: UFix64, description: String, imageURL: String) {\n        self.id = id\n        self.name = name\n        self.amount = amount\n        self.description = description\n        self.imageURL = imageURL\n    }\n}",
               "spec": {
                  "order": [
                     "address",
                     "marketplace",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "address": "Address",
                     "amount": "UFix64",
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "getMetadataForRegisterDapper": {
               "code": "import FIND from 0x179b6b1cb6755e31\n\npub fun main(merchAccount: Address, name: String, amount: UFix64) : PurchaseData {\n\n    let description = \"Name :\".concat(name).concat(\" for Dapper Credit \").concat(amount.toString())\n    let imageURL = \"https://ik.imagekit.io/xyvsisxky/tr:ot-\".concat(name).concat(\",ots-55,otc-58B792,ox-N166,oy-N24,ott-b/https://i.imgur.com/8W8NoO1.png\")\n\n    return PurchaseData(\n            id: 0, \n            name: name, \n            amount: amount, \n            description: description, \n            imageURL: imageURL\n            )\n\n}\n\npub struct PurchaseData {\n    pub let id: UInt64\n    pub let name: String\n    pub let amount: UFix64\n    pub let description: String\n    pub let imageURL: String\n\n    init(id: UInt64, name: String, amount: UFix64, description: String, imageURL: String) {\n        self.id = id\n        self.name = name\n        self.amount = amount\n        self.description = description\n        self.imageURL = imageURL\n    }\n}",
               "spec": {
                  "order": [
                     "merchAccount",
                     "name",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "merchAccount": "Address",
                     "name": "String"
                  }
               }
            },
            "getMetadataForRenewNameDapper": {
               "code": "import FIND from 0x179b6b1cb6755e31\n\npub fun main(merchAccount: Address, name: String, amount: UFix64) : PurchaseData {\n\n    let description = \"Renew name :\".concat(name).concat(\" for Dapper Credit \").concat(amount.toString())\n    let imageURL = \"https://ik.imagekit.io/xyvsisxky/tr:ot-\".concat(name).concat(\",ots-55,otc-58B792,ox-N166,oy-N24,ott-b/https://i.imgur.com/8W8NoO1.png\")\n\n    return PurchaseData(\n            id: 0, \n            name: name, \n            amount: amount, \n            description: description, \n            imageURL: imageURL\n            )\n}\n\npub struct PurchaseData {\n    pub let id: UInt64\n    pub let name: String\n    pub let amount: UFix64\n    pub let description: String\n    pub let imageURL: String\n\n    init(id: UInt64, name: String, amount: UFix64, description: String, imageURL: String) {\n        self.id = id\n        self.name = name\n        self.amount = amount\n        self.description = description\n        self.imageURL = imageURL\n    }\n}",
               "spec": {
                  "order": [
                     "merchAccount",
                     "name",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "merchAccount": "Address",
                     "name": "String"
                  }
               }
            },
            "getMetadataForSaleItem": {
               "code": "import FindMarketSale from 0x179b6b1cb6755e31\n\npub struct PurchaseData {\n    pub let id: UInt64\n    pub let name: String\n    pub let amount: UFix64\n    pub let description: String\n    pub let imageURL: String\n\n    init(id: UInt64, name: String, amount: UFix64, description: String, imageURL: String) {\n        self.id = id\n        self.name = name\n        self.amount = amount\n        self.description = description\n        self.imageURL = imageURL\n    }\n}\npub fun main(merchantAddress: Address, marketplace:Address, address: Address, id: UInt64, amount: UFix64) : PurchaseData{\n    let saleItemsCap= FindMarketSale.getSaleItemCapability(marketplace: marketplace, user:address) ?? panic(\"cannot find sale item cap\")\n    let saleItemCollection = saleItemsCap.borrow()!\n    let item = saleItemCollection.borrowSaleItem(id)\n\n    let display = item.getDisplay()\n\n    var thumbnail = replacePrefix(display.thumbnail.uri(), prefix: \"ipfs://\", replace:\"https://find.mypinata.clloud/ipfs/\")\n    return PurchaseData(\n        id: id, \n        name: display.name, \n        amount: amount,\n        description: display.description, \n        imageURL: thumbnail\n    )\n}\n\npub fun replacePrefix(_ original: String, prefix:String, replace:String) : String {\n    if original.length \u003c prefix.length  {\n        return original\n    }\n    let oprefix = original.slice(from:0, upTo:prefix.length)\n    if oprefix != prefix {\n        return original\n    }\n    let rest = original.slice(from:prefix.length, upTo: original.length)\n    return replace.concat(rest)\n}",
               "spec": {
                  "order": [
                     "merchantAddress",
                     "marketplace",
                     "address",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "address": "Address",
                     "amount": "UFix64",
                     "id": "UInt64",
                     "marketplace": "Address",
                     "merchantAddress": "Address"
                  }
               }
            },
            "getNFTCatalogIDs": {
               "code": "import MetadataViews from 0xf8d6e0586b0a20c7\nimport FIND from 0x179b6b1cb6755e31\nimport FINDNFTCatalog from 0x179b6b1cb6755e31\n\npub fun main(user: String, collections: [String]) : {String : ItemReport} {\n    return fetchNFTCatalog(user: user, targetCollections:collections)\n}\n\npub struct ItemReport {\n    pub let length : Int // mapping of collection to no. of ids \n    pub let extraIDs : [UInt64]\n    pub let shard : String \n    pub let extraIDsIdentifier : String \n    pub let collectionName: String\n\n    init(length : Int, extraIDs :[UInt64] , shard: String, extraIDsIdentifier: String, collectionName: String) {\n        self.length=length \n        self.extraIDs=extraIDs\n        self.shard=shard\n        self.extraIDsIdentifier=extraIDsIdentifier\n        self.collectionName=collectionName\n    }\n}\n\npub struct NFTView {\n    pub let id: UInt64\n    pub let display: MetadataViews.Display?\n    pub let editions: MetadataViews.Editions?\n    pub let collectionDisplay: MetadataViews.NFTCollectionDisplay?\n    pub let nftType: Type\n\n    init(\n        id : UInt64,\n        display : MetadataViews.Display?,\n        editions : MetadataViews.Editions?,\n        collectionDisplay: MetadataViews.NFTCollectionDisplay?,\n        nftType: Type\n    ) {\n        self.id = id\n        self.display = display\n        self.editions = editions\n        self.collectionDisplay = collectionDisplay\n        self.nftType = nftType\n    }\n}\n\npub struct NFTIDs {\n    pub let ids: [UInt64]\n    pub let collectionName: String \n\n    init(ids: [UInt64], collectionName: String ) {\n        self.ids = ids\n        self.collectionName = collectionName\n    }\n}\n\n// Helper function \n\npub fun resolveAddress(user: String) : Address? {\n    return FIND.resolve(user)\n}\n\npub fun getNFTIDs(ownerAddress: Address) : {String : NFTIDs} {\n\n    let account = getAuthAccount(ownerAddress)\n\n    if account.balance == 0.0 {\n        return {}\n    }\n\n    let inventory : {String:NFTIDs}={}\n    let types = FINDNFTCatalog.getCatalogTypeData()\n    for nftType in types.keys {\n\n        let typeData=types[nftType]!\n        let collectionKey=typeData.keys[0]\n        let catalogEntry = FINDNFTCatalog.getCatalogEntry(collectionIdentifier:collectionKey)!\n\n        var collectionName = collectionKey\n        if typeData.length == 1 {\n            collectionName = catalogEntry.collectionDisplay.name\n        }\n\n        let storagePath = catalogEntry.collectionData.storagePath\n        let ref= account.borrow\u003c\u0026{MetadataViews.ResolverCollection}\u003e(from: storagePath)\n        if ref != nil {\n            inventory[collectionKey] = NFTIDs(ids: ref!.getIDs(), collectionName: collectionName)\n        }\n\n    }\n    return inventory\n}\n\npub fun fetchNFTCatalog(user: String, targetCollections: [String]) : {String : ItemReport} {\n    let source = \"NFTCatalog\"\n    let account = resolveAddress(user: user)\n    if account == nil { return {} }\n\n\n    let extraIDs = getNFTIDs(ownerAddress: account!)\n    let inventory : {String : ItemReport} = {}\n    var fetchedCount : Int = 0\n\n    for project in extraIDs.keys {\n\n        let catalogEntry = FINDNFTCatalog.getCatalogEntry(collectionIdentifier:project)!\n        let projectName = catalogEntry.contractName\n\n        if extraIDs[project]! == nil || extraIDs[project]!.ids.length \u003c 1{\n            extraIDs.remove(key: project)\n            continue\n        }\n        \n        let collectionLength = extraIDs[project]!.ids.length\n\n        // by pass if this is not the target collection\n        if targetCollections.length \u003e 0 \u0026\u0026 !targetCollections.contains(project) {\n            // inventory[project] = ItemReport(length : collectionLength, extraIDs :extraIDs[project]! , shard: source)\n            continue\n        }\n\n        inventory[catalogEntry.contractName] = ItemReport(length : collectionLength, extraIDs :extraIDs[project]?.ids ?? [] , shard: source, extraIDsIdentifier: project, collectionName: extraIDs[project]!.collectionName)\n\n    }\n\n    return inventory\n\n}",
               "spec": {
                  "order": [
                     "user",
                     "collections"
                  ],
                  "parameters": {
                     "collections": "[String]",
                     "user": "String"
                  }
               }
            },
            "getNFTCatalogItems": {
               "code": "import MetadataViews from 0xf8d6e0586b0a20c7\nimport FIND from 0x179b6b1cb6755e31\nimport FindViews from 0x179b6b1cb6755e31\n\nimport FINDNFTCatalog from 0x179b6b1cb6755e31\n\npub fun main(user: String, collectionIDs: {String : [UInt64]}) : {String : [MetadataCollectionItem]} {\n    return fetchNFTCatalog(user: user, collectionIDs: collectionIDs)\n}\n\npub struct NFTView {\n    pub let id: UInt64\n    pub let display: MetadataViews.Display?\n    pub let edition: UInt64?\n    pub let collectionDisplay: MetadataViews.NFTCollectionDisplay?\n    pub let soulBounded: Bool\n    pub let nftType: Type\n\n    init(\n        id : UInt64,\n        display : MetadataViews.Display?,\n        edition : UInt64?,\n        collectionDisplay: MetadataViews.NFTCollectionDisplay?,\n        soulBounded: Bool ,\n        nftType: Type\n    ) {\n        self.id = id\n        self.display = display\n        self.edition = edition\n        self.collectionDisplay = collectionDisplay\n        self.soulBounded = soulBounded\n        self.nftType = nftType\n    }\n}\n\npub fun getNFTs(ownerAddress: Address, ids: {String : [UInt64]}) : [NFTView] {\n\n    let account = getAuthAccount(ownerAddress)\n\n    if account.balance == 0.0 {\n        return []\n    }\n\n    let results : [NFTView] = []\n    for collectionKey in ids.keys {\n        let catalogEntry = FINDNFTCatalog.getCatalogEntry(collectionIdentifier:collectionKey)!\n        let storagePath = catalogEntry.collectionData.storagePath\n        let ref= account.borrow\u003c\u0026{MetadataViews.ResolverCollection}\u003e(from: storagePath)\n        if ref != nil{\n            for id in ids[collectionKey]! {\n                // results.append(MetadataViews.getNFTView(id:id, viewResolver: ref!.borrowViewResolver(id:id)!))\n                let viewResolver = ref!.borrowViewResolver(id:id)!\n\n                var e : UInt64? = nil\n                if let editions =  MetadataViews.getEditions(viewResolver) {\n                    if editions.infoList.length \u003e 0 {\n                        e = editions.infoList[0].number\n                    }\n                }\n\n                if let v = viewResolver.resolveView(Type\u003cMetadataViews.Edition\u003e()) {\n                    if let edition = v as? MetadataViews.Edition {\n                        e = edition.number\n                    }\n                }\n\n                results.append(\n                    NFTView(\n                        id : id,\n                        display: MetadataViews.getDisplay(viewResolver),\n                        edition : e,\n                        collectionDisplay : MetadataViews.getNFTCollectionDisplay(viewResolver),\n                        soulBounded : FindViews.checkSoulBound(viewResolver),\n                        nftType : viewResolver.getType()\n                    )\n                )\n            }\n        }\n    }\n    return results\n}\n\npub struct CollectionReport {\n    pub let items : {String : [MetadataCollectionItem]}\n    pub let collections : {String : Int} // mapping of collection to no. of ids\n    pub let extraIDs : {String : [UInt64]}\n\n    init(items: {String : [MetadataCollectionItem]},  collections : {String : Int}, extraIDs : {String : [UInt64]} ) {\n        self.items=items\n        self.collections=collections\n        self.extraIDs=extraIDs\n    }\n}\n\npub struct MetadataCollectionItem {\n    pub let id:UInt64\n    pub let name: String\n    pub let edition: UInt64?\n    pub let collection: String // \u003c- This will be Alias unless they want something else\n    pub let subCollection: String? // \u003c- This will be Alias unless they want something else\n    pub let nftDetailIdentifier: String\n    pub let soulBounded: Bool\n\n    pub let media  : String\n    pub let mediaType : String\n    pub let source : String\n\n    init(id:UInt64, name: String, edition: UInt64?, collection: String, subCollection: String?, media  : String, mediaType : String, source : String, nftDetailIdentifier: String, soulBounded: Bool ) {\n        self.id=id\n        self.name=name\n        self.edition=edition\n        self.collection=collection\n        self.subCollection=subCollection\n        self.media=media\n        self.mediaType=mediaType\n        self.source=source\n        self.nftDetailIdentifier=nftDetailIdentifier\n        self.soulBounded=soulBounded\n    }\n}\n\n// Helper function\n\npub fun resolveAddress(user: String) : PublicAccount? {\n    let address = FIND.resolve(user)\n    if address == nil {\n        return nil\n    }\n    return getAccount(address!)\n}\n\n\n//////////////////////////////////////////////////////////////\n// Fetch Specific Collections in FIND Catalog\n//////////////////////////////////////////////////////////////\npub fun fetchNFTCatalog(user: String, collectionIDs: {String : [UInt64]}) : {String : [MetadataCollectionItem]} {\n    let source = \"NFTCatalog\"\n    let account = resolveAddress(user: user)\n    if account == nil { return {} }\n\n    let items : {String : [MetadataCollectionItem]} = {}\n\n    let fetchingIDs = collectionIDs\n\n\n    for project in fetchingIDs.keys {\n\n        let catalogEntry = FINDNFTCatalog.getCatalogEntry(collectionIdentifier:project)!\n        let projectName = catalogEntry.contractName\n\n        let returnedNFTs = getNFTs(ownerAddress: account!.address, ids: {project : fetchingIDs[project]!})\n\n        var collectionItems : [MetadataCollectionItem] = []\n        for nft in returnedNFTs {\n            if nft == nil {\n                continue\n            }\n\n            var subCollection = \"\"\n            if project != nft.collectionDisplay!.name {\n             subCollection = nft.collectionDisplay!.name\n            }\n\n            var name = nft.display!.name\n            if name == \"\" {\n                name = projectName\n            }\n\n            let item = MetadataCollectionItem(\n                id: nft.id,\n                name: name,\n                edition: nft.edition,\n                collection: project,\n                subCollection: subCollection,\n                media: nft.display!.thumbnail.uri(),\n                mediaType: \"image/png\",\n                source: source,\n                nftDetailIdentifier: nft.nftType.identifier,\n                soulBounded: nft.soulBounded\n            )\n            collectionItems.append(item)\n        }\n\n        if collectionItems.length \u003e 0 {\n            items[project] = collectionItems\n        }\n    }\n    return items\n}",
               "spec": {
                  "order": [
                     "user",
                     "collectionIDs"
                  ],
                  "parameters": {
                     "collectionIDs": "{String: [UInt64]}",
                     "user": "String"
                  }
               }
            },
            "getNFTCatalogItemsWithMetadata": {
               "code": "import MetadataViews from 0xf8d6e0586b0a20c7\nimport FIND from 0x179b6b1cb6755e31\nimport FindViews from 0x179b6b1cb6755e31\n\nimport FINDNFTCatalog from 0x179b6b1cb6755e31\n\npub fun main(user: String, collectionIDs: {String : [UInt64]}) : {String : [MetadataCollectionItem]} {\n    return fetchNFTCatalog(user: user, collectionIDs: collectionIDs)\n}\n\npub struct NFTView {\n    pub let id: UInt64\n    pub let display: MetadataViews.Display?\n    pub let collectionDisplay: MetadataViews.NFTCollectionDisplay?\n    pub var rarity:MetadataViews.Rarity?\n    pub var editions: MetadataViews.Editions?\n    pub var serial: UInt64?\n    pub var traits: MetadataViews.Traits?\n    pub let soulBounded: Bool \n    pub let nftType: Type\n\n    init(\n        id : UInt64,\n        display : MetadataViews.Display?,\n        editions : MetadataViews.Editions?,\n        rarity:MetadataViews.Rarity?,\n        serial: UInt64?,\n        traits: MetadataViews.Traits?,\n        collectionDisplay: MetadataViews.NFTCollectionDisplay?,\n        soulBounded: Bool ,\n        nftType: Type\n    ) {\n        self.id = id\n        self.display = display\n        self.editions = editions\n        self.rarity = rarity\n        self.serial = serial\n        self.traits = traits\n        self.collectionDisplay = collectionDisplay\n        self.soulBounded = soulBounded\n        self.nftType = nftType\n    }\n}\n\npub fun getNFTs(ownerAddress: Address, ids: {String : [UInt64]}) : [NFTView] {\n\n    let account = getAuthAccount(ownerAddress)\n\n    if account.balance == 0.0 {\n        return []\n    }\n\n    let results : [NFTView] = []\n    for collectionKey in ids.keys {\n        let catalogEntry = FINDNFTCatalog.getCatalogEntry(collectionIdentifier:collectionKey)!\n        let storagePath = catalogEntry.collectionData.storagePath\n        let ref= account.borrow\u003c\u0026{MetadataViews.ResolverCollection}\u003e(from: storagePath)\n        if ref != nil{\n            for id in ids[collectionKey]! {\n                // results.append(MetadataViews.getNFTView(id:id, viewResolver: ref!.borrowViewResolver(id:id)!))\n                let viewResolver = ref!.borrowViewResolver(id:id)!\n\n                var traitsStruct : MetadataViews.Traits? = nil \n\n                if let traits = MetadataViews.getTraits(viewResolver) {\n                    if let trait = getTrait(viewResolver) {\n                        var check = false \n                        for item in traits.traits {\n                            if item.name == trait.name {\n                                check = true \n                                break\n                            }\n                            if !check {\n                                let array = traits.traits\n                                array.append(trait)\n\n                                traitsStruct = cleanUpTraits(array)\n                            }\n                        }\n                    } else {\n                        traitsStruct = cleanUpTraits(traits.traits)\n                    }\n                } else {\n                    if let trait = getTrait(viewResolver) {\n                        traitsStruct = cleanUpTraits([trait])\n                    }\n                }\n\n                var editionStruct : MetadataViews.Editions? = nil \n\n                if let editions = MetadataViews.getEditions(viewResolver) {\n                    if let edition = getEdition(viewResolver) {\n                        var check = false\n                        for item in editions.infoList {\n                            if item.name == edition.name \u0026\u0026 item.number == edition.number \u0026\u0026 item.max == edition.max {\n                                check = true\n                                break\n                            }\n                        }\n                        // If the edition does not exist in editions, add it in\n                        if !check {\n                            let array = editions.infoList \n                            array.append(edition)\n                            editionStruct = MetadataViews.Editions(array)\n                        }\n                    } else {\n                    // If edition does not exist OR edition is already in editions , append it to views and continue\n                        editionStruct = editions\n                    }\n                } else if let edition = getEdition(viewResolver) {\n                        editionStruct = MetadataViews.Editions([edition])\n                }\n\n                results.append(\n                    NFTView(\n                        id : id,\n                        display: MetadataViews.getDisplay(viewResolver),\n                        editions : editionStruct,\n                        rarity : MetadataViews.getRarity(viewResolver),\n                        serial :  MetadataViews.getSerial(viewResolver)?.number,\n                        traits : traitsStruct,\n                        collectionDisplay : MetadataViews.getNFTCollectionDisplay(viewResolver),\n                        soulBounded : FindViews.checkSoulBound(viewResolver),\n                        nftType : viewResolver.getType()\n                    )\n                )\n            }\n        }\n    }\n    return results\n}\n\npub struct CollectionReport {\n    pub let items : {String : [MetadataCollectionItem]} \n    pub let collections : {String : Int} // mapping of collection to no. of ids \n    pub let extraIDs : {String : [UInt64]} \n\n    init(items: {String : [MetadataCollectionItem]},  collections : {String : Int}, extraIDs : {String : [UInt64]} ) {\n        self.items=items \n        self.collections=collections \n        self.extraIDs=extraIDs\n    }\n}\n\npub struct MetadataCollectionItem {\n    pub let id:UInt64\n    pub let name: String\n    pub let collection: String // \u003c- This will be Alias unless they want something else\n    pub let subCollection: String? // \u003c- This will be Alias unless they want something else\n    pub let nftDetailIdentifier: String\n    pub let soulBounded: Bool \n\n    pub let media  : String\n    pub let mediaType : String \n    pub let source : String \n\n    pub var rarity:MetadataViews.Rarity?\n    pub var editions: MetadataViews.Editions?\n    pub var serial: UInt64?\n    pub var traits: MetadataViews.Traits?\n\n    init(id:UInt64, \n         name: String, \n         collection: String, \n         subCollection: String?, \n         media  : String, \n         mediaType : String, \n         source : String, \n         nftDetailIdentifier: String, \n         editions : MetadataViews.Editions?,\n         rarity:MetadataViews.Rarity?,\n         serial: UInt64?,\n         traits: MetadataViews.Traits?,\n         soulBounded: Bool \n         ) {\n        self.id=id\n        self.name=name \n        self.collection=collection \n        self.subCollection=subCollection \n        self.media=media \n        self.mediaType=mediaType \n        self.source=source\n        self.nftDetailIdentifier=nftDetailIdentifier\n        self.editions=editions\n        self.rarity=rarity\n        self.serial=serial\n        self.traits=traits\n        self.soulBounded=soulBounded\n    }\n}\n\n// Helper function \n\npub fun resolveAddress(user: String) : PublicAccount? {\n    let address = FIND.resolve(user)\n    if address == nil {\n        return nil\n    }\n    return getAccount(address!)\n}\n\n\n//////////////////////////////////////////////////////////////\n// Fetch Specific Collections in Find Catalog\n//////////////////////////////////////////////////////////////\npub fun fetchNFTCatalog(user: String, collectionIDs: {String : [UInt64]}) : {String : [MetadataCollectionItem]} {\n    let source = \"NFTCatalog\"\n    let account = resolveAddress(user: user)\n    if account == nil { return {} }\n\n    let items : {String : [MetadataCollectionItem]} = {}\n\n    let fetchingIDs = collectionIDs\n\n\n    for project in fetchingIDs.keys {\n\n        let catalogEntry = FINDNFTCatalog.getCatalogEntry(collectionIdentifier:project)!\n        let projectName = catalogEntry.contractName\n\n        let returnedNFTs = getNFTs(ownerAddress: account!.address, ids: {project : fetchingIDs[project]!})\n\n        var collectionItems : [MetadataCollectionItem] = []\n        for nft in returnedNFTs {\n            if nft == nil {\n                continue\n            }\n\n            var subCollection = \"\"\n            if project != nft!.collectionDisplay!.name {\n             subCollection = nft!.collectionDisplay!.name\n            }\n\n            var name = nft!.display!.name \n            if name == \"\" {\n                name = projectName\n            }\n\n            if nft.editions != nil \u0026\u0026 nft.editions!.infoList.length \u003e 0 {\n                let edition = nft.editions!.infoList[0].number.toString()\n                // check if the name ends with \"editionNumber\"\n                // If the name ends with \"editionNumber\", we do not concat the edition\n                if name.length \u003e edition.length \u0026\u0026 name.slice(from: name.length - edition.length, upTo: name.length) != edition {\n                    name = name.concat(\"#\").concat(nft.editions!.infoList[0].number.toString())\n                }\n            }\n            \n            let item = MetadataCollectionItem(\n                id: nft!.id,\n                name: name,\n                collection: project,\n                subCollection: subCollection, \n                media: nft!.display!.thumbnail.uri(),\n                mediaType: \"image/png\",\n                source: source, \n                nftDetailIdentifier: nft!.nftType.identifier, \n                editions : nft!.editions,\n                rarity: nft!.rarity,\n                serial: nft!.serial,\n                traits: nft!.traits,\n                soulBounded: nft.soulBounded\n            )\n            collectionItems.append(item)\n        }\n\n        if collectionItems.length \u003e 0 {\n            items[project] = collectionItems\n        }\n    }\n    return items\n}\n\npub fun cleanUpTraits(_ traits: [MetadataViews.Trait]) : MetadataViews.Traits {\n    let dateValues  = {\"Date\" : true, \"Numeric\":false, \"Number\":false, \"date\":true, \"numeric\":false, \"number\":false}\n\n    let array : [MetadataViews.Trait] = []\n\n    for i , trait in traits {\n        let displayType = trait.displayType ?? \"string\"\n        if let isDate = dateValues[displayType] {\n            if isDate {\n                array.append(MetadataViews.Trait(name: trait.name, value: trait.value, displayType: \"Date\", rarity: trait.rarity))\n            } else {\n                array.append(MetadataViews.Trait(name: trait.name, value: trait.value, displayType: \"Numeric\", rarity: trait.rarity))\n            }\n        } else {\n            if let value = trait.value as? Bool {\n                if value {\n                    array.append(MetadataViews.Trait(name: trait.name, value: trait.value, displayType: \"Bool\", rarity: trait.rarity))\n                }else {\n                    array.append(MetadataViews.Trait(name: trait.name, value: trait.value, displayType: \"Bool\", rarity: trait.rarity))\n                }\n            } else if let value = trait.value as? String {\n                array.append(MetadataViews.Trait(name: trait.name, value: trait.value, displayType: \"String\", rarity: trait.rarity))\n            } else {\n                array.append(MetadataViews.Trait(name: trait.name, value: trait.value, displayType: \"String\", rarity: trait.rarity))\n            }\n        }\n    }\n    return MetadataViews.Traits(array)\n}\n\npub fun getTrait(_ viewResolver: \u0026{MetadataViews.Resolver}) : MetadataViews.Trait? {\n    if let view = viewResolver.resolveView(Type\u003cMetadataViews.Trait\u003e()) {\n        if let v = view as? MetadataViews.Trait {\n            return v\n        }\n    }\n    return nil\n}\n\npub fun getEdition(_ viewResolver: \u0026{MetadataViews.Resolver}) : MetadataViews.Edition? {\n    if let view = viewResolver.resolveView(Type\u003cMetadataViews.Edition\u003e()) {\n        if let v = view as? MetadataViews.Edition {\n            return v\n        }\n    }\n    return nil\n}",
               "spec": {
                  "order": [
                     "user",
                     "collectionIDs"
                  ],
                  "parameters": {
                     "collectionIDs": "{String: [UInt64]}",
                     "user": "String"
                  }
               }
            },
            "getNFTDetailsNFTCatalog": {
               "code": "import FindMarket from 0x179b6b1cb6755e31\nimport FindViews from 0x179b6b1cb6755e31\nimport FindUtils from 0x179b6b1cb6755e31\nimport FIND from 0x179b6b1cb6755e31\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FINDNFTCatalog from 0x179b6b1cb6755e31\nimport FTRegistry from 0x179b6b1cb6755e31\nimport FindUserStatus from 0x179b6b1cb6755e31\n\npub struct NFTDetailReport {\n    pub let findMarket: {String : FindMarket.SaleItemInformation}\n    pub let storefront: FindUserStatus.StorefrontListing?\n    pub let storefrontV2: FindUserStatus.StorefrontListing?\n    pub let flowty: FindUserStatus.FlowtyListing?\n    pub let flowtyRental: FindUserStatus.FlowtyRental?\n    pub let flovatar: FindUserStatus.FlovatarListing?\n    pub let flovatarComponent: FindUserStatus.FlovatarComponentListing?\n    pub let nftDetail: NFTDetail?\n    pub let allowedListingActions: {String : ListingTypeReport}\n    pub let dapperAllowedListingActions: {String : ListingTypeReport}\n    pub let linkedForMarket : Bool?\n\n\n    init(findMarket:{String : FindMarket.SaleItemInformation}, storefront: FindUserStatus.StorefrontListing?, storefrontV2: FindUserStatus.StorefrontListing?, flowty: FindUserStatus.FlowtyListing?, flowtyRental: FindUserStatus.FlowtyRental? , flovatar: FindUserStatus.FlovatarListing? , flovatarComponent: FindUserStatus.FlovatarComponentListing? , nftDetail: NFTDetail?, allowedListingActions: {String : ListingTypeReport}, dapperAllowedListingActions: {String : ListingTypeReport}, linkedForMarket : Bool?) {\n        self.findMarket=findMarket\n        self.storefront=storefront\n        self.storefrontV2=storefrontV2\n        self.flowty=flowty\n        self.flowtyRental=flowtyRental\n        self.flovatar=flovatar\n        self.flovatarComponent=flovatarComponent\n        self.nftDetail=nftDetail\n        self.allowedListingActions=allowedListingActions\n        self.dapperAllowedListingActions=dapperAllowedListingActions\n        self.linkedForMarket = linkedForMarket\n    }\n}\n\n\npub struct ListingTypeReport {\n    pub let ftAlias: [String]\n    pub let ftIdentifiers: [String]\n    pub let listingType: String\n    pub let status: String\n    pub let ListingDetails: [ListingRoyalties]\n\n    init(listingType: String, ftAlias: [String], ftIdentifiers: [String],  status: String , ListingDetails: [ListingRoyalties]) {\n        self.listingType=listingType\n        self.status=status\n        self.ListingDetails=ListingDetails\n        self.ftAlias=ftAlias\n        self.ftIdentifiers=ftIdentifiers\n    }\n}\n\npub struct NFTDetail {\n    pub let id: UInt64\n    pub let uuid: UInt64\n    pub let name:String\n    pub let description:String\n    pub let thumbnail:String\n    pub let type: String\n    pub var externalViewURL: String?\n    pub var rarity:MetadataViews.Rarity?\n    pub var editions: [MetadataViews.Edition]\n    pub var serial: UInt64?\n    pub var traits: [MetadataViews.Trait]\n    pub var media : {String: String} //url to mediaType\n    pub var collection : NFTCollectionDisplay?\n    pub var license : String?\n    pub var data: {String : AnyStruct?}\n    pub var soulBounded: Bool\n    pub var views :[String]\n\n    init(_ pointer: FindViews.ViewReadPointer, views: {String : AnyStruct}, resolvedViews: [Type]){\n\n        self.type=pointer.itemType.identifier\n        self.id=pointer.id\n        self.uuid=pointer.getUUID()\n\n        // Display\n        let display = views[\"Display\"] ?? panic(\"Could not find display\")\n        let d = display as! MetadataViews.Display\n        self.name=d.name\n        self.description=d.description\n        self.thumbnail=d.thumbnail.uri()\n        views.remove(key: \"Display\")\n\n        // External URL\n        self.externalViewURL = nil\n        if let externalURL = views[\"ExternalURL\"] {\n            if let e = externalURL as? MetadataViews.ExternalURL {\n                self.externalViewURL = e.url\n            }\n        }\n        views.remove(key: \"ExternalURL\")\n\n        // Edition\n        self.editions=[]\n        if let editions = views[\"Editions\"] {\n            if let e = editions as? MetadataViews.Editions {\n                if e.infoList.length \u003e 0 {\n                    self.editions=e.infoList\n                }\n            }\n        }\n        views.remove(key: \"Editions\")\n\n        // Serial\n        self.serial=nil\n        if let serial = views[\"Serial\"] {\n            if let s = serial as? MetadataViews.Serial {\n                self.serial=s.number\n            }\n        }\n        views.remove(key: \"Serial\")\n\n        // subCollection\n        self.collection=nil\n        if let grouping = views[\"NFTCollectionDisplay\"] {\n            if let sc = grouping as? MetadataViews.NFTCollectionDisplay {\n                self.collection=NFTCollectionDisplay(sc)\n            }\n        }\n        views.remove(key: \"NFTCollectionDisplay\")\n\n        // Medias\n        self.media={}\n        if let medias= views[\"Medias\"] {\n            if let ms = medias as? MetadataViews.Medias {\n                for m in ms.items {\n                    let url = m.file.uri()\n                    let type = m.mediaType\n                    self.media[url] = type\n                }\n            }\n        }\n        views.remove(key: \"Medias\")\n\n        // Rarity\n        self.rarity=nil\n        if let rarity= views[\"Rarity\"] {\n            if let r = rarity as? MetadataViews.Rarity {\n                self.rarity = r\n            }\n        }\n        views.remove(key: \"Rarity\")\n\n        // Traits\n        self.traits=[]\n        if let traits = views[\"Traits\"] {\n            if let t = traits as? MetadataViews.Traits {\n                if t.traits.length \u003e 0 {\n                    self.traits=t.traits\n                }\n            }\n        }\n        views.remove(key: \"Traits\")\n\n        // License\n        self.license= nil\n        if let license= views[\"License\"] {\n            if let l = license as? MetadataViews.License {\n                self.license = l.spdxIdentifier\n            }\n        }\n        views.remove(key: \"License\")\n\n        self.soulBounded = false\n        if let soulBound= views[\"SoulBound\"] {\n            self.soulBounded = true\n        }\n        views.remove(key: \"SoulBound\")\n\n        self.views=[]\n\n        for view in pointer.getViews() {\n            if defaultViews().contains(view) {\n                continue\n            }\n            if resolvedViews.contains(view) {\n                continue\n            }\n            self.views.append(view.identifier)\n        }\n        self.data=views\n\n    }\n}\n\npub struct ListingRoyalties {\n\n    pub let ftAlias: String?\n    pub let ftIdentifier: String\n    pub let royalties: [Royalties]\n\n    init(ftAlias: String?, ftIdentifier: String, royalties: [Royalties]) {\n        self.ftAlias=ftAlias\n        self.ftIdentifier=ftIdentifier\n        self.royalties=royalties\n    }\n}\n\npub struct Royalties {\n\n    pub let royaltyName: String\n    pub let address: Address\n    pub let findName: String?\n    pub let cut: UFix64\n\n    init(royaltyName: String , address: Address, findName: String?, cut: UFix64) {\n        self.royaltyName=royaltyName\n        self.address=address\n        self.findName=findName\n        self.cut=cut\n    }\n}\n\npub struct NFTCollectionDisplay {\n    // Name that should be used when displaying this NFT collection.\n    pub let name: String\n\n    // Description that should be used to give an overview of this collection.\n    pub let description: String\n\n    // External link to a URL to view more information about this collection.\n    pub let externalURL: String\n\n    // Square-sized image to represent this collection.\n    pub let squareImage: {String : String}\n\n    // Banner-sized image for this collection, recommended to have a size near 1200x630.\n    pub let bannerImage: {String : String}\n\n    // Social links to reach this collection's social homepages.\n    // Possible keys may be \"instagram\", \"twitter\", \"discord\", etc.\n    pub let socials: {String: String}\n\n    init(\n        _ nftCD : MetadataViews.NFTCollectionDisplay\n    ) {\n        self.name = nftCD.name\n        self.description = nftCD.description\n        self.externalURL = nftCD.externalURL.url\n\n        let squareImage = {nftCD.squareImage.file.uri() : nftCD.squareImage.mediaType}\n        self.squareImage = squareImage\n\n        let bannerImage = {nftCD.bannerImage.file.uri() : nftCD.bannerImage.mediaType}\n        self.bannerImage = bannerImage\n\n        let socials : {String : String} = {}\n        for key in nftCD.socials.keys{\n            socials[key] = nftCD.socials[key]!.url\n        }\n        self.socials = socials\n    }\n}\n\npub var counter = 0\n\npub fun main(user: String, project:String, id: UInt64, views: [String]) : NFTDetailReport?{\n    let resolveAddress = FIND.resolve(user)\n    if resolveAddress == nil {\n        return nil\n    }\n    let address = resolveAddress!\n\n    let account = getAuthAccount(address)\n\n    if account.balance \u003e 0.0 {\n        // check link for market\n        let linkedForMarket = account.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(getPublicPath(project)).check()\n\n        let storagePath = getStoragePath(project)\n        let publicPath = PublicPath(identifier: \"find_temp_path_\".concat(counter.toString()))!\n        counter = counter + 1\n        account.link\u003c\u0026{MetadataViews.ResolverCollection}\u003e(publicPath, target: storagePath)\n        let cap = account.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(publicPath)\n        if !cap.check() {\n            panic(\"The user does not set up collection correctly.\")\n        }\n        let pointer = FindViews.ViewReadPointer(cap: cap, id: id)\n\n        let nftDetail = getNFTDetail(pointer:pointer, views: views)\n        if nftDetail == nil {\n            return nil\n        }\n\n\n        let findAddress=FindMarket.getFindTenantAddress()\n        var findMarket=FindMarket.getNFTListing(tenant:findAddress, address: address, id: nftDetail!.uuid, getNFTInfo:false)\n\n        var report : {String : ListingTypeReport} = {}\n        var dapperReport : {String : ListingTypeReport} = {}\n\n        // check if that's soulBound, if yes, the report will be nil\n        if !pointer.checkSoulBound() {\n            let tenantCap = FindMarket.getTenantCapability(findAddress)!\n            let tenantRef = tenantCap.borrow() ?? panic(\"This tenant is not set up. Tenant : \".concat(tenantCap.address.toString()))\n\n            let marketTypes = FindMarket.getSaleItemTypes()\n\n            for marketType in marketTypes {\n                if let allowedListing = tenantRef.getAllowedListings(nftType: pointer.getItemType(), marketType: marketType) {\n                    report[FindMarket.getMarketOptionFromType(marketType)] = createListingTypeReport(allowedListing, pointer: pointer, tenantRef: tenantRef, dapper: false)\n                    dapperReport[FindMarket.getMarketOptionFromType(marketType)] = createListingTypeReport(allowedListing, pointer: pointer, tenantRef: tenantRef, dapper: true)\n                }\n            }\n        }\n\n        let nftType = pointer.itemType\n        let listingsV1 = FindUserStatus.getStorefrontListing(user: address, id : id, type: nftType)\n        let listingsV2 = FindUserStatus.getStorefrontV2Listing(user: address, id : id, type: nftType)\n        let flowty = FindUserStatus.getFlowtyListing(user: address, id : id, type: nftType)\n        let flowtyRental = FindUserStatus.getFlowtyRentals(user: address, id : id, type: nftType)\n        let flovatar = FindUserStatus.getFlovatarListing(user: address, id : id, type: nftType)\n        let flovatarComponent = FindUserStatus.getFlovatarComponentListing(user: address, id : id, type: nftType)\n\n        return NFTDetailReport(findMarket:findMarket, storefront:listingsV1, storefrontV2: listingsV2, flowty:flowty, flowtyRental:flowtyRental, flovatar:flovatar, flovatarComponent:flovatarComponent, nftDetail: nftDetail, allowedListingActions: report, dapperAllowedListingActions: dapperReport, linkedForMarket : linkedForMarket)\n    }\n    return nil\n\n}\n\npub let resolvedAddresses : {Address : String} = {}\n\npub var nftRoyalties : [Royalties]? = nil\n\npub fun reverseLookup(_ addr: Address) : String? {\n\n    if let name = resolvedAddresses[addr] {\n        if name == \"\" {\n            return nil\n        } else {\n            return name\n        }\n    }\n    let name = FIND.reverseLookup(addr)\n    if name == nil {\n        resolvedAddresses[addr] = \"\"\n    } else {\n        resolvedAddresses[addr] = name\n    }\n    return name\n\n}\n\npub fun getNFTDetail(pointer: FindViews.ViewReadPointer, views: [String]) : NFTDetail? {\n\n    if !pointer.valid() {\n        return nil\n    }\n\n    var nftViews: {String : AnyStruct} = {}\n    var resolvedViews: [Type] = []\n    let viewResolver = pointer.getViewResolver()\n\n    let defaultViews = defaultViews()\n    for view in views {\n        if let runTimeType = CompositeType(view) {\n            if !defaultViews.contains(runTimeType) {\n                defaultViews.append(runTimeType)\n            }\n        }\n    }\n\n\n    for runTimeType in defaultViews {\n        // Resolve arrayed views to ensure we didn't miss any stuff\n        if runTimeType == Type\u003cMetadataViews.Editions\u003e() {\n            if let editions = MetadataViews.getEditions(viewResolver) {\n                if let edition = getEdition(viewResolver) {\n                    var check = false\n                    for item in editions.infoList {\n                        if item.name == edition.name \u0026\u0026 item.number == edition.number \u0026\u0026 item.max == edition.max {\n                            check = true\n                            break\n                        }\n                    }\n                    // If the edition does not exist in editions, add it in\n                    if !check {\n                        let array = editions.infoList\n                        array.append(edition)\n                        nftViews[\"Editions\"] = MetadataViews.Editions(array)\n                        resolvedViews.append(runTimeType)\n                        continue\n                    }\n                }\n                // If edition does not exist OR edition is already in editions , append it to views and continue\n                nftViews[\"Editions\"] = editions\n                resolvedViews.append(runTimeType)\n                continue\n            }\n        }\n\n        if runTimeType == Type\u003cMetadataViews.Edition\u003e() {\n            // If the editions does not exist, check if there is edition, if there is, add it in as editions\n            if nftViews[\"Editions\"] == nil {\n                if let edition = getEdition(viewResolver) {\n                    nftViews[\"Editions\"] = MetadataViews.Editions([edition])\n                    resolvedViews.append(runTimeType)\n                }\n            }\n            continue\n        }\n\n        if runTimeType == Type\u003cMetadataViews.Medias\u003e() {\n            if let medias = MetadataViews.getMedias(viewResolver) {\n                if let media = getMedia(viewResolver) {\n                    var check = false\n                    let uri = media.file.uri()\n                    for item in medias.items {\n                        if item.file.uri() == uri {\n                            check = true\n                            break\n                        }\n                        if !check {\n                            let array = medias.items\n                            array.append(media)\n                            nftViews[\"Medias\"] = MetadataViews.Medias(array)\n                            resolvedViews.append(runTimeType)\n                            continue\n                        }\n                    }\n                }\n                nftViews[\"Medias\"] = medias\n                resolvedViews.append(runTimeType)\n                continue\n            }\n        }\n\n        if runTimeType == Type\u003cMetadataViews.Media\u003e() {\n            if nftViews[\"Medias\"] == nil {\n                if let media = getMedia(viewResolver) {\n                    nftViews[\"Medias\"] = MetadataViews.Medias([media])\n                    resolvedViews.append(runTimeType)\n                }\n            }\n            continue\n        }\n\n        if runTimeType == Type\u003cMetadataViews.Traits\u003e() {\n            if let traits = MetadataViews.getTraits(viewResolver) {\n                if let trait = getTrait(viewResolver) {\n                    var check = false\n                    for item in traits.traits {\n                        if item.name == trait.name {\n                            check = true\n                            break\n                        }\n                        if !check {\n                            let array = traits.traits\n                            array.append(trait)\n\n                            nftViews[\"Traits\"] = cleanUpTraits(array)\n                            resolvedViews.append(runTimeType)\n                            continue\n                        }\n                    }\n                }\n                nftViews[\"Traits\"] = cleanUpTraits(traits.traits)\n                resolvedViews.append(runTimeType)\n                continue\n            }\n        }\n\n        if runTimeType == Type\u003cMetadataViews.Trait\u003e() {\n            if nftViews[\"Traits\"] == nil {\n                if let trait = getTrait(viewResolver) {\n                    nftViews[\"Traits\"] = MetadataViews.Traits([trait])\n                    resolvedViews.append(runTimeType)\n                }\n            }\n            continue\n        }\n\n        if let view = pointer.resolveView(runTimeType) {\n            let name = FindUtils.splitString(runTimeType.identifier, sep: \".\")[3]\n            nftViews[name] = view\n            resolvedViews.append(runTimeType)\n        }\n    }\n\n    return NFTDetail(pointer, views: nftViews, resolvedViews: resolvedViews)\n\n\n}\n\npub fun getEdition(_ viewResolver: \u0026{MetadataViews.Resolver}) : MetadataViews.Edition? {\n    if let view = viewResolver.resolveView(Type\u003cMetadataViews.Edition\u003e()) {\n        if let v = view as? MetadataViews.Edition {\n            return v\n        }\n    }\n    return nil\n}\n\npub fun getMedia(_ viewResolver: \u0026{MetadataViews.Resolver}) : MetadataViews.Media? {\n    if let view = viewResolver.resolveView(Type\u003cMetadataViews.Media\u003e()) {\n        if let v = view as? MetadataViews.Media {\n            return v\n        }\n    }\n    return nil\n}\n\npub fun getTrait(_ viewResolver: \u0026{MetadataViews.Resolver}) : MetadataViews.Trait? {\n    if let view = viewResolver.resolveView(Type\u003cMetadataViews.Trait\u003e()) {\n        if let v = view as? MetadataViews.Trait {\n            return v\n        }\n    }\n    return nil\n}\n\n/* Helper Function */\npub fun resolveRoyalties(_ pointer: FindViews.ViewReadPointer) : [Royalties] {\n    let array : [Royalties] = []\n    for royalty in pointer.getRoyalty().getRoyalties() {\n        let address = royalty.receiver.address\n        array.append(Royalties(royaltyName: royalty.description, address: address, findName: reverseLookup(address), cut: royalty.cut))\n    }\n\n    return array\n}\n\npub fun resolveMarketplaceRoyalties(tenantRef: \u0026FindMarket.Tenant{FindMarket.TenantPublic}, listing: Type, nft: Type, ft: Type) : [Royalties] {\n\n    let cuts = tenantRef.getCuts(name:\"\", listingType: listing, nftType:nft, ftType:ft)\n\n    let royalties :[Royalties] = []\n\n    for allCuts in cuts.values {\n        for cut in allCuts.cuts {\n            royalties.append(Royalties(royaltyName: cut.getName(), address: cut.getAddress(), findName: reverseLookup(cut.getAddress()), cut: cut.getCut()))\n        }\n    }\n\n    return royalties\n}\n\npub fun createListingTypeReport(_ allowedListing: FindMarket.AllowedListing, pointer: FindViews.ViewReadPointer, tenantRef: \u0026FindMarket.Tenant{FindMarket.TenantPublic}, dapper: Bool) : ListingTypeReport? {\n    let listingType = allowedListing.listingType.identifier\n    var ftAlias : [String] = []\n    var ftIdentifier : [String] = []\n    var listingDetails : [ListingRoyalties] = []\n    for ft in allowedListing.ftTypes {\n        var alias : String? = nil\n        let ftInfo = FTRegistry.getFTInfo(ft.identifier) ?? panic(ft.identifier.concat(\" is not added to FTRegistry yet.\"))\n        switch dapper {\n            case true :\n                if !ftInfo.tag.contains(\"dapper\") {\n                    continue\n                }\n\n            case false :\n                if ftInfo.tag.contains(\"dapper\") {\n                    continue\n                }\n        }\n        alias = ftInfo.alias\n        ftAlias.append(ftInfo.alias)\n        ftIdentifier.append(ft.identifier)\n\n        // getRoyalties\n        var nftR = nftRoyalties\n        if nftR == nil {\n            nftRoyalties = resolveRoyalties(pointer)\n            nftR = nftRoyalties\n        }\n\n        let findR = resolveMarketplaceRoyalties(tenantRef: tenantRef, listing: allowedListing.listingType , nft: pointer.getItemType(), ft: ft)\n        findR.appendAll(nftR!)\n\n        listingDetails.append(ListingRoyalties(ftAlias: alias, ftIdentifier: ft.identifier, royalties: findR))\n    }\n\n    if ftIdentifier.length == 0 {\n        return nil\n    }\n\n    return ListingTypeReport(listingType: listingType, ftAlias: ftAlias, ftIdentifiers: ftIdentifier,  status: allowedListing.status , ListingDetails: listingDetails)\n}\n\npub fun defaultViews() : [Type] {\n    return [\n    Type\u003cMetadataViews.Display\u003e() ,\n    Type\u003cMetadataViews.Editions\u003e() ,\n    Type\u003cMetadataViews.Edition\u003e() ,\n    Type\u003cMetadataViews.Serial\u003e() ,\n    Type\u003cMetadataViews.Medias\u003e() ,\n    Type\u003cMetadataViews.Media\u003e() ,\n    Type\u003cMetadataViews.License\u003e() ,\n    Type\u003cMetadataViews.ExternalURL\u003e() ,\n    Type\u003cMetadataViews.NFTCollectionDisplay\u003e() ,\n    Type\u003cMetadataViews.Traits\u003e() ,\n    Type\u003cMetadataViews.Trait\u003e() ,\n    Type\u003cMetadataViews.Rarity\u003e(),\n    Type\u003cFindViews.SoulBound\u003e()\n    ]\n}\n\npub fun getStoragePath(_ nftIdentifier: String) : StoragePath {\n    if let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys {\n        let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])!\n        return collection.collectionData.storagePath\n    }\n\n    if let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier :nftIdentifier) {\n        return collection.collectionData.storagePath\n    }\n    panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier))\n}\n\npub fun getPublicPath(_ nftIdentifier: String) : PublicPath {\n    if let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys {\n        let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])!\n        return collection.collectionData.publicPath\n    }\n\n    if let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier :nftIdentifier) {\n        return collection.collectionData.publicPath\n    }\n    panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier))\n}\n\npub fun cleanUpTraits(_ traits: [MetadataViews.Trait]) : MetadataViews.Traits {\n    let dateValues  = {\"Date\" : true, \"Numeric\":false, \"Number\":false, \"date\":true, \"numeric\":false, \"number\":false}\n\n    let array : [MetadataViews.Trait] = []\n\n    for i , trait in traits {\n        let displayType = trait.displayType ?? \"string\"\n        if let isDate = dateValues[displayType] {\n            if isDate {\n                array.append(MetadataViews.Trait(name: trait.name, value: trait.value, displayType: \"Date\", rarity: trait.rarity))\n            } else {\n                array.append(MetadataViews.Trait(name: trait.name, value: trait.value, displayType: \"Numeric\", rarity: trait.rarity))\n            }\n        } else {\n            if let value = trait.value as? Bool {\n                if value {\n                    array.append(MetadataViews.Trait(name: trait.name, value: trait.value, displayType: \"Bool\", rarity: trait.rarity))\n                }else {\n                    array.append(MetadataViews.Trait(name: trait.name, value: trait.value, displayType: \"Bool\", rarity: trait.rarity))\n                }\n            } else if let value = trait.value as? String {\n                array.append(MetadataViews.Trait(name: trait.name, value: trait.value, displayType: \"String\", rarity: trait.rarity))\n            } else {\n                array.append(MetadataViews.Trait(name: trait.name, value: trait.value, displayType: \"String\", rarity: trait.rarity))\n            }\n        }\n    }\n    return MetadataViews.Traits(array)\n}",
               "spec": {
                  "order": [
                     "user",
                     "project",
                     "id",
                     "views"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "project": "String",
                     "user": "String",
                     "views": "[String]"
                  }
               }
            },
            "getNFTView": {
               "code": "import MetadataViews from 0xf8d6e0586b0a20c7\nimport FINDNFTCatalog from 0x179b6b1cb6755e31\nimport FIND from 0x179b6b1cb6755e31\n\n//Fetch a single view from a nft on a given path\npub fun main(user: String, aliasOrIdentifier:String, id: UInt64, identifier: String) : AnyStruct? {\n\n    let publicPath = getPublicPath(aliasOrIdentifier)\n    let resolveAddress = FIND.resolve(user) \n    if resolveAddress == nil {return []}\n    let address = resolveAddress!\n\n    let pp = publicPath\n    let account = getAccount(address)\n    if account.balance == 0.0 {\n        return nil\n    }\n    let collection= account.getCapability(pp).borrow\u003c\u0026{MetadataViews.ResolverCollection}\u003e()!\n\n    let nft=collection.borrowViewResolver(id: id)\n    for v in nft.getViews() {\n        if v.identifier== identifier {\n            return nft.resolveView(v)\n        }\n    }\n    return nil\n}\n\npub fun getPublicPath(_ nftIdentifier: String) : PublicPath {\n    let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier)) \n    let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n    return collection.collectionData.publicPath\n}",
               "spec": {
                  "order": [
                     "user",
                     "aliasOrIdentifier",
                     "id",
                     "identifier"
                  ],
                  "parameters": {
                     "aliasOrIdentifier": "String",
                     "id": "UInt64",
                     "identifier": "String",
                     "user": "String"
                  }
               }
            },
            "getNFTViews": {
               "code": "import MetadataViews from 0xf8d6e0586b0a20c7\nimport NFTCatalog from 0xf8d6e0586b0a20c7\nimport FINDNFTCatalog from 0x179b6b1cb6755e31\nimport FIND from 0x179b6b1cb6755e31\n\n//get all the views for an nft and address/path/id\npub fun main(user: String, aliasOrIdentifier:String, id: UInt64) : [String] {\n    let nftInfo = getCollectionData(aliasOrIdentifier) \n\n    let resolveAddress = FIND.resolve(user) \n    if resolveAddress == nil {return []}\n    let address = resolveAddress!\n    let pp = nftInfo.publicPath\n    let collection= getAccount(address).getCapability(pp).borrow\u003c\u0026{MetadataViews.ResolverCollection}\u003e()!\n    let nft=collection.borrowViewResolver(id: id)\n    let views:[String]=[]\n    for v in nft.getViews() {\n        views.append(v.identifier)\n    }\n    return views\n}\n\npub fun getCollectionData(_ nftIdentifier: String) : NFTCatalog.NFTCollectionData {\n    let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier)) \n    let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n    return collection.collectionData\n}",
               "spec": {
                  "order": [
                     "user",
                     "aliasOrIdentifier",
                     "id"
                  ],
                  "parameters": {
                     "aliasOrIdentifier": "String",
                     "id": "UInt64",
                     "user": "String"
                  }
               }
            },
            "getName": {
               "code": "import FIND from 0x179b6b1cb6755e31\n\npub fun main(address: Address) : String?{\n    return FIND.reverseLookup(address)\n}",
               "spec": {
                  "order": [
                     "address"
                  ],
                  "parameters": {
                     "address": "Address"
                  }
               }
            },
            "getNameDetails": {
               "code": "import FIND from 0x179b6b1cb6755e31\nimport Profile from 0x179b6b1cb6755e31\nimport FindRelatedAccounts from 0x179b6b1cb6755e31\n\npub struct FINDReport {\n    pub let profile:Profile.UserReport?\n    pub let bids: [FIND.BidInfo]\n    pub let relatedAccounts: { String: [Address]}\n    pub let leases: [FIND.LeaseInformation]\n    pub let privateMode: Bool\n    pub let activatedAccount: Bool \n\n\n    init(profile: Profile.UserReport?, relatedAccounts: { String: [Address]}, bids: [FIND.BidInfo], leases : [FIND.LeaseInformation], privateMode: Bool, activatedAccount: Bool ) {\n        self.profile=profile\n        self.bids=bids\n        self.leases=leases\n        self.relatedAccounts=relatedAccounts\n        self.privateMode=privateMode\n        self.activatedAccount=activatedAccount\n    }\n}\n\npub struct NameReport {\n    pub let status: String\n    pub let cost: UFix64 \n    pub let leaseStatus: FIND.LeaseInformation?\n    pub let userReport: FINDReport? \n\n    init(status: String, cost: UFix64, leaseStatus: FIND.LeaseInformation?, userReport: FINDReport? ) {\n        self.status=status \n        self.cost=cost \n        self.leaseStatus=leaseStatus\n        self.userReport=userReport\n    }\n}\n\npub fun main(user: String) : NameReport? {\n\n    var findReport: FINDReport? = nil\n    var nameLease: FIND.LeaseInformation? = nil\n    if let address=FIND.resolve(user) {\n        let account=getAccount(address)\n        if account.balance != 0.0 {\n            let bidCap = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n            let leaseCap = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n            let profile=account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath).borrow()\n\n            var profileReport = profile?.asReport() \n            if profileReport != nil \u0026\u0026 profileReport!.findName != FIND.reverseLookup(address) {\n                profileReport = Profile.UserReport(\n                    findName: \"\",\n                    address: profileReport!.address,\n                    name: profileReport!.name,\n                    gender: profileReport!.gender,\n                    description: profileReport!.description,\n                    tags: profileReport!.tags,\n                    avatar: profileReport!.avatar,\n                    links: profileReport!.links,\n                    wallets: profileReport!.wallets, \n                    following: profileReport!.following,\n                    followers: profileReport!.followers,\n                    allowStoringFollowers: profileReport!.allowStoringFollowers,\n                    createdAt: profileReport!.createdAt\n                )\n            }\n\n            findReport = FINDReport(\n                profile: profileReport,\n                relatedAccounts: FindRelatedAccounts.findRelatedFlowAccounts(address:address),\n                bids: bidCap.borrow()?.getBids() ?? [],\n                leases: leaseCap.borrow()?.getLeaseInformation() ?? [],\n                privateMode: profile?.isPrivateModeEnabled() ?? false, \n                activatedAccount: true\n            )\n            if FIND.validateFindName(user) \u0026\u0026 findReport != nil {\n                for lease in findReport!.leases {\n                    if lease.name == user {\n                        nameLease = lease\n                        break\n                    }\n                }\n            }\n        } else {\n            findReport = FINDReport(\n                profile: nil,\n                relatedAccounts: {},\n                bids: [],\n                leases: [],\n                privateMode: false, \n                activatedAccount: false\n            )\n        }\n        \n    }\n\n    var nameReport : NameReport? = nil \n    if FIND.validateFindName(user) {\n        let status = FIND.status(user)\n        let cost=FIND.calculateCost(user)\n        var s=\"TAKEN\"    \n        if status.status == FIND.LeaseStatus.FREE {\n            s=\"FREE\"\n        } else if status.status == FIND.LeaseStatus.LOCKED {\n            s=\"LOCKED\"\n        }\n        nameReport = NameReport(status: s, cost: cost, leaseStatus: nameLease, userReport: findReport)\n    }\n    \n\n    return nameReport\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "getNameStatus": {
               "code": "import FIND from 0x179b6b1cb6755e31\nimport Profile from 0x179b6b1cb6755e31\n\npub fun main(name: String) :  \u0026{Profile.Public}? {\n    return FIND.lookup(name)\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "getNames": {
               "code": "import FIND from 0x179b6b1cb6755e31\n\npub fun main(address: [Address]) : { Address:String}{\n\n    let items : {Address:String} = {}\n    for a in address {\n        if let name= FIND.reverseLookup(a) {\n            items[a]=name\n        }\n    }\n    return items\n}",
               "spec": {
                  "order": [
                     "address"
                  ],
                  "parameters": {
                     "address": "[Address]"
                  }
               }
            },
            "getNamesWithBids": {
               "code": "import FIND from 0x179b6b1cb6755e31\n\npub fun main(user: String) : [FIND.LeaseInformation] {\n\n    let resolveAddress = FIND.resolve(user) \n    if resolveAddress == nil {return []}\n    let address = resolveAddress!\n    let account=getAccount(address)\n\n    if account.balance == 0.0 {\n        return []\n    }\n\n    let leaseCap = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\n    let leases=leaseCap.borrow()?.getLeaseInformation() ?? []\n\n    var leasesWithBids :[FIND.LeaseInformation] =[]\n    for lease in leases {\n        if lease.latestBidBy != nil {\n            leasesWithBids.append(lease)\n        }\n    }\n\n    return leasesWithBids\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "getNamesWithoutBids": {
               "code": "import FIND from 0x179b6b1cb6755e31\n\n\npub fun main(user: String) : [String] {\n\n    let resolveAddress = FIND.resolve(user) \n    if resolveAddress == nil {return []}\n    let address = resolveAddress!\n    let account=getAccount(address)\n\n    if account.balance == 0.0 {\n        return []\n    }\n\n    let leaseCap = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\n    let leases=leaseCap.borrow()?.getLeaseInformation() ?? []\n\n    var leasesWithBids :[String] =[]\n    for lease in leases {\n        if lease.latestBidBy == nil {\n            leasesWithBids.append(lease.name)\n        }\n    }\n\n    return leasesWithBids\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "getOwnedFindThoughts": {
               "code": "import FindThoughts from 0x179b6b1cb6755e31\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FindViews from 0x179b6b1cb6755e31\nimport FindMarket from 0x179b6b1cb6755e31\nimport Profile from 0x179b6b1cb6755e31\nimport FIND from 0x179b6b1cb6755e31\n\npub fun main(address: Address) : [Thought] {\n    let thoughts : [Thought] = [] \n\n\n        let account = getAccount(address) \n        let cap = account.getCapability\u003c\u0026{FindThoughts.CollectionPublic}\u003e(FindThoughts.CollectionPublicPath) \n        if !cap.check() {\n            return []\n        }\n        let ref = cap.borrow()! \n        for id in ref.getIDs() {\n            let t = ref.borrowThoughtPublic(id) \n            thoughts.append(getThought(t, withQuote: true))\n        }\n    \n    return thoughts\n}\n\npub struct User {\n    pub var name: String?\n    pub let address: Address \n    pub let findName: String? \n    pub var avatar: String? \n    pub let reaction: String\n\n    init(address: Address, reaction: String){\n        self.name = nil\n        self.findName = FIND.reverseLookup(address)\n        self.avatar = nil\n        self.reaction = reaction\n        self.address = address \n        let profileCap = getAccount(address).getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if profileCap.check() {\n            let p = profileCap.borrow()!\n            self.name = p.getName()\n            self.avatar = p.getAvatar()\n        }    \n    }\n}\n\npub struct Thought {\n    pub let id: UInt64 \n    pub let creator: Address \n    pub let creatorName: String? \n    pub var creatorProfileName: String? \n    pub var creatorAvatar: String? \n    pub var header: String?\n    pub var body: String?\n    pub let created: UFix64? \n    pub var lastUpdated: UFix64?\n    pub let medias: {String : String}\n    pub let nft: [FindMarket.NFTInfo]\n    pub var tags: [String]\n    pub var reacted: {String : [User]}\n    pub var reactions: {String : Int}\n    pub var reactedUsers: {String : [String]}\n    pub var quotedThought: Thought?\n    pub var hidden: Bool?\n\n    init(id: UInt64 , creator: Address , creatorName: String? , creatorProfileName: String? , creatorAvatar: String? , header: String? , body: String? , created: UFix64? , lastUpdated: UFix64?, medias: {String : String}, nft: [FindMarket.NFTInfo], tags: [String], reacted: {String : [User]}, reactions: {String : Int}, reactedUsers: {String : [String]}, quotedThought: Thought?, hidden: Bool?) {\n        self.id = id\n        self.creator = creator\n        self.creatorName = creatorName\n        self.creatorProfileName = creatorProfileName\n        self.creatorAvatar = creatorAvatar\n        self.header = header\n        self.body = body\n        self.created = created\n        self.lastUpdated = lastUpdated\n        self.medias = medias\n        self.nft = nft\n        self.tags = tags\n        self.reacted = reacted\n        self.reactions = reactions\n        self.reactedUsers = reactedUsers\n        self.quotedThought = quotedThought\n        self.hidden = hidden\n    }\n}\n\npub fun getThought(_ t: \u0026{FindThoughts.ThoughtPublic}, withQuote: Bool) : Thought {\n\n        var creatorProfileName : String? = nil\n        var creatorAvatar : String? = nil \n        let profileCap = getAccount(t.creator).getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if profileCap.check() {\n            creatorProfileName = profileCap.borrow()!.getName()\n            creatorAvatar = profileCap.borrow()!.getAvatar()\n        }\n\n        let medias : {String : String} = {}\n        for m in t.medias {\n            medias[m.file.uri()] = m.mediaType\n        }\n\n        let nft : [FindMarket.NFTInfo] = [] \n        for n in t.nft {\n            let vr = n.getViewResolver() \n            nft.append(FindMarket.NFTInfo(vr, id: n.id, detail: true))\n        }\n\n        let reacted : {String : [User]} = {}\n        let reactedUsers : {String :[String]} = {}\n        for user in t.reacted.keys {\n            let reaction = t.reacted[user]!\n            let allReacted = reacted[reaction] ?? []\n            let u = User(address: user, reaction: reaction)\n\n            allReacted.append(u)\n            reacted[reaction] = allReacted\n\n            let preReactedUser = reactedUsers[reaction] ?? []\n            preReactedUser.append(u.name ?? u.address.toString())\n            reactedUsers[reaction] = preReactedUser\n        }\n\n        var quotedThought : Thought? = nil \n        if withQuote {\n            if let p = t.getQuotedThought() {\n                if let ref = p.borrowThoughtPublic() {\n                    quotedThought = getThought(ref, withQuote: false)\n                } else {\n                    let creator = p.owner()\n                    var qCreatorProfileName : String? = nil\n                    var qCreatorAvatar : String? = nil \n                    let qProfileCap = getAccount(creator).getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n                    if qProfileCap.check() {\n                        qCreatorProfileName = qProfileCap.borrow()!.getName()\n                        qCreatorAvatar = qProfileCap.borrow()!.getAvatar()\n                    }\n\n                    quotedThought = Thought(\n                        id: p.id , \n                        creator: creator  , \n                        creatorName: FIND.reverseLookup(creator) , \n                        creatorProfileName: qCreatorProfileName , \n                        creatorAvatar: qCreatorAvatar, \n                        header: nil, \n                        body: nil , \n                        created: nil, \n                        lastUpdated: nil, \n                        medias: {}, \n                        nft: [], \n                        tags: [], \n                        reacted: {}, \n                        reactions: {}, \n                        reactedUsers: {},\n                        quotedThought: nil, \n                        hidden: false\n                    )    \n                }\n            }\n        }\n\n        return Thought(\n            id: t.id , \n            creator: t.creator  , \n            creatorName: FIND.reverseLookup(t.creator) , \n            creatorProfileName: creatorProfileName , \n            creatorAvatar: creatorAvatar, \n            header: t.header , \n            body: t.body , \n            created: t.created, \n            lastUpdated: t.lastUpdated, \n            medias: medias, \n            nft: nft, \n            tags: t.tags, \n            reacted: reacted, \n            reactions: t.reactions, \n            reactedUsers: reactedUsers,\n            quotedThought: quotedThought, \n            hidden: t.getHide()\n        )\n\n}",
               "spec": {
                  "order": [
                     "address"
                  ],
                  "parameters": {
                     "address": "Address"
                  }
               }
            },
            "getProfile": {
               "code": "import Profile from 0x179b6b1cb6755e31\nimport FIND from 0x179b6b1cb6755e31\n\npub fun main(user: String) :  Profile.UserReport? {\n    let resolveAddress = FIND.resolve(user) \n    if resolveAddress == nil {return nil}\n    let address = resolveAddress!\n    let account = getAccount(address)\n    if account.balance == 0.0 {\n        return nil\n    }\n\n    var profileReport = account\n        .getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        .borrow()?.asReport()\n\n    if profileReport != nil \u0026\u0026 profileReport!.findName != FIND.reverseLookup(address) {\n        profileReport = Profile.UserReport(\n            findName: \"\",\n            address: profileReport!.address,\n            name: profileReport!.name,\n            gender: profileReport!.gender,\n            description: profileReport!.description,\n            tags: profileReport!.tags,\n            avatar: profileReport!.avatar,\n            links: profileReport!.links,\n            wallets: profileReport!.wallets, \n            following: profileReport!.following,\n            followers: profileReport!.followers,\n            allowStoringFollowers: profileReport!.allowStoringFollowers,\n            createdAt: profileReport!.createdAt\n        )\n    }\n\n    return profileReport\n\n\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "getRoyaltyChangedIds": {
               "code": "import FindMarket from 0x179b6b1cb6755e31\nimport FIND from 0x179b6b1cb6755e31\n\npub fun main(marketplace: Address, user: String) : {String : [UInt64]} {\n    if let address = FIND.resolve(user){\n        return FindMarket.getRoyaltiesChangedIds(tenant:marketplace, address: address)\n    }\n    return {}\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "user"
                  ],
                  "parameters": {
                     "marketplace": "Address",
                     "user": "String"
                  }
               }
            },
            "getRoyaltyChangedItems": {
               "code": "import FindMarket from 0x179b6b1cb6755e31\nimport FIND from 0x179b6b1cb6755e31\n\npub fun main(marketplace: Address, user: String) : {String : FindMarket.SaleItemCollectionReport} {\n    if let address = FIND.resolve(user){\n        return FindMarket.getRoyaltiesChangedItems(tenant:marketplace, address: address)\n    }\n    return {}\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "user"
                  ],
                  "parameters": {
                     "marketplace": "Address",
                     "user": "String"
                  }
               }
            },
            "getShardCollectionsNFTCatalog": {
               "code": "import NonFungibleToken from 0xf8d6e0586b0a20c7\nimport FIND from 0x179b6b1cb6755e31\nimport FINDNFTCatalog from 0x179b6b1cb6755e31\n\npub fun main(user: String) : {String : CollectionLength} {\n\n    if let address = FIND.resolve(user) {\n\n        return getNFTIDs_Catalog(ownerAddress: address, cacheCollections: {})\n\n    }\n    return {}\n\n}\n\npub struct CollectionLength {\n    pub let shard : String \n    pub let length : Int \n    init(shard : String, length : Int ) {\n        self.shard=shard \n        self.length=length\n    }\n}\n\n// Helper function \n\npub fun resolveAddress(user: String) : Address? {\n    return FIND.resolve(user)\n}\n\npub fun getNFTIDs_Catalog(ownerAddress: Address, cacheCollections: {String:CollectionLength}) : {String:CollectionLength} {\n\n    let account = getAuthAccount(ownerAddress)\n\n    let types = FINDNFTCatalog.getCatalogTypeData()\n    for nftType in types.keys {\n\n        let typeData=types[nftType]!\n        let collectionKey=typeData.keys[0]\n        let catalogEntry = FINDNFTCatalog.getCatalogEntry(collectionIdentifier:collectionKey)!\n        let tempPathStr = \"catalog\".concat(collectionKey)\n        let tempPublicPath = PublicPath(identifier: tempPathStr)!\n        account.link\u003c\u0026NonFungibleToken.Collection\u003e(tempPublicPath, target: catalogEntry.collectionData.storagePath)\n        let cap= account.getCapability\u003c\u0026NonFungibleToken.Collection\u003e(tempPublicPath)\n        if cap.check(){\n            let collection = cap.borrow()!\n            let length = collection.ownedNFTs.length\n            if length == 0 {\n                continue\n            }\n            cacheCollections[collectionKey] = CollectionLength(shard: \"NFTCatalog\", length: length)\n        }\n    }\n    return cacheCollections\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "getStatus": {
               "code": "import FIND from 0x179b6b1cb6755e31\nimport Profile from 0x179b6b1cb6755e31\nimport FindRelatedAccounts from 0x179b6b1cb6755e31\nimport FindMarket from 0x179b6b1cb6755e31\nimport FindLeaseMarket from 0x179b6b1cb6755e31\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport EmeraldIdentity from 0xf8d6e0586b0a20c7\nimport EmeraldIdentityDapper from 0xf8d6e0586b0a20c7\nimport EmeraldIdentityLilico from 0xf8d6e0586b0a20c7\nimport TokenForwarding from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport Wearables from 0xf8d6e0586b0a20c7\n\npub struct FINDReport{\n    pub let isDapper: Bool\n    pub let profile:Profile.UserReport?\n    pub let bids: [FIND.BidInfo]\n\n    pub let leases: [FIND.LeaseInformation]\n    pub let privateMode: Bool\n    pub let leasesForSale: {String : FindLeaseMarket.SaleItemCollectionReport}\n    pub let leasesBids: {String : FindLeaseMarket.BidItemCollectionReport}\n    pub let itemsForSale: {String : FindMarket.SaleItemCollectionReport}\n    pub let marketBids: {String : FindMarket.BidItemCollectionReport}\n    pub let activatedAccount: Bool\n\n\n    // This is deprecating, moving to accounts\n    pub let relatedAccounts: { String: [Address]}\n\n     pub let lostAndFoundTypes: {String : String}\n    // This is deprecating, moving to accounts\n    // EmeraldID Account Linkage\n    pub let emeraldIDAccounts : {String : Address}\n\n    pub let accounts : [AccountInformation]?\n\n    pub let readyForWearables : Bool?\n\n    init(profile: Profile.UserReport?,\n         relatedAccounts: {String: [Address]},\n         bids: [FIND.BidInfo],\n         leases : [FIND.LeaseInformation],\n         privateMode: Bool,\n         leasesForSale: {String : FindLeaseMarket.SaleItemCollectionReport},\n         leasesBids: {String : FindLeaseMarket.BidItemCollectionReport},\n         itemsForSale: {String : FindMarket.SaleItemCollectionReport},\n         marketBids: {String : FindMarket.BidItemCollectionReport},\n         activatedAccount: Bool,\n         emeraldIDAccounts : {String : Address},\n         isDapper: Bool,\n         accounts: [AccountInformation]?,\n         readyForWearables: Bool?\n         ) {\n\n      self.lostAndFoundTypes={}\n        self.profile=profile\n        self.bids=bids\n        self.leases=leases\n        self.relatedAccounts=relatedAccounts\n        self.privateMode=privateMode\n        self.leasesForSale=leasesForSale\n        self.leasesBids=leasesBids\n        self.itemsForSale=itemsForSale\n        self.marketBids=marketBids\n        self.activatedAccount=activatedAccount\n        self.emeraldIDAccounts=emeraldIDAccounts\n        self.isDapper=isDapper\n        self.accounts=accounts\n        self.readyForWearables=readyForWearables\n    }\n}\n\npub struct AccountInformation {\n    pub let name: String\n    pub let address: String\n    pub let network: String\n    pub let trusted: Bool\n    pub let node: String\n\n    init(name: String, address: String, network: String, trusted: Bool, node: String) {\n        self.name = name\n        self.address = address\n        self.network = network\n        self.trusted = trusted\n        self.node = node\n    }\n}\n\npub struct NameReport {\n    pub let status: String\n    pub let cost: UFix64\n    pub let owner: Address?\n    pub let validUntil: UFix64?\n    pub let lockedUntil: UFix64?\n    pub let registeredTime: UFix64?\n\n    init(status: String, cost: UFix64, owner: Address?, validUntil: UFix64?, lockedUntil: UFix64?, registeredTime: UFix64? ) {\n        self.status=status\n        self.cost=cost\n        self.owner=owner\n        self.validUntil=validUntil\n        self.lockedUntil=lockedUntil\n        self.registeredTime=registeredTime\n    }\n}\n\npub struct Report {\n    pub let FINDReport: FINDReport?\n    pub let NameReport: NameReport?\n\n    init(FINDReport: FINDReport?, NameReport: NameReport?) {\n        self.FINDReport=FINDReport\n        self.NameReport=NameReport\n    }\n}\n\npub fun main(user: String) : Report? {\n\n    var findReport: FINDReport? = nil\n    if let address=FIND.resolve(user) {\n        let account=getAccount(address)\n        if account.balance \u003e 0.0 {\n\n            var isDapper=false\n            if let receiver =account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver).borrow() {\n                 isDapper=receiver.isInstance(Type\u003c@TokenForwarding.Forwarder\u003e())\n            } else {\n                if let duc = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver).borrow() {\n                    isDapper = duc.isInstance(Type\u003c@TokenForwarding.Forwarder\u003e())\n                } else {\n                    isDapper = false\n                }\n            }\n\n            let bidCap = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n            let leaseCap = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n            let profile=account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath).borrow()\n\n            let find= FindMarket.getFindTenantAddress()\n            var items : {String : FindMarket.SaleItemCollectionReport} = FindMarket.getSaleItemReport(tenant:find, address: address, getNFTInfo:true)\n\n            var marketBids : {String : FindMarket.BidItemCollectionReport} = FindMarket.getBidsReport(tenant:find, address: address, getNFTInfo:true)\n\n            let leasesSale : {String : FindLeaseMarket.SaleItemCollectionReport} = FindLeaseMarket.getSaleItemReport(tenant:find, address: address, getLeaseInfo:true)\n\n            let leasesBids : {String : FindLeaseMarket.BidItemCollectionReport} = FindLeaseMarket.getBidsReport(tenant:find, address: address, getLeaseInfo:true)\n\n            var profileReport = profile?.asReport()\n            if profileReport != nil \u0026\u0026 profileReport!.findName != FIND.reverseLookup(address) {\n                profileReport = Profile.UserReport(\n                    findName: \"\",\n                    address: profileReport!.address,\n                    name: profileReport!.name,\n                    gender: profileReport!.gender,\n                    description: profileReport!.description,\n                    tags: profileReport!.tags,\n                    avatar: profileReport!.avatar,\n                    links: profileReport!.links,\n                    wallets: profileReport!.wallets,\n                    following: profileReport!.following,\n                    followers: profileReport!.followers,\n                    allowStoringFollowers: profileReport!.allowStoringFollowers,\n                    createdAt: profileReport!.createdAt\n                )\n            }\n\n            /*\n            // NFTCatalog Output\n            let nftCatalogTypes = FINDNFTCatalog.getCatalogTypeData()\n            let types : {String : NFTCatalog.NFTCollectionData} = {}\n            for type in FindLostAndFoundWrapper.getSpecificRedeemableTypes(user: address, specificType: Type\u003c@NonFungibleToken.NFT\u003e()) {\n                types[type.identifier] = FINDNFTCatalog.getCollectionDataForType(nftTypeIdentifier: type.identifier)\n            }\n            */\n\n            let discordID = EmeraldIdentity.getDiscordFromAccount(account: address)\n                                    ?? EmeraldIdentityDapper.getDiscordFromAccount(account: address)\n                                    ?? EmeraldIdentityLilico.getDiscordFromAccount(account: address)\n                                    ?? \"\"\n\n            let emeraldIDAccounts : {String : Address} = {}\n            emeraldIDAccounts[\"blocto\"] = EmeraldIdentity.getAccountFromDiscord(discordID: discordID)\n            emeraldIDAccounts[\"lilico\"] = EmeraldIdentityLilico.getAccountFromDiscord(discordID: discordID)\n            emeraldIDAccounts[\"dapper\"] = EmeraldIdentityDapper.getAccountFromDiscord(discordID: discordID)\n\n            let accounts : [AccountInformation] = []\n            for wallet in [\"blocto\", \"lilico\", \"dapper\"] {\n                if let w = emeraldIDAccounts[wallet] {\n                    accounts.append(\n                        AccountInformation(\n                            name: wallet,\n                            address: w.toString(),\n                            network: \"Flow\",\n                            trusted: true,\n                            node: \"EmeraldID\")\n                    )\n                }\n            }\n\n            let allAcctsCap = FindRelatedAccounts.getCapability(address)\n            if allAcctsCap.check() {\n                let allAcctsRef = allAcctsCap.borrow()!\n                let allAccts = allAcctsRef.getAllRelatedAccountInfo()\n                for acct in allAccts.values {\n                    // We only verify flow accounts that are mutually linked\n                    var trusted = false\n                    if acct.address != nil {\n                        trusted = allAcctsRef.linked(name: acct.name, network: acct.network, address: acct.address!)\n                    }\n                    accounts.append(\n                        AccountInformation(\n                            name: acct.name,\n                            address: acct.stringAddress!,\n                            network: acct.network,\n                            trusted: trusted,\n                            node: \"FindRelatedAccounts\")\n                    )\n                }\n            }\n\n            let wearableAccount = getAuthAccount(address)\n            var readyForWearables = true\n            let wearablesRef= wearableAccount.borrow\u003c\u0026Wearables.Collection\u003e(from: Wearables.CollectionStoragePath)\n            if wearablesRef == nil {\n                readyForWearables = false\n            }\n\n            let wearablesCap= wearableAccount.getCapability\u003c\u0026Wearables.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(Wearables.CollectionPublicPath)\n            if !wearablesCap.check() {\n                readyForWearables = false\n            }\n\n            let wearablesProviderCap= wearableAccount.getCapability\u003c\u0026Wearables.Collection{NonFungibleToken.Provider,NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(Wearables.CollectionPrivatePath)\n            if !wearablesCap.check() {\n                readyForWearables = false\n            }\n\n            findReport = FINDReport(\n                profile: profileReport,\n                relatedAccounts: FindRelatedAccounts.findRelatedFlowAccounts(address:address),\n                bids: bidCap.borrow()?.getBids() ?? [],\n                leases: leaseCap.borrow()?.getLeaseInformation() ?? [],\n                privateMode: profile?.isPrivateModeEnabled() ?? false,\n                leasesForSale: leasesSale,\n                leasesBids: leasesBids,\n                itemsForSale: items,\n                marketBids: marketBids,\n                activatedAccount: true,\n                emeraldIDAccounts: emeraldIDAccounts,\n                isDapper:isDapper,\n                accounts: accounts,\n                readyForWearables: readyForWearables\n            )\n        } else {\n            findReport = FINDReport(\n                profile: nil,\n                relatedAccounts: {},\n                bids: [],\n                leases: [],\n                privateMode: false,\n                leasesForSale: {},\n                leasesBids: {},\n                itemsForSale: {},\n                marketBids: {},\n                activatedAccount: false,\n                emeraldIDAccounts: {},\n                isDapper: false,\n                accounts: nil,\n                readyForWearables: nil\n            )\n        }\n    }\n\n    var nameReport : NameReport? = nil\n    if FIND.validateFindName(user) {\n        let status = FIND.status(user)\n        let cost=FIND.calculateCost(user)\n        var s=\"TAKEN\"\n        if status.status == FIND.LeaseStatus.FREE {\n            s=\"FREE\"\n        } else if status.status == FIND.LeaseStatus.LOCKED {\n            s=\"LOCKED\"\n        }\n        let findAddr = FIND.getFindNetworkAddress()\n        let network = getAuthAccount(findAddr).borrow\u003c\u0026FIND.Network\u003e(from: FIND.NetworkStoragePath)!\n        let lease =  network.getLease(user)\n        nameReport = NameReport(status: s, cost: cost, owner: lease?.profile?.address, validUntil: lease?.validUntil, lockedUntil: lease?.lockedUntil, registeredTime: lease?.registeredTime)\n    }\n\n\n    return Report(FINDReport: findReport, NameReport: nameReport)\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "getStatusLostAndFound": {
               "code": "import FIND from 0x179b6b1cb6755e31\nimport FINDNFTCatalog from 0x179b6b1cb6755e31\nimport FindLostAndFoundWrapper from 0x179b6b1cb6755e31\nimport NFTCatalog from 0xf8d6e0586b0a20c7\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\n\npub fun main(user: String) :  {String : NFTCatalog.NFTCollectionData} {\n    let lostAndFoundTypes: {String : NFTCatalog.NFTCollectionData}={}\n\n    if let address=FIND.resolve(user) {\n        let account=getAccount(address)\n        if account.balance \u003e 0.0 {\n            // NFTCatalog Output\n            let nftCatalogTypes = FINDNFTCatalog.getCatalogTypeData()\n            let types : {String : NFTCatalog.NFTCollectionData} = {}\n            for type in FindLostAndFoundWrapper.getSpecificRedeemableTypes(user: address, specificType: Type\u003c@NonFungibleToken.NFT\u003e()) {\n                types[type.identifier] = FINDNFTCatalog.getCollectionDataForType(nftTypeIdentifier: type.identifier)\n            }\n        }\n    }\n    return lostAndFoundTypes\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "getTenantSaleItem": {
               "code": "import FindMarket from 0x179b6b1cb6755e31\n\npub fun main(tenant: Address) : TenantSaleItems {\n    let tenantCap = FindMarket.getTenantCapability(tenant) ?? panic(\"No tenant capability is set up. Tenant Address : \".concat(tenant.toString()))\n    let tenantRef = tenantCap.borrow() ?? panic(\"Cannot borrow tenant reference. Tenant Address : \".concat(tenant.toString()))\n    let saleItems = tenantRef.getSaleItems()\n    return TenantSaleItems(findSaleItems: saleItems[\"findSaleItems\"]! ,\n                           tenantSaleItems: saleItems[\"tenantSaleItems\"]! ,\n                           findCuts: saleItems[\"findCuts\"]! )\n\n}\n\npub struct TenantSaleItems {\n    pub let findSaleItems : {String : FindMarket.TenantSaleItem}\n    pub let tenantSaleItems : {String : FindMarket.TenantSaleItem}\n    pub let findCuts : {String : FindMarket.TenantSaleItem} \n\n    init(findSaleItems : {String : FindMarket.TenantSaleItem}, \n         tenantSaleItems : {String : FindMarket.TenantSaleItem},\n         findCuts : {String : FindMarket.TenantSaleItem}) {\n             self.findSaleItems = findSaleItems\n             self.tenantSaleItems = tenantSaleItems \n             self.findCuts = findCuts \n         }\n}",
               "spec": {
                  "order": [
                     "tenant"
                  ],
                  "parameters": {
                     "tenant": "Address"
                  }
               }
            },
            "hasCharity": {
               "code": "import CharityNFT from 0x179b6b1cb6755e31\n\npub fun main(user: Address) : Bool {\n    let account=getAccount(user)\n    if account.balance == 0.0 {\n        return false\n    }\n    let charityCap = account.getCapability\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection)\n    return charityCap.check()\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "Address"
                  }
               }
            },
            "isFindUser": {
               "code": "import Profile from 0x179b6b1cb6755e31\nimport FIND from 0x179b6b1cb6755e31\n\npub fun main(user: Address) : Bool {\n\n    let account=getAccount(user)\n    if account.balance == 0.0 {\n        return false\n    }\n    let leaseCap=account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n    let profileCap=account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\n    return leaseCap.check() \u0026\u0026 profileCap.check()\n\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "Address"
                  }
               }
            },
            "resolve": {
               "code": "import FIND from 0x179b6b1cb6755e31\n\npub fun main(name:String) : Address?{\n\n    return FIND.resolve(name)\n\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "reverseLookup": {
               "code": "import FIND from 0x179b6b1cb6755e31\n\npub fun main(addr:Address) : String?{\n\n    return FIND.reverseLookup(addr)\n\n}",
               "spec": {
                  "order": [
                     "addr"
                  ],
                  "parameters": {
                     "addr": "Address"
                  }
               }
            },
            "sendNFTs": {
               "code": "import NonFungibleToken from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport TokenForwarding from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport NFTCatalog from 0xf8d6e0586b0a20c7\nimport FINDNFTCatalog from 0x179b6b1cb6755e31\nimport Profile from 0x179b6b1cb6755e31\nimport FindViews from 0x179b6b1cb6755e31\nimport FIND from 0x179b6b1cb6755e31\nimport FindAirdropper from 0x179b6b1cb6755e31\nimport FindUtils from 0x179b6b1cb6755e31\n\npub fun main(sender: Address, nftIdentifiers: [String],  allReceivers:[String] , ids: [UInt64], memos: [String]) : [Report] {\n\n     fun logErr(_ i: Int , err: String) : Report {\n        return Report(receiver: allReceivers[i] , address: nil, inputName: nil, findName: nil, avatar: nil, isDapper: nil, type: nftIdentifiers[i], id: ids[i] , message: memos[i] ,receiverLinked: nil , collectionPublicLinked: nil , accountInitialized: nil , nftInPlace: nil, royalties: nil, err: err)\n    }\n\n        let paths : [PublicPath] = []\n        let contractData : {Type : NFTCatalog.NFTCatalogMetadata} = {}\n        let addresses : {String : Address} = {}\n\n        let account = getAuthAccount(sender)\n        let report : [Report] = []\n        for i , typeIdentifier in nftIdentifiers {\n            let checkType = CompositeType(typeIdentifier)\n            if checkType == nil {\n                report.append(logErr(i, err: \"Cannot refer to type with identifier : \".concat(typeIdentifier)))\n                continue\n            }\n            let type = checkType!\n\n            var data : NFTCatalog.NFTCatalogMetadata? = contractData[type]\n            if data == nil {\n                let checkData = FINDNFTCatalog.getMetadataFromType(type)\n                if checkData == nil {\n                    report.append(logErr(i, err: \"NFT Type is not supported by NFT Catalog. Type : \".concat(type.identifier)))\n                    continue\n                }\n                contractData[type] = checkData!\n                data = checkData!\n            }\n\n            let path = data!.collectionData\n\n            let checkCol = account.borrow\u003c\u0026NonFungibleToken.Collection\u003e(from: path.storagePath)\n            if checkCol == nil {\n                report.append(logErr(i, err: \"Cannot borrow collection from sender. Type : \".concat(type.identifier)))\n                continue\n            }\n            let ownedNFTs : \u0026{UInt64 : NonFungibleToken.NFT} = \u0026checkCol!.ownedNFTs as \u0026{UInt64 : NonFungibleToken.NFT}\n            let owned = ownedNFTs.containsKey(ids[i])\n\n            let receiver = allReceivers[i]\n            let id = ids[i]\n            let message = memos[i]\n\n            var user = addresses[receiver]\n            if user == nil {\n                let checkUser = FIND.resolve(receiver)\n                if checkUser == nil {\n                    report.append(logErr(i, err: \"Cannot resolve user with name / address : \".concat(receiver)))\n                    continue\n                }\n                addresses[receiver] = checkUser!\n                user = checkUser!\n            }\n            let checkAcct = getAccount(user!)\n            if checkAcct.balance == 0.0 {\n                report.append(logErr(i, err: \"Account is not an activated account\"))\n                continue\n            }\n\n\n            var isDapper=false\n            if let receiver =getAccount(user!).getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver).borrow() {\n                 isDapper=receiver.isInstance(Type\u003c@TokenForwarding.Forwarder\u003e())\n            } else {\n                if let duc = getAccount(user!).getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver).borrow() {\n                    isDapper = duc.isInstance(Type\u003c@TokenForwarding.Forwarder\u003e())\n                }\n            }\n\n            // check receiver account storage\n            let receiverCap = getAccount(user!).getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(path.publicPath)\n            let collectionPublicCap = getAccount(user!).getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(path.publicPath)\n            let storage = getAuthAccount(user!).type(at: path.storagePath)\n\n            var storageInited = false\n            if storage != nil \u0026\u0026 checkSameContract(collection: storage!, nft: type){\n                storageInited = true\n            }\n\n            var royalties : Royalties? = nil\n            let mv = account.borrow\u003c\u0026{MetadataViews.ResolverCollection}\u003e(from: path.storagePath)\n            if mv != nil {\n                let rv = mv!.borrowViewResolver(id: id)\n                if let r = MetadataViews.getRoyalties(rv) {\n                    royalties = Royalties(r)\n                }\n            }\n\n            var inputName : String? = receiver\n            var findName : String? = FIND.reverseLookup(user!)\n            if FindUtils.hasPrefix(receiver, prefix: \"0x\") {\n                inputName = nil\n            }\n\n            var avatar : String? = nil\n            if let profile = getAccount(user!).getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath).borrow() {\n                avatar = profile.getAvatar()\n            }\n\n            let r = Report(receiver: allReceivers[i] , address: user, inputName: inputName, findName: findName, avatar: avatar, isDapper: isDapper, type: nftIdentifiers[i], id: ids[i] , message: memos[i] ,receiverLinked: receiverCap.check() , collectionPublicLinked: collectionPublicCap.check() , accountInitialized: storageInited , nftInPlace: owned, royalties:royalties, err: nil)\n            report.append(r)\n        }\n\n    return report\n}\n\n\npub struct Report {\n    pub let receiver: String\n    pub let address: Address?\n    pub let inputName: String?\n    pub let findName: String?\n    pub let avatar: String?\n    pub let isDapper: Bool?\n    pub let type: String\n    pub let id: UInt64\n    pub let message: String\n    pub var ok: Bool\n    pub let receiverLinked: Bool?\n    pub let collectionPublicLinked: Bool?\n    pub let accountInitialized: Bool?\n    pub let nftInPlace: Bool?\n    pub let royalties: Royalties?\n    pub let err: String?\n\n    init(receiver: String , address: Address?, inputName: String?, findName: String?, avatar: String?, isDapper: Bool? , type: String, id: UInt64 , message: String ,receiverLinked: Bool? , collectionPublicLinked: Bool? , accountInitialized: Bool? , nftInPlace: Bool?, royalties: Royalties?, err: String?) {\n        self.receiver=receiver\n        self.address=address\n        self.inputName=inputName\n        self.findName=findName\n        self.avatar=avatar\n        self.isDapper=isDapper\n        self.type=type\n        self.id=id\n        self.message=message\n        self.receiverLinked=receiverLinked\n        self.collectionPublicLinked=collectionPublicLinked\n        self.accountInitialized=accountInitialized\n        self.nftInPlace=nftInPlace\n        self.err=err\n        self.royalties=royalties\n        self.ok = false\n        if accountInitialized == true \u0026\u0026 nftInPlace == true {\n            if receiverLinked == true || collectionPublicLinked == true {\n                self.ok = true\n            }\n        }\n    }\n}\n\npub struct Royalties {\n    pub let totalRoyalty: UFix64\n    pub let royalties: [Royalty]\n\n    init(_ royalties: MetadataViews.Royalties) {\n        var totalR = 0.0\n        let array : [Royalty] = []\n        for r in royalties.getRoyalties() {\n            array.append(Royalty(r))\n            totalR = totalR + r.cut\n        }\n        self.totalRoyalty = totalR\n        self.royalties = array\n    }\n}\n\npub struct Royalty {\n    pub let name: String?\n    pub let address: Address\n    pub let cut: UFix64\n    pub let acceptTypes: [String]\n    pub let description: String\n\n    init(_ r: MetadataViews.Royalty) {\n        self.name = FIND.reverseLookup(r.receiver.address)\n        self.address = r.receiver.address\n        self.cut = r.cut\n        self.description = r.description\n        let acceptTypes : [String] = []\n        if r.receiver.check() {\n            let ref = r.receiver.borrow()!\n            let t = ref.getType()\n            if t.isInstance(Type\u003c@FungibleToken.Vault\u003e()) {\n                acceptTypes.append(t.identifier)\n            } else if t == Type\u003c@TokenForwarding.Forwarder\u003e() {\n                acceptTypes.append(Type\u003c@FlowToken.Vault\u003e().identifier)\n            } else if t == Type\u003c@Profile.User\u003e() {\n                let ref = getAccount(r.receiver.address).getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath).borrow()!\n                let wallets = ref.getWallets()\n                for w in wallets {\n                    acceptTypes.append(w.accept.identifier)\n                }\n            }\n        }\n        self.acceptTypes = acceptTypes\n    }\n}\n\npub fun checkSameContract(collection: Type, nft: Type) : Bool {\n    let colType = collection.identifier\n    let croppedCol = colType.slice(from: 0 , upTo : colType.length - \"collection\".length)\n    let nftType = nft.identifier\n    let croppedNft = nftType.slice(from: 0 , upTo : nftType.length - \"nft\".length)\n    if croppedCol == croppedNft {\n        return true\n    }\n    return false\n}",
               "spec": {
                  "order": [
                     "sender",
                     "nftIdentifiers",
                     "allReceivers",
                     "ids",
                     "memos"
                  ],
                  "parameters": {
                     "allReceivers": "[String]",
                     "ids": "[UInt64]",
                     "memos": "[String]",
                     "nftIdentifiers": "[String]",
                     "sender": "Address"
                  }
               }
            }
         },
         "transactions": {
            "acceptDirectOfferSoft": {
               "code": "import FindMarketDirectOfferSoft from 0x179b6b1cb6755e31\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FindViews from 0x179b6b1cb6755e31\nimport FINDNFTCatalog from 0x179b6b1cb6755e31\nimport FindMarket from 0x179b6b1cb6755e31\n\ntransaction(marketplace:Address, id: UInt64) {\n\n    let market : \u0026FindMarketDirectOfferSoft.SaleItemCollection\n    let pointer : FindViews.AuthNFTPointer\n\n    prepare(account: AuthAccount) {\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e())\n        self.market = account.borrow\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection\u003e(from: storagePath)!\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e())\n        let item = FindMarket.assertOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: id)\n        let nftIdentifier = item.getItemType().identifier\n\n        //If this is nil, there must be something wrong with FIND setup\n        // let privatePath = getPrivatePath(nftIdentifier)\n\n        let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier)) \n        let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n        let privatePath = collection.collectionData.privatePath\n\n\n        let providerCap=account.getCapability\u003c\u0026{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e(privatePath)\n        self.pointer= FindViews.AuthNFTPointer(cap: providerCap, id: item.getItemID())\n    }\n\n    execute {\n        self.market.acceptOffer(self.pointer)\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "acceptDirectOfferSoftDapper": {
               "code": "import FindMarketDirectOfferSoft from 0x179b6b1cb6755e31\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FindViews from 0x179b6b1cb6755e31\nimport NFTCatalog from 0xf8d6e0586b0a20c7\nimport FINDNFTCatalog from 0x179b6b1cb6755e31\nimport FindMarket from 0x179b6b1cb6755e31\nimport FungibleToken from 0xee82856bf20e2aa6\n\ntransaction(marketplace:Address, id: UInt64) {\n\n    let market : \u0026FindMarketDirectOfferSoft.SaleItemCollection\n    let pointer : FindViews.AuthNFTPointer\n\n    prepare(account: AuthAccount) {\n\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e())\n        self.market = account.borrow\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection\u003e(from: storagePath)!\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e())\n        let item = FindMarket.assertOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: id)\n        let nftIdentifier = item.getItemType().identifier\n\n        let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier)) \n        let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n        let nft = collection.collectionData\n\n        let providerCap=account.getCapability\u003c\u0026{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e(nft.privatePath)\n        self.pointer= FindViews.AuthNFTPointer(cap: providerCap, id: item.getItemID())\n\n    }\n\n    execute {\n        self.market.acceptOffer(self.pointer)\n    }\n    \n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "acceptLeaseDirectOfferSoft": {
               "code": "import FindLeaseMarketDirectOfferSoft from 0x179b6b1cb6755e31\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FindViews from 0x179b6b1cb6755e31\nimport FindMarket from 0x179b6b1cb6755e31\nimport FindLeaseMarket from 0x179b6b1cb6755e31\nimport FIND from 0x179b6b1cb6755e31\n\ntransaction(leaseName: String) {\n\n    let market : \u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection\n    let pointer : FindLeaseMarket.AuthLeasePointer\n\n    prepare(account: AuthAccount) {\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e())\n        self.market = account.borrow\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(from: storagePath)!\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e())\n        let item = FindLeaseMarket.assertOperationValid(tenant: marketplace, name: leaseName, marketOption: marketOption)\n        let ref = account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from: FIND.LeaseStoragePath) ?? panic(\"Cannot borrow reference to find lease collection. Account : \".concat(account.address.toString()))\n        self.pointer= FindLeaseMarket.AuthLeasePointer(ref: ref, name: leaseName)\n    }\n\n    execute {\n        self.market.acceptOffer(self.pointer)\n    }\n}",
               "spec": {
                  "order": [
                     "leaseName"
                  ],
                  "parameters": {
                     "leaseName": "String"
                  }
               }
            },
            "acceptLeaseDirectOfferSoftDapper": {
               "code": "import FindLeaseMarketDirectOfferSoft from 0x179b6b1cb6755e31\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FindViews from 0x179b6b1cb6755e31\nimport FindMarket from 0x179b6b1cb6755e31\nimport FindLeaseMarket from 0x179b6b1cb6755e31\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FIND from 0x179b6b1cb6755e31\n\ntransaction(leaseName: String) {\n\n    let market : \u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection\n    let pointer : FindLeaseMarket.AuthLeasePointer\n\n    prepare(account: AuthAccount) {\n\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e())\n        self.market = account.borrow\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(from: storagePath)!\n\n        let ref = account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from: FIND.LeaseStoragePath) ?? panic(\"Cannot borrow reference to Find lease collection. Account : \".concat(account.address.toString()))\n        self.pointer= FindLeaseMarket.AuthLeasePointer(ref: ref, name: leaseName)\n\n    }\n\n    execute {\n        self.market.acceptOffer(self.pointer)\n    }\n\n}",
               "spec": {
                  "order": [
                     "leaseName"
                  ],
                  "parameters": {
                     "leaseName": "String"
                  }
               }
            },
            "acceptMultipleDirectOfferSoft": {
               "code": "import FindMarketDirectOfferSoft from 0x179b6b1cb6755e31\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FindViews from 0x179b6b1cb6755e31\nimport NFTCatalog from 0xf8d6e0586b0a20c7\nimport FINDNFTCatalog from 0x179b6b1cb6755e31\nimport FindMarket from 0x179b6b1cb6755e31\n\ntransaction(marketplace:Address, ids: [UInt64]) {\n\n    let market : \u0026FindMarketDirectOfferSoft.SaleItemCollection\n    let pointer : [FindViews.AuthNFTPointer]\n\n    prepare(account: AuthAccount) {\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e())\n        self.market = account.borrow\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection\u003e(from: storagePath)!\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e())\n\n        var counter = 0\n        self.pointer = []\n        let nfts : {String : NFTCatalog.NFTCollectionData} = {}\n\n        while counter \u003c ids.length {\n            let item = FindMarket.assertOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: ids[counter])\n            var nft : NFTCatalog.NFTCollectionData? = nil\n            let nftIdentifier = item.getItemType().identifier\n\n            if nfts[nftIdentifier] != nil {\n                nft = nfts[nftIdentifier]\n            } else {\n                // nft = getCollectionData(nftIdentifier) \n                let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier)) \n                let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n                nft = collection.collectionData\n                nfts[nftIdentifier] = nft\n            }\n\n            let providerCap=account.getCapability\u003c\u0026{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e(nft!.privatePath)\n            let pointer= FindViews.AuthNFTPointer(cap: providerCap, id: item.getItemID())\n            self.pointer.append(pointer)\n            counter = counter + 1\n        }\n    }\n\n    execute {\n        var counter = 0\n        while counter \u003c ids.length {\n            self.market.acceptOffer(self.pointer[counter])\n            counter = counter + 1\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "ids"
                  ],
                  "parameters": {
                     "ids": "[UInt64]",
                     "marketplace": "Address"
                  }
               }
            },
            "acceptMultipleDirectOfferSoftDapper": {
               "code": "import FindMarketDirectOfferSoft from 0x179b6b1cb6755e31\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FindViews from 0x179b6b1cb6755e31\nimport NFTCatalog from 0xf8d6e0586b0a20c7\nimport FINDNFTCatalog from 0x179b6b1cb6755e31\nimport FindMarket from 0x179b6b1cb6755e31\nimport FungibleToken from 0xee82856bf20e2aa6\n\ntransaction(marketplace:Address, ids: [UInt64]) {\n\n    let market : \u0026FindMarketDirectOfferSoft.SaleItemCollection\n    let pointer : [FindViews.AuthNFTPointer]\n\n    prepare(account: AuthAccount) {\n\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e())\n        self.market = account.borrow\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection\u003e(from: storagePath)!\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e())\n\n        var counter = 0\n        self.pointer = []\n        let nfts : {String : NFTCatalog.NFTCollectionData} = {}\n\n        while counter \u003c ids.length {\n            let item = FindMarket.assertOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: ids[counter])\n            var nft : NFTCatalog.NFTCollectionData? = nil\n            let nftIdentifier = item.getItemType().identifier\n            let ftType = item.getFtType()\n\n            if nfts[nftIdentifier] != nil {\n                nft = nfts[nftIdentifier]\n            } else {\n                // nft = getCollectionData(nftIdentifier) \n                let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier)) \n                let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n                nft = collection.collectionData\n                nfts[nftIdentifier] = nft\n            }\n\n            let providerCap=account.getCapability\u003c\u0026{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e(nft!.privatePath)\n            let pointer= FindViews.AuthNFTPointer(cap: providerCap, id: item.getItemID())\n            self.pointer.append(pointer)\n            counter = counter + 1\n        }\n\n    }\n\n    execute {\n        var counter = 0\n        while counter \u003c ids.length {\n            self.market.acceptOffer(self.pointer[counter])\n            counter = counter + 1\n        }\n    }\n    \n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "ids"
                  ],
                  "parameters": {
                     "ids": "[UInt64]",
                     "marketplace": "Address"
                  }
               }
            },
            "addCuratedCollection": {
               "code": "transaction(name: String, items: [String]) {\n    prepare(account: AuthAccount) {\n\n        let path=/storage/FindCuratedCollections\n        let publicPath=/public/FindCuratedCollections\n\n        var collections : {String: [String]} = {}\n        if account.borrow\u003c\u0026{String: [String]}\u003e(from:path) != nil {\n             collections=account.load\u003c{String: [String]}\u003e(from:path)!\n        }\n        collections[name] = items\n        account.save(collections, to: path)\n        let link = account.getCapability\u003c\u0026{String: [String]}\u003e(publicPath)\n        if !link.check() {\n            account.link\u003c\u0026{String: [String]}\u003e( publicPath, target: path)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "items"
                  ],
                  "parameters": {
                     "items": "[String]",
                     "name": "String"
                  }
               }
            },
            "addRelatedAccount": {
               "code": "import FindRelatedAccounts from 0x179b6b1cb6755e31\n\ntransaction(name: String, network: String, address: String) {\n\n    var relatedAccounts : \u0026FindRelatedAccounts.Accounts?\n\n    prepare(account: AuthAccount) {\n\n        self.relatedAccounts= account.borrow\u003c\u0026FindRelatedAccounts.Accounts\u003e(from:FindRelatedAccounts.storagePath)\n        if self.relatedAccounts == nil {\n            let relatedAccounts \u003c- FindRelatedAccounts.createEmptyAccounts()\n            account.save(\u003c- relatedAccounts, to: FindRelatedAccounts.storagePath)\n            account.link\u003c\u0026FindRelatedAccounts.Accounts{FindRelatedAccounts.Public}\u003e(FindRelatedAccounts.publicPath, target: FindRelatedAccounts.storagePath)\n            self.relatedAccounts = account.borrow\u003c\u0026FindRelatedAccounts.Accounts\u003e(from:FindRelatedAccounts.storagePath)\n        }\n\n        let cap = account.getCapability\u003c\u0026FindRelatedAccounts.Accounts{FindRelatedAccounts.Public}\u003e(FindRelatedAccounts.publicPath)\n        if !cap.check() {\n            account.unlink(FindRelatedAccounts.publicPath)\n            account.link\u003c\u0026FindRelatedAccounts.Accounts{FindRelatedAccounts.Public}\u003e(FindRelatedAccounts.publicPath, target: FindRelatedAccounts.storagePath)\n        }\n    }\n\n    execute {\n        self.relatedAccounts!.addRelatedAccount(name:name, network:network, address: address)\n    }\n\n}",
               "spec": {
                  "order": [
                     "name",
                     "network",
                     "address"
                  ],
                  "parameters": {
                     "address": "String",
                     "name": "String",
                     "network": "String"
                  }
               }
            },
            "addRelatedFlowAccount": {
               "code": "import FindRelatedAccounts from 0x179b6b1cb6755e31\n\ntransaction(name: String, address: Address) {\n\n    var relatedAccounts : \u0026FindRelatedAccounts.Accounts?\n\n    prepare(account: AuthAccount) {\n\n        self.relatedAccounts= account.borrow\u003c\u0026FindRelatedAccounts.Accounts\u003e(from:FindRelatedAccounts.storagePath)\n        if self.relatedAccounts == nil {\n            let relatedAccounts \u003c- FindRelatedAccounts.createEmptyAccounts()\n            account.save(\u003c- relatedAccounts, to: FindRelatedAccounts.storagePath)\n            account.link\u003c\u0026FindRelatedAccounts.Accounts{FindRelatedAccounts.Public}\u003e(FindRelatedAccounts.publicPath, target: FindRelatedAccounts.storagePath)\n            self.relatedAccounts = account.borrow\u003c\u0026FindRelatedAccounts.Accounts\u003e(from:FindRelatedAccounts.storagePath)\n        }\n\n        let cap = account.getCapability\u003c\u0026FindRelatedAccounts.Accounts{FindRelatedAccounts.Public}\u003e(FindRelatedAccounts.publicPath)\n        if !cap.check() {\n            account.unlink(FindRelatedAccounts.publicPath)\n            account.link\u003c\u0026FindRelatedAccounts.Accounts{FindRelatedAccounts.Public}\u003e(FindRelatedAccounts.publicPath, target: FindRelatedAccounts.storagePath)\n        }\n    }\n\n    execute {\n        self.relatedAccounts!.addFlowAccount(name:name, address: address)\n    }\n\n}",
               "spec": {
                  "order": [
                     "name",
                     "address"
                  ],
                  "parameters": {
                     "address": "Address",
                     "name": "String"
                  }
               }
            },
            "alterMarketOption": {
               "code": "import FindMarket from 0x179b6b1cb6755e31\n\ntransaction(marketRule: String , action: String ){\n    prepare(account: AuthAccount){\n        let path = FindMarket.TenantClientStoragePath\n        let tenantRef = account.borrow\u003c\u0026FindMarket.TenantClient\u003e(from: path) ?? panic(\"Cannot borrow Reference.\")\n\n\n        switch action {\n            case \"enable\" :\n                tenantRef.enableMarketOption(marketRule)\n\n            case \"deprecate\" :\n                tenantRef.deprecateMarketOption(marketRule)\n\n            case \"stop\" :\n                tenantRef.stopMarketOption(marketRule)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "marketRule",
                     "action"
                  ],
                  "parameters": {
                     "action": "String",
                     "marketRule": "String"
                  }
               }
            },
            "bidLeaseMarketAuctionSoft": {
               "code": "import FungibleToken from 0xee82856bf20e2aa6\nimport Profile from 0x179b6b1cb6755e31\nimport FTRegistry from 0x179b6b1cb6755e31\nimport FindMarket from 0x179b6b1cb6755e31\nimport FIND from 0x179b6b1cb6755e31\nimport FindLeaseMarket from 0x179b6b1cb6755e31\nimport FindLeaseMarketAuctionSoft from 0x179b6b1cb6755e31\n\ntransaction(leaseName: String, amount: UFix64) {\n\n    let saleItemsCap: Capability\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic}\u003e\n    let walletReference : \u0026FungibleToken.Vault\n    let bidsReference: \u0026FindLeaseMarketAuctionSoft.MarketBidCollection?\n    let balanceBeforeBid: UFix64\n    let ftVaultType: Type\n\n    prepare(account: AuthAccount) {\n\n        let resolveAddress = FIND.resolve(leaseName)\n        if resolveAddress == nil {panic(\"The address input is not a valid name nor address. Input : \".concat(leaseName))}\n        let address = resolveAddress!\n\n        let leaseMarketplace = FindMarket.getFindTenantAddress()\n        let leaseTenantCapability= FindMarket.getTenantCapability(leaseMarketplace)!\n        let leaseTenant = leaseTenantCapability.borrow()!\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let leaseASBidType= Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e()\n        let leaseASBidPublicPath=leaseTenant.getPublicPath(leaseASBidType)\n        let leaseASBidStoragePath= leaseTenant.getStoragePath(leaseASBidType)\n        let leaseASBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath)\n        if !leaseASBidCap.check() {\n            account.save\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseASBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath, target: leaseASBidStoragePath)\n        }\n\n        self.saleItemsCap= FindLeaseMarketAuctionSoft.getSaleItemCapability(marketplace:leaseMarketplace, user:address) ?? panic(\"cannot find sale item cap\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e())\n\n        let item = FindLeaseMarket.assertOperationValid(tenant: leaseMarketplace, name: leaseName, marketOption: marketOption)\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n\n        self.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account. Account address : \".concat(account.address.toString()))\n        self.ftVaultType = ft.type\n\n        let bidStoragePath=leaseTenant.getStoragePath(Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e())\n\n        self.bidsReference= account.borrow\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(from: bidStoragePath)\n        self.balanceBeforeBid=self.walletReference.balance\n    }\n\n    pre {\n        self.bidsReference != nil : \"This account does not have a bid collection\"\n        self.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n    }\n\n    execute {\n        self.bidsReference!.bid(name:leaseName, amount: amount, vaultType: self.ftVaultType, bidExtraField: {})\n    }\n}",
               "spec": {
                  "order": [
                     "leaseName",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "leaseName": "String"
                  }
               }
            },
            "bidLeaseMarketAuctionSoftDapper": {
               "code": "import Profile from 0x179b6b1cb6755e31\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FTRegistry from 0x179b6b1cb6755e31\nimport FindMarket from 0x179b6b1cb6755e31\nimport FIND from 0x179b6b1cb6755e31\nimport FindLeaseMarketAuctionSoft from 0x179b6b1cb6755e31\nimport FindLeaseMarket from 0x179b6b1cb6755e31\n\ntransaction(leaseName: String, amount: UFix64) {\n\n    let saleItemsCap: Capability\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic}\u003e\n    let bidsReference: \u0026FindLeaseMarketAuctionSoft.MarketBidCollection?\n    let ftVaultType: Type\n\n    prepare(account: AuthAccount) {\n\n        let resolveAddress = FIND.resolve(leaseName)\n        if resolveAddress == nil {panic(\"The address input is not a valid name nor address. Input : \".concat(leaseName))}\n        let address = resolveAddress!\n\n        let leaseMarketplace = FindMarket.getFindTenantAddress()\n        let leaseTenantCapability= FindMarket.getTenantCapability(leaseMarketplace)!\n        let leaseTenant = leaseTenantCapability.borrow()!\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let leaseASBidType= Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e()\n        let leaseASBidPublicPath=leaseTenant.getPublicPath(leaseASBidType)\n        let leaseASBidStoragePath= leaseTenant.getStoragePath(leaseASBidType)\n        let leaseASBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath)\n        if !leaseASBidCap.check() {\n            account.save\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseASBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath, target: leaseASBidStoragePath)\n        }\n\n        self.saleItemsCap= FindLeaseMarketAuctionSoft.getSaleItemCapability(marketplace:leaseMarketplace, user:address) ?? panic(\"cannot find sale item cap\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e())\n\n        let item = FindLeaseMarket.assertOperationValid(tenant: leaseMarketplace, name: leaseName, marketOption: marketOption)\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n\n        self.ftVaultType = ft.type\n\n        let bidStoragePath=leaseTenant.getStoragePath(Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e())\n\n        self.bidsReference= account.borrow\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(from: bidStoragePath)\n    }\n\n    pre {\n        self.bidsReference != nil : \"This account does not have a bid collection\"\n    }\n\n    execute {\n        self.bidsReference!.bid(name:leaseName, amount: amount, vaultType: self.ftVaultType, bidExtraField: {})\n    }\n}",
               "spec": {
                  "order": [
                     "leaseName",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "leaseName": "String"
                  }
               }
            },
            "bidLeaseMarketDirectOfferSoft": {
               "code": "import Profile from 0x179b6b1cb6755e31\nimport FindMarket from 0x179b6b1cb6755e31\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FTRegistry from 0x179b6b1cb6755e31\nimport FIND from 0x179b6b1cb6755e31\nimport FindLeaseMarket from 0x179b6b1cb6755e31\nimport FindLeaseMarketDirectOfferSoft from 0x179b6b1cb6755e31\n\ntransaction(leaseName: String, ftAliasOrIdentifier:String, amount: UFix64, validUntil: UFix64?) {\n\n    let bidsReference: \u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection?\n    let ftVaultType: Type\n\n    prepare(account: AuthAccount) {\n\n\n        let resolveAddress = FIND.resolve(leaseName)\n        if resolveAddress == nil {panic(\"The address input is not a valid name nor address. Input : \".concat(leaseName))}\n        let address = resolveAddress!\n\n        let ft = FTRegistry.getFTInfo(ftAliasOrIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftAliasOrIdentifier))\n\n        self.ftVaultType = ft.type\n\n        let walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n        assert(walletReference.balance \u003e amount , message: \"Bidder has to have enough balance in wallet\")\n\n        let leaseMarketplace = FindMarket.getFindTenantAddress()\n        let leaseTenantCapability= FindMarket.getTenantCapability(leaseMarketplace)!\n        let leaseTenant = leaseTenantCapability.borrow()!\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let leaseDOSBidType= Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let leaseDOSBidPublicPath=leaseTenant.getPublicPath(leaseDOSBidType)\n        let leaseDOSBidStoragePath= leaseTenant.getStoragePath(leaseDOSBidType)\n        let leaseDOSBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath)\n        if !leaseDOSBidCap.check() {\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOSBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath, target: leaseDOSBidStoragePath)\n        }\n\n        self.bidsReference= account.borrow\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(from: leaseDOSBidStoragePath)\n\n    }\n\n    pre {\n        self.bidsReference != nil : \"This account does not have a bid collection\"\n    }\n\n    execute {\n        self.bidsReference!.bid(name:leaseName, amount: amount, vaultType: self.ftVaultType, validUntil: validUntil, saleItemExtraField: {}, bidExtraField: {})\n    }\n}",
               "spec": {
                  "order": [
                     "leaseName",
                     "ftAliasOrIdentifier",
                     "amount",
                     "validUntil"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "ftAliasOrIdentifier": "String",
                     "leaseName": "String",
                     "validUntil": "UFix64?"
                  }
               }
            },
            "bidLeaseMarketDirectOfferSoftDapper": {
               "code": "import FungibleToken from 0xee82856bf20e2aa6\nimport Profile from 0x179b6b1cb6755e31\nimport FindMarket from 0x179b6b1cb6755e31\nimport FTRegistry from 0x179b6b1cb6755e31\nimport FIND from 0x179b6b1cb6755e31\nimport FindLeaseMarket from 0x179b6b1cb6755e31\nimport FindLeaseMarketDirectOfferSoft from 0x179b6b1cb6755e31\n\ntransaction(leaseName: String, ftAliasOrIdentifier:String, amount: UFix64, validUntil: UFix64?) {\n\n    let bidsReference: \u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection?\n    let ftVaultType: Type\n\n    prepare(account: AuthAccount) {\n\n        let ft = FTRegistry.getFTInfo(ftAliasOrIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftAliasOrIdentifier))\n\n        self.ftVaultType = ft.type\n\n        let leaseMarketplace = FindMarket.getFindTenantAddress()\n        let leaseTenantCapability= FindMarket.getTenantCapability(leaseMarketplace)!\n        let leaseTenant = leaseTenantCapability.borrow()!\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let leaseDOSBidType= Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let leaseDOSBidPublicPath=leaseTenant.getPublicPath(leaseDOSBidType)\n        let leaseDOSBidStoragePath= leaseTenant.getStoragePath(leaseDOSBidType)\n        let leaseDOSBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath)\n        if !leaseDOSBidCap.check() {\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOSBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath, target: leaseDOSBidStoragePath)\n        }\n\n        self.bidsReference= account.borrow\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(from: leaseDOSBidStoragePath)\n\n    }\n\n    pre {\n        self.bidsReference != nil : \"This account does not have a bid collection\"\n    }\n\n    execute {\n        self.bidsReference!.bid(name:leaseName, amount: amount, vaultType: self.ftVaultType, validUntil: validUntil, saleItemExtraField: {}, bidExtraField: {})\n    }\n}",
               "spec": {
                  "order": [
                     "leaseName",
                     "ftAliasOrIdentifier",
                     "amount",
                     "validUntil"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "ftAliasOrIdentifier": "String",
                     "leaseName": "String",
                     "validUntil": "UFix64?"
                  }
               }
            },
            "bidMarketAuctionEscrowed": {
               "code": "import FindMarketAuctionEscrow from 0x179b6b1cb6755e31\nimport FungibleToken from 0xee82856bf20e2aa6\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FindViews from 0x179b6b1cb6755e31\nimport FINDNFTCatalog from 0x179b6b1cb6755e31\nimport FTRegistry from 0x179b6b1cb6755e31\nimport FindMarket from 0x179b6b1cb6755e31\nimport FIND from 0x179b6b1cb6755e31\nimport Profile from 0x179b6b1cb6755e31\n\ntransaction(marketplace:Address, user: String, id: UInt64, amount: UFix64) {\n\n    let saleItemsCap: Capability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic}\u003e \n    var targetCapability : Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e\n    let walletReference : \u0026FungibleToken.Vault\n    let bidsReference: \u0026FindMarketAuctionEscrow.MarketBidCollection?\n    let balanceBeforeBid: UFix64\n    let pointer: FindViews.ViewReadPointer\n\n    prepare(account: AuthAccount) {\n        let resolveAddress = FIND.resolve(user)\n        if resolveAddress == nil {panic(\"The address input is not a valid name nor address. Input : \".concat(user))}\n        let address = resolveAddress!\n\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n        let tenant = tenantCapability.borrow()!\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        /// auctions that escrow ft\n        let aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\n        let aeBidPublicPath=FindMarket.getPublicPath(aeBidType, name: tenant.name)\n        let aeBidStoragePath= FindMarket.getStoragePath(aeBidType, name:tenant.name)\n        let aeBidCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n        if !aeBidCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n        }\n\n        self.saleItemsCap= FindMarketAuctionEscrow.getSaleItemCapability(marketplace:marketplace, user:address) ?? panic(\"cannot find sale item cap. User address : \".concat(address.toString()))\n\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e())\n        let item = FindMarket.assertOperationValid(tenant: marketplace, address: address, marketOption: marketOption, id: id)\n\n        let nftIdentifier = item.getItemType().identifier\n        let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier)) \n        let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n        let nft = collection.collectionData\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n    \n        self.targetCapability= account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(nft.publicPath)\n        /* Check for nftCapability */\n        if !self.targetCapability.check() {\n            let cd = item.getNFTCollectionData()\n            // should use account.type here instead\n            if account.type(at: cd.storagePath) != nil {\n                let pathIdentifier = nft.publicPath.toString()\n                let findPath = PublicPath(identifier: pathIdentifier.slice(from: \"/public/\".length , upTo: pathIdentifier.length).concat(\"_FIND\"))!\n                account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                    findPath,\n                    target: nft.storagePath\n                )\n                self.targetCapability = account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(findPath)\n            } else {\n                account.save(\u003c- cd.createEmptyCollection(), to: cd.storagePath)\n                account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.publicPath, target: cd.storagePath)\n                account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.providerPath, target: cd.storagePath)\n            }\n\n        }\n        \n        self.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n        \n        let bidSstoragePath=tenant.getStoragePath(Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e())\n\n        self.bidsReference= account.borrow\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection\u003e(from: bidSstoragePath)\n        self.balanceBeforeBid=self.walletReference.balance\n        self.pointer= FindViews.createViewReadPointer(address: address, path:nft.publicPath, id: item.getItemID())\n    }\n\n    pre {\n        self.bidsReference != nil : \"This account does not have a bid collection\"\n        self.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount) \n        self.bidsReference!.bid(item:self.pointer, vault: \u003c- vault, nftCap: self.targetCapability, bidExtraField: {})\n    }\n\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "user",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64",
                     "marketplace": "Address",
                     "user": "String"
                  }
               }
            },
            "bidMarketAuctionSoft": {
               "code": "import FindMarketAuctionSoft from 0x179b6b1cb6755e31\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FindViews from 0x179b6b1cb6755e31\nimport FTRegistry from 0x179b6b1cb6755e31\nimport FINDNFTCatalog from 0x179b6b1cb6755e31\nimport FindMarket from 0x179b6b1cb6755e31\nimport FIND from 0x179b6b1cb6755e31\nimport Profile from 0x179b6b1cb6755e31\n\ntransaction(marketplace:Address, user: String, id: UInt64, amount: UFix64) {\n\n    let saleItemsCap: Capability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic}\u003e \n    var targetCapability : Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e\n    let walletReference : \u0026FungibleToken.Vault\n    let bidsReference: \u0026FindMarketAuctionSoft.MarketBidCollection?\n    let balanceBeforeBid: UFix64\n    let pointer: FindViews.ViewReadPointer\n    let ftVaultType: Type\n\n    prepare(account: AuthAccount) {\n\n        let resolveAddress = FIND.resolve(user)\n        if resolveAddress == nil {panic(\"The address input is not a valid name nor address. Input : \".concat(user))}\n        let address = resolveAddress!\n\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n        let tenant = tenantCapability.borrow()!\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n        if !asBidCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n        }\n\n        self.saleItemsCap= FindMarketAuctionSoft.getSaleItemCapability(marketplace:marketplace, user:address) ?? panic(\"cannot find sale item cap\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e())\n\n        let item = FindMarket.assertOperationValid(tenant: marketplace, address: address, marketOption: marketOption, id: id)\n\n        let nftIdentifier = item.getItemType().identifier\n        let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier)) \n        let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n        let nft = collection.collectionData\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n    \n        self.targetCapability= account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(nft.publicPath)\n        /* Check for nftCapability */\n        if !self.targetCapability.check() {\n            let cd = item.getNFTCollectionData()\n            // should use account.type here instead\n            if account.type(at: cd.storagePath) != nil {\n                let pathIdentifier = nft.publicPath.toString()\n                let findPath = PublicPath(identifier: pathIdentifier.slice(from: \"/public/\".length , upTo: pathIdentifier.length).concat(\"_FIND\"))!\n                account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                    findPath,\n                    target: nft.storagePath\n                )\n                self.targetCapability = account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(findPath)\n            } else {\n                account.save(\u003c- cd.createEmptyCollection(), to: cd.storagePath)\n                account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.publicPath, target: cd.storagePath)\n                account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.providerPath, target: cd.storagePath)\n            }\n\n        }\n        \n        self.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account. Account address : \".concat(account.address.toString()))\n        self.ftVaultType = ft.type\n\n        let bidStoragePath=tenant.getStoragePath(Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e())\n\n        self.bidsReference= account.borrow\u003c\u0026FindMarketAuctionSoft.MarketBidCollection\u003e(from: bidStoragePath)\n        self.balanceBeforeBid=self.walletReference.balance\n        self.pointer= FindViews.createViewReadPointer(address: address, path:nft.publicPath, id: item.getItemID())\n    }\n\n    pre {\n        self.bidsReference != nil : \"This account does not have a bid collection\"\n        self.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n    }\n\n    execute {\n        self.bidsReference!.bid(item:self.pointer, amount: amount, vaultType: self.ftVaultType, nftCap: self.targetCapability, bidExtraField: {})\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "user",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64",
                     "marketplace": "Address",
                     "user": "String"
                  }
               }
            },
            "bidMarketAuctionSoftDapper": {
               "code": "import FindMarketAuctionSoft from 0x179b6b1cb6755e31\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FindViews from 0x179b6b1cb6755e31\nimport FTRegistry from 0x179b6b1cb6755e31\nimport FINDNFTCatalog from 0x179b6b1cb6755e31\nimport FindMarket from 0x179b6b1cb6755e31\nimport FIND from 0x179b6b1cb6755e31\nimport Profile from 0x179b6b1cb6755e31\n\ntransaction(marketplace:Address, user: String, id: UInt64, amount: UFix64) {\n\n    let saleItemsCap: Capability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic}\u003e \n    var targetCapability : Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e\n    let bidsReference: \u0026FindMarketAuctionSoft.MarketBidCollection?\n    let pointer: FindViews.ViewReadPointer\n    let ftVaultType: Type\n\n    prepare(account: AuthAccount) {\n\n        let resolveAddress = FIND.resolve(user)\n        if resolveAddress == nil {panic(\"The address input is not a valid name nor address. Input : \".concat(user))}\n        let address = resolveAddress!\n\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n        let tenant = tenantCapability.borrow()!\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n        if !asBidCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n        }\n\n        self.saleItemsCap= FindMarketAuctionSoft.getSaleItemCapability(marketplace:marketplace, user:address) ?? panic(\"cannot find sale item cap\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e())\n\n        let item = FindMarket.assertOperationValid(tenant: marketplace, address: address, marketOption: marketOption, id: id)\n\n        let nftIdentifier = item.getItemType().identifier\n        let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier)) \n        let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n        let nft = collection.collectionData\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n    \n        self.targetCapability= account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(nft.publicPath)\n        /* Check for nftCapability */\n        if !self.targetCapability.check() {\n            let cd = item.getNFTCollectionData()\n            // should use account.type here instead\n            if account.type(at: cd.storagePath) != nil {\n                let pathIdentifier = nft.publicPath.toString()\n                let findPath = PublicPath(identifier: pathIdentifier.slice(from: \"/public/\".length , upTo: pathIdentifier.length).concat(\"_FIND\"))!\n                account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                    findPath,\n                    target: nft.storagePath\n                )\n                self.targetCapability = account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(findPath)\n            } else {\n                account.save(\u003c- cd.createEmptyCollection(), to: cd.storagePath)\n                account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.publicPath, target: cd.storagePath)\n                account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.providerPath, target: cd.storagePath)\n            }\n\n        }\n        \n        self.ftVaultType = ft.type\n\n        let bidStoragePath=tenant.getStoragePath(Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e())\n\n        self.bidsReference= account.borrow\u003c\u0026FindMarketAuctionSoft.MarketBidCollection\u003e(from: bidStoragePath)\n        self.pointer= FindViews.createViewReadPointer(address: address, path:nft.publicPath, id: item.getItemID())\n    }\n\n    pre {\n        self.bidsReference != nil : \"This account does not have a bid collection\"\n    }\n\n    execute {\n        self.bidsReference!.bid(item:self.pointer, amount: amount, vaultType: self.ftVaultType, nftCap: self.targetCapability, bidExtraField: {})\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "user",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64",
                     "marketplace": "Address",
                     "user": "String"
                  }
               }
            },
            "bidMarketDirectOfferEscrowed": {
               "code": "import Profile from 0x179b6b1cb6755e31\nimport FindMarket from 0x179b6b1cb6755e31\nimport FindMarketDirectOfferEscrow from 0x179b6b1cb6755e31\nimport FungibleToken from 0xee82856bf20e2aa6\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FindViews from 0x179b6b1cb6755e31\nimport FTRegistry from 0x179b6b1cb6755e31\nimport FINDNFTCatalog from 0x179b6b1cb6755e31\nimport FIND from 0x179b6b1cb6755e31\n\ntransaction(marketplace:Address, user: String, nftAliasOrIdentifier: String, id: UInt64, ftAliasOrIdentifier:String, amount: UFix64, validUntil: UFix64?) {\n\n    var targetCapability : Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e\n    let walletReference : \u0026FungibleToken.Vault\n    let bidsReference: \u0026FindMarketDirectOfferEscrow.MarketBidCollection?\n    let pointer: FindViews.ViewReadPointer\n\n    prepare(account: AuthAccount) {\n\n        let resolveAddress = FIND.resolve(user)\n        if resolveAddress == nil {panic(\"The address input is not a valid name nor address. Input : \".concat(user))}\n        let address = resolveAddress!\n\n        let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftAliasOrIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftAliasOrIdentifier)) \n        let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n        let nft = collection.collectionData\n\n        let ft = FTRegistry.getFTInfo(ftAliasOrIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftAliasOrIdentifier))\n        \n        self.targetCapability= account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(nft.publicPath)\n        self.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n        let tenant = tenantCapability.borrow()!\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        let doeBidPublicPath=FindMarket.getPublicPath(doeBidType, name: tenant.name)\n        let doeBidStoragePath= FindMarket.getStoragePath(doeBidType, name:tenant.name)\n        let doeBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n        if !doeBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n        }\n\n        self.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection\u003e(from: doeBidStoragePath)\n        self.pointer= FindViews.createViewReadPointer(address: address, path:nft.publicPath, id: id)\n\n        /* Check for nftCapability */\n        if !self.targetCapability.check() {\n            let cd = self.pointer.getNFTCollectionData()\n            // should use account.type here instead\n            if account.type(at: cd.storagePath) != nil {\n                let pathIdentifier = nft.publicPath.toString()\n                let findPath = PublicPath(identifier: pathIdentifier.slice(from: \"/public/\".length , upTo: pathIdentifier.length).concat(\"_FIND\"))!\n                account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                    findPath,\n                    target: nft.storagePath\n                )\n                self.targetCapability = account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(findPath)\n            } else {\n                account.save(\u003c- cd.createEmptyCollection(), to: cd.storagePath)\n                account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.publicPath, target: cd.storagePath)\n                account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.providerPath, target: cd.storagePath)\n            }\n\n        }\n    }\n\n    pre {\n        self.bidsReference != nil : \"This account does not have a bid collection\"\n        self.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount) \n        self.bidsReference!.bid(item:self.pointer, vault: \u003c- vault, nftCap: self.targetCapability, validUntil: validUntil, saleItemExtraField: {}, bidExtraField: {})\n    }\n\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "user",
                     "nftAliasOrIdentifier",
                     "id",
                     "ftAliasOrIdentifier",
                     "amount",
                     "validUntil"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "ftAliasOrIdentifier": "String",
                     "id": "UInt64",
                     "marketplace": "Address",
                     "nftAliasOrIdentifier": "String",
                     "user": "String",
                     "validUntil": "UFix64?"
                  }
               }
            },
            "bidMarketDirectOfferSoft": {
               "code": "import Profile from 0x179b6b1cb6755e31\nimport FindMarketDirectOfferSoft from 0x179b6b1cb6755e31\nimport FindMarket from 0x179b6b1cb6755e31\nimport FungibleToken from 0xee82856bf20e2aa6\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FindViews from 0x179b6b1cb6755e31\nimport FTRegistry from 0x179b6b1cb6755e31\nimport FINDNFTCatalog from 0x179b6b1cb6755e31\nimport FIND from 0x179b6b1cb6755e31\n\ntransaction(marketplace:Address, user: String, nftAliasOrIdentifier: String, id: UInt64, ftAliasOrIdentifier:String, amount: UFix64, validUntil: UFix64?) {\n\n    var targetCapability : Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e\n    let walletReference : \u0026FungibleToken.Vault\n    let bidsReference: \u0026FindMarketDirectOfferSoft.MarketBidCollection?\n    let balanceBeforeBid: UFix64\n    let pointer: FindViews.ViewReadPointer\n    let ftVaultType: Type\n\n    prepare(account: AuthAccount) {\n        \n        let resolveAddress = FIND.resolve(user)\n        if resolveAddress == nil {panic(\"The address input is not a valid name nor address. Input : \".concat(user))}\n        let address = resolveAddress!\n\n        let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftAliasOrIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftAliasOrIdentifier)) \n        let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n        let nft = collection.collectionData\n\n        let ft = FTRegistry.getFTInfo(ftAliasOrIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftAliasOrIdentifier))\n\n        self.ftVaultType = ft.type\n\n        self.targetCapability= account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(nft.publicPath)\n        self.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n        let tenant = tenantCapability.borrow()!\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n        if !dosBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n        }\n\n        self.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection\u003e(from: dosBidStoragePath)\n        self.balanceBeforeBid=self.walletReference.balance\n        self.pointer= FindViews.createViewReadPointer(address: address, path:nft.publicPath, id: id)\n\n        /* Check for nftCapability */\n        if !self.targetCapability.check() {\n            let cd = self.pointer.getNFTCollectionData()\n            // should use account.type here instead\n            if account.type(at: cd.storagePath) != nil {\n                let pathIdentifier = nft.publicPath.toString()\n                let findPath = PublicPath(identifier: pathIdentifier.slice(from: \"/public/\".length , upTo: pathIdentifier.length).concat(\"_FIND\"))!\n                account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                    findPath,\n                    target: nft.storagePath\n                )\n                self.targetCapability = account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(findPath)\n            } else {\n                account.save(\u003c- cd.createEmptyCollection(), to: cd.storagePath)\n                account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.publicPath, target: cd.storagePath)\n                account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.providerPath, target: cd.storagePath)\n            }\n\n        }\n    }\n\n    pre {\n        self.bidsReference != nil : \"This account does not have a bid collection\"\n        self.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n    }\n\n    execute {\n        self.bidsReference!.bid(item:self.pointer, amount: amount, vaultType: self.ftVaultType, nftCap: self.targetCapability, validUntil: validUntil, saleItemExtraField: {}, bidExtraField: {})\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "user",
                     "nftAliasOrIdentifier",
                     "id",
                     "ftAliasOrIdentifier",
                     "amount",
                     "validUntil"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "ftAliasOrIdentifier": "String",
                     "id": "UInt64",
                     "marketplace": "Address",
                     "nftAliasOrIdentifier": "String",
                     "user": "String",
                     "validUntil": "UFix64?"
                  }
               }
            },
            "bidMarketDirectOfferSoftDapper": {
               "code": "import Profile from 0x179b6b1cb6755e31\nimport FindMarketDirectOfferSoft from 0x179b6b1cb6755e31\nimport FindMarket from 0x179b6b1cb6755e31\nimport FungibleToken from 0xee82856bf20e2aa6\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FindViews from 0x179b6b1cb6755e31\nimport FINDNFTCatalog from 0x179b6b1cb6755e31\nimport FTRegistry from 0x179b6b1cb6755e31\nimport FIND from 0x179b6b1cb6755e31\n\ntransaction(marketplace:Address, user: String, nftAliasOrIdentifier: String, id: UInt64, ftAliasOrIdentifier: String, amount: UFix64, validUntil: UFix64?) {\n\n    var targetCapability : Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e\n    let bidsReference: \u0026FindMarketDirectOfferSoft.MarketBidCollection?\n    let pointer: FindViews.ViewReadPointer\n    let ftVaultType: Type\n\n    prepare(account: AuthAccount) {\n        \n        let resolveAddress = FIND.resolve(user)\n        if resolveAddress == nil {panic(\"The address input is not a valid name nor address. Input : \".concat(user))}\n        let address = resolveAddress!\n\n        let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftAliasOrIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftAliasOrIdentifier)) \n        let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n        let nft = collection.collectionData\n\n        let ft = FTRegistry.getFTInfo(ftAliasOrIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftAliasOrIdentifier))\n\n        self.ftVaultType = ft.type\n\n        self.targetCapability= account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(nft.publicPath)\n\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n        let tenant = tenantCapability.borrow()!\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n        if !dosBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n        }\n\n        self.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection\u003e(from: dosBidStoragePath)\n        self.pointer= FindViews.createViewReadPointer(address: address, path:nft.publicPath, id: id)\n\n        /* Check for nftCapability */\n        if !self.targetCapability.check() {\n            let cd = self.pointer.getNFTCollectionData()\n            // should use account.type here instead\n            if account.type(at: cd.storagePath) != nil {\n                let pathIdentifier = nft.publicPath.toString()\n                let findPath = PublicPath(identifier: pathIdentifier.slice(from: \"/public/\".length , upTo: pathIdentifier.length).concat(\"_FIND\"))!\n                account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                    findPath,\n                    target: nft.storagePath\n                )\n                self.targetCapability = account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(findPath)\n            } else {\n                account.save(\u003c- cd.createEmptyCollection(), to: cd.storagePath)\n                account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.publicPath, target: cd.storagePath)\n                account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.providerPath, target: cd.storagePath)\n            }\n\n        }\n    }\n\n    pre {\n        self.bidsReference != nil : \"This account does not have a bid collection\"\n    }\n\n    execute {\n        self.bidsReference!.bid(item:self.pointer, amount: amount, vaultType: self.ftVaultType, nftCap: self.targetCapability, validUntil: validUntil, saleItemExtraField: {}, bidExtraField: {})\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "user",
                     "nftAliasOrIdentifier",
                     "id",
                     "ftAliasOrIdentifier",
                     "amount",
                     "validUntil"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "ftAliasOrIdentifier": "String",
                     "id": "UInt64",
                     "marketplace": "Address",
                     "nftAliasOrIdentifier": "String",
                     "user": "String",
                     "validUntil": "UFix64?"
                  }
               }
            },
            "bidMultipleMarketDirectOfferEscrowed": {
               "code": "import FindMarket from 0x179b6b1cb6755e31\nimport FindMarketSale from 0x179b6b1cb6755e31\nimport FindMarketDirectOfferEscrow from 0x179b6b1cb6755e31\nimport FungibleToken from 0xee82856bf20e2aa6\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FindViews from 0x179b6b1cb6755e31\nimport FTRegistry from 0x179b6b1cb6755e31\nimport NFTCatalog from 0xf8d6e0586b0a20c7\nimport FINDNFTCatalog from 0x179b6b1cb6755e31\nimport FIND from 0x179b6b1cb6755e31\n\ntransaction(marketplace:Address, users: [String], nftAliasOrIdentifiers: [String], ids: [UInt64], ftAliasOrIdentifiers:[String], amounts: [UFix64], validUntil: UFix64?) {\n\n    let targetCapability : [Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e]\n    let walletReference : [\u0026FungibleToken.Vault]\n    let bidsReference: \u0026FindMarketDirectOfferEscrow.MarketBidCollection?\n    let pointer: [FindViews.ViewReadPointer]\n\n    prepare(account: AuthAccount) {\n\n        if nftAliasOrIdentifiers.length != users.length {\n            panic(\"The length of arrays passed in has to be the same\")\n        } else if nftAliasOrIdentifiers.length != ids.length {\n            panic(\"The length of arrays passed in has to be the same\")\n        } else if nftAliasOrIdentifiers.length != ftAliasOrIdentifiers.length {\n            panic(\"The length of arrays passed in has to be the same\")\n        } else if nftAliasOrIdentifiers.length != amounts.length {\n            panic(\"The length of arrays passed in has to be the same\")\n        }\n\n        let addresses : {String : Address} = {}\n        let nfts : {String : NFTCatalog.NFTCollectionData} = {}\n        let fts : {String : FTRegistry.FTInfo} = {}\n\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketSale.SaleItemCollection\u003e())\n        let vaultRefs : {StoragePath : \u0026FungibleToken.Vault} = {}\n\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n        let tenant = tenantCapability.borrow()!\n        let bidStoragePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e())\n\n        self.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection\u003e(from: bidStoragePath)\n        self.walletReference = []\n        self.pointer = []\n        self.targetCapability = []\n\n        var counter = 0\n        while counter \u003c users.length {\n            var resolveAddress : Address? = nil\n            if addresses[users[counter]] != nil {\n                resolveAddress = addresses[users[counter]]!\n            } else {\n                let address = FIND.resolve(users[counter])\n                if address == nil {\n                    panic(\"The address input is not a valid name nor address. Input : \".concat(users[counter]))\n                }\n                addresses[users[counter]] = address!\n                resolveAddress = address!\n            }\n            let address = resolveAddress!\n\n            var nft : NFTCatalog.NFTCollectionData? = nil\n            var ft : FTRegistry.FTInfo? = nil\n            let nftIdentifier = nftAliasOrIdentifiers[counter]\n            let ftIdentifier = ftAliasOrIdentifiers[counter]\n\n            if nfts[nftIdentifier] != nil {\n                nft = nfts[nftIdentifier]\n            } else {\n                let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier))\n                let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])!\n                nft =  collection.collectionData\n\n                nfts[nftIdentifier] = nft\n            }\n\n            if fts[ftIdentifier] != nil {\n                ft = fts[ftIdentifier]\n            } else {\n                ft = FTRegistry.getFTInfo(ftIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftIdentifier))\n                fts[ftIdentifier] = ft\n            }\n\n            if vaultRefs[ft!.vaultPath] != nil {\n                self.walletReference.append(vaultRefs[ft!.vaultPath]!)\n            } else {\n                let walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft!.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n                vaultRefs[ft!.vaultPath] = walletReference\n                self.walletReference.append(walletReference)\n            }\n\n            let pointer= FindViews.createViewReadPointer(address: address, path:nft!.publicPath, id: ids[counter])\n            self.pointer.append(pointer)\n\n            var targetCapability= account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(nft!.publicPath)\n            /* Check for nftCapability */\n            if !targetCapability.check() {\n                let cd = pointer.getNFTCollectionData()\n                // should use account.type here instead\n                if account.type(at: cd.storagePath) != nil {\n                    let pathIdentifier = nft!.publicPath.toString()\n                    let findPath = PublicPath(identifier: pathIdentifier.slice(from: \"/public/\".length , upTo: pathIdentifier.length).concat(\"_FIND\"))!\n                    account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                        findPath,\n                        target: nft!.storagePath\n                    )\n                    targetCapability = account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(findPath)\n                } else {\n                    account.save(\u003c- cd.createEmptyCollection(), to: cd.storagePath)\n                    account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.publicPath, target: cd.storagePath)\n                    account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.providerPath, target: cd.storagePath)\n                }\n\n            }\n            self.targetCapability.append(targetCapability)\n            counter = counter + 1\n        }\n    }\n\n    pre {\n        self.bidsReference != nil : \"This account does not have a bid collection\"\n    }\n\n    execute {\n        var counter = 0\n        while counter \u003c ids.length {\n            if self.walletReference[counter].balance \u003c amounts[counter] {\n                panic(\"Your wallet does not have enough funds to pay for this item. Fund Type : \".concat(ftAliasOrIdentifiers[counter]).concat(\"Required Amount : \").concat(amounts[counter].toString()))\n            }\n            let vault \u003c- self.walletReference[counter].withdraw(amount: amounts[counter])\n            self.bidsReference!.bid(item:self.pointer[counter], vault: \u003c- vault, nftCap: self.targetCapability[counter], validUntil: validUntil, saleItemExtraField: {}, bidExtraField: {})\n            counter = counter + 1\n        }\n    }\n\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "users",
                     "nftAliasOrIdentifiers",
                     "ids",
                     "ftAliasOrIdentifiers",
                     "amounts",
                     "validUntil"
                  ],
                  "parameters": {
                     "amounts": "[UFix64]",
                     "ftAliasOrIdentifiers": "[String]",
                     "ids": "[UInt64]",
                     "marketplace": "Address",
                     "nftAliasOrIdentifiers": "[String]",
                     "users": "[String]",
                     "validUntil": "UFix64?"
                  }
               }
            },
            "bidMultipleMarketDirectOfferSoft": {
               "code": "import FindMarketDirectOfferSoft from 0x179b6b1cb6755e31\nimport FindMarket from 0x179b6b1cb6755e31\nimport FungibleToken from 0xee82856bf20e2aa6\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FindViews from 0x179b6b1cb6755e31\nimport FTRegistry from 0x179b6b1cb6755e31\nimport NFTCatalog from 0xf8d6e0586b0a20c7\nimport FINDNFTCatalog from 0x179b6b1cb6755e31\nimport FIND from 0x179b6b1cb6755e31\n\ntransaction(marketplace:Address, users: [String], nftAliasOrIdentifiers: [String], ids: [UInt64], ftAliasOrIdentifiers:[String], amounts: [UFix64], validUntil: UFix64?) {\n\n    let targetCapability : [Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e]\n    let walletReference : [\u0026FungibleToken.Vault]\n    let bidsReference: \u0026FindMarketDirectOfferSoft.MarketBidCollection?\n    let pointer: [FindViews.ViewReadPointer]\n    let ftVaultType: [Type]\n    let totalPrice : {String : UFix64}\n\n    prepare(account: AuthAccount) {\n\n        if nftAliasOrIdentifiers.length != users.length {\n            panic(\"The length of arrays passed in has to be the same\")\n        } else if nftAliasOrIdentifiers.length != ids.length {\n            panic(\"The length of arrays passed in has to be the same\")\n        } else if nftAliasOrIdentifiers.length != ftAliasOrIdentifiers.length {\n            panic(\"The length of arrays passed in has to be the same\")\n        } else if nftAliasOrIdentifiers.length != amounts.length {\n            panic(\"The length of arrays passed in has to be the same\")\n        }\n\n        let addresses : {String : Address} = {}\n        let nfts : {String : NFTCatalog.NFTCollectionData} = {}\n        let fts : {String : FTRegistry.FTInfo} = {}\n        let vaultRefs : {StoragePath : \u0026FungibleToken.Vault} = {}\n        \n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n        let tenant = tenantCapability.borrow()!\n        let bidStoragePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n        self.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection\u003e(from: bidStoragePath)\n        self.walletReference = []\n        self.pointer = []\n        self.targetCapability = []\n        self.ftVaultType = []\n        self.totalPrice = {}\n\n        var counter = 0\n        while counter \u003c users.length {\n            var resolveAddress : Address? = nil\n            if addresses[users[counter]] != nil {\n                resolveAddress = addresses[users[counter]]!\n            } else {\n                let address = FIND.resolve(users[counter])\n                if address == nil {\n                    panic(\"The address input is not a valid name nor address. Input : \".concat(users[counter]))\n                }\n                addresses[users[counter]] = address!\n                resolveAddress = address!\n            }\n            let address = resolveAddress!\n\n            var nft : NFTCatalog.NFTCollectionData? = nil\n            var ft : FTRegistry.FTInfo? = nil\n            let nftIdentifier = nftAliasOrIdentifiers[counter]\n            let ftIdentifier = ftAliasOrIdentifiers[counter]\n\n            if nfts[nftIdentifier] != nil {\n                nft = nfts[nftIdentifier]\n            } else {\n                let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier)) \n                let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n                nft = collection.collectionData\n                nfts[nftIdentifier] = nft\n            }\n\n            if fts[ftIdentifier] != nil {\n                ft = fts[ftIdentifier]\n            } else {\n                ft = FTRegistry.getFTInfo(ftIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftIdentifier))\n                fts[ftIdentifier] = ft \n            }\n        \n            if vaultRefs[ft!.vaultPath] != nil {\n                self.walletReference.append(vaultRefs[ft!.vaultPath]!)\n                self.ftVaultType.append(vaultRefs[ft!.vaultPath]!.getType())\n            } else {\n                let walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft!.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n                vaultRefs[ft!.vaultPath] = walletReference\n                self.walletReference.append(walletReference)\n                self.ftVaultType.append(ft!.type)\n            }\n\n            if self.totalPrice[ftIdentifier] == nil {\n                self.totalPrice[ftIdentifier] = amounts[counter]\n            } else {\n                self.totalPrice[ftIdentifier] = self.totalPrice[ftIdentifier]! + amounts[counter]\n            }\n\n            let pointer= FindViews.createViewReadPointer(address: address, path:nft!.publicPath, id: ids[counter])\n            self.pointer.append(pointer)\n\n            var targetCapability= account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(nft!.publicPath)\n\n            /* Check for nftCapability */\n            if !targetCapability.check() {\n                let cd = pointer.getNFTCollectionData()\n                // should use account.type here instead\n                if account.type(at: cd.storagePath) != nil {\n                    let pathIdentifier = nft!.publicPath.toString()\n                    let findPath = PublicPath(identifier: pathIdentifier.slice(from: \"/public/\".length , upTo: pathIdentifier.length).concat(\"_FIND\"))!\n                    account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                        findPath,\n                        target: nft!.storagePath\n                    )\n                    targetCapability = account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(findPath)\n                } else {\n                    account.save(\u003c- cd.createEmptyCollection(), to: cd.storagePath)\n                    account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.publicPath, target: cd.storagePath)\n                    account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.providerPath, target: cd.storagePath)\n                }\n\n            }\n            self.targetCapability.append(targetCapability)\n            counter = counter + 1\n        }\n    }\n\n    pre {\n        self.bidsReference != nil : \"This account does not have a bid collection\"\n    }\n\n    execute {\n        var counter = 0\n        while counter \u003c ids.length {\n            if self.walletReference[counter].balance \u003c self.totalPrice[ftAliasOrIdentifiers[counter]]! {\n                panic(\"Your wallet does not have enough funds to pay for this item. Vault Type : \".concat(self.ftVaultType[counter].getType().identifier).concat(\" . Required : \".concat(self.totalPrice[ftAliasOrIdentifiers[counter]]!.toString())))\n            }    \n            self.bidsReference!.bid(item:self.pointer[counter], amount: amounts[counter], vaultType: self.ftVaultType[counter], nftCap: self.targetCapability[counter], validUntil: validUntil, saleItemExtraField: {}, bidExtraField: {})\n            counter = counter + 1 \n        }\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "users",
                     "nftAliasOrIdentifiers",
                     "ids",
                     "ftAliasOrIdentifiers",
                     "amounts",
                     "validUntil"
                  ],
                  "parameters": {
                     "amounts": "[UFix64]",
                     "ftAliasOrIdentifiers": "[String]",
                     "ids": "[UInt64]",
                     "marketplace": "Address",
                     "nftAliasOrIdentifiers": "[String]",
                     "users": "[String]",
                     "validUntil": "UFix64?"
                  }
               }
            },
            "bidMultipleMarketDirectOfferSoftDapper": {
               "code": "import FindMarketSale from 0x179b6b1cb6755e31\nimport FindMarketDirectOfferSoft from 0x179b6b1cb6755e31\nimport FindMarket from 0x179b6b1cb6755e31\nimport FungibleToken from 0xee82856bf20e2aa6\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FindViews from 0x179b6b1cb6755e31\nimport NFTCatalog from 0xf8d6e0586b0a20c7\nimport FINDNFTCatalog from 0x179b6b1cb6755e31\nimport FTRegistry from 0x179b6b1cb6755e31\nimport FIND from 0x179b6b1cb6755e31\n\ntransaction(marketplace:Address, users: [String], nftAliasOrIdentifiers: [String], ids: [UInt64], ftAliasOrIdentifiers: [String], amounts: [UFix64], validUntil: UFix64?) {\n\n    let targetCapability : [Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e]\n    let bidsReference: \u0026FindMarketDirectOfferSoft.MarketBidCollection?\n    let pointer: [FindViews.ViewReadPointer]\n    let walletReference : [\u0026FungibleToken.Vault]\n    let ftVaultType: [Type]\n    let walletBalances : {Type : UFix64}\n\n    prepare(account: AuthAccount) {\n\n        if nftAliasOrIdentifiers.length != users.length {\n            panic(\"The length of arrays passed in has to be the same\")\n        } else if nftAliasOrIdentifiers.length != ids.length {\n            panic(\"The length of arrays passed in has to be the same\")\n        } else if nftAliasOrIdentifiers.length != amounts.length {\n            panic(\"The length of arrays passed in has to be the same\")\n        }\n        \n        let addresses : {String : Address} = {}\n        let nfts : {String : NFTCatalog.NFTCollectionData} = {}\n        let fts : {String : FTRegistry.FTInfo} = {}\n\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketSale.SaleItemCollection\u003e())\n        let vaultType : {String : Type} = {}\n\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n        let tenant = tenantCapability.borrow()!\n        let bidStoragePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n        self.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection\u003e(from: bidStoragePath)\n        \n        self.pointer = []\n        self.targetCapability = []\n        self.walletReference = []\n        self.ftVaultType = []\n        self.walletBalances = {}\n\n        var counter = 0\n        while counter \u003c users.length {\n            var resolveAddress : Address? = nil\n            if addresses[users[counter]] != nil {\n                resolveAddress = addresses[users[counter]]!\n            } else {\n                let address = FIND.resolve(users[counter])\n                if address == nil {\n                    panic(\"The address input is not a valid name nor address. Input : \".concat(users[counter]))\n                }\n                addresses[users[counter]] = address!\n                resolveAddress = address!\n            }\n            let address = resolveAddress!\n\n            var nft : NFTCatalog.NFTCollectionData? = nil\n            var ft : FTRegistry.FTInfo? = nil\n            let nftIdentifier = nftAliasOrIdentifiers[counter]\n            let ftIdentifier = ftAliasOrIdentifiers[counter]\n\n            if nfts[nftIdentifier] != nil {\n                nft = nfts[nftIdentifier]\n            } else {\n                let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier)) \n                let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n                nft = collection.collectionData\n                nfts[nftIdentifier] = nft\n            }\n\n            if fts[ftIdentifier] != nil {\n                ft = fts[ftIdentifier]\n            } else {\n                ft = FTRegistry.getFTInfo(ftIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftIdentifier))\n                fts[ftIdentifier] = ft \n            }\n        \n            self.ftVaultType.append(fts[ftIdentifier]!.type)\n\n\n            let pointer= FindViews.createViewReadPointer(address: address, path:nft!.publicPath, id: ids[counter])\n            self.pointer.append(pointer)\n\n            var targetCapability= account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(nft!.publicPath)\n\n            /* Check for nftCapability */\n            if !targetCapability.check() {\n                let cd = pointer.getNFTCollectionData()\n                // should use account.type here instead\n                if account.type(at: cd.storagePath) != nil {\n                    let pathIdentifier = nft!.publicPath.toString()\n                    let findPath = PublicPath(identifier: pathIdentifier.slice(from: \"/public/\".length , upTo: pathIdentifier.length).concat(\"_FIND\"))!\n                    account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                        findPath,\n                        target: nft!.storagePath\n                    )\n                    targetCapability = account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(findPath)\n                } else {\n                    account.save(\u003c- cd.createEmptyCollection(), to: cd.storagePath)\n                    account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.publicPath, target: cd.storagePath)\n                    account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.providerPath, target: cd.storagePath)\n                }\n\n            }\n            self.targetCapability.append(targetCapability)\n            counter = counter + 1\n        }\n    }\n\n    pre {\n        self.bidsReference != nil : \"This account does not have a bid collection\"\n    }\n\n    execute {\n        var counter = 0\n        while counter \u003c ids.length {\n            self.bidsReference!.bid(item:self.pointer[counter], amount: amounts[counter], vaultType: self.ftVaultType[counter], nftCap: self.targetCapability[counter], validUntil: validUntil, saleItemExtraField: {}, bidExtraField: {})\n            counter = counter + 1\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "users",
                     "nftAliasOrIdentifiers",
                     "ids",
                     "ftAliasOrIdentifiers",
                     "amounts",
                     "validUntil"
                  ],
                  "parameters": {
                     "amounts": "[UFix64]",
                     "ftAliasOrIdentifiers": "[String]",
                     "ids": "[UInt64]",
                     "marketplace": "Address",
                     "nftAliasOrIdentifiers": "[String]",
                     "users": "[String]",
                     "validUntil": "UFix64?"
                  }
               }
            },
            "bidName": {
               "code": "import FUSD from 0xf8d6e0586b0a20c7\nimport FIND from 0x179b6b1cb6755e31\n\ntransaction(name: String, amount: UFix64) {\n\n    let vaultRef : \u0026FUSD.Vault?\n    let bidRef : \u0026FIND.BidCollection?\n\n    prepare(account: AuthAccount) {\n\n        self.vaultRef = account.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault)\n        self.bidRef = account.borrow\u003c\u0026FIND.BidCollection\u003e(from: FIND.BidStoragePath)\n    }\n\n    pre{\n        self.vaultRef != nil : \"Could not borrow reference to the fusdVault!\" \n        self.bidRef != nil : \"Could not borrow reference to the bid collection!\" \n    }\n\n    execute {\n        let vault \u003c- self.vaultRef!.withdraw(amount: amount) as! @FUSD.Vault\n        self.bidRef!.bid(name: name, vault: \u003c- vault)\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "name": "String"
                  }
               }
            },
            "burnNFTs": {
               "code": "import NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport NFTCatalog from 0xf8d6e0586b0a20c7\nimport FINDNFTCatalog from 0x179b6b1cb6755e31\nimport FindViews from 0x179b6b1cb6755e31\nimport FIND from 0x179b6b1cb6755e31\nimport FindFurnace from 0x179b6b1cb6755e31\n\ntransaction(types: [String] , ids: [UInt64], messages: [String]) {\n\n    let authPointers : [FindViews.AuthNFTPointer]\n\n    prepare(account : AuthAccount) {\n\n        self.authPointers = []\n\n        let contractData : {Type : NFTCatalog.NFTCatalogMetadata} = {}\n\n\n        for i , typeIdentifier in types {\n            let type = CompositeType(typeIdentifier) ?? panic(\"Cannot refer to type with identifier : \".concat(typeIdentifier))\n\n            var data : NFTCatalog.NFTCatalogMetadata? = contractData[type]\n            if data == nil {\n                data = FINDNFTCatalog.getMetadataFromType(type) ?? panic(\"NFT Type is not supported by NFT Catalog. Type : \".concat(type.identifier))\n                contractData[type] = data\n            }\n\n            let path = data!.collectionData\n\n            var providerCap=account.getCapability\u003c\u0026{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e(path.privatePath)\n            if !providerCap.check() {\n                let newCap = account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                    path.privatePath,\n                    target: path.storagePath\n                )\n                if newCap == nil {\n                    // If linking is not successful, we link it using finds custom link \n                    let pathIdentifier = path.privatePath.toString()\n                    let findPath = PrivatePath(identifier: pathIdentifier.slice(from: \"/private/\".length , upTo: pathIdentifier.length).concat(\"_FIND\"))!\n                    account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                        findPath,\n                        target: path.storagePath\n                    )\n                    providerCap = account.getCapability\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(findPath)\n                }\n            }\n            let pointer = FindViews.AuthNFTPointer(cap: providerCap, id: ids[i])\n            self.authPointers.append(pointer)\n        }\n    }\n\n    execute {\n        let ctx : {String : String} = {\n            \"tenant\" : \"find\"\n        }\n        for i,  pointer in self.authPointers {\n            let id = ids[i] \n            ctx[\"message\"] = messages[i]\n\n            // burn thru furnace\n            FindFurnace.burn(pointer: pointer, context: ctx)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "types",
                     "ids",
                     "messages"
                  ],
                  "parameters": {
                     "ids": "[UInt64]",
                     "messages": "[String]",
                     "types": "[String]"
                  }
               }
            },
            "buyAddon": {
               "code": "import FUSD from 0xf8d6e0586b0a20c7\nimport FIND from 0x179b6b1cb6755e31\n\n\ntransaction(name: String, addon:String, amount:UFix64) {\n\n    let leases : \u0026FIND.LeaseCollection?\n    let vaultRef : \u0026FUSD.Vault? \n\n    prepare(account: AuthAccount) {\n\n        self.leases= account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)\n        self.vaultRef = account.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault)\n\n    }\n\n    pre{\n        self.leases != nil : \"Could not borrow reference to the leases collection\"\n        self.vaultRef != nil : \"Could not borrow reference to the fusdVault!\"\n    }\n\n    execute {\n        let vault \u003c- self.vaultRef!.withdraw(amount: amount) as! @FUSD.Vault\n        self.leases!.buyAddon(name: name, addon: addon, vault: \u003c- vault)\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "addon",
                     "amount"
                  ],
                  "parameters": {
                     "addon": "String",
                     "amount": "UFix64",
                     "name": "String"
                  }
               }
            },
            "buyAddonDapper": {
               "code": "import DapperUtilityCoin from 0x01cf0e2f2f715450\nimport FIND from 0x179b6b1cb6755e31\n\n\ntransaction(merchAccount: Address, name: String, addon:String, amount:UFix64) {\n\n    let finLeases : \u0026FIND.LeaseCollection\n    let mainDapperUtilityCoinVault: \u0026DapperUtilityCoin.Vault\n    let balanceBeforeTransfer: UFix64\n\n    prepare(dapper: AuthAccount, account: AuthAccount) {\n        self.mainDapperUtilityCoinVault = dapper.borrow\u003c\u0026DapperUtilityCoin.Vault\u003e(from: /storage/dapperUtilityCoinVault) ?? panic(\"Cannot borrow DapperUtilityCoin vault from account storage\".concat(dapper.address.toString()))\n        self.balanceBeforeTransfer = self.mainDapperUtilityCoinVault.balance\n        self.finLeases= account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath) ?? panic(\"Could not borrow reference to find lease collection\")\n\n    }\n\n    execute {\n        let vault \u003c- self.mainDapperUtilityCoinVault.withdraw(amount: amount) as! @DapperUtilityCoin.Vault\n        self.finLeases.buyAddonDapper(merchAccount: merchAccount, name: name, addon: addon, vault: \u003c- vault)\n    }\n\n    post {\n        self.mainDapperUtilityCoinVault.balance == self.balanceBeforeTransfer: \"DapperUtilityCoin leakage\"\n    }\n}",
               "spec": {
                  "order": [
                     "merchAccount",
                     "name",
                     "addon",
                     "amount"
                  ],
                  "parameters": {
                     "addon": "String",
                     "amount": "UFix64",
                     "merchAccount": "Address",
                     "name": "String"
                  }
               }
            },
            "buyFindPack": {
               "code": "import FindPack from 0x179b6b1cb6755e31\nimport FungibleToken from 0xee82856bf20e2aa6\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport FUSD from 0xf8d6e0586b0a20c7\nimport Profile from 0x179b6b1cb6755e31\n\ntransaction(packTypeName: String, packTypeId:UInt64, numberOfPacks:UInt64, totalAmount: UFix64) {\n    let packs: \u0026FindPack.Collection{FindPack.CollectionPublic}\n\n    let userPacks: Capability\u003c\u0026FindPack.Collection{NonFungibleToken.Receiver}\u003e\n    let salePrice: UFix64\n    let packsLeft: UInt64\n\n    let userFlowTokenVault: \u0026FlowToken.Vault\n\n    let paymentVault: @FungibleToken.Vault\n    let balanceBeforeTransfer:UFix64\n\n    prepare(account: AuthAccount) {\n\n        let findPackCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(FindPack.CollectionPublicPath)\n        if !findPackCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e( \u003c- FindPack.createEmptyCollection(), to: FindPack.CollectionStoragePath)\n            account.link\u003c\u0026FindPack.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                FindPack.CollectionPublicPath,\n                target: FindPack.CollectionStoragePath\n            )\n        }\n\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:account.address.toString(), createdAt: \"find\")\n\n            //Add exising FUSD or create a new one and add it\n            let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n            if !fusdReceiver.check() {\n                let fusd \u003c- FUSD.createEmptyVault()\n                account.save(\u003c- fusd, to: /storage/fusdVault)\n                account.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n                account.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n            }\n\n            let fusdWallet=Profile.Wallet(\n                name:\"FUSD\", \n                receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver),\n                balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance),\n                accept: Type\u003c@FUSD.Vault\u003e(),\n                names: [\"fusd\", \"stablecoin\"]\n            )\n\n            profile.addWallet(fusdWallet)\n\n            let flowWallet=Profile.Wallet(\n                name:\"Flow\", \n                receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver),\n                balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance),\n                accept: Type\u003c@FlowToken.Vault\u003e(),\n                names: [\"flow\"]\n            )\n            profile.addWallet(flowWallet)\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n\n\n        }\n\n        self.userPacks=account.getCapability\u003c\u0026FindPack.Collection{NonFungibleToken.Receiver}\u003e(FindPack.CollectionPublicPath)\n        self.packs=FindPack.getPacksCollection(packTypeName: packTypeName, packTypeId:packTypeId)\n\n        self.salePrice= FindPack.getCurrentPrice(packTypeName: packTypeName, packTypeId:packTypeId, user:account.address) ?? panic (\"Cannot buy the pack now\") \n        self.packsLeft= UInt64(self.packs.getPacksLeft())\n\n\n        self.userFlowTokenVault = account.borrow\u003c\u0026FlowToken.Vault\u003e(from: /storage/flowTokenVault) ?? panic(\"Cannot borrow FlowToken vault from account storage\")\n        self.balanceBeforeTransfer = self.userFlowTokenVault.balance\n\n        if self.balanceBeforeTransfer \u003c totalAmount {\n            panic(\"Your account does not have enough funds has \".concat(self.balanceBeforeTransfer.toString()).concat(\" needs \").concat(totalAmount.toString()))\n        }\n        self.paymentVault \u003c- self.userFlowTokenVault.withdraw(amount: totalAmount)\n    }\n\n    pre {\n        self.salePrice * UFix64(numberOfPacks) == totalAmount: \"unexpected sending amount\"\n        self.packsLeft \u003e= numberOfPacks : \"Rats! there are no packs left\"\n        self.userPacks.check() : \"User need a receiver to put the pack in\"\n    }\n\n    execute {\n        var counter = numberOfPacks\n        while counter \u003e 0 {\n            let purchasingVault \u003c- self.paymentVault.withdraw(amount: self.salePrice)\n            self.packs.buy(packTypeName: packTypeName, typeId:packTypeId, vault: \u003c- purchasingVault, collectionCapability: self.userPacks)\n            counter = counter - 1\n        }\n        if self.paymentVault.balance != 0.0 {\n            panic(\"paymentVault balance is non-zero after paying\")\n        }\n        destroy self.paymentVault\n    }\n\n}",
               "spec": {
                  "order": [
                     "packTypeName",
                     "packTypeId",
                     "numberOfPacks",
                     "totalAmount"
                  ],
                  "parameters": {
                     "numberOfPacks": "UInt64",
                     "packTypeId": "UInt64",
                     "packTypeName": "String",
                     "totalAmount": "UFix64"
                  }
               }
            },
            "buyFindPackWithReservation": {
               "code": "import FindPack from 0x179b6b1cb6755e31\nimport FungibleToken from 0xee82856bf20e2aa6\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport FUSD from 0xf8d6e0586b0a20c7\nimport Profile from 0x179b6b1cb6755e31\n\ntransaction(packTypeName: String, packTypeId:UInt64, packId: UInt64, amount: UFix64, signature:String) {\n    let packs: \u0026FindPack.Collection{FindPack.CollectionPublic}\n\n    let userPacks: Capability\u003c\u0026FindPack.Collection{NonFungibleToken.Receiver}\u003e\n    let salePrice: UFix64\n    let packsLeft: UInt64\n\n    let userFlowTokenVault: \u0026FlowToken.Vault\n\n    let paymentVault: @FungibleToken.Vault\n    let balanceBeforeTransfer:UFix64\n\n    prepare(account: AuthAccount) {\n\n        let findPackCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(FindPack.CollectionPublicPath)\n        if !findPackCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e( \u003c- FindPack.createEmptyCollection(), to: FindPack.CollectionStoragePath)\n            account.link\u003c\u0026FindPack.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                FindPack.CollectionPublicPath,\n                target: FindPack.CollectionStoragePath\n            )\n        }\n\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:account.address.toString(), createdAt: \"find\")\n\n            //Add exising FUSD or create a new one and add it\n            let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n            if !fusdReceiver.check() {\n                let fusd \u003c- FUSD.createEmptyVault()\n                account.save(\u003c- fusd, to: /storage/fusdVault)\n                account.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n                account.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n            }\n\n            let fusdWallet=Profile.Wallet(\n                name:\"FUSD\", \n                receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver),\n                balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance),\n                accept: Type\u003c@FUSD.Vault\u003e(),\n                names: [\"fusd\", \"stablecoin\"]\n            )\n\n            profile.addWallet(fusdWallet)\n\n            let flowWallet=Profile.Wallet(\n                name:\"Flow\", \n                receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver),\n                balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance),\n                accept: Type\u003c@FlowToken.Vault\u003e(),\n                names: [\"flow\"]\n            )\n            profile.addWallet(flowWallet)\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n\n\n        }\n\n        self.userPacks=account.getCapability\u003c\u0026FindPack.Collection{NonFungibleToken.Receiver}\u003e(FindPack.CollectionPublicPath)\n        self.packs=FindPack.getPacksCollection(packTypeName: packTypeName, packTypeId:packTypeId)\n\n        self.salePrice= FindPack.getCurrentPrice(packTypeName: packTypeName, packTypeId:packTypeId, user:account.address) ?? panic (\"Cannot buy the pack now\") \n\n        self.packsLeft= UInt64(self.packs.getPacksLeft())\n\n\n        self.userFlowTokenVault = account.borrow\u003c\u0026FlowToken.Vault\u003e(from: /storage/flowTokenVault) ?? panic(\"Cannot borrow FlowToken vault from account storage\")\n        self.balanceBeforeTransfer = self.userFlowTokenVault.balance\n\n        if self.balanceBeforeTransfer \u003c amount {\n            panic(\"Your account does not have enough funds has \".concat(self.balanceBeforeTransfer.toString()).concat(\" needs \").concat(amount.toString()))\n        }\n        self.paymentVault \u003c- self.userFlowTokenVault.withdraw(amount: amount)\n    }\n\n    pre {\n        self.salePrice == amount: \"unexpected sending amount\"\n        self.packs.contains(packId): \"The pack does not exist. ID : \".concat(packId.toString())\n        self.userPacks.check() : \"User need a receiver to put the pack in\"\n    }\n\n    execute {\n        self.packs.buyWithSignature(packId:packId, signature: signature, vault: \u003c- self.paymentVault, collectionCapability: self.userPacks)\n    }\n\n}",
               "spec": {
                  "order": [
                     "packTypeName",
                     "packTypeId",
                     "packId",
                     "amount",
                     "signature"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "packId": "UInt64",
                     "packTypeId": "UInt64",
                     "packTypeName": "String",
                     "signature": "String"
                  }
               }
            },
            "buyForSaleMultiple": {
               "code": "import FUSD from 0xf8d6e0586b0a20c7\nimport FindMarket from 0x179b6b1cb6755e31\nimport FindMarketSale from 0x179b6b1cb6755e31\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport NFTCatalog from 0xf8d6e0586b0a20c7\nimport FINDNFTCatalog from 0x179b6b1cb6755e31\nimport FTRegistry from 0x179b6b1cb6755e31\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FIND from 0x179b6b1cb6755e31\n\ntransaction(marketplace:Address, users: [Address], ids: [AnyStruct], amounts: [UFix64]) {\n\n    let targetCapability : [Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e]\n    var walletReference : [\u0026FungibleToken.Vault]\n\n    let saleItems: [\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}]\n    let leaseNames: [String]\n    let leaseBidReference: \u0026FIND.BidCollection\n    var totalPrice : UFix64\n    let prices : [UFix64]\n    let buyer : Address\n\n    prepare(account: AuthAccount) {\n\n        if users.length != ids.length {\n            panic(\"The array length of users and ids should be the same\")\n        }\n\n        var counter = 0\n        self.walletReference= []\n        self.targetCapability = []\n\n        self.saleItems = []\n        let nfts : {String : NFTCatalog.NFTCollectionData} = {}\n        let fts : {String : FTRegistry.FTInfo} = {}\n        let saleItems : {Address : \u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}} = {}\n\n        let saleItemType = Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let marketOption = FindMarket.getMarketOptionFromType(saleItemType)\n\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath)\n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        self.buyer = account.address\n        self.leaseNames = []\n        self.leaseBidReference = account.borrow\u003c\u0026FIND.BidCollection\u003e(from: FIND.BidStoragePath) ?? panic(\"Could not borrow reference to the bid collection!\" )\n\n        var vaultType : Type? = nil\n\n        self.totalPrice = 0.0\n        self.prices = []\n\n        while counter \u003c users.length {\n\n            let address=users[counter]\n\n            if let name = ids[counter] as? String {\n                let targetAddress = FIND.lookupAddress(name) ?? panic(\"Cannot look up address for name : \".concat(name))\n                let leaseCap = getAccount(targetAddress).getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n                let leaseRef = leaseCap.borrow() ?? panic(\"Cannot borrow reference from name owner. Name : \".concat(name))\n                let nameInfo = leaseRef.getLease(name)!\n                let price = nameInfo.salePrice ?? panic(\"Name is not listed for sale. Name : \".concat(name))\n                self.prices.append(price)\n                self.leaseNames.append(name)\n\n                self.walletReference.append(\n                    account.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault) ?? panic(\"No suitable wallet linked for this account\")\n                )\n            }\n\n            if let id = ids[counter] as? UInt64 {\n                if saleItems[address] == nil {\n                    let saleItem = getAccount(address).getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath).borrow() ?? panic(\"cannot find target sale item cap. ID : \".concat(id.toString()))\n                    self.saleItems.append(saleItem)\n                    saleItems[address] = saleItem\n                } else {\n                    self.saleItems.append(saleItems[address]!)\n                }\n\n                let item=saleItems[address]!.borrowSaleItem(id)\n\n                self.prices.append(item.getBalance())\n                self.totalPrice = self.totalPrice + self.prices[counter]\n\n                var nft : NFTCatalog.NFTCollectionData? = nil\n                var ft : FTRegistry.FTInfo? = nil\n                let nftIdentifier = item.getItemType().identifier\n                let ftIdentifier = item.getFtType().identifier\n\n                if nfts[nftIdentifier] != nil {\n                    nft = nfts[nftIdentifier]\n                } else {\n                    let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier))\n                    let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])!\n                    nft = collection.collectionData\n                    nfts[nftIdentifier] = nft\n                }\n\n                if fts[ftIdentifier] != nil {\n                    ft = fts[ftIdentifier]\n                } else {\n                    ft = FTRegistry.getFTInfo(ftIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftIdentifier))\n                    fts[ftIdentifier] = ft\n                }\n\n                self.walletReference.append(\n                    account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft!.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n                )\n\n                var targetCapability= account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(nft!.publicPath)\n                /* Check for nftCapability */\n                if !targetCapability.check() {\n                    let cd = item.getNFTCollectionData()\n                    // should use account.type here instead\n                    if account.type(at: cd.storagePath) != nil {\n                        let pathIdentifier = nft!.publicPath.toString()\n                        let findPath = PublicPath(identifier: pathIdentifier.slice(from: \"/public/\".length , upTo: pathIdentifier.length).concat(\"_FIND\"))!\n                        account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                            findPath,\n                            target: nft!.storagePath\n                        )\n                        targetCapability = account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(findPath)\n                    } else {\n                        account.save(\u003c- cd.createEmptyCollection(), to: cd.storagePath)\n                        account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.publicPath, target: cd.storagePath)\n                        account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.providerPath, target: cd.storagePath)\n                    }\n\n                }\n                self.targetCapability.append(targetCapability)\n            }\n            counter = counter + 1\n        }\n\n\n    }\n\n    execute {\n        var counter = 0\n        var nameCounter = 0\n        for i, input in ids {\n\n            if let name = input as? String {\n                if self.prices[i] != amounts[i] {\n                    panic(\"Please pass in the correct price of the name. Required : \".concat(self.prices[i].toString()).concat(\" . Name : \".concat(name)))\n                }\n                if self.walletReference[i].balance \u003c amounts[i] {\n                    panic(\"Your wallet does not have enough funds to pay for this name. Required : \".concat(self.prices[i].toString()).concat(\" . Name : \".concat(name)))\n                }\n\n                let vault \u003c- self.walletReference[i].withdraw(amount: self.prices[i]) as! @FUSD.Vault\n                self.leaseBidReference.bid(name: name, vault: \u003c- vault)\n                nameCounter = nameCounter + 1\n                continue\n            }\n\n            let id = input as! UInt64\n            if self.prices[i] != amounts[i] {\n                panic(\"Please pass in the correct price of the buy items. Required : \".concat(self.prices[i].toString()).concat(\" . saleItem ID : \".concat(id.toString())))\n            }\n            if self.walletReference[i].balance \u003c amounts[i] {\n                panic(\"Your wallet does not have enough funds to pay for this item. Required : \".concat(self.prices[i].toString()).concat(\" . saleItem ID : \".concat(id.toString())))\n            }\n\n            self.saleItems[counter].buy(id:id, vault: \u003c- self.walletReference[i].withdraw(amount: amounts[i])\n            , nftCap: self.targetCapability[counter])\n            counter = counter + 1\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "users",
                     "ids",
                     "amounts"
                  ],
                  "parameters": {
                     "amounts": "[UFix64]",
                     "ids": "[AnyStruct]",
                     "marketplace": "Address",
                     "users": "[Address]"
                  }
               }
            },
            "buyLeaseForSale": {
               "code": "import FindMarket from 0x179b6b1cb6755e31\nimport FTRegistry from 0x179b6b1cb6755e31\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FIND from 0x179b6b1cb6755e31\nimport FindLeaseMarketSale from 0x179b6b1cb6755e31\nimport FindLeaseMarket from 0x179b6b1cb6755e31\n\ntransaction(leaseName: String, amount: UFix64) {\n\n    let walletReference : \u0026FungibleToken.Vault\n\n    let saleItemsCap: Capability\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e\n    let buyer: Address\n\n    prepare(account: AuthAccount) {\n\n        let resolveAddress = FIND.resolve(leaseName)\n        if resolveAddress == nil {\n            panic(\"The address input is not a valid name nor address. Input : \".concat(leaseName))\n        }\n        let address = resolveAddress!\n        let leaseMarketplace = FindMarket.getFindTenantAddress()\n        let leaseTenantCapability= FindMarket.getTenantCapability(leaseMarketplace)!\n        let leaseTenant = leaseTenantCapability.borrow()!\n\n        let leaseSaleItemType= Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()\n        let leasePublicPath=leaseTenant.getPublicPath(leaseSaleItemType)\n        let leaseStoragePath= leaseTenant.getStoragePath(leaseSaleItemType)\n        let leaseSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath)\n        if !leaseSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketSale.SaleItemCollection\u003e(\u003c- FindLeaseMarketSale.createEmptySaleItemCollection(leaseTenantCapability), to: leaseStoragePath)\n            account.link\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath, target: leaseStoragePath)\n        }\n\n        self.saleItemsCap= getAccount(address).getCapability\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath)\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e())\n\n        let item= FindLeaseMarket.assertOperationValid(tenant: leaseMarketplace, name: leaseName, marketOption: marketOption)\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n\n        self.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n        self.buyer = account.address\n    }\n\n    pre {\n        self.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount)\n        self.saleItemsCap.borrow()!.buy(name:leaseName, vault: \u003c- vault, to: self.buyer)\n    }\n}",
               "spec": {
                  "order": [
                     "leaseName",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "leaseName": "String"
                  }
               }
            },
            "buyLeaseForSaleDapper": {
               "code": "import FindMarket from 0x179b6b1cb6755e31\nimport FTRegistry from 0x179b6b1cb6755e31\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FIND from 0x179b6b1cb6755e31\nimport Profile from 0x179b6b1cb6755e31\nimport FindLeaseMarketSale from 0x179b6b1cb6755e31\nimport FindLeaseMarket from 0x179b6b1cb6755e31\n\ntransaction(sellerAccount: Address, leaseName: String, amount: UFix64) {\n\n    let to : Address\n    let walletReference : \u0026FungibleToken.Vault\n\n    let saleItemCollection: \u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\n    let balanceBeforeTransfer: UFix64\n\n    prepare(dapper: AuthAccount, account: AuthAccount) {\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath) ?? panic(\"You do not have a profile set up, initialize the user first\")\n\n        let address = FIND.resolve(leaseName) ?? panic(\"The address input is not a valid name nor address. Input : \".concat(leaseName))\n\n        if address != sellerAccount {\n            panic(\"address does not resolve to seller\")\n        }\n\n        let leaseMarketplace = FindMarket.getTenantAddress(\"find\") ?? panic(\"Cannot find find tenant\")\n        let saleItemsCap= FindLeaseMarketSale.getSaleItemCapability(marketplace: leaseMarketplace, user:address) ?? panic(\"cannot find sale item cap for find\")\n\n        let leaseTenantCapability= FindMarket.getTenantCapability(leaseMarketplace)!\n        let leaseTenant = leaseTenantCapability.borrow()!\n\n        let leaseSaleItemType= Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()\n        let leasePublicPath=FindMarket.getPublicPath(leaseSaleItemType, name: \"find\")\n        let leaseStoragePath= FindMarket.getStoragePath(leaseSaleItemType, name:\"find\")\n        let leaseSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath)\n        if !leaseSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketSale.SaleItemCollection\u003e(\u003c- FindLeaseMarketSale.createEmptySaleItemCollection(leaseTenantCapability), to: leaseStoragePath)\n            account.link\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath, target: leaseStoragePath)\n        }\n\n        self.to= account.address\n\n        self.saleItemCollection = saleItemsCap.borrow()!\n        let item = self.saleItemCollection.borrowSaleItem(leaseName)\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n        self.walletReference = dapper.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n        self.balanceBeforeTransfer = self.walletReference.balance\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount)\n        self.saleItemCollection.buy(name:leaseName, vault: \u003c- vault, to: self.to)\n    }\n\n    // Check that all dapper Coin was routed back to Dapper\n    post {\n        self.walletReference.balance == self.balanceBeforeTransfer: \"Dapper Coin leakage\"\n    }\n}",
               "spec": {
                  "order": [
                     "sellerAccount",
                     "leaseName",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "leaseName": "String",
                     "sellerAccount": "Address"
                  }
               }
            },
            "buyMultipleNFTForSale": {
               "code": "import FindMarket from 0x179b6b1cb6755e31\nimport FindMarketSale from 0x179b6b1cb6755e31\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport NFTCatalog from 0xf8d6e0586b0a20c7\nimport FINDNFTCatalog from 0x179b6b1cb6755e31\nimport FTRegistry from 0x179b6b1cb6755e31\nimport FungibleToken from 0xee82856bf20e2aa6\n\ntransaction(marketplace:Address, users: [Address], ids: [UInt64], amounts: [UFix64]) {\n\n    let targetCapability : [Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e]\n    var walletReference : [\u0026FungibleToken.Vault]\n\n    let saleItems: [\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}]\n    var totalPrice : UFix64\n    let prices : [UFix64]\n    prepare(account: AuthAccount) {\n\n        if users.length != ids.length {\n            panic(\"The array length of users and ids should be the same\")\n        }\n\n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n\n        var counter = 0\n        self.walletReference= []\n        self.targetCapability = []\n\n        self.saleItems = []\n        let nfts : {String : NFTCatalog.NFTCollectionData} = {}\n        let fts : {String : FTRegistry.FTInfo} = {}\n        let saleItems : {Address : \u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}} = {}\n\n        let saleItemType = Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let marketOption = FindMarket.getMarketOptionFromType(saleItemType)\n\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        var vaultType : Type? = nil\n\n        self.totalPrice = 0.0\n        self.prices = []\n\n        while counter \u003c users.length {\n\n            let address=users[counter]\n\n            if saleItems[address] == nil {\n                let saleItem = getAccount(address).getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath).borrow() ?? panic(\"cannot find sale item cap\")\n                self.saleItems.append(saleItem)\n                saleItems[address] = saleItem \n            } else {\n                self.saleItems.append(saleItems[address]!)\n            }\n\n\n            // let item= FindMarket.assertOperationValid(tenant: marketplace, address: address, marketOption: marketOption, id: ids[counter])\n            let item=saleItems[address]!.borrowSaleItem(ids[counter])\n\n            self.prices.append(item.getBalance())\n            self.totalPrice = self.totalPrice + self.prices[counter]\n\n            var nft : NFTCatalog.NFTCollectionData? = nil\n            var ft : FTRegistry.FTInfo? = nil\n            let nftIdentifier = item.getItemType().identifier\n            let ftIdentifier = item.getFtType().identifier\n\n            if nfts[nftIdentifier] != nil {\n                nft = nfts[nftIdentifier]\n            } else {\n                let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier)) \n                let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n                nft = collection.collectionData\n                nfts[nftIdentifier] = nft\n            }\n\n            if fts[ftIdentifier] != nil {\n                ft = fts[ftIdentifier]\n            } else {\n                ft = FTRegistry.getFTInfo(ftIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftIdentifier))\n                fts[ftIdentifier] = ft \n            }\n\n            self.walletReference.append(\n                account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft!.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n            )\n\n            var targetCapability= account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(nft!.publicPath)\n            /* Check for nftCapability */\n            if !targetCapability.check() {\n                let cd = item.getNFTCollectionData()\n                // should use account.type here instead\n                if account.type(at: cd.storagePath) != nil {\n                    let pathIdentifier = nft!.publicPath.toString()\n                    let findPath = PublicPath(identifier: pathIdentifier.slice(from: \"/public/\".length , upTo: pathIdentifier.length).concat(\"_FIND\"))!\n                    account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                        findPath,\n                        target: nft!.storagePath\n                    )\n                    targetCapability = account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(findPath)\n                } else {\n                    account.save(\u003c- cd.createEmptyCollection(), to: cd.storagePath)\n                    account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.publicPath, target: cd.storagePath)\n                    account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.providerPath, target: cd.storagePath)\n                }\n\n            }\n            self.targetCapability.append(targetCapability)\n            counter = counter + 1\n        }\n\n\n    }\n\n    execute {\n        var counter = 0\n        while counter \u003c users.length {\n            if self.prices[counter] != amounts[counter] {\n                panic(\"Please pass in the correct price of the buy items. Required : \".concat(self.prices[counter].toString()).concat(\" . saleItem ID : \".concat(ids[counter].toString())))\n            }\n            if self.walletReference[counter].balance \u003c amounts[counter] {\n                panic(\"Your wallet does not have enough funds to pay for this item. Required : \".concat(self.prices[counter].toString()).concat(\" . saleItem ID : \".concat(ids[counter].toString())))\n            }\n\n            self.saleItems[counter].buy(id:ids[counter], vault: \u003c- self.walletReference[counter].withdraw(amount: amounts[counter]) \n            , nftCap: self.targetCapability[counter])\n            counter = counter + 1\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "users",
                     "ids",
                     "amounts"
                  ],
                  "parameters": {
                     "amounts": "[UFix64]",
                     "ids": "[UInt64]",
                     "marketplace": "Address",
                     "users": "[Address]"
                  }
               }
            },
            "buyMultipleNFTForSaleDapper": {
               "code": "import FindMarket from 0x179b6b1cb6755e31\nimport FindMarketSale from 0x179b6b1cb6755e31\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport NFTCatalog from 0xf8d6e0586b0a20c7\nimport FINDNFTCatalog from 0x179b6b1cb6755e31\nimport FTRegistry from 0x179b6b1cb6755e31\nimport FungibleToken from 0xee82856bf20e2aa6\n\ntransaction(marketplace:Address, users: [Address], ids: [UInt64], amounts: [UFix64]) {\n\n    let targetCapability : [Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e]\n    var walletReference : [\u0026FungibleToken.Vault]\n    let walletBalance : {Type : UFix64}\n\n    let saleItems: [\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}]\n    var totalPrice : UFix64\n    let prices : [UFix64]\n    prepare(dapper: AuthAccount, account: AuthAccount) {\n\n        if users.length != ids.length {\n            panic(\"The array length of users and ids should be the same\")\n        }\n\n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n\n        var counter = 0\n        self.walletReference= []\n        self.targetCapability = []\n        self.walletBalance = {}\n\n        self.saleItems = []\n        let nfts : {String : NFTCatalog.NFTCollectionData} = {}\n        let fts : {String : FTRegistry.FTInfo} = {}\n        let saleItems : {Address : \u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}} = {}\n\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketSale.SaleItemCollection\u003e())\n\n        let saleItemType = Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath)\n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n        var vaultType : Type? = nil\n\n        self.totalPrice = 0.0\n        self.prices = []\n\n        while counter \u003c users.length {\n\n            let address=users[counter]\n\n            if saleItems[address] == nil {\n                let saleItem = getAccount(address).getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath).borrow() ?? panic(\"cannot find sale item cap\")\n                self.saleItems.append(saleItem)\n                saleItems[address] = saleItem\n            } else {\n                self.saleItems.append(saleItems[address]!)\n            }\n\n\n            // let item= FindMarket.assertOperationValid(tenant: marketplace, address: address, marketOption: marketOption, id: ids[counter])\n            let item=saleItems[address]!.borrowSaleItem(ids[counter])\n\n            self.prices.append(item.getBalance())\n            self.totalPrice = self.totalPrice + self.prices[counter]\n\n            var nft : NFTCatalog.NFTCollectionData? = nil\n            var ft : FTRegistry.FTInfo? = nil\n            let nftIdentifier = item.getItemType().identifier\n            let ftIdentifier = item.getFtType().identifier\n\n            if nfts[nftIdentifier] != nil {\n                nft = nfts[nftIdentifier]\n            } else {\n                let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier))\n                let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])!\n                nft = collection.collectionData\n                nfts[nftIdentifier] = nft\n            }\n\n            if fts[ftIdentifier] != nil {\n                ft = fts[ftIdentifier]\n            } else {\n                ft = FTRegistry.getFTInfo(ftIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftIdentifier))\n                fts[ftIdentifier] = ft\n            }\n\n            let dapperVault = dapper.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft!.vaultPath) ?? panic(\"Cannot borrow Dapper Coin Vault : \".concat(ft!.type.identifier))\n\n            self.walletReference.append(\n                dapperVault\n            )\n\n            if self.walletBalance[dapperVault.getType()] == nil {\n                self.walletBalance[dapperVault.getType()] = dapperVault.balance\n            }\n\n            var targetCapability= account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(nft!.publicPath)\n            /* Check for nftCapability */\n            if !targetCapability.check() {\n                let cd = item.getNFTCollectionData()\n                // should use account.type here instead\n                if account.type(at: cd.storagePath) != nil {\n                    let pathIdentifier = nft!.publicPath.toString()\n                    let findPath = PublicPath(identifier: pathIdentifier.slice(from: \"/public/\".length , upTo: pathIdentifier.length).concat(\"_FIND\"))!\n                    account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                        findPath,\n                        target: nft!.storagePath\n                    )\n                    targetCapability = account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(findPath)\n                } else {\n                    account.save(\u003c- cd.createEmptyCollection(), to: cd.storagePath)\n                    account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.publicPath, target: cd.storagePath)\n                    account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.providerPath, target: cd.storagePath)\n                }\n\n            }\n            self.targetCapability.append(targetCapability)\n            counter = counter + 1\n        }\n\n\n    }\n\n    execute {\n        var counter = 0\n        while counter \u003c users.length {\n            if self.prices[counter] != amounts[counter] {\n                panic(\"Please pass in the correct price of the buy items. Required : \".concat(self.prices[counter].toString()).concat(\" . saleItem ID : \".concat(ids[counter].toString())))\n            }\n            if self.walletReference[counter].balance \u003c amounts[counter] {\n                panic(\"Your wallet does not have enough funds to pay for this item. Required : \".concat(self.prices[counter].toString()).concat(\" . saleItem ID : \".concat(ids[counter].toString())))\n            }\n\n            self.saleItems[counter].buy(id:ids[counter], vault: \u003c- self.walletReference[counter].withdraw(amount: amounts[counter]) , nftCap: self.targetCapability[counter])\n            counter = counter + 1\n        }\n\n        // post\n        for vault in self.walletReference {\n            if vault.balance != self.walletBalance[vault.getType()] {\n                panic(\"Dapper Coin Leakage : \".concat(vault.getType().identifier))\n            }\n        }\n    }\n\n\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "users",
                     "ids",
                     "amounts"
                  ],
                  "parameters": {
                     "amounts": "[UFix64]",
                     "ids": "[UInt64]",
                     "marketplace": "Address",
                     "users": "[Address]"
                  }
               }
            },
            "buyNFTForSale": {
               "code": "import FindMarket from 0x179b6b1cb6755e31\nimport FindMarketSale from 0x179b6b1cb6755e31\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FINDNFTCatalog from 0x179b6b1cb6755e31\nimport FTRegistry from 0x179b6b1cb6755e31\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FIND from 0x179b6b1cb6755e31\ntransaction(marketplace:Address, user: String, id: UInt64, amount: UFix64) {\n\n    var targetCapability : Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e\n    let walletReference : \u0026FungibleToken.Vault\n\n    let saleItemsCap: Capability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic}\u003e\n\n    prepare(account: AuthAccount) {\n\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath)\n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        let resolveAddress = FIND.resolve(user)\n        if resolveAddress == nil {\n            panic(\"The address input is not a valid name nor address. Input : \".concat(user))\n        }\n        let address = resolveAddress!\n        self.saleItemsCap= FindMarketSale.getSaleItemCapability(marketplace: marketplace, user:address) ?? panic(\"cannot find sale item cap\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketSale.SaleItem\u003e())\n\n        let item= FindMarket.assertOperationValid(tenant: marketplace, address: address, marketOption: marketOption, id: id)\n\n        let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: item.getItemType().identifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(item.getItemType().identifier))\n        let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])!\n        let nft = collection.collectionData\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n\n        self.targetCapability= account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(nft.publicPath)\n        /* Check for nftCapability */\n        if !self.targetCapability.check() {\n            let cd = item.getNFTCollectionData()\n            // should use account.type here instead\n            if account.type(at: cd.storagePath) != nil {\n                let pathIdentifier = nft.publicPath.toString()\n                let findPath = PublicPath(identifier: pathIdentifier.slice(from: \"/public/\".length , upTo: pathIdentifier.length).concat(\"_FIND\"))!\n                account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                    findPath,\n                    target: nft.storagePath\n                )\n                self.targetCapability = account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(findPath)\n            } else {\n                account.save(\u003c- cd.createEmptyCollection(), to: cd.storagePath)\n                account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.publicPath, target: cd.storagePath)\n                account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.providerPath, target: cd.storagePath)\n            }\n\n        }\n\n        self.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n    }\n\n    pre {\n        self.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount)\n        self.saleItemsCap.borrow()!.buy(id:id, vault: \u003c- vault, nftCap: self.targetCapability)\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "user",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64",
                     "marketplace": "Address",
                     "user": "String"
                  }
               }
            },
            "buyNFTForSaleDapper": {
               "code": "import FindMarket from 0x179b6b1cb6755e31\nimport Profile from 0x179b6b1cb6755e31\nimport FindMarketSale from 0x179b6b1cb6755e31\nimport NFTCatalog from 0xf8d6e0586b0a20c7\nimport FINDNFTCatalog from 0x179b6b1cb6755e31\nimport FTRegistry from 0x179b6b1cb6755e31\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport DapperStorageRent from 0xf8d6e0586b0a20c7\nimport TopShot from 0xf8d6e0586b0a20c7\n\n//first argument is the address to the merchant that gets the funds\ntransaction(address: Address, marketplace:Address, id: UInt64, amount: UFix64) {\n\n    let targetCapability : Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e\n    let walletReference : \u0026FungibleToken.Vault\n    let receiver : Address\n\n    let saleItemsCap: Capability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic}\u003e\n    let balanceBeforeTransfer: UFix64\n    prepare(dapper: AuthAccount, account: AuthAccount) {\n        self.receiver=account.address\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath)\n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        self.saleItemsCap= FindMarketSale.getSaleItemCapability(marketplace: marketplace, user:address) ?? panic(\"cannot find sale item cap\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketSale.SaleItemCollection\u003e())\n\n        //we do some security check to verify that this tenant can do this operation. This will ensure that the onefootball tenant can only sell using DUC and not some other token. But we can change this with transactions later and not have to modify code/transactions\n        let item= FindMarket.assertOperationValid(tenant: marketplace, address: address, marketOption: marketOption, id: id)\n           let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: item.getItemType().identifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(item.getItemType().identifier))\n        let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])!\n        let nft = collection.collectionData\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n\n        self.targetCapability= account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(nft.publicPath)\n\n        if !self.targetCapability.check() {\n            let cd = item.getNFTCollectionData()\n            if let storage = account.borrow\u003c\u0026AnyResource\u003e(from: cd.storagePath) {\n                if let st = account.borrow\u003c\u0026TopShot.Collection\u003e(from: cd.storagePath) {\n                    // here means the topShot is not linked in the way it should be. We can relink that for our use\n                    account.unlink(cd.publicPath)\n                    account.link\u003c\u0026TopShot.Collection{TopShot.MomentCollectionPublic,NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}\u003e(cd.publicPath, target: cd.storagePath)\n                } else {\n                    panic(\"This collection public link is not set up properly.\")\n                }\n            } else {\n                account.save(\u003c- cd.createEmptyCollection(), to: cd.storagePath)\n                account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.publicPath, target: cd.storagePath)\n                account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.providerPath, target: cd.storagePath)\n            }\n        }\n\n        self.walletReference = dapper.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n        self.balanceBeforeTransfer = self.walletReference.balance\n    }\n\n    pre {\n        self.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount)\n        self.saleItemsCap.borrow()!.buy(id:id, vault: \u003c- vault, nftCap: self.targetCapability)\n        DapperStorageRent.tryRefill(self.receiver)\n    }\n\n    // Check that all dapper Coin was routed back to Dapper\n    post {\n        self.walletReference.balance == self.balanceBeforeTransfer: \"Dapper Coin leakage\"\n    }\n}",
               "spec": {
                  "order": [
                     "address",
                     "marketplace",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "address": "Address",
                     "amount": "UFix64",
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "cancelAllLeaseMarketAuctionSoft": {
               "code": "import FindMarket from 0x179b6b1cb6755e31\nimport FindLeaseMarketAuctionSoft from 0x179b6b1cb6755e31\n\ntransaction() {\n\n    let saleItems : \u0026FindLeaseMarketAuctionSoft.SaleItemCollection?\n\n    prepare(account: AuthAccount) {\n        let leaseMarketplace = FindMarket.getFindTenantAddress()\n        let tenant = FindMarket.getTenant(leaseMarketplace)\n        self.saleItems= account.borrow\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e()))\n\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to the saleItem.\"\n    }\n\n    execute {\n        let leaseNames = self.saleItems!.getNameSales()\n        for lease in leaseNames {\n            self.saleItems!.cancel(lease)\n        }\n    }\n}",
               "spec": {
                  "order": [],
                  "parameters": {}
               }
            },
            "cancelAllLeaseMarketDirectOfferSoft": {
               "code": "import FindMarket from 0x179b6b1cb6755e31\nimport FindLeaseMarketDirectOfferSoft from 0x179b6b1cb6755e31\n\ntransaction() {\n\n    let saleItems : \u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection?\n\n    prepare(account: AuthAccount) {\n\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenant=FindMarket.getTenant(marketplace)\n        self.saleItems= account.borrow\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e()))\n\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to saleItem.\"\n    }\n\n    execute{\n        let nameLeases = self.saleItems!.getNameSales()\n        for nameLease in nameLeases {\n            self.saleItems!.cancel(nameLease)\n        }\n    }\n\n}",
               "spec": {
                  "order": [],
                  "parameters": {}
               }
            },
            "cancelAllMarketAuctionEscrowed": {
               "code": "import FindMarket from 0x179b6b1cb6755e31\nimport FindMarketAuctionEscrow from 0x179b6b1cb6755e31\n\ntransaction(marketplace:Address) {\n\n    let saleItems : \u0026FindMarketAuctionEscrow.SaleItemCollection?\n\n    prepare(account: AuthAccount) {\n        let tenant = FindMarket.getTenant(marketplace)\n        self.saleItems= account.borrow\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()))\n\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to the saleItem capability.\"\n    }\n\n    execute {\n        let ids = self.saleItems!.getIds()\n        for id in ids {\n            self.saleItems!.cancel(id)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace"
                  ],
                  "parameters": {
                     "marketplace": "Address"
                  }
               }
            },
            "cancelAllMarketAuctionSoft": {
               "code": "import FindMarket from 0x179b6b1cb6755e31\nimport FindMarketAuctionSoft from 0x179b6b1cb6755e31\n\ntransaction(marketplace:Address) {\n\n    let saleItems : \u0026FindMarketAuctionSoft.SaleItemCollection?\n\n    prepare(account: AuthAccount) {\n        let tenant = FindMarket.getTenant(marketplace)\n        self.saleItems= account.borrow\u003c\u0026FindMarketAuctionSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()))\n\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to the saleItem.\"\n    }\n\n    execute {\n        let ids = self.saleItems!.getIds()\n        for id in ids {\n            self.saleItems!.cancel(id)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace"
                  ],
                  "parameters": {
                     "marketplace": "Address"
                  }
               }
            },
            "cancelAllMarketDirectOfferEscrowed": {
               "code": "import FindMarket from 0x179b6b1cb6755e31\nimport FindMarketDirectOfferEscrow from 0x179b6b1cb6755e31\n\ntransaction(marketplace:Address) {\n\n    let saleItems : \u0026FindMarketDirectOfferEscrow.SaleItemCollection?\n\n    prepare(account: AuthAccount) {\n\n        let tenant=FindMarket.getTenant(marketplace)\n        self.saleItems= account.borrow\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()))\n\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to saleItem.\"\n    }\n\n    execute{\n        let ids = self.saleItems!.getIds()\n        for id in ids {\n            self.saleItems!.cancel(id)\n        }\n    }\n\n}",
               "spec": {
                  "order": [
                     "marketplace"
                  ],
                  "parameters": {
                     "marketplace": "Address"
                  }
               }
            },
            "cancelAllMarketDirectOfferSoft": {
               "code": "import FindMarket from 0x179b6b1cb6755e31\nimport FindMarketDirectOfferSoft from 0x179b6b1cb6755e31\n\ntransaction(marketplace:Address) {\n\n    let saleItems : \u0026FindMarketDirectOfferSoft.SaleItemCollection?\n\n    prepare(account: AuthAccount) {\n\n        let tenant=FindMarket.getTenant(marketplace)\n        self.saleItems= account.borrow\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()))\n\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to saleItem.\"\n    }\n\n    execute{\n        let ids = self.saleItems!.getIds()\n        for id in ids {\n            self.saleItems!.cancel(id)\n        }\n    }\n\n}",
               "spec": {
                  "order": [
                     "marketplace"
                  ],
                  "parameters": {
                     "marketplace": "Address"
                  }
               }
            },
            "cancelAllMarketListings": {
               "code": "import FindMarket from 0x179b6b1cb6755e31\nimport FindMarketDirectOfferEscrow from 0x179b6b1cb6755e31\nimport FindMarketAuctionEscrow from 0x179b6b1cb6755e31\nimport FindMarketAuctionSoft from 0x179b6b1cb6755e31\nimport FindMarketDirectOfferSoft from 0x179b6b1cb6755e31\nimport FindMarketSale from 0x179b6b1cb6755e31\n\ntransaction(marketplace:Address) {\n    prepare(account: AuthAccount) {\n\n        let tenant=FindMarket.getTenant(marketplace)\n\n        if let saleItems= account.borrow\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e())) {\n            var ids = saleItems.getIds()\n            for id in ids {\n                saleItems.cancel(id)\n            }\n        }\n\n        if let saleItem2= account.borrow\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e())) {\n            var ids = saleItem2.getIds()\n            for id in ids {\n                saleItem2.cancel(id)\n            }\n        }\n\n        if let saleItems3= account.borrow\u003c\u0026FindMarketAuctionSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e())) {\n            var ids = saleItems3.getIds()\n            for id in ids {\n                saleItems3.cancel(id)\n            }\n        }\n\n        if let saleItems4= account.borrow\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e())) {\n            var ids = saleItems4.getIds()\n            for id in ids {\n                saleItems4.cancel(id)\n            }\n        }\n\n        if let saleItems5= account.borrow\u003c\u0026FindMarketSale.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketSale.SaleItemCollection\u003e())) {\n            var ids = saleItems5.getIds()\n            for id in ids {\n                saleItems5.delist(id)\n            }\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace"
                  ],
                  "parameters": {
                     "marketplace": "Address"
                  }
               }
            },
            "cancelLeaseMarketAuctionSoft": {
               "code": "import FindMarket from 0x179b6b1cb6755e31\nimport FindLeaseMarketAuctionSoft from 0x179b6b1cb6755e31\n\ntransaction(leaseNames: [String]) {\n\n    let saleItems : \u0026FindLeaseMarketAuctionSoft.SaleItemCollection?\n\n    prepare(account: AuthAccount) {\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenant=FindMarket.getTenant(marketplace)\n        self.saleItems= account.borrow\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e()))\n    }\n\n    pre{\n        self.saleItems != nil\n    }\n\n    execute{\n        for leaseName in leaseNames {\n            self.saleItems!.cancel(leaseName)\n        }\n    }\n\n}",
               "spec": {
                  "order": [
                     "leaseNames"
                  ],
                  "parameters": {
                     "leaseNames": "[String]"
                  }
               }
            },
            "cancelLeaseMarketDirectOfferSoft": {
               "code": "import FindMarket from 0x179b6b1cb6755e31\nimport FindLeaseMarketDirectOfferSoft from 0x179b6b1cb6755e31\n\ntransaction(leaseNames: [String]) {\n\n    let saleItems : \u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection?\n\n    prepare(account: AuthAccount) {\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenant=FindMarket.getTenant(marketplace)\n        self.saleItems= account.borrow\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e()))\n\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute {\n        for leaseName in leaseNames {\n            self.saleItems!.cancel(leaseName)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "leaseNames"
                  ],
                  "parameters": {
                     "leaseNames": "[String]"
                  }
               }
            },
            "cancelMarketAuctionEscrowed": {
               "code": "import FindMarket from 0x179b6b1cb6755e31\nimport FindMarketAuctionEscrow from 0x179b6b1cb6755e31\n\ntransaction(marketplace:Address, ids: [UInt64]) {\n\n    let saleItems : \u0026FindMarketAuctionEscrow.SaleItemCollection?\n\n    prepare(account: AuthAccount) {\n\n        let tenant=FindMarket.getTenant(marketplace)\n        self.saleItems= account.borrow\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()))\n\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        for id in ids {\n            self.saleItems!.cancel(id)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "ids"
                  ],
                  "parameters": {
                     "ids": "[UInt64]",
                     "marketplace": "Address"
                  }
               }
            },
            "cancelMarketAuctionSoft": {
               "code": "import FindMarket from 0x179b6b1cb6755e31\nimport FindMarketAuctionSoft from 0x179b6b1cb6755e31\n\ntransaction(marketplace:Address, ids: [UInt64]) {\n\n    let saleItems : \u0026FindMarketAuctionSoft.SaleItemCollection?\n\n    prepare(account: AuthAccount) {\n        let tenant=FindMarket.getTenant(marketplace)\n        self.saleItems= account.borrow\u003c\u0026FindMarketAuctionSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()))\n    }\n\n    pre{\n        self.saleItems != nil \n    }\n\n    execute{\n        for id in ids {\n            self.saleItems!.cancel(id)\n        }\n    }\n\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "ids"
                  ],
                  "parameters": {
                     "ids": "[UInt64]",
                     "marketplace": "Address"
                  }
               }
            },
            "cancelMarketDirectOfferEscrowed": {
               "code": "import FindMarket from 0x179b6b1cb6755e31\nimport FindMarketDirectOfferEscrow from 0x179b6b1cb6755e31\n\ntransaction(marketplace:Address, ids: [UInt64]) {\n\n    let saleItems : \u0026FindMarketDirectOfferEscrow.SaleItemCollection?\n\n    prepare(account: AuthAccount) {\n\n        let tenant=FindMarket.getTenant(marketplace)\n        self.saleItems= account.borrow\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()))\n\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        for id in ids {\n            self.saleItems!.cancel(id)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "ids"
                  ],
                  "parameters": {
                     "ids": "[UInt64]",
                     "marketplace": "Address"
                  }
               }
            },
            "cancelMarketDirectOfferSoft": {
               "code": "import FindMarket from 0x179b6b1cb6755e31\nimport FindMarketDirectOfferSoft from 0x179b6b1cb6755e31\n\ntransaction(marketplace:Address, ids: [UInt64]) {\n\n    let saleItems : \u0026FindMarketDirectOfferSoft.SaleItemCollection?\n\n    prepare(account: AuthAccount) {\n\n        let tenant=FindMarket.getTenant(marketplace)\n        self.saleItems= account.borrow\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()))\n\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute {\n        for id in ids {\n            self.saleItems!.cancel(id)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "ids"
                  ],
                  "parameters": {
                     "ids": "[UInt64]",
                     "marketplace": "Address"
                  }
               }
            },
            "cancelMarketListings": {
               "code": "import FindMarket from 0x179b6b1cb6755e31\nimport FindMarketDirectOfferEscrow from 0x179b6b1cb6755e31\nimport FindMarketAuctionEscrow from 0x179b6b1cb6755e31\nimport FindMarketAuctionSoft from 0x179b6b1cb6755e31\nimport FindMarketDirectOfferSoft from 0x179b6b1cb6755e31\nimport FindMarketSale from 0x179b6b1cb6755e31\n\ntransaction(marketplace:Address, ids: {String : [UInt64]}) {\n    prepare(account: AuthAccount) {\n\n        let tenant=FindMarket.getTenant(marketplace)\n\n        var saleType = Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        if let ids = ids[FindMarket.getMarketOptionFromType(saleType)] {\n            let saleItems= account.borrow\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection\u003e(from: tenant.getStoragePath(saleType))!\n            for id in ids {\n                saleItems.cancel(id)\n            }\n        }\n\n        saleType = Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        if let ids = ids[FindMarket.getMarketOptionFromType(saleType)] {\n            let saleItems= account.borrow\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection\u003e(from: tenant.getStoragePath(saleType))!\n            for id in ids {\n                saleItems.cancel(id)\n            }\n        }\n\n        saleType = Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        if let ids = ids[FindMarket.getMarketOptionFromType(saleType)] {\n            let saleItems= account.borrow\u003c\u0026FindMarketAuctionSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(saleType))!\n            for id in ids {\n                saleItems.cancel(id)\n            }\n        }\n\n        saleType = Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n        if let ids = ids[FindMarket.getMarketOptionFromType(saleType)] {\n            let saleItems= account.borrow\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(saleType))!\n            for id in ids {\n                saleItems.cancel(id)\n            }\n        }\n\n        saleType = Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        if let ids = ids[FindMarket.getMarketOptionFromType(saleType)] {\n            let saleItems= account.borrow\u003c\u0026FindMarketSale.SaleItemCollection\u003e(from: tenant.getStoragePath(saleType))!\n            for id in ids {\n                saleItems.delist(id)\n            }\n        }\n\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "ids"
                  ],
                  "parameters": {
                     "ids": "{String: [UInt64]}",
                     "marketplace": "Address"
                  }
               }
            },
            "cancelNameAuction": {
               "code": "import FIND from 0x179b6b1cb6755e31\n\ntransaction(names: [String]) {\n\n    let finLeases : \u0026FIND.LeaseCollection?\n\n    prepare(account: AuthAccount) {\n        self.finLeases= account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)\n    }\n\n    pre{\n        self.finLeases != nil : \"Cannot borrow reference to find leases collection\"\n    }\n\n    execute {\n        for name in names {\n            self.finLeases!.cancel(name)\n            self.finLeases!.delistAuction(name)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "names"
                  ],
                  "parameters": {
                     "names": "[String]"
                  }
               }
            },
            "cancelNameBid": {
               "code": "import FIND from 0x179b6b1cb6755e31\n\ntransaction(names: [String]) {\n\n    let bids : \u0026FIND.BidCollection?\n\n    prepare(account: AuthAccount) {\n        self.bids = account.borrow\u003c\u0026FIND.BidCollection\u003e(from: FIND.BidStoragePath)\n    }\n\n    pre{\n        self.bids != nil : \"Cannot borrow reference to find bid collection\"\n    }\n\n    execute {\n        for name in names {\n            self.bids!.cancelBid(name)\n        }\n    }\n\n}",
               "spec": {
                  "order": [
                     "names"
                  ],
                  "parameters": {
                     "names": "[String]"
                  }
               }
            },
            "createCharity": {
               "code": "import NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport CharityNFT from 0x179b6b1cb6755e31\n\n//This transaction will prepare the art collection\ntransaction() {\n    prepare(account: AuthAccount) {\n\n        let stdCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath)\n        if !stdCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- CharityNFT.createEmptyCollection(), to: CharityNFT.CollectionStoragePath)\n            account.link\u003c\u0026{NonFungibleToken.CollectionPublic, MetadataViews.ResolverCollection}\u003e(CharityNFT.CollectionPublicPath, target: CharityNFT.CollectionStoragePath)\n        }\n\n        let charityCap = account.getCapability\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection)\n        if !charityCap.check() {\n            account.link\u003c\u0026{CharityNFT.CollectionPublic, MetadataViews.ResolverCollection}\u003e(/public/findCharityNFTCollection, target: CharityNFT.CollectionStoragePath)\n        }\n    }\n}",
               "spec": {
                  "order": [],
                  "parameters": {}
               }
            },
            "createProfile": {
               "code": "import FungibleToken from 0xee82856bf20e2aa6\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport FUSD from 0xf8d6e0586b0a20c7\nimport FiatToken from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FIND from 0x179b6b1cb6755e31\nimport FindPack from 0x179b6b1cb6755e31\nimport Profile from 0x179b6b1cb6755e31\nimport FindMarket from 0x179b6b1cb6755e31\nimport FindMarketDirectOfferEscrow from 0x179b6b1cb6755e31\nimport Dandy from 0x179b6b1cb6755e31\nimport FindThoughts from 0x179b6b1cb6755e31\n\ntransaction(name: String) {\n    prepare(account: AuthAccount) {\n        //if we do not have a profile it might be stored under a different address so we will just remove it\n        let profileCapFirst = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if profileCapFirst.check() {\n            return \n        }\n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n        //SYNC with register\n        //Add exising FUSD or create a new one and add it\n        let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n        if !fusdReceiver.check() {\n            let fusd \u003c- FUSD.createEmptyVault()\n            account.save(\u003c- fusd, to: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n        }\n\n        let usdcCap = account.getCapability\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e(FiatToken.VaultReceiverPubPath)\n        if !usdcCap.check() {\n                account.save( \u003c-FiatToken.createEmptyVault(), to: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e( FiatToken.VaultReceiverPubPath, target: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FiatToken.ResourceId}\u003e( FiatToken.VaultUUIDPubPath, target: FiatToken.VaultStoragePath)\n                account.link\u003c\u0026FiatToken.Vault{FungibleToken.Balance}\u003e( FiatToken.VaultBalancePubPath, target:FiatToken.VaultStoragePath)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let dandyCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        let thoughtsCap= account.getCapability\u003c\u0026{FindThoughts.CollectionPublic}\u003e(FindThoughts.CollectionPublicPath)\n        if !thoughtsCap.check() {\n            account.save(\u003c- FindThoughts.createEmptyCollection(), to: FindThoughts.CollectionStoragePath)\n            account.link\u003c\u0026FindThoughts.Collection{FindThoughts.CollectionPublic , MetadataViews.ResolverCollection}\u003e(\n                FindThoughts.CollectionPublicPath,\n                target: FindThoughts.CollectionStoragePath\n            )\n        }\n\n        let findPackCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(FindPack.CollectionPublicPath)\n        if !findPackCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e( \u003c- FindPack.createEmptyCollection(), to: FindPack.CollectionStoragePath)\n            account.link\u003c\u0026FindPack.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                FindPack.CollectionPublicPath,\n                target: FindPack.CollectionStoragePath\n            )\n        }\n\n        var created=false\n        var updated=false\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        if !profile.hasWallet(\"Flow\") {\n            let flowWallet=Profile.Wallet( name:\"Flow\", receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), tags: [\"flow\"])\n    \n            profile.addWallet(flowWallet)\n            updated=true\n        }\n        if !profile.hasWallet(\"FUSD\") {\n            profile.addWallet(Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), tags: [\"fusd\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if !profile.hasWallet(\"USDC\") {\n            profile.addWallet(Profile.Wallet( name:\"USDC\", receiver:usdcCap, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(FiatToken.VaultBalancePubPath), accept: Type\u003c@FiatToken.Vault\u003e(), tags: [\"usdc\", \"stablecoin\"]))\n            updated=true\n        }\n\n         //If find name not set and we have a profile set it.\n        if profile.getFindName() == \"\" {\n            if let findName = FIND.reverseLookup(account.address) {\n                profile.setFindName(findName)\n                // If name is set, it will emit Updated Event, there is no need to emit another update event below. \n                updated=false\n            }\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else if updated {\n            profile.emitUpdatedEvent()\n        }\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let tenantCapability= FindMarket.getTenantCapability(FindMarket.getFindTenantAddress())!\n\n        let tenant = tenantCapability.borrow()!\n\n        let doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        let doeSalePublicPath=FindMarket.getPublicPath(doeSaleType, name: tenant.name)\n        let doeSaleStoragePath= FindMarket.getStoragePath(doeSaleType, name:tenant.name)\n        let doeSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n        if !doeSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n        }\n        //SYNC with register\n\n    }\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "createProfileDapper": {
               "code": "import FungibleToken from 0xee82856bf20e2aa6\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FIND from 0x179b6b1cb6755e31\nimport Dandy from 0x179b6b1cb6755e31\nimport Profile from 0x179b6b1cb6755e31\nimport FindMarket from 0x179b6b1cb6755e31\nimport FindMarketDirectOfferSoft from 0x179b6b1cb6755e31\nimport DapperUtilityCoin from 0x01cf0e2f2f715450\nimport FlowUtilityToken from 0x01cf0e2f2f715450\nimport FindLeaseMarketDirectOfferSoft from 0x179b6b1cb6755e31\nimport FindLeaseMarket from 0x179b6b1cb6755e31\n\ntransaction(name: String) {\n    prepare(account: AuthAccount) {\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let dandyCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        var created=false\n        var updated=false\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        if !profile.hasWallet(\"DUC\") {\n            let ducReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver)\n            profile.addWallet(Profile.Wallet( name:\"DUC\", receiver:ducReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/dapperUtilityCoinBalance), accept: Type\u003c@DapperUtilityCoin.Vault\u003e(), tags: [\"duc\", \"dapperUtilityCoin\",\"dapper\"]))\n            updated=true\n        }\n\n        if !profile.hasWallet(\"FUT\") {\n            let futReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowUtilityTokenReceiver)\n            profile.addWallet(Profile.Wallet( name:\"FUT\", receiver:futReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowUtilityTokenBalance), accept: Type\u003c@FlowUtilityToken.Vault\u003e(), tags: [\"fut\", \"flowUtilityToken\",\"dapper\"]))\n            updated=true\n        }\n\n        profile.emitCreatedEvent()\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let tenantCapability= FindMarket.getTenantCapability(FindMarket.getFindTenantAddress())!\n\n        let tenant = tenantCapability.borrow()!\n\n        let dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n        let dosSalePublicPath=FindMarket.getPublicPath(dosSaleType, name: tenant.name)\n        let dosSaleStoragePath= FindMarket.getStoragePath(dosSaleType, name:tenant.name)\n        let dosSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath)\n        if !dosSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n        }\n\n        let leaseTenantCapability= FindMarket.getTenantCapability(FindMarket.getFindTenantAddress())!\n        let leaseTenant = leaseTenantCapability.borrow()!\n\n        let leaseDOSSaleItemType= Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e()\n        let leaseDOSPublicPath=leaseTenant.getPublicPath(leaseDOSSaleItemType)\n        let leaseDOSStoragePath= leaseTenant.getStoragePath(leaseDOSSaleItemType)\n        let leaseDOSSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath)\n        if !leaseDOSSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOSStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath, target: leaseDOSStoragePath)\n        }\n\n    }\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "deleteFindThoughts": {
               "code": "import FindThoughts from 0x179b6b1cb6755e31\n\ntransaction(ids: [UInt64]) {\n\n    let collection : \u0026FindThoughts.Collection\n\n    prepare(account: AuthAccount) {\n\n        self.collection=account.borrow\u003c\u0026FindThoughts.Collection\u003e(from: FindThoughts.CollectionStoragePath) ?? panic(\"Cannot borrow thoughts reference from path\")\n    }\n\n    execute {\n        for id in ids {\n            self.collection.delete(id)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "ids"
                  ],
                  "parameters": {
                     "ids": "[UInt64]"
                  }
               }
            },
            "delistAllLeaseSale": {
               "code": "import FindLeaseMarketSale from 0x179b6b1cb6755e31\nimport FindMarket from 0x179b6b1cb6755e31\nimport FindLeaseMarket from 0x179b6b1cb6755e31\n\ntransaction() {\n    prepare(account: AuthAccount) {\n        // Get all the saleItems Id\n\n        let tenant = FindMarket.getTenant(FindMarket.getFindTenantAddress())\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindLeaseMarketSale.SaleItem\u003e())\n        let cap = FindLeaseMarket.getSaleItemCollectionCapability(tenantRef: tenant, marketOption: marketOption, address: account.address)\n        let ref = cap.borrow() ?? panic(\"Cannot borrow reference to the capability.\")\n\n        let listingType=Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()\n        let saleItems= account.borrow\u003c\u0026FindLeaseMarketSale.SaleItemCollection\u003e(from: tenant.getStoragePath(listingType))!\n        let leases = ref.getNameSales()\n        for lease in leases {\n            saleItems.delist(lease)\n        }\n    }\n}",
               "spec": {
                  "order": [],
                  "parameters": {}
               }
            },
            "delistAllNFTSale": {
               "code": "import FindMarketSale from 0x179b6b1cb6755e31\nimport FindMarket from 0x179b6b1cb6755e31\n\ntransaction(marketplace:Address) {\n\n    let saleItems : \u0026FindMarketSale.SaleItemCollection?\n\n    prepare(account: AuthAccount) {\n        let tenant = FindMarket.getTenant(marketplace)\n        self.saleItems= account.borrow\u003c\u0026FindMarketSale.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketSale.SaleItemCollection\u003e())) \n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        let ids = self.saleItems!.getIds()\n        for id in ids {\n            self.saleItems!.delist(id)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace"
                  ],
                  "parameters": {
                     "marketplace": "Address"
                  }
               }
            },
            "delistAllNameSale": {
               "code": "import FIND from 0x179b6b1cb6755e31\n\ntransaction() {\n\n    let finLeases : \u0026FIND.LeaseCollection?\n\n    prepare(acct: AuthAccount) {\n        self.finLeases= acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)\n\n    }\n\n    pre{\n        self.finLeases != nil : \"Cannot borrow reference to find lease collection\"\n    }\n\n    execute{\n        let leases = self.finLeases!.getLeaseInformation()\n        for lease in leases {\n            if lease.salePrice != nil {\n                self.finLeases!.delistSale(lease.name)\n            }\n        }\n    }\n}",
               "spec": {
                  "order": [],
                  "parameters": {}
               }
            },
            "delistLeaseSale": {
               "code": "import FindMarket from 0x179b6b1cb6755e31\nimport FindLeaseMarketSale from 0x179b6b1cb6755e31\n\ntransaction(leases: [String]) {\n    let saleItems : \u0026FindLeaseMarketSale.SaleItemCollection?\n\n    prepare(account: AuthAccount) {\n\n        let tenant=FindMarket.getTenant(FindMarket.getFindTenantAddress())\n        self.saleItems= account.borrow\u003c\u0026FindLeaseMarketSale.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()))\n\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        for lease in leases {\n            self.saleItems!.delist(lease)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "leases"
                  ],
                  "parameters": {
                     "leases": "[String]"
                  }
               }
            },
            "delistNFTSale": {
               "code": "import FindMarket from 0x179b6b1cb6755e31\nimport FindMarketSale from 0x179b6b1cb6755e31\n\n//Remove one or more listings from a marketplace\ntransaction(marketplace:Address, ids: [UInt64]) {\n\n    let saleItems : \u0026FindMarketSale.SaleItemCollection?\n\n    prepare(account: AuthAccount) {\n        let tenant=FindMarket.getTenant(marketplace)\n        self.saleItems= account.borrow\u003c\u0026FindMarketSale.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketSale.SaleItemCollection\u003e()))\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        for id in ids {\n            self.saleItems!.delist(id)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "ids"
                  ],
                  "parameters": {
                     "ids": "[UInt64]",
                     "marketplace": "Address"
                  }
               }
            },
            "delistNameSale": {
               "code": "import FIND from 0x179b6b1cb6755e31\n\ntransaction(names: [String]) {\n\n    let finLeases : \u0026FIND.LeaseCollection?\n\n    prepare(acct: AuthAccount) {\n        self.finLeases= acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)\n    }\n\n    pre{\n        self.finLeases != nil : \"Cannot borrow reference to find lease collection\"\n    }\n\n    execute{\n        for name in names {\n            self.finLeases!.delistSale(name)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "names"
                  ],
                  "parameters": {
                     "names": "[String]"
                  }
               }
            },
            "editFindThought": {
               "code": "import FindThoughts from 0x179b6b1cb6755e31\n\ntransaction(id: UInt64, header: String , body: String, tags: [String]) {\n\n    let collection : \u0026FindThoughts.Collection\n\n    prepare(account: AuthAccount) {\n\n        self.collection=account.borrow\u003c\u0026FindThoughts.Collection\u003e(from: FindThoughts.CollectionStoragePath) ?? panic(\"Cannot borrow thoughts reference from path\")\n    }\n\n    execute {\n        let thought = self.collection.borrow(id)\n        thought.edit(header: header , body: body, tags: tags)\n    }\n}",
               "spec": {
                  "order": [
                     "id",
                     "header",
                     "body",
                     "tags"
                  ],
                  "parameters": {
                     "body": "String",
                     "header": "String",
                     "id": "UInt64",
                     "tags": "[String]"
                  }
               }
            },
            "editProfile": {
               "code": "import FungibleToken from 0xee82856bf20e2aa6\nimport FUSD from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport FIND from 0x179b6b1cb6755e31\nimport Profile from 0x179b6b1cb6755e31\n\ntransaction(name:String, description: String, avatar: String, tags:[String], allowStoringFollowers: Bool, linkTitles : {String: String}, linkTypes: {String:String}, linkUrls : {String:String}, removeLinks : [String]) {\n    \n    let profile : \u0026Profile.User\n\n    prepare(account: AuthAccount) {\n\n        self.profile =account.borrow\u003c\u0026Profile.User\u003e(from:Profile.storagePath) ?? panic(\"Cannot borrow reference to profile\")\n\n        //Add exising FUSD or create a new one and add it\n        let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n        if !fusdReceiver.check() {\n            let fusd \u003c- FUSD.createEmptyVault()\n            account.save(\u003c- fusd, to: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n        }\n\n\n        var hasFusdWallet=false\n        var hasFlowWallet=false\n        let wallets=self.profile.getWallets()\n        for wallet in wallets {\n            if wallet.name==\"FUSD\" {\n                hasFusdWallet=true\n            }\n\n            if wallet.name ==\"Flow\" {\n                hasFlowWallet=true\n            }\n        }\n\n        if !hasFlowWallet {\n            let flowWallet=Profile.Wallet(\n                name:\"Flow\", \n                receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver),\n                balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance),\n                accept: Type\u003c@FlowToken.Vault\u003e(),\n                tags: [\"flow\"]\n            )\n            self.profile.addWallet(flowWallet)\n        }\n\n        if !hasFusdWallet {\n            let fusdWallet=Profile.Wallet(\n                name:\"FUSD\", \n                receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver),\n                balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance),\n                accept: Type\u003c@FUSD.Vault\u003e(),\n                tags: [\"fusd\", \"stablecoin\"]\n            )\n            self.profile.addWallet(fusdWallet)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n    }\n\n    execute{\n        self.profile!.setName(name)\n        self.profile!.setDescription(description)\n        self.profile!.setAvatar(avatar)\n        self.profile!.setTags(tags)\n\n        for link in removeLinks {\n            self.profile!.removeLink(link)\n        }\n\n        for titleName in linkTitles.keys {\n            let title=linkTitles[titleName]!\n            let url = linkUrls[titleName]!\n            let type = linkTypes[titleName]!\n\n            self.profile!.addLinkWithName(name:titleName, link: Profile.Link(title: title, type: type, url: url))\n        }\n        self.profile!.emitUpdatedEvent()\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "description",
                     "avatar",
                     "tags",
                     "allowStoringFollowers",
                     "linkTitles",
                     "linkTypes",
                     "linkUrls",
                     "removeLinks"
                  ],
                  "parameters": {
                     "allowStoringFollowers": "Bool",
                     "avatar": "String",
                     "description": "String",
                     "linkTitles": "{String: String}",
                     "linkTypes": "{String: String}",
                     "linkUrls": "{String: String}",
                     "name": "String",
                     "removeLinks": "[String]",
                     "tags": "[String]"
                  }
               }
            },
            "editProfileDapper": {
               "code": "import FIND from 0x179b6b1cb6755e31\nimport Profile from 0x179b6b1cb6755e31\n\ntransaction(name:String, description: String, avatar: String, tags:[String], allowStoringFollowers: Bool, linkTitles : {String: String}, linkTypes: {String:String}, linkUrls : {String:String}, removeLinks : [String]) {\n    \n    let profile : \u0026Profile.User\n\n    prepare(account: AuthAccount) {\n\n        self.profile =account.borrow\u003c\u0026Profile.User\u003e(from:Profile.storagePath) ?? panic(\"You do not have a profile set up, initialize the user first\")\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n\n        }\n\n    }\n\n    execute{\n        self.profile.setName(name)\n        self.profile.setDescription(description)\n        self.profile.setAvatar(avatar)\n        self.profile.setTags(tags)\n\n        for link in removeLinks {\n            self.profile.removeLink(link)\n        }\n\n        for titleName in linkTitles.keys {\n            let title=linkTitles[titleName]!\n            let url = linkUrls[titleName]!\n            let type = linkTypes[titleName]!\n\n            self.profile.addLinkWithName(name:titleName, link: Profile.Link(title: title, type: type, url: url))\n        }\n        self.profile.emitUpdatedEvent()\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "description",
                     "avatar",
                     "tags",
                     "allowStoringFollowers",
                     "linkTitles",
                     "linkTypes",
                     "linkUrls",
                     "removeLinks"
                  ],
                  "parameters": {
                     "allowStoringFollowers": "Bool",
                     "avatar": "String",
                     "description": "String",
                     "linkTitles": "{String: String}",
                     "linkTypes": "{String: String}",
                     "linkUrls": "{String: String}",
                     "name": "String",
                     "removeLinks": "[String]",
                     "tags": "[String]"
                  }
               }
            },
            "follow": {
               "code": "import FungibleToken from 0xee82856bf20e2aa6\nimport FUSD from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport FIND from 0x179b6b1cb6755e31\nimport Profile from 0x179b6b1cb6755e31\n\n// map of {User in string (find name or address) : [tag]}\ntransaction(follows:{String : [String]}) {\n\n    let profile : \u0026Profile.User\n\n    prepare(account: AuthAccount) {\n\n        self.profile =account.borrow\u003c\u0026Profile.User\u003e(from:Profile.storagePath) ?? panic(\"Cannot borrow reference to profile\")\n\n        //Add exising FUSD or create a new one and add it\n        let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n        if !fusdReceiver.check() {\n            let fusd \u003c- FUSD.createEmptyVault()\n            account.save(\u003c- fusd, to: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n        }\n\n\n        var hasFusdWallet=false\n        var hasFlowWallet=false\n        let wallets=self.profile.getWallets()\n        for wallet in wallets {\n            if wallet.name==\"FUSD\" {\n                hasFusdWallet=true\n            }\n\n            if wallet.name ==\"Flow\" {\n                hasFlowWallet=true\n            }\n        }\n\n        if !hasFlowWallet {\n            let flowWallet=Profile.Wallet(\n                name:\"Flow\",\n                receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver),\n                balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance),\n                accept: Type\u003c@FlowToken.Vault\u003e(),\n                tags: [\"flow\"]\n            )\n            self.profile.addWallet(flowWallet)\n        }\n\n        if !hasFusdWallet {\n            let fusdWallet=Profile.Wallet(\n                name:\"FUSD\",\n                receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver),\n                balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance),\n                accept: Type\u003c@FUSD.Vault\u003e(),\n                tags: [\"fusd\", \"stablecoin\"]\n            )\n            self.profile.addWallet(fusdWallet)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n    }\n\n    execute{\n        for key in follows.keys {\n            let user = FIND.resolve(key) ?? panic(key.concat(\" cannot be resolved. It is either an invalid .find name or address\"))\n            let tags = follows[key]!\n            self.profile.follow(user, tags: tags)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "follows"
                  ],
                  "parameters": {
                     "follows": "{String: [String]}"
                  }
               }
            },
            "followDapper": {
               "code": "import FungibleToken from 0xee82856bf20e2aa6\nimport FUSD from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport FIND from 0x179b6b1cb6755e31\nimport Profile from 0x179b6b1cb6755e31\n\n// map of {User in string (find name or address) : [tag]}\ntransaction(follows:{String : [String]}) {\n\n    let profile : \u0026Profile.User\n\n    prepare(account: AuthAccount) {\n\n        self.profile =account.borrow\u003c\u0026Profile.User\u003e(from:Profile.storagePath) ?? panic(\"You do not have a profile set up, initialize the user first\")\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n\n        }\n    }\n\n    execute{\n        for key in follows.keys {\n            let user = FIND.resolve(key) ?? panic(key.concat(\" cannot be resolved. It is either an invalid .find name or address\"))\n            let tags = follows[key]!\n            self.profile.follow(user, tags: tags)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "follows"
                  ],
                  "parameters": {
                     "follows": "{String: [String]}"
                  }
               }
            },
            "fulfillLeaseMarketAuctionSoft": {
               "code": "import FindLeaseMarketAuctionSoft from 0x179b6b1cb6755e31\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FTRegistry from 0x179b6b1cb6755e31\nimport FindMarket from 0x179b6b1cb6755e31\nimport FindLeaseMarket from 0x179b6b1cb6755e31\n\ntransaction(leaseName: String, amount:UFix64) {\n\n    let walletReference : \u0026FungibleToken.Vault\n    let bidsReference: \u0026FindLeaseMarketAuctionSoft.MarketBidCollection\n    let requiredAmount: UFix64\n\n    prepare(account: AuthAccount) {\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e())\n\n        self.bidsReference= account.borrow\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"This account does not have a bid collection\")\n\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e())\n        let item = FindLeaseMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, name: leaseName)\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n\n        self.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n        self.requiredAmount = self.bidsReference.getBalance(leaseName)\n    }\n\n    pre{\n        self.walletReference.balance \u003e self.requiredAmount : \"Your wallet does not have enough funds to pay for this item\"\n        self.requiredAmount == amount : \"Amount needed to fulfill is \".concat(self.requiredAmount.toString()).concat(\" you sent in \").concat(amount.toString())\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount)\n        self.bidsReference.fulfillAuction(name: leaseName, vault: \u003c- vault)\n    }\n}",
               "spec": {
                  "order": [
                     "leaseName",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "leaseName": "String"
                  }
               }
            },
            "fulfillLeaseMarketAuctionSoftDapper": {
               "code": "import FindLeaseMarketAuctionSoft from 0x179b6b1cb6755e31\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FTRegistry from 0x179b6b1cb6755e31\nimport FindMarket from 0x179b6b1cb6755e31\nimport FindLeaseMarket from 0x179b6b1cb6755e31\n\ntransaction(leaseName: String, amount:UFix64) {\n\n    let walletReference : \u0026FungibleToken.Vault\n    let bidsReference: \u0026FindLeaseMarketAuctionSoft.MarketBidCollection\n    let requiredAmount: UFix64\n    let mainDapperCoinVault: \u0026FungibleToken.Vault\n    let balanceBeforeTransfer: UFix64\n\n    prepare(dapper: AuthAccount, account: AuthAccount) {\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e())\n\n        self.bidsReference= account.borrow\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"This account does not have a bid collection\")\n\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e())\n        let item = FindLeaseMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, name: leaseName)\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n\n        self.mainDapperCoinVault = dapper.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"Cannot borrow Dapper Coin vault from account storage. Type : \".concat(ft.type.identifier))\n        self.balanceBeforeTransfer = self.mainDapperCoinVault.balance\n\n        self.walletReference = dapper.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n        self.requiredAmount = self.bidsReference.getBalance(leaseName)\n    }\n\n    pre{\n        self.walletReference.balance \u003e self.requiredAmount : \"Your wallet does not have enough funds to pay for this item\"\n        self.requiredAmount == amount : \"Amount needed to fulfill is \".concat(self.requiredAmount.toString()).concat(\" you sent in \").concat(amount.toString())\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount)\n        self.bidsReference.fulfillAuction(name: leaseName, vault: \u003c- vault)\n    }\n\n    // Check that all dapper Coin was routed back to Dapper\n    post {\n        self.mainDapperCoinVault.balance == self.balanceBeforeTransfer: \"Dapper Coin leakage\"\n    }\n}",
               "spec": {
                  "order": [
                     "leaseName",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "leaseName": "String"
                  }
               }
            },
            "fulfillLeaseMarketDirectOfferSoft": {
               "code": "import FindLeaseMarketDirectOfferSoft from 0x179b6b1cb6755e31\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FTRegistry from 0x179b6b1cb6755e31\nimport FindMarket from 0x179b6b1cb6755e31\nimport FindLeaseMarket from 0x179b6b1cb6755e31\n\ntransaction(leaseName: String, amount:UFix64) {\n\n    let walletReference : \u0026FungibleToken.Vault\n    let bidsReference: \u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection\n    let requiredAmount:UFix64\n\n    prepare(account: AuthAccount) {\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e())\n        self.bidsReference= account.borrow\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"Cannot borrow direct offer soft bid collection\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e())\n        let item = FindLeaseMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, name: leaseName)\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n\n          self.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n\n        self.requiredAmount = self.bidsReference.getBalance(leaseName)\n    }\n\n    pre {\n        self.walletReference.balance \u003e self.requiredAmount : \"Your wallet does not have enough funds to pay for this item\"\n        self.requiredAmount == amount : \"Amount needed to fulfill is \".concat(amount.toString())\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount)\n        self.bidsReference.fulfillDirectOffer(name: leaseName, vault: \u003c- vault)\n    }\n}",
               "spec": {
                  "order": [
                     "leaseName",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "leaseName": "String"
                  }
               }
            },
            "fulfillLeaseMarketDirectOfferSoftDapper": {
               "code": "import FindLeaseMarketDirectOfferSoft from 0x179b6b1cb6755e31\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FTRegistry from 0x179b6b1cb6755e31\nimport FindMarket from 0x179b6b1cb6755e31\nimport FindLeaseMarket from 0x179b6b1cb6755e31\n\ntransaction(leaseName: String, amount:UFix64) {\n\n    let walletReference : \u0026FungibleToken.Vault\n    let bidsReference: \u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection\n    let requiredAmount:UFix64\n    let mainDapperCoinVault: \u0026FungibleToken.Vault\n    let balanceBeforeTransfer: UFix64\n\n    prepare(dapper: AuthAccount, account: AuthAccount) {\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e())\n        self.bidsReference= account.borrow\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"Cannot borrow direct offer soft bid collection\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e())\n        let item = FindLeaseMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, name: leaseName)\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n\n        self.mainDapperCoinVault = dapper.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"Cannot borrow Dapper Coin vault from account storage. Type : \".concat(ft.type.identifier))\n        self.balanceBeforeTransfer = self.mainDapperCoinVault.balance\n\n          self.walletReference = dapper.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n\n        self.requiredAmount = self.bidsReference.getBalance(leaseName)\n    }\n\n    pre {\n        self.walletReference.balance \u003e self.requiredAmount : \"Your wallet does not have enough funds to pay for this item\"\n        self.requiredAmount == amount : \"Amount needed to fulfill is \".concat(amount.toString())\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount)\n        self.bidsReference.fulfillDirectOffer(name: leaseName, vault: \u003c- vault)\n    }\n\n    // Check that all dapper Coin was routed back to Dapper\n    post {\n        self.mainDapperCoinVault.balance == self.balanceBeforeTransfer: \"Dapper Coin leakage\"\n    }\n}",
               "spec": {
                  "order": [
                     "leaseName",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "leaseName": "String"
                  }
               }
            },
            "fulfillMarketAuctionEscrowed": {
               "code": "import FindMarketAuctionEscrow from 0x179b6b1cb6755e31\nimport FIND from 0x179b6b1cb6755e31\n\ntransaction(marketplace:Address, owner: String, id: UInt64) {\n\n    let saleItem : Capability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic}\u003e?\n\n    prepare(account: AuthAccount) {\n        let resolveAddress = FIND.resolve(owner)\n        if resolveAddress == nil { \n            panic(\"The address input is not a valid name nor address. Input : \".concat(owner))\n        }\n        let address = resolveAddress!\n        self.saleItem = FindMarketAuctionEscrow.getSaleItemCapability(marketplace:marketplace, user:address)\n\n    }\n\n    pre{\n        self.saleItem != nil : \"This saleItem capability does not exist. Sale item ID: \".concat(id.toString())\n        self.saleItem!.check() : \"Cannot borrow reference to saleItem. Sale item ID: \".concat(id.toString())\n    }\n\n    execute {\n        self.saleItem!.borrow()!.fulfillAuction(id)\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "owner",
                     "id"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "marketplace": "Address",
                     "owner": "String"
                  }
               }
            },
            "fulfillMarketAuctionEscrowedFromBidder": {
               "code": "import FindMarketAuctionEscrow from 0x179b6b1cb6755e31\nimport FindMarket from 0x179b6b1cb6755e31\n\ntransaction(marketplace:Address, id: UInt64) {\n\n    let bidsReference : \u0026FindMarketAuctionEscrow.MarketBidCollection?\n\n    prepare(account: AuthAccount) {\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e())\n        self.bidsReference= account.borrow\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection\u003e(from: storagePath)\n\n        \n    }\n\n    pre{\n        self.bidsReference != nil : \"Cannot borrow reference to bid collection.\"\n    }\n\n    execute{\n        self.bidsReference!.fulfillAuction(id)\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "fulfillMarketAuctionSoft": {
               "code": "import FindMarketAuctionSoft from 0x179b6b1cb6755e31\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FTRegistry from 0x179b6b1cb6755e31\nimport FindMarket from 0x179b6b1cb6755e31\n\ntransaction(marketplace:Address, id: UInt64, amount:UFix64) {\n\n    let walletReference : \u0026FungibleToken.Vault\n    let bidsReference: \u0026FindMarketAuctionSoft.MarketBidCollection\n    let requiredAmount: UFix64\n\n    prepare(account: AuthAccount) {\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e())\n\n        self.bidsReference= account.borrow\u003c\u0026FindMarketAuctionSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"This account does not have a bid collection\")\n\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e())\n        let item = FindMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: id)\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n    \n        self.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n        self.requiredAmount = self.bidsReference.getBalance(id)\n    }\n\n    pre{\n        self.walletReference.balance \u003e self.requiredAmount : \"Your wallet does not have enough funds to pay for this item\"\n        self.requiredAmount == amount : \"Amount needed to fulfill is \".concat(self.requiredAmount.toString()).concat(\" you sent in \").concat(amount.toString())\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount) \n        self.bidsReference.fulfillAuction(id: id, vault: \u003c- vault)\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "fulfillMarketAuctionSoftDapper": {
               "code": "import FindMarketAuctionSoft from 0x179b6b1cb6755e31\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FTRegistry from 0x179b6b1cb6755e31\nimport FindMarket from 0x179b6b1cb6755e31\n\ntransaction(marketplace:Address, id: UInt64, amount:UFix64) {\n\n    let walletReference : \u0026FungibleToken.Vault\n    let bidsReference: \u0026FindMarketAuctionSoft.MarketBidCollection\n    let requiredAmount: UFix64\n    let mainDapperCoinVault: \u0026FungibleToken.Vault\n    let balanceBeforeTransfer: UFix64\n\n    prepare(dapper: AuthAccount, account: AuthAccount) {\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e())\n\n        self.bidsReference= account.borrow\u003c\u0026FindMarketAuctionSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"This account does not have a bid collection\")\n\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e())\n        let item = FindMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: id)\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n    \n        self.mainDapperCoinVault = dapper.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"Cannot borrow Dapper Coin vault from account storage. Type : \".concat(ft.type.identifier))\n        self.balanceBeforeTransfer = self.mainDapperCoinVault.balance\n\n        self.walletReference = dapper.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n        self.requiredAmount = self.bidsReference.getBalance(id)\n    }\n\n    pre{\n        self.walletReference.balance \u003e self.requiredAmount : \"Your wallet does not have enough funds to pay for this item\"\n        self.requiredAmount == amount : \"Amount needed to fulfill is \".concat(self.requiredAmount.toString()).concat(\" you sent in \").concat(amount.toString())\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount) \n        self.bidsReference.fulfillAuction(id: id, vault: \u003c- vault)\n    }\n\n    // Check that all dapper Coin was routed back to Dapper\n    post {\n        self.mainDapperCoinVault.balance == self.balanceBeforeTransfer: \"Dapper Coin leakage\"\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "fulfillMarketDirectOfferEscrowed": {
               "code": "import FindMarketDirectOfferEscrow from 0x179b6b1cb6755e31\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FindViews from 0x179b6b1cb6755e31\nimport NFTCatalog from 0xf8d6e0586b0a20c7\nimport FINDNFTCatalog from 0x179b6b1cb6755e31\nimport FindMarket from 0x179b6b1cb6755e31\n\ntransaction(marketplace:Address, id: UInt64) {\n\n    let market : \u0026FindMarketDirectOfferEscrow.SaleItemCollection?\n    let pointer : FindViews.AuthNFTPointer\n\n    prepare(account: AuthAccount) {\n\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e())\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e())\n\n        let item = FindMarket.assertOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: id)\n\n        let nftIdentifier = item.getItemType().identifier\n        let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier)) \n        let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n        let nft = collection.collectionData\n\n    \n        var providerCap=account.getCapability\u003c\u0026{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e(nft.privatePath)\n\n        /* Ben : Question -\u003e Either client will have to provide the path here or agree that we set it up for the user */\n        if !providerCap.check() {\n            let newCap = account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                    nft.privatePath,\n                    target: nft.storagePath\n            )\n            if newCap == nil {\n                // If linking is not successful, we link it using finds custom link \n                let pathIdentifier = nft.privatePath.toString()\n                let findPath = PrivatePath(identifier: pathIdentifier.slice(from: \"/private/\".length , upTo: pathIdentifier.length).concat(\"_FIND\"))!\n                account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                    findPath,\n                    target: nft.storagePath\n                )\n                providerCap = account.getCapability\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(findPath)\n            }\n        }\n\n        self.pointer= FindViews.AuthNFTPointer(cap: providerCap, id: item.getItemID())\n        self.market = account.borrow\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection\u003e(from: storagePath)\n\n    }\n\n    pre{\n        self.market != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        self.market!.acceptDirectOffer(self.pointer)\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "fulfillMarketDirectOfferSoft": {
               "code": "import FindMarketDirectOfferSoft from 0x179b6b1cb6755e31\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FTRegistry from 0x179b6b1cb6755e31\nimport FindMarket from 0x179b6b1cb6755e31\n\ntransaction(marketplace:Address, id: UInt64, amount:UFix64) {\n\n    let walletReference : \u0026FungibleToken.Vault\n    let bidsReference: \u0026FindMarketDirectOfferSoft.MarketBidCollection\n    let requiredAmount:UFix64\n\n    prepare(account: AuthAccount) {\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n        self.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"Cannot borrow direct offer soft bid collection\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n        let item = FindMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: id)\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n\n      self.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n\n        self.requiredAmount = self.bidsReference.getBalance(id)\n    }\n\n    pre {\n        self.walletReference.balance \u003e self.requiredAmount : \"Your wallet does not have enough funds to pay for this item\"\n        self.requiredAmount == amount : \"Amount needed to fulfill is \".concat(amount.toString())\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount) \n        self.bidsReference.fulfillDirectOffer(id: id, vault: \u003c- vault)\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "fulfillMarketDirectOfferSoftDapper": {
               "code": "import FindMarketDirectOfferSoft from 0x179b6b1cb6755e31\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FTRegistry from 0x179b6b1cb6755e31\nimport FindMarket from 0x179b6b1cb6755e31\n\ntransaction(marketplace:Address, id: UInt64, amount:UFix64) {\n\n    let walletReference : \u0026FungibleToken.Vault\n    let bidsReference: \u0026FindMarketDirectOfferSoft.MarketBidCollection\n    let requiredAmount:UFix64\n    let mainDapperCoinVault: \u0026FungibleToken.Vault\n    let balanceBeforeTransfer: UFix64\n\n    prepare(dapper: AuthAccount, account: AuthAccount) {\n\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n        self.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"Cannot borrow direct offer soft bid collection\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n        let item = FindMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: id)\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n\n        self.mainDapperCoinVault = dapper.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"Cannot borrow Dapper Coin vault from account storage. Type : \".concat(ft.type.identifier))\n        self.balanceBeforeTransfer = self.mainDapperCoinVault.balance\n\n          self.walletReference = dapper.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n\n        self.requiredAmount = self.bidsReference.getBalance(id)\n    }\n\n    pre {\n        self.walletReference.balance \u003e self.requiredAmount : \"Your wallet does not have enough funds to pay for this item\"\n        self.requiredAmount == amount : \"Amount needed to fulfill is \".concat(amount.toString())\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount) \n        self.bidsReference.fulfillDirectOffer(id: id, vault: \u003c- vault)\n    }\n\n    // Check that all dapper Coin was routed back to Dapper\n    post {\n        self.mainDapperCoinVault.balance == self.balanceBeforeTransfer: \"Dapper Coin leakage\"\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "fulfillMultipleMarketDirectOfferEscrowed": {
               "code": "import FindMarketDirectOfferEscrow from 0x179b6b1cb6755e31\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FindViews from 0x179b6b1cb6755e31\nimport NFTCatalog from 0xf8d6e0586b0a20c7\nimport FINDNFTCatalog from 0x179b6b1cb6755e31\nimport FindMarket from 0x179b6b1cb6755e31\n\ntransaction(marketplace:Address, ids: [UInt64]) {\n\n    let market : \u0026FindMarketDirectOfferEscrow.SaleItemCollection?\n    let pointer : [FindViews.AuthNFTPointer]\n\n    prepare(account: AuthAccount) {\n\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e())\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e())\n        self.market = account.borrow\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection\u003e(from: storagePath)\n        self.pointer = []\n\n        let nfts : {String : NFTCatalog.NFTCollectionData} = {}\n        var counter = 0\n        while counter \u003c ids.length {\n            let item = FindMarket.assertOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: ids[counter])\n\n            var nft : NFTCatalog.NFTCollectionData? = nil\n            let nftIdentifier = item.getItemType().identifier\n\n            if nfts[nftIdentifier] != nil {\n                nft = nfts[nftIdentifier]\n            } else {\n                let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier)) \n                let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n                nft = collection.collectionData\n                nfts[nftIdentifier] = nft\n            }\n        \n            var providerCap=account.getCapability\u003c\u0026{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e(nft!.privatePath)\n\n            /* Ben : Question -\u003e Either client will have to provide the path here or agree that we set it up for the user */\n            if !providerCap.check() {\n                let newCap = account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                        nft!.privatePath,\n                        target: nft!.storagePath\n                )\n                if newCap == nil {\n                    // If linking is not successful, we link it using finds custom link \n                    let pathIdentifier = nft!.privatePath.toString()\n                    let findPath = PrivatePath(identifier: pathIdentifier.slice(from: \"/private/\".length , upTo: pathIdentifier.length).concat(\"_FIND\"))!\n                    account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                        findPath,\n                        target: nft!.storagePath\n                    )\n                    providerCap = account.getCapability\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(findPath)\n                }\n            }\n\n            let pointer= FindViews.AuthNFTPointer(cap: providerCap, id: item.getItemID())\n            self.pointer.append(pointer)\n            counter = counter + 1\n        }\n\n    }\n\n    pre{\n        self.market != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        var counter = 0\n        while counter \u003c ids.length {\n            self.market!.acceptDirectOffer(self.pointer[counter])\n            counter = counter + 1\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "ids"
                  ],
                  "parameters": {
                     "ids": "[UInt64]",
                     "marketplace": "Address"
                  }
               }
            },
            "fulfillMultipleMarketDirectOfferSoft": {
               "code": "import FindMarketDirectOfferSoft from 0x179b6b1cb6755e31\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FTRegistry from 0x179b6b1cb6755e31\nimport FindMarket from 0x179b6b1cb6755e31\n\ntransaction(marketplace:Address, ids: [UInt64], amounts:[UFix64]) {\n\n    let walletReference : [\u0026FungibleToken.Vault]\n    let bidsReference: \u0026FindMarketDirectOfferSoft.MarketBidCollection\n    let requiredAmount: [UFix64]\n\n    prepare(account: AuthAccount) {\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n        self.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"Cannot borrow direct offer soft bid collection\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n\n        var counter = 0\n        self.requiredAmount = []\n        self.walletReference = []\n        let fts : {String : FTRegistry.FTInfo} = {}\n        let vaultRefs : {StoragePath : \u0026FungibleToken.Vault} = {}\n\n\n        while counter \u003c ids.length {\n            let item = FindMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: ids[counter])\n\n            var ft : FTRegistry.FTInfo? = nil\n            let ftIdentifier = item.getFtType().identifier\n            if fts[ftIdentifier] != nil {\n                ft = fts[ftIdentifier]\n            } else {\n                ft = FTRegistry.getFTInfoByTypeIdentifier(ftIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftIdentifier))\n                fts[ftIdentifier] = ft\n            }\n\n            if vaultRefs[ft!.vaultPath] != nil {\n                self.walletReference.append(vaultRefs[ft!.vaultPath]!)\n            } else {\n                let walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft!.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n                vaultRefs[ft!.vaultPath] = walletReference\n                self.walletReference.append(walletReference)\n            }\n            let requiredAmount = self.bidsReference.getBalance(ids[counter])\n            self.requiredAmount.append(requiredAmount)\n            counter = counter + 1\n        }\n    }\n\n    execute {\n        var counter = 0\n        while counter \u003c ids.length {\n            if self.walletReference[counter].balance \u003c self.requiredAmount[counter] {\n                panic(\"Your wallet does not have enough funds to pay for this item. Item ID: \".concat(ids[counter].toString()))\n            }\n            if self.requiredAmount[counter] != amounts[counter] {\n                panic(\"Amount needed to fulfill is \".concat(amounts[counter].toString()))\n            }\n            let vault \u003c- self.walletReference[counter].withdraw(amount: amounts[counter]) \n            self.bidsReference.fulfillDirectOffer(id: ids[counter], vault: \u003c- vault)\n            counter = counter + 1\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "ids",
                     "amounts"
                  ],
                  "parameters": {
                     "amounts": "[UFix64]",
                     "ids": "[UInt64]",
                     "marketplace": "Address"
                  }
               }
            },
            "fulfillMultipleMarketDirectOfferSoftDapper": {
               "code": "import FindMarketDirectOfferSoft from 0x179b6b1cb6755e31\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FTRegistry from 0x179b6b1cb6755e31\nimport FindMarket from 0x179b6b1cb6755e31\n\ntransaction(marketplace:Address, ids: [UInt64], amounts:[UFix64]) {\n\n    let walletReference : [\u0026FungibleToken.Vault]\n    let bidsReference: \u0026FindMarketDirectOfferSoft.MarketBidCollection\n    let requiredAmount: [UFix64]\n    let balanceBeforeTransfer: {Type : UFix64}\n\n    prepare(dapper: AuthAccount, account: AuthAccount) {\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n        self.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"Cannot borrow direct offer soft bid collection\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n\n        var counter = 0\n        self.requiredAmount = []\n        self.walletReference = []\n        self.balanceBeforeTransfer = {}\n        let fts : {String : FTRegistry.FTInfo} = {}\n        let vaultRefs : {StoragePath : \u0026FungibleToken.Vault} = {}\n\n\n        while counter \u003c ids.length {\n            let item = FindMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: ids[counter])\n\n            var ft : FTRegistry.FTInfo? = nil\n            let ftIdentifier = item.getFtType().identifier\n            if fts[ftIdentifier] != nil {\n                ft = fts[ftIdentifier]\n            } else {\n                ft = FTRegistry.getFTInfoByTypeIdentifier(ftIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftIdentifier))\n                fts[ftIdentifier] = ft\n            }\n\n            if vaultRefs[ft!.vaultPath] != nil {\n                let vaultRef = vaultRefs[ft!.vaultPath]!\n                self.walletReference.append(vaultRef)\n            } else {\n                let walletReference = dapper.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft!.vaultPath) ?? panic(\"Cannot borrow Dapper Coin Vault. Type : \".concat(ft!.type.identifier))\n                vaultRefs[ft!.vaultPath] = walletReference\n                self.walletReference.append(walletReference)\n                self.balanceBeforeTransfer[walletReference.getType()] = walletReference.balance\n            }\n            let requiredAmount = self.bidsReference.getBalance(ids[counter])\n            self.requiredAmount.append(requiredAmount)\n            counter = counter + 1\n        }\n    }\n\n    execute {\n        var counter = 0\n        while counter \u003c ids.length {\n            if self.walletReference[counter].balance \u003c self.requiredAmount[counter] {\n                panic(\"Your wallet does not have enough funds to pay for this item. Item ID: \".concat(ids[counter].toString()))\n            }\n            if self.requiredAmount[counter] != amounts[counter] {\n                panic(\"Amount needed to fulfill is \".concat(amounts[counter].toString()))\n            }\n            let vault \u003c- self.walletReference[counter].withdraw(amount: amounts[counter]) \n            self.bidsReference.fulfillDirectOffer(id: ids[counter], vault: \u003c- vault)\n            counter = counter + 1\n        }\n        // Check that all dapper Coin was routed back to Dapper\n        for vault in self.walletReference {\n            if self.balanceBeforeTransfer[vault.getType()]! != vault.balance {\n                panic(\"Dapper Coin leakage. Type : \".concat(vault.getType().identifier))\n            }\n        }\n    }\n\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "ids",
                     "amounts"
                  ],
                  "parameters": {
                     "amounts": "[UFix64]",
                     "ids": "[UInt64]",
                     "marketplace": "Address"
                  }
               }
            },
            "fulfillName": {
               "code": "import FIND from 0x179b6b1cb6755e31\nimport Profile from 0x179b6b1cb6755e31\n\ntransaction(name: String) {\n\n    let finLeases : \u0026FIND.LeaseCollection?\n\n    prepare(account: AuthAccount) {\n        self.finLeases= account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath) \n    }\n\n    pre{\n        self.finLeases != nil : \"Cannot borrow reference to find lease collection\"\n    }\n\n    execute{\n        self.finLeases!.fulfill(name)\n    }\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "fulfillNameAuction": {
               "code": "import FIND from 0x179b6b1cb6755e31\nimport Profile from 0x179b6b1cb6755e31\n\ntransaction(owner: Address, name: String) {\n\n    let leases : \u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}?\n\n    prepare(account: AuthAccount) {\n        self.leases = getAccount(owner).getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath).borrow()\n    }\n\n    pre{\n        self.leases != nil : \"Cannot borrow reference to lease collection reference. Account address: \".concat(owner.toString())\n    }\n\n    execute{\n        self.leases!.fulfillAuction(name)\n    }\n}",
               "spec": {
                  "order": [
                     "owner",
                     "name"
                  ],
                  "parameters": {
                     "name": "String",
                     "owner": "Address"
                  }
               }
            },
            "fulfillNameAuctionBidder": {
               "code": "import FIND from 0x179b6b1cb6755e31\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FUSD from 0xf8d6e0586b0a20c7\nimport Profile from 0x179b6b1cb6755e31\n\ntransaction(owner: Address, name: String) {\n\n    let leaseCollectionOwner : \u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}?\n\n    prepare(account: AuthAccount) {\n\n\n    //Add exising FUSD or create a new one and add it\n        let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n        if !fusdReceiver.check() {\n            let fusd \u003c- FUSD.createEmptyVault()\n            account.save(\u003c- fusd, to: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n\n            let fusdWallet=Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), tags: [\"fusd\", \"stablecoin\"])\n\n            profile.addWallet(fusdWallet)\n\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n        }\n\n        self.leaseCollectionOwner = getAccount(owner).getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath).borrow()\n\n    }\n\n    pre{\n        self.leaseCollectionOwner != nil : \"Cannot borrow reference to find lease collection. Account address: \".concat(owner.toString())\n    }\n\n    execute {\n        self.leaseCollectionOwner!.fulfillAuction(name)\n    }\n}",
               "spec": {
                  "order": [
                     "owner",
                     "name"
                  ],
                  "parameters": {
                     "name": "String",
                     "owner": "Address"
                  }
               }
            },
            "hideFindThoughts": {
               "code": "import FindThoughts from 0x179b6b1cb6755e31\nimport FIND from 0x179b6b1cb6755e31\n\ntransaction(ids: [UInt64], hide: [Bool]) {\n\n    let collection : \u0026FindThoughts.Collection\n\n    prepare(account: AuthAccount) {\n        self.collection=account.borrow\u003c\u0026FindThoughts.Collection\u003e(from: FindThoughts.CollectionStoragePath) ?? panic(\"Cannot borrow thoughts reference from path\")\n    }\n\n    execute {\n        for i, id in ids {\n            self.collection.hide(id: id, hide: hide[i])\n        }\n\n    }\n}",
               "spec": {
                  "order": [
                     "ids",
                     "hide"
                  ],
                  "parameters": {
                     "hide": "[Bool]",
                     "ids": "[UInt64]"
                  }
               }
            },
            "increaseBidLeaseMarketAuctionSoft": {
               "code": "import FindLeaseMarketAuctionSoft from 0x179b6b1cb6755e31\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FTRegistry from 0x179b6b1cb6755e31\nimport FindMarket from 0x179b6b1cb6755e31\nimport FindLeaseMarket from 0x179b6b1cb6755e31\n\ntransaction(leaseName: String, amount: UFix64) {\n\n    let bidsReference: \u0026FindLeaseMarketAuctionSoft.MarketBidCollection\n\n    prepare(account: AuthAccount) {\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e())\n        self.bidsReference= account.borrow\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"Bid resource does not exist\")\n        // get Bidding Fungible Token Vault\n          let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e())\n        let item = FindLeaseMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, name: leaseName)\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n\n    }\n\n    execute {\n        self.bidsReference.increaseBid(name: leaseName, increaseBy: amount)\n    }\n\n}",
               "spec": {
                  "order": [
                     "leaseName",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "leaseName": "String"
                  }
               }
            },
            "increaseBidLeaseMarketDirectOfferSoft": {
               "code": "import FindLeaseMarketDirectOfferSoft from 0x179b6b1cb6755e31\nimport FindMarket from 0x179b6b1cb6755e31\nimport FindLeaseMarket from 0x179b6b1cb6755e31\n\ntransaction(leaseName: String, amount: UFix64) {\n\n    let bidsReference: \u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection\n\n    prepare(account: AuthAccount) {\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e())\n        self.bidsReference= account.borrow\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"Bid resource does not exist\")\n        // get Bidding Fungible Token Vault\n          let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e())\n        let item = FindLeaseMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, name: leaseName)\n    }\n\n    execute {\n        self.bidsReference.increaseBid(name: leaseName, increaseBy: amount)\n    }\n}",
               "spec": {
                  "order": [
                     "leaseName",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "leaseName": "String"
                  }
               }
            },
            "increaseBidMarketAuctionEscrowed": {
               "code": "import FindMarketAuctionEscrow from 0x179b6b1cb6755e31\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FTRegistry from 0x179b6b1cb6755e31\nimport FindMarket from 0x179b6b1cb6755e31\n\ntransaction(marketplace:Address, id: UInt64, amount: UFix64) {\n\n    let walletReference : \u0026FungibleToken.Vault\n    let bidsReference: \u0026FindMarketAuctionEscrow.MarketBidCollection\n    let balanceBeforeBid: UFix64\n\n    prepare(account: AuthAccount) {\n\n        // Get the accepted vault type from BidInfo\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e())\n        self.bidsReference= account.borrow\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection\u003e(from: storagePath) ?? panic(\"This account does not have a bid collection\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e())\n        let item = FindMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: id)\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n        self.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n        self.balanceBeforeBid = self.walletReference.balance\n    }\n\n    pre {\n        self.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount) \n        self.bidsReference.increaseBid(id: id, vault: \u003c- vault)\n    }\n\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "increaseBidMarketAuctionSoft": {
               "code": "import FindMarketAuctionSoft from 0x179b6b1cb6755e31\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FTRegistry from 0x179b6b1cb6755e31\nimport FindMarket from 0x179b6b1cb6755e31\n\ntransaction(marketplace:Address, id: UInt64, amount: UFix64) {\n\n    let bidsReference: \u0026FindMarketAuctionSoft.MarketBidCollection\n\n\n    prepare(account: AuthAccount) {\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e())\n        self.bidsReference= account.borrow\u003c\u0026FindMarketAuctionSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"Bid resource does not exist\")\n        // get Bidding Fungible Token Vault\n          let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e())\n        let item = FindMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: id)\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n        if !ft.tag.contains(\"dapper\") {\n            let walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n        }\n    }\n\n    execute {\n        self.bidsReference.increaseBid(id: id, increaseBy: amount)\n    }\n\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "increaseBidMarketDirectOfferEscrowed": {
               "code": "import FindMarketDirectOfferEscrow from 0x179b6b1cb6755e31\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FTRegistry from 0x179b6b1cb6755e31\nimport FindMarket from 0x179b6b1cb6755e31\n\ntransaction(marketplace:Address, id: UInt64, amount: UFix64) {\n\n    let walletReference : \u0026FungibleToken.Vault\n    let bidsReference: \u0026FindMarketDirectOfferEscrow.MarketBidCollection\n    let balanceBeforeBid: UFix64\n\n    prepare(account: AuthAccount) {\n        let tenant=FindMarket.getTenantCapability(marketplace)!.borrow() ?? panic(\"Cannot borrow reference to tenant\")\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e())\n        self.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection\u003e(from: storagePath) ?? panic(\"This account does not have a bid collection\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e())\n        let item = FindMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: id)\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n        self.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n        self.balanceBeforeBid=self.walletReference.balance\n    }\n\n    pre {\n        self.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount) \n        self.bidsReference!.increaseBid(id: id, vault: \u003c- vault)\n    }\n\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "increaseBidMarketDirectOfferSoft": {
               "code": "import FindMarketDirectOfferSoft from 0x179b6b1cb6755e31\nimport FindMarket from 0x179b6b1cb6755e31\n\ntransaction(marketplace: Address, id: UInt64, amount: UFix64) {\n\n    let bidsReference: \u0026FindMarketDirectOfferSoft.MarketBidCollection\n\n    prepare(account: AuthAccount) {\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n        self.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"Bid resource does not exist\")\n        // get Bidding Fungible Token Vault\n          let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n        let item = FindMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: id)\n    }\n\n    execute {\n        self.bidsReference.increaseBid(id: id, increaseBy: amount)\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "increaseNameBid": {
               "code": "import FIND from 0x179b6b1cb6755e31\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FUSD from 0xf8d6e0586b0a20c7\n\ntransaction(name: String, amount: UFix64) {\n\n    let vaultRef : \u0026FUSD.Vault?\n    let bids : \u0026FIND.BidCollection?\n\n    prepare(account: AuthAccount) {\n\n        \n        let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        self.vaultRef = account.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault)\n        self.bids = account.borrow\u003c\u0026FIND.BidCollection\u003e(from: FIND.BidStoragePath)\n    }\n\n    pre{\n        self.vaultRef != nil : \"Could not borrow reference to the fusdVault!\"\n        self.bids != nil : \"Could not borrow reference to bid collection\"\n    }\n\n    execute{\n        let vault \u003c- self.vaultRef!.withdraw(amount: amount) as! @FUSD.Vault\n        self.bids!.increaseBid(name: name, vault: \u003c- vault)\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "name": "String"
                  }
               }
            },
            "initDapperAccount": {
               "code": "import FungibleToken from 0xee82856bf20e2aa6\nimport DapperUtilityCoin from 0x01cf0e2f2f715450\nimport FlowUtilityToken from 0x01cf0e2f2f715450 \nimport TokenForwarding from 0xf8d6e0586b0a20c7\n\ntransaction(dapperAddress: Address) {\n    prepare(account: AuthAccount) {\n\n        let dapper=getAccount(dapperAddress)\n        //this is only for emulator\n        let ducReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver)\n        if !ducReceiver.check() {\n            // Create a new Forwarder resource for DUC and store it in the new account's storage\n            let ducForwarder \u003c- TokenForwarding.createNewForwarder(recipient: dapper.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver))\n            account.save(\u003c-ducForwarder, to: /storage/dapperUtilityCoinVault)\n            // Publish a Receiver capability for the new account, which is linked to the DUC Forwarder\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver,target: /storage/dapperUtilityCoinVault)\n        }\n\n        //this is only for emulator\n        let futReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowUtilityTokenReceiver)\n        if !futReceiver.check() {\n            // Create a new Forwarder resource for FUT and store it in the new account's storage\n            let futForwarder \u003c- TokenForwarding.createNewForwarder(recipient: dapper.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowUtilityTokenReceiver))\n            account.save(\u003c-futForwarder, to: /storage/flowUtilityTokenVault)\n            // Publish a Receiver capability for the new account, which is linked to the FUT Forwarder\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowUtilityTokenReceiver,target: /storage/flowUtilityTokenVault)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "dapperAddress"
                  ],
                  "parameters": {
                     "dapperAddress": "Address"
                  }
               }
            },
            "initMerchantAccount": {
               "code": "import TokenForwarding from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport DapperUtilityCoin from 0x01cf0e2f2f715450\nimport FlowUtilityToken from 0x01cf0e2f2f715450\nimport FungibleTokenSwitchboard from 0xf8d6e0586b0a20c7\nimport FiatToken from 0xf8d6e0586b0a20c7\nimport FUSD from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\n\n/**\n This is a transaction to set up an merchant account\n\n It has to be a blocto account since dapper will not allow us to run this account on a merchan account\n\n The only input parameter to this is your merchant account at dapper\n\n // 1. run this transaction in a lilico/blocto account your \"credit account\"\n // 2. use the path = /public/fungibleTokenSwitchboardPublic on this account as royalty receiver, it will be able to handle all the common FT\n**/\n\ntransaction(dapperMerchantAccountAddress: Address) {\n\n    prepare(acct: AuthAccount) {\n        // Get a Receiver reference for the Dapper account that will be the recipient of the forwarded DUC and FUT\n        let dapper = getAccount(dapperMerchantAccountAddress)\n\n        //FUSD\n        let fusdReceiver = acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n        if !fusdReceiver.check() {\n            let fusd \u003c- FUSD.createEmptyVault()\n            acct.save(\u003c- fusd, to: /storage/fusdVault)\n            acct.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n            acct.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n        }\n\n        //USDC\n        let usdcCap = acct.getCapability\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e(FiatToken.VaultReceiverPubPath)\n        if !usdcCap.check() {\n            acct.save( \u003c-FiatToken.createEmptyVault(), to: FiatToken.VaultStoragePath)\n            acct.link\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e( FiatToken.VaultReceiverPubPath, target: FiatToken.VaultStoragePath)\n            acct.link\u003c\u0026FiatToken.Vault{FiatToken.ResourceId}\u003e( FiatToken.VaultUUIDPubPath, target: FiatToken.VaultStoragePath)\n            acct.link\u003c\u0026FiatToken.Vault{FungibleToken.Balance}\u003e( FiatToken.VaultBalancePubPath, target:FiatToken.VaultStoragePath)\n        }\n\n        //We have to first check if the SIGNER has forwarder created.\n        //If not then we create a forwarder with the capability to DAPPER's receiver\n        //Dapper utility token\n\n        let ducReceiver = acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver)\n        let dapperDUCReceiver = dapper.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver)\n        if !ducReceiver.check(){\n            let ducForwarder \u003c- TokenForwarding.createNewForwarder(recipient: dapperDUCReceiver)\n            acct.save(\u003c-ducForwarder, to: /storage/dapperUtilityCoinReceiver)\n            acct.link\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver, target: /storage/dapperUtilityCoinReceiver)\n        }\n\n        //We have to first check if the SIGNER has forwarder created.\n        //If not then we create a forwarder with the capability to DAPPER's receiver\n        //FlowUtility token\n\n        let futReceiver = acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowUtilityTokenReceiver)\n        let dapperFUTReceiver = dapper.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowUtilityTokenReceiver)\n        if !futReceiver.check(){\n            let futForwarder \u003c- TokenForwarding.createNewForwarder(recipient: dapperFUTReceiver)\n            acct.save(\u003c-futForwarder, to: /storage/flowUtilityTokenReceiver)\n            acct.link\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowUtilityTokenReceiver, target: /storage/flowUtilityTokenReceiver)\n        }\n\n        let switchboard \u003c- FungibleTokenSwitchboard.createSwitchboard()\n\n        //We add the direct forwarder to the merchant account to the switchboard so that the chain will be\n        //switchboard --\u003e merchant account forwarder --\u003e dapper\n        //the alternative would be \n        //switchboard --\u003e our forwarder --\u003e merchant account forwarder --\u003e dapper\n        switchboard.addNewVaultWrapper(capability: dapperDUCReceiver, type: Type\u003c@DapperUtilityCoin.Vault\u003e())\n        switchboard.addNewVaultWrapper(capability: dapperFUTReceiver, type: Type\u003c@FlowUtilityToken.Vault\u003e())\n        switchboard.addNewVault(capability: usdcCap)\n        switchboard.addNewVault(capability: fusdReceiver)\n        switchboard.addNewVault(capability: acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver))\n\n        acct.save(\u003c- switchboard, to: FungibleTokenSwitchboard.StoragePath)\n        acct.link\u003c\u0026FungibleTokenSwitchboard.Switchboard{FungibleToken.Receiver}\u003e( FungibleTokenSwitchboard.ReceiverPublicPath, target: FungibleTokenSwitchboard.StoragePath)\n        acct.link\u003c\u0026FungibleTokenSwitchboard.Switchboard{FungibleTokenSwitchboard.SwitchboardPublic, FungibleToken.Receiver}\u003e(\n            FungibleTokenSwitchboard.PublicPath,\n            target: FungibleTokenSwitchboard.StoragePath\n        )\n    }\n}",
               "spec": {
                  "order": [
                     "dapperMerchantAccountAddress"
                  ],
                  "parameters": {
                     "dapperMerchantAccountAddress": "Address"
                  }
               }
            },
            "initSwitchboard": {
               "code": "import FungibleToken from 0xee82856bf20e2aa6\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport FUSD from 0xf8d6e0586b0a20c7\nimport FiatToken from 0xf8d6e0586b0a20c7\nimport TokenForwarding from 0xf8d6e0586b0a20c7\nimport FungibleTokenSwitchboard from 0xf8d6e0586b0a20c7\nimport DapperUtilityCoin from 0x01cf0e2f2f715450\nimport FlowUtilityToken from 0x01cf0e2f2f715450\n\ntransaction(dapperAddress: Address) {\n    prepare(acct: AuthAccount) {\n\n        let dapper = getAccount(dapperAddress)\n\n        //FUSD\n        let fusdReceiver = acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n        if !fusdReceiver.check() {\n            let fusd \u003c- FUSD.createEmptyVault()\n            acct.save(\u003c- fusd, to: /storage/fusdVault)\n            acct.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n            acct.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n        }\n\n        //USDC\n        let usdcCap = acct.getCapability\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e(FiatToken.VaultReceiverPubPath)\n        if !usdcCap.check() {\n            acct.save( \u003c-FiatToken.createEmptyVault(), to: FiatToken.VaultStoragePath)\n            acct.link\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e( FiatToken.VaultReceiverPubPath, target: FiatToken.VaultStoragePath)\n            acct.link\u003c\u0026FiatToken.Vault{FiatToken.ResourceId}\u003e( FiatToken.VaultUUIDPubPath, target: FiatToken.VaultStoragePath)\n            acct.link\u003c\u0026FiatToken.Vault{FungibleToken.Balance}\u003e( FiatToken.VaultBalancePubPath, target:FiatToken.VaultStoragePath)\n        }\n\n\n        //Dapper utility token\n        let dapperDUCReceiver = dapper.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver)\n        let DUCReceiver = acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver)\n        if !DUCReceiver.check(){\n            let ducForwarder \u003c- TokenForwarding.createNewForwarder(recipient: dapperDUCReceiver)\n            acct.save(\u003c-ducForwarder, to: /storage/dapperUtilityCoinReceiver)\n            acct.link\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver, target: /storage/dapperUtilityCoinReceiver)\n        }\n\n        //FlowUtility token\n        let dapperFUTReceiver = dapper.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowUtilityTokenReceiver)\n        let FUTReceiver = acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowUtilityTokenReceiver)\n        if !FUTReceiver.check(){\n            let futForwarder \u003c- TokenForwarding.createNewForwarder(recipient: dapperFUTReceiver)\n            acct.save(\u003c-futForwarder, to: /storage/flowUtilityTokenReceiver)\n            acct.link\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowUtilityTokenReceiver, target: /storage/flowUtilityTokenReceiver)\n        }\n\n        let switchboardRef = acct.borrow\u003c\u0026FungibleTokenSwitchboard.Switchboard\u003e(from: FungibleTokenSwitchboard.StoragePath)\n        if switchboardRef == nil{\n            let sb \u003c- FungibleTokenSwitchboard.createSwitchboard()\n            acct.save(\u003c- sb, to: FungibleTokenSwitchboard.StoragePath)\n            acct.link\u003c\u0026FungibleTokenSwitchboard.Switchboard{FungibleToken.Receiver}\u003e( FungibleTokenSwitchboard.ReceiverPublicPath, target: FungibleTokenSwitchboard.StoragePath)\n            acct.link\u003c\u0026FungibleTokenSwitchboard.Switchboard{FungibleTokenSwitchboard.SwitchboardPublic, FungibleToken.Receiver}\u003e(\n                FungibleTokenSwitchboard.PublicPath,\n                target: FungibleTokenSwitchboard.StoragePath\n            )\n        }\n        let switchboard = acct.borrow\u003c\u0026FungibleTokenSwitchboard.Switchboard\u003e(from: FungibleTokenSwitchboard.StoragePath)!\n        let types = switchboard.getVaultTypes()\n        if !types.contains(Type\u003c@DapperUtilityCoin.Vault\u003e()) {\n            switchboard.addNewVaultWrapper(capability: dapperDUCReceiver, type: Type\u003c@DapperUtilityCoin.Vault\u003e())\n        }\n        if !types.contains(Type\u003c@FlowUtilityToken.Vault\u003e()) {\n            switchboard.addNewVaultWrapper(capability: dapperFUTReceiver, type: Type\u003c@FlowUtilityToken.Vault\u003e())\n        }\n        if !types.contains(usdcCap.borrow()!.getType()) {\n            switchboard.addNewVault(capability: usdcCap)\n        }\n        if !types.contains(fusdReceiver.borrow()!.getType()) {\n            switchboard.addNewVault(capability: fusdReceiver)\n        }\n        let flowTokenCap = acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver)\n        if !types.contains(flowTokenCap.borrow()!.getType()) {\n            switchboard.addNewVault(capability: flowTokenCap)\n        }\n\n    }\n}",
               "spec": {
                  "order": [
                     "dapperAddress"
                  ],
                  "parameters": {
                     "dapperAddress": "Address"
                  }
               }
            },
            "initWearables": {
               "code": "import Wearables from 0xf8d6e0586b0a20c7\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\n\ntransaction() {\n    prepare(account: AuthAccount) {\n\n        let wearablesRef= account.borrow\u003c\u0026Wearables.Collection\u003e(from: Wearables.CollectionStoragePath)\n        if wearablesRef == nil {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Wearables.createEmptyCollection(), to: Wearables.CollectionStoragePath)\n            account.unlink(Wearables.CollectionPublicPath)\n            account.link\u003c\u0026Wearables.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                Wearables.CollectionPublicPath,\n                target: Wearables.CollectionStoragePath\n            )\n            account.unlink(Wearables.CollectionPrivatePath)\n            account.link\u003c\u0026Wearables.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                Wearables.CollectionPrivatePath,\n                target: Wearables.CollectionStoragePath\n            )\n            return\n        }\n\n        let wearablesCap= account.getCapability\u003c\u0026Wearables.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(Wearables.CollectionPublicPath)\n        if !wearablesCap.check() {\n            account.unlink(Wearables.CollectionPublicPath)\n            account.link\u003c\u0026Wearables.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                Wearables.CollectionPublicPath,\n                target: Wearables.CollectionStoragePath\n            )\n        }\n\n        let wearablesProviderCap= account.getCapability\u003c\u0026Wearables.Collection{NonFungibleToken.Provider,NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(Wearables.CollectionPrivatePath)\n        if !wearablesProviderCap.check() {\n            account.unlink(Wearables.CollectionPrivatePath)\n            account.link\u003c\u0026Wearables.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                Wearables.CollectionPrivatePath,\n                target: Wearables.CollectionStoragePath\n            )\n        }\n\n    }\n}",
               "spec": {
                  "order": [],
                  "parameters": {}
               }
            },
            "linkDUCVaultReceiver": {
               "code": "import TokenForwarding from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\n\n\ntransaction() {\n    prepare(account: AuthAccount) {\n        account.unlink(/public/dapperUtilityCoinReceiver)\n        account.link\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver,target: /storage/dapperUtilityCoinVault)\n    }\n}",
               "spec": {
                  "order": [],
                  "parameters": {}
               }
            },
            "listForSaleMultiple": {
               "code": "import FIND from 0x179b6b1cb6755e31\nimport FUSD from 0xf8d6e0586b0a20c7\nimport FindMarket from 0x179b6b1cb6755e31\nimport FindMarketSale from 0x179b6b1cb6755e31\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FindViews from 0x179b6b1cb6755e31\nimport NFTCatalog from 0xf8d6e0586b0a20c7\nimport FINDNFTCatalog from 0x179b6b1cb6755e31\nimport FTRegistry from 0x179b6b1cb6755e31\n\ntransaction(marketplace:Address, nftAliasOrIdentifiers: [String], ids: [AnyStruct], ftAliasOrIdentifiers: [String], directSellPrices:[UFix64], validUntil: UFix64?) {\n\n    let saleItems : \u0026FindMarketSale.SaleItemCollection?\n    let pointers : [FindViews.AuthNFTPointer]\n    let leaseNames : [String]\n    let vaultTypes : [Type]\n    let finLeases : \u0026FIND.LeaseCollection\n\n    prepare(account: AuthAccount) {\n\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n        let tenant = tenantCapability.borrow()!\n        self.vaultTypes= []\n        self.pointers= []\n        self.leaseNames= []\n        self.finLeases= account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath) ?? panic(\"Cannot borrow reference to find lease collection\")\n\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath)\n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n        self.saleItems= account.borrow\u003c\u0026FindMarketSale.SaleItemCollection\u003e(from: storagePath)!\n\n        var counter = 0\n\n        let nfts : {String : NFTCatalog.NFTCollectionData} = {}\n        let fts : {String : FTRegistry.FTInfo} = {}\n\n        while counter \u003c ids.length {\n            var ft : FTRegistry.FTInfo? = nil\n\n            if fts[ftAliasOrIdentifiers[counter]] != nil {\n                ft = fts[ftAliasOrIdentifiers[counter]]\n            } else {\n                ft = FTRegistry.getFTInfo(ftAliasOrIdentifiers[counter]) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftAliasOrIdentifiers[counter]))\n                fts[ftAliasOrIdentifiers[counter]] = ft\n            }\n\n            if let name = ids[counter] as? String {\n                if nftAliasOrIdentifiers[counter] != Type\u003c@FIND.Lease\u003e().identifier {\n                    panic(\"Lease does not match with identifiers\")\n                }\n                if ftAliasOrIdentifiers[counter] != Type\u003c@FUSD.Vault\u003e().identifier {\n                    panic(\"Listing of leases only supports FUSD at the moment\")\n                }\n                self.leaseNames.append(name)\n            }\n\n            if let id = ids[counter] as? UInt64 {\n                // Get supported NFT and FT Information from Registries from input alias\n                var nft : NFTCatalog.NFTCollectionData? = nil\n\n                if nfts[nftAliasOrIdentifiers[counter]] != nil {\n                    nft = nfts[nftAliasOrIdentifiers[counter]]\n                } else {\n                    let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftAliasOrIdentifiers[counter])?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftAliasOrIdentifiers[counter]))\n                    let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])!\n                    nft = collection.collectionData\n                    nfts[nftAliasOrIdentifiers[counter]] = nft\n                }\n\n                var providerCap=account.getCapability\u003c\u0026{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e(nft!.privatePath)\n\n                /* Ben : Question -\u003e Either client will have to provide the path here or agree that we set it up for the user */\n                if !providerCap.check() {\n                    let newCap = account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                            nft!.privatePath,\n                            target: nft!.storagePath\n                    )\n                    if newCap == nil {\n                        // If linking is not successful, we link it using finds custom link\n                        let pathIdentifier = nft!.privatePath.toString()\n                        let findPath = PrivatePath(identifier: pathIdentifier.slice(from: \"/private/\".length , upTo: pathIdentifier.length).concat(\"_FIND\"))!\n                        account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                            findPath,\n                            target: nft!.storagePath\n                        )\n                        providerCap = account.getCapability\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(findPath)\n                    }\n                }\n                // Get the salesItemRef from tenant\n                self.pointers.append(FindViews.AuthNFTPointer(cap: providerCap, id: id))\n            }\n\n            self.vaultTypes.append(ft!.type)\n            counter = counter + 1\n        }\n    }\n\n    execute{\n        var counter = 0\n        var nameCounter = 0\n        for identifier in nftAliasOrIdentifiers {\n            let vc = counter + nameCounter\n            if identifier == Type\u003c@FIND.Lease\u003e().identifier {\n                self.finLeases.listForSale(name: self.leaseNames[nameCounter],  directSellPrice:directSellPrices[vc])\n                nameCounter = nameCounter + 1\n                continue\n            }\n\n            self.saleItems!.listForSale(pointer: self.pointers[counter], vaultType: self.vaultTypes[vc], directSellPrice: directSellPrices[vc], validUntil: validUntil, extraField: {})\n            counter = counter + 1\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "nftAliasOrIdentifiers",
                     "ids",
                     "ftAliasOrIdentifiers",
                     "directSellPrices",
                     "validUntil"
                  ],
                  "parameters": {
                     "directSellPrices": "[UFix64]",
                     "ftAliasOrIdentifiers": "[String]",
                     "ids": "[AnyStruct]",
                     "marketplace": "Address",
                     "nftAliasOrIdentifiers": "[String]",
                     "validUntil": "UFix64?"
                  }
               }
            },
            "listLeaseForAuctionSoft": {
               "code": "import FindMarket from 0x179b6b1cb6755e31\nimport FTRegistry from 0x179b6b1cb6755e31\nimport FIND from 0x179b6b1cb6755e31\nimport FindLeaseMarketAuctionSoft from 0x179b6b1cb6755e31\nimport FindLeaseMarket from 0x179b6b1cb6755e31\n\ntransaction(leaseName: String, ftAliasOrIdentifier:String, price:UFix64, auctionReservePrice: UFix64, auctionDuration: UFix64, auctionExtensionOnLateBid: UFix64, minimumBidIncrement: UFix64, auctionValidUntil: UFix64?) {\n\n    let saleItems : \u0026FindLeaseMarketAuctionSoft.SaleItemCollection?\n    let pointer : FindLeaseMarket.AuthLeasePointer\n    let vaultType : Type\n\n    prepare(account: AuthAccount) {\n\n        // Get supported NFT and FT Information from Registries from input alias\n        let ft = FTRegistry.getFTInfo(ftAliasOrIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftAliasOrIdentifier))\n\n        let leaseMarketplace = FindMarket.getFindTenantAddress()\n        let leaseTenantCapability= FindMarket.getTenantCapability(leaseMarketplace)!\n        let leaseTenant = leaseTenantCapability.borrow()!\n\n        let leaseASSaleItemType= Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e()\n        let leaseASPublicPath=leaseTenant.getPublicPath(leaseASSaleItemType)\n        let leaseASStoragePath= leaseTenant.getStoragePath(leaseASSaleItemType)\n        let leaseASSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath)\n        if !leaseASSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseASStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath, target: leaseASStoragePath)\n        }\n\n        self.saleItems= account.borrow\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(from: leaseASStoragePath)\n        let ref = account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from: FIND.LeaseStoragePath)!\n        self.pointer= FindLeaseMarket.AuthLeasePointer(ref: ref, name: leaseName)\n        self.vaultType= ft.type\n\n    }\n\n    pre{\n        // Ben : panic on some unreasonable inputs in trxn\n        minimumBidIncrement \u003e 0.0 :\"Minimum bid increment should be larger than 0.\"\n        (auctionReservePrice - auctionReservePrice) % minimumBidIncrement == 0.0 : \"Acution ReservePrice should be in step of minimum bid increment.\"\n        auctionDuration \u003e 0.0 : \"Auction Duration should be greater than 0.\"\n        auctionExtensionOnLateBid \u003e 0.0 : \"Auction Duration should be greater than 0.\"\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        self.saleItems!.listForAuction(pointer: self.pointer, vaultType: self.vaultType, auctionStartPrice: price, auctionReservePrice: auctionReservePrice, auctionDuration: auctionDuration, auctionExtensionOnLateBid: auctionExtensionOnLateBid, minimumBidIncrement: minimumBidIncrement, auctionValidUntil: auctionValidUntil, saleItemExtraField: {})\n\n    }\n}",
               "spec": {
                  "order": [
                     "leaseName",
                     "ftAliasOrIdentifier",
                     "price",
                     "auctionReservePrice",
                     "auctionDuration",
                     "auctionExtensionOnLateBid",
                     "minimumBidIncrement",
                     "auctionValidUntil"
                  ],
                  "parameters": {
                     "auctionDuration": "UFix64",
                     "auctionExtensionOnLateBid": "UFix64",
                     "auctionReservePrice": "UFix64",
                     "auctionValidUntil": "UFix64?",
                     "ftAliasOrIdentifier": "String",
                     "leaseName": "String",
                     "minimumBidIncrement": "UFix64",
                     "price": "UFix64"
                  }
               }
            },
            "listLeaseForAuctionSoftDapper": {
               "code": "import FindMarket from 0x179b6b1cb6755e31\nimport FTRegistry from 0x179b6b1cb6755e31\nimport FIND from 0x179b6b1cb6755e31\nimport FindLeaseMarketAuctionSoft from 0x179b6b1cb6755e31\nimport FindLeaseMarket from 0x179b6b1cb6755e31\n\ntransaction(leaseName: String, ftAliasOrIdentifier: String, price:UFix64, auctionReservePrice: UFix64, auctionDuration: UFix64, auctionExtensionOnLateBid: UFix64, minimumBidIncrement: UFix64, auctionValidUntil: UFix64?) {\n\n    let saleItems : \u0026FindLeaseMarketAuctionSoft.SaleItemCollection?\n    let pointer : FindLeaseMarket.AuthLeasePointer\n    let vaultType : Type\n\n    prepare(account: AuthAccount) {\n\n        // Get supported NFT and FT Information from Registries from input alias\n        let ft = FTRegistry.getFTInfo(ftAliasOrIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftAliasOrIdentifier))\n\n        let leaseMarketplace = FindMarket.getFindTenantAddress()\n        let leaseTenantCapability= FindMarket.getTenantCapability(leaseMarketplace)!\n        let leaseTenant = leaseTenantCapability.borrow()!\n\n        let leaseASSaleItemType= Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e()\n        let leaseASPublicPath=leaseTenant.getPublicPath(leaseASSaleItemType)\n        let leaseASStoragePath= leaseTenant.getStoragePath(leaseASSaleItemType)\n        let leaseASSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath)\n        if !leaseASSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseASStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath, target: leaseASStoragePath)\n        }\n\n        self.saleItems= account.borrow\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(from: leaseASStoragePath)\n        let ref= account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from: FIND.LeaseStoragePath)!\n        self.pointer= FindLeaseMarket.AuthLeasePointer(ref: ref, name: leaseName)\n        self.vaultType= ft.type\n    }\n\n    pre{\n        // Ben : panic on some unreasonable inputs in trxn\n        minimumBidIncrement \u003e 0.0 :\"Minimum bid increment should be larger than 0.\"\n        (auctionReservePrice - auctionReservePrice) % minimumBidIncrement == 0.0 : \"Acution ReservePrice should be in step of minimum bid increment.\"\n        auctionDuration \u003e 0.0 : \"Auction Duration should be greater than 0.\"\n        auctionExtensionOnLateBid \u003e 0.0 : \"Auction Duration should be greater than 0.\"\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        self.saleItems!.listForAuction(pointer: self.pointer, vaultType: self.vaultType, auctionStartPrice: price, auctionReservePrice: auctionReservePrice, auctionDuration: auctionDuration, auctionExtensionOnLateBid: auctionExtensionOnLateBid, minimumBidIncrement: minimumBidIncrement, auctionValidUntil: auctionValidUntil, saleItemExtraField: {})\n\n    }\n}",
               "spec": {
                  "order": [
                     "leaseName",
                     "ftAliasOrIdentifier",
                     "price",
                     "auctionReservePrice",
                     "auctionDuration",
                     "auctionExtensionOnLateBid",
                     "minimumBidIncrement",
                     "auctionValidUntil"
                  ],
                  "parameters": {
                     "auctionDuration": "UFix64",
                     "auctionExtensionOnLateBid": "UFix64",
                     "auctionReservePrice": "UFix64",
                     "auctionValidUntil": "UFix64?",
                     "ftAliasOrIdentifier": "String",
                     "leaseName": "String",
                     "minimumBidIncrement": "UFix64",
                     "price": "UFix64"
                  }
               }
            },
            "listLeaseForSale": {
               "code": "import FindMarket from 0x179b6b1cb6755e31\nimport FIND from 0x179b6b1cb6755e31\nimport FTRegistry from 0x179b6b1cb6755e31\nimport FindLeaseMarketSale from 0x179b6b1cb6755e31\nimport FindLeaseMarket from 0x179b6b1cb6755e31\n\ntransaction(leaseName: String, ftAliasOrIdentifier: String, directSellPrice:UFix64, validUntil: UFix64?) {\n\n    let saleItems : \u0026FindLeaseMarketSale.SaleItemCollection?\n    let pointer : FindLeaseMarket.AuthLeasePointer\n    let vaultType : Type\n\n    prepare(account: AuthAccount) {\n\n        // Get the salesItemRef from tenant\n        let leaseMarketplace = FindMarket.getFindTenantAddress()\n        let leaseTenantCapability= FindMarket.getTenantCapability(leaseMarketplace)!\n        let leaseTenant = leaseTenantCapability.borrow()!\n\n        let leaseSaleItemType= Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()\n        let leasePublicPath=leaseTenant.getPublicPath(leaseSaleItemType)\n        let leaseStoragePath= leaseTenant.getStoragePath(leaseSaleItemType)\n        let leaseSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath)\n        if !leaseSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketSale.SaleItemCollection\u003e(\u003c- FindLeaseMarketSale.createEmptySaleItemCollection(leaseTenantCapability), to: leaseStoragePath)\n            account.link\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath, target: leaseStoragePath)\n        }\n\n        self.saleItems= account.borrow\u003c\u0026FindLeaseMarketSale.SaleItemCollection\u003e(from: leaseStoragePath)!\n\n        // Get supported NFT and FT Information from Registries from input alias\n        let ft = FTRegistry.getFTInfo(ftAliasOrIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftAliasOrIdentifier))\n        self.vaultType= ft.type\n\n        let lease=account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from: FIND.LeaseStoragePath)!\n\n\n        self.pointer= FindLeaseMarket.AuthLeasePointer(ref:lease, name: leaseName)\n\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        self.saleItems!.listForSale(pointer: self.pointer, vaultType: self.vaultType, directSellPrice: directSellPrice, validUntil: validUntil, extraField: {})\n    }\n}",
               "spec": {
                  "order": [
                     "leaseName",
                     "ftAliasOrIdentifier",
                     "directSellPrice",
                     "validUntil"
                  ],
                  "parameters": {
                     "directSellPrice": "UFix64",
                     "ftAliasOrIdentifier": "String",
                     "leaseName": "String",
                     "validUntil": "UFix64?"
                  }
               }
            },
            "listLeaseForSaleDapper": {
               "code": "import FindMarket from 0x179b6b1cb6755e31\nimport FIND from 0x179b6b1cb6755e31\nimport FTRegistry from 0x179b6b1cb6755e31\nimport FindLeaseMarketSale from 0x179b6b1cb6755e31\nimport FindLeaseMarket from 0x179b6b1cb6755e31\n\ntransaction(leaseName: String, ftAliasOrIdentifier: String, directSellPrice:UFix64, validUntil: UFix64?) {\n\n    let saleItems : \u0026FindLeaseMarketSale.SaleItemCollection?\n    let pointer : FindLeaseMarket.AuthLeasePointer\n    let vaultType : Type\n\n    prepare(account: AuthAccount) {\n\n        // Get the salesItemRef from tenant\n        let leaseMarketplace = FindMarket.getFindTenantAddress()\n        let leaseTenantCapability= FindMarket.getTenantCapability(leaseMarketplace)!\n        let leaseTenant = leaseTenantCapability.borrow()!\n\n        let leaseSaleItemType= Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()\n        let leasePublicPath=leaseTenant.getPublicPath(leaseSaleItemType)\n        let leaseStoragePath= leaseTenant.getStoragePath(leaseSaleItemType)\n        let leaseSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath)\n        if !leaseSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketSale.SaleItemCollection\u003e(\u003c- FindLeaseMarketSale.createEmptySaleItemCollection(leaseTenantCapability), to: leaseStoragePath)\n            account.link\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath, target: leaseStoragePath)\n        }\n\n        self.saleItems= account.borrow\u003c\u0026FindLeaseMarketSale.SaleItemCollection\u003e(from: leaseStoragePath)!\n\n        // Get supported NFT and FT Information from Registries from input alias\n        let ft = FTRegistry.getFTInfo(ftAliasOrIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftAliasOrIdentifier))\n        self.vaultType= ft.type\n\n        let ref=account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from: FIND.LeaseStoragePath)!\n\n        self.pointer= FindLeaseMarket.AuthLeasePointer(ref: ref, name: leaseName)\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        self.saleItems!.listForSale(pointer: self.pointer, vaultType: self.vaultType, directSellPrice: directSellPrice, validUntil: validUntil, extraField: {})\n\n    }\n\n}",
               "spec": {
                  "order": [
                     "leaseName",
                     "ftAliasOrIdentifier",
                     "directSellPrice",
                     "validUntil"
                  ],
                  "parameters": {
                     "directSellPrice": "UFix64",
                     "ftAliasOrIdentifier": "String",
                     "leaseName": "String",
                     "validUntil": "UFix64?"
                  }
               }
            },
            "listMultipleNFTForSale": {
               "code": "import FindMarket from 0x179b6b1cb6755e31\nimport FindMarketSale from 0x179b6b1cb6755e31\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FindViews from 0x179b6b1cb6755e31\nimport NFTCatalog from 0xf8d6e0586b0a20c7\nimport FINDNFTCatalog from 0x179b6b1cb6755e31\nimport FTRegistry from 0x179b6b1cb6755e31\n\ntransaction(marketplace:Address, nftAliasOrIdentifiers: [String], ids: [UInt64], ftAliasOrIdentifiers: [String], directSellPrices:[UFix64], validUntil: UFix64?) {\n    \n    let saleItems : \u0026FindMarketSale.SaleItemCollection?\n    let pointers : [FindViews.AuthNFTPointer]\n    let vaultTypes : [Type]\n\n    prepare(account: AuthAccount) {\n\n        if nftAliasOrIdentifiers.length != ids.length {\n            panic(\"The length of arrays passed in has to be the same\")\n        } else if nftAliasOrIdentifiers.length != ftAliasOrIdentifiers.length {\n            panic(\"The length of arrays passed in has to be the same\")\n        } else if nftAliasOrIdentifiers.length != directSellPrices.length {\n            panic(\"The length of arrays passed in has to be the same\")\n        }\n        \n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n        let tenant = tenantCapability.borrow()!\n        self.saleItems= account.borrow\u003c\u0026FindMarketSale.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketSale.SaleItemCollection\u003e()))\n        self.vaultTypes= []\n        self.pointers= []\n\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        var counter = 0\n\n        let nfts : {String : NFTCatalog.NFTCollectionData} = {}\n        let fts : {String : FTRegistry.FTInfo} = {}\n\n        while counter \u003c ids.length {\n            // Get supported NFT and FT Information from Registries from input alias\n            var nft : NFTCatalog.NFTCollectionData? = nil\n            var ft : FTRegistry.FTInfo? = nil\n\n            if nfts[nftAliasOrIdentifiers[counter]] != nil {\n                nft = nfts[nftAliasOrIdentifiers[counter]]\n            } else {\n                let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftAliasOrIdentifiers[counter])?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftAliasOrIdentifiers[counter])) \n                let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n                nft = collection.collectionData\n                nfts[nftAliasOrIdentifiers[counter]] = nft\n            }\n\n            if fts[ftAliasOrIdentifiers[counter]] != nil {\n                ft = fts[ftAliasOrIdentifiers[counter]]\n            } else {\n                ft = FTRegistry.getFTInfo(ftAliasOrIdentifiers[counter]) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftAliasOrIdentifiers[counter]))\n                fts[ftAliasOrIdentifiers[counter]] = ft \n            }\n\n            var providerCap=account.getCapability\u003c\u0026{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e(nft!.privatePath)\n\n            /* Ben : Question -\u003e Either client will have to provide the path here or agree that we set it up for the user */\n            if !providerCap.check() {\n                let newCap = account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                        nft!.privatePath,\n                        target: nft!.storagePath\n                )\n                if newCap == nil {\n                    // If linking is not successful, we link it using finds custom link \n                    let pathIdentifier = nft!.privatePath.toString()\n                    let findPath = PrivatePath(identifier: pathIdentifier.slice(from: \"/private/\".length , upTo: pathIdentifier.length).concat(\"_FIND\"))!\n                    account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                        findPath,\n                        target: nft!.storagePath\n                    )\n                    providerCap = account.getCapability\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(findPath)\n                }\n            }\n            // Get the salesItemRef from tenant\n            self.pointers.append(FindViews.AuthNFTPointer(cap: providerCap, id: ids[counter]))\n            self.vaultTypes.append(ft!.type)\n            counter = counter + 1\n        }\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        var counter = 0\n        while counter \u003c ids.length {\n            self.saleItems!.listForSale(pointer: self.pointers[counter], vaultType: self.vaultTypes[counter], directSellPrice: directSellPrices[counter], validUntil: validUntil, extraField: {})\n            counter = counter + 1\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "nftAliasOrIdentifiers",
                     "ids",
                     "ftAliasOrIdentifiers",
                     "directSellPrices",
                     "validUntil"
                  ],
                  "parameters": {
                     "directSellPrices": "[UFix64]",
                     "ftAliasOrIdentifiers": "[String]",
                     "ids": "[UInt64]",
                     "marketplace": "Address",
                     "nftAliasOrIdentifiers": "[String]",
                     "validUntil": "UFix64?"
                  }
               }
            },
            "listMultipleNFTForSaleDapper": {
               "code": "import FindMarket from 0x179b6b1cb6755e31\nimport FindMarketSale from 0x179b6b1cb6755e31\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FindViews from 0x179b6b1cb6755e31\nimport NFTCatalog from 0xf8d6e0586b0a20c7\nimport FINDNFTCatalog from 0x179b6b1cb6755e31\nimport FTRegistry from 0x179b6b1cb6755e31\n\ntransaction(marketplace:Address, nftAliasOrIdentifiers: [String], ids: [UInt64], ftAliasOrIdentifiers: [String], directSellPrices:[UFix64], validUntil: UFix64?) {\n    \n    let saleItems : \u0026FindMarketSale.SaleItemCollection?\n    let pointers : [FindViews.AuthNFTPointer]\n    let vaultTypes : [Type]\n    \n    prepare(account: AuthAccount) {\n\n        if nftAliasOrIdentifiers.length != ids.length {\n            panic(\"The length of arrays passed in has to be the same\")\n        } else if nftAliasOrIdentifiers.length != directSellPrices.length {\n            panic(\"The length of arrays passed in has to be the same\")\n        }\n\n\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n        let tenant = tenantCapability.borrow()!\n        self.saleItems= account.borrow\u003c\u0026FindMarketSale.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketSale.SaleItemCollection\u003e()))\n        self.pointers= []\n        self.vaultTypes= []\n\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        let nfts : {String : NFTCatalog.NFTCollectionData} = {}\n        let fts : {String : FTRegistry.FTInfo} = {}\n\n        var counter = 0\n        while counter \u003c ids.length {\n            // Get supported NFT and FT Information from Registries from input alias\n            var nft : NFTCatalog.NFTCollectionData? = nil\n\n            if nfts[nftAliasOrIdentifiers[counter]] != nil {\n                nft = nfts[nftAliasOrIdentifiers[counter]]\n            } else {\n                let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftAliasOrIdentifiers[counter])?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftAliasOrIdentifiers[counter])) \n                let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n                nft = collection.collectionData\n                nfts[nftAliasOrIdentifiers[counter]] = nft\n            }\n\n            if fts[ftAliasOrIdentifiers[counter]] != nil {\n                let ft = fts[ftAliasOrIdentifiers[counter]]!\n                self.vaultTypes.append(ft.type)\n            } else {\n                let ft = FTRegistry.getFTInfo(ftAliasOrIdentifiers[counter]) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftAliasOrIdentifiers[counter]))\n                fts[ftAliasOrIdentifiers[counter]] = ft \n                self.vaultTypes.append(ft.type)\n            }\n\n\n\n            var providerCap=account.getCapability\u003c\u0026{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e(nft!.privatePath)\n\n            /* Ben : Question -\u003e Either client will have to provide the path here or agree that we set it up for the user */\n            if !providerCap.check() {\n                let newCap = account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                        nft!.privatePath,\n                        target: nft!.storagePath\n                )\n                if newCap == nil {\n                    // If linking is not successful, we link it using finds custom link \n                    let pathIdentifier = nft!.privatePath.toString()\n                    let findPath = PrivatePath(identifier: pathIdentifier.slice(from: \"/private/\".length , upTo: pathIdentifier.length).concat(\"_FIND\"))!\n                    account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                        findPath,\n                        target: nft!.storagePath\n                    )\n                    providerCap = account.getCapability\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(findPath)\n                }\n            }\n            // Get the salesItemRef from tenant\n            self.pointers.append(FindViews.AuthNFTPointer(cap: providerCap, id: ids[counter]))\n            counter = counter + 1\n        }\n\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        var counter = 0\n        while counter \u003c ids.length {\n            self.saleItems!.listForSale(pointer: self.pointers[counter], vaultType: self.vaultTypes[counter], directSellPrice: directSellPrices[counter], validUntil: validUntil, extraField: {})\n            counter = counter + 1\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "nftAliasOrIdentifiers",
                     "ids",
                     "ftAliasOrIdentifiers",
                     "directSellPrices",
                     "validUntil"
                  ],
                  "parameters": {
                     "directSellPrices": "[UFix64]",
                     "ftAliasOrIdentifiers": "[String]",
                     "ids": "[UInt64]",
                     "marketplace": "Address",
                     "nftAliasOrIdentifiers": "[String]",
                     "validUntil": "UFix64?"
                  }
               }
            },
            "listNFTForAuctionEscrowed": {
               "code": "import FindMarket from 0x179b6b1cb6755e31\nimport FindMarketAuctionEscrow from 0x179b6b1cb6755e31\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FindViews from 0x179b6b1cb6755e31\nimport FINDNFTCatalog from 0x179b6b1cb6755e31\nimport FTRegistry from 0x179b6b1cb6755e31\n\ntransaction(marketplace:Address, nftAliasOrIdentifier:String, id: UInt64, ftAliasOrIdentifier:String, price:UFix64, auctionReservePrice: UFix64, auctionDuration: UFix64, auctionExtensionOnLateBid: UFix64, minimumBidIncrement: UFix64, auctionStartTime: UFix64?, auctionValidUntil: UFix64?) {\n    \n    let saleItems : \u0026FindMarketAuctionEscrow.SaleItemCollection?\n    let vaultType : Type\n    let pointer : FindViews.AuthNFTPointer\n    \n    prepare(account: AuthAccount) {\n\n\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n        let tenant = tenantCapability.borrow()!\n        let path=FindMarket.getStoragePath(Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(), name: tenant.name)\n\n        /// auctions that escrow ft\n        let aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        let aeSalePublicPath=FindMarket.getPublicPath(aeSaleType, name: tenant.name)\n        let aeSaleStoragePath= FindMarket.getStoragePath(aeSaleType, name:tenant.name)\n        let aeSaleCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n        if !aeSaleCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n        }\n\n        // Get supported NFT and FT Information from Registries from input alias\n        let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftAliasOrIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftAliasOrIdentifier)) \n        let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n        let nft = collection.collectionData\n\n        let ft = FTRegistry.getFTInfo(ftAliasOrIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftAliasOrIdentifier))\n\n        var providerCap=account.getCapability\u003c\u0026{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e(nft.privatePath)\n        \n        /* Ben : Question -\u003e Either client will have to provide the path here or agree that we set it up for the user */\n        if !providerCap.check() {\n            let newCap = account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                    nft.privatePath,\n                    target: nft.storagePath\n            )\n            if newCap == nil {\n                // If linking is not successful, we link it using finds custom link \n                let pathIdentifier = nft.privatePath.toString()\n                let findPath = PrivatePath(identifier: pathIdentifier.slice(from: \"/private/\".length , upTo: pathIdentifier.length).concat(\"_FIND\"))!\n                account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                    findPath,\n                    target: nft.storagePath\n                )\n                providerCap = account.getCapability\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(findPath)\n            }\n        }\n\n        self.saleItems= account.borrow\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection\u003e(from: path)\n        self.pointer= FindViews.AuthNFTPointer(cap: providerCap, id: id)\n        self.vaultType= ft.type\n    }\n\n    pre{\n        // Ben : panic on some unreasonable inputs in trxn \n        minimumBidIncrement \u003e 0.0 : \"Minimum bid increment should be larger than 0.\"\n        (auctionReservePrice - auctionReservePrice) % minimumBidIncrement == 0.0 : \"Acution ReservePrice should be in step of minimum bid increment.\" \n        auctionDuration \u003e 0.0 : \"Auction Duration should be greater than 0.\"\n        auctionExtensionOnLateBid \u003e 0.0 : \"Auction Duration should be greater than 0.\"\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute {\n        self.saleItems!.listForAuction(pointer: self.pointer, vaultType: self.vaultType, auctionStartPrice: price, auctionReservePrice: auctionReservePrice, auctionDuration: auctionDuration, auctionExtensionOnLateBid: auctionExtensionOnLateBid, minimumBidIncrement: minimumBidIncrement, auctionStartTime: auctionStartTime, auctionValidUntil:auctionValidUntil, saleItemExtraField: {})\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "nftAliasOrIdentifier",
                     "id",
                     "ftAliasOrIdentifier",
                     "price",
                     "auctionReservePrice",
                     "auctionDuration",
                     "auctionExtensionOnLateBid",
                     "minimumBidIncrement",
                     "auctionStartTime",
                     "auctionValidUntil"
                  ],
                  "parameters": {
                     "auctionDuration": "UFix64",
                     "auctionExtensionOnLateBid": "UFix64",
                     "auctionReservePrice": "UFix64",
                     "auctionStartTime": "UFix64?",
                     "auctionValidUntil": "UFix64?",
                     "ftAliasOrIdentifier": "String",
                     "id": "UInt64",
                     "marketplace": "Address",
                     "minimumBidIncrement": "UFix64",
                     "nftAliasOrIdentifier": "String",
                     "price": "UFix64"
                  }
               }
            },
            "listNFTForAuctionSoft": {
               "code": "import FindMarket from 0x179b6b1cb6755e31\nimport FindMarketAuctionSoft from 0x179b6b1cb6755e31\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FindViews from 0x179b6b1cb6755e31\nimport FTRegistry from 0x179b6b1cb6755e31\nimport FINDNFTCatalog from 0x179b6b1cb6755e31\n\ntransaction(marketplace:Address, nftAliasOrIdentifier:String, id: UInt64, ftAliasOrIdentifier:String, price:UFix64, auctionReservePrice: UFix64, auctionDuration: UFix64, auctionExtensionOnLateBid: UFix64, minimumBidIncrement: UFix64, auctionValidUntil: UFix64?) {\n    \n    let saleItems : \u0026FindMarketAuctionSoft.SaleItemCollection?\n    let pointer : FindViews.AuthNFTPointer\n    let vaultType : Type\n    \n    prepare(account: AuthAccount) {\n\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n        let tenant = tenantCapability.borrow()!\n\n         /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n        }\n\n        // Get supported NFT and FT Information from Registries from input alias\n        let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftAliasOrIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftAliasOrIdentifier)) \n        let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n        let nft = collection.collectionData\n\n        let ft = FTRegistry.getFTInfo(ftAliasOrIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftAliasOrIdentifier))\n\n        var providerCap = account.getCapability\u003c\u0026{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e(nft.privatePath)\n\n        /* Ben : Question -\u003e Either client will have to provide the path here or agree that we set it up for the user */\n        if !providerCap.check() {\n            let newCap = account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                    nft.privatePath,\n                    target: nft.storagePath\n            )\n            if newCap == nil {\n                // If linking is not successful, we link it using finds custom link \n                let pathIdentifier = nft.privatePath.toString()\n                let findPath = PrivatePath(identifier: pathIdentifier.slice(from: \"/private/\".length , upTo: pathIdentifier.length).concat(\"_FIND\"))!\n                account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                    findPath,\n                    target: nft.storagePath\n                )\n                providerCap = account.getCapability\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(findPath)\n            }\n        }\n        \n        self.saleItems= account.borrow\u003c\u0026FindMarketAuctionSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()))\n        self.pointer= FindViews.AuthNFTPointer(cap: providerCap, id: id)\n        self.vaultType= ft.type\n\n        \n\n    }\n\n    pre{\n        // Ben : panic on some unreasonable inputs in trxn \n        minimumBidIncrement \u003e 0.0 :\"Minimum bid increment should be larger than 0.\"\n        (auctionReservePrice - auctionReservePrice) % minimumBidIncrement == 0.0 : \"Acution ReservePrice should be in step of minimum bid increment.\" \n        auctionDuration \u003e 0.0 : \"Auction Duration should be greater than 0.\"\n        auctionExtensionOnLateBid \u003e 0.0 : \"Auction Duration should be greater than 0.\"\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        self.saleItems!.listForAuction(pointer: self.pointer, vaultType: self.vaultType, auctionStartPrice: price, auctionReservePrice: auctionReservePrice, auctionDuration: auctionDuration, auctionExtensionOnLateBid: auctionExtensionOnLateBid, minimumBidIncrement: minimumBidIncrement, auctionValidUntil: auctionValidUntil, saleItemExtraField: {})\n\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "nftAliasOrIdentifier",
                     "id",
                     "ftAliasOrIdentifier",
                     "price",
                     "auctionReservePrice",
                     "auctionDuration",
                     "auctionExtensionOnLateBid",
                     "minimumBidIncrement",
                     "auctionValidUntil"
                  ],
                  "parameters": {
                     "auctionDuration": "UFix64",
                     "auctionExtensionOnLateBid": "UFix64",
                     "auctionReservePrice": "UFix64",
                     "auctionValidUntil": "UFix64?",
                     "ftAliasOrIdentifier": "String",
                     "id": "UInt64",
                     "marketplace": "Address",
                     "minimumBidIncrement": "UFix64",
                     "nftAliasOrIdentifier": "String",
                     "price": "UFix64"
                  }
               }
            },
            "listNFTForAuctionSoftDapper": {
               "code": "import FindMarket from 0x179b6b1cb6755e31\nimport FindMarketAuctionSoft from 0x179b6b1cb6755e31\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FindViews from 0x179b6b1cb6755e31\nimport FINDNFTCatalog from 0x179b6b1cb6755e31\nimport FTRegistry from 0x179b6b1cb6755e31\n\ntransaction(marketplace:Address, nftAliasOrIdentifier:String, id: UInt64, ftAliasOrIdentifier:String, price:UFix64, auctionReservePrice: UFix64, auctionDuration: UFix64, auctionExtensionOnLateBid: UFix64, minimumBidIncrement: UFix64, auctionValidUntil: UFix64?) {\n    \n    let saleItems : \u0026FindMarketAuctionSoft.SaleItemCollection?\n    let pointer : FindViews.AuthNFTPointer\n    let vaultType : Type\n    \n    prepare(account: AuthAccount) {\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n        let tenant = tenantCapability.borrow()!\n\n         /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n        }\n\n        // Get supported NFT and FT Information from Registries from input alias\n        let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftAliasOrIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftAliasOrIdentifier)) \n        let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n        let nft = collection.collectionData\n\n        let ft = FTRegistry.getFTInfo(ftAliasOrIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftAliasOrIdentifier))\n\n        var providerCap = account.getCapability\u003c\u0026{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e(nft.privatePath)\n\n        /* Ben : Question -\u003e Either client will have to provide the path here or agree that we set it up for the user */\n        if !providerCap.check() {\n            let newCap = account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                    nft.privatePath,\n                    target: nft.storagePath\n            )\n            if newCap == nil {\n                // If linking is not successful, we link it using finds custom link \n                let pathIdentifier = nft.privatePath.toString()\n                let findPath = PrivatePath(identifier: pathIdentifier.slice(from: \"/private/\".length , upTo: pathIdentifier.length).concat(\"_FIND\"))!\n                account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                    findPath,\n                    target: nft.storagePath\n                )\n                providerCap = account.getCapability\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(findPath)\n            }\n        }\n        \n\n        self.saleItems= account.borrow\u003c\u0026FindMarketAuctionSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()))\n        self.pointer= FindViews.AuthNFTPointer(cap: providerCap, id: id)    \n        self.vaultType= ft.type    \n    }\n\n    pre{\n        // Ben : panic on some unreasonable inputs in trxn \n        minimumBidIncrement \u003e 0.0 :\"Minimum bid increment should be larger than 0.\"\n        (auctionReservePrice - auctionReservePrice) % minimumBidIncrement == 0.0 : \"Acution ReservePrice should be in step of minimum bid increment.\" \n        auctionDuration \u003e 0.0 : \"Auction Duration should be greater than 0.\"\n        auctionExtensionOnLateBid \u003e 0.0 : \"Auction Duration should be greater than 0.\"\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        self.saleItems!.listForAuction(pointer: self.pointer, vaultType: self.vaultType, auctionStartPrice: price, auctionReservePrice: auctionReservePrice, auctionDuration: auctionDuration, auctionExtensionOnLateBid: auctionExtensionOnLateBid, minimumBidIncrement: minimumBidIncrement, auctionValidUntil: auctionValidUntil, saleItemExtraField: {})\n\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "nftAliasOrIdentifier",
                     "id",
                     "ftAliasOrIdentifier",
                     "price",
                     "auctionReservePrice",
                     "auctionDuration",
                     "auctionExtensionOnLateBid",
                     "minimumBidIncrement",
                     "auctionValidUntil"
                  ],
                  "parameters": {
                     "auctionDuration": "UFix64",
                     "auctionExtensionOnLateBid": "UFix64",
                     "auctionReservePrice": "UFix64",
                     "auctionValidUntil": "UFix64?",
                     "ftAliasOrIdentifier": "String",
                     "id": "UInt64",
                     "marketplace": "Address",
                     "minimumBidIncrement": "UFix64",
                     "nftAliasOrIdentifier": "String",
                     "price": "UFix64"
                  }
               }
            },
            "listNFTForSale": {
               "code": "import FindMarket from 0x179b6b1cb6755e31\nimport FindMarketSale from 0x179b6b1cb6755e31\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FindViews from 0x179b6b1cb6755e31\nimport FINDNFTCatalog from 0x179b6b1cb6755e31\nimport FTRegistry from 0x179b6b1cb6755e31\n\ntransaction(marketplace:Address, nftAliasOrIdentifier: String, id: UInt64, ftAliasOrIdentifier: String, directSellPrice:UFix64, validUntil: UFix64?) {\n\n    let saleItems : \u0026FindMarketSale.SaleItemCollection?\n    let pointer : FindViews.AuthNFTPointer\n    let vaultType : Type\n\n    prepare(account: AuthAccount) {\n\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath)\n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n        // Get supported NFT and FT Information from Registries from input alias\n        let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier:nftAliasOrIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftAliasOrIdentifier))\n        let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])!\n        let nft = collection.collectionData\n\n        let ft = FTRegistry.getFTInfo(ftAliasOrIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftAliasOrIdentifier))\n\n        var providerCap=account.getCapability\u003c\u0026{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e(nft.privatePath)\n\n        /* Ben : Question -\u003e Either client will have to provide the path here or agree that we set it up for the user */\n        if !providerCap.check() {\n            let newCap = account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                nft.privatePath,\n                target: nft.storagePath\n            )\n            if newCap == nil {\n                // If linking is not successful, we link it using finds custom link\n                let pathIdentifier = nft.privatePath.toString()\n                let findPath = PrivatePath(identifier: pathIdentifier.slice(from: \"/private/\".length , upTo: pathIdentifier.length).concat(\"_FIND\"))!\n                account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                    findPath,\n                    target: nft.storagePath\n                )\n                providerCap = account.getCapability\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(findPath)\n            }\n        }\n        // Get the salesItemRef from tenant\n        self.saleItems= account.borrow\u003c\u0026FindMarketSale.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketSale.SaleItemCollection\u003e()))\n        self.pointer= FindViews.AuthNFTPointer(cap: providerCap, id: id)\n        self.vaultType= ft.type\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        self.saleItems!.listForSale(pointer: self.pointer, vaultType: self.vaultType, directSellPrice: directSellPrice, validUntil: validUntil, extraField: {})\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "nftAliasOrIdentifier",
                     "id",
                     "ftAliasOrIdentifier",
                     "directSellPrice",
                     "validUntil"
                  ],
                  "parameters": {
                     "directSellPrice": "UFix64",
                     "ftAliasOrIdentifier": "String",
                     "id": "UInt64",
                     "marketplace": "Address",
                     "nftAliasOrIdentifier": "String",
                     "validUntil": "UFix64?"
                  }
               }
            },
            "listNFTForSaleDapper": {
               "code": "import FindMarket from 0x179b6b1cb6755e31\nimport FindMarketSale from 0x179b6b1cb6755e31\nimport FINDNFTCatalog from 0x179b6b1cb6755e31\nimport FTRegistry from 0x179b6b1cb6755e31\nimport FindViews from 0x179b6b1cb6755e31\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FlowUtilityToken from 0x01cf0e2f2f715450\nimport TokenForwarding from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\n\ntransaction(marketplace:Address, nftAliasOrIdentifier: String, id: UInt64, ftAliasOrIdentifier: String, directSellPrice:UFix64, validUntil: UFix64?) {\n    \n    let saleItems : \u0026FindMarketSale.SaleItemCollection?\n    let pointer : FindViews.AuthNFTPointer\n    let vaultType : Type\n    \n    prepare(account: AuthAccount) {\n\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n\n        let tenant = tenantCapability.borrow()!\n\n        //TODO:how do we fix this on testnet/mainnet\n        let dapper=getAccount(FindViews.getDapperAddress())\n\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        // Get supported NFT and FT Information from Registries from input alias\n        let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftAliasOrIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftAliasOrIdentifier)) \n        let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n        let nft = collection.collectionData\n\n        let ft = FTRegistry.getFTInfo(ftAliasOrIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftAliasOrIdentifier))\n\n        let futReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowUtilityTokenReceiver)\n        if ft.type == Type\u003c@FlowUtilityToken.Vault\u003e() \u0026\u0026 !futReceiver.check() {\n            // Create a new Forwarder resource for FUT and store it in the new account's storage\n            let futForwarder \u003c- TokenForwarding.createNewForwarder(recipient: dapper.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowUtilityTokenReceiver))\n            account.save(\u003c-futForwarder, to: /storage/flowUtilityTokenVault)\n            // Publish a Receiver capability for the new account, which is linked to the FUT Forwarder\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowUtilityTokenReceiver,target: /storage/flowUtilityTokenVault)\n        }\n\n\n        let providerCap=account.getCapability\u003c\u0026{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e(nft.privatePath)\n\n        if !providerCap.check() {\n            account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                nft.privatePath,\n                target: nft.storagePath\n            )\n        }\n        // Get the salesItemRef from tenant\n        self.saleItems= account.borrow\u003c\u0026FindMarketSale.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketSale.SaleItemCollection\u003e()))\n        self.pointer= FindViews.AuthNFTPointer(cap: providerCap, id: id)\n        self.vaultType= ft.type\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        self.saleItems!.listForSale(pointer: self.pointer, vaultType: self.vaultType, directSellPrice: directSellPrice, validUntil: validUntil, extraField: {})\n\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "nftAliasOrIdentifier",
                     "id",
                     "ftAliasOrIdentifier",
                     "directSellPrice",
                     "validUntil"
                  ],
                  "parameters": {
                     "directSellPrice": "UFix64",
                     "ftAliasOrIdentifier": "String",
                     "id": "UInt64",
                     "marketplace": "Address",
                     "nftAliasOrIdentifier": "String",
                     "validUntil": "UFix64?"
                  }
               }
            },
            "listNameForAuction": {
               "code": "import FIND from 0x179b6b1cb6755e31\n\ntransaction(name: String, auctionStartPrice: UFix64, auctionReservePrice: UFix64, auctionDuration: UFix64, auctionExtensionOnLateBid: UFix64) {\n    \n    let finLeases : \u0026FIND.LeaseCollection?\n\n    prepare(acct: AuthAccount) {\n        self.finLeases= acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)\n    }\n\n    pre{\n        self.finLeases != nil : \"Cannot borrow reference to find lease collection\"\n    }\n\n    execute{\n        self.finLeases!.listForAuction(name: name, auctionStartPrice: auctionStartPrice, auctionReservePrice: auctionReservePrice, auctionDuration: auctionDuration,  auctionExtensionOnLateBid: auctionExtensionOnLateBid)\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "auctionStartPrice",
                     "auctionReservePrice",
                     "auctionDuration",
                     "auctionExtensionOnLateBid"
                  ],
                  "parameters": {
                     "auctionDuration": "UFix64",
                     "auctionExtensionOnLateBid": "UFix64",
                     "auctionReservePrice": "UFix64",
                     "auctionStartPrice": "UFix64",
                     "name": "String"
                  }
               }
            },
            "listNameForSale": {
               "code": "import FIND from 0x179b6b1cb6755e31\n\ntransaction(name: String, directSellPrice:UFix64) {\n\n    let finLeases : \u0026FIND.LeaseCollection?\n\n    prepare(acct: AuthAccount) {\n        self.finLeases= acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)\n    }\n\n    pre{\n        self.finLeases != nil : \"Cannot borrow reference to find lease collection\"\n    }\n\n    execute{\n        self.finLeases!.listForSale(name: name,  directSellPrice:directSellPrice)\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "directSellPrice"
                  ],
                  "parameters": {
                     "directSellPrice": "UFix64",
                     "name": "String"
                  }
               }
            },
            "moveNameTO": {
               "code": "import Profile from 0x179b6b1cb6755e31\nimport FIND from 0x179b6b1cb6755e31\n\n\ntransaction(name: String, receiver:String) {\n\n\n    let receiverAddress:Address?\n    let sender : \u0026FIND.LeaseCollection\n\n    prepare(acct: AuthAccount) {\n        self.sender= acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath) ?? panic(\"You do not have a profile set up, initialize the user first\")\n        self.receiverAddress=FIND.resolve(receiver)\n    } \n\n    pre{\n        self.receiverAddress != nil : \"The input pass in is not a valid name or address. Input : \".concat(receiver)\n    }\n\n    execute {\n        let receiver=getAccount(self.receiverAddress!)\n        let receiverLease = receiver.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        let receiverProfile = receiver.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\n        if !receiverLease.check() || !receiverProfile.check() {\n            panic(\"Not a valid FIND user\")\n        }\n\n        self.sender.move(name:name, profile:receiverProfile, to: receiverLease)\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "receiver"
                  ],
                  "parameters": {
                     "name": "String",
                     "receiver": "String"
                  }
               }
            },
            "moveNameToDapper": {
               "code": "import Profile from 0x179b6b1cb6755e31\nimport FIND from 0x179b6b1cb6755e31\n\n\ntransaction(name: String, receiver:String) {\n\n\n    let receiverAddress:Address?\n    let sender : \u0026FIND.LeaseCollection\n\n    prepare(acct: AuthAccount) {\n        self.sender= acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath) ?? panic(\"You do not have a profile set up, initialize the user first\")\n        self.receiverAddress=FIND.resolve(receiver)\n    } \n\n    pre{\n        self.receiverAddress != nil : \"The input pass in is not a valid name or address. Input : \".concat(receiver)\n    }\n\n    execute {\n        let receiver=getAccount(self.receiverAddress!)\n        let receiverLease = receiver.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        let receiverProfile = receiver.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\n        if !receiverLease.check() || !receiverProfile.check() {\n            panic(\"Not a valid FIND user\")\n        }\n\n        self.sender.move(name:name, profile:receiverProfile, to: receiverLease)\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "receiver"
                  ],
                  "parameters": {
                     "name": "String",
                     "receiver": "String"
                  }
               }
            },
            "openBl0xPack": {
               "code": "import Bl0x from 0xe03daebed8ca0615\nimport Bl0xPack from 0xe03daebed8ca0615\nimport FungibleToken from 0xee82856bf20e2aa6\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\n\n/// A transaction to open a pack with a given id\n/// @param packId: The id of the pack to open\ntransaction(packId:UInt64) {\n\n    let packs: \u0026Bl0xPack.Collection\n    var receiver: Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e\n\n    prepare(account: AuthAccount) {\n        self.packs=account.borrow\u003c\u0026Bl0xPack.Collection\u003e(from: Bl0xPack.CollectionStoragePath)!\n        self.receiver = account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(Bl0x.CollectionPublicPath)\n        if !self.receiver.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Bl0x.createEmptyCollection(), to: Bl0x.CollectionStoragePath)\n            account.link\u003c\u0026Bl0x.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                Bl0x.CollectionPublicPath,\n                target: Bl0x.CollectionStoragePath\n            )\n            account.link\u003c\u0026Bl0x.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                Bl0x.CollectionPrivatePath,\n                target: Bl0x.CollectionStoragePath\n            )\n\n            self.receiver = account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(Bl0x.CollectionPublicPath)\n        }\n\n    }\n\n    pre {\n        self.receiver.check() : \"The receiver collection for the packs is not set up properly\"\n    }\n    execute {\n        self.packs.open(packId: packId, receiverCap:self.receiver)\n    }\n\n    post {\n        !self.packs.getIDs().contains(packId) : \"The pack is still present in the users collection\"\n    }\n}",
               "spec": {
                  "order": [
                     "packId"
                  ],
                  "parameters": {
                     "packId": "UInt64"
                  }
               }
            },
            "openFindPack": {
               "code": "import FindPack from 0x179b6b1cb6755e31\nimport FINDNFTCatalog from 0x179b6b1cb6755e31\nimport NFTCatalog from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\n\n/// A transaction to open a pack with a given id\n/// @param packId: The id of the pack to open\ntransaction(packId:UInt64) {\n\n    let packs: \u0026FindPack.Collection\n    let receiver: { Type : Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e}\n\n    prepare(account: AuthAccount) {\n        self.packs=account.borrow\u003c\u0026FindPack.Collection\u003e(from: FindPack.CollectionStoragePath)!\n\n        let packData = self.packs.borrowFindPack(id: packId) ?? panic(\"You do not own this pack. ID : \".concat(packId.toString()))\n        let packMetadata = packData.getMetadata()\n        let types = packMetadata.itemTypes\n\n        self.receiver = {}\n\n        // check the account setup for receiving nfts\n        for type in types {\n            let collection = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: type.identifier)\n            if collection == nil || collection!.length == 0 {\n                panic(\"Type : \".concat(type.identifier).concat(\" is not supported in NFTCatalog at the moment\"))\n            }\n            let collectionInfo = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collection!.keys[0])!.collectionData\n\n            let cap = account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(collectionInfo.publicPath)\n            if !cap.check() {\n                let newCollection \u003c- FindPack.createEmptyCollectionFromPackData(packData: packMetadata, type: type)\n                account.save(\u003c- newCollection, to: collectionInfo.storagePath)\n                account.link\u003c\u0026{NonFungibleToken.Receiver, NonFungibleToken.CollectionPublic, MetadataViews.ResolverCollection}\u003e(\n                    collectionInfo.publicPath, target: collectionInfo.storagePath)\n            }\n            self.receiver[type] = cap\n        }\n\n    }\n\n    execute {\n        self.packs.open(packId: packId, receiverCap:self.receiver)\n    }\n\n    post {\n        !self.packs.getIDs().contains(packId) : \"The pack is still present in the users collection\"\n    }\n}",
               "spec": {
                  "order": [
                     "packId"
                  ],
                  "parameters": {
                     "packId": "UInt64"
                  }
               }
            },
            "orderForge": {
               "code": "import FindForge from 0x179b6b1cb6755e31\nimport FIND from 0x179b6b1cb6755e31\nimport MetadataViews from 0xf8d6e0586b0a20c7\n\n\ntransaction(name: String, mintType:String, minterCut: UFix64, collectionDisplay: MetadataViews.NFTCollectionDisplay) {\n\n    let leases : \u0026FIND.LeaseCollection?\n\n    prepare(account: AuthAccount) {\n\n        self.leases= account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)\n\n    }\n\n    pre{\n        self.leases != nil : \"Could not borrow reference to the leases collection\"\n    }\n\n    execute {\n        let lease = self.leases!.borrow(name)\n        var mintCut : UFix64? = minterCut\n        if minterCut == 0.0 {\n            mintCut = nil\n        } \n        FindForge.orderForge(lease: lease, mintType: mintType, minterCut: mintCut, collectionDisplay: collectionDisplay)\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "mintType",
                     "minterCut",
                     "collectionDisplay"
                  ],
                  "parameters": {
                     "collectionDisplay": "MetadataViews.NFTCollectionDisplay",
                     "mintType": "String",
                     "minterCut": "UFix64",
                     "name": "String"
                  }
               }
            },
            "publishFindThought": {
               "code": "import MetadataViews from 0xf8d6e0586b0a20c7\nimport FindThoughts from 0x179b6b1cb6755e31\nimport FINDNFTCatalog from 0x179b6b1cb6755e31\nimport FindViews from 0x179b6b1cb6755e31\nimport FindUtils from 0x179b6b1cb6755e31\n\ntransaction(header: String , body: String , tags: [String], mediaHash: String?, mediaType: String?, quoteNFTOwner: Address?, quoteNFTType: String?, quoteNFTId: UInt64?, quoteCreator: Address?, quoteId: UInt64?) {\n\n    let collection : \u0026FindThoughts.Collection\n\n    prepare(account: AuthAccount) {\n        let thoughtsCap= account.getCapability\u003c\u0026{FindThoughts.CollectionPublic}\u003e(FindThoughts.CollectionPublicPath)\n        if !thoughtsCap.check() {\n            account.save(\u003c- FindThoughts.createEmptyCollection(), to: FindThoughts.CollectionStoragePath)\n            account.link\u003c\u0026FindThoughts.Collection{FindThoughts.CollectionPublic , MetadataViews.ResolverCollection}\u003e(\n                FindThoughts.CollectionPublicPath,\n                target: FindThoughts.CollectionStoragePath\n            )\n        }\n        self.collection=account.borrow\u003c\u0026FindThoughts.Collection\u003e(from: FindThoughts.CollectionStoragePath) ?? panic(\"Cannot borrow thoughts reference from path\")\n    }\n\n    execute {\n\n        var media : MetadataViews.Media? = nil \n        if mediaHash != nil {\n            var file : {MetadataViews.File}? = nil  \n            if FindUtils.hasPrefix(mediaHash!, prefix: \"ipfs://\") {\n                file = MetadataViews.IPFSFile(cid: mediaHash!.slice(from: \"ipfs://\".length , upTo: mediaHash!.length), path: nil) \n            } else {\n                file = MetadataViews.HTTPFile(url: mediaHash!) \n            }\n            media = MetadataViews.Media(file: file!, mediaType: mediaType!)\n        }\n\n        var nftPointer : FindViews.ViewReadPointer? = nil \n        if quoteNFTOwner != nil {\n                let path = FINDNFTCatalog.getCollectionDataForType(nftTypeIdentifier: quoteNFTType!)?.publicPath ?? panic(\"This nft type is not supported by NFT Catalog. Type : \".concat(quoteNFTType!))\n                let cap = getAccount(quoteNFTOwner!).getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(path)\n                nftPointer = FindViews.ViewReadPointer(cap: cap, id: quoteNFTId!)\n        }\n\n        var quote : FindThoughts.ThoughtPointer? = nil \n        if quoteCreator != nil {\n            quote = FindThoughts.ThoughtPointer(creator: quoteCreator!, id: quoteId!)\n        }\n\n        self.collection.publish(header: header, body: body, tags: tags, media: media, nftPointer: nftPointer, quote: quote)\n    }\n}",
               "spec": {
                  "order": [
                     "header",
                     "body",
                     "tags",
                     "mediaHash",
                     "mediaType",
                     "quoteNFTOwner",
                     "quoteNFTType",
                     "quoteNFTId",
                     "quoteCreator",
                     "quoteId"
                  ],
                  "parameters": {
                     "body": "String",
                     "header": "String",
                     "mediaHash": "String?",
                     "mediaType": "String?",
                     "quoteCreator": "Address?",
                     "quoteId": "UInt64?",
                     "quoteNFTId": "UInt64?",
                     "quoteNFTOwner": "Address?",
                     "quoteNFTType": "String?",
                     "tags": "[String]"
                  }
               }
            },
            "reactToFindThoughts": {
               "code": "import MetadataViews from 0xf8d6e0586b0a20c7\nimport FindThoughts from 0x179b6b1cb6755e31\nimport FIND from 0x179b6b1cb6755e31\n\ntransaction(users: [String], ids: [UInt64] , reactions: [String], undoReactionUsers: [String], undoReactionIds: [UInt64]) {\n\n    let collection : \u0026FindThoughts.Collection\n\n    prepare(account: AuthAccount) {\n        let thoughtsCap= account.getCapability\u003c\u0026{FindThoughts.CollectionPublic}\u003e(FindThoughts.CollectionPublicPath)\n        if !thoughtsCap.check() {\n            account.save(\u003c- FindThoughts.createEmptyCollection(), to: FindThoughts.CollectionStoragePath)\n            account.link\u003c\u0026FindThoughts.Collection{FindThoughts.CollectionPublic , MetadataViews.ResolverCollection}\u003e(\n                FindThoughts.CollectionPublicPath,\n                target: FindThoughts.CollectionStoragePath\n            )\n        }\n        self.collection=account.borrow\u003c\u0026FindThoughts.Collection\u003e(from: FindThoughts.CollectionStoragePath) ?? panic(\"Cannot borrow thoughts reference from path\")\n    }\n\n    execute {\n        for i, user in users {\n            let address = FIND.resolve(user) ?? panic(\"Cannot resolve user : \".concat(user))\n            self.collection.react(user: address, id: ids[i], reaction: reactions[i])\n        }\n\n        for i, user in undoReactionUsers {\n            let address = FIND.resolve(user) ?? panic(\"Cannot resolve user : \".concat(user))\n            self.collection.react(user: address, id: undoReactionIds[i], reaction: nil)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "users",
                     "ids",
                     "reactions",
                     "undoReactionUsers",
                     "undoReactionIds"
                  ],
                  "parameters": {
                     "ids": "[UInt64]",
                     "reactions": "[String]",
                     "undoReactionIds": "[UInt64]",
                     "undoReactionUsers": "[String]",
                     "users": "[String]"
                  }
               }
            },
            "redeemAllLostAndFoundNFTs": {
               "code": "import FindLostAndFoundWrapper from 0x179b6b1cb6755e31\nimport LostAndFound from 0xf8d6e0586b0a20c7\nimport FINDNFTCatalog from 0x179b6b1cb6755e31\nimport NFTCatalog from 0xf8d6e0586b0a20c7\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FIND from 0x179b6b1cb6755e31\n\n//IMPORT\n\ntransaction() {\n\n    let ids : {String : [UInt64]}\n    let nftInfos : {String : NFTCatalog.NFTCollectionData}\n    let receiverAddress : Address\n\n    prepare(account: AuthAccount){\n\n        //LINK\n\n\n        self.nftInfos = {}\n        self.ids = FindLostAndFoundWrapper.getTicketIDs(user: account.address, specificType: Type\u003c@NonFungibleToken.NFT\u003e())\n\n        for type in self.ids.keys{ \n            if self.nftInfos[type] == nil {\n                let collections = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: type) ?? panic(\"NFT type is not supported at the moment. Type : \".concat(type))\n                self.nftInfos[type] = FINDNFTCatalog.getCatalogEntry(collectionIdentifier: collections.keys[0])!.collectionData\n            }\n        }\n\n        self.receiverAddress = account.address\n    }\n\n    execute{\n        for type in self.ids.keys{ \n            let path = self.nftInfos[type]!.publicPath\n            for id in self.ids[type]! {\n                FindLostAndFoundWrapper.redeemNFT(type: CompositeType(type)!, ticketID: id, receiverAddress: self.receiverAddress, collectionPublicPath: path)\n            }\n        }\n    }\n}",
               "spec": {
                  "order": [],
                  "parameters": {}
               }
            },
            "redeemAllLostAndFoundNFTsOnBehalf": {
               "code": "import FindLostAndFoundWrapper from 0x179b6b1cb6755e31\nimport LostAndFound from 0xf8d6e0586b0a20c7\nimport FINDNFTCatalog from 0x179b6b1cb6755e31\nimport NFTCatalog from 0xf8d6e0586b0a20c7\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FIND from 0x179b6b1cb6755e31\n\n//IMPORT\n\ntransaction(receiverAddress: Address) {\n\n    let ids : {String : [UInt64]}\n    let nftInfos : {String : NFTCatalog.NFTCollectionData}\n    let receiverAddress : Address\n\n    prepare(account: AuthAccount){\n        self.receiverAddress = receiverAddress\n\n        self.nftInfos = {}\n        self.ids = FindLostAndFoundWrapper.getTicketIDs(user: receiverAddress, specificType: Type\u003c@NonFungibleToken.NFT\u003e())\n\n        for type in self.ids.keys{ \n            if self.nftInfos[type] == nil {\n                let collections = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: type) ?? panic(\"NFT type is not supported at the moment. Type : \".concat(type))\n                self.nftInfos[type] = FINDNFTCatalog.getCatalogEntry(collectionIdentifier: collections.keys[0])!.collectionData\n            }\n        }\n\n    }\n\n    execute{\n        for type in self.ids.keys{ \n            let path = self.nftInfos[type]!.publicPath\n            for id in self.ids[type]! {\n                FindLostAndFoundWrapper.redeemNFT(type: CompositeType(type)!, ticketID: id, receiverAddress: self.receiverAddress, collectionPublicPath: path)\n            }\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "receiverAddress"
                  ],
                  "parameters": {
                     "receiverAddress": "Address"
                  }
               }
            },
            "redeemLostAndFoundNFTs": {
               "code": "import FindLostAndFoundWrapper from 0x179b6b1cb6755e31\nimport LostAndFound from 0xf8d6e0586b0a20c7\nimport FINDNFTCatalog from 0x179b6b1cb6755e31\nimport NFTCatalog from 0xf8d6e0586b0a20c7\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FindViews from 0x179b6b1cb6755e31\nimport FIND from 0x179b6b1cb6755e31\n\n//IMPORT\n\ntransaction(ids: {String : [UInt64]}) {\n\n    let nftInfos : {String : NFTCatalog.NFTCollectionData}\n    let receiverAddress : Address\n\n    prepare(account: AuthAccount){\n\n        //LINK\n        self.nftInfos = {}\n\n        for type in ids.keys{ \n            if self.nftInfos[type] == nil {\n                let collections = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: type) ?? panic(\"NFT type is not supported at the moment. Type : \".concat(type))\n                self.nftInfos[type] = FINDNFTCatalog.getCatalogEntry(collectionIdentifier: collections.keys[0])!.collectionData\n            }\n        }\n\n        self.receiverAddress = account.address\n    }\n\n    execute{\n        for type in ids.keys{ \n            let path = self.nftInfos[type]!.publicPath\n            for id in ids[type]! {\n                FindLostAndFoundWrapper.redeemNFT(type: CompositeType(type)!, ticketID: id, receiverAddress:self.receiverAddress, collectionPublicPath: path)\n            }\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "ids"
                  ],
                  "parameters": {
                     "ids": "{String: [UInt64]}"
                  }
               }
            },
            "redeemLostAndFoundNFTsOnBehalf": {
               "code": "import FindLostAndFoundWrapper from 0x179b6b1cb6755e31\nimport LostAndFound from 0xf8d6e0586b0a20c7\nimport FINDNFTCatalog from 0x179b6b1cb6755e31\nimport NFTCatalog from 0xf8d6e0586b0a20c7\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FindViews from 0x179b6b1cb6755e31\nimport FIND from 0x179b6b1cb6755e31\nimport Bl0xPack from 0xe03daebed8ca0615\n\n//IMPORT\n\ntransaction(receiverAddress: Address, ids: {String : [UInt64]}) {\n\n    let nftInfos : {String : NFTCatalog.NFTCollectionData}\n    let receiverAddress : Address\n\n    prepare(account: AuthAccount){\n\n        self.receiverAddress = receiverAddress\n\n        self.nftInfos = {}\n\n        for type in ids.keys{ \n            if self.nftInfos[type] == nil {\n                let collections = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: type) ?? panic(\"NFT type is not supported at the moment. Type : \".concat(type))\n                self.nftInfos[type] = FINDNFTCatalog.getCatalogEntry(collectionIdentifier: collections.keys[0])!.collectionData\n            }\n        }\n\n    }\n\n    execute{\n        for type in ids.keys{ \n            let path = self.nftInfos[type]!.publicPath\n            for id in ids[type]! {\n                FindLostAndFoundWrapper.redeemNFT(type: CompositeType(type)!, ticketID: id, receiverAddress:self.receiverAddress, collectionPublicPath: path)\n            }\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "receiverAddress",
                     "ids"
                  ],
                  "parameters": {
                     "ids": "{String: [UInt64]}",
                     "receiverAddress": "Address"
                  }
               }
            },
            "register": {
               "code": "import FUSD from 0xf8d6e0586b0a20c7\nimport FIND from 0x179b6b1cb6755e31\n\ntransaction(name: String, amount: UFix64) {\n\n    let vaultRef : \u0026FUSD.Vault?\n    let leases : \u0026FIND.LeaseCollection?\n    let price : UFix64\n\n    prepare(account: AuthAccount) {\n\n        self.price=FIND.calculateCost(name)\n        log(\"The cost for registering this name is \".concat(self.price.toString()))\n        self.vaultRef = account.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault)\n        self.leases=account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from: FIND.LeaseStoragePath)\n    }\n\n    pre{\n        self.vaultRef != nil : \"Could not borrow reference to the fusdVault!\"\n        self.leases != nil : \"Could not borrow reference to find lease collection\"\n        self.price == amount : \"Calculated cost : \".concat(self.price.toString()).concat(\" does not match expected cost : \").concat(amount.toString())\n    }\n\n    execute{\n        let payVault \u003c- self.vaultRef!.withdraw(amount: self.price) as! @FUSD.Vault\n        self.leases!.register(name: name, vault: \u003c- payVault)\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "name": "String"
                  }
               }
            },
            "registerDapper": {
               "code": "import DapperUtilityCoin from 0x01cf0e2f2f715450\nimport FIND from 0x179b6b1cb6755e31\n\ntransaction(merchAccount: Address, name: String, amount: UFix64) {\n\n    let finLeases : \u0026FIND.LeaseCollection\n    let mainDapperUtilityCoinVault: \u0026DapperUtilityCoin.Vault\n    let balanceBeforeTransfer: UFix64\n    let price : UFix64\n\n    prepare(dapper: AuthAccount, account: AuthAccount) {\n\n        self.price=FIND.calculateCost(name)\n        log(\"The cost for registering this name is \".concat(self.price.toString()))\n        self.mainDapperUtilityCoinVault = dapper.borrow\u003c\u0026DapperUtilityCoin.Vault\u003e(from: /storage/dapperUtilityCoinVault) ?? panic(\"Cannot borrow DapperUtilityCoin vault from account storage\".concat(dapper.address.toString()))\n        self.balanceBeforeTransfer = self.mainDapperUtilityCoinVault.balance\n        self.finLeases= account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath) ?? panic(\"Could not borrow reference to find lease collection\")\n    }\n\n    pre{\n        self.price == amount : \"Calculated cost : \".concat(self.price.toString()).concat(\" does not match expected cost : \").concat(amount.toString())\n    }\n\n    execute{\n        let payVault \u003c- self.mainDapperUtilityCoinVault.withdraw(amount: self.price) as! @DapperUtilityCoin.Vault\n        self.finLeases.registerDapper(merchAccount: merchAccount, name: name, vault: \u003c- payVault)\n    }\n\n    post {\n        self.mainDapperUtilityCoinVault.balance == self.balanceBeforeTransfer: \"DapperUtilityCoin leakage\"\n    }\n}",
               "spec": {
                  "order": [
                     "merchAccount",
                     "name",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "merchAccount": "Address",
                     "name": "String"
                  }
               }
            },
            "registerGift": {
               "code": "import FUSD from 0xf8d6e0586b0a20c7\nimport Profile from 0x179b6b1cb6755e31\nimport FIND from 0x179b6b1cb6755e31\n\ntransaction(name: String, amount: UFix64, recipient: String) {\n\n    let price : UFix64 \n    let vaultRef : \u0026FUSD.Vault? \n    let receiverLease : Capability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e\n    let receiverProfile : Capability\u003c\u0026{Profile.Public}\u003e\n    let leases : \u0026FIND.LeaseCollection?\n\n    prepare(acct: AuthAccount) {\n\n        let resolveAddress = FIND.resolve(recipient)\n        if resolveAddress == nil {panic(\"The input pass in is not a valid name or address. Input : \".concat(recipient))}\n        let address = resolveAddress!\n\n        self.price=FIND.calculateCost(name)\n        log(\"The cost for registering this name is \".concat(self.price.toString()))\n\n        self.vaultRef = acct.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault)\n\n        self.leases=acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from: FIND.LeaseStoragePath)\n\n        let receiver = getAccount(address)\n        self.receiverLease = receiver.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        self.receiverProfile = receiver.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\n    }\n\n    pre{\n        self.price == amount : \"Calculated cost : \".concat(self.price.toString()).concat(\" does not match expected cost\").concat(amount.toString())\n        self.vaultRef != nil : \"Cannot borrow reference to fusd Vault!\"\n        self.receiverLease.check() : \"Lease capability is invalid\"\n        self.receiverProfile.check() : \"Profile capability is invalid\"\n        self.leases != nil : \"Cannot borrow refernce to find lease collection\"\n    }\n\n    execute{\n        let payVault \u003c- self.vaultRef!.withdraw(amount: self.price) as! @FUSD.Vault\n        self.leases!.register(name: name, vault: \u003c- payVault)\n        self.leases!.move(name: name, profile: self.receiverProfile, to: self.receiverLease)\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "amount",
                     "recipient"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "name": "String",
                     "recipient": "String"
                  }
               }
            },
            "rejectNameDirectOffer": {
               "code": "import FIND from 0x179b6b1cb6755e31\n\ntransaction(names: [String]) {\n\n    let finLeases : \u0026FIND.LeaseCollection? \n\n    prepare(account: AuthAccount) {\n        self.finLeases= account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)\n    }\n\n    pre{\n        self.finLeases != nil : \"Cannot borrow reference to find lease collection\"\n    }\n\n    execute{\n        for name in names {\n            self.finLeases!.cancel(name)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "names"
                  ],
                  "parameters": {
                     "names": "[String]"
                  }
               }
            },
            "relistMarketListings": {
               "code": "import FindMarket from 0x179b6b1cb6755e31\nimport FindMarketDirectOfferEscrow from 0x179b6b1cb6755e31\nimport FindMarketAuctionEscrow from 0x179b6b1cb6755e31\nimport FindMarketAuctionSoft from 0x179b6b1cb6755e31\nimport FindMarketDirectOfferSoft from 0x179b6b1cb6755e31\nimport FindMarketSale from 0x179b6b1cb6755e31\n\ntransaction(marketplace:Address, ids: {String : [UInt64]}) {\n    prepare(account: AuthAccount) {\n\n        let tenant=FindMarket.getTenant(marketplace)\n\n        var saleType = Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        if let ids = ids[FindMarket.getMarketOptionFromType(saleType)] {\n            let saleItems= account.borrow\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection\u003e(from: tenant.getStoragePath(saleType))!\n            for id in ids {\n                saleItems.relist(id)\n            }\n        }\n\n        saleType = Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        if let ids = ids[FindMarket.getMarketOptionFromType(saleType)] {\n            let saleItems= account.borrow\u003c\u0026FindMarketAuctionSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(saleType))!\n            for id in ids {\n                saleItems.relist(id)\n            }\n        }\n\n        saleType = Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        if let ids = ids[FindMarket.getMarketOptionFromType(saleType)] {\n            let saleItems= account.borrow\u003c\u0026FindMarketSale.SaleItemCollection\u003e(from: tenant.getStoragePath(saleType))!\n            for id in ids {\n                saleItems.relist(id)\n            }\n        }\n\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "ids"
                  ],
                  "parameters": {
                     "ids": "{String: [UInt64]}",
                     "marketplace": "Address"
                  }
               }
            },
            "removeCurratedCollection": {
               "code": "transaction(name: String) {\n    prepare(account: AuthAccount) {\n\n        let path=/storage/FindCuratedCollections\n        let publicPath=/public/FindCuratedCollections\n\n        var collections : {String: [String]} = {}\n        if account.borrow\u003c\u0026{String: [String]}\u003e(from:path) != nil {\n             collections=account.load\u003c{String: [String]}\u003e(from:path)!\n        }\n        collections.remove(key: name)\n        account.save(collections, to: path)\n        let link = account.getCapability\u003c\u0026{String: [String]}\u003e(publicPath)\n        if !link.check() {\n            account.link\u003c\u0026{String: [String]}\u003e( publicPath, target: path)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "removeMarketOption": {
               "code": "import FindMarket from 0x179b6b1cb6755e31\n\ntransaction(saleItemName: String){\n    \n    prepare(account: AuthAccount){\n        let path = FindMarket.TenantClientStoragePath\n        let tenantRef = account.borrow\u003c\u0026FindMarket.TenantClient\u003e(from: path) ?? panic(\"Cannot borrow Reference.\")\n\n        tenantRef.removeMarketOption(name: saleItemName)\n    }\n}",
               "spec": {
                  "order": [
                     "saleItemName"
                  ],
                  "parameters": {
                     "saleItemName": "String"
                  }
               }
            },
            "removeRelatedAccount": {
               "code": "import FindRelatedAccounts from 0x179b6b1cb6755e31\n\ntransaction(name: String, network: String, address: String) {\n\n    var relatedAccounts : \u0026FindRelatedAccounts.Accounts?\n\n    prepare(account: AuthAccount) {\n\n        self.relatedAccounts= account.borrow\u003c\u0026FindRelatedAccounts.Accounts\u003e(from:FindRelatedAccounts.storagePath)\n        if self.relatedAccounts == nil {\n            let relatedAccounts \u003c- FindRelatedAccounts.createEmptyAccounts()\n            account.save(\u003c- relatedAccounts, to: FindRelatedAccounts.storagePath)\n            account.link\u003c\u0026FindRelatedAccounts.Accounts{FindRelatedAccounts.Public}\u003e(FindRelatedAccounts.publicPath, target: FindRelatedAccounts.storagePath)\n            self.relatedAccounts = account.borrow\u003c\u0026FindRelatedAccounts.Accounts\u003e(from:FindRelatedAccounts.storagePath)\n        }\n\n        let cap = account.getCapability\u003c\u0026FindRelatedAccounts.Accounts{FindRelatedAccounts.Public}\u003e(FindRelatedAccounts.publicPath)\n        if !cap.check() {\n            account.unlink(FindRelatedAccounts.publicPath)\n            account.link\u003c\u0026FindRelatedAccounts.Accounts{FindRelatedAccounts.Public}\u003e(FindRelatedAccounts.publicPath, target: FindRelatedAccounts.storagePath)\n        }\n    }\n\n    execute {\n        self.relatedAccounts!.removeRelatedAccount(name:name, network:network, address: address)\n    }\n\n}",
               "spec": {
                  "order": [
                     "name",
                     "network",
                     "address"
                  ],
                  "parameters": {
                     "address": "String",
                     "name": "String",
                     "network": "String"
                  }
               }
            },
            "removeRelatedAccountDapper": {
               "code": "import FindRelatedAccounts from 0x179b6b1cb6755e31\n\ntransaction(name: String, network: String, address: String){\n\n    var relatedAccounts : \u0026FindRelatedAccounts.Accounts?\n\n    prepare(account: AuthAccount) {\n\n        self.relatedAccounts= account.borrow\u003c\u0026FindRelatedAccounts.Accounts\u003e(from:FindRelatedAccounts.storagePath)\n        if self.relatedAccounts == nil {\n            let relatedAccounts \u003c- FindRelatedAccounts.createEmptyAccounts()\n            account.save(\u003c- relatedAccounts, to: FindRelatedAccounts.storagePath)\n            account.link\u003c\u0026FindRelatedAccounts.Accounts{FindRelatedAccounts.Public}\u003e(FindRelatedAccounts.publicPath, target: FindRelatedAccounts.storagePath)\n            self.relatedAccounts= account.borrow\u003c\u0026FindRelatedAccounts.Accounts\u003e(from:FindRelatedAccounts.storagePath)\n        }\n\n        let cap = account.getCapability\u003c\u0026FindRelatedAccounts.Accounts{FindRelatedAccounts.Public}\u003e(FindRelatedAccounts.publicPath)\n        if !cap.check() {\n            account.unlink(FindRelatedAccounts.publicPath)\n            account.link\u003c\u0026FindRelatedAccounts.Accounts{FindRelatedAccounts.Public}\u003e(FindRelatedAccounts.publicPath, target: FindRelatedAccounts.storagePath)\n        }\n\n    }\n\n    execute{\n        self.relatedAccounts!.removeRelatedAccount(name: name, network: network, address: address)\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "network",
                     "address"
                  ],
                  "parameters": {
                     "address": "String",
                     "name": "String",
                     "network": "String"
                  }
               }
            },
            "removeTenantRule": {
               "code": "import FindMarket from 0x179b6b1cb6755e31\n\ntransaction(optionName: String, tenantRuleName: String){\n    prepare(account: AuthAccount){\n        let path = FindMarket.TenantClientStoragePath\n        let tenantRef = account.borrow\u003c\u0026FindMarket.TenantClient\u003e(from: path) ?? panic(\"Cannot borrow Reference.\")\n\n        tenantRef.removeTenantRule(optionName: optionName, tenantRuleName: tenantRuleName)\n    }\n}",
               "spec": {
                  "order": [
                     "optionName",
                     "tenantRuleName"
                  ],
                  "parameters": {
                     "optionName": "String",
                     "tenantRuleName": "String"
                  }
               }
            },
            "remove_find_market_1": {
               "code": "import FindMarketAdmin from 0x179b6b1cb6755e31\n\n//signed by admin to link tenantClient to a new tenant\ntransaction(tenant: Address) {\n    //versus account\n    prepare(account: AuthAccount) {\n        let adminClient=account.borrow\u003c\u0026FindMarketAdmin.AdminProxy\u003e(from: FindMarketAdmin.AdminProxyStoragePath)!\n\n        adminClient.removeFindMarketTenant(tenant: tenant)\n    }\n}",
               "spec": {
                  "order": [
                     "tenant"
                  ],
                  "parameters": {
                     "tenant": "Address"
                  }
               }
            },
            "remove_find_market_2": {
               "code": "import FindMarket from 0x179b6b1cb6755e31\n\n\n//Transaction that is signed by find to create a find market tenant for find\ntransaction() {\n    prepare(account: AuthAccount) {\n        //in finds case the\n        destroy account.load\u003c@FindMarket.TenantClient\u003e(from:FindMarket.TenantClientStoragePath)\n        account.unlink(FindMarket.TenantClientPublicPath)\n    }\n}",
               "spec": {
                  "order": [],
                  "parameters": {}
               }
            },
            "renewName": {
               "code": "import FUSD from 0xf8d6e0586b0a20c7\nimport FIND from 0x179b6b1cb6755e31\n\ntransaction(name: String, amount: UFix64) {\n\n    let price : UFix64\n    let vaultRef : \u0026FUSD.Vault? \n    let finLeases : \u0026FIND.LeaseCollection? \n\n    prepare(acct: AuthAccount) {\n        self.price=FIND.calculateCost(name)\n        self.vaultRef = acct.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault)\n        self.finLeases= acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)\n    }\n\n    pre{\n        self.price == amount : \"expected renew cost : \".concat(self.price.toString()).concat(\" is not the same as calculated renew cost : \").concat(amount.toString())\n        self.vaultRef != nil : \"Could not borrow reference to the fusdVault!\"\n        self.finLeases != nil : \"Could not borrow reference to find lease collection\"\n    }\n\n    execute{\n        let payVault \u003c- self.vaultRef!.withdraw(amount: self.price) as! @FUSD.Vault\n        let finToken= self.finLeases!.borrow(name)\n        finToken.extendLease(\u003c- payVault)\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "name": "String"
                  }
               }
            },
            "renewNameDapper": {
               "code": "import DapperUtilityCoin from 0x01cf0e2f2f715450\nimport FIND from 0x179b6b1cb6755e31\n\ntransaction(merchAccount: Address, name: String, amount: UFix64) {\n\n    let price : UFix64\n    let finLeases : \u0026FIND.LeaseCollection\n    let mainDapperUtilityCoinVault: \u0026DapperUtilityCoin.Vault\n    let balanceBeforeTransfer: UFix64\n\n    prepare(dapper: AuthAccount, acct: AuthAccount) {\n        self.price=FIND.calculateCost(name)\n        self.mainDapperUtilityCoinVault = dapper.borrow\u003c\u0026DapperUtilityCoin.Vault\u003e(from: /storage/dapperUtilityCoinVault) ?? panic(\"Cannot borrow DapperUtilityCoin vault from account storage\".concat(dapper.address.toString()))\n        self.balanceBeforeTransfer = self.mainDapperUtilityCoinVault.balance\n        self.finLeases= acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath) ?? panic(\"Could not borrow reference to find lease collection\")\n    }\n\n    pre{\n        self.price == amount : \"expected renew cost : \".concat(self.price.toString()).concat(\" is not the same as calculated renew cost : \").concat(amount.toString())\n    }\n\n    execute{\n        let payVault \u003c- self.mainDapperUtilityCoinVault.withdraw(amount: self.price) as! @DapperUtilityCoin.Vault\n        let finToken= self.finLeases.borrow(name)\n        finToken.extendLeaseDapper(merchAccount: merchAccount, vault: \u003c- payVault)\n    }\n\n    post {\n        self.mainDapperUtilityCoinVault.balance == self.balanceBeforeTransfer: \"DapperUtilityCoin leakage\"\n    }\n}",
               "spec": {
                  "order": [
                     "merchAccount",
                     "name",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "merchAccount": "Address",
                     "name": "String"
                  }
               }
            },
            "retractOfferLeaseMarketDirectOfferSoft": {
               "code": "import FindMarket from 0x179b6b1cb6755e31\nimport FindLeaseMarketDirectOfferSoft from 0x179b6b1cb6755e31\n\ntransaction(leaseName: String) {\n    let bidsReference: \u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection?\n\n    prepare(account: AuthAccount) {\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e())\n        self.bidsReference= account.borrow\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(from: storagePath)\n    }\n\n    pre{\n        self.bidsReference != nil : \"Bid resource does not exist\"\n    }\n\n    execute {\n        self.bidsReference!.cancelBid(leaseName)\n    }\n}",
               "spec": {
                  "order": [
                     "leaseName"
                  ],
                  "parameters": {
                     "leaseName": "String"
                  }
               }
            },
            "retractOfferMarketDirectOfferEscrowed": {
               "code": "import FindMarket from 0x179b6b1cb6755e31\nimport FindMarketDirectOfferEscrow from 0x179b6b1cb6755e31\n\ntransaction(marketplace:Address, id: UInt64) {\n    let bidsReference: \u0026FindMarketDirectOfferEscrow.MarketBidCollection? \n\n    prepare(account: AuthAccount) {\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e())\n        self.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection\u003e(from: storagePath) \n    }\n\n    pre{\n        self.bidsReference != nil : \"This account does not have a bid collection\"\n    }\n\n    execute {\n        self.bidsReference!.cancelBid(id)\n    }\n\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "retractOfferMarketDirectOfferSoft": {
               "code": "import FindMarket from 0x179b6b1cb6755e31\nimport FindMarketDirectOfferSoft from 0x179b6b1cb6755e31\n\ntransaction(marketplace:Address, id: UInt64) {\n    let bidsReference: \u0026FindMarketDirectOfferSoft.MarketBidCollection?\n\n    prepare(account: AuthAccount) {\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n        self.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection\u003e(from: storagePath) \n    }\n\n    pre{\n        self.bidsReference != nil : \"Bid resource does not exist\"\n    }\n\n    execute {\n        self.bidsReference!.cancelBid(id)\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "sendCharity": {
               "code": "import NonFungibleToken from 0xf8d6e0586b0a20c7\nimport CharityNFT from 0x179b6b1cb6755e31\n\n//mint an art and add it to a users collection\ntransaction(\n    id: UInt64,\n    recipient: Address\n) {\n    let receiverCap: Capability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e\n    let charityCollection: \u0026NonFungibleToken.Collection\n\n    prepare(account: AuthAccount) {\n        self.charityCollection =account.borrow\u003c\u0026NonFungibleToken.Collection\u003e(from: CharityNFT.CollectionStoragePath)!\n        self.receiverCap= getAccount(recipient).getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath)\n    }\n\n    pre{\n        self.receiverCap.check() : \"Receiver doesn't have receiving vault set up properly.\"\n    }\n\n    execute {\n        let nft \u003c- self.charityCollection.withdraw(withdrawID: id)\n        self.receiverCap.borrow()!.deposit(token: \u003c- nft)\n    }\n}",
               "spec": {
                  "order": [
                     "id",
                     "recipient"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "recipient": "Address"
                  }
               }
            },
            "sendDandy": {
               "code": "import FIND from 0x179b6b1cb6755e31\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport Dandy from 0x179b6b1cb6755e31\n\ntransaction(user: String, id: UInt64) {\n\n    let address : Address\n    let cap : Capability\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic}\u003e\n    let senderRef : \u0026Dandy.Collection\n\n    prepare(account: AuthAccount) {\n        self.address = FIND.resolve(user) ?? panic(\"Cannot find user with this name / address\")\n        self.cap = getAccount(self.address).getCapability\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n\n        self.senderRef = account.borrow\u003c\u0026Dandy.Collection\u003e(from: Dandy.CollectionStoragePath) ?? panic(\"Cannot borrow reference to sender Collection.\")\n    }\n\n    pre{\n        self.cap.check() : \"Cannot borrow reference to receiver Collection. Receiver account : \".concat(self.address.toString())\n        self.senderRef != nil : \"Cannot borrow reference to sender Collection.\"\n    }\n\n    execute{\n        self.cap.borrow()!.deposit(token: \u003c- self.senderRef!.withdraw(withdrawID: id))\n    }\n}",
               "spec": {
                  "order": [
                     "user",
                     "id"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "user": "String"
                  }
               }
            },
            "sendExampleNFT": {
               "code": "import FIND from 0x179b6b1cb6755e31\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport ExampleNFT from 0x179b6b1cb6755e31\n\ntransaction(user: String, id: UInt64) {\n    let address : Address\n    let cap : Capability\u003c\u0026ExampleNFT.Collection{NonFungibleToken.CollectionPublic}\u003e\n    let senderRef : \u0026ExampleNFT.Collection\n\n    prepare(account: AuthAccount) {\n        self.address = FIND.resolve(user) ?? panic(\"Cannot find user with this name / address\")\n        self.cap = getAccount(self.address).getCapability\u003c\u0026ExampleNFT.Collection{NonFungibleToken.CollectionPublic}\u003e(ExampleNFT.CollectionPublicPath)\n\n        self.senderRef = account.borrow\u003c\u0026ExampleNFT.Collection\u003e(from: ExampleNFT.CollectionStoragePath) ?? panic(\"Cannot borrow reference to sender Collection.\")\n    }\n\n    pre{\n        self.cap.check() : \"Cannot borrow reference to receiver Collection. Receiver account : \".concat(self.address.toString())\n        self.senderRef != nil : \"Cannot borrow reference to sender Collection.\"\n    }\n\n    execute{\n        self.cap.borrow()!.deposit(token: \u003c- self.senderRef!.withdraw(withdrawID: id))\n    }\n}",
               "spec": {
                  "order": [
                     "user",
                     "id"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "user": "String"
                  }
               }
            },
            "sendFT": {
               "code": "import FungibleToken from 0xee82856bf20e2aa6\nimport Sender from 0x179b6b1cb6755e31\nimport FIND from 0x179b6b1cb6755e31\nimport FTRegistry from 0x179b6b1cb6755e31\n\n\ntransaction(name: String, amount: UFix64, ftAliasOrIdentifier: String, tag: String, message:String) {\n\n    var token : \u0026Sender.Token\n    let walletReference : \u0026FungibleToken.Vault? \n\n    prepare(account: AuthAccount) {\n\n        let ft = FTRegistry.getFTInfo(ftAliasOrIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftAliasOrIdentifier))\n        self.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath)\n\n        if account.borrow\u003c\u0026Sender.Token\u003e(from: Sender.storagePath) == nil {\n            account.save(\u003c- Sender.create(), to: Sender.storagePath)\n        }\n\n        self.token =account.borrow\u003c\u0026Sender.Token\u003e(from: Sender.storagePath)!\n    }\n\n    pre{\n        self.walletReference != nil : \"No suitable wallet linked for this account\"\n    }\n\n    execute{\n        let vault \u003c- self.walletReference!.withdraw(amount: amount)\n        FIND.depositWithTagAndMessage(to: name, message: message, tag: tag, vault: \u003c- vault, from: self.token)\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "amount",
                     "ftAliasOrIdentifier",
                     "tag",
                     "message"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "ftAliasOrIdentifier": "String",
                     "message": "String",
                     "name": "String",
                     "tag": "String"
                  }
               }
            },
            "sendFTWithTag": {
               "code": "import NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FUSD from 0xf8d6e0586b0a20c7\nimport Profile from 0x179b6b1cb6755e31\nimport Sender from 0x179b6b1cb6755e31\nimport FIND from 0x179b6b1cb6755e31\nimport CharityNFT from 0x179b6b1cb6755e31\n\n\ntransaction(name: String, amount: UFix64, type: String, tag:String) {\n\n    prepare(account: AuthAccount) {\n\n        let stdCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath)\n        if !stdCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- CharityNFT.createEmptyCollection(), to: CharityNFT.CollectionStoragePath)\n            account.link\u003c\u0026{NonFungibleToken.CollectionPublic, MetadataViews.ResolverCollection}\u003e(CharityNFT.CollectionPublicPath, target: CharityNFT.CollectionStoragePath)\n        }\n\n        let charityCap = account.getCapability\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection)\n        if !charityCap.check() {\n            account.link\u003c\u0026{CharityNFT.CollectionPublic, MetadataViews.ResolverCollection}\u003e(/public/findCharityNFTCollection, target: CharityNFT.CollectionStoragePath)\n        }\n\n      let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n        if !fusdReceiver.check() {\n            let fusd \u003c- FUSD.createEmptyVault()\n            account.save(\u003c- fusd, to: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profileName = account.address.toString()\n\n            let profile \u003c-Profile.createUser(name:profileName, createdAt: \"find\")\n\n            let fusdWallet=Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), names: [\"fusd\", \"stablecoin\"])\n\n            profile.addWallet(fusdWallet)\n\n            let flowWallet=Profile.Wallet(\n                name:\"Flow\", \n                receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver),\n                balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance),\n                accept: Type\u003c@FlowToken.Vault\u003e(),\n                names: [\"flow\"]\n            )\n    \n            profile.addWallet(flowWallet)\n            profile.addCollection(Profile.ResourceCollection(\"FINDLeases\",leaseCollection, Type\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(), [\"find\", \"leases\"]))\n            profile.addCollection(Profile.ResourceCollection(\"FINDBids\", bidCollection, Type\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(), [\"find\", \"bids\"]))\n\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n        }\n\n        if account.borrow\u003c\u0026Sender.Token\u003e(from: Sender.storagePath) == nil {\n            account.save(\u003c- Sender.create(), to: Sender.storagePath)\n        }\n\n        let token =account.borrow\u003c\u0026Sender.Token\u003e(from: Sender.storagePath)!\n\n\n        if type == \"fusd\" {\n            let vaultRef = account.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault) ?? panic(\"Could not borrow reference to the fusdVault!\")\n            let vault \u003c- vaultRef.withdraw(amount: amount)\n            FIND.depositWithTagAndMessage(to: name, message: \"\", tag: tag, vault: \u003c- vault, from: token)\n            return \n        }\n\n        let vaultRef = account.borrow\u003c\u0026FlowToken.Vault\u003e(from: /storage/flowTokenVault) ?? panic(\"Could not borrow reference to the fusdVault!\")\n        let vault \u003c- vaultRef.withdraw(amount: amount)\n        FIND.depositWithTagAndMessage(to: name, message: \"\", tag: tag, vault: \u003c- vault, from: token)\n    }\n\n}",
               "spec": {
                  "order": [
                     "name",
                     "amount",
                     "type",
                     "tag"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "name": "String",
                     "tag": "String",
                     "type": "String"
                  }
               }
            },
            "sendFindPacks": {
               "code": "import FindPack from 0x179b6b1cb6755e31\nimport FIND from 0x179b6b1cb6755e31\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport FindAirdropper from 0x179b6b1cb6755e31\nimport Admin from 0x179b6b1cb6755e31\n\ntransaction(packInfo: FindPack.AirdropInfo) {\n\n    prepare(account: AuthAccount) {\n\n        let pathIdentifier = \"FindPack_\".concat(packInfo.packTypeName).concat(\"_\").concat(packInfo.packTypeId.toString())\n\n        let pathCollection = FindPack.getPacksCollection(packTypeName: packInfo.packTypeName, packTypeId: packInfo.packTypeId)\n        let adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n\n        let ids = pathCollection.getIDs()\n        for i, user in packInfo.users {\n            let id = ids[i]\n\n            let address = FIND.resolve(user)\n            if address == nil {\n                panic(\"User cannot be resolved : \".concat(user))\n            }\n\n            let uAccount = getAccount(address!)\n            let userPacks=uAccount.getCapability\u003c\u0026FindPack.Collection{NonFungibleToken.Receiver}\u003e(FindPack.CollectionPublicPath).borrow() ?? panic(\"Could not find userPacks for \".concat(user))\n            let pointer = adminRef.getAuthPointer(pathIdentifier: pathIdentifier, id: id)\n            let ctx : {String : String } = {\"message\" : packInfo.message, \"tenant\" : \"find\"}\n            FindAirdropper.safeAirdrop(pointer: pointer, receiver: address!, path: FindPack.CollectionPublicPath, context: ctx , deepValidation: true)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "packInfo"
                  ],
                  "parameters": {
                     "packInfo": "FindPack.AirdropInfo"
                  }
               }
            },
            "sendNFTs": {
               "code": "import NonFungibleToken from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FlowStorageFees from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport NFTCatalog from 0xf8d6e0586b0a20c7\nimport FINDNFTCatalog from 0x179b6b1cb6755e31\nimport FindViews from 0x179b6b1cb6755e31\nimport FIND from 0x179b6b1cb6755e31\nimport FindAirdropper from 0x179b6b1cb6755e31\nimport FTRegistry from 0x179b6b1cb6755e31\nimport Profile from 0x179b6b1cb6755e31\nimport Sender from 0x179b6b1cb6755e31\n\ntransaction(nftIdentifiers: [String], allReceivers: [String] , ids:[UInt64], memos: [String], donationTypes: [String?], donationAmounts: [UFix64?], findDonationType: String?, findDonationAmount: UFix64?) {\n\n    let authPointers : [FindViews.AuthNFTPointer]\n    let paths : [PublicPath]\n    let flowVault : \u0026FungibleToken.Vault\n    let flowTokenRepayment : Capability\u003c\u0026FlowToken.Vault{FungibleToken.Receiver}\u003e\n    let defaultTokenAvailableBalance : UFix64\n\n    let royalties: [MetadataViews.Royalties?]\n    let totalRoyalties: [UFix64]\n    let vaultRefs: {String : \u0026FungibleToken.Vault}\n    var token : \u0026Sender.Token\n\n    prepare(account : AuthAccount) {\n\n        self.authPointers = []\n        self.paths = []\n        self.royalties = []\n        self.totalRoyalties = []\n        self.vaultRefs = {}\n\n\n        let contractData : {Type : NFTCatalog.NFTCatalogMetadata} = {}\n\n\n        for i , typeIdentifier in nftIdentifiers {\n            let type = CompositeType(typeIdentifier) ?? panic(\"Cannot refer to type with identifier : \".concat(typeIdentifier))\n\n            var data : NFTCatalog.NFTCatalogMetadata? = contractData[type]\n            if data == nil {\n                data = FINDNFTCatalog.getMetadataFromType(type) ?? panic(\"NFT Type is not supported by NFT Catalog. Type : \".concat(type.identifier))\n                contractData[type] = data\n            }\n\n            let path = data!.collectionData\n\n            var providerCap=account.getCapability\u003c\u0026{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e(path.privatePath)\n            if !providerCap.check() {\n                let newCap = account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                    path.privatePath,\n                    target: path.storagePath\n                )\n                if newCap == nil {\n                    // If linking is not successful, we link it using finds custom link\n                    let pathIdentifier = path.privatePath.toString()\n                    let findPath = PrivatePath(identifier: pathIdentifier.slice(from: \"/private/\".length , upTo: pathIdentifier.length).concat(\"_FIND\"))!\n                    account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                        findPath,\n                        target: path.storagePath\n                    )\n                    providerCap = account.getCapability\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(findPath)\n                }\n            }\n            let pointer = FindViews.AuthNFTPointer(cap: providerCap, id: ids[i])\n\n            if let dt = donationTypes[i] {\n                self.royalties.append(pointer.getRoyalty())\n                self.totalRoyalties.append(pointer.getTotalRoyaltiesCut())\n\n                // get the vault for donation\n                if self.vaultRefs[dt] == nil {\n                    let info = FTRegistry.getFTInfo(dt) ?? panic(\"This token type is not supported at the moment : \".concat(dt))\n                    let ftPath = info.vaultPath\n                    let ref = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ftPath) ?? panic(\"Cannot borrow vault reference for type : \".concat(dt))\n                    self.vaultRefs[dt] = ref\n                }\n\n            } else {\n                self.royalties.append(nil)\n                self.totalRoyalties.append(0.0)\n            }\n\n            self.authPointers.append(pointer)\n            self.paths.append(path.publicPath)\n        }\n\n        self.flowVault = account.borrow\u003c\u0026FlowToken.Vault\u003e(from: /storage/flowTokenVault) ?? panic(\"Cannot borrow reference to sender's flow vault\")\n        self.flowTokenRepayment = account.getCapability\u003c\u0026FlowToken.Vault{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver)\n        self.defaultTokenAvailableBalance = FlowStorageFees.defaultTokenAvailableBalance(account.address)\n\n        // get the vault for find donation\n        if let dt = findDonationType {\n            if self.vaultRefs[dt] == nil {\n                let info = FTRegistry.getFTInfo(dt) ?? panic(\"This token type is not supported at the moment : \".concat(dt))\n                let ftPath = info.vaultPath\n                let ref = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ftPath) ?? panic(\"Cannot borrow vault reference for type : \".concat(dt))\n                self.vaultRefs[dt] = ref\n            }\n        }\n\n        if account.borrow\u003c\u0026Sender.Token\u003e(from: Sender.storagePath) == nil {\n            account.save(\u003c- Sender.create(), to: Sender.storagePath)\n        }\n\n        self.token =account.borrow\u003c\u0026Sender.Token\u003e(from: Sender.storagePath)!\n\n    }\n\n    execute {\n        let addresses : {String : Address} = {}\n        let estimatedStorageFee = 0.0002 * UFix64(self.authPointers.length)\n        // we pass in the least amount as possible for storage fee here\n        let tempVault \u003c- self.flowVault.withdraw(amount: 0.0)\n        var vaultRef = \u0026tempVault as \u0026FungibleToken.Vault\n        if self.defaultTokenAvailableBalance \u003c= estimatedStorageFee {\n            vaultRef = self.flowVault as \u0026FungibleToken.Vault\n        } else {\n            tempVault.deposit(from: \u003c- self.flowVault.withdraw(amount: estimatedStorageFee))\n        }\n\n        let ctx : {String : String} = {\n            \"tenant\" : \"find\"\n        }\n\n        for i,  pointer in self.authPointers {\n            let receiver = allReceivers[i]\n            let id = ids[i]\n            ctx[\"message\"] = memos[i]\n            let path = self.paths[i]\n\n            var user = addresses[receiver]\n            if user == nil {\n                user = FIND.resolve(receiver) ?? panic(\"Cannot resolve user with name / address : \".concat(receiver))\n                addresses[receiver] = user\n            }\n\n            // airdrop thru airdropper\n            FindAirdropper.forcedAirdrop(pointer: pointer, receiver: user!, path: path, context: ctx, storagePayment: vaultRef, flowTokenRepayment: self.flowTokenRepayment, deepValidation: true)\n        }\n        self.flowVault.deposit(from: \u003c- tempVault)\n\n        // This is hard coded for spliting at the front end for now. So if there are no royalties, all goes to find\n        // AND This does not support different ft types for now.\n        var goesToFindFund = 0.0\n        for i , type in donationTypes {\n            if type == nil {\n                continue\n            }\n            let amount = donationAmounts[i]!\n            let royalties = self.royalties[i]!\n            let totalRoyalties = self.totalRoyalties[i]\n            let vaultRef = self.vaultRefs[type!]!\n            var noRoyalty = false\n            if totalRoyalties == 0.0 {\n                goesToFindFund = goesToFindFund + amount\n                continue\n            }\n\n            let balance = vaultRef.balance\n            var totalPaid = 0.0\n\n            for j, r in royalties.getRoyalties() {\n                var cap : Capability\u003c\u0026{FungibleToken.Receiver}\u003e = r.receiver\n                if !r.receiver.check(){\n                    // try to grab from profile\n                    if let ref = getAccount(r.receiver.address).getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath).borrow() {\n                        if ref.hasWallet(vaultRef.getType().identifier) {\n                            cap = getAccount(r.receiver.address).getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n                        } else if let ftInfo = FTRegistry.getFTInfo(vaultRef.getType().identifier) {\n                            cap = getAccount(r.receiver.address).getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(ftInfo.receiverPath)\n                        }\n                    }\n\n                }\n\n                if cap.check() {\n                    let individualAmount = r.cut / totalRoyalties * amount\n                    let vault \u003c- vaultRef.withdraw(amount: individualAmount)\n                    cap.borrow()!.deposit(from: \u003c- vault)\n\n                    totalPaid = totalPaid + individualAmount\n                }\n            }\n\n            assert(totalPaid \u003c= amount, message: \"Amount paid is greater than expected\" )\n\n        }\n\n        // for donating to find\n        if findDonationType != nil {\n            vaultRef = self.vaultRefs[findDonationType!]!\n            let vault \u003c- vaultRef.withdraw(amount: findDonationAmount! + goesToFindFund)\n            FIND.depositWithTagAndMessage(to: \"find\", message: \"donation to .find\", tag: \"donation\", vault: \u003c- vault, from: self.token)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "nftIdentifiers",
                     "allReceivers",
                     "ids",
                     "memos",
                     "donationTypes",
                     "donationAmounts",
                     "findDonationType",
                     "findDonationAmount"
                  ],
                  "parameters": {
                     "allReceivers": "[String]",
                     "donationAmounts": "[UFix64?]",
                     "donationTypes": "[String?]",
                     "findDonationAmount": "UFix64?",
                     "findDonationType": "String?",
                     "ids": "[UInt64]",
                     "memos": "[String]",
                     "nftIdentifiers": "[String]"
                  }
               }
            },
            "sendNFTsSafe": {
               "code": "import NonFungibleToken from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport NFTCatalog from 0xf8d6e0586b0a20c7\nimport FINDNFTCatalog from 0x179b6b1cb6755e31\nimport FindViews from 0x179b6b1cb6755e31\nimport FIND from 0x179b6b1cb6755e31\nimport FindAirdropper from 0x179b6b1cb6755e31\nimport FTRegistry from 0x179b6b1cb6755e31\nimport Profile from 0x179b6b1cb6755e31\nimport Sender from 0x179b6b1cb6755e31\n\ntransaction(nftIdentifiers: [String], allReceivers: [String] , ids:[UInt64], memos: [String], donationTypes: [String?], donationAmounts: [UFix64?], findDonationType: String?, findDonationAmount: UFix64?) {\n\n    let authPointers : [FindViews.AuthNFTPointer]\n    let paths : [PublicPath]\n    let royalties: [MetadataViews.Royalties?]\n    let totalRoyalties: [UFix64]\n    let vaultRefs: {String : \u0026FungibleToken.Vault}\n    var token : \u0026Sender.Token\n\n    prepare(account : AuthAccount) {\n\n        self.authPointers = []\n        self.paths = []\n        self.royalties = []\n        self.totalRoyalties = []\n        self.vaultRefs = {}\n\n        let contractData : {Type : NFTCatalog.NFTCatalogMetadata} = {}\n\n\n        for i , typeIdentifier in nftIdentifiers {\n            let type = CompositeType(typeIdentifier) ?? panic(\"Cannot refer to type with identifier : \".concat(typeIdentifier))\n\n            var data : NFTCatalog.NFTCatalogMetadata? = contractData[type]\n            if data == nil {\n                data = FINDNFTCatalog.getMetadataFromType(type) ?? panic(\"NFT Type is not supported by NFT Catalog. Type : \".concat(type.identifier))\n                contractData[type] = data\n            }\n\n            let path = data!.collectionData\n\n            var providerCap=account.getCapability\u003c\u0026{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e(path.privatePath)\n            if !providerCap.check() {\n                let newCap = account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                    path.privatePath,\n                    target: path.storagePath\n                )\n                if newCap == nil {\n                    // If linking is not successful, we link it using finds custom link\n                    let pathIdentifier = path.privatePath.toString()\n                    let findPath = PrivatePath(identifier: pathIdentifier.slice(from: \"/private/\".length , upTo: pathIdentifier.length).concat(\"_FIND\"))!\n                    account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                        findPath,\n                        target: path.storagePath\n                    )\n                    providerCap = account.getCapability\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(findPath)\n                }\n            }\n            let pointer = FindViews.AuthNFTPointer(cap: providerCap, id: ids[i])\n\n            if let dt = donationTypes[i] {\n                self.royalties.append(pointer.getRoyalty())\n                self.totalRoyalties.append(pointer.getTotalRoyaltiesCut())\n\n                // get the vault for donation\n                if self.vaultRefs[dt] == nil {\n                    let info = FTRegistry.getFTInfo(dt) ?? panic(\"This token type is not supported at the moment : \".concat(dt))\n                    let ftPath = info.vaultPath\n                    let ref = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ftPath) ?? panic(\"Cannot borrow vault reference for type : \".concat(dt))\n                    self.vaultRefs[dt] = ref\n                }\n\n            } else {\n                self.royalties.append(nil)\n                self.totalRoyalties.append(0.0)\n            }\n\n\n            self.authPointers.append(pointer)\n            self.paths.append(path.publicPath)\n        }\n\n        // get the vault for find donation\n        if let dt = findDonationType {\n            if self.vaultRefs[dt] == nil {\n                let info = FTRegistry.getFTInfo(dt) ?? panic(\"This token type is not supported at the moment : \".concat(dt))\n                let ftPath = info.vaultPath\n                let ref = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ftPath) ?? panic(\"Cannot borrow vault reference for type : \".concat(dt))\n                self.vaultRefs[dt] = ref\n            }\n        }\n\n        if account.borrow\u003c\u0026Sender.Token\u003e(from: Sender.storagePath) == nil {\n            account.save(\u003c- Sender.create(), to: Sender.storagePath)\n        }\n\n        self.token =account.borrow\u003c\u0026Sender.Token\u003e(from: Sender.storagePath)!\n\n    }\n\n    execute {\n        let addresses : {String : Address} = {}\n\n        let ctx : {String : String} = {\n            \"tenant\" : \"find\"\n        }\n\n        for i,  pointer in self.authPointers {\n            let receiver = allReceivers[i]\n            let id = ids[i]\n            ctx[\"message\"] = memos[i]\n            let path = self.paths[i]\n\n            var user = addresses[receiver]\n            if user == nil {\n                user = FIND.resolve(receiver) ?? panic(\"Cannot resolve user with name / address : \".concat(receiver))\n                addresses[receiver] = user\n            }\n\n            // airdrop thru airdropper\n            FindAirdropper.safeAirdrop(pointer: pointer, receiver: user!, path: path, context: ctx, deepValidation: true)\n        }\n\n\n        // This is hard coded for spliting at the front end for now. So if there are no royalties, all goes to find\n        // AND This does not support different ft types for now.\n        var goesToFindFund = 0.0\n        for i , type in donationTypes {\n            if type == nil {\n                continue\n            }\n            let amount = donationAmounts[i]!\n            let royalties = self.royalties[i]!\n            let totalRoyalties = self.totalRoyalties[i]\n            let vaultRef = self.vaultRefs[type!]!\n            if totalRoyalties == 0.0 {\n                goesToFindFund = goesToFindFund + amount\n                continue\n            }\n\n            let balance = vaultRef.balance\n            var totalPaid = 0.0\n\n            for j, r in royalties.getRoyalties() {\n                var cap : Capability\u003c\u0026{FungibleToken.Receiver}\u003e = r.receiver\n                if !r.receiver.check(){\n                    // try to grab from profile\n                    if let ref = getAccount(r.receiver.address).getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath).borrow() {\n                        if ref.hasWallet(vaultRef.getType().identifier) {\n                            cap = getAccount(r.receiver.address).getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n                        } else if let ftInfo = FTRegistry.getFTInfo(vaultRef.getType().identifier) {\n                            cap = getAccount(r.receiver.address).getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(ftInfo.receiverPath)\n                        }\n                    }\n\n                }\n\n                if cap.check() {\n                    let individualAmount = r.cut / totalRoyalties * amount\n                    let vault \u003c- vaultRef.withdraw(amount: individualAmount)\n                    cap.borrow()!.deposit(from: \u003c- vault)\n\n                    totalPaid = totalPaid + individualAmount\n                }\n            }\n\n            assert(totalPaid \u003c= amount, message: \"Amount paid is greater than expected\" )\n\n        }\n\n\n        // for donating to find\n        if findDonationType != nil {\n            let vaultRef = self.vaultRefs[findDonationType!]!\n            let vault \u003c- vaultRef.withdraw(amount: findDonationAmount! + goesToFindFund)\n            FIND.depositWithTagAndMessage(to: \"find\", message: \"donation to .find\", tag: \"donation\", vault: \u003c- vault, from: self.token)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "nftIdentifiers",
                     "allReceivers",
                     "ids",
                     "memos",
                     "donationTypes",
                     "donationAmounts",
                     "findDonationType",
                     "findDonationAmount"
                  ],
                  "parameters": {
                     "allReceivers": "[String]",
                     "donationAmounts": "[UFix64?]",
                     "donationTypes": "[String?]",
                     "findDonationAmount": "UFix64?",
                     "findDonationType": "String?",
                     "ids": "[UInt64]",
                     "memos": "[String]",
                     "nftIdentifiers": "[String]"
                  }
               }
            },
            "sendNFTsSubsidize": {
               "code": "import NonFungibleToken from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FlowStorageFees from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport NFTCatalog from 0xf8d6e0586b0a20c7\nimport FINDNFTCatalog from 0x179b6b1cb6755e31\nimport FindViews from 0x179b6b1cb6755e31\nimport FIND from 0x179b6b1cb6755e31\nimport FindAirdropper from 0x179b6b1cb6755e31\nimport FTRegistry from 0x179b6b1cb6755e31\nimport Profile from 0x179b6b1cb6755e31\nimport Sender from 0x179b6b1cb6755e31\n\ntransaction(nftIdentifiers: [String], allReceivers: [String] , ids:[UInt64], memos: [String], donationTypes: [String?], donationAmounts: [UFix64?], findDonationType: String?, findDonationAmount: UFix64?) {\n\n    let authPointers : [FindViews.AuthNFTPointer]\n    let paths : [PublicPath]\n    let flowVault : \u0026FungibleToken.Vault\n    let flowTokenRepayment : Capability\u003c\u0026FlowToken.Vault{FungibleToken.Receiver}\u003e\n    let defaultTokenAvailableBalance : UFix64\n\n    let royalties: [MetadataViews.Royalties?]\n    let totalRoyalties: [UFix64]\n    let vaultRefs: {String : \u0026FungibleToken.Vault}\n    var token : \u0026Sender.Token\n\n    prepare(account : AuthAccount) {\n\n        self.authPointers = []\n        self.paths = []\n        self.royalties = []\n        self.totalRoyalties = []\n        self.vaultRefs = {}\n\n        let contractData : {Type : NFTCatalog.NFTCatalogMetadata} = {}\n\n\n        for i , typeIdentifier in nftIdentifiers {\n            let type = CompositeType(typeIdentifier) ?? panic(\"Cannot refer to type with identifier : \".concat(typeIdentifier))\n\n            var data : NFTCatalog.NFTCatalogMetadata? = contractData[type]\n            if data == nil {\n                data = FINDNFTCatalog.getMetadataFromType(type) ?? panic(\"NFT Type is not supported by NFT Catalog. Type : \".concat(type.identifier))\n                contractData[type] = data\n            }\n\n            let path = data!.collectionData\n\n            var providerCap=account.getCapability\u003c\u0026{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e(path.privatePath)\n            if !providerCap.check() {\n                let newCap = account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                    path.privatePath,\n                    target: path.storagePath\n                )\n                if newCap == nil {\n                    // If linking is not successful, we link it using finds custom link\n                    let pathIdentifier = path.privatePath.toString()\n                    let findPath = PrivatePath(identifier: pathIdentifier.slice(from: \"/private/\".length , upTo: pathIdentifier.length).concat(\"_FIND\"))!\n                    account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                        findPath,\n                        target: path.storagePath\n                    )\n                    providerCap = account.getCapability\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(findPath)\n                }\n            }\n            let pointer = FindViews.AuthNFTPointer(cap: providerCap, id: ids[i])\n\n            if let dt = donationTypes[i] {\n                self.royalties.append(pointer.getRoyalty())\n                self.totalRoyalties.append(pointer.getTotalRoyaltiesCut())\n\n                // get the vault for donation\n                if self.vaultRefs[dt] == nil {\n                    let info = FTRegistry.getFTInfo(dt) ?? panic(\"This token type is not supported at the moment : \".concat(dt))\n                    let ftPath = info.vaultPath\n                    let ref = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ftPath) ?? panic(\"Cannot borrow vault reference for type : \".concat(dt))\n                    self.vaultRefs[dt] = ref\n                }\n\n            } else {\n                self.royalties.append(nil)\n                self.totalRoyalties.append(0.0)\n            }\n\n\n            self.authPointers.append(pointer)\n            self.paths.append(path.publicPath)\n        }\n\n        self.flowVault = account.borrow\u003c\u0026FlowToken.Vault\u003e(from: /storage/flowTokenVault) ?? panic(\"Cannot borrow reference to sender's flow vault\")\n        self.flowTokenRepayment = account.getCapability\u003c\u0026FlowToken.Vault{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver)\n        self.defaultTokenAvailableBalance = FlowStorageFees.defaultTokenAvailableBalance(account.address)\n\n        // get the vault for find donation\n        if let dt = findDonationType {\n            if self.vaultRefs[dt] == nil {\n                let info = FTRegistry.getFTInfo(dt) ?? panic(\"This token type is not supported at the moment : \".concat(dt))\n                let ftPath = info.vaultPath\n                let ref = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ftPath) ?? panic(\"Cannot borrow vault reference for type : \".concat(dt))\n                self.vaultRefs[dt] = ref\n            }\n        }\n\n        if account.borrow\u003c\u0026Sender.Token\u003e(from: Sender.storagePath) == nil {\n            account.save(\u003c- Sender.create(), to: Sender.storagePath)\n        }\n\n        self.token =account.borrow\u003c\u0026Sender.Token\u003e(from: Sender.storagePath)!\n\n\n    }\n\n    execute {\n        let addresses : {String : Address} = {}\n        let estimatedStorageFee = 0.0002 * UFix64(self.authPointers.length)\n        // we pass in the least amount as possible for storage fee here\n        let tempVault \u003c- self.flowVault.withdraw(amount: 0.0)\n        var vaultRef = \u0026tempVault as \u0026FungibleToken.Vault\n        if self.defaultTokenAvailableBalance \u003c= estimatedStorageFee {\n            vaultRef = self.flowVault as \u0026FungibleToken.Vault\n        } else {\n            tempVault.deposit(from: \u003c- self.flowVault.withdraw(amount: estimatedStorageFee))\n        }\n\n        let ctx : {String : String} = {\n            \"tenant\" : \"find\"\n        }\n\n        for i,  pointer in self.authPointers {\n            let receiver = allReceivers[i]\n            let id = ids[i]\n            ctx[\"message\"] = memos[i]\n            let path = self.paths[i]\n\n            var user = addresses[receiver]\n            if user == nil {\n                user = FIND.resolve(receiver) ?? panic(\"Cannot resolve user with name / address : \".concat(receiver))\n                addresses[receiver] = user\n            }\n\n            // airdrop thru airdropper\n            FindAirdropper.subsidizedAirdrop(pointer: pointer, receiver: user!, path: path, context: ctx, storagePayment: vaultRef, flowTokenRepayment: self.flowTokenRepayment, deepValidation: true)\n        }\n        self.flowVault.deposit(from: \u003c- tempVault)\n\n        // This is hard coded for spliting at the front end for now. So if there are no royalties, all goes to find\n        // AND This does not support different ft types for now.\n        var goesToFindFund = 0.0\n        for i , type in donationTypes {\n            if type == nil {\n                continue\n            }\n            let amount = donationAmounts[i]!\n            let royalties = self.royalties[i]!\n            let totalRoyalties = self.totalRoyalties[i]\n            let vaultRef = self.vaultRefs[type!]!\n            if totalRoyalties == 0.0 {\n                goesToFindFund = goesToFindFund + amount\n                continue\n            }\n\n            let balance = vaultRef.balance\n            var totalPaid = 0.0\n\n            for j, r in royalties.getRoyalties() {\n                var cap : Capability\u003c\u0026{FungibleToken.Receiver}\u003e = r.receiver\n                if !r.receiver.check(){\n                    // try to grab from profile\n                    if let ref = getAccount(r.receiver.address).getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath).borrow() {\n                        if ref.hasWallet(vaultRef.getType().identifier) {\n                            cap = getAccount(r.receiver.address).getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n                        } else if let ftInfo = FTRegistry.getFTInfo(vaultRef.getType().identifier) {\n                            cap = getAccount(r.receiver.address).getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(ftInfo.receiverPath)\n                        }\n                    }\n\n                }\n\n                if cap.check() {\n                    let individualAmount = r.cut / totalRoyalties * amount\n                    let vault \u003c- vaultRef.withdraw(amount: individualAmount)\n                    cap.borrow()!.deposit(from: \u003c- vault)\n\n                    totalPaid = totalPaid + individualAmount\n                }\n            }\n\n            assert(totalPaid \u003c= amount, message: \"Amount paid is greater than expected\" )\n\n        }\n\n\n        // for donating to find\n        if findDonationType != nil {\n            vaultRef = self.vaultRefs[findDonationType!]!\n            let vault \u003c- vaultRef.withdraw(amount: findDonationAmount! + goesToFindFund)\n            FIND.depositWithTagAndMessage(to: \"find\", message: \"donation to .find\", tag: \"donation\", vault: \u003c- vault, from: self.token)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "nftIdentifiers",
                     "allReceivers",
                     "ids",
                     "memos",
                     "donationTypes",
                     "donationAmounts",
                     "findDonationType",
                     "findDonationAmount"
                  ],
                  "parameters": {
                     "allReceivers": "[String]",
                     "donationAmounts": "[UFix64?]",
                     "donationTypes": "[String?]",
                     "findDonationAmount": "UFix64?",
                     "findDonationType": "String?",
                     "ids": "[UInt64]",
                     "memos": "[String]",
                     "nftIdentifiers": "[String]"
                  }
               }
            },
            "sendWearables": {
               "code": "import NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FindViews from 0x179b6b1cb6755e31\nimport FIND from 0x179b6b1cb6755e31\nimport FindAirdropper from 0x179b6b1cb6755e31\nimport Wearables from 0xf8d6e0586b0a20c7\n\ntransaction(allReceivers: [String] , ids:[UInt64], memos: [String]) {\n\n    let authPointers : [FindViews.AuthNFTPointer]\n\n    prepare(account : AuthAccount) {\n\n        self.authPointers = []\n        let privatePath = Wearables.CollectionPrivatePath\n        let storagePath = Wearables.CollectionStoragePath\n\n        for id in ids {\n\n            var providerCap=account.getCapability\u003c\u0026{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e(privatePath)\n            if !providerCap.check() {\n                let newCap = account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                    privatePath,\n                    target: storagePath\n                )\n                if newCap == nil {\n                    // If linking is not successful, we link it using finds custom link\n                    let pathIdentifier = privatePath.toString()\n                    let findPath = PrivatePath(identifier: pathIdentifier.slice(from: \"/private/\".length , upTo: pathIdentifier.length).concat(\"_FIND\"))!\n                    account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                        findPath,\n                        target: storagePath\n                    )\n                    providerCap = account.getCapability\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(findPath)\n                }\n            }\n            let pointer = FindViews.AuthNFTPointer(cap: providerCap, id: id)\n\n            self.authPointers.append(pointer)\n        }\n\n    }\n\n    execute {\n        let addresses : {String : Address} = {}\n        let publicPath = Wearables.CollectionPublicPath\n\n        let ctx : {String : String} = {\n            \"tenant\" : \"find\"\n        }\n\n        for i,  pointer in self.authPointers {\n            let receiver = allReceivers[i]\n            let id = ids[i]\n            ctx[\"message\"] = memos[i]\n\n            var user = addresses[receiver]\n            if user == nil {\n                user = FIND.resolve(receiver) ?? panic(\"Cannot resolve user with name / address : \".concat(receiver))\n                addresses[receiver] = user\n            }\n\n            // airdrop thru airdropper\n            FindAirdropper.safeAirdrop(pointer: pointer, receiver: user!, path: publicPath, context: ctx, deepValidation: true)\n        }\n\n    }\n}",
               "spec": {
                  "order": [
                     "allReceivers",
                     "ids",
                     "memos"
                  ],
                  "parameters": {
                     "allReceivers": "[String]",
                     "ids": "[UInt64]",
                     "memos": "[String]"
                  }
               }
            },
            "setMainName": {
               "code": "import Profile from 0x179b6b1cb6755e31\nimport FIND from 0x179b6b1cb6755e31\n\n\ntransaction(name: String) {\n\n    let leaseCollectionOwner : Capability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e\n    let profile : \u0026Profile.User\n\n    prepare(acct: AuthAccount) {\n        self.leaseCollectionOwner = acct.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        self.profile =acct.borrow\u003c\u0026Profile.User\u003e(from:Profile.storagePath)!\n    }\n\n    pre{\n        self.leaseCollectionOwner.check() : \"Not a find user\"\n        self.leaseCollectionOwner.borrow()!.getLease(name) != nil : \"You do not own this lease so you cannot set it as main name\"\n    }\n\n    execute{\n        self.profile.setFindName(name)\n    }\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "setMarketOptionFlowDandy": {
               "code": "import FindMarket from 0x179b6b1cb6755e31\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport Dandy from 0x179b6b1cb6755e31\n\ntransaction(){\n    prepare(account: AuthAccount){\n        let path = FindMarket.TenantClientStoragePath\n        let tenantRef = account.borrow\u003c\u0026FindMarket.TenantClient\u003e(from: path) ?? panic(\"Cannot borrow Reference.\")\n\n        tenantRef.setMarketOption(name:\"FlowDandy\", cut: nil, rules:[\n            FindMarket.TenantRule(name:\"Flow\", types:[Type\u003c@FlowToken.Vault\u003e()], ruleType: \"ft\", allow: true),\n            FindMarket.TenantRule(name:\"Dandy\", types:[ Type\u003c@Dandy.NFT\u003e()], ruleType: \"nft\", allow: true)\n            ]\n        )\n    }\n}",
               "spec": {
                  "order": [],
                  "parameters": {}
               }
            },
            "setPrivateMode": {
               "code": "import Profile from 0x179b6b1cb6755e31\n\ntransaction(mode: Bool) {\n\n    let profile : \u0026Profile.User?\n\n    prepare(acct: AuthAccount) {\n        self.profile =acct.borrow\u003c\u0026Profile.User\u003e(from:Profile.storagePath)\n    }\n\n    pre{\n        self.profile != nil : \"Cannot borrow reference to profile\"\n    }\n\n    execute{\n        self.profile!.setPrivateMode(mode)\n        self.profile!.emitUpdatedEvent()\n    }\n}",
               "spec": {
                  "order": [
                     "mode"
                  ],
                  "parameters": {
                     "mode": "Bool"
                  }
               }
            },
            "setPrivateModeDapper": {
               "code": "import Profile from 0x179b6b1cb6755e31\n\ntransaction(mode: Bool) {\n\n    let profile : \u0026Profile.User?\n\n    prepare(acct: AuthAccount) {\n        self.profile =acct.borrow\u003c\u0026Profile.User\u003e(from:Profile.storagePath)\n    }\n\n    pre{\n        self.profile != nil : \"Cannot borrow reference to profile\"\n    }\n\n    execute{\n        self.profile!.setPrivateMode(mode)\n        self.profile!.emitUpdatedEvent()\n    }\n}",
               "spec": {
                  "order": [
                     "mode"
                  ],
                  "parameters": {
                     "mode": "Bool"
                  }
               }
            },
            "setProfile": {
               "code": "import Profile from 0x179b6b1cb6755e31\n\ntransaction(avatar: String) {\n\n    let profile : \u0026Profile.User?\n\n    prepare(acct: AuthAccount) {\n        self.profile =acct.borrow\u003c\u0026Profile.User\u003e(from:Profile.storagePath)\n    }\n\n    pre{\n        self.profile != nil : \"Cannot borrow reference to profile\"\n    }\n\n    execute{\n        self.profile!.setAvatar(avatar)\n        self.profile!.emitUpdatedEvent()\n    }\n}",
               "spec": {
                  "order": [
                     "avatar"
                  ],
                  "parameters": {
                     "avatar": "String"
                  }
               }
            },
            "setRelatedAccount": {
               "code": "import FindRelatedAccounts from 0x179b6b1cb6755e31\nimport FIND from 0x179b6b1cb6755e31\n\ntransaction(name: String, target: String) {\n\n    var relatedAccounts : \u0026FindRelatedAccounts.Accounts?\n    let address : Address?\n\n    prepare(account: AuthAccount) {\n\n\n        self.address = FIND.resolve(target)\n\n        self.relatedAccounts= account.borrow\u003c\u0026FindRelatedAccounts.Accounts\u003e(from:FindRelatedAccounts.storagePath)\n        if self.relatedAccounts == nil {\n            let relatedAccounts \u003c- FindRelatedAccounts.createEmptyAccounts()\n            account.save(\u003c- relatedAccounts, to: FindRelatedAccounts.storagePath)\n            account.link\u003c\u0026FindRelatedAccounts.Accounts{FindRelatedAccounts.Public}\u003e(FindRelatedAccounts.publicPath, target: FindRelatedAccounts.storagePath)\n            self.relatedAccounts= account.borrow\u003c\u0026FindRelatedAccounts.Accounts\u003e(from:FindRelatedAccounts.storagePath)\n        }\n\n        let cap = account.getCapability\u003c\u0026FindRelatedAccounts.Accounts{FindRelatedAccounts.Public}\u003e(FindRelatedAccounts.publicPath)\n        if !cap.check() {\n            account.unlink(FindRelatedAccounts.publicPath)\n            account.link\u003c\u0026FindRelatedAccounts.Accounts{FindRelatedAccounts.Public}\u003e(FindRelatedAccounts.publicPath, target: FindRelatedAccounts.storagePath)\n        }\n    }\n\n    pre{\n        self.address != nil : \"The input pass in is not a valid name or address. Input : \".concat(target)\n    }\n\n    execute{\n        self.relatedAccounts!.addFlowAccount(name: name, address: self.address!)\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "target"
                  ],
                  "parameters": {
                     "name": "String",
                     "target": "String"
                  }
               }
            },
            "setRelatedAccountDapper": {
               "code": "import FindRelatedAccounts from 0x179b6b1cb6755e31\nimport FIND from 0x179b6b1cb6755e31\n\ntransaction(name: String, target: String) {\n\n    var relatedAccounts : \u0026FindRelatedAccounts.Accounts?\n    let address : Address?\n\n    prepare(account: AuthAccount) {\n\n\n        self.address = FIND.resolve(target)\n\n        self.relatedAccounts= account.borrow\u003c\u0026FindRelatedAccounts.Accounts\u003e(from:FindRelatedAccounts.storagePath)\n        if self.relatedAccounts == nil {\n            let relatedAccounts \u003c- FindRelatedAccounts.createEmptyAccounts()\n            account.save(\u003c- relatedAccounts, to: FindRelatedAccounts.storagePath)\n            account.link\u003c\u0026FindRelatedAccounts.Accounts{FindRelatedAccounts.Public}\u003e(FindRelatedAccounts.publicPath, target: FindRelatedAccounts.storagePath)\n            self.relatedAccounts= account.borrow\u003c\u0026FindRelatedAccounts.Accounts\u003e(from:FindRelatedAccounts.storagePath)\n        }\n\n        let cap = account.getCapability\u003c\u0026FindRelatedAccounts.Accounts{FindRelatedAccounts.Public}\u003e(FindRelatedAccounts.publicPath)\n        if !cap.check() {\n            account.unlink(FindRelatedAccounts.publicPath)\n            account.link\u003c\u0026FindRelatedAccounts.Accounts{FindRelatedAccounts.Public}\u003e(FindRelatedAccounts.publicPath, target: FindRelatedAccounts.storagePath)\n        }\n    }\n\n    pre{\n        self.address != nil : \"The input pass in is not a valid name or address. Input : \".concat(target)\n    }\n\n    execute{\n        self.relatedAccounts!.addFlowAccount(name: name, address: self.address!)\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "target"
                  ],
                  "parameters": {
                     "name": "String",
                     "target": "String"
                  }
               }
            },
            "setSellDandyRules": {
               "code": "import FindMarket from 0x179b6b1cb6755e31\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport FUSD from 0xf8d6e0586b0a20c7\nimport Dandy from 0x179b6b1cb6755e31\n\ntransaction(){\n    prepare(account: AuthAccount){\n        let path = FindMarket.TenantClientStoragePath\n        let tenantRef = account.borrow\u003c\u0026FindMarket.TenantClient\u003e(from: path) ?? panic(\"Cannot borrow Reference.\")\n\n        tenantRef.setMarketOption(name:\"FUSDDandy\", cut: nil, rules:[\n            FindMarket.TenantRule(name:\"FUSD\", types:[Type\u003c@FUSD.Vault\u003e()], ruleType: \"ft\", allow: true),\n            FindMarket.TenantRule(name:\"Dandy\", types:[ Type\u003c@Dandy.NFT\u003e()], ruleType: \"nft\", allow: true)\n            ]\n        )\n\n        tenantRef.setMarketOption(name:\"FlowDandy\", cut: nil, rules:[\n            FindMarket.TenantRule(name:\"Flow\", types:[Type\u003c@FlowToken.Vault\u003e()], ruleType: \"ft\", allow: true),\n            FindMarket.TenantRule(name:\"Dandy\", types:[ Type\u003c@Dandy.NFT\u003e()], ruleType: \"nft\", allow: true)\n            ]\n        )\n\n    }\n}",
               "spec": {
                  "order": [],
                  "parameters": {}
               }
            },
            "setTenantRuleFUSD": {
               "code": "import FindMarket from 0x179b6b1cb6755e31\nimport FUSD from 0xf8d6e0586b0a20c7\n\ntransaction(optionName: String){\n    prepare(account: AuthAccount){\n        let path = FindMarket.TenantClientStoragePath\n        let tenantRef = account.borrow\u003c\u0026FindMarket.TenantClient\u003e(from: path) ?? panic(\"Cannot borrow Reference.\")\n\n        tenantRef.setTenantRule(optionName: optionName, tenantRule:\n            FindMarket.TenantRule(name:\"FUSD\", types:[Type\u003c@FUSD.Vault\u003e()], ruleType: \"ft\", allow: true)\n        )\n    }\n}",
               "spec": {
                  "order": [
                     "optionName"
                  ],
                  "parameters": {
                     "optionName": "String"
                  }
               }
            },
            "startNameAuction": {
               "code": "import FIND from 0x179b6b1cb6755e31\n\ntransaction(name: String) {\n\n    let finLeases : \u0026FIND.LeaseCollection?\n\n    prepare(account: AuthAccount) {\n        self.finLeases= account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)\n    }\n\n    pre{\n        self.finLeases != nil : \"Cannot borrow reference to find lease collection\"\n    }\n\n    execute{\n        self.finLeases!.startAuction(name)\n    }\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "storeCuratedCollections": {
               "code": "transaction(collections: {String :  [String]}) {\n    prepare(account: AuthAccount) {\n\n        let path=/storage/FindCuratedCollections\n        let publicPath=/public/FindCuratedCollections\n\n        if account.borrow\u003c\u0026{String: [String]}\u003e(from:path) != nil {\n             account.load\u003c{String: [String]}\u003e(from:path)\n        }\n        account.save(collections, to: path)\n\n        let link = account.getCapability\u003c\u0026{String: [String]}\u003e(publicPath)\n        if !link.check() {\n            account.link\u003c\u0026{String: [String]}\u003e( publicPath, target: path)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "collections"
                  ],
                  "parameters": {
                     "collections": "{String: [String]}"
                  }
               }
            },
            "tenantsetExtraCut": {
               "code": "import FindMarket from 0x179b6b1cb6755e31\nimport FindMarketCutStruct from 0x179b6b1cb6755e31\n\ntransaction(ftTypes: [String], category: String, cuts: [FindMarketCutStruct.ThresholdCut]){\n    prepare(account: AuthAccount){\n\n        let types : [Type] = []\n        for t in ftTypes {\n            types.append(CompositeType(t)!)\n        }\n\n        let allCuts = FindMarketCutStruct.Cuts(cuts)\n\n        let clientRef = account.borrow\u003c\u0026FindMarket.TenantClient\u003e(from: FindMarket.TenantClientStoragePath) ?? panic(\"Cannot borrow Tenant Client Reference.\")\n        clientRef.setExtraCut(types: types, category: category, cuts: allCuts)\n    }\n}",
               "spec": {
                  "order": [
                     "ftTypes",
                     "category",
                     "cuts"
                  ],
                  "parameters": {
                     "category": "String",
                     "cuts": "[FindMarketCutStruct.ThresholdCut]",
                     "ftTypes": "[String]"
                  }
               }
            },
            "tenantsetLeaseOptionDapper": {
               "code": "import FindMarket from 0x179b6b1cb6755e31\nimport DapperUtilityCoin from 0x01cf0e2f2f715450\nimport FlowUtilityToken from 0x01cf0e2f2f715450\nimport FindLeaseMarketSale from 0x179b6b1cb6755e31\nimport FindLeaseMarketAuctionSoft from 0x179b6b1cb6755e31\nimport FindLeaseMarketDirectOfferSoft from 0x179b6b1cb6755e31\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FungibleTokenSwitchboard from 0xf8d6e0586b0a20c7\n\ntransaction(nftName: String, nftType: String, cut: UFix64){\n    prepare(account: AuthAccount){\n\n        let defaultRules : [FindMarket.TenantRule] = [\n            FindMarket.TenantRule(\n                name: \"Dapper\",\n                types:[Type\u003c@DapperUtilityCoin.Vault\u003e(), Type\u003c@FlowUtilityToken.Vault\u003e()],\n                ruleType: \"ft\",\n                allow:true\n            ),\n            FindMarket.TenantRule(\n                name: \"Soft\",\n                types:[Type\u003c@FindLeaseMarketSale.SaleItem\u003e(),\n                Type\u003c@FindLeaseMarketAuctionSoft.SaleItem\u003e(),\n                Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItem\u003e()\n                ],\n                ruleType: \"listing\",\n                allow:true\n            )\n        ]\n\n        defaultRules.append(\n            FindMarket.TenantRule(\n                name: nftName,\n                types:[CompositeType(nftType)!],\n                ruleType: \"nft\",\n                allow:true\n            )\n        )\n\n        var royalty : MetadataViews.Royalty? = nil\n        if cut != 0.0 {\n            royalty = MetadataViews.Royalty(\n                receiver: account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(FungibleTokenSwitchboard.ReceiverPublicPath),\n                cut: cut,\n                description: \"tenant\"\n            )\n        }\n\n        let saleItem = FindMarket.TenantSaleItem(\n            name: \"Dapper\".concat(nftName).concat(\"Soft\"),\n            cut: royalty,\n            rules: defaultRules,\n            status: \"active\"\n        )\n\n        let clientRef = account.borrow\u003c\u0026FindMarket.TenantClient\u003e(from: FindMarket.TenantClientStoragePath) ?? panic(\"Cannot borrow Tenant Client Reference.\")\n        clientRef.setMarketOption(saleItem: saleItem)\n    }\n}",
               "spec": {
                  "order": [
                     "nftName",
                     "nftType",
                     "cut"
                  ],
                  "parameters": {
                     "cut": "UFix64",
                     "nftName": "String",
                     "nftType": "String"
                  }
               }
            },
            "tenantsetMarketOption": {
               "code": "import FindMarket from 0x179b6b1cb6755e31\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport FUSD from 0xf8d6e0586b0a20c7\nimport FiatToken from 0xf8d6e0586b0a20c7\nimport FindMarketSale from 0x179b6b1cb6755e31\nimport FindMarketAuctionEscrow from 0x179b6b1cb6755e31\nimport FindMarketDirectOfferEscrow from 0x179b6b1cb6755e31\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FungibleTokenSwitchboard from 0xf8d6e0586b0a20c7\n\ntransaction(nftName: String, nftType: String, cut: UFix64){\n    prepare(account: AuthAccount){\n\n        let defaultRules : [FindMarket.TenantRule] = [\n            FindMarket.TenantRule(\n                name: \"Flow\",\n                types:[\n                    Type\u003c@FlowToken.Vault\u003e()\n                    ],\n                ruleType: \"ft\",\n                allow:true\n            ),\n            FindMarket.TenantRule(\n                name: nftName,\n                types:[CompositeType(nftType)!],\n                ruleType: \"nft\",\n                allow:true\n            ),\n                FindMarket.TenantRule(\n                name: \"Escrow\",\n                types:[Type\u003c@FindMarketSale.SaleItem\u003e(), Type\u003c@FindMarketAuctionEscrow.SaleItem\u003e(), Type\u003c@FindMarketDirectOfferEscrow.SaleItem\u003e()],\n                ruleType: \"listing\",\n                allow:true\n            )\n        ]\n\n        var royalty : MetadataViews.Royalty? = nil\n        if cut != 0.0 {\n            royalty = MetadataViews.Royalty(\n                receiver: account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(FungibleTokenSwitchboard.ReceiverPublicPath),\n                cut: cut,\n                description: \"tenant\"\n            )\n        }\n\n        let saleItem = FindMarket.TenantSaleItem(\n            name: \"Flow\".concat(nftName).concat(\"Escrow\"),\n            cut: royalty,\n            rules: defaultRules,\n            status: \"active\"\n        )\n\n        let clientRef = account.borrow\u003c\u0026FindMarket.TenantClient\u003e(from: FindMarket.TenantClientStoragePath) ?? panic(\"Cannot borrow Tenant Client Reference.\")\n        clientRef.setMarketOption(saleItem: saleItem)\n    }\n}",
               "spec": {
                  "order": [
                     "nftName",
                     "nftType",
                     "cut"
                  ],
                  "parameters": {
                     "cut": "UFix64",
                     "nftName": "String",
                     "nftType": "String"
                  }
               }
            },
            "tenantsetMarketOptionDUC": {
               "code": "import FindMarket from 0x179b6b1cb6755e31\nimport DapperUtilityCoin from 0x01cf0e2f2f715450\nimport FlowUtilityToken from 0x01cf0e2f2f715450\nimport FindLeaseMarketSale from 0x179b6b1cb6755e31\nimport FindLeaseMarketAuctionSoft from 0x179b6b1cb6755e31\nimport FindLeaseMarketDirectOfferSoft from 0x179b6b1cb6755e31\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FungibleTokenSwitchboard from 0xf8d6e0586b0a20c7\n\ntransaction(nftName: String, nftType: String, cut: UFix64){\n    prepare(account: AuthAccount){\n\n        let defaultRules : [FindMarket.TenantRule] = [\n            FindMarket.TenantRule(\n                name: \"Dapper\",\n                types:[\n                    // Type\u003c@FlowUtilityToken.Vault\u003e(),\n                    Type\u003c@DapperUtilityCoin.Vault\u003e()\n                ],\n                ruleType: \"ft\",\n                allow:true\n            ),\n            FindMarket.TenantRule(\n                name: \"Soft\",\n                types:[\n                    Type\u003c@FindLeaseMarketSale.SaleItem\u003e(),\n                    Type\u003c@FindLeaseMarketAuctionSoft.SaleItem\u003e(),\n                    Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItem\u003e()\n                ],\n                ruleType: \"listing\",\n                allow:true\n            )\n        ]\n\n        defaultRules.append(\n            FindMarket.TenantRule(\n                name: nftName,\n                types:[CompositeType(nftType)!],\n                ruleType: \"nft\",\n                allow:true\n            )\n        )\n\n        var royalty : MetadataViews.Royalty? = nil\n        if cut != 0.0 {\n            royalty = MetadataViews.Royalty(\n                receiver: account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(FungibleTokenSwitchboard.ReceiverPublicPath),\n                cut: cut,\n                description: \"tenant\"\n            )\n        }\n\n        let saleItem = FindMarket.TenantSaleItem(\n            name: \"Dapper\".concat(nftName).concat(\"Soft\"),\n            cut: royalty,\n            rules: defaultRules,\n            status: \"active\"\n        )\n\n        let clientRef = account.borrow\u003c\u0026FindMarket.TenantClient\u003e(from: FindMarket.TenantClientStoragePath) ?? panic(\"Cannot borrow Tenant Client Reference.\")\n        clientRef.setMarketOption(saleItem: saleItem)\n    }\n}",
               "spec": {
                  "order": [
                     "nftName",
                     "nftType",
                     "cut"
                  ],
                  "parameters": {
                     "cut": "UFix64",
                     "nftName": "String",
                     "nftType": "String"
                  }
               }
            },
            "tenantsetMarketOptionDapper": {
               "code": "import FindMarket from 0x179b6b1cb6755e31\nimport DapperUtilityCoin from 0x01cf0e2f2f715450\nimport FlowUtilityToken from 0x01cf0e2f2f715450\nimport FindMarketSale from 0x179b6b1cb6755e31\nimport FindMarketAuctionSoft from 0x179b6b1cb6755e31\nimport FindMarketDirectOfferSoft from 0x179b6b1cb6755e31\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FungibleTokenSwitchboard from 0xf8d6e0586b0a20c7\n\ntransaction(nftName: String, nftType: String, cut: UFix64){\n    prepare(account: AuthAccount){\n\n        let defaultRules : [FindMarket.TenantRule] = [\n            FindMarket.TenantRule(\n                name: \"Dapper\",\n                types:[\n                    Type\u003c@FlowUtilityToken.Vault\u003e(),\n                    Type\u003c@DapperUtilityCoin.Vault\u003e()\n                ],\n                ruleType: \"ft\",\n                allow:true\n            ),\n            FindMarket.TenantRule(\n                name: \"Soft\",\n                types:[\n                    Type\u003c@FindMarketSale.SaleItem\u003e(),\n                    Type\u003c@FindMarketAuctionSoft.SaleItem\u003e(),\n                    Type\u003c@FindMarketDirectOfferSoft.SaleItem\u003e()\n                ],\n                ruleType: \"listing\",\n                allow:true\n            )\n        ]\n\n        defaultRules.append(\n            FindMarket.TenantRule(\n                name: nftName,\n                types:[CompositeType(nftType)!],\n                ruleType: \"nft\",\n                allow:true\n            )\n        )\n\n        var royalty : MetadataViews.Royalty? = nil\n        if cut != 0.0 {\n            royalty = MetadataViews.Royalty(\n                receiver: account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(FungibleTokenSwitchboard.ReceiverPublicPath),\n                cut: cut,\n                description: \"tenant\"\n            )\n        }\n\n        let saleItem = FindMarket.TenantSaleItem(\n            name: \"Dapper\".concat(nftName).concat(\"Soft\"),\n            cut: royalty,\n            rules: defaultRules,\n            status: \"active\"\n        )\n\n        let clientRef = account.borrow\u003c\u0026FindMarket.TenantClient\u003e(from: FindMarket.TenantClientStoragePath) ?? panic(\"Cannot borrow Tenant Client Reference.\")\n        clientRef.setMarketOption(saleItem: saleItem)\n    }\n}",
               "spec": {
                  "order": [
                     "nftName",
                     "nftType",
                     "cut"
                  ],
                  "parameters": {
                     "cut": "UFix64",
                     "nftName": "String",
                     "nftType": "String"
                  }
               }
            },
            "testInitFUSDVault": {
               "code": "import FungibleToken from 0xee82856bf20e2aa6\nimport FUSD from 0xf8d6e0586b0a20c7\nimport FiatToken from 0xf8d6e0586b0a20c7\n\n\ntransaction() {\n    prepare(account: AuthAccount) {\n        let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n        if !fusdReceiver.check() {\n            let fusd \u003c- FUSD.createEmptyVault()\n            account.save(\u003c- fusd, to: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n        }\n\n    }\n}",
               "spec": {
                  "order": [],
                  "parameters": {}
               }
            },
            "unfollow": {
               "code": "import FIND from 0x179b6b1cb6755e31\nimport Profile from 0x179b6b1cb6755e31\n\n// array of [User in string (find name or address)]\ntransaction(unfollows:[String]) {\n\n    let profile : \u0026Profile.User\n\n    prepare(account: AuthAccount) {\n\n        self.profile =account.borrow\u003c\u0026Profile.User\u003e(from:Profile.storagePath) ?? panic(\"Cannot borrow reference to profile\")\n\n    }\n\n    execute{\n        for key in unfollows {\n            let user = FIND.resolve(key) ?? panic(key.concat(\" cannot be resolved. It is either an invalid .find name or address\"))\n            self.profile.unfollow(user)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "unfollows"
                  ],
                  "parameters": {
                     "unfollows": "[String]"
                  }
               }
            },
            "unlinkDUCVaultReceiver": {
               "code": "import TokenForwarding from 0xf8d6e0586b0a20c7\n\n\ntransaction() {\n    prepare(account: AuthAccount) {\n        account.unlink(/public/dapperUtilityCoinReceiver)\n    }\n}",
               "spec": {
                  "order": [],
                  "parameters": {}
               }
            },
            "updateRelatedAccount": {
               "code": "import FindRelatedAccounts from 0x179b6b1cb6755e31\n\ntransaction(name: String, network: String, oldAddress:String, address: String) {\n\n    var relatedAccounts : \u0026FindRelatedAccounts.Accounts?\n\n    prepare(account: AuthAccount) {\n\n        self.relatedAccounts= account.borrow\u003c\u0026FindRelatedAccounts.Accounts\u003e(from:FindRelatedAccounts.storagePath)\n        if self.relatedAccounts == nil {\n            let relatedAccounts \u003c- FindRelatedAccounts.createEmptyAccounts()\n            account.save(\u003c- relatedAccounts, to: FindRelatedAccounts.storagePath)\n            account.link\u003c\u0026FindRelatedAccounts.Accounts{FindRelatedAccounts.Public}\u003e(FindRelatedAccounts.publicPath, target: FindRelatedAccounts.storagePath)\n            self.relatedAccounts = account.borrow\u003c\u0026FindRelatedAccounts.Accounts\u003e(from:FindRelatedAccounts.storagePath)\n        }\n\n        let cap = account.getCapability\u003c\u0026FindRelatedAccounts.Accounts{FindRelatedAccounts.Public}\u003e(FindRelatedAccounts.publicPath)\n        if !cap.check() {\n            account.unlink(FindRelatedAccounts.publicPath)\n            account.link\u003c\u0026FindRelatedAccounts.Accounts{FindRelatedAccounts.Public}\u003e(FindRelatedAccounts.publicPath, target: FindRelatedAccounts.storagePath)\n        }\n    }\n\n    execute {\n        self.relatedAccounts!.updateRelatedAccount(name:name, network:network, oldAddress: oldAddress, address: address)\n    }\n\n}",
               "spec": {
                  "order": [
                     "name",
                     "network",
                     "oldAddress",
                     "address"
                  ],
                  "parameters": {
                     "address": "String",
                     "name": "String",
                     "network": "String",
                     "oldAddress": "String"
                  }
               }
            },
            "updateRelatedFlowAccount": {
               "code": "import FindRelatedAccounts from 0x179b6b1cb6755e31\n\ntransaction(name: String, oldAddress: Address, address: Address) {\n\n    var relatedAccounts : \u0026FindRelatedAccounts.Accounts?\n\n    prepare(account: AuthAccount) {\n\n        self.relatedAccounts= account.borrow\u003c\u0026FindRelatedAccounts.Accounts\u003e(from:FindRelatedAccounts.storagePath)\n        if self.relatedAccounts == nil {\n            let relatedAccounts \u003c- FindRelatedAccounts.createEmptyAccounts()\n            account.save(\u003c- relatedAccounts, to: FindRelatedAccounts.storagePath)\n            account.link\u003c\u0026FindRelatedAccounts.Accounts{FindRelatedAccounts.Public}\u003e(FindRelatedAccounts.publicPath, target: FindRelatedAccounts.storagePath)\n            self.relatedAccounts = account.borrow\u003c\u0026FindRelatedAccounts.Accounts\u003e(from:FindRelatedAccounts.storagePath)\n        }\n\n        let cap = account.getCapability\u003c\u0026FindRelatedAccounts.Accounts{FindRelatedAccounts.Public}\u003e(FindRelatedAccounts.publicPath)\n        if !cap.check() {\n            account.unlink(FindRelatedAccounts.publicPath)\n            account.link\u003c\u0026FindRelatedAccounts.Accounts{FindRelatedAccounts.Public}\u003e(FindRelatedAccounts.publicPath, target: FindRelatedAccounts.storagePath)\n        }\n    }\n\n    execute {\n        self.relatedAccounts!.updateFlowAccount(name:name, oldAddress: oldAddress, address: address)\n    }\n\n}",
               "spec": {
                  "order": [
                     "name",
                     "oldAddress",
                     "address"
                  ],
                  "parameters": {
                     "address": "Address",
                     "name": "String",
                     "oldAddress": "Address"
                  }
               }
            }
         }
      },
      "mainnet": {
         "scripts": {
            "batchParty": {
               "code": "import MetadataViews from  0x1d7e57aa55817448\nimport PartyFavorz from 0x123cb666996b8432\n\npub fun main(users:[Address]) : AnyStruct {\n\n    let viewType= Type\u003cMetadataViews.Display\u003e()\n\n    let addressNames : {Address : [String]} = {}\n    let addresses:  {Address: [String] }={}\n    for  user in users {\n        let account=getAccount(user)\n        let aeraCap = account.getCapability\u003c\u0026PartyFavorz.Collection{MetadataViews.ResolverCollection}\u003e(\n            PartyFavorz.CollectionPublicPath\n        )\n        if !aeraCap.check() {\n            continue\n        }\n        let ref = aeraCap.borrow()!\n        let names : [String] = []\n        for id in ref.getIDs() {\n            let resolver=ref.borrowViewResolver(id: id)\n            if let display = MetadataViews.getDisplay(resolver) {\n                names.append(display.name)\n            }\n        }\n\n        addressNames[user]=names\n    }\n    return addressNames\n}",
               "spec": {
                  "order": [
                     "users"
                  ],
                  "parameters": {
                     "users": "[Address]"
                  }
               }
            },
            "getAlchemy1IDs": {
               "code": "import MetadataViews from 0x1d7e57aa55817448\nimport FIND from 0x097bafa4e0b48eef\nimport FINDNFTCatalog from 0x097bafa4e0b48eef\n// /* Alchemy Mainnet Wrapper */\nimport AlchemyMetadataWrapperMainnetShard1 from 0xeb8cb4c3157d5dac\n// import AlchemyMetadataWrapperMainnetShard2 from 0xeb8cb4c3157d5dac\n// import AlchemyMetadataWrapperMainnetShard3 from 0xeb8cb4c3157d5dac\n// import AlchemyMetadataWrapperMainnetShard4 from 0xeb8cb4c3157d5dac\n\n// /* Alchemy Testnet Wrapper */\n\n// import AlchemyMetadataWrapperTestnetShard1 from 0x5ff2c7b4c40de11\n// import AlchemyMetadataWrapperTestnetShard2 from 0x5ff2c7b4c40de11\n// import AlchemyMetadataWrapperTestnetShard3 from 0x5ff2c7b4c40de11\n\n\n\n\n    pub fun main(user: String, collections: [String]) : {String : ItemReport}  {\n        return fetchAlchemyShard1(user: user, targetCollections:collections)\n    }\n\n    pub let NFTCatalogContracts : [String] = getNFTCatalogContracts()\n\n    pub struct ItemReport {\n        pub let length : Int // mapping of collection to no. of ids \n        pub let extraIDs : [UInt64]\n        pub let shard : String \n        pub let extraIDsIdentifier : String \n        pub let collectionName: String\n\n        init(length : Int, extraIDs :[UInt64] , shard: String, extraIDsIdentifier: String, collectionName: String) {\n            self.length=length \n            self.extraIDs=extraIDs\n            self.shard=shard\n            self.extraIDsIdentifier=extraIDsIdentifier\n            self.collectionName=collectionName\n        }\n    }\n\n    // Helper function \n\n    pub fun resolveAddress(user: String) : Address? {\n        return FIND.resolve(user)\n    }\n\n    pub fun getNFTCatalogContracts() : [String] {\n        let catalogs = FINDNFTCatalog.getCatalog()\n        let names : [String] = []\n        for catalog in catalogs.values {\n            names.append(catalog.contractName)\n        }\n        return names\n    }\n\n    pub fun fetchAlchemyShard1(user: String, targetCollections: [String]) : {String : ItemReport} {\n        let source = \"Shard1\"\n        let account = resolveAddress(user: user)\n        if account == nil { return {} }\n\n\n        let extraIDs = AlchemyMetadataWrapperMainnetShard1.getNFTIDs(ownerAddress: account!)\n        let inventory : {String : ItemReport} = {}\n        var fetchedCount : Int = 0\n\n        for project in extraIDs.keys {\n\n            if extraIDs[project]! == nil || extraIDs[project]!.length \u003c 1{\n                extraIDs.remove(key: project)\n                continue\n            }\n            \n            let collectionLength = extraIDs[project]!.length\n\n            // by pass if this is not the target collection\n            if targetCollections.length \u003e 0 \u0026\u0026 !targetCollections.contains(project) {\n                // inventory[project] = ItemReport(items: [],  length : collectionLength, extraIDs :extraIDs[project]! , shard: source)\n                continue\n            }\n\n            let contractItem = AlchemyMetadataWrapperMainnetShard1.getNFTs(ownerAddress: account!, ids: {project : [extraIDs[project]![0]]})\n            if contractItem.length \u003e 0 \u0026\u0026 contractItem[0] != nil {\n                if NFTCatalogContracts.contains(contractItem[0]!.contract.name) {\n                    continue\n                }\n            }\n\n            inventory[project] = ItemReport(length : collectionLength, extraIDs :extraIDs[project] ?? [] , shard: source, extraIDsIdentifier: project, collectionName: contractItem[0]?.contract?.name ?? project)\n\n        }\n\n        return inventory\n\n    }",
               "spec": {
                  "order": [
                     "user",
                     "collections"
                  ],
                  "parameters": {
                     "collections": "[String]",
                     "user": "String"
                  }
               }
            },
            "getAlchemy1Items": {
               "code": "import MetadataViews from 0x1d7e57aa55817448\nimport FIND from 0x097bafa4e0b48eef\n\n// /* Alchemy Mainnet Wrapper */\nimport AlchemyMetadataWrapperMainnetShard1 from 0xeb8cb4c3157d5dac\n// import AlchemyMetadataWrapperMainnetShard2 from 0xeb8cb4c3157d5dac\n// import AlchemyMetadataWrapperMainnetShard3 from 0xeb8cb4c3157d5dac\n// import AlchemyMetadataWrapperMainnetShard4 from 0xeb8cb4c3157d5dac\n\n// /* Alchemy Testnet Wrapper */\n\n// import AlchemyMetadataWrapperTestnetShard1 from 0x5ff2c7b4c40de11\n// import AlchemyMetadataWrapperTestnetShard2 from 0x5ff2c7b4c40de11\n// import AlchemyMetadataWrapperTestnetShard3 from 0x5ff2c7b4c40de11\n\npub fun main(user: String, collectionIDs: {String : [UInt64]}) : {String : [MetadataCollectionItem]} {\n    return fetchAlchemyCollectionShard1(user: user, collectionIDs: collectionIDs)\n}\n\n    pub struct CollectionReport {\n        pub let items : {String : [MetadataCollectionItem]} \n        pub let collections : {String : Int} // mapping of collection to no. of ids \n        pub let extraIDs : {String : [UInt64]} \n\n        init(items: {String : [MetadataCollectionItem]},  collections : {String : Int}, extraIDs : {String : [UInt64]} ) {\n            self.items=items \n            self.collections=collections \n            self.extraIDs=extraIDs\n        }\n    }\n\n    pub struct MetadataCollectionItem {\n        pub let id:UInt64\n        pub let name: String\n        pub let collection: String // \u003c- This will be Alias unless they want something else\n        pub let subCollection: String? // \u003c- This will be Alias unless they want something else\n        pub let nftDetailIdentifier: String\n\n        pub let media  : String\n        pub let mediaType : String \n        pub let source : String \n\n        init(id:UInt64, name: String, collection: String, subCollection: String?, media  : String, mediaType : String, source : String, nftDetailIdentifier: String) {\n            self.id=id\n            self.name=name \n            self.collection=collection \n            self.subCollection=subCollection \n            self.media=media \n            self.mediaType=mediaType \n            self.source=source\n            self.nftDetailIdentifier=nftDetailIdentifier\n        }\n    }\n\n    // Helper function \n\n    pub fun resolveAddress(user: String) : PublicAccount? {\n        let address = FIND.resolve(user)\n        if address == nil {\n            return nil\n        }\n        return getAccount(address!)\n    }\n\n        \n    //////////////////////////////////////////////////////////////\n    // Fetch Specific Collections in Shard 1\n    //////////////////////////////////////////////////////////////\n    pub fun fetchAlchemyCollectionShard1(user: String, collectionIDs: {String : [UInt64]}) : {String : [MetadataCollectionItem]} {\n        let source = \"Shard1\"\n        let account = resolveAddress(user: user)\n        if account == nil { return {} }\n        if account!.balance == 0.0 {\n            return {}\n        }\n\n        let items : {String : [MetadataCollectionItem]} = {}\n        \n        let fetchingIDs = collectionIDs\n\n        for project in fetchingIDs.keys {\n            // For passing bugs\n            if project == \"Xtingles_NFT\" {\n                fetchingIDs[\"Xtingles\"] = fetchingIDs.remove(key: project)\n            }\n\n            if project == \"RCRDSHPNFT\" {\n                fetchingIDs.remove(key: project)\n            }\n        }\n\n        for project in fetchingIDs.keys {\n            let returnedNFTs = AlchemyMetadataWrapperMainnetShard1.getNFTs(ownerAddress: account!.address, ids: {project : fetchingIDs[project]!})\n\n            var collectionItems : [MetadataCollectionItem] = []\n            for nft in returnedNFTs {\n                if nft == nil {\n                    continue\n                }\n\n                var media = \"\"\n                var mediaType = \"\"\n                if nft!.media.length \u003e 0 \u0026\u0026 nft!.media[0]?.uri != nil {\n                    let m = nft!.media[0]!\n                    mediaType = m.mimetype ?? \"\"\n                    media = m.uri!\n                }\n\n                let item = MetadataCollectionItem(\n                    id: nft!.id,\n                    name: nft!.title ?? \"\",\n                    collection: project,\n                    subCollection: nil, \n                    media: media,\n                    mediaType: mediaType,\n                    source: source, \n                    nftDetailIdentifier: project \n                )\n                collectionItems.append(item)\n            }\n\n            if collectionItems.length \u003e 0 {\n                items[project] = collectionItems\n            }\n        }\n        return items\n    }",
               "spec": {
                  "order": [
                     "user",
                     "collectionIDs"
                  ],
                  "parameters": {
                     "collectionIDs": "{String: [UInt64]}",
                     "user": "String"
                  }
               }
            },
            "getAlchemy2IDs": {
               "code": "import MetadataViews from 0x1d7e57aa55817448\nimport FIND from 0x097bafa4e0b48eef\nimport FINDNFTCatalog from 0x097bafa4e0b48eef\nimport FindUtils from 0x097bafa4e0b48eef\n// /* Alchemy Mainnet Wrapper */\n// import AlchemyMetadataWrapperMainnetShard1 from 0xeb8cb4c3157d5dac\nimport AlchemyMetadataWrapperMainnetShard2 from 0xeb8cb4c3157d5dac\n// import AlchemyMetadataWrapperMainnetShard3 from 0xeb8cb4c3157d5dac\n// import AlchemyMetadataWrapperMainnetShard4 from 0xeb8cb4c3157d5dac\n\n// /* Alchemy Testnet Wrapper */\n\n// import AlchemyMetadataWrapperTestnetShard1 from 0x5ff2c7b4c40de11\n// import AlchemyMetadataWrapperTestnetShard2 from 0x5ff2c7b4c40de11\n// import AlchemyMetadataWrapperTestnetShard3 from 0x5ff2c7b4c40de11\n\n\n\n\n    pub fun main(user: String, collections: [String]) : {String : ItemReport} {\n        return fetchAlchemyShard2(user: user, targetCollections:collections)\n    }\n\n    pub let NFTCatalogContracts : [String] = getNFTCatalogContracts()\n\n    pub struct ItemReport {\n        pub let length : Int // mapping of collection to no. of ids\n        pub let extraIDs : [UInt64]\n        pub let shard : String\n        pub let extraIDsIdentifier : String\n        pub let collectionName: String\n\n        init(length : Int, extraIDs :[UInt64] , shard: String, extraIDsIdentifier: String, collectionName: String) {\n            self.length=length\n            self.extraIDs=extraIDs\n            self.shard=shard\n            self.extraIDsIdentifier=extraIDsIdentifier\n            self.collectionName=collectionName\n        }\n    }\n\n    // Helper function\n\n    pub fun resolveAddress(user: String) : Address? {\n        return FIND.resolve(user)\n    }\n\n    pub fun getNFTCatalogContracts() : [String] {\n        let catalogs = FINDNFTCatalog.getCatalog()\n        let names : [String] = []\n        for catalog in catalogs.values {\n            names.append(catalog.contractName)\n        }\n        return names\n    }\n\n    pub fun fetchAlchemyShard2(user: String, targetCollections: [String]) : {String : ItemReport} {\n        let source = \"Shard2\"\n        let account = resolveAddress(user: user)\n        if account == nil { return {} }\n\n\n        let extraIDs = AlchemyMetadataWrapperMainnetShard2.getNFTIDs(ownerAddress: account!)\n        let inventory : {String : ItemReport} = {}\n        var fetchedCount : Int = 0\n\n        for project in extraIDs.keys {\n            if extraIDs[project]! == nil || extraIDs[project]!.length \u003c 1{\n                extraIDs.remove(key: project)\n                continue\n            }\n\n            let collectionLength = extraIDs[project]!.length\n\n            // by pass if this is not the target collection\n            if targetCollections.length \u003e 0 \u0026\u0026 !targetCollections.contains(project) {\n                // inventory[project] = ItemReport(items: [],  length : collectionLength, extraIDs :extraIDs[project]! , shard: source)\n                continue\n            }\n\n            let contractItem = AlchemyMetadataWrapperMainnetShard2.getNFTs(ownerAddress: account!, ids: {rename(project) : [extraIDs[project]![0]]})\n            if contractItem.length \u003e 0 \u0026\u0026 contractItem[0] != nil {\n                if NFTCatalogContracts.contains(contractItem[0]!.contract.name) {\n                    continue\n                }\n            }\n\n            inventory[project] = ItemReport(length : collectionLength, extraIDs :extraIDs[project] ?? [] , shard: source, extraIDsIdentifier: rename(project), collectionName: contractItem[0]?.contract?.name ?? project)\n\n        }\n\n        return inventory\n\n    }\n\n    pub fun rename(_ name: String) : String {\n\n        if FindUtils.contains(name, element: \"MintStoreItem\") {\n            return \"MintStoreItem\"\n        }\n        return name\n\n    }",
               "spec": {
                  "order": [
                     "user",
                     "collections"
                  ],
                  "parameters": {
                     "collections": "[String]",
                     "user": "String"
                  }
               }
            },
            "getAlchemy2Items": {
               "code": "import MetadataViews from 0x1d7e57aa55817448\nimport FIND from 0x097bafa4e0b48eef\nimport FindUtils from 0x097bafa4e0b48eef\n\n// /* Alchemy Mainnet Wrapper */\n// import AlchemyMetadataWrapperMainnetShard1 from 0xeb8cb4c3157d5dac\nimport AlchemyMetadataWrapperMainnetShard2 from 0xeb8cb4c3157d5dac\n// import AlchemyMetadataWrapperMainnetShard3 from 0xeb8cb4c3157d5dac\n// import AlchemyMetadataWrapperMainnetShard4 from 0xeb8cb4c3157d5dac\n\n// /* Alchemy Testnet Wrapper */\n\n// import AlchemyMetadataWrapperTestnetShard1 from 0x5ff2c7b4c40de11\n// import AlchemyMetadataWrapperTestnetShard2 from 0x5ff2c7b4c40de11\n// import AlchemyMetadataWrapperTestnetShard3 from 0x5ff2c7b4c40de11\n\npub fun main(user: String, collectionIDs: {String : [UInt64]}) : {String : [MetadataCollectionItem]} {\n    return fetchAlchemyCollectionShard2(user: user, collectionIDs: collectionIDs)\n}\n\n    pub struct CollectionReport {\n        pub let items : {String : [MetadataCollectionItem]}\n        pub let collections : {String : Int} // mapping of collection to no. of ids\n        pub let extraIDs : {String : [UInt64]}\n\n        init(items: {String : [MetadataCollectionItem]},  collections : {String : Int}, extraIDs : {String : [UInt64]} ) {\n            self.items=items\n            self.collections=collections\n            self.extraIDs=extraIDs\n        }\n    }\n\n    pub struct MetadataCollectionItem {\n        pub let id:UInt64\n        pub let name: String\n        pub let collection: String // \u003c- This will be Alias unless they want something else\n        pub let subCollection: String? // \u003c- This will be Alias unless they want something else\n        pub let nftDetailIdentifier: String\n\n        pub let media  : String\n        pub let mediaType : String\n        pub let source : String\n\n        init(id:UInt64, name: String, collection: String, subCollection: String?, media  : String, mediaType : String, source : String, nftDetailIdentifier: String) {\n            self.id=id\n            self.name=name\n            self.collection=collection\n            self.subCollection=subCollection\n            self.media=media\n            self.mediaType=mediaType\n            self.source=source\n            self.nftDetailIdentifier=nftDetailIdentifier\n        }\n    }\n\n    // Helper function\n\n    pub fun resolveAddress(user: String) : PublicAccount? {\n        let address = FIND.resolve(user)\n        if address == nil {\n            return nil\n        }\n        return getAccount(address!)\n    }\n\n\n    ////////////////////////////////////////////////////////////\n    // Fetch Specific Collections in Shard 2\n    ////////////////////////////////////////////////////////////\n    pub fun fetchAlchemyCollectionShard2(user: String, collectionIDs: {String : [UInt64]}) : {String : [MetadataCollectionItem]} {\n        let source = \"Shard2\"\n        let account = resolveAddress(user: user)\n        if account == nil { return {} }\n        if account!.balance == 0.0 {\n            return {}\n        }\n\n        let items : {String : [MetadataCollectionItem]} = {}\n\n        let fetchingIDs = collectionIDs\n\n        for project in fetchingIDs.keys {\n            // For passing bugs\n            if project == \"Xtingles_NFT\" {\n                fetchingIDs[\"Xtingles\"] = fetchingIDs.remove(key: project)\n            }\n\n            if project == \"RCRDSHPNFT\" {\n                fetchingIDs.remove(key: project)\n            }\n        }\n\n        for project in fetchingIDs.keys {\n            let returnedNFTs = AlchemyMetadataWrapperMainnetShard2.getNFTs(ownerAddress: account!.address, ids: {rename(project) : fetchingIDs[project]!})\n\n            var collectionItems : [MetadataCollectionItem] = []\n            for nft in returnedNFTs {\n                if nft == nil {\n                    continue\n                }\n\n                var media = \"\"\n                var mediaType = \"\"\n                if nft!.media.length \u003e 0 \u0026\u0026 nft!.media[0]?.uri != nil {\n                    let m = nft!.media[0]!\n                    mediaType = m.mimetype ?? \"\"\n                    media = m.uri!\n                }\n\n                let item = MetadataCollectionItem(\n                    id: nft!.id,\n                    name: nft!.title ?? \"\",\n                    collection: project,\n                    subCollection: nil,\n                    media: media,\n                    mediaType: mediaType,\n                    source: source,\n                    nftDetailIdentifier: project\n                )\n                collectionItems.append(item)\n            }\n\n            if collectionItems.length \u003e 0 {\n                items[project] = collectionItems\n            }\n        }\n        return items\n    }\n\n\n    pub fun rename(_ name: String) : String {\n\n        if FindUtils.contains(name, element: \"MintStoreItem\") {\n            return \"MintStoreItem\"\n        }\n        return name\n\n    }",
               "spec": {
                  "order": [
                     "user",
                     "collectionIDs"
                  ],
                  "parameters": {
                     "collectionIDs": "{String: [UInt64]}",
                     "user": "String"
                  }
               }
            },
            "getAlchemy3IDs": {
               "code": "import MetadataViews from 0x1d7e57aa55817448\nimport FIND from 0x097bafa4e0b48eef\nimport FINDNFTCatalog from 0x097bafa4e0b48eef\n// /* Alchemy Mainnet Wrapper */\n// import AlchemyMetadataWrapperMainnetShard1 from 0xeb8cb4c3157d5dac\n// import AlchemyMetadataWrapperMainnetShard2 from 0xeb8cb4c3157d5dac\nimport AlchemyMetadataWrapperMainnetShard3 from 0xeb8cb4c3157d5dac\n// import AlchemyMetadataWrapperMainnetShard4 from 0xeb8cb4c3157d5dac\n\n// /* Alchemy Testnet Wrapper */\n\n// import AlchemyMetadataWrapperTestnetShard1 from 0x5ff2c7b4c40de11\n// import AlchemyMetadataWrapperTestnetShard2 from 0x5ff2c7b4c40de11\n// import AlchemyMetadataWrapperTestnetShard3 from 0x5ff2c7b4c40de11\n\n    pub fun main(user: String, collections: [String]) : {String : ItemReport} {\n        return fetchAlchemyShard3(user: user, targetCollections:collections)\n    }\n\n    pub let NFTCatalogContracts : [String] = getNFTCatalogContracts()\n\n    pub struct ItemReport {\n        pub let length : Int // mapping of collection to no. of ids \n        pub let extraIDs : [UInt64]\n        pub let shard : String \n        pub let extraIDsIdentifier : String \n        pub let collectionName: String\n\n        init(length : Int, extraIDs :[UInt64] , shard: String, extraIDsIdentifier: String, collectionName: String) {\n            self.length=length \n            self.extraIDs=extraIDs\n            self.shard=shard\n            self.extraIDsIdentifier=extraIDsIdentifier\n            self.collectionName=collectionName\n        }\n    }\n\n    // Helper function \n\n    pub fun resolveAddress(user: String) : Address? {\n        return FIND.resolve(user)\n    }\n\n    pub fun getNFTCatalogContracts() : [String] {\n        let catalogs = FINDNFTCatalog.getCatalog()\n        let names : [String] = []\n        for catalog in catalogs.values {\n            names.append(catalog.contractName)\n        }\n        return names\n    }\n            \n    pub fun fetchAlchemyShard3(user: String, targetCollections: [String]) : {String : ItemReport} {\n        let source = \"Shard3\"\n        let account = resolveAddress(user: user)\n        if account == nil { return {} }\n\n\n        let extraIDs = AlchemyMetadataWrapperMainnetShard3.getNFTIDs(ownerAddress: account!)\n        let inventory : {String : ItemReport} = {}\n        var fetchedCount : Int = 0\n\n        for project in extraIDs.keys {\n            if extraIDs[project]! == nil || extraIDs[project]!.length \u003c 1{\n                extraIDs.remove(key: project)\n                continue\n            }\n            \n            let collectionLength = extraIDs[project]!.length\n\n            // by pass if this is not the target collection\n            if targetCollections.length \u003e 0 \u0026\u0026 !targetCollections.contains(project) {\n                // inventory[project] = ItemReport(items: [],  length : collectionLength, extraIDs :extraIDs[project]! , shard: source)\n                continue\n            }\n\n            let contractItem = AlchemyMetadataWrapperMainnetShard3.getNFTs(ownerAddress: account!, ids: {project : [extraIDs[project]![0]]})\n            if contractItem.length \u003e 0 \u0026\u0026 contractItem[0] != nil {\n                if NFTCatalogContracts.contains(contractItem[0]!.contract.name) {\n                    continue\n                }\n            }\n\n            inventory[project] = ItemReport(length : collectionLength, extraIDs :extraIDs[project] ?? [] , shard: source, extraIDsIdentifier: project, collectionName: contractItem[0]?.contract?.name ?? project)\n\n        }\n\n        return inventory\n\n    }",
               "spec": {
                  "order": [
                     "user",
                     "collections"
                  ],
                  "parameters": {
                     "collections": "[String]",
                     "user": "String"
                  }
               }
            },
            "getAlchemy3Items": {
               "code": "import MetadataViews from 0x1d7e57aa55817448\nimport FIND from 0x097bafa4e0b48eef\n\n// /* Alchemy Mainnet Wrapper */\n// import AlchemyMetadataWrapperMainnetShard1 from 0xeb8cb4c3157d5dac\n// import AlchemyMetadataWrapperMainnetShard2 from 0xeb8cb4c3157d5dac\nimport AlchemyMetadataWrapperMainnetShard3 from 0xeb8cb4c3157d5dac\n// import AlchemyMetadataWrapperMainnetShard4 from 0xeb8cb4c3157d5dac\n\n// /* Alchemy Testnet Wrapper */\n\n// import AlchemyMetadataWrapperTestnetShard1 from 0x5ff2c7b4c40de11\n// import AlchemyMetadataWrapperTestnetShard2 from 0x5ff2c7b4c40de11\n// import AlchemyMetadataWrapperTestnetShard3 from 0x5ff2c7b4c40de11\n\npub fun main(user: String, collectionIDs: {String : [UInt64]}) : {String : [MetadataCollectionItem]} {\n    return fetchAlchemyCollectionShard3(user: user, collectionIDs: collectionIDs)\n}\n\n    pub struct CollectionReport {\n        pub let items : {String : [MetadataCollectionItem]} \n        pub let collections : {String : Int} // mapping of collection to no. of ids \n        pub let extraIDs : {String : [UInt64]} \n\n        init(items: {String : [MetadataCollectionItem]},  collections : {String : Int}, extraIDs : {String : [UInt64]} ) {\n            self.items=items \n            self.collections=collections \n            self.extraIDs=extraIDs\n        }\n    }\n\n    pub struct MetadataCollectionItem {\n        pub let id:UInt64\n        pub let name: String\n        pub let collection: String // \u003c- This will be Alias unless they want something else\n        pub let subCollection: String? // \u003c- This will be Alias unless they want something else\n        pub let nftDetailIdentifier: String\n\n        pub let media  : String\n        pub let mediaType : String \n        pub let source : String \n\n        init(id:UInt64, name: String, collection: String, subCollection: String?, media  : String, mediaType : String, source : String, nftDetailIdentifier: String) {\n            self.id=id\n            self.name=name \n            self.collection=collection \n            self.subCollection=subCollection \n            self.media=media \n            self.mediaType=mediaType \n            self.source=source\n            self.nftDetailIdentifier=nftDetailIdentifier\n        }\n    }\n\n    // Helper function \n\n    pub fun resolveAddress(user: String) : PublicAccount? {\n        let address = FIND.resolve(user)\n        if address == nil {\n            return nil\n        }\n        return getAccount(address!)\n    }\n\n\n    //////////////////////////////////////////////////////////////\n    // Fetch Specific Collections in Shard 3\n    //////////////////////////////////////////////////////////////\n    pub fun fetchAlchemyCollectionShard3(user: String, collectionIDs: {String : [UInt64]}) : {String : [MetadataCollectionItem]} {\n        let source = \"Shard3\"\n        let account = resolveAddress(user: user)\n        if account == nil { return {} }\n        if account!.balance == 0.0 {\n            return {}\n        }\n        \n        let items : {String : [MetadataCollectionItem]} = {}\n        \n        let fetchingIDs = collectionIDs\n\n        for project in fetchingIDs.keys {\n            // For passing bugs\n            if project == \"Xtingles_NFT\" {\n                fetchingIDs[\"Xtingles\"] = fetchingIDs.remove(key: project)\n            }\n\n            if project == \"RCRDSHPNFT\" {\n                fetchingIDs.remove(key: project)\n            }\n        }\n\n        for project in fetchingIDs.keys {\n            let returnedNFTs = AlchemyMetadataWrapperMainnetShard3.getNFTs(ownerAddress: account!.address, ids: {project : fetchingIDs[project]!})\n\n            var collectionItems : [MetadataCollectionItem] = []\n            for nft in returnedNFTs {\n                if nft == nil {\n                    continue\n                }\n\n                var media = \"\"\n                var mediaType = \"\"\n                if nft!.media.length \u003e 0 \u0026\u0026 nft!.media[0]?.uri != nil {\n                    let m = nft!.media[0]!\n                    mediaType = m.mimetype ?? \"\"\n                    media = m.uri!\n                }\n\n                let item = MetadataCollectionItem(\n                    id: nft!.id,\n                    name: nft!.title ?? \"\",\n                    collection: project,\n                    subCollection: nil, \n                    media: media,\n                    mediaType: mediaType,\n                    source: source, \n                    nftDetailIdentifier: project \n                )\n                collectionItems.append(item)\n            }\n\n            if collectionItems.length \u003e 0 {\n                items[project] = collectionItems\n            }\n        }\n        return items\n    }",
               "spec": {
                  "order": [
                     "user",
                     "collectionIDs"
                  ],
                  "parameters": {
                     "collectionIDs": "{String: [UInt64]}",
                     "user": "String"
                  }
               }
            },
            "getAlchemy4IDs": {
               "code": "import MetadataViews from 0x1d7e57aa55817448\nimport FIND from 0x097bafa4e0b48eef\nimport FINDNFTCatalog from 0x097bafa4e0b48eef\n// /* Alchemy Mainnet Wrapper */\n// import AlchemyMetadataWrapperMainnetShard1 from 0xeb8cb4c3157d5dac\n// import AlchemyMetadataWrapperMainnetShard2 from 0xeb8cb4c3157d5dac\n// import AlchemyMetadataWrapperMainnetShard3 from 0xeb8cb4c3157d5dac\nimport AlchemyMetadataWrapperMainnetShard4 from 0xeb8cb4c3157d5dac\n\n// /* Alchemy Testnet Wrapper */\n\n// import AlchemyMetadataWrapperTestnetShard1 from 0x5ff2c7b4c40de11\n// import AlchemyMetadataWrapperTestnetShard2 from 0x5ff2c7b4c40de11\n// import AlchemyMetadataWrapperTestnetShard3 from 0x5ff2c7b4c40de11\n\n    pub fun main(user: String, collections: [String]) : {String : ItemReport}  {\n        return fetchAlchemyShard4(user: user, targetCollections:collections)\n    }\n\n    pub let NFTCatalogContracts : [String] = getNFTCatalogContracts()\n\n    pub struct ItemReport {\n        pub let length : Int // mapping of collection to no. of ids \n        pub let extraIDs : [UInt64]\n        pub let shard : String \n        pub let extraIDsIdentifier : String \n        pub let collectionName: String\n\n        init(length : Int, extraIDs :[UInt64] , shard: String, extraIDsIdentifier: String, collectionName: String) {\n            self.length=length \n            self.extraIDs=extraIDs\n            self.shard=shard\n            self.extraIDsIdentifier=extraIDsIdentifier\n            self.collectionName=collectionName\n        }\n    }\n\n    // Helper function \n\n    pub fun resolveAddress(user: String) : Address? {\n        return FIND.resolve(user)\n    }\n\n    pub fun getNFTCatalogContracts() : [String] {\n        let catalogs = FINDNFTCatalog.getCatalog()\n        let names : [String] = []\n        for catalog in catalogs.values {\n            names.append(catalog.contractName)\n        }\n        return names\n    }\n\n    pub fun fetchAlchemyShard4(user: String, targetCollections: [String]) : {String : ItemReport} {\n        let source = \"Shard4\"\n        let account = resolveAddress(user: user)\n        if account == nil { return {} }\n\n\n        let extraIDs = AlchemyMetadataWrapperMainnetShard4.getNFTIDs(ownerAddress: account!)\n        let inventory : {String : ItemReport} = {}\n        var fetchedCount : Int = 0\n\n        // For by-passing bugs\n\n        if extraIDs[\"MintStoreItem.NBA ALL STAR \"] != nil { // who the hell put a space at the end of the string\n            extraIDs[\"MintStoreItem\"] = extraIDs.remove(key: \"MintStoreItem.NBA ALL STAR \")\n        }\n\n\n        for project in extraIDs.keys {\n            if extraIDs[project]! == nil || extraIDs[project]!.length \u003c 1{\n                extraIDs.remove(key: project)\n                continue\n            }\n\n            if project == \"RCRDSHPNFT\" {\n                continue\n            }\n            \n            let collectionLength = extraIDs[project]!.length\n\n            // by pass if this is not the target collection\n            if targetCollections.length \u003e 0 \u0026\u0026 !targetCollections.contains(project) {\n                // inventory[project] = ItemReport(items: [],  length : collectionLength, extraIDs :extraIDs[project]! , shard: source)\n                continue\n            }\n\n           let contractItem = AlchemyMetadataWrapperMainnetShard4.getNFTs(ownerAddress: account!, ids: {project : [extraIDs[project]![0]]})\n            if contractItem.length \u003e 0 \u0026\u0026 contractItem[0] != nil {\n                if NFTCatalogContracts.contains(contractItem[0]!.contract.name) {\n                    continue\n                }\n            }\n\n            inventory[project] = ItemReport(length : collectionLength, extraIDs :extraIDs[project] ?? [] , shard: source, extraIDsIdentifier: project, collectionName: contractItem[0]?.contract?.name ?? project)\n\n        }\n\n        return inventory\n\n    }",
               "spec": {
                  "order": [
                     "user",
                     "collections"
                  ],
                  "parameters": {
                     "collections": "[String]",
                     "user": "String"
                  }
               }
            },
            "getAlchemy4Items": {
               "code": "import MetadataViews from 0x1d7e57aa55817448\nimport FIND from 0x097bafa4e0b48eef\n\n// /* Alchemy Mainnet Wrapper */\n// import AlchemyMetadataWrapperMainnetShard1 from 0xeb8cb4c3157d5dac\n// import AlchemyMetadataWrapperMainnetShard2 from 0xeb8cb4c3157d5dac\n// import AlchemyMetadataWrapperMainnetShard3 from 0xeb8cb4c3157d5dac\nimport AlchemyMetadataWrapperMainnetShard4 from 0xeb8cb4c3157d5dac\n\n// /* Alchemy Testnet Wrapper */\n\n// import AlchemyMetadataWrapperTestnetShard1 from 0x5ff2c7b4c40de11\n// import AlchemyMetadataWrapperTestnetShard2 from 0x5ff2c7b4c40de11\n// import AlchemyMetadataWrapperTestnetShard3 from 0x5ff2c7b4c40de11\n\npub fun main(user: String, collectionIDs: {String : [UInt64]}) : {String : [MetadataCollectionItem]} {\n    return fetchAlchemyCollectionShard4(user: user, collectionIDs: collectionIDs)\n}\n\n    pub struct CollectionReport {\n        pub let items : {String : [MetadataCollectionItem]} \n        pub let collections : {String : Int} // mapping of collection to no. of ids \n        pub let extraIDs : {String : [UInt64]} \n\n        init(items: {String : [MetadataCollectionItem]},  collections : {String : Int}, extraIDs : {String : [UInt64]} ) {\n            self.items=items \n            self.collections=collections \n            self.extraIDs=extraIDs\n        }\n    }\n\n    pub struct MetadataCollectionItem {\n        pub let id:UInt64\n        pub let name: String\n        pub let collection: String // \u003c- This will be Alias unless they want something else\n        pub let subCollection: String? // \u003c- This will be Alias unless they want something else\n        pub let nftDetailIdentifier: String\n\n        pub let media  : String\n        pub let mediaType : String \n        pub let source : String \n\n        init(id:UInt64, name: String, collection: String, subCollection: String?, media  : String, mediaType : String, source : String, nftDetailIdentifier: String) {\n            self.id=id\n            self.name=name \n            self.collection=collection \n            self.subCollection=subCollection \n            self.media=media \n            self.mediaType=mediaType \n            self.source=source\n            self.nftDetailIdentifier=nftDetailIdentifier\n        }\n    }\n\n    // Helper function \n\n    pub fun resolveAddress(user: String) : PublicAccount? {\n        let address = FIND.resolve(user)\n        if address == nil {\n            return nil\n        }\n        return getAccount(address!)\n    }\n\n        \n    //////////////////////////////////////////////////////////////\n    // Fetch Specific Collections in Shard 4\n    //////////////////////////////////////////////////////////////\n    pub fun fetchAlchemyCollectionShard4(user: String, collectionIDs: {String : [UInt64]}) : {String : [MetadataCollectionItem]} {\n        let source = \"Shard4\"\n        let account = resolveAddress(user: user)\n        if account == nil { return {} }\n        if account!.balance == 0.0 {\n            return {}\n        }\n        \n        let items : {String : [MetadataCollectionItem]} = {}\n        \n        let fetchingIDs = collectionIDs\n\n        for project in fetchingIDs.keys {\n            // For passing bugs\n            if project == \"Xtingles_NFT\" {\n                fetchingIDs[\"Xtingles\"] = fetchingIDs.remove(key: project)\n            }\n\n            if project == \"RCRDSHPNFT\" {\n                fetchingIDs.remove(key: project)\n            }\n        }\n\n        for project in fetchingIDs.keys {\n            let returnedNFTs = AlchemyMetadataWrapperMainnetShard4.getNFTs(ownerAddress: account!.address, ids: {project : fetchingIDs[project]!})\n\n            var collectionItems : [MetadataCollectionItem] = []\n            for nft in returnedNFTs {\n                if nft == nil {\n                    continue\n                }\n\n                var media = \"\"\n                var mediaType = \"\"\n                if nft!.media.length \u003e 0 \u0026\u0026 nft!.media[0]?.uri != nil {\n                    let m = nft!.media[0]!\n                    mediaType = m.mimetype ?? \"\"\n                    media = m.uri!\n                }\n\n                let item = MetadataCollectionItem(\n                    id: nft!.id,\n                    name: nft!.title ?? \"\",\n                    collection: project,\n                    subCollection: nil, \n                    media: media,\n                    mediaType: mediaType,\n                    source: source, \n                    nftDetailIdentifier: project \n                )\n                collectionItems.append(item)\n            }\n\n            if collectionItems.length \u003e 0 {\n                items[project] = collectionItems\n            }\n        }\n        return items\n    }",
               "spec": {
                  "order": [
                     "user",
                     "collectionIDs"
                  ],
                  "parameters": {
                     "collectionIDs": "{String: [UInt64]}",
                     "user": "String"
                  }
               }
            },
            "getAllFindPackSaleDetails": {
               "code": "import FindPack from 0x097bafa4e0b48eef\nimport FTRegistry from 0x097bafa4e0b48eef\nimport MetadataViews from 0x1d7e57aa55817448\n\npub fun main(packTypeName: String) : {UInt64 : Report} {\n    let packs = FindPack.getMetadataByName(packTypeName: packTypeName)\n    let packData : {UInt64 : Report} = {}\n    for packTypeId in packs.keys {\n        if let metadata = FindPack.getMetadataById(packTypeName: packTypeName, typeId: packTypeId) {\n            let packsLeft = FindPack.getPacksCollection(packTypeName: packTypeName, packTypeId: packTypeId).getPacksLeft()\n            packData[packTypeId] = Report(metadata, packsLeft: packsLeft)\n        }\n    }\n    return packData\n}\n\npub struct Report {\n        pub let name: String\n        pub let description: String\n\n        pub let thumbnailHash: String?\n        pub let thumbnailUrl:String?\n\n        pub let walletType: String\n        pub let walletAlias: String?\n\n        pub let openTime: UFix64\n        pub var saleEnded: Bool\n        pub let saleInfos: [SaleInfo]\n\n        pub let storageRequirement: UInt64\n        pub let collectionDisplay: MetadataViews.NFTCollectionDisplay\n\n        pub let itemTypes: [Type]\n\n        pub let extraData : {String : AnyStruct}\n        pub let packFields: {String : String}\n        pub let requiresReservation: Bool\n\n        pub let packsLeft : Int \n\n        init(_ md: FindPack.Metadata, packsLeft: Int) {\n            self.packsLeft = packsLeft\n            self.name=md.name\n            self.description=md.description\n            self.thumbnailHash=md.thumbnailHash\n            self.thumbnailUrl=md.thumbnailUrl\n            self.walletType=md.walletType.identifier\n            self.walletAlias=FTRegistry.getFTInfoByTypeIdentifier(md.walletType.identifier)?.alias\n            self.openTime=md.openTime\n            self.storageRequirement=md.storageRequirement\n            self.itemTypes=md.itemTypes\n            self.extraData=md.extraData\n            self.packFields=md.packFields\n            self.requiresReservation=md.requiresReservation\n            self.saleInfos=convertSaleInfo(md.saleInfos)\n            self.collectionDisplay=md.collectionDisplay\n            self.saleEnded=true\n            if self.packsLeft != 0 {\n                self.saleEnded=false\n            } else {\n                let currentTime = getCurrentBlock().timestamp\n                var saleEnded = true\n                for saleInfo in self.saleInfos{\n                    if saleInfo.endTime == nil || saleInfo.endTime! \u003e currentTime {\n                        saleEnded=true\n                        break\n                    }\n                }\n            }\n        }\n}\n\npub struct SaleInfo {\n        pub let name : String\n        pub let startTime : UFix64 \n        pub let endTime : UFix64?\n        pub let price : UFix64\n        pub let purchaseLimit : UInt64?\n        pub let purchaseRecord : {Address : UInt64}\n        pub let verifiers : [String]\n        pub let verifyAll : Bool \n\n        init(_ si: FindPack.SaleInfo) {\n            self.name=si.name\n            self.startTime=si.startTime\n            self.endTime=si.endTime\n            self.price=si.price\n            self.purchaseLimit=si.purchaseLimit\n            self.purchaseRecord=si.purchaseRecord\n\n            var verifierDesc : [String] = []\n            for verifier in si.verifiers {\n                verifierDesc.append(verifier.description)\n            }\n            self.verifiers=verifierDesc\n            self.verifyAll=si.verifyAll\n        }\n}\n\npub fun convertSaleInfo(_ info: [FindPack.SaleInfo]) : [SaleInfo] {\n    let res : [SaleInfo] = []\n    for i in info {\n        res.append(SaleInfo(i))\n    }\n    return res\n}",
               "spec": {
                  "order": [
                     "packTypeName"
                  ],
                  "parameters": {
                     "packTypeName": "String"
                  }
               }
            },
            "getAllNFTViews": {
               "code": "import MetadataViews from 0x1d7e57aa55817448\nimport FINDNFTCatalog from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\n\n//Fetch a single view from a nft on a given path\npub fun main(user: String, aliasOrIdentifier:String, id: UInt64) : {String : AnyStruct} {\n\n    let publicPath = getPublicPath(aliasOrIdentifier)\n    let resolveAddress = FIND.resolve(user) \n    if resolveAddress == nil {return {}}\n    let address = resolveAddress!\n\n    let pp = publicPath\n    let account = getAccount(address)\n    if account.balance == 0.0 {\n        return {}\n    }\n    let collection= account.getCapability(pp).borrow\u003c\u0026{MetadataViews.ResolverCollection}\u003e()!\n\n    let nft=collection.borrowViewResolver(id: id)\n    let view : {String : AnyStruct} = {}\n    for v in nft.getViews() {\n        if v != Type\u003cMetadataViews.NFTCollectionData\u003e() {\n            view[v.identifier] = nft.resolveView(v)\n        }\n    }\n    return view\n}\n\npub fun getPublicPath(_ nftIdentifier: String) : PublicPath {\n    let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier)) \n    let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n    return collection.collectionData.publicPath\n}",
               "spec": {
                  "order": [
                     "user",
                     "aliasOrIdentifier",
                     "id"
                  ],
                  "parameters": {
                     "aliasOrIdentifier": "String",
                     "id": "UInt64",
                     "user": "String"
                  }
               }
            },
            "getAllRelatedAccounts": {
               "code": "import FindRelatedAccounts from 0x097bafa4e0b48eef\n\npub fun main(user: Address) : {String : {String : [String]}} {\n    let account = getAccount(user)\n    let cap= account.getCapability\u003c\u0026FindRelatedAccounts.Accounts{FindRelatedAccounts.Public}\u003e(FindRelatedAccounts.publicPath)\n    let ref = cap.borrow()! \n    return ref.getAllRelatedAccounts()\n\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "Address"
                  }
               }
            },
            "getCatalog": {
               "code": "import NFTCatalog from 0x49a7cda3a1eecc29\nimport FINDNFTCatalog from 0x097bafa4e0b48eef\n\npub fun main() : {String : NFTCatalog.NFTCatalogMetadata} {\n    return FINDNFTCatalog.getCatalog() \n}",
               "spec": {
                  "order": [],
                  "parameters": {}
               }
            },
            "getCatalogCollectionDisplay": {
               "code": "import MetadataViews from 0x1d7e57aa55817448\nimport NFTCatalog from 0x49a7cda3a1eecc29\nimport FINDNFTCatalog from 0x097bafa4e0b48eef\n\npub fun main(collectionIdentifier : String, type: String?) : NFTCatalogMetadata? {\n    if let catalog = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier) {\n        return NFTCatalogMetadata(\n            contractName : catalog.contractName, \n            contractAddress : catalog.contractAddress, \n            nftType: catalog.nftType, \n            collectionDisplay : catalog.collectionDisplay\n        )\n    }\n\n    // if we have type identifier here: loop thru the items in that specific type\n    // otherwise we just loop over the entire catalog to get the collection display\n    var types : [String] = FINDNFTCatalog.getCatalogTypeData().keys \n    if type != nil {\n        types = [type!]\n    }\n\n    for identifier in types {\n        if let collections : [String] = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: identifier)?.keys {\n            for ci in collections {\n                let catalog = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : ci)! \n                if catalog.collectionDisplay.name == collectionIdentifier {\n                    return NFTCatalogMetadata(\n                        contractName : catalog.contractName, \n                        contractAddress : catalog.contractAddress, \n                        nftType: catalog.nftType, \n                        collectionDisplay : catalog.collectionDisplay\n                    )\n                }\n            }\n        }\n    }\n\n    return nil\n}\n\npub struct NFTCatalogMetadata {\n    pub let contractName : String\n    pub let contractAddress : Address\n    pub let nftType: String\n    pub let collectionDisplay: MetadataViews.NFTCollectionDisplay\n\n    init (contractName : String, contractAddress : Address, nftType: Type, collectionDisplay : MetadataViews.NFTCollectionDisplay) {\n        self.contractName = contractName\n        self.contractAddress = contractAddress\n        self.nftType = nftType.identifier\n        self.collectionDisplay = collectionDisplay\n    }\n}",
               "spec": {
                  "order": [
                     "collectionIdentifier",
                     "type"
                  ],
                  "parameters": {
                     "collectionIdentifier": "String",
                     "type": "String?"
                  }
               }
            },
            "getCatalogEntry": {
               "code": "import NFTCatalog from 0x49a7cda3a1eecc29\nimport FINDNFTCatalog from 0x097bafa4e0b48eef\n\npub fun main(collectionIdentifier : String) : NFTCatalog.NFTCatalogMetadata? {\n    return FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier) \n}",
               "spec": {
                  "order": [
                     "collectionIdentifier"
                  ],
                  "parameters": {
                     "collectionIdentifier": "String"
                  }
               }
            },
            "getCatalogTypeData": {
               "code": "import NFTCatalog from 0x49a7cda3a1eecc29\nimport FINDNFTCatalog from 0x097bafa4e0b48eef\n\npub fun main() : {String : {String : Bool}} {\n    return FINDNFTCatalog.getCatalogTypeData() \n}",
               "spec": {
                  "order": [],
                  "parameters": {}
               }
            },
            "getCheckRoyalty": {
               "code": "import MetadataViews from 0x1d7e57aa55817448\nimport FIND from 0x097bafa4e0b48eef\nimport FINDNFTCatalog from 0x097bafa4e0b48eef\n\npub fun main(name: String, id: UInt64, nftAliasOrIdentifier: String, viewIdentifier: String) : AnyStruct? {\n\n    let address =FIND.resolve(name)!\n\n    // Get collection public path from NFT Registry\n    let collectionPublicPath = getPublicPath(nftAliasOrIdentifier)\n    let collection= getAuthAccount(address).borrow\u003c\u0026{MetadataViews.ResolverCollection}\u003e(from: collectionPublicPath)!\n\n    let nft=collection.borrowViewResolver(id: id)\n    return nft.resolveView(CompositeType(viewIdentifier)!)\n}\n\npub fun getPublicPath(_ nftIdentifier: String) : StoragePath {\n    let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier)) \n    let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n    return collection.collectionData.storagePath\n}",
               "spec": {
                  "order": [
                     "name",
                     "id",
                     "nftAliasOrIdentifier",
                     "viewIdentifier"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "name": "String",
                     "nftAliasOrIdentifier": "String",
                     "viewIdentifier": "String"
                  }
               }
            },
            "getCollectionForType": {
               "code": "import NFTCatalog from 0x49a7cda3a1eecc29\nimport FINDNFTCatalog from 0x097bafa4e0b48eef\n\npub fun main(nftTypeIdentifier : String) : {String : Bool}? {\n    return FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftTypeIdentifier)\n}",
               "spec": {
                  "order": [
                     "nftTypeIdentifier"
                  ],
                  "parameters": {
                     "nftTypeIdentifier": "String"
                  }
               }
            },
            "getCollectionIndex": {
               "code": "import MetadataViews from 0x1d7e57aa55817448\nimport FINDNFTCatalog from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\n\npub fun main(user: String) : {String : [UInt64]} {\n\n    if let address = FIND.resolve(user) {\n        var resultMap : {String : [UInt64]} = {}\n        let account = getAccount(address)\n        for nftInfo in FINDNFTCatalog.getCatalog().values {\n            let publicPath = nftInfo.collectionData.publicPath\n\n            if let subCollections = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftInfo.nftType.identifier) {\n                if subCollections.length \u003c 1 {\n                    continue\n                } else if subCollections.length == 1 {\n                    let collection = nftInfo.nftType.identifier\n                    let resolverCollectionCap= account.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(publicPath)\n                    if resolverCollectionCap.check() {\n                        let collection = resolverCollectionCap.borrow()!\n                        resultMap[nftInfo.collectionDisplay.name] = collection.getIDs()\n                    }\n                } else {\n                    let collection = nftInfo.nftType.identifier\n                    let resolverCollectionCap= account.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(publicPath)\n\n                    let array : [UInt64] = []\n                    if resolverCollectionCap.check() {\n                        let collection = resolverCollectionCap.borrow()!\n                        for id in collection.getIDs() {\n                            let vr = collection.borrowViewResolver(id: id)\n                            if let sc = vr.resolveView(Type\u003cMetadataViews.NFTCollectionDisplay\u003e()) {\n                                let scv = sc as! MetadataViews.NFTCollectionDisplay\n                                if scv.name == nftInfo.collectionDisplay.name {\n                                    array.append(id)\n                                }\n                            }\n                        }\n                    }\n                    resultMap[nftInfo.collectionDisplay.name] = array\n                }\n            } \n\n        }\n\n        return resultMap\n    }\n    return {}\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "getCuratedCollections": {
               "code": "pub fun main(address: Address) : \u0026{String: [String]}? {\n    let account=getAccount(address)\n\n    if account.balance == 0.0 {\n        return nil\n    }\n\n    let publicPath=/public/FindCuratedCollections\n    let link = account.getCapability\u003c\u0026{String: [String]}\u003e(publicPath)\n    if link.check() {\n        return link.borrow()\n    }\n    return nil\n}",
               "spec": {
                  "order": [
                     "address"
                  ],
                  "parameters": {
                     "address": "Address"
                  }
               }
            },
            "getDandiesIDsFor": {
               "code": "import Dandy from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\n\npub fun main(user: String, minter: String) : [UInt64] {\n    let address = FIND.resolve(user)\n    if address == nil {\n        return []\n    }\n    let account = getAccount(address!)\n    if account.balance == 0.0 {\n        return []\n    }\n    let cap = account.getCapability\u003c\u0026Dandy.Collection{Dandy.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n    let ref = cap.borrow() ?? panic(\"Cannot borrow reference to Dandy Collection. Account address : \".concat(address!.toString()))\n\n    return ref.getIDsFor(minter: minter)\n}",
               "spec": {
                  "order": [
                     "user",
                     "minter"
                  ],
                  "parameters": {
                     "minter": "String",
                     "user": "String"
                  }
               }
            },
            "getDandiesMinters": {
               "code": "import Dandy from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\n\npub fun main(user: String) : [String] {\n    let address = FIND.resolve(user)\n    if address == nil {\n        return []\n    }\n    let account = getAccount(address!)\n    if account.balance == 0.0 {\n        return []\n    }\n    let cap = account.getCapability\u003c\u0026Dandy.Collection{Dandy.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n    let ref = cap.borrow() ?? panic(\"Cannot borrow reference to Dandy Collection. Account address : \".concat(address!.toString()))\n\n    return ref.getMinters()\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "getFTInfo": {
               "code": "import FTRegistry from 0x097bafa4e0b48eef\n\npub fun main(aliasOrIdentifier: String) : FTRegistry.FTInfo?{\n\n    return FTRegistry.getFTInfo(aliasOrIdentifier)\n\n}",
               "spec": {
                  "order": [
                     "aliasOrIdentifier"
                  ],
                  "parameters": {
                     "aliasOrIdentifier": "String"
                  }
               }
            },
            "getFTInfoAll": {
               "code": "import FTRegistry from 0x097bafa4e0b48eef\n\npub fun main() : {String: FTRegistry.FTInfo}{\n\n    return FTRegistry.getFTInfoAll()\n\n}",
               "spec": {
                  "order": [],
                  "parameters": {}
               }
            },
            "getFindPackSaleDetailsWithUser": {
               "code": "import FindPack from 0x097bafa4e0b48eef\nimport FTRegistry from 0x097bafa4e0b48eef\nimport FlowStorageFees from 0xe467b9dd11fa00df\nimport MetadataViews from 0x1d7e57aa55817448\nimport FIND from 0x097bafa4e0b48eef\n\npub fun main(packTypeName: String, packTypeId: UInt64, user: Address) : Report? {\n    if let metadata = FindPack.getMetadataById(packTypeName: packTypeName, typeId: packTypeId) {\n        let packsLeft = FindPack.getPacksCollection(packTypeName: packTypeName, packTypeId: packTypeId).getPacksLeft()\n        return Report(metadata, user: user, packsLeft:packsLeft)\n    }\n\n    return nil\n}\n\npub struct Report {\n        pub let name: String\n        pub let description: String\n\n        pub let thumbnailHash: String?\n        pub let thumbnailUrl:String?\n\n        pub let walletType: String\n        pub let walletAlias: String?\n\n        pub let openTime: UFix64\n\n        pub let storageRequirement: UInt64\n        pub let collectionDisplay: MetadataViews.NFTCollectionDisplay\n\n        pub let itemTypes: [Type]\n\n        pub let extraData : {String : AnyStruct}\n        pub let packFields: {String : String}\n        pub let requiresReservation: Bool\n        pub let storageFlowNeeded: UFix64? \n\n        pub let userQualifiedSale : UserSaleInfo?\n        pub let saleInfos: [SaleInfo]\n        pub let packsLeft : Int \n\n        init(_ md: FindPack.Metadata, user: Address, packsLeft: Int) {\n            self.packsLeft=packsLeft\n            self.name=md.name\n            self.description=md.description\n            self.thumbnailHash=md.thumbnailHash\n            self.thumbnailUrl=md.thumbnailUrl\n            self.walletType=md.walletType.identifier\n            self.walletAlias=FTRegistry.getFTInfoByTypeIdentifier(md.walletType.identifier)?.alias\n            self.openTime=md.openTime\n            self.storageRequirement=md.storageRequirement\n            self.itemTypes=md.itemTypes\n            self.extraData=md.extraData\n            self.packFields=md.packFields\n            self.requiresReservation=md.requiresReservation\n            self.userQualifiedSale=getSoonestQualifiedSale(md.saleInfos, user: user)\n            self.storageFlowNeeded=getRequiredFlow(md.storageRequirement, user: user)\n            self.collectionDisplay=md.collectionDisplay\n            self.saleInfos=convertSaleInfo(md.saleInfos)\n        }\n}\n\npub struct UserSaleInfo {\n        pub let name : String\n        pub let startTime : UFix64 \n        pub let endTime : UFix64?\n        pub let price : UFix64\n        pub let purchaseLimit : UInt64?\n        pub let userPurchaseRecord : UInt64\n        pub let canBuyNow : Bool\n\n        init(_ si: FindPack.SaleInfo, user: Address, timeStamp: UFix64) {\n            self.name=si.name\n            self.startTime=si.startTime\n            self.endTime=si.endTime\n            self.price=si.price\n            self.purchaseLimit=si.purchaseLimit\n            self.userPurchaseRecord=si.purchaseRecord[user] ?? 0\n            self.canBuyNow= si.startTime\u003c=timeStamp\n        }\n}\n\npub fun getSoonestQualifiedSale(_ infos: [FindPack.SaleInfo], user: Address) : UserSaleInfo? {\n    let res : [UserSaleInfo] = []\n    let currentTime = getCurrentBlock().timestamp\n    var availableOption : FindPack.SaleInfo? = nil \n    var soonestOption : FindPack.SaleInfo? = nil \n\n    // check for the sale option that is available to the user, and is with the lowest price\n    for info in infos {\n        if info.checkBuyable(addr: user, time: currentTime){\n            if availableOption == nil || availableOption!.price \u003e info!.price {\n                availableOption = info\n            }\n        } else {\n            let endTime = info.endTime ?? UFix64.max\n            if currentTime \u003e endTime {\n                continue\n            }\n\n    // if there is no option available, get the soonest option available to the user, again, lowest price\n            if info.checkBuyable(addr: user, time: info.startTime) {\n                if soonestOption == nil || soonestOption!.startTime \u003e info.startTime {\n                    soonestOption = info\n                } else if soonestOption!.startTime == info.startTime \u0026\u0026 soonestOption!.price \u003e info.price {\n                    soonestOption = info\n                }\n            }\n        }\n    }\n\n    if availableOption != nil {\n        return UserSaleInfo(availableOption!, user: user, timeStamp: currentTime)\n    } else if soonestOption != nil {\n        return UserSaleInfo(soonestOption!, user: user, timeStamp: currentTime)\n    }\n    return nil\n}\n\npub fun getRequiredFlow(_ requiresReservation: UInt64, user: Address) : UFix64? {\n\n    let account = getAccount(user)\n    if account.storageCapacity \u003e account.storageUsed {\n        if account.storageCapacity - account.storageUsed \u003e requiresReservation {\n            return nil\n        }\n    }\n    return FlowStorageFees.storageCapacityToFlow(FlowStorageFees.convertUInt64StorageBytesToUFix64Megabytes(account.storageUsed + requiresReservation))\n}\n\npub struct SaleInfo {\n        pub let name : String\n        pub let startTime : UFix64 \n        pub let endTime : UFix64?\n        pub let price : UFix64\n        pub let purchaseLimit : UInt64?\n        pub let purchaseRecord : {Address : UInt64}\n        pub let verifiers : [String]\n        pub let verifyAll : Bool \n\n        init(_ si: FindPack.SaleInfo) {\n            self.name=si.name\n            self.startTime=si.startTime\n            self.endTime=si.endTime\n            self.price=si.price\n            self.purchaseLimit=si.purchaseLimit\n            self.purchaseRecord=si.purchaseRecord\n\n            var verifierDesc : [String] = []\n            for verifier in si.verifiers {\n                verifierDesc.append(verifier.description)\n            }\n            self.verifiers=verifierDesc\n            self.verifyAll=si.verifyAll\n        }\n}\n\npub fun convertSaleInfo(_ info: [FindPack.SaleInfo]) : [SaleInfo] {\n    let res : [SaleInfo] = []\n    for i in info {\n        res.append(SaleInfo(i))\n    }\n    return res\n}",
               "spec": {
                  "order": [
                     "packTypeName",
                     "packTypeId",
                     "user"
                  ],
                  "parameters": {
                     "packTypeId": "UInt64",
                     "packTypeName": "String",
                     "user": "Address"
                  }
               }
            },
            "getFindThoughts": {
               "code": "import FindThoughts from 0x097bafa4e0b48eef\nimport MetadataViews from 0x1d7e57aa55817448\nimport FindViews from 0x097bafa4e0b48eef\nimport FindMarket from 0x097bafa4e0b48eef\nimport Profile from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\n\npub fun main(addresses: [Address], ids: [UInt64]) : [Thought] {\n    let thoughts : [Thought] = [] \n\n    for i, address in addresses {\n        let account = getAccount(address) \n        let cap = account.getCapability\u003c\u0026{FindThoughts.CollectionPublic}\u003e(FindThoughts.CollectionPublicPath) \n        if !cap.check() {\n            continue\n        }\n        let ref = cap.borrow()! \n        let t = ref.borrowThoughtPublic(ids[i]) \n        thoughts.append(getThought(t, withQuote: true))\n        \n    }\n    return thoughts\n}\n\npub struct User {\n    pub var name: String?\n    pub let address: Address \n    pub let findName: String? \n    pub var avatar: String? \n    pub let reaction: String\n\n    init(address: Address, reaction: String){\n        self.name = nil\n        self.findName = FIND.reverseLookup(address)\n        self.avatar = nil\n        self.reaction = reaction\n        self.address = address \n        let profileCap = getAccount(address).getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if profileCap.check() {\n            let p = profileCap.borrow()!\n            self.name = p.getName()\n            self.avatar = p.getAvatar()\n        }    \n    }\n}\n\npub struct Thought {\n    pub let id: UInt64 \n    pub let creator: Address \n    pub let creatorName: String? \n    pub var creatorProfileName: String? \n    pub var creatorAvatar: String? \n    pub var header: String?\n    pub var body: String?\n    pub let created: UFix64? \n    pub var lastUpdated: UFix64?\n    pub let medias: {String : String}\n    pub let nft: [FindMarket.NFTInfo]\n    pub var tags: [String]\n    pub var reacted: {String : [User]}\n    pub var reactions: {String : Int}\n    pub var reactedUsers: {String : [String]}\n    pub var quotedThought: Thought?\n    pub let hidden: Bool?\n\n    init(id: UInt64 , creator: Address , creatorName: String? , creatorProfileName: String? , creatorAvatar: String? , header: String? , body: String? , created: UFix64? , lastUpdated: UFix64?, medias: {String : String}, nft: [FindMarket.NFTInfo], tags: [String], reacted: {String : [User]}, reactions: {String : Int}, reactedUsers: {String : [String]}, quotedThought: Thought?, hidden: Bool?) {\n        self.id = id\n        self.creator = creator\n        self.creatorName = creatorName\n        self.creatorProfileName = creatorProfileName\n        self.creatorAvatar = creatorAvatar\n        self.header = header\n        self.body = body\n        self.created = created\n        self.lastUpdated = lastUpdated\n        self.medias = medias\n        self.nft = nft\n        self.tags = tags\n        self.reacted = reacted\n        self.reactions = reactions\n        self.reactedUsers = reactedUsers\n        self.quotedThought = quotedThought\n        self.hidden = hidden\n    }\n}\n\npub fun getThought(_ t: \u0026{FindThoughts.ThoughtPublic}, withQuote: Bool) : Thought {\n\n        var creatorProfileName : String? = nil\n        var creatorAvatar : String? = nil \n        let profileCap = getAccount(t.creator).getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if profileCap.check() {\n            creatorProfileName = profileCap.borrow()!.getName()\n            creatorAvatar = profileCap.borrow()!.getAvatar()\n        }\n\n        let medias : {String : String} = {}\n        for m in t.medias {\n            medias[m.file.uri()] = m.mediaType\n        }\n\n        let nft : [FindMarket.NFTInfo] = [] \n        for n in t.nft {\n            let vr = n.getViewResolver() \n            nft.append(FindMarket.NFTInfo(vr, id: n.id, detail: true))\n        }\n\n        let reacted : {String : [User]} = {}\n        let reactedUsers : {String :[String]} = {}\n        for user in t.reacted.keys {\n            let reaction = t.reacted[user]!\n            let allReacted = reacted[reaction] ?? []\n            let u = User(address: user, reaction: reaction)\n\n            allReacted.append(u)\n            reacted[reaction] = allReacted\n\n            let preReactedUser = reactedUsers[reaction] ?? []\n            preReactedUser.append(u.name ?? u.address.toString())\n            reactedUsers[reaction] = preReactedUser\n        }\n\n        var quotedThought : Thought? = nil \n        if withQuote {\n            if let p = t.getQuotedThought() {\n                if let ref = p.borrowThoughtPublic() {\n                    quotedThought = getThought(ref, withQuote: false)\n                } else {\n                    let creator = p.owner()\n                    var qCreatorProfileName : String? = nil\n                    var qCreatorAvatar : String? = nil \n                    let qProfileCap = getAccount(creator).getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n                    if qProfileCap.check() {\n                        qCreatorProfileName = qProfileCap.borrow()!.getName()\n                        qCreatorAvatar = qProfileCap.borrow()!.getAvatar()\n                    }\n\n                    quotedThought = Thought(\n                        id: p.id , \n                        creator: creator  , \n                        creatorName: FIND.reverseLookup(creator) , \n                        creatorProfileName: qCreatorProfileName , \n                        creatorAvatar: qCreatorAvatar, \n                        header: nil, \n                        body: nil , \n                        created: nil, \n                        lastUpdated: nil, \n                        medias: {}, \n                        nft: [], \n                        tags: [], \n                        reacted: {}, \n                        reactions: {}, \n                        reactedUsers: {},\n                        quotedThought: nil, \n                        hidden: nil\n                    )\n                }\n            }\n        }\n\n        return Thought(\n            id: t.id , \n            creator: t.creator  , \n            creatorName: FIND.reverseLookup(t.creator) , \n            creatorProfileName: creatorProfileName , \n            creatorAvatar: creatorAvatar, \n            header: t.header , \n            body: t.body , \n            created: t.created, \n            lastUpdated: t.lastUpdated, \n            medias: medias, \n            nft: nft, \n            tags: t.tags, \n            reacted: reacted, \n            reactions: t.reactions, \n            reactedUsers: reactedUsers,\n            quotedThought: quotedThought,\n            hidden: t.getHide()\n        )\n\n}",
               "spec": {
                  "order": [
                     "addresses",
                     "ids"
                  ],
                  "parameters": {
                     "addresses": "[Address]",
                     "ids": "[UInt64]"
                  }
               }
            },
            "getItem": {
               "code": "import MetadataViews from 0x1d7e57aa55817448\nimport FIND from 0x097bafa4e0b48eef\nimport FINDNFTCatalog from 0x097bafa4e0b48eef\n\npub struct MetadataCollectionItem {\n    pub let id:UInt64\n    pub let uuid:UInt64\n    pub let name: String\n    pub let description: String?\n    pub let image: String\n    pub let url: String\n    pub let contentType:String\n    pub let rarity:String\n    pub let minter:String?\n    pub let type:Type\n\n\n    init(id:UInt64, uuid:UInt64, name:String, description:String?, image:String, url:String, contentType: String, rarity: String, minter:String?, type:Type) {\n        self.id=id\n        self.uuid=uuid\n        self.name=name\n        self.description=description\n        self.minter=minter\n        self.url=url\n        self.type=type\n        self.image=image\n        self.contentType=contentType\n        self.rarity=rarity\n    }\n}\n\n\npub fun main(user: String, aliasOrIdentifier: String, id:UInt64) : MetadataCollectionItem?{\n\n    let publicPath = getPublicPath(aliasOrIdentifier)\n\n    let resolveAddress = FIND.resolve(user) \n    if resolveAddress == nil {return nil}\n    let address = resolveAddress!\n    let account=getAccount(address)\n    if account.balance == 0.0 {\n        return nil\n    }\n    let resolverCollectionCap= account.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(publicPath)\n    if !resolverCollectionCap.check() {\n        return nil\n    }\n\n    let collection = resolverCollectionCap.borrow()!\n    let nft = collection.borrowViewResolver(id: id)!\n\n    if let displayView = nft.resolveView(Type\u003cMetadataViews.Display\u003e()) {\n        let display = displayView as! MetadataViews.Display\n\n        var externalUrl=\"\"\n        if let externalUrlView = nft.resolveView(Type\u003cMetadataViews.ExternalURL\u003e()) {\n            let edvu= externalUrlView as! MetadataViews.ExternalURL\n            externalUrl=edvu.url\n        }\n        let item = MetadataCollectionItem(\n            id: id,\n            uuid: nft.uuid,\n            name: display.name,\n            description:display.description,\n            image: display.thumbnail.uri(),\n            url: externalUrl,\n            contentType: \"image\",\n            rarity: \"\",\n            minter: \"\",\n            type: nft.getType()\n        )\n        return item\n    }\n    return nil\n}\n\npub fun getPublicPath(_ nftIdentifier: String) : PublicPath {\n    let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier)) \n    let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n    return collection.collectionData.publicPath\n}",
               "spec": {
                  "order": [
                     "user",
                     "aliasOrIdentifier",
                     "id"
                  ],
                  "parameters": {
                     "aliasOrIdentifier": "String",
                     "id": "UInt64",
                     "user": "String"
                  }
               }
            },
            "getLeases": {
               "code": "import FIND from 0x097bafa4e0b48eef\n\npub fun main() : [FIND.NetworkLease] {\n    return FIND.getLeases()\n}",
               "spec": {
                  "order": [],
                  "parameters": {}
               }
            },
            "getListings": {
               "code": "import FindMarket from 0x097bafa4e0b48eef \nimport FIND from 0x097bafa4e0b48eef \n\npub fun main(marketplace:Address, user: String) : {String : FindMarket.SaleItemCollectionReport} {\n    let resolveAddress = FIND.resolve(user)\n    if resolveAddress == nil { return {}}\n    let address = resolveAddress!\n        return FindMarket.getSaleItemReport(tenant:marketplace, address: address, getNFTInfo:false)\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "user"
                  ],
                  "parameters": {
                     "marketplace": "Address",
                     "user": "String"
                  }
               }
            },
            "getLostAndFoundNFTs": {
               "code": "import LostAndFoundHelper from 0x473d6a2c37eab5be\nimport FindLostAndFoundWrapper from 0x097bafa4e0b48eef\nimport NonFungibleToken from 0x1d7e57aa55817448\nimport FIND from 0x097bafa4e0b48eef\nimport FINDNFTCatalog from 0x097bafa4e0b48eef\n\npub fun main(user: String) : Report {\n\n    if let address = FIND.resolve(user) {\n        let runTimeType = Type\u003c@NonFungibleToken.NFT\u003e()\n\n        let ticketsInfo = FindLostAndFoundWrapper.getTickets(user: address, specificType: runTimeType)\n\n        let ticketIds : {String : [UInt64]} = {}\n        let NFTCatalogTicketInfo : {String : [LostAndFoundHelper.Ticket]} = {}\n        for type in ticketsInfo.keys {\n            // check if this type is in NFTCatalog\n            let nftCatalog = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: type)\n            var inNFTCatalog : Bool = true \n            if nftCatalog == nil {\n                inNFTCatalog = false\n            }\n\n            // append id in array\n            let id : [UInt64] = []\n            for ticket in ticketsInfo[type]! {\n                if ticket.ticketID != nil {\n                    id.append(ticket.ticketID!)\n                }\n            }\n            ticketIds[type] = id\n\n            // If it is in NFT Catalog, add it in NFTCatalogTicketInfo\n            if inNFTCatalog {\n                NFTCatalogTicketInfo[type] = ticketsInfo.remove(key: type)\n            }\n        }\n\n        return Report(nftCatalogTicketInfo : NFTCatalogTicketInfo, ticketInfo : ticketsInfo, ticketIds : ticketIds, error: nil)\n    }\n    return logErr(\"Cannot resolve user. User : \".concat(user))\n}\n\n\npub struct Report {\n\n    pub let nftCatalogTicketInfo : {String : [LostAndFoundHelper.Ticket]}\n    pub let ticketInfo : {String : [LostAndFoundHelper.Ticket]}\n    pub let ticketIds : {String : [UInt64]}\n    pub let error : String?\n\n    init(nftCatalogTicketInfo : {String : [LostAndFoundHelper.Ticket]}, ticketInfo : {String : [LostAndFoundHelper.Ticket]}, ticketIds : {String : [UInt64]}, error: String?) {\n        self.nftCatalogTicketInfo = nftCatalogTicketInfo\n        self.ticketInfo = ticketInfo\n        self.ticketIds = ticketIds\n        self.error = error\n    }\n}\n\npub fun logErr(_ err: String) : Report {\n    return Report(nftCatalogTicketInfo: {}, ticketInfo : {}, ticketIds : {} , error: err)\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "getLostAndFoundRedeemableNFTTypes": {
               "code": "import FindLostAndFoundWrapper from 0x097bafa4e0b48eef\nimport NonFungibleToken from 0x1d7e57aa55817448\nimport FIND from 0x097bafa4e0b48eef\n\npub fun main(user: String) : Report {\n\n    if let address = FIND.resolve(user){\n        let type : Type = Type\u003c@NonFungibleToken.NFT\u003e()\n        return Report(nftTypes: typeToStringArray(FindLostAndFoundWrapper.getSpecificRedeemableTypes(user: address, specificType: type)), err: nil)\n    }\n    return logErr(\"cannot resolve user\")\n\n}\n\npub fun typeToStringArray(_ array: [Type]) : [String] {\n    let res : [String] = []\n    for type in array {\n        res.append(type.identifier)\n    }\n    return res\n}\n\npub struct Report {\n    pub let nftTypes : [String]\n    pub let err : String? \n\n    init(nftTypes : [String] , err : String? ) {\n        self.nftTypes = nftTypes\n        self.err = err\n    }\n}\n\npub fun logErr(_ err: String) : Report{\n    return Report(nftTypes: [], err: err)\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "getLostAndFoundRequiredStorageType": {
               "code": "import FindLostAndFoundWrapper from 0x097bafa4e0b48eef\nimport FINDNFTCatalog from 0x097bafa4e0b48eef\nimport NonFungibleToken from 0x1d7e57aa55817448\nimport MetadataViews from 0x1d7e57aa55817448\nimport FIND from 0x097bafa4e0b48eef\n\npub fun main(user: String) : Report {\n\n    if let address = FIND.resolve(user){\n        let runTimeType : Type = Type\u003c@NonFungibleToken.NFT\u003e()\n\n        let types = FindLostAndFoundWrapper.getSpecificRedeemableTypes(user: address, specificType: runTimeType)\n\n        let account = getAuthAccount(address)\n\n        let initiableStorage : [String] = []\n        let relinkableStorage : [String] = []\n        let initiatedStorage : [String] = []\n        let problematicStorage : [String] = []\n        let notSupportedType : [String] = []\n        for type in types {\n\n            let nftInfo = FINDNFTCatalog.getCollectionDataForType(nftTypeIdentifier: type.identifier)\n\n            if nftInfo == nil {\n                initiableStorage.append(type.identifier)\n                continue\n            }\n\n            let storageType = account.type(at: nftInfo!.storagePath)\n            if storageType == nil {\n                initiableStorage.append(type.identifier)\n                continue\n            } \n            \n            let storageTypeIdentifier = storageType!.identifier.slice(from: 0 , upTo: storageType!.identifier.length - \".Collection\".length)\n            let typeIdentifier = type.identifier.slice(from: 0 , upTo: type.identifier.length - \".NFT\".length)\n            if storageTypeIdentifier != typeIdentifier {\n                problematicStorage.append(type.identifier)\n            } else {\n\n                // check if relink needed\n                if account.getCapability\u003c\u0026{NonFungibleToken.Receiver, NonFungibleToken.CollectionPublic, MetadataViews.ResolverCollection}\u003e(nftInfo!.publicPath).check() {\n                    initiatedStorage.append(type.identifier)\n                } else {\n                    relinkableStorage.append(type.identifier)\n                }\n\n            }\n        }\n        return Report(initiableStorage: initiableStorage, relinkableStorage: relinkableStorage ,initiatedStorage: initiatedStorage, problematicStorage: problematicStorage, notSupportedType: notSupportedType, err: nil)\n    }\n    return logErr(\"cannot resolve user\")\n\n}\n\npub struct Report {\n\n    pub let initiableStorage : [String] \n    pub let relinkableStorage : [String]\n    pub let initiatedStorage : [String] \n    pub let problematicStorage : [String] \n    pub let notSupportedType : [String] \n\n    pub let err : String? \n\n    init(initiableStorage : [String] , relinkableStorage : [String] , initiatedStorage : [String], problematicStorage : [String] , notSupportedType : [String] , err : String? ) {\n        self.initiableStorage = initiableStorage\n        self.relinkableStorage = relinkableStorage\n        self.initiatedStorage = initiatedStorage\n        self.problematicStorage = problematicStorage\n        self.notSupportedType = notSupportedType\n        self.err = err\n    }\n\n}\n\npub fun logErr(_ err: String) : Report {\n    return Report(initiableStorage: [] , relinkableStorage : [] , initiatedStorage : [] , problematicStorage: [], notSupportedType: [], err: err)\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "getMarketBlockedNFT": {
               "code": "import FindMarket from 0x097bafa4e0b48eef \n\npub fun main() : {String : [String] } {\n    let mapping : {String : [String] } = {}\n\n    let findAddress=FindMarket.getFindTenantAddress()\n    let tenantCap = FindMarket.getTenantCapability(findAddress)!\n    let tenantRef = tenantCap.borrow() ?? panic(\"This tenant is not set up. Tenant : \".concat(tenantCap.address.toString()))\n    let marketTypes = FindMarket.getSaleItemTypes()\n    for marketType in marketTypes {\n        let list : [String] = []\n        for type in tenantRef.getBlockedNFT(marketType: marketType) {\n            list.append(type.identifier)\n        }\n        mapping[FindMarket.getMarketOptionFromType(marketType)] = list\n    }\n\nreturn mapping\n}",
               "spec": {
                  "order": [],
                  "parameters": {}
               }
            },
            "getMetadataForBuyAddonDapper": {
               "code": "import FIND from 0x097bafa4e0b48eef\n\npub fun main(merchAccount: Address, name: String, addon:String, amount:UFix64) : PurchaseData {\n    let description = \"Purchase addon \".concat(addon).concat(\" for name :\").concat(name).concat(\" for Dapper Credit \").concat(amount.toString())\n    let imageURL = \"https://i.imgur.com/8W8NoO1.png\"\n\n    return PurchaseData(\n            id: 0, \n            name: name, \n            amount: amount, \n            description: description, \n            imageURL: imageURL\n            )\n\n\n}\n\npub struct PurchaseData {\n    pub let id: UInt64\n    pub let name: String\n    pub let amount: UFix64\n    pub let description: String\n    pub let imageURL: String\n\n    init(id: UInt64, name: String, amount: UFix64, description: String, imageURL: String) {\n        self.id = id\n        self.name = name\n        self.amount = amount\n        self.description = description\n        self.imageURL = imageURL\n    }\n}",
               "spec": {
                  "order": [
                     "merchAccount",
                     "name",
                     "addon",
                     "amount"
                  ],
                  "parameters": {
                     "addon": "String",
                     "amount": "UFix64",
                     "merchAccount": "Address",
                     "name": "String"
                  }
               }
            },
            "getMetadataForBuyLeaseForSaleDapper": {
               "code": "import FindMarket from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\nimport Profile from 0x097bafa4e0b48eef\nimport DapperUtilityCoin from 0xead892083b3e2c6c\nimport FindLeaseMarketSale from 0x097bafa4e0b48eef\nimport FindLeaseMarket from 0x097bafa4e0b48eef\n\npub fun main(sellerAccount: Address, leaseName: String, amount: UFix64) :PurchaseData{\n\n    let address = FIND.resolve(leaseName) ?? panic(\"The address input is not a valid name nor address. Input : \".concat(leaseName))\n    let leaseMarketplace = FindMarket.getFindTenantAddress()\n    let leaseTenant = FindMarket.getTenant(leaseMarketplace)\n    let storagePath = leaseTenant.getStoragePath(Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e())\n    let saleItemRef = getAuthAccount(address).borrow\u003c\u0026FindLeaseMarketSale.SaleItemCollection\u003e(from: storagePath) ?? panic(\"Cannot borrow reference to sale item\")\n    let saleItem = saleItemRef.borrow(leaseName)\n\n    let description = \"Name :\".concat(leaseName).concat(\" for Dapper Credit \").concat(amount.toString())\n    let imageURL = \"https://i.imgur.com/8W8NoO1.png\"\n\n    return PurchaseData(\n            id: saleItem.getId(),\n            name: leaseName,\n            amount: amount,\n            description: description,\n            imageURL: imageURL\n            )\n}\n\npub struct PurchaseData {\n    pub let id: UInt64\n    pub let name: String\n    pub let amount: UFix64\n    pub let description: String\n    pub let imageURL: String\n\n    init(id: UInt64, name: String, amount: UFix64, description: String, imageURL: String) {\n        self.id = id\n        self.name = name\n        self.amount = amount\n        self.description = description\n        self.imageURL = imageURL\n    }\n}",
               "spec": {
                  "order": [
                     "sellerAccount",
                     "leaseName",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "leaseName": "String",
                     "sellerAccount": "Address"
                  }
               }
            },
            "getMetadataForBuyNFTForSaleDapper": {
               "code": "import FindMarket from 0x097bafa4e0b48eef\nimport FindMarketSale from 0x097bafa4e0b48eef\n\n\npub fun main(address: Address, marketplace:Address, id: UInt64, amount: UFix64) : PurchaseData {\n\n    let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketSale.SaleItemCollection\u003e())\n    let item= FindMarket.assertOperationValid(tenant: marketplace, address: address, marketOption: marketOption, id: id)\n    let display = item.getDisplay()\n    let itemID = item.getItemID()\n    let amount = item.getBalance()\n\n\n    return PurchaseData(\n        id: itemID,\n        name: display.name,\n        amount: amount,\n        description: display.description,\n        imageURL: display.thumbnail.uri()\n    )\n}\n\npub struct PurchaseData {\n    pub let id: UInt64\n    pub let name: String\n    pub let amount: UFix64\n    pub let description: String\n    pub let imageURL: String\n\n    init(id: UInt64, name: String, amount: UFix64, description: String, imageURL: String) {\n        self.id = id\n        self.name = name\n        self.amount = amount\n        self.description = description\n        self.imageURL = imageURL\n    }\n}",
               "spec": {
                  "order": [
                     "address",
                     "marketplace",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "address": "Address",
                     "amount": "UFix64",
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "getMetadataForRegisterDapper": {
               "code": "import FIND from 0x097bafa4e0b48eef\n\npub fun main(merchAccount: Address, name: String, amount: UFix64) : PurchaseData {\n\n    let description = \"Name :\".concat(name).concat(\" for Dapper Credit \").concat(amount.toString())\n    let imageURL = \"https://ik.imagekit.io/xyvsisxky/tr:ot-\".concat(name).concat(\",ots-55,otc-58B792,ox-N166,oy-N24,ott-b/https://i.imgur.com/8W8NoO1.png\")\n\n    return PurchaseData(\n            id: 0, \n            name: name, \n            amount: amount, \n            description: description, \n            imageURL: imageURL\n            )\n\n}\n\npub struct PurchaseData {\n    pub let id: UInt64\n    pub let name: String\n    pub let amount: UFix64\n    pub let description: String\n    pub let imageURL: String\n\n    init(id: UInt64, name: String, amount: UFix64, description: String, imageURL: String) {\n        self.id = id\n        self.name = name\n        self.amount = amount\n        self.description = description\n        self.imageURL = imageURL\n    }\n}",
               "spec": {
                  "order": [
                     "merchAccount",
                     "name",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "merchAccount": "Address",
                     "name": "String"
                  }
               }
            },
            "getMetadataForRenewNameDapper": {
               "code": "import FIND from 0x097bafa4e0b48eef\n\npub fun main(merchAccount: Address, name: String, amount: UFix64) : PurchaseData {\n\n    let description = \"Renew name :\".concat(name).concat(\" for Dapper Credit \").concat(amount.toString())\n    let imageURL = \"https://ik.imagekit.io/xyvsisxky/tr:ot-\".concat(name).concat(\",ots-55,otc-58B792,ox-N166,oy-N24,ott-b/https://i.imgur.com/8W8NoO1.png\")\n\n    return PurchaseData(\n            id: 0, \n            name: name, \n            amount: amount, \n            description: description, \n            imageURL: imageURL\n            )\n}\n\npub struct PurchaseData {\n    pub let id: UInt64\n    pub let name: String\n    pub let amount: UFix64\n    pub let description: String\n    pub let imageURL: String\n\n    init(id: UInt64, name: String, amount: UFix64, description: String, imageURL: String) {\n        self.id = id\n        self.name = name\n        self.amount = amount\n        self.description = description\n        self.imageURL = imageURL\n    }\n}",
               "spec": {
                  "order": [
                     "merchAccount",
                     "name",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "merchAccount": "Address",
                     "name": "String"
                  }
               }
            },
            "getMetadataForSaleItem": {
               "code": "import FindMarketSale from 0x097bafa4e0b48eef\n\npub struct PurchaseData {\n    pub let id: UInt64\n    pub let name: String\n    pub let amount: UFix64\n    pub let description: String\n    pub let imageURL: String\n\n    init(id: UInt64, name: String, amount: UFix64, description: String, imageURL: String) {\n        self.id = id\n        self.name = name\n        self.amount = amount\n        self.description = description\n        self.imageURL = imageURL\n    }\n}\npub fun main(merchantAddress: Address, marketplace:Address, address: Address, id: UInt64, amount: UFix64) : PurchaseData{\n    let saleItemsCap= FindMarketSale.getSaleItemCapability(marketplace: marketplace, user:address) ?? panic(\"cannot find sale item cap\")\n    let saleItemCollection = saleItemsCap.borrow()!\n    let item = saleItemCollection.borrowSaleItem(id)\n\n    let display = item.getDisplay()\n\n    var thumbnail = replacePrefix(display.thumbnail.uri(), prefix: \"ipfs://\", replace:\"https://find.mypinata.clloud/ipfs/\")\n    return PurchaseData(\n        id: id, \n        name: display.name, \n        amount: amount,\n        description: display.description, \n        imageURL: thumbnail\n    )\n}\n\npub fun replacePrefix(_ original: String, prefix:String, replace:String) : String {\n    if original.length \u003c prefix.length  {\n        return original\n    }\n    let oprefix = original.slice(from:0, upTo:prefix.length)\n    if oprefix != prefix {\n        return original\n    }\n    let rest = original.slice(from:prefix.length, upTo: original.length)\n    return replace.concat(rest)\n}",
               "spec": {
                  "order": [
                     "merchantAddress",
                     "marketplace",
                     "address",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "address": "Address",
                     "amount": "UFix64",
                     "id": "UInt64",
                     "marketplace": "Address",
                     "merchantAddress": "Address"
                  }
               }
            },
            "getNFTCatalogIDs": {
               "code": "import MetadataViews from 0x1d7e57aa55817448\nimport FIND from 0x097bafa4e0b48eef\nimport FINDNFTCatalog from 0x097bafa4e0b48eef\n\npub fun main(user: String, collections: [String]) : {String : ItemReport} {\n    return fetchNFTCatalog(user: user, targetCollections:collections)\n}\n\npub struct ItemReport {\n    pub let length : Int // mapping of collection to no. of ids \n    pub let extraIDs : [UInt64]\n    pub let shard : String \n    pub let extraIDsIdentifier : String \n    pub let collectionName: String\n\n    init(length : Int, extraIDs :[UInt64] , shard: String, extraIDsIdentifier: String, collectionName: String) {\n        self.length=length \n        self.extraIDs=extraIDs\n        self.shard=shard\n        self.extraIDsIdentifier=extraIDsIdentifier\n        self.collectionName=collectionName\n    }\n}\n\npub struct NFTView {\n    pub let id: UInt64\n    pub let display: MetadataViews.Display?\n    pub let editions: MetadataViews.Editions?\n    pub let collectionDisplay: MetadataViews.NFTCollectionDisplay?\n    pub let nftType: Type\n\n    init(\n        id : UInt64,\n        display : MetadataViews.Display?,\n        editions : MetadataViews.Editions?,\n        collectionDisplay: MetadataViews.NFTCollectionDisplay?,\n        nftType: Type\n    ) {\n        self.id = id\n        self.display = display\n        self.editions = editions\n        self.collectionDisplay = collectionDisplay\n        self.nftType = nftType\n    }\n}\n\npub struct NFTIDs {\n    pub let ids: [UInt64]\n    pub let collectionName: String \n\n    init(ids: [UInt64], collectionName: String ) {\n        self.ids = ids\n        self.collectionName = collectionName\n    }\n}\n\n// Helper function \n\npub fun resolveAddress(user: String) : Address? {\n    return FIND.resolve(user)\n}\n\npub fun getNFTIDs(ownerAddress: Address) : {String : NFTIDs} {\n\n    let account = getAuthAccount(ownerAddress)\n\n    if account.balance == 0.0 {\n        return {}\n    }\n\n    let inventory : {String:NFTIDs}={}\n    let types = FINDNFTCatalog.getCatalogTypeData()\n    for nftType in types.keys {\n\n        let typeData=types[nftType]!\n        let collectionKey=typeData.keys[0]\n        let catalogEntry = FINDNFTCatalog.getCatalogEntry(collectionIdentifier:collectionKey)!\n\n        var collectionName = collectionKey\n        if typeData.length == 1 {\n            collectionName = catalogEntry.collectionDisplay.name\n        }\n\n        let storagePath = catalogEntry.collectionData.storagePath\n        let ref= account.borrow\u003c\u0026{MetadataViews.ResolverCollection}\u003e(from: storagePath)\n        if ref != nil {\n            inventory[collectionKey] = NFTIDs(ids: ref!.getIDs(), collectionName: collectionName)\n        }\n\n    }\n    return inventory\n}\n\npub fun fetchNFTCatalog(user: String, targetCollections: [String]) : {String : ItemReport} {\n    let source = \"NFTCatalog\"\n    let account = resolveAddress(user: user)\n    if account == nil { return {} }\n\n\n    let extraIDs = getNFTIDs(ownerAddress: account!)\n    let inventory : {String : ItemReport} = {}\n    var fetchedCount : Int = 0\n\n    for project in extraIDs.keys {\n\n        let catalogEntry = FINDNFTCatalog.getCatalogEntry(collectionIdentifier:project)!\n        let projectName = catalogEntry.contractName\n\n        if extraIDs[project]! == nil || extraIDs[project]!.ids.length \u003c 1{\n            extraIDs.remove(key: project)\n            continue\n        }\n        \n        let collectionLength = extraIDs[project]!.ids.length\n\n        // by pass if this is not the target collection\n        if targetCollections.length \u003e 0 \u0026\u0026 !targetCollections.contains(project) {\n            // inventory[project] = ItemReport(length : collectionLength, extraIDs :extraIDs[project]! , shard: source)\n            continue\n        }\n\n        inventory[catalogEntry.contractName] = ItemReport(length : collectionLength, extraIDs :extraIDs[project]?.ids ?? [] , shard: source, extraIDsIdentifier: project, collectionName: extraIDs[project]!.collectionName)\n\n    }\n\n    return inventory\n\n}",
               "spec": {
                  "order": [
                     "user",
                     "collections"
                  ],
                  "parameters": {
                     "collections": "[String]",
                     "user": "String"
                  }
               }
            },
            "getNFTCatalogItems": {
               "code": "import MetadataViews from 0x1d7e57aa55817448\nimport FIND from 0x097bafa4e0b48eef\nimport FindViews from 0x097bafa4e0b48eef\n\nimport FINDNFTCatalog from 0x097bafa4e0b48eef\n\npub fun main(user: String, collectionIDs: {String : [UInt64]}) : {String : [MetadataCollectionItem]} {\n    return fetchNFTCatalog(user: user, collectionIDs: collectionIDs)\n}\n\npub struct NFTView {\n    pub let id: UInt64\n    pub let display: MetadataViews.Display?\n    pub let edition: UInt64?\n    pub let collectionDisplay: MetadataViews.NFTCollectionDisplay?\n    pub let soulBounded: Bool\n    pub let nftType: Type\n\n    init(\n        id : UInt64,\n        display : MetadataViews.Display?,\n        edition : UInt64?,\n        collectionDisplay: MetadataViews.NFTCollectionDisplay?,\n        soulBounded: Bool ,\n        nftType: Type\n    ) {\n        self.id = id\n        self.display = display\n        self.edition = edition\n        self.collectionDisplay = collectionDisplay\n        self.soulBounded = soulBounded\n        self.nftType = nftType\n    }\n}\n\npub fun getNFTs(ownerAddress: Address, ids: {String : [UInt64]}) : [NFTView] {\n\n    let account = getAuthAccount(ownerAddress)\n\n    if account.balance == 0.0 {\n        return []\n    }\n\n    let results : [NFTView] = []\n    for collectionKey in ids.keys {\n        let catalogEntry = FINDNFTCatalog.getCatalogEntry(collectionIdentifier:collectionKey)!\n        let storagePath = catalogEntry.collectionData.storagePath\n        let ref= account.borrow\u003c\u0026{MetadataViews.ResolverCollection}\u003e(from: storagePath)\n        if ref != nil{\n            for id in ids[collectionKey]! {\n                // results.append(MetadataViews.getNFTView(id:id, viewResolver: ref!.borrowViewResolver(id:id)!))\n                let viewResolver = ref!.borrowViewResolver(id:id)!\n\n                var e : UInt64? = nil\n                if let editions =  MetadataViews.getEditions(viewResolver) {\n                    if editions.infoList.length \u003e 0 {\n                        e = editions.infoList[0].number\n                    }\n                }\n\n                if let v = viewResolver.resolveView(Type\u003cMetadataViews.Edition\u003e()) {\n                    if let edition = v as? MetadataViews.Edition {\n                        e = edition.number\n                    }\n                }\n\n                results.append(\n                    NFTView(\n                        id : id,\n                        display: MetadataViews.getDisplay(viewResolver),\n                        edition : e,\n                        collectionDisplay : MetadataViews.getNFTCollectionDisplay(viewResolver),\n                        soulBounded : FindViews.checkSoulBound(viewResolver),\n                        nftType : viewResolver.getType()\n                    )\n                )\n            }\n        }\n    }\n    return results\n}\n\npub struct CollectionReport {\n    pub let items : {String : [MetadataCollectionItem]}\n    pub let collections : {String : Int} // mapping of collection to no. of ids\n    pub let extraIDs : {String : [UInt64]}\n\n    init(items: {String : [MetadataCollectionItem]},  collections : {String : Int}, extraIDs : {String : [UInt64]} ) {\n        self.items=items\n        self.collections=collections\n        self.extraIDs=extraIDs\n    }\n}\n\npub struct MetadataCollectionItem {\n    pub let id:UInt64\n    pub let name: String\n    pub let edition: UInt64?\n    pub let collection: String // \u003c- This will be Alias unless they want something else\n    pub let subCollection: String? // \u003c- This will be Alias unless they want something else\n    pub let nftDetailIdentifier: String\n    pub let soulBounded: Bool\n\n    pub let media  : String\n    pub let mediaType : String\n    pub let source : String\n\n    init(id:UInt64, name: String, edition: UInt64?, collection: String, subCollection: String?, media  : String, mediaType : String, source : String, nftDetailIdentifier: String, soulBounded: Bool ) {\n        self.id=id\n        self.name=name\n        self.edition=edition\n        self.collection=collection\n        self.subCollection=subCollection\n        self.media=media\n        self.mediaType=mediaType\n        self.source=source\n        self.nftDetailIdentifier=nftDetailIdentifier\n        self.soulBounded=soulBounded\n    }\n}\n\n// Helper function\n\npub fun resolveAddress(user: String) : PublicAccount? {\n    let address = FIND.resolve(user)\n    if address == nil {\n        return nil\n    }\n    return getAccount(address!)\n}\n\n\n//////////////////////////////////////////////////////////////\n// Fetch Specific Collections in FIND Catalog\n//////////////////////////////////////////////////////////////\npub fun fetchNFTCatalog(user: String, collectionIDs: {String : [UInt64]}) : {String : [MetadataCollectionItem]} {\n    let source = \"NFTCatalog\"\n    let account = resolveAddress(user: user)\n    if account == nil { return {} }\n\n    let items : {String : [MetadataCollectionItem]} = {}\n\n    let fetchingIDs = collectionIDs\n\n\n    for project in fetchingIDs.keys {\n\n        let catalogEntry = FINDNFTCatalog.getCatalogEntry(collectionIdentifier:project)!\n        let projectName = catalogEntry.contractName\n\n        let returnedNFTs = getNFTs(ownerAddress: account!.address, ids: {project : fetchingIDs[project]!})\n\n        var collectionItems : [MetadataCollectionItem] = []\n        for nft in returnedNFTs {\n            if nft == nil {\n                continue\n            }\n\n            var subCollection = \"\"\n            if project != nft.collectionDisplay!.name {\n             subCollection = nft.collectionDisplay!.name\n            }\n\n            var name = nft.display!.name\n            if name == \"\" {\n                name = projectName\n            }\n\n            let item = MetadataCollectionItem(\n                id: nft.id,\n                name: name,\n                edition: nft.edition,\n                collection: project,\n                subCollection: subCollection,\n                media: nft.display!.thumbnail.uri(),\n                mediaType: \"image/png\",\n                source: source,\n                nftDetailIdentifier: nft.nftType.identifier,\n                soulBounded: nft.soulBounded\n            )\n            collectionItems.append(item)\n        }\n\n        if collectionItems.length \u003e 0 {\n            items[project] = collectionItems\n        }\n    }\n    return items\n}",
               "spec": {
                  "order": [
                     "user",
                     "collectionIDs"
                  ],
                  "parameters": {
                     "collectionIDs": "{String: [UInt64]}",
                     "user": "String"
                  }
               }
            },
            "getNFTCatalogItemsWithMetadata": {
               "code": "import MetadataViews from 0x1d7e57aa55817448\nimport FIND from 0x097bafa4e0b48eef\nimport FindViews from 0x097bafa4e0b48eef\n\nimport FINDNFTCatalog from 0x097bafa4e0b48eef\n\npub fun main(user: String, collectionIDs: {String : [UInt64]}) : {String : [MetadataCollectionItem]} {\n    return fetchNFTCatalog(user: user, collectionIDs: collectionIDs)\n}\n\npub struct NFTView {\n    pub let id: UInt64\n    pub let display: MetadataViews.Display?\n    pub let collectionDisplay: MetadataViews.NFTCollectionDisplay?\n    pub var rarity:MetadataViews.Rarity?\n    pub var editions: MetadataViews.Editions?\n    pub var serial: UInt64?\n    pub var traits: MetadataViews.Traits?\n    pub let soulBounded: Bool \n    pub let nftType: Type\n\n    init(\n        id : UInt64,\n        display : MetadataViews.Display?,\n        editions : MetadataViews.Editions?,\n        rarity:MetadataViews.Rarity?,\n        serial: UInt64?,\n        traits: MetadataViews.Traits?,\n        collectionDisplay: MetadataViews.NFTCollectionDisplay?,\n        soulBounded: Bool ,\n        nftType: Type\n    ) {\n        self.id = id\n        self.display = display\n        self.editions = editions\n        self.rarity = rarity\n        self.serial = serial\n        self.traits = traits\n        self.collectionDisplay = collectionDisplay\n        self.soulBounded = soulBounded\n        self.nftType = nftType\n    }\n}\n\npub fun getNFTs(ownerAddress: Address, ids: {String : [UInt64]}) : [NFTView] {\n\n    let account = getAuthAccount(ownerAddress)\n\n    if account.balance == 0.0 {\n        return []\n    }\n\n    let results : [NFTView] = []\n    for collectionKey in ids.keys {\n        let catalogEntry = FINDNFTCatalog.getCatalogEntry(collectionIdentifier:collectionKey)!\n        let storagePath = catalogEntry.collectionData.storagePath\n        let ref= account.borrow\u003c\u0026{MetadataViews.ResolverCollection}\u003e(from: storagePath)\n        if ref != nil{\n            for id in ids[collectionKey]! {\n                // results.append(MetadataViews.getNFTView(id:id, viewResolver: ref!.borrowViewResolver(id:id)!))\n                let viewResolver = ref!.borrowViewResolver(id:id)!\n\n                var traitsStruct : MetadataViews.Traits? = nil \n\n                if let traits = MetadataViews.getTraits(viewResolver) {\n                    if let trait = getTrait(viewResolver) {\n                        var check = false \n                        for item in traits.traits {\n                            if item.name == trait.name {\n                                check = true \n                                break\n                            }\n                            if !check {\n                                let array = traits.traits\n                                array.append(trait)\n\n                                traitsStruct = cleanUpTraits(array)\n                            }\n                        }\n                    } else {\n                        traitsStruct = cleanUpTraits(traits.traits)\n                    }\n                } else {\n                    if let trait = getTrait(viewResolver) {\n                        traitsStruct = cleanUpTraits([trait])\n                    }\n                }\n\n                var editionStruct : MetadataViews.Editions? = nil \n\n                if let editions = MetadataViews.getEditions(viewResolver) {\n                    if let edition = getEdition(viewResolver) {\n                        var check = false\n                        for item in editions.infoList {\n                            if item.name == edition.name \u0026\u0026 item.number == edition.number \u0026\u0026 item.max == edition.max {\n                                check = true\n                                break\n                            }\n                        }\n                        // If the edition does not exist in editions, add it in\n                        if !check {\n                            let array = editions.infoList \n                            array.append(edition)\n                            editionStruct = MetadataViews.Editions(array)\n                        }\n                    } else {\n                    // If edition does not exist OR edition is already in editions , append it to views and continue\n                        editionStruct = editions\n                    }\n                } else if let edition = getEdition(viewResolver) {\n                        editionStruct = MetadataViews.Editions([edition])\n                }\n\n                results.append(\n                    NFTView(\n                        id : id,\n                        display: MetadataViews.getDisplay(viewResolver),\n                        editions : editionStruct,\n                        rarity : MetadataViews.getRarity(viewResolver),\n                        serial :  MetadataViews.getSerial(viewResolver)?.number,\n                        traits : traitsStruct,\n                        collectionDisplay : MetadataViews.getNFTCollectionDisplay(viewResolver),\n                        soulBounded : FindViews.checkSoulBound(viewResolver),\n                        nftType : viewResolver.getType()\n                    )\n                )\n            }\n        }\n    }\n    return results\n}\n\npub struct CollectionReport {\n    pub let items : {String : [MetadataCollectionItem]} \n    pub let collections : {String : Int} // mapping of collection to no. of ids \n    pub let extraIDs : {String : [UInt64]} \n\n    init(items: {String : [MetadataCollectionItem]},  collections : {String : Int}, extraIDs : {String : [UInt64]} ) {\n        self.items=items \n        self.collections=collections \n        self.extraIDs=extraIDs\n    }\n}\n\npub struct MetadataCollectionItem {\n    pub let id:UInt64\n    pub let name: String\n    pub let collection: String // \u003c- This will be Alias unless they want something else\n    pub let subCollection: String? // \u003c- This will be Alias unless they want something else\n    pub let nftDetailIdentifier: String\n    pub let soulBounded: Bool \n\n    pub let media  : String\n    pub let mediaType : String \n    pub let source : String \n\n    pub var rarity:MetadataViews.Rarity?\n    pub var editions: MetadataViews.Editions?\n    pub var serial: UInt64?\n    pub var traits: MetadataViews.Traits?\n\n    init(id:UInt64, \n         name: String, \n         collection: String, \n         subCollection: String?, \n         media  : String, \n         mediaType : String, \n         source : String, \n         nftDetailIdentifier: String, \n         editions : MetadataViews.Editions?,\n         rarity:MetadataViews.Rarity?,\n         serial: UInt64?,\n         traits: MetadataViews.Traits?,\n         soulBounded: Bool \n         ) {\n        self.id=id\n        self.name=name \n        self.collection=collection \n        self.subCollection=subCollection \n        self.media=media \n        self.mediaType=mediaType \n        self.source=source\n        self.nftDetailIdentifier=nftDetailIdentifier\n        self.editions=editions\n        self.rarity=rarity\n        self.serial=serial\n        self.traits=traits\n        self.soulBounded=soulBounded\n    }\n}\n\n// Helper function \n\npub fun resolveAddress(user: String) : PublicAccount? {\n    let address = FIND.resolve(user)\n    if address == nil {\n        return nil\n    }\n    return getAccount(address!)\n}\n\n\n//////////////////////////////////////////////////////////////\n// Fetch Specific Collections in Find Catalog\n//////////////////////////////////////////////////////////////\npub fun fetchNFTCatalog(user: String, collectionIDs: {String : [UInt64]}) : {String : [MetadataCollectionItem]} {\n    let source = \"NFTCatalog\"\n    let account = resolveAddress(user: user)\n    if account == nil { return {} }\n\n    let items : {String : [MetadataCollectionItem]} = {}\n\n    let fetchingIDs = collectionIDs\n\n\n    for project in fetchingIDs.keys {\n\n        let catalogEntry = FINDNFTCatalog.getCatalogEntry(collectionIdentifier:project)!\n        let projectName = catalogEntry.contractName\n\n        let returnedNFTs = getNFTs(ownerAddress: account!.address, ids: {project : fetchingIDs[project]!})\n\n        var collectionItems : [MetadataCollectionItem] = []\n        for nft in returnedNFTs {\n            if nft == nil {\n                continue\n            }\n\n            var subCollection = \"\"\n            if project != nft!.collectionDisplay!.name {\n             subCollection = nft!.collectionDisplay!.name\n            }\n\n            var name = nft!.display!.name \n            if name == \"\" {\n                name = projectName\n            }\n\n            if nft.editions != nil \u0026\u0026 nft.editions!.infoList.length \u003e 0 {\n                let edition = nft.editions!.infoList[0].number.toString()\n                // check if the name ends with \"editionNumber\"\n                // If the name ends with \"editionNumber\", we do not concat the edition\n                if name.length \u003e edition.length \u0026\u0026 name.slice(from: name.length - edition.length, upTo: name.length) != edition {\n                    name = name.concat(\"#\").concat(nft.editions!.infoList[0].number.toString())\n                }\n            }\n            \n            let item = MetadataCollectionItem(\n                id: nft!.id,\n                name: name,\n                collection: project,\n                subCollection: subCollection, \n                media: nft!.display!.thumbnail.uri(),\n                mediaType: \"image/png\",\n                source: source, \n                nftDetailIdentifier: nft!.nftType.identifier, \n                editions : nft!.editions,\n                rarity: nft!.rarity,\n                serial: nft!.serial,\n                traits: nft!.traits,\n                soulBounded: nft.soulBounded\n            )\n            collectionItems.append(item)\n        }\n\n        if collectionItems.length \u003e 0 {\n            items[project] = collectionItems\n        }\n    }\n    return items\n}\n\npub fun cleanUpTraits(_ traits: [MetadataViews.Trait]) : MetadataViews.Traits {\n    let dateValues  = {\"Date\" : true, \"Numeric\":false, \"Number\":false, \"date\":true, \"numeric\":false, \"number\":false}\n\n    let array : [MetadataViews.Trait] = []\n\n    for i , trait in traits {\n        let displayType = trait.displayType ?? \"string\"\n        if let isDate = dateValues[displayType] {\n            if isDate {\n                array.append(MetadataViews.Trait(name: trait.name, value: trait.value, displayType: \"Date\", rarity: trait.rarity))\n            } else {\n                array.append(MetadataViews.Trait(name: trait.name, value: trait.value, displayType: \"Numeric\", rarity: trait.rarity))\n            }\n        } else {\n            if let value = trait.value as? Bool {\n                if value {\n                    array.append(MetadataViews.Trait(name: trait.name, value: trait.value, displayType: \"Bool\", rarity: trait.rarity))\n                }else {\n                    array.append(MetadataViews.Trait(name: trait.name, value: trait.value, displayType: \"Bool\", rarity: trait.rarity))\n                }\n            } else if let value = trait.value as? String {\n                array.append(MetadataViews.Trait(name: trait.name, value: trait.value, displayType: \"String\", rarity: trait.rarity))\n            } else {\n                array.append(MetadataViews.Trait(name: trait.name, value: trait.value, displayType: \"String\", rarity: trait.rarity))\n            }\n        }\n    }\n    return MetadataViews.Traits(array)\n}\n\npub fun getTrait(_ viewResolver: \u0026{MetadataViews.Resolver}) : MetadataViews.Trait? {\n    if let view = viewResolver.resolveView(Type\u003cMetadataViews.Trait\u003e()) {\n        if let v = view as? MetadataViews.Trait {\n            return v\n        }\n    }\n    return nil\n}\n\npub fun getEdition(_ viewResolver: \u0026{MetadataViews.Resolver}) : MetadataViews.Edition? {\n    if let view = viewResolver.resolveView(Type\u003cMetadataViews.Edition\u003e()) {\n        if let v = view as? MetadataViews.Edition {\n            return v\n        }\n    }\n    return nil\n}",
               "spec": {
                  "order": [
                     "user",
                     "collectionIDs"
                  ],
                  "parameters": {
                     "collectionIDs": "{String: [UInt64]}",
                     "user": "String"
                  }
               }
            },
            "getNFTDetailsNFTCatalog": {
               "code": "import FindMarket from 0x097bafa4e0b48eef\nimport FindViews from 0x097bafa4e0b48eef\nimport FindUtils from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\nimport MetadataViews from 0x1d7e57aa55817448\nimport FINDNFTCatalog from 0x097bafa4e0b48eef\nimport FTRegistry from 0x097bafa4e0b48eef\nimport FindUserStatus from 0x097bafa4e0b48eef\n\npub struct NFTDetailReport {\n    pub let findMarket: {String : FindMarket.SaleItemInformation}\n    pub let storefront: FindUserStatus.StorefrontListing?\n    pub let storefrontV2: FindUserStatus.StorefrontListing?\n    pub let flowty: FindUserStatus.FlowtyListing?\n    pub let flowtyRental: FindUserStatus.FlowtyRental?\n    pub let flovatar: FindUserStatus.FlovatarListing?\n    pub let flovatarComponent: FindUserStatus.FlovatarComponentListing?\n    pub let nftDetail: NFTDetail?\n    pub let allowedListingActions: {String : ListingTypeReport}\n    pub let dapperAllowedListingActions: {String : ListingTypeReport}\n    pub let linkedForMarket : Bool?\n\n\n    init(findMarket:{String : FindMarket.SaleItemInformation}, storefront: FindUserStatus.StorefrontListing?, storefrontV2: FindUserStatus.StorefrontListing?, flowty: FindUserStatus.FlowtyListing?, flowtyRental: FindUserStatus.FlowtyRental? , flovatar: FindUserStatus.FlovatarListing? , flovatarComponent: FindUserStatus.FlovatarComponentListing? , nftDetail: NFTDetail?, allowedListingActions: {String : ListingTypeReport}, dapperAllowedListingActions: {String : ListingTypeReport}, linkedForMarket : Bool?) {\n        self.findMarket=findMarket\n        self.storefront=storefront\n        self.storefrontV2=storefrontV2\n        self.flowty=flowty\n        self.flowtyRental=flowtyRental\n        self.flovatar=flovatar\n        self.flovatarComponent=flovatarComponent\n        self.nftDetail=nftDetail\n        self.allowedListingActions=allowedListingActions\n        self.dapperAllowedListingActions=dapperAllowedListingActions\n        self.linkedForMarket = linkedForMarket\n    }\n}\n\n\npub struct ListingTypeReport {\n    pub let ftAlias: [String]\n    pub let ftIdentifiers: [String]\n    pub let listingType: String\n    pub let status: String\n    pub let ListingDetails: [ListingRoyalties]\n\n    init(listingType: String, ftAlias: [String], ftIdentifiers: [String],  status: String , ListingDetails: [ListingRoyalties]) {\n        self.listingType=listingType\n        self.status=status\n        self.ListingDetails=ListingDetails\n        self.ftAlias=ftAlias\n        self.ftIdentifiers=ftIdentifiers\n    }\n}\n\npub struct NFTDetail {\n    pub let id: UInt64\n    pub let uuid: UInt64\n    pub let name:String\n    pub let description:String\n    pub let thumbnail:String\n    pub let type: String\n    pub var externalViewURL: String?\n    pub var rarity:MetadataViews.Rarity?\n    pub var editions: [MetadataViews.Edition]\n    pub var serial: UInt64?\n    pub var traits: [MetadataViews.Trait]\n    pub var media : {String: String} //url to mediaType\n    pub var collection : NFTCollectionDisplay?\n    pub var license : String?\n    pub var data: {String : AnyStruct?}\n    pub var soulBounded: Bool\n    pub var views :[String]\n\n    init(_ pointer: FindViews.ViewReadPointer, views: {String : AnyStruct}, resolvedViews: [Type]){\n\n        self.type=pointer.itemType.identifier\n        self.id=pointer.id\n        self.uuid=pointer.getUUID()\n\n        // Display\n        let display = views[\"Display\"] ?? panic(\"Could not find display\")\n        let d = display as! MetadataViews.Display\n        self.name=d.name\n        self.description=d.description\n        self.thumbnail=d.thumbnail.uri()\n        views.remove(key: \"Display\")\n\n        // External URL\n        self.externalViewURL = nil\n        if let externalURL = views[\"ExternalURL\"] {\n            if let e = externalURL as? MetadataViews.ExternalURL {\n                self.externalViewURL = e.url\n            }\n        }\n        views.remove(key: \"ExternalURL\")\n\n        // Edition\n        self.editions=[]\n        if let editions = views[\"Editions\"] {\n            if let e = editions as? MetadataViews.Editions {\n                if e.infoList.length \u003e 0 {\n                    self.editions=e.infoList\n                }\n            }\n        }\n        views.remove(key: \"Editions\")\n\n        // Serial\n        self.serial=nil\n        if let serial = views[\"Serial\"] {\n            if let s = serial as? MetadataViews.Serial {\n                self.serial=s.number\n            }\n        }\n        views.remove(key: \"Serial\")\n\n        // subCollection\n        self.collection=nil\n        if let grouping = views[\"NFTCollectionDisplay\"] {\n            if let sc = grouping as? MetadataViews.NFTCollectionDisplay {\n                self.collection=NFTCollectionDisplay(sc)\n            }\n        }\n        views.remove(key: \"NFTCollectionDisplay\")\n\n        // Medias\n        self.media={}\n        if let medias= views[\"Medias\"] {\n            if let ms = medias as? MetadataViews.Medias {\n                for m in ms.items {\n                    let url = m.file.uri()\n                    let type = m.mediaType\n                    self.media[url] = type\n                }\n            }\n        }\n        views.remove(key: \"Medias\")\n\n        // Rarity\n        self.rarity=nil\n        if let rarity= views[\"Rarity\"] {\n            if let r = rarity as? MetadataViews.Rarity {\n                self.rarity = r\n            }\n        }\n        views.remove(key: \"Rarity\")\n\n        // Traits\n        self.traits=[]\n        if let traits = views[\"Traits\"] {\n            if let t = traits as? MetadataViews.Traits {\n                if t.traits.length \u003e 0 {\n                    self.traits=t.traits\n                }\n            }\n        }\n        views.remove(key: \"Traits\")\n\n        // License\n        self.license= nil\n        if let license= views[\"License\"] {\n            if let l = license as? MetadataViews.License {\n                self.license = l.spdxIdentifier\n            }\n        }\n        views.remove(key: \"License\")\n\n        self.soulBounded = false\n        if let soulBound= views[\"SoulBound\"] {\n            self.soulBounded = true\n        }\n        views.remove(key: \"SoulBound\")\n\n        self.views=[]\n\n        for view in pointer.getViews() {\n            if defaultViews().contains(view) {\n                continue\n            }\n            if resolvedViews.contains(view) {\n                continue\n            }\n            self.views.append(view.identifier)\n        }\n        self.data=views\n\n    }\n}\n\npub struct ListingRoyalties {\n\n    pub let ftAlias: String?\n    pub let ftIdentifier: String\n    pub let royalties: [Royalties]\n\n    init(ftAlias: String?, ftIdentifier: String, royalties: [Royalties]) {\n        self.ftAlias=ftAlias\n        self.ftIdentifier=ftIdentifier\n        self.royalties=royalties\n    }\n}\n\npub struct Royalties {\n\n    pub let royaltyName: String\n    pub let address: Address\n    pub let findName: String?\n    pub let cut: UFix64\n\n    init(royaltyName: String , address: Address, findName: String?, cut: UFix64) {\n        self.royaltyName=royaltyName\n        self.address=address\n        self.findName=findName\n        self.cut=cut\n    }\n}\n\npub struct NFTCollectionDisplay {\n    // Name that should be used when displaying this NFT collection.\n    pub let name: String\n\n    // Description that should be used to give an overview of this collection.\n    pub let description: String\n\n    // External link to a URL to view more information about this collection.\n    pub let externalURL: String\n\n    // Square-sized image to represent this collection.\n    pub let squareImage: {String : String}\n\n    // Banner-sized image for this collection, recommended to have a size near 1200x630.\n    pub let bannerImage: {String : String}\n\n    // Social links to reach this collection's social homepages.\n    // Possible keys may be \"instagram\", \"twitter\", \"discord\", etc.\n    pub let socials: {String: String}\n\n    init(\n        _ nftCD : MetadataViews.NFTCollectionDisplay\n    ) {\n        self.name = nftCD.name\n        self.description = nftCD.description\n        self.externalURL = nftCD.externalURL.url\n\n        let squareImage = {nftCD.squareImage.file.uri() : nftCD.squareImage.mediaType}\n        self.squareImage = squareImage\n\n        let bannerImage = {nftCD.bannerImage.file.uri() : nftCD.bannerImage.mediaType}\n        self.bannerImage = bannerImage\n\n        let socials : {String : String} = {}\n        for key in nftCD.socials.keys{\n            socials[key] = nftCD.socials[key]!.url\n        }\n        self.socials = socials\n    }\n}\n\npub var counter = 0\n\npub fun main(user: String, project:String, id: UInt64, views: [String]) : NFTDetailReport?{\n    let resolveAddress = FIND.resolve(user)\n    if resolveAddress == nil {\n        return nil\n    }\n    let address = resolveAddress!\n\n    let account = getAuthAccount(address)\n\n    if account.balance \u003e 0.0 {\n        // check link for market\n        let linkedForMarket = account.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(getPublicPath(project)).check()\n\n        let storagePath = getStoragePath(project)\n        let publicPath = PublicPath(identifier: \"find_temp_path_\".concat(counter.toString()))!\n        counter = counter + 1\n        account.link\u003c\u0026{MetadataViews.ResolverCollection}\u003e(publicPath, target: storagePath)\n        let cap = account.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(publicPath)\n        if !cap.check() {\n            panic(\"The user does not set up collection correctly.\")\n        }\n        let pointer = FindViews.ViewReadPointer(cap: cap, id: id)\n\n        let nftDetail = getNFTDetail(pointer:pointer, views: views)\n        if nftDetail == nil {\n            return nil\n        }\n\n\n        let findAddress=FindMarket.getFindTenantAddress()\n        var findMarket=FindMarket.getNFTListing(tenant:findAddress, address: address, id: nftDetail!.uuid, getNFTInfo:false)\n\n        var report : {String : ListingTypeReport} = {}\n        var dapperReport : {String : ListingTypeReport} = {}\n\n        // check if that's soulBound, if yes, the report will be nil\n        if !pointer.checkSoulBound() {\n            let tenantCap = FindMarket.getTenantCapability(findAddress)!\n            let tenantRef = tenantCap.borrow() ?? panic(\"This tenant is not set up. Tenant : \".concat(tenantCap.address.toString()))\n\n            let marketTypes = FindMarket.getSaleItemTypes()\n\n            for marketType in marketTypes {\n                if let allowedListing = tenantRef.getAllowedListings(nftType: pointer.getItemType(), marketType: marketType) {\n                    report[FindMarket.getMarketOptionFromType(marketType)] = createListingTypeReport(allowedListing, pointer: pointer, tenantRef: tenantRef, dapper: false)\n                    dapperReport[FindMarket.getMarketOptionFromType(marketType)] = createListingTypeReport(allowedListing, pointer: pointer, tenantRef: tenantRef, dapper: true)\n                }\n            }\n        }\n\n        let nftType = pointer.itemType\n        let listingsV1 = FindUserStatus.getStorefrontListing(user: address, id : id, type: nftType)\n        let listingsV2 = FindUserStatus.getStorefrontV2Listing(user: address, id : id, type: nftType)\n        let flowty = FindUserStatus.getFlowtyListing(user: address, id : id, type: nftType)\n        let flowtyRental = FindUserStatus.getFlowtyRentals(user: address, id : id, type: nftType)\n        let flovatar = FindUserStatus.getFlovatarListing(user: address, id : id, type: nftType)\n        let flovatarComponent = FindUserStatus.getFlovatarComponentListing(user: address, id : id, type: nftType)\n\n        return NFTDetailReport(findMarket:findMarket, storefront:listingsV1, storefrontV2: listingsV2, flowty:flowty, flowtyRental:flowtyRental, flovatar:flovatar, flovatarComponent:flovatarComponent, nftDetail: nftDetail, allowedListingActions: report, dapperAllowedListingActions: dapperReport, linkedForMarket : linkedForMarket)\n    }\n    return nil\n\n}\n\npub let resolvedAddresses : {Address : String} = {}\n\npub var nftRoyalties : [Royalties]? = nil\n\npub fun reverseLookup(_ addr: Address) : String? {\n\n    if let name = resolvedAddresses[addr] {\n        if name == \"\" {\n            return nil\n        } else {\n            return name\n        }\n    }\n    let name = FIND.reverseLookup(addr)\n    if name == nil {\n        resolvedAddresses[addr] = \"\"\n    } else {\n        resolvedAddresses[addr] = name\n    }\n    return name\n\n}\n\npub fun getNFTDetail(pointer: FindViews.ViewReadPointer, views: [String]) : NFTDetail? {\n\n    if !pointer.valid() {\n        return nil\n    }\n\n    var nftViews: {String : AnyStruct} = {}\n    var resolvedViews: [Type] = []\n    let viewResolver = pointer.getViewResolver()\n\n    let defaultViews = defaultViews()\n    for view in views {\n        if let runTimeType = CompositeType(view) {\n            if !defaultViews.contains(runTimeType) {\n                defaultViews.append(runTimeType)\n            }\n        }\n    }\n\n\n    for runTimeType in defaultViews {\n        // Resolve arrayed views to ensure we didn't miss any stuff\n        if runTimeType == Type\u003cMetadataViews.Editions\u003e() {\n            if let editions = MetadataViews.getEditions(viewResolver) {\n                if let edition = getEdition(viewResolver) {\n                    var check = false\n                    for item in editions.infoList {\n                        if item.name == edition.name \u0026\u0026 item.number == edition.number \u0026\u0026 item.max == edition.max {\n                            check = true\n                            break\n                        }\n                    }\n                    // If the edition does not exist in editions, add it in\n                    if !check {\n                        let array = editions.infoList\n                        array.append(edition)\n                        nftViews[\"Editions\"] = MetadataViews.Editions(array)\n                        resolvedViews.append(runTimeType)\n                        continue\n                    }\n                }\n                // If edition does not exist OR edition is already in editions , append it to views and continue\n                nftViews[\"Editions\"] = editions\n                resolvedViews.append(runTimeType)\n                continue\n            }\n        }\n\n        if runTimeType == Type\u003cMetadataViews.Edition\u003e() {\n            // If the editions does not exist, check if there is edition, if there is, add it in as editions\n            if nftViews[\"Editions\"] == nil {\n                if let edition = getEdition(viewResolver) {\n                    nftViews[\"Editions\"] = MetadataViews.Editions([edition])\n                    resolvedViews.append(runTimeType)\n                }\n            }\n            continue\n        }\n\n        if runTimeType == Type\u003cMetadataViews.Medias\u003e() {\n            if let medias = MetadataViews.getMedias(viewResolver) {\n                if let media = getMedia(viewResolver) {\n                    var check = false\n                    let uri = media.file.uri()\n                    for item in medias.items {\n                        if item.file.uri() == uri {\n                            check = true\n                            break\n                        }\n                        if !check {\n                            let array = medias.items\n                            array.append(media)\n                            nftViews[\"Medias\"] = MetadataViews.Medias(array)\n                            resolvedViews.append(runTimeType)\n                            continue\n                        }\n                    }\n                }\n                nftViews[\"Medias\"] = medias\n                resolvedViews.append(runTimeType)\n                continue\n            }\n        }\n\n        if runTimeType == Type\u003cMetadataViews.Media\u003e() {\n            if nftViews[\"Medias\"] == nil {\n                if let media = getMedia(viewResolver) {\n                    nftViews[\"Medias\"] = MetadataViews.Medias([media])\n                    resolvedViews.append(runTimeType)\n                }\n            }\n            continue\n        }\n\n        if runTimeType == Type\u003cMetadataViews.Traits\u003e() {\n            if let traits = MetadataViews.getTraits(viewResolver) {\n                if let trait = getTrait(viewResolver) {\n                    var check = false\n                    for item in traits.traits {\n                        if item.name == trait.name {\n                            check = true\n                            break\n                        }\n                        if !check {\n                            let array = traits.traits\n                            array.append(trait)\n\n                            nftViews[\"Traits\"] = cleanUpTraits(array)\n                            resolvedViews.append(runTimeType)\n                            continue\n                        }\n                    }\n                }\n                nftViews[\"Traits\"] = cleanUpTraits(traits.traits)\n                resolvedViews.append(runTimeType)\n                continue\n            }\n        }\n\n        if runTimeType == Type\u003cMetadataViews.Trait\u003e() {\n            if nftViews[\"Traits\"] == nil {\n                if let trait = getTrait(viewResolver) {\n                    nftViews[\"Traits\"] = MetadataViews.Traits([trait])\n                    resolvedViews.append(runTimeType)\n                }\n            }\n            continue\n        }\n\n        if let view = pointer.resolveView(runTimeType) {\n            let name = FindUtils.splitString(runTimeType.identifier, sep: \".\")[3]\n            nftViews[name] = view\n            resolvedViews.append(runTimeType)\n        }\n    }\n\n    return NFTDetail(pointer, views: nftViews, resolvedViews: resolvedViews)\n\n\n}\n\npub fun getEdition(_ viewResolver: \u0026{MetadataViews.Resolver}) : MetadataViews.Edition? {\n    if let view = viewResolver.resolveView(Type\u003cMetadataViews.Edition\u003e()) {\n        if let v = view as? MetadataViews.Edition {\n            return v\n        }\n    }\n    return nil\n}\n\npub fun getMedia(_ viewResolver: \u0026{MetadataViews.Resolver}) : MetadataViews.Media? {\n    if let view = viewResolver.resolveView(Type\u003cMetadataViews.Media\u003e()) {\n        if let v = view as? MetadataViews.Media {\n            return v\n        }\n    }\n    return nil\n}\n\npub fun getTrait(_ viewResolver: \u0026{MetadataViews.Resolver}) : MetadataViews.Trait? {\n    if let view = viewResolver.resolveView(Type\u003cMetadataViews.Trait\u003e()) {\n        if let v = view as? MetadataViews.Trait {\n            return v\n        }\n    }\n    return nil\n}\n\n/* Helper Function */\npub fun resolveRoyalties(_ pointer: FindViews.ViewReadPointer) : [Royalties] {\n    let array : [Royalties] = []\n    for royalty in pointer.getRoyalty().getRoyalties() {\n        let address = royalty.receiver.address\n        array.append(Royalties(royaltyName: royalty.description, address: address, findName: reverseLookup(address), cut: royalty.cut))\n    }\n\n    return array\n}\n\npub fun resolveMarketplaceRoyalties(tenantRef: \u0026FindMarket.Tenant{FindMarket.TenantPublic}, listing: Type, nft: Type, ft: Type) : [Royalties] {\n\n    let cuts = tenantRef.getCuts(name:\"\", listingType: listing, nftType:nft, ftType:ft)\n\n    let royalties :[Royalties] = []\n\n    for allCuts in cuts.values {\n        for cut in allCuts.cuts {\n            royalties.append(Royalties(royaltyName: cut.getName(), address: cut.getAddress(), findName: reverseLookup(cut.getAddress()), cut: cut.getCut()))\n        }\n    }\n\n    return royalties\n}\n\npub fun createListingTypeReport(_ allowedListing: FindMarket.AllowedListing, pointer: FindViews.ViewReadPointer, tenantRef: \u0026FindMarket.Tenant{FindMarket.TenantPublic}, dapper: Bool) : ListingTypeReport? {\n    let listingType = allowedListing.listingType.identifier\n    var ftAlias : [String] = []\n    var ftIdentifier : [String] = []\n    var listingDetails : [ListingRoyalties] = []\n    for ft in allowedListing.ftTypes {\n        var alias : String? = nil\n        let ftInfo = FTRegistry.getFTInfo(ft.identifier) ?? panic(ft.identifier.concat(\" is not added to FTRegistry yet.\"))\n        switch dapper {\n            case true :\n                if !ftInfo.tag.contains(\"dapper\") {\n                    continue\n                }\n\n            case false :\n                if ftInfo.tag.contains(\"dapper\") {\n                    continue\n                }\n        }\n        alias = ftInfo.alias\n        ftAlias.append(ftInfo.alias)\n        ftIdentifier.append(ft.identifier)\n\n        // getRoyalties\n        var nftR = nftRoyalties\n        if nftR == nil {\n            nftRoyalties = resolveRoyalties(pointer)\n            nftR = nftRoyalties\n        }\n\n        let findR = resolveMarketplaceRoyalties(tenantRef: tenantRef, listing: allowedListing.listingType , nft: pointer.getItemType(), ft: ft)\n        findR.appendAll(nftR!)\n\n        listingDetails.append(ListingRoyalties(ftAlias: alias, ftIdentifier: ft.identifier, royalties: findR))\n    }\n\n    if ftIdentifier.length == 0 {\n        return nil\n    }\n\n    return ListingTypeReport(listingType: listingType, ftAlias: ftAlias, ftIdentifiers: ftIdentifier,  status: allowedListing.status , ListingDetails: listingDetails)\n}\n\npub fun defaultViews() : [Type] {\n    return [\n    Type\u003cMetadataViews.Display\u003e() ,\n    Type\u003cMetadataViews.Editions\u003e() ,\n    Type\u003cMetadataViews.Edition\u003e() ,\n    Type\u003cMetadataViews.Serial\u003e() ,\n    Type\u003cMetadataViews.Medias\u003e() ,\n    Type\u003cMetadataViews.Media\u003e() ,\n    Type\u003cMetadataViews.License\u003e() ,\n    Type\u003cMetadataViews.ExternalURL\u003e() ,\n    Type\u003cMetadataViews.NFTCollectionDisplay\u003e() ,\n    Type\u003cMetadataViews.Traits\u003e() ,\n    Type\u003cMetadataViews.Trait\u003e() ,\n    Type\u003cMetadataViews.Rarity\u003e(),\n    Type\u003cFindViews.SoulBound\u003e()\n    ]\n}\n\npub fun getStoragePath(_ nftIdentifier: String) : StoragePath {\n    if let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys {\n        let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])!\n        return collection.collectionData.storagePath\n    }\n\n    if let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier :nftIdentifier) {\n        return collection.collectionData.storagePath\n    }\n    panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier))\n}\n\npub fun getPublicPath(_ nftIdentifier: String) : PublicPath {\n    if let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys {\n        let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])!\n        return collection.collectionData.publicPath\n    }\n\n    if let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier :nftIdentifier) {\n        return collection.collectionData.publicPath\n    }\n    panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier))\n}\n\npub fun cleanUpTraits(_ traits: [MetadataViews.Trait]) : MetadataViews.Traits {\n    let dateValues  = {\"Date\" : true, \"Numeric\":false, \"Number\":false, \"date\":true, \"numeric\":false, \"number\":false}\n\n    let array : [MetadataViews.Trait] = []\n\n    for i , trait in traits {\n        let displayType = trait.displayType ?? \"string\"\n        if let isDate = dateValues[displayType] {\n            if isDate {\n                array.append(MetadataViews.Trait(name: trait.name, value: trait.value, displayType: \"Date\", rarity: trait.rarity))\n            } else {\n                array.append(MetadataViews.Trait(name: trait.name, value: trait.value, displayType: \"Numeric\", rarity: trait.rarity))\n            }\n        } else {\n            if let value = trait.value as? Bool {\n                if value {\n                    array.append(MetadataViews.Trait(name: trait.name, value: trait.value, displayType: \"Bool\", rarity: trait.rarity))\n                }else {\n                    array.append(MetadataViews.Trait(name: trait.name, value: trait.value, displayType: \"Bool\", rarity: trait.rarity))\n                }\n            } else if let value = trait.value as? String {\n                array.append(MetadataViews.Trait(name: trait.name, value: trait.value, displayType: \"String\", rarity: trait.rarity))\n            } else {\n                array.append(MetadataViews.Trait(name: trait.name, value: trait.value, displayType: \"String\", rarity: trait.rarity))\n            }\n        }\n    }\n    return MetadataViews.Traits(array)\n}",
               "spec": {
                  "order": [
                     "user",
                     "project",
                     "id",
                     "views"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "project": "String",
                     "user": "String",
                     "views": "[String]"
                  }
               }
            },
            "getNFTDetailsShard1": {
               "code": "import FIND from 0x097bafa4e0b48eef\nimport AlchemyMetadataWrapperMainnetShard1 from 0xeb8cb4c3157d5dac\n\npub fun main(user: String , project: String, id: UInt64, views: [String]) : AlchemyMetadataWrapperMainnetShard1.NFTData? {\n\n    if let address = FIND.resolve(user) {\n        let ids : {String:[UInt64]} = {project : [id]}\n        let res = AlchemyMetadataWrapperMainnetShard1.getNFTs(ownerAddress: address, ids: ids)\n        if res.length == 0 || res[0] == nil {\n            return nil\n        }\n        return res[0]!\n    }\n    return nil\n\n}",
               "spec": {
                  "order": [
                     "user",
                     "project",
                     "id",
                     "views"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "project": "String",
                     "user": "String",
                     "views": "[String]"
                  }
               }
            },
            "getNFTDetailsShard2": {
               "code": "import FIND from 0x097bafa4e0b48eef\nimport AlchemyMetadataWrapperMainnetShard2 from 0xeb8cb4c3157d5dac\n\npub fun main(user: String , project: String, id: UInt64, views: [String]) : AlchemyMetadataWrapperMainnetShard2.NFTData? {\n\n    if let address = FIND.resolve(user) {\n        let ids : {String:[UInt64]} = {project : [id]}\n        let res = AlchemyMetadataWrapperMainnetShard2.getNFTs(ownerAddress: address, ids: ids)\n        if res.length == 0 || res[0] == nil {\n            return nil\n        }\n        return res[0]!\n    }\n    return nil\n\n}",
               "spec": {
                  "order": [
                     "user",
                     "project",
                     "id",
                     "views"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "project": "String",
                     "user": "String",
                     "views": "[String]"
                  }
               }
            },
            "getNFTDetailsShard3": {
               "code": "import FIND from 0x097bafa4e0b48eef\nimport AlchemyMetadataWrapperMainnetShard3 from 0xeb8cb4c3157d5dac\n\npub fun main(user: String , project: String, id: UInt64, views: [String]) : AlchemyMetadataWrapperMainnetShard3.NFTData? {\n\n    if let address = FIND.resolve(user) {\n        let ids : {String:[UInt64]} = {project : [id]}\n        let res = AlchemyMetadataWrapperMainnetShard3.getNFTs(ownerAddress: address, ids: ids)\n        if res.length == 0 || res[0] == nil {\n            return nil\n        }\n        return res[0]!\n    }\n    return nil\n\n}",
               "spec": {
                  "order": [
                     "user",
                     "project",
                     "id",
                     "views"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "project": "String",
                     "user": "String",
                     "views": "[String]"
                  }
               }
            },
            "getNFTDetailsShard4": {
               "code": "import FIND from 0x097bafa4e0b48eef\nimport AlchemyMetadataWrapperMainnetShard4 from 0xeb8cb4c3157d5dac\n\npub fun main(user: String , project: String, id: UInt64, views: [String]) : AlchemyMetadataWrapperMainnetShard4.NFTData? {\n\n    if let address = FIND.resolve(user) {\n        let ids : {String:[UInt64]} = {project : [id]}\n        let res = AlchemyMetadataWrapperMainnetShard4.getNFTs(ownerAddress: address, ids: ids)\n        if res.length == 0 || res[0] == nil {\n            return nil\n        }\n        return res[0]!\n    }\n    return nil\n\n}",
               "spec": {
                  "order": [
                     "user",
                     "project",
                     "id",
                     "views"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "project": "String",
                     "user": "String",
                     "views": "[String]"
                  }
               }
            },
            "getNFTDetailsSocks": {
               "code": "import FIND from 0x097bafa4e0b48eef\nimport RaribleNFT from 0x01ab36aaf654a13e\n\npub fun main(user: String , project: String, id: UInt64, views: [String]) : NFTData? {\n\n    if let address = FIND.resolve(user) {\n        if let uuid = getSocks(ownerAddress: address, id: id) {\n\n            let contract = NFTContractData(\n                name: \"RaribleNFT\",\n                address: 0x01ab36aaf654a13e,\n                storage_path: \"/storage/RaribleNFTCollection\",\n                public_path: \"/public/RaribleNFTCollection\",\n                public_collection_name: \"CollectionPublic\",\n                external_domain: \"https://rarible.com/\"\n            )\n\n            return NFTData(\n                contract: contract,\n                id: id,\n                uuid: uuid,\n                title: \"Flowverse socks\",\n                description: \"Socks by Flowverse NFTs were designed by NYC-based metaverse artist Jenny Jiang. The 111 Socks were then distributed to some of the earliest, most committed and most engaged Flowverse community members for Christmas 2021.\",\n                external_domain_view_url: nil,\n                token_uri: nil,\n                media: [\n                    NFTMedia(uri: \"https://img.rarible.com/prod/video/upload/t_video_big/prod-itemAnimations/FLOW-A.01ab36aaf654a13e.RaribleNFT:15029/b1cedf3\", mimetype: \"video\")\n                ],\n                metadata: {}\n            )\n        }\n    }\n    return nil\n\n}\n\npub fun getSocks(ownerAddress: Address, id: UInt64) : UInt64? {\n\n    let account = getAuthAccount(ownerAddress)\n    let ref = account.borrow\u003c\u0026RaribleNFT.Collection\u003e(from: RaribleNFT.collectionStoragePath)\n    if ref != nil {\n        let nfts = ref!\n        if nfts.ownedNFTs.containsKey(id) {\n            return ref!.borrowNFT(id: id).uuid\n        }\n    }\n    \n    return nil\n}\n\npub let FlowverseSocksIds : [UInt64] = [14813, 15013, 14946, 14808, 14899, 14792, 15016, 14961, 14816, 14796, 14992, 14977, 14815, 14863, 14817, 14814, 14875, 14960, 14985, 14850, 14849, 14966, 14826, 14972, 14795, 15021, 14950, 14847, 14970, 14833, 14786, 15010, 14953, 14799, 14883, 14947, 14844, 14801, 14886, 15015, 15023, 15027, 15029, 14802, 14810, 14948, 14955, 14957, 14988, 15007, 15009, 14837, 15024, 14803, 14973, 14969, 15002, 15017, 14797, 14894, 14881, 15025, 14791, 14979, 14789, 14993, 14873, 14939, 15005, 15006, 14869, 14889, 15004, 15008, 15026, 14990, 14998, 14898, 14819, 14840, 14974, 15019, 14856, 14838, 14787, 14876, 14996, 14798, 14855, 14824, 14843, 14959, 15020, 14862, 14822, 14897, 14830, 14790, 14867, 14878, 14991, 14835, 14818, 14892, 14800, 15000, 14857, 14986, 14805, 14812, 14962]\n\npub struct NFTData {\n    pub let contract: NFTContractData\n    pub let id: UInt64\n    pub let uuid: UInt64?\n    pub let title: String?\n    pub let description: String?\n    pub let external_domain_view_url: String?\n    pub let token_uri: String?\n    pub let media: [NFTMedia?]\n    pub let metadata: {String: String?}\n\n    init(\n        contract: NFTContractData,\n        id: UInt64,\n        uuid: UInt64?,\n        title: String?,\n        description: String?,\n        external_domain_view_url: String?,\n        token_uri: String?,\n        media: [NFTMedia?],\n        metadata: {String: String?}\n    ) {\n        self.contract = contract\n        self.id = id\n        self.uuid = uuid\n        self.title = title\n        self.description = description\n        self.external_domain_view_url = external_domain_view_url\n        self.token_uri = token_uri\n        self.media = media\n        self.metadata = metadata\n    }\n}\n\npub struct NFTContractData {\n    pub let name: String\n    pub let address: Address\n    pub let storage_path: String\n    pub let public_path: String\n    pub let public_collection_name: String\n    pub let external_domain: String\n\n    init(\n        name: String,\n        address: Address,\n        storage_path: String,\n        public_path: String,\n        public_collection_name: String,\n        external_domain: String\n    ) {\n        self.name = name\n        self.address = address\n        self.storage_path = storage_path\n        self.public_path = public_path\n        self.public_collection_name = public_collection_name\n        self.external_domain = external_domain\n    }\n}\n\npub struct NFTMedia {\n    pub let uri: String?\n    pub let mimetype: String?\n\n    init(\n        uri: String?,\n        mimetype: String?\n    ) {\n        self.uri = uri\n        self.mimetype = mimetype\n    }\n}",
               "spec": {
                  "order": [
                     "user",
                     "project",
                     "id",
                     "views"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "project": "String",
                     "user": "String",
                     "views": "[String]"
                  }
               }
            },
            "getNFTIds": {
               "code": "import NonFungibleToken from 0x1d7e57aa55817448\nimport GooberXContract from 0x34f2bf4a80bb0f69\n\nimport SturdyItems from 0x427ceada271aa0b1\nimport UFC_NFT from 0x329feb3ab062d289\n\nimport Gaia from 0x8b148183c28ff88f\n\nimport MatrixWorldFlowFestNFT from 0x2d2750f240198f91\nimport DGD_NFT from 0x329feb3ab062d289\nimport The_Next_Cartel_NFT from 0x329feb3ab062d289\nimport OneFootballCollectible from 0x6831760534292098\nimport MatrixWorldAssetsNFT from 0xf20df769e658c257\nimport Necryptolis from 0x718efe5e88fe48ea\nimport RareRooms_NFT from 0x329feb3ab062d289\nimport CNN_NFT from 0x329feb3ab062d289\nimport Evolution from 0xf4264ac8f3256818\nimport MintStoreItem from 0x20187093790b9aef\nimport MotoGPCard from 0xa49cc0ee46c54bfb\nimport SomePlaceCollectible from 0x667a16294a089ef8\nimport Canes_Vault_NFT from 0x329feb3ab062d289\nimport RaceDay_NFT from 0x329feb3ab062d289\nimport GeniaceNFT from 0xabda6627c70c7f52\nimport GoatedGoats from 0x2068315349bdfce5\nimport HaikuNFT from 0xf61e40c19db2a9e2\nimport KlktnNFT from 0xabd6e80be7e9682c\nimport Mynft from 0xf6fcbef550d97aa5\nimport BarterYardPackNFT from 0xa95b021cf8a30d80\nimport Moments from 0xd4ad4740ee426334\nimport CryptoPiggo from 0xd3df824bf81910a4\nimport GoatedGoatsVouchers from 0xdfc74d9d561374c0\nimport TraitPacksVouchers from 0xdfc74d9d561374c0\nimport GoatedGoatsTrait from 0x2068315349bdfce5\nimport GoatedGoatsTraitPack from 0x2068315349bdfce5\nimport Art from 0xd796ff17107bbff6\nimport Marketplace from 0xd796ff17107bbff6\nimport Flovatar from 0x921ea449dffec68a\nimport FlovatarMarketplace from  0x921ea449dffec68a\nimport CharityNFT from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\n\n\nimport NeoAvatar from 0xb25138dbf45e5801\nimport NeoVoucher from 0xb25138dbf45e5801\nimport NeoMember from 0xb25138dbf45e5801\nimport NeoViews from 0xb25138dbf45e5801\nimport MetadataViews from 0x1d7e57aa55817448\nimport BarterYardClubWerewolf from  0x28abb9f291cadaf2\n\n//Jambb\nimport Vouchers from 0x444f5ea22c6ea12c\n\n//xtingles\nimport Collectible from 0xf5b0eb433389ac3f\n\nimport Momentables from 0x9d21537544d9123d\nimport ZeedzINO from 0x62b3063fbe672fc8\nimport PartyMansionDrinksContract from 0x34f2bf4a80bb0f69\n\nimport DayNFT from 0x1600b04bf033fb99\nimport RaribleNFT from 0x01ab36aaf654a13e\n\nimport FLOAT from 0x2d4c3caffbeab845\n\nimport Bl0x from 0x7620acf6d7f2468a\nimport Bl0xPack from 0x7620acf6d7f2468a\n\n\npub fun getNFTIDs(ownerAddress: Address): {String: [UInt64]} {\n    let account = getAccount(ownerAddress)\n    if account.balance == 0.0 {\n        return {}\n    }\n    let ids: {String: [UInt64]} = {}\n\n\n    let flovatarCap = account.getCapability\u003c\u0026{Flovatar.CollectionPublic}\u003e(Flovatar.CollectionPublicPath)  \n    if flovatarCap.check() {\n        ids[\"Flovatar\"]=flovatarCap.borrow()!.getIDs()\n    }\n\n    let flovatarMarketCap = account.getCapability\u003c\u0026{FlovatarMarketplace.SalePublic}\u003e(FlovatarMarketplace.CollectionPublicPath)\n    if flovatarMarketCap.check() {\n        ids[\"FlovatarForSale\"]=flovatarMarketCap.borrow()!.getFlovatarIDs()\n    }\n\n    let versusMarketplace = account.getCapability\u003c\u0026{Marketplace.SalePublic}\u003e(Marketplace.CollectionPublicPath)\n    if versusMarketplace.check() {\n        ids[\"VersusForSale\"]=versusMarketplace.borrow()!.getIDs()\n    }\n\n    let versusArtCap=account.getCapability\u003c\u0026{Art.CollectionPublic}\u003e(Art.CollectionPublicPath)\n    if versusArtCap.check() {\n        ids[\"Versus\"]=versusArtCap.borrow()!.getIDs()\n    }\n\n    let goobersCap = account.getCapability\u003c\u0026GooberXContract.Collection{NonFungibleToken.CollectionPublic, GooberXContract.GooberCollectionPublic}\u003e(GooberXContract.CollectionPublicPath)\n    if goobersCap.check() {\n        ids[\"Gooberz\"] = goobersCap.borrow()!.getIDs()\n    }\n\n    let partyMansionDrinksCap = account.getCapability\u003c\u0026{PartyMansionDrinksContract.DrinkCollectionPublic}\u003e(PartyMansionDrinksContract.CollectionPublicPath)\n    if partyMansionDrinksCap.check() {\n        ids[\"PartyMansionDrinksContract\"] = partyMansionDrinksCap.borrow()!.getIDs()\n    }\n\n    let rareRoomCap = account.getCapability\u003c\u0026RareRooms_NFT.Collection{RareRooms_NFT.RareRooms_NFTCollectionPublic}\u003e(RareRooms_NFT.CollectionPublicPath)\n    if rareRoomCap.check() {\n        ids[\"RareRooms\"] = rareRoomCap.borrow()!.getIDs()\n    }\n\n    let cnnCap = account.getCapability\u003c\u0026CNN_NFT.Collection{CNN_NFT.CNN_NFTCollectionPublic}\u003e(CNN_NFT.CollectionPublicPath)\n    if cnnCap.check() {\n        ids[\"CNN\"] = cnnCap.borrow()!.getIDs()\n    }\n\n    let canesVaultCap = account.getCapability\u003c\u0026Canes_Vault_NFT.Collection{Canes_Vault_NFT.Canes_Vault_NFTCollectionPublic}\u003e(Canes_Vault_NFT.CollectionPublicPath)\n    if canesVaultCap.check() {\n        ids[\"Canes_Vault_NFT\"] = canesVaultCap.borrow()!.getIDs()\n    }\n    let dgdCap = account.getCapability\u003c\u0026DGD_NFT.Collection{DGD_NFT.DGD_NFTCollectionPublic}\u003e(DGD_NFT.CollectionPublicPath)\n    if dgdCap.check() {\n        ids[\"DGD_NFT\"] = dgdCap.borrow()!.getIDs()\n    }\n\n    let raceDayCap = account.getCapability\u003c\u0026RaceDay_NFT.Collection{RaceDay_NFT.RaceDay_NFTCollectionPublic}\u003e(RaceDay_NFT.CollectionPublicPath)\n    if raceDayCap.check() {\n        ids[\"RaceDay_NFT\"] = raceDayCap.borrow()!.getIDs()\n    }\n\n    let nextCartelCap = account.getCapability\u003c\u0026The_Next_Cartel_NFT.Collection{The_Next_Cartel_NFT.The_Next_Cartel_NFTCollectionPublic}\u003e(The_Next_Cartel_NFT.CollectionPublicPath)\n    if nextCartelCap.check() {\n        ids[\"The_Next_Cartel_NFT\"] = nextCartelCap.borrow()!.getIDs()\n    }\n    let ufcCap = account.getCapability\u003c\u0026UFC_NFT.Collection{UFC_NFT.UFC_NFTCollectionPublic}\u003e(UFC_NFT.CollectionPublicPath)\n    if ufcCap.check() {\n        ids[\"UFC\"] = ufcCap.borrow()!.getIDs()\n    }\n\n    let motoGPCollectionCap = account.getCapability\u003c\u0026MotoGPCard.Collection{MotoGPCard.ICardCollectionPublic}\u003e(/public/motogpCardCollection)\n    if motoGPCollectionCap.check() {\n        ids[\"MotoGPCard\"] = motoGPCollectionCap.borrow()!.getIDs()\n    }\n\n    let gaiaCap = account.getCapability\u003c\u0026{Gaia.CollectionPublic}\u003e(Gaia.CollectionPublicPath)\n    if gaiaCap.check() {\n        ids[\"Gaia\"] = gaiaCap.borrow()!.getIDs()\n    }\n\n    let jambbCap = account.getCapability\u003c\u0026Moments.Collection{Moments.CollectionPublic}\u003e(Moments.CollectionPublicPath)\n    if jambbCap.check() {\n        ids[\"Jambb\"] = jambbCap.borrow()!.getIDs()\n    }\n    let voucherCap = account.getCapability\u003c\u0026{Vouchers.CollectionPublic}\u003e(Vouchers.CollectionPublicPath)\n    if voucherCap.check() {\n        ids[\"JambbVoucher\"] = voucherCap.borrow()!.getIDs()\n    }\n\n    let mwaCap = account.getCapability\u003c\u0026{MatrixWorldAssetsNFT.Metadata, NonFungibleToken.CollectionPublic}\u003e(MatrixWorldAssetsNFT.collectionPublicPath)\n    if mwaCap.check() {\n        ids[\"MatrixWorldAssetsNFT\"] = mwaCap.borrow()!.getIDs()\n    }\n\n    let mwffCap = account.getCapability\u003c\u0026{MatrixWorldFlowFestNFT.MatrixWorldFlowFestNFTCollectionPublic}\u003e(MatrixWorldFlowFestNFT.CollectionPublicPath)\n    if mwffCap.check() {\n        ids[\"MatrixWorldFlowFest\"] = mwffCap.borrow()!.getIDs()\n    }\n\n    let sturdyCap = account.getCapability\u003c\u0026SturdyItems.Collection{SturdyItems.SturdyItemsCollectionPublic}\u003e(SturdyItems.CollectionPublicPath)\n    if sturdyCap.check() {\n        ids[\"SturdyItems\"] = sturdyCap.borrow()!.getIDs()\n    }\n\n    let charityCap = account.getCapability\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection)\n    if charityCap.check() {\n        ids[\"FindCharity\"] = charityCap.borrow()!.getIDs()\n    }\n\n    let evolutionCap=account.getCapability\u003c\u0026{Evolution.EvolutionCollectionPublic}\u003e(/public/f4264ac8f3256818_Evolution_Collection)\n    if evolutionCap.check() {\n        ids[\"Evolution\"] = evolutionCap.borrow()!.getIDs()\n    }\n\n    let geniaceCap = account.getCapability\u003c\u0026GeniaceNFT.Collection{NonFungibleToken.CollectionPublic, GeniaceNFT.GeniaceNFTCollectionPublic}\u003e(GeniaceNFT.CollectionPublicPath)\n    if geniaceCap.check() {\n        ids[\"GeniaceNFT\"] = geniaceCap.borrow()!.getIDs()\n    }\n\n    let ofCap = account.getCapability\u003c\u0026OneFootballCollectible.Collection{OneFootballCollectible.OneFootballCollectibleCollectionPublic}\u003e(OneFootballCollectible.CollectionPublicPath)\n    if ofCap.check() {\n        ids[\"OneFootballCollectible\"] = ofCap.borrow()!.getIDs()\n    }\n\n    let cryptoPiggoCap = account.getCapability\u003c\u0026{CryptoPiggo.CryptoPiggoCollectionPublic}\u003e(CryptoPiggo.CollectionPublicPath)\n    if cryptoPiggoCap.check() {\n        ids[\"CryptoPiggo\"] = cryptoPiggoCap.borrow()!.getIDs()\n    }\n\n    let xtinglesCap= account.getCapability\u003c\u0026{Collectible.CollectionPublic}\u003e(Collectible.CollectionPublicPath)\n    if xtinglesCap.check() {\n        ids[\"Xtingles\"] = xtinglesCap.borrow()!.getIDs()\n    }\n\n    let goatsVoucherCap = account.getCapability\u003c\u0026{GoatedGoatsVouchers.GoatsVoucherCollectionPublic}\u003e(GoatedGoatsVouchers.CollectionPublicPath)\n    if goatsVoucherCap.check() {\n        ids[\"GoatedGoatsVoucher\"] = goatsVoucherCap.borrow()!.getIDs()\n    }\n\n    let goatsTraitVoucherCap = account.getCapability\u003c\u0026{TraitPacksVouchers.PackVoucherCollectionPublic}\u003e(TraitPacksVouchers.CollectionPublicPath)\n    if goatsTraitVoucherCap.check() {\n        ids[\"GoatedGoatsTraitVoucher\"] = goatsTraitVoucherCap.borrow()!.getIDs()\n    }\n\n    let goatsCap = account.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(GoatedGoats.CollectionPublicPath)\n    if goatsCap.check() {\n        ids[\"GoatedGoats\"] = goatsCap.borrow()!.getIDs()\n    }\n\n    let goatsTraitCap = account.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(GoatedGoatsTrait.CollectionPublicPath)\n    if goatsTraitCap.check() {\n        ids[\"GoatedGoatsTrait\"] = goatsTraitCap.borrow()!.getIDs()\n    }\n\n    let goatsTraitPackCap = account.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(GoatedGoatsTraitPack.CollectionPublicPath)\n    if goatsTraitPackCap.check() {\n        ids[\"GoatedGoatsTraitPack\"] = goatsTraitPackCap.borrow()!.getIDs()\n    }\n\n\n    let bitkuCap = account.getCapability\u003c\u0026{HaikuNFT.HaikuCollectionPublic}\u003e(HaikuNFT.HaikuCollectionPublicPath)\n    if bitkuCap.check() {\n        ids[\"Bitku\"] = bitkuCap.borrow()!.getIDs()\n    }\n\n    let klktnCap = account.getCapability\u003c\u0026{KlktnNFT.KlktnNFTCollectionPublic}\u003e(KlktnNFT.CollectionPublicPath)\n    if klktnCap.check() {\n        ids[\"KLKTN\"] = klktnCap.borrow()!.getIDs()\n    }\n\n    let mynftCap = account.getCapability\u003c\u0026{Mynft.MynftCollectionPublic}\u003e(Mynft.CollectionPublicPath)\n    if mynftCap.check() {\n        ids[\"Mynft\"] = mynftCap.borrow()!.getIDs()\n    }\n\n    let neoAvatarCap = account.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(NeoAvatar.CollectionPublicPath)\n    if neoAvatarCap.check() {\n        ids[\"NeoAvatar\"] = neoAvatarCap.borrow()!.getIDs()\n    }\n\n    let neoVoucherCap = account.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(NeoVoucher.CollectionPublicPath)\n    if neoVoucherCap.check() {\n        ids[\"NeoVoucher\"] = neoVoucherCap.borrow()!.getIDs()\n    }\n\n    let neoMemberCap = account.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(NeoMember.CollectionPublicPath)\n    if neoMemberCap.check() {\n        ids[\"NeoMember\"] = neoMemberCap.borrow()!.getIDs()\n    }\n\n    let barterYardPackCap= account.getCapability\u003c\u0026{BarterYardPackNFT.BarterYardPackNFTCollectionPublic}\u003e(BarterYardPackNFT.CollectionPublicPath)\n    if barterYardPackCap.check() {\n        ids[\"BarterYardClubPack\"] = barterYardPackCap.borrow()!.getIDs()\n    }\n\n    let byCap = account.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(BarterYardClubWerewolf.CollectionPublicPath)\n    if byCap.check() {\n        ids[\"BarterYardClubWerewolf\"] = byCap.borrow()!.getIDs()\n    }\n\n    let momentablesCap = account.getCapability\u003c\u0026{Momentables.MomentablesCollectionPublic}\u003e(Momentables.CollectionPublicPath)\n    if momentablesCap.check(){\n        ids[\"Momentables\"] = momentablesCap.borrow()!.getIDs()\n    }\n\n    let zeedzCap = account.getCapability\u003c\u0026{ZeedzINO.ZeedzCollectionPublic}\u003e(ZeedzINO.CollectionPublicPath)\n    if zeedzCap.check(){\n        ids[\"ZeedzINO\"]=zeedzCap.borrow()!.getIDs()\n    }\n\n    let dayCap = account.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(DayNFT.CollectionPublicPath)\n    if dayCap.check() {\n        ids[\"DayNFT\"] = dayCap.borrow()!.getIDs()\n    }\n\n    let necroCap = account.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(Necryptolis.ResolverCollectionPublicPath)\n    if necroCap.check() {\n        ids[\"Necryptolis\"] = necroCap.borrow()!.getIDs()\n    }\n\n\n    let sockIds : [UInt64] = [14813, 15013, 14946, 14808, 14899, 14792, 15016, 14961, 14816, 14796, 14992, 14977, 14815, 14863, 14817, 14814, 14875, 14960, 14985, 14850, 14849, 14966, 14826, 14972, 14795, 15021, 14950, 14847, 14970, 14833, 14786, 15010, 14953, 14799, 14883, 14947, 14844, 14801, 14886, 15015, 15023, 15027, 15029, 14802, 14810, 14948, 14955, 14957, 14988, 15007, 15009, 14837, 15024, 14803, 14973, 14969, 15002, 15017, 14797, 14894, 14881, 15025, 14791, 14979, 14789, 14993, 14873, 14939, 15005, 15006, 14869, 14889, 15004, 15008, 15026, 14990, 14998, 14898, 14819, 14840, 14974, 15019, 14856, 14838, 14787, 14876, 14996, 14798, 14855, 14824, 14843, 14959, 15020, 14862, 14822, 14897, 14830, 14790, 14867, 14878, 14991, 14835, 14818, 14892, 14800, 15000, 14857, 14986, 14805, 14812, 14962]\n\n\n    let raribleCap = account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(RaribleNFT.collectionPublicPath)\n\n    if raribleCap.check() {\n    let mySockIds : [UInt64] = []\n    for id in raribleCap.borrow()!.getIDs() {\n        if sockIds.contains(id) {\n            mySockIds.append(id)\n        }\n    }\n    ids[\"FlowverseSocks\"] = mySockIds\n    }\n\n\n    let floatCap = account.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(FLOAT.FLOATCollectionPublicPath)\n    if floatCap.check() {\n        ids[\"FLOAT\"] = floatCap.borrow()!.getIDs()\n    }\n\n  let mintStoreCap = account.getCapability\u003c\u0026{MintStoreItem.MintStoreItemCollectionPublic}\u003e(MintStoreItem.CollectionPublicPath)\n    if mintStoreCap.check() {\n        ids[\"MintStore\"] = mintStoreCap.borrow()!.getIDs()\n    }\n\n    let somePlaceCap =account.getCapability\u003c\u0026{SomePlaceCollectible.CollectibleCollectionPublic}\u003e(SomePlaceCollectible.CollectionPublicPath)\n    if somePlaceCap.check(){\n        ids[\"SomePlace\"] = somePlaceCap.borrow()!.getIDs()\n    }\n\n    let bl0xCap = account.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(Bl0x.CollectionPublicPath)\n    if bl0xCap.check() {\n        ids[\"Bl0x\"] = bl0xCap.borrow()!.getIDs()\n    }\n\n    let bl0xPackCap = account.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(Bl0xPack.CollectionPublicPath)\n    if bl0xPackCap.check() {\n        ids[\"Bl0xPack\"] = bl0xPackCap.borrow()!.getIDs()\n    }\n\n    for key in ids.keys {\n        if ids[key]!.length == 0 {\n            ids.remove(key: key)\n        }\n    }\n    return ids\n}\n\n\npub fun main(user: String) : {String: [UInt64]} {\n    let resolvingAddress = FIND.resolve(user)\n    if resolvingAddress == nil {\n        return {}\n    }\n    let address = resolvingAddress!\n\n    return getNFTIDs(ownerAddress: address)\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "getNFTView": {
               "code": "import MetadataViews from 0x1d7e57aa55817448\nimport FINDNFTCatalog from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\n\n//Fetch a single view from a nft on a given path\npub fun main(user: String, aliasOrIdentifier:String, id: UInt64, identifier: String) : AnyStruct? {\n\n    let publicPath = getPublicPath(aliasOrIdentifier)\n    let resolveAddress = FIND.resolve(user) \n    if resolveAddress == nil {return []}\n    let address = resolveAddress!\n\n    let pp = publicPath\n    let account = getAccount(address)\n    if account.balance == 0.0 {\n        return nil\n    }\n    let collection= account.getCapability(pp).borrow\u003c\u0026{MetadataViews.ResolverCollection}\u003e()!\n\n    let nft=collection.borrowViewResolver(id: id)\n    for v in nft.getViews() {\n        if v.identifier== identifier {\n            return nft.resolveView(v)\n        }\n    }\n    return nil\n}\n\npub fun getPublicPath(_ nftIdentifier: String) : PublicPath {\n    let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier)) \n    let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n    return collection.collectionData.publicPath\n}",
               "spec": {
                  "order": [
                     "user",
                     "aliasOrIdentifier",
                     "id",
                     "identifier"
                  ],
                  "parameters": {
                     "aliasOrIdentifier": "String",
                     "id": "UInt64",
                     "identifier": "String",
                     "user": "String"
                  }
               }
            },
            "getNFTViews": {
               "code": "import MetadataViews from 0x1d7e57aa55817448\nimport NFTCatalog from 0x49a7cda3a1eecc29\nimport FINDNFTCatalog from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\n\n//get all the views for an nft and address/path/id\npub fun main(user: String, aliasOrIdentifier:String, id: UInt64) : [String] {\n    let nftInfo = getCollectionData(aliasOrIdentifier) \n\n    let resolveAddress = FIND.resolve(user) \n    if resolveAddress == nil {return []}\n    let address = resolveAddress!\n    let pp = nftInfo.publicPath\n    let collection= getAccount(address).getCapability(pp).borrow\u003c\u0026{MetadataViews.ResolverCollection}\u003e()!\n    let nft=collection.borrowViewResolver(id: id)\n    let views:[String]=[]\n    for v in nft.getViews() {\n        views.append(v.identifier)\n    }\n    return views\n}\n\npub fun getCollectionData(_ nftIdentifier: String) : NFTCatalog.NFTCollectionData {\n    let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier)) \n    let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n    return collection.collectionData\n}",
               "spec": {
                  "order": [
                     "user",
                     "aliasOrIdentifier",
                     "id"
                  ],
                  "parameters": {
                     "aliasOrIdentifier": "String",
                     "id": "UInt64",
                     "user": "String"
                  }
               }
            },
            "getNFTs": {
               "code": "import NonFungibleToken from 0x1d7e57aa55817448\nimport MetadataViews from 0x1d7e57aa55817448\n\n//are in alchemy\nimport Mynft from 0xf6fcbef550d97aa5\nimport GooberXContract from 0x34f2bf4a80bb0f69\nimport RareRooms_NFT from 0x329feb3ab062d289\nimport CNN_NFT from 0x329feb3ab062d289\nimport Canes_Vault_NFT from 0x329feb3ab062d289\nimport DGD_NFT from 0x329feb3ab062d289\nimport RaceDay_NFT from 0x329feb3ab062d289\nimport The_Next_Cartel_NFT from 0x329feb3ab062d289\nimport MatrixWorldFlowFestNFT from 0x2d2750f240198f91\nimport GeniaceNFT from 0xabda6627c70c7f52\nimport OneFootballCollectible from 0x6831760534292098\nimport GoatedGoats from 0x2068315349bdfce5\nimport GoatedGoatsTrait from 0x2068315349bdfce5\nimport HaikuNFT from 0xf61e40c19db2a9e2\nimport KlktnNFT from 0xabd6e80be7e9682c\nimport BarterYardPackNFT from 0xa95b021cf8a30d80\nimport Evolution from 0xf4264ac8f3256818\nimport UFC_NFT from 0x329feb3ab062d289\nimport Moments from 0xd4ad4740ee426334\nimport CryptoPiggo from 0xd3df824bf81910a4\nimport Momentables from 0x9d21537544d9123d\nimport ZeedzINO from 0x62b3063fbe672fc8\nimport PartyMansionDrinksContract from 0x34f2bf4a80bb0f69\nimport DayNFT from 0x1600b04bf033fb99\nimport RaribleNFT from 0x01ab36aaf654a13e\nimport SomePlaceCollectible from 0x667a16294a089ef8\nimport SturdyItems from 0x427ceada271aa0b1\n\n//we have better url\nimport MotoGPCard from 0xa49cc0ee46c54bfb\n\n//we have sent pr\nimport Gaia from 0x8b148183c28ff88f\n\nimport FIND from 0x097bafa4e0b48eef\n\n//They are lacking this one\nimport MatrixWorldAssetsNFT from 0xf20df769e658c257\n\n//Will have Views!\nimport NeoAvatar from 0xb25138dbf45e5801\nimport NeoVoucher from 0xb25138dbf45e5801\nimport NeoMember from 0xb25138dbf45e5801\nimport NeoViews from 0xb25138dbf45e5801\nimport Art from 0xd796ff17107bbff6\nimport Marketplace from 0xd796ff17107bbff6\nimport Flovatar from 0x921ea449dffec68a\nimport FlovatarMarketplace from  0x921ea449dffec68a\nimport CharityNFT from 0x097bafa4e0b48eef\nimport GoatedGoatsVouchers from 0xdfc74d9d561374c0\nimport TraitPacksVouchers from 0xdfc74d9d561374c0\nimport GoatedGoatsTraitPack from 0x2068315349bdfce5\nimport BarterYardClubWerewolf from  0x28abb9f291cadaf2\nimport Necryptolis from 0x718efe5e88fe48ea\nimport FLOAT from 0x2d4c3caffbeab845\nimport Bl0x from 0x7620acf6d7f2468a\nimport Bl0xPack from 0x7620acf6d7f2468a\n\n//Jambb, not called Jambb Vouchers\nimport Vouchers from 0x444f5ea22c6ea12c\n\n//xtingles\n//urls is wrong in alchemy to media\nimport Collectible from 0xf5b0eb433389ac3f\n\n//They do not have external url correct\nimport MintStoreItem from 0x20187093790b9aef\n\n\n\n\npub struct MetadataCollectionItem {\n    pub let id:UInt64\n    pub let name: String\n    pub let image: String\n    pub let url: String\n    pub let listPrice: UFix64?\n    pub let listToken: String?\n    pub let contentType:String\n    pub let rarity:String\n\n\n    init(id:UInt64, name:String, image:String, url:String, listPrice: UFix64?, listToken:String?, contentType: String, rarity: String) {\n        self.id=id\n        self.name=name\n        self.url=url\n        self.image=image\n        self.listToken=listToken\n        self.listPrice=listPrice\n        self.contentType=contentType\n        self.rarity=rarity\n    }\n}\n\n//TODO:missing some from mainnet\n\n// Same method signature as getNFTs.cdc for backwards-compatability.\npub fun getNFTs(ownerAddress: Address, ids: {String:[UInt64]}): [MetadataCollectionItem] {\n    let NFTs: [MetadataCollectionItem] = []\n    let owner = getAccount(ownerAddress)\n    if owner.balance == 0.0 {\n        return []\n    }\n\n    for key in ids.keys {\n        for id in ids[key]! {\n            var d: MetadataCollectionItem? = nil\n\n\n            switch key {\n                case \"CNN\": d  = getCNN(owner:owner, id:id) \n                case \"Mynft\": d  = getMynft(owner:owner, id:id)\n                case \"Flovatar\": d = getFlovatar(owner:owner, id:id)\n                case \"FlovatarForSale\": d = getFlovatarSale(owner:owner, id:id)\n                case \"VersusForSale\": d = getVersusSale(owner:owner, id:id)\n                case \"Versus\": d = getVersus(owner:owner, id:id)\n                case \"Gooberz\": d  = getGoober(owner:owner, id:id) \n                case \"PartyMansionDrinksContract\": d  = getPartyBeers(owner:owner, id:id) \n                case \"RareRooms\": d  = getRareRooms(owner:owner, id:id) \n                case \"Canes_Vault_NFT\": d  = getCanesVault(owner:owner, id:id)\n                case \"DGD_NFT\": d  = getDGD(owner:owner, id:id) \n                case \"RaceDay_NFT\": d  = getRaceDay(owner:owner, id:id) \n                case \"The_Next_Cartel_NFT\": d  = getTheNextCartel(owner:owner, id:id)\n                case \"UFC\": d  = getUFC(owner:owner, id:id)\n                case \"MotoGPCard\": d  = getMotoGP(owner:owner, id:id)\n                case \"Gaia\": d  = getGaia(owner:owner, id:id) \n                case \"Jambb\": d  = getJambb(owner:owner, id:id) \n                case \"JambbVoucher\": d  = getJambbVoucher(owner:owner, id:id) \n                case \"MatrixWorldAssetsNFT\": d  = getMatrixWorldAssets(owner:owner, id:id) \n                case \"MatrixWorldFlowFest\": d  = getMatrixWorldFlowFest(owner:owner, id:id) \n                case \"SturdyItems\": d  = getSturdyItems(owner:owner, id:id) \n                case \"FindCharity\": d  = getFindCharity(owner:owner, id:id)\n                case \"Evolution\": d  = getEvolution(owner:owner, id:id) \n                case \"GeniaceNFT\": d  = getGeniace(owner:owner, id:id) \n                case \"OneFootballCollectible\": d  = getOneFootballCollectible(owner:owner, id:id) \n                case \"CryptoPiggo\": d  = getCryptoPiggoes(owner:owner, id:id) \n                case \"Xtingles\": d  = getXtingles(owner:owner, id:id) \n                case \"GoatedGoatsVoucher\": d  = getGGVouhcer(owner:owner, id:id)\n                case \"GoatedGoatsTraitVoucher\": d  = getGGTraitVoucher(owner:owner, id:id) \n                case \"GoatedGoats\": d  = getGG(owner:owner, id:id) \n                case \"GoatedGoatsTrait\": d  = getGGT(owner:owner, id:id) \n                case \"GoatedGoatsTraitPack\": d  = getGGTP(owner:owner, id:id) \n                case \"Bitku\": d  = getBitku(owner:owner, id:id) \n                case \"KLKTN\": d  = getKLKNT(owner:owner, id:id)\n                case \"NeoAvatar\": d  = getNeoA(owner:owner, id:id)\n                case \"NeoVoucher\": d  = getNeoV(owner:owner, id:id)\n                case \"NeoMember\": d  = getNeoM(owner:owner, id:id) \n                case \"BarterYardClubPack\": d  = getBYCP(owner:owner, id:id) \n                case \"BarterYardClubWerewolf\": d  = getBYCW(owner:owner, id:id) \n                case \"Momentables\": d  = getMomentables(owner:owner, id:id) \n                case \"ZeedsINO\": d = getZeeds(owner:owner, id:id)\n                case \"DayNFT\" : d = getDayNFT(owner:owner, id:id)\n                case \"Necryptolis\" : d = getNecryptolis(owner:owner, id:id)\n                case \"FlowverseSocks\" : d = getFlowverseSocks(owner:owner, id:id)\n                case \"FLOAT\" : d = getFloat(owner:owner, id:id)\n                case \"MintStore\" : d = getMintStore(owner:owner, id:id)\n                case \"SomePlace\" : d = getSomePlace(owner:owner, id:id)\n                case \"Bl0x\" : d = getBl0x(owner: owner, id: id)\n                case \"Bl0xPack\" : d = getBl0xPack(owner: owner, id: id)\n\n            default:\n                panic(\"adapter for NFT not found: \".concat(key))\n            }\n\n            if d!= nil {\n                NFTs.append(d!)\n            }\n        }\n    }\n\n    return NFTs\n}\n\npub fun    getFlovatar(owner:PublicAccount, id:UInt64) : MetadataCollectionItem? {\n\n    let flovatarCap = owner.getCapability\u003c\u0026{Flovatar.CollectionPublic}\u003e(Flovatar.CollectionPublicPath)  \n    if !flovatarCap.check(){\n        return nil\n    }\n\n    let flovatars=flovatarCap.borrow()!\n    let flovatar = flovatars.borrowFlovatar(id: id)!\n\n    let metadata=flovatar.getMetadata()\n    var name = flovatar.getName()\n    if name == \"\" {\n        name=\"Flovatar #\".concat(flovatar.id.toString())\n    }\n\n    var rarity=\"common\"\n    if metadata.legendaryCount \u003e 0 {\n        rarity=\"legendary\"\n    } else if metadata.epicCount \u003e 0 {\n        rarity=\"epic\"\n    } else if metadata.rareCount \u003e 0 {\n        rarity=\"rare\"\n    }\n\n\n    return MetadataCollectionItem(\n        id: flovatar.id, \n        name: name, \n        image: \"https://flovatar.com/api/image/\".concat(flovatar.id.toString()),\n        url: \"https://flovatar.com/flovatars/\".concat(flovatar.id.toString()).concat(\"/\"),\n        listPrice:nil,\n        listToken:nil,\n        contentType: \"image\",\n        rarity: rarity\n    )\n}\n\npub fun    getFlovatarSale(owner:PublicAccount, id:UInt64) : MetadataCollectionItem? {\n    let flovatarMarketCap = owner.getCapability\u003c\u0026{FlovatarMarketplace.SalePublic}\u003e(FlovatarMarketplace.CollectionPublicPath)  \n    if !flovatarMarketCap.check(){\n        return nil\n    }\n\n    let saleCollection=flovatarMarketCap.borrow()!\n    let flovatar = saleCollection.getFlovatar(tokenId: id)!\n\n    let metadata=flovatar.getMetadata()\n    var name = flovatar.getName()\n    if name == \"\" {\n        name=\"Flovatar #\".concat(flovatar.id.toString())\n    }\n\n    var rarity=\"common\"\n    if metadata.legendaryCount \u003e 0 {\n        rarity=\"legendary\"\n    }else if metadata.epicCount \u003e 0 {\n        rarity=\"epic\"\n    }else if metadata.rareCount \u003e 0 {\n        rarity=\"rare\"\n    }\n\n    let price = saleCollection.getFlovatarPrice(tokenId: id)\n\n\n\n    return MetadataCollectionItem(\n        id: flovatar.id, \n        name: name, \n        image: \"https://flovatar.com/api/image/\".concat(flovatar.id.toString()),\n        url: \"https://flovatar.com/flovatars/\".concat(flovatar.id.toString()).concat(\"/\"),\n        listPrice: price,\n        listToken: \"Flow\",\n        contentType: \"image\",\n        rarity: rarity\n    )\n}\n\npub fun    getVersusSale(owner:PublicAccount, id:UInt64) : MetadataCollectionItem? {\n\n    let versusImageUrlPrefix = \"https://res.cloudinary.com/dxra4agvf/image/upload/c_fill,w_600/f_auto/maincache\"\n    let versusMarketplace = owner.getCapability\u003c\u0026{Marketplace.SalePublic}\u003e(Marketplace.CollectionPublicPath)\n    if !versusMarketplace.check() {\n        return nil\n    }\n\n    let versusMarket = versusMarketplace.borrow()!\n    let saleItem =versusMarket.getSaleItem(tokenID: id)\n    return  MetadataCollectionItem(\n        id: saleItem.id,\n        name: saleItem.art.name.concat(\" edition \").concat(saleItem.art.edition.toString()).concat(\"/\").concat(saleItem.art.maxEdition.toString()).concat(\" by \").concat(saleItem.art.artist),\n        image: versusImageUrlPrefix.concat(saleItem.cacheKey), \n        url: \"https://www.versus.auction/listing/\".concat(saleItem.id.toString()).concat(\"/\"),\n        listPrice: saleItem.price,\n        listToken: \"Flow\",\n        contentType: \"image\",\n        rarity: \"\"\n    )\n}\n\npub fun    getVersus(owner:PublicAccount, id:UInt64) : MetadataCollectionItem? {\n    let versusArtCap=owner.getCapability\u003c\u0026{Art.CollectionPublic}\u003e(Art.CollectionPublicPath)\n    let versusImageUrlPrefix = \"https://res.cloudinary.com/dxra4agvf/image/upload/c_fill,w_600/f_auto/maincache\"\n    if !versusArtCap.check(){\n        return nil\n    }\n    let address=owner.address!\n\n    let artCollection= versusArtCap.borrow()!\n    var art=artCollection.borrowArt(id: id)!\n    return MetadataCollectionItem(\n        id: id,\n        name: art.metadata.name.concat(\" edition \").concat(art.metadata.edition.toString()).concat(\"/\").concat(art.metadata.maxEdition.toString()).concat(\" by \").concat(art.metadata.artist),  \n        image: versusImageUrlPrefix.concat(art.cacheKey()), \n        url: \"https://www.versus.auction/piece/\".concat(address.toString()).concat(\"/\").concat(art.id.toString()).concat(\"/\"),\n        listPrice:nil,\n        listToken:nil,\n        contentType: \"image\",\n        rarity: \"\"\n    )\n}\n\npub fun    getGoober(owner:PublicAccount, id:UInt64) : MetadataCollectionItem? {\n\n    let goobersCap = owner.getCapability\u003c\u0026GooberXContract.Collection{NonFungibleToken.CollectionPublic, GooberXContract.GooberCollectionPublic}\u003e(GooberXContract.CollectionPublicPath)\n    if !goobersCap.check() {\n        return nil\n    }\n\n    let goobers = goobersCap.borrow()!\n    let goober= goobers.borrowGoober(id:id)!\n    return MetadataCollectionItem(\n        id: id,\n        name: \"Goober #\".concat(id.toString()),\n        image: goober.data.uri,\n        url: \"https://partymansion.io/gooberz/\".concat(id.toString()),\n        listPrice:nil,\n        listToken:nil,\n        contentType: \"image\",\n        rarity: \"\"\n    )\n} \n\npub fun    getPartyBeers(owner:PublicAccount, id:UInt64) : MetadataCollectionItem? {\n\n    let partyMansionDrinksCap = owner.getCapability\u003c\u0026{PartyMansionDrinksContract.DrinkCollectionPublic}\u003e(PartyMansionDrinksContract.CollectionPublicPath)\n    if !partyMansionDrinksCap.check() {\n        return nil\n    }\n\n    let collection = partyMansionDrinksCap.borrow()!\n    let nft = collection.borrowDrink(id: id)!\n    return MetadataCollectionItem(\n        id: id,\n        name: nft.data.description,\n        image: \"ipfs://\".concat(nft.imageCID()),\n        url: \"https://partymansion.io\",\n        listPrice: nil,\n        listToken: nil,\n        contentType: \"image\",\n        rarity: PartyMansionDrinksContract.rarityToString(rarity:nft.data.rarity)\n    )\n} \n\npub fun    getRareRooms(owner:PublicAccount, id:UInt64) : MetadataCollectionItem? {\n    let rareRoomCap = owner.getCapability\u003c\u0026RareRooms_NFT.Collection{RareRooms_NFT.RareRooms_NFTCollectionPublic}\u003e(RareRooms_NFT.CollectionPublicPath)\n    if !rareRoomCap.check() {\n        return nil\n    }\n    let collection = rareRoomCap.borrow()!\n    let nft = collection.borrowRareRooms_NFT(id: id)!\n    let metadata = RareRooms_NFT.getSetMetadata(setId: nft.setId)!\n    return MetadataCollectionItem(\n        id: id,\n        name: metadata[\"name\"]!,\n        image: metadata[\"preview\"]!,\n        url: \"https://rarerooms.io/tokens/\".concat(id.toString()),\n        listPrice: nil,\n        listToken: nil,\n        contentType: \"image\",\n        rarity: \"\"\n    )\n\n\n} \npub fun    getCNN(owner:PublicAccount, id:UInt64) : MetadataCollectionItem? {\n    let cnnCap = owner.getCapability\u003c\u0026CNN_NFT.Collection{CNN_NFT.CNN_NFTCollectionPublic}\u003e(CNN_NFT.CollectionPublicPath)\n    if !cnnCap.check() {\n        return nil\n\n    }\n    let collection = cnnCap.borrow()!\n    let nft = collection.borrowCNN_NFT(id: id)!\n    let metadata = CNN_NFT.getSetMetadata(setId: nft.setId)!\n\n    var image= metadata[\"preview\"]!\n    var contentType=\"image\"\n\n    return MetadataCollectionItem(\n        id: id,\n        name: metadata[\"name\"]!,\n        image: image,\n        url: \"http://vault.cnn.com\",\n        listPrice: nil,\n        listToken: nil,\n        contentType: contentType,\n        rarity: \"\"\n    )\n} \n\npub fun    getCanesVault(owner:PublicAccount, id:UInt64) : MetadataCollectionItem? {\n    let canesVaultCap = owner.getCapability\u003c\u0026Canes_Vault_NFT.Collection{Canes_Vault_NFT.Canes_Vault_NFTCollectionPublic}\u003e(Canes_Vault_NFT.CollectionPublicPath)\n    if !canesVaultCap.check() {\n        return nil\n    }\n    let collection = canesVaultCap.borrow()!\n    let nft = collection.borrowCanes_Vault_NFT(id: id)!\n    let metadata = Canes_Vault_NFT.getSetMetadata(setId: nft.setId)!\n    var image= metadata[\"preview\"]!\n    var contentType=\"image\"\n    return MetadataCollectionItem(\n        id: id,\n        name: metadata[\"name\"]!,\n        image: image,\n        url: \"https://canesvault.com/\",\n        listPrice: nil,\n        listToken: nil,\n        contentType: contentType,\n        rarity: \"\"\n    )\n}\n\npub fun    getDGD(owner:PublicAccount, id:UInt64) : MetadataCollectionItem? {\n    let dgdCap = owner.getCapability\u003c\u0026DGD_NFT.Collection{DGD_NFT.DGD_NFTCollectionPublic}\u003e(DGD_NFT.CollectionPublicPath)\n    if !dgdCap.check() {\n        return nil\n    }\n    let collection = dgdCap.borrow()!\n    let nft = collection.borrowDGD_NFT(id: id)!\n    let metadata = DGD_NFT.getSetMetadata(setId: nft.setId)!\n    var image= metadata[\"preview\"]!\n    var contentType=\"image\"\n\n    return MetadataCollectionItem(\n        id: id,\n        name: metadata[\"name\"]!,\n        image: image,\n        url: \"https://www.theplayerslounge.io/\",\n        listPrice: nil,\n        listToken: nil,\n        contentType: contentType,\n        rarity: \"\"\n    )\n} \n\npub fun    getRaceDay(owner:PublicAccount, id:UInt64) : MetadataCollectionItem? {\n    let raceDayCap = owner.getCapability\u003c\u0026RaceDay_NFT.Collection{RaceDay_NFT.RaceDay_NFTCollectionPublic}\u003e(RaceDay_NFT.CollectionPublicPath)\n    if !raceDayCap.check() {\n        return nil\n    }\n    let collection = raceDayCap.borrow()!\n    let nft = collection.borrowRaceDay_NFT(id: id)!\n    let metadata = RaceDay_NFT.getSetMetadata(setId: nft.setId)!\n    var image= metadata[\"preview\"]!\n    var contentType=\"image\"\n\n    return MetadataCollectionItem(\n        id: id,\n        name: metadata[\"name\"]!,\n        image: image, \n        url: \"https://www.racedaynft.com\",\n        listPrice: nil,\n        listToken: nil,\n        contentType: contentType,\n        rarity: \"\"\n    )\n} \n\npub fun    getTheNextCartel(owner:PublicAccount, id:UInt64) : MetadataCollectionItem? {\n    let nextCartelCap = owner.getCapability\u003c\u0026The_Next_Cartel_NFT.Collection{The_Next_Cartel_NFT.The_Next_Cartel_NFTCollectionPublic}\u003e(The_Next_Cartel_NFT.CollectionPublicPath)\n    if !nextCartelCap.check() {\n        return nil\n    }\n    let collection = nextCartelCap.borrow()!\n    let nft = collection.borrowThe_Next_Cartel_NFT(id: id)!\n    let metadata = The_Next_Cartel_NFT.getSetMetadata(setId: nft.setId)!\n    var image= metadata[\"preview\"]!\n    var contentType=\"image\"\n    return MetadataCollectionItem(\n        id: id,\n        name: metadata[\"name\"]!,\n        // we use \"preview\" and not \"image\" because of potential .glg and .mp4 file types\n        image: image,\n        url: \"https://thenextcartel.com/\",\n        listPrice: nil,\n        listToken: nil,\n        contentType: contentType,\n        rarity: \"\"\n    )\n}\n\npub fun    getUFC(owner:PublicAccount, id:UInt64) : MetadataCollectionItem? {\n    let ufcCap = owner.getCapability\u003c\u0026UFC_NFT.Collection{UFC_NFT.UFC_NFTCollectionPublic}\u003e(UFC_NFT.CollectionPublicPath)\n    if !ufcCap.check() {\n        return nil\n    }\n\n    let collection = ufcCap.borrow()!\n    let nft = collection.borrowUFC_NFT(id: id)!\n    let metadata = UFC_NFT.getSetMetadata(setId: nft.setId)!\n    var image= metadata[\"image\"]!\n    var contentType=\"video\"\n    return MetadataCollectionItem(\n        id: id,\n        name: metadata[\"name\"]!,\n        image: image,\n        url: \"https://www.ufcstrike.com\",\n        listPrice: nil,\n        listToken: nil,\n        contentType: contentType,\n        rarity: \"\"\n    )\n\n\n}\npub fun    getMotoGP(owner:PublicAccount, id:UInt64) : MetadataCollectionItem? {\n    let motoGPCollection = owner.getCapability\u003c\u0026MotoGPCard.Collection{MotoGPCard.ICardCollectionPublic}\u003e(/public/motogpCardCollection)\n    if !motoGPCollection.check() {\n        return nil\n    }\n    let address=owner.address!\n    let motoGPNfts = motoGPCollection.borrow()!.getIDs()\n    let nft = motoGPCollection.borrow()!.borrowCard(id: id)!\n    let metadata = nft.getCardMetadata()!\n    return MetadataCollectionItem(\n        id: id,\n        name: metadata.name,\n        image: metadata.imageUrl,\n        url: \"https://motogp-ignition.com/nft/card/\".concat(id.toString()).concat(\"?owner=\").concat(address.toString()),\n        listPrice: nil,\n        listToken: nil,\n        contentType: \"image\",\n        rarity: \"\"\n    )\n}\npub fun    getGaia(owner:PublicAccount, id:UInt64) : MetadataCollectionItem? {\n    let gaiaCollection = owner.getCapability\u003c\u0026{Gaia.CollectionPublic}\u003e(Gaia.CollectionPublicPath)\n    if !gaiaCollection.check() {\n        return nil\n    }\n\n    let gaiaNfts = gaiaCollection.borrow()!.getIDs()\n    let nft = gaiaCollection.borrow()!.borrowGaiaNFT(id: id)!\n    let metadata = Gaia.getTemplateMetaData(templateID: nft.data.templateID)!\n\n    //For ballerz we can do this...\n    var url=\"http://ongaia.com/\"\n    var name=metadata[\"title\"]!\n\n    if let seriesFullName=metadata[\"series\"] {\n        if seriesFullName==\"Bryson DeChambeau - Vegas, Baby!\" {\n            //For golf there is yet another way\n            url=\"http://ongaia.com/bryson/\".concat(nft.data.mintNumber.toString())\n            name=metadata[\"title\"]!.concat(\" #\").concat(nft.data.mintNumber.toString())\n        } else {\n            //If the series is basketball with shareef we can do this\n            url=\"http://ongaia.com/shareef/nft/\".concat(id.toString())\n            name=metadata[\"title\"]!.concat(\" #\").concat(nft.data.mintNumber.toString())\n        }\n    }\n\n    let newCollections= [\"ballerz\", \"sneakerz\"]\n    if let mid = metadata[\"id\"] {\n        if let uri = metadata[\"uri\"] {\n            for c in newCollections {\n                if uri == \"/collection/\".concat(c).concat(\"//\").concat(mid) {\n                url=\"http://ongaia.com/\".concat(c).concat(\"/\").concat(mid)\n            }\n        }\n    }\n}\n\n\nreturn MetadataCollectionItem(\n    id: id,\n    name: name,\n    image: metadata[\"img\"]!,\n    url: url,\n    listPrice: nil,\n    listToken: nil,\n    contentType: \"image\",\n    rarity: \"\"\n)\n} \n\npub fun    getJambb(owner:PublicAccount, id:UInt64) : MetadataCollectionItem? {\n    let jambbCap = owner.getCapability\u003c\u0026Moments.Collection{Moments.CollectionPublic}\u003e(Moments.CollectionPublicPath)\n    if !jambbCap.check() {\n        return nil\n    }\n    let jambb = jambbCap.borrow()!\n    let nft = jambb.borrowMoment(id: id)!\n    let metadata=nft.getMetadata()\n    return MetadataCollectionItem(\n        id: id,\n        name: metadata.contentName,\n        image: \"ipfs://\".concat(metadata.videoHash),\n        url: \"https://www.jambb.com/c/moment/\".concat(id.toString()),\n        listPrice: nil,\n        listToken: nil,\n        contentType: \"video\",\n        rarity: \"\"\n    )\n} \n\npub fun    getJambbVoucher(owner:PublicAccount, id:UInt64) : MetadataCollectionItem? {\n    let voucherCap = owner.getCapability\u003c\u0026{Vouchers.CollectionPublic}\u003e(Vouchers.CollectionPublicPath)\n    if !voucherCap.check() {\n        return nil\n    }\n    let collection = voucherCap.borrow()!\n    let nft = collection.borrowVoucher(id: id)!\n    let metadata=nft.getMetadata()!\n\n    let url=\"https://jambb.com\"\n    return  MetadataCollectionItem(\n        id: id,\n        name: metadata.name,\n        image: \"ipfs://\".concat(metadata.mediaHash),\n        url: url,\n        listPrice: nil,\n        listToken: nil,\n        contentType: metadata.mediaType,\n        rarity: \"\"\n    )\n} \n\npub fun    getMatrixWorldFlowFest(owner:PublicAccount, id:UInt64) : MetadataCollectionItem? {\n    let mwaCap = owner.getCapability\u003c\u0026{MatrixWorldFlowFestNFT.MatrixWorldFlowFestNFTCollectionPublic}\u003e(MatrixWorldFlowFestNFT.CollectionPublicPath)\n    if !mwaCap.check() {\n        return nil\n    }\n\n    let mwa=mwaCap.borrow()!\n    let nft = mwa.borrowVoucher(id: id)!\n    let metadata=nft.metadata\n    return MetadataCollectionItem(\n        id: nft.id,\n        name: metadata.name,\n        image: metadata.animationUrl,\n        url: \"https://matrixworld.org/\",\n        listPrice: nil,\n        listToken: nil,\n        contentType: \"image\",\n        rarity: \"\"\n    )\n} \n\npub fun    getMatrixWorldAssets(owner:PublicAccount, id:UInt64) : MetadataCollectionItem? {\n\n    let matrixworldAsset = owner.getCapability\u003c\u0026{MatrixWorldAssetsNFT.Metadata, NonFungibleToken.CollectionPublic}\u003e(MatrixWorldAssetsNFT.collectionPublicPath)\n    if !matrixworldAsset.check() {\n        return nil\n    }\n    let collection = matrixworldAsset.borrow()!\n    let metadata = collection.getMetadata(id: id)!\n    return  MetadataCollectionItem(\n        id: id,\n        name: metadata[\"name\"]!,\n        image: metadata[\"image\"]!,\n        url: metadata[\"external_url\"]!,\n        listPrice: nil,\n        listToken: nil,\n        contentType: \"image\",\n        rarity: \"\"\n    )\n} \n\npub fun    getSturdyItems(owner:PublicAccount, id:UInt64) : MetadataCollectionItem? {\n\n    let sturdyCollectionCap = owner.getCapability\u003c\u0026SturdyItems.Collection{SturdyItems.SturdyItemsCollectionPublic}\u003e(SturdyItems.CollectionPublicPath)\n    if !sturdyCollectionCap.check() {\n        return nil\n    }\n    let sturdyNfts = sturdyCollectionCap.borrow()!.getIDs()\n    let nft = sturdyCollectionCap.borrow()!.borrowSturdyItem(id: id)!\n    // the only thing we can play with is the nft title which is for example:\n    //     - \"HOODLUM#10\"\n    //     - \"HOLIDAY MYSTERY BADGE 2021\"\n    //  - \"EXCALIBUR\"\n    let isHoodlum = nft.tokenTitle.slice(from: 0, upTo: 7) == \"HOODLUM\"\n    if !isHoodlum {\n        return nil\n    }\n    // the hoodlum id is needed to retrieve the image but is not in the nft\n    let hoodlumId = nft.tokenTitle.slice(from: 8, upTo: nft.tokenTitle.length)\n    return  MetadataCollectionItem(\n        id: id,\n        name: nft.tokenTitle,\n        image: \"https://hoodlumsnft.com/_next/image?url=%2Fthumbs%2FsomeHoodlum_\".concat(hoodlumId).concat(\".png\u0026w=1920\u0026q=75\"),\n        url: \"https://hoodlumsnft.com/\",\n        listPrice:nil,\n        listToken:nil,\n        contentType:\"image\",\n        rarity: \"\"\n    )\n} \n\npub fun    getFindCharity(owner:PublicAccount, id:UInt64) : MetadataCollectionItem? {\n    let charityCap = owner.getCapability\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection)\n    if !charityCap.check() {\n        return nil\n    }\n    let collection = charityCap.borrow()!\n    let nft = collection.borrowCharity(id: id)!\n    let metadata = nft.getMetadata()\n    return MetadataCollectionItem(\n        id: id,\n        name: metadata[\"name\"]!,\n        image: metadata[\"thumbnail\"]!,\n        url: metadata[\"originUrl\"]!,\n        listPrice: nil,\n        listToken: nil,\n        contentType:\"image\",\n        rarity: \"\"\n    )\n}\n\npub fun    getEvolution(owner:PublicAccount, id:UInt64) : MetadataCollectionItem? {\n    let evolutionCap=owner.getCapability\u003c\u0026{Evolution.EvolutionCollectionPublic}\u003e(/public/f4264ac8f3256818_Evolution_Collection)\n    if !evolutionCap.check() {\n        return nil\n    }\n    let evolution=evolutionCap.borrow()!\n    let nfts = evolution.getIDs()\n    // the metadata is a JSON stored on IPFS at the address nft.tokenURI\n    let nft = evolution.borrowCollectible(id: id)!\n    let metadata = Evolution.getItemMetadata(itemId: nft.data.itemId)!\n    return MetadataCollectionItem(\n        id: id,\n        name: metadata[\"Title\"]!.concat(\" #\").concat(nft.data.serialNumber.toString()),\n        image: \"https://storage.viv3.com/0xf4264ac8f3256818/mv/\".concat(nft.data.itemId.toString()),\n        url: \"https://www.evolution-collect.com/\",\n        listPrice: nil,\n        listToken: nil,\n        contentType:\"video\",\n        rarity: \"\"\n    )\n}\n\npub fun    getGeniace(owner:PublicAccount, id:UInt64) : MetadataCollectionItem? {\n    let geniaceCap = owner.getCapability\u003c\u0026GeniaceNFT.Collection{NonFungibleToken.CollectionPublic, GeniaceNFT.GeniaceNFTCollectionPublic}\u003e(GeniaceNFT.CollectionPublicPath)\n    if !geniaceCap.check() {\n        return nil\n    }\n\n    let geniace=geniaceCap.borrow()!\n    let nft = geniace.borrowGeniaceNFT(id: id)!\n    let metadata = nft.metadata\n    var rarity=\"\"\n    if metadata.rarity == GeniaceNFT.Rarity.Collectible {\n        rarity=\"Collectible\"\n    }else if metadata.rarity == GeniaceNFT.Rarity.Rare {\n        rarity=\"Rare\"\n    }else if metadata.rarity == GeniaceNFT.Rarity.UltraRare {\n        rarity=\"UltraRare\"\n    }\n\n    return MetadataCollectionItem(\n        id: id,\n        name: metadata.name,\n        image: metadata.imageUrl,\n        url: \"https://www.geniace.com/product/\".concat(id.toString()),\n        listPrice: nil,\n        listToken: nil,\n        contentType: metadata.data[\"mimetype\"]!,\n        rarity: rarity,\n    )\n} \n\npub fun    getOneFootballCollectible(owner:PublicAccount, id:UInt64) : MetadataCollectionItem? {\n    let address=owner.address!\n    let oneFootballCollectibleCap = owner.getCapability\u003c\u0026OneFootballCollectible.Collection{OneFootballCollectible.OneFootballCollectibleCollectionPublic}\u003e(OneFootballCollectible.CollectionPublicPath)\n    if !oneFootballCollectibleCap.check() {\n        return nil\n    }\n    let collection = oneFootballCollectibleCap.borrow()!\n    let nft = collection.borrowOneFootballCollectible(id: id)!\n    let metadata = nft.getTemplate()!\n    return MetadataCollectionItem(\n        id: id,\n        name: metadata.name,\n        image: \"ipfs://\".concat(metadata.media),\n        url: \"https://xmas.onefootball.com/\".concat(owner.address.toString()),\n        listPrice: nil,\n        listToken: nil,\n        contentType: \"video\",\n        rarity: \"\"\n\n    )\n} \n\npub fun    getCryptoPiggoes(owner:PublicAccount, id:UInt64) : MetadataCollectionItem? {\n    let cryptoPiggoCap = owner.getCapability\u003c\u0026{CryptoPiggo.CryptoPiggoCollectionPublic}\u003e(CryptoPiggo.CollectionPublicPath)\n    if !cryptoPiggoCap.check() {\n        return nil\n    }\n    let collection = cryptoPiggoCap.borrow()!\n    let nft = collection.borrowItem(id: id)!\n    return MetadataCollectionItem(\n        id: id,\n        name: \"CryptoPiggo #\".concat(id.toString()),\n        image: \"https://s3.us-west-2.amazonaws.com/crypto-piggo.nft/piggo-\".concat(id.toString()).concat(\".png\"),\n        url: \"https://rareworx.com/piggo/details/\".concat(id.toString()),\n        listPrice: nil,\n        listToken: nil,\n        contentType: \"image\",\n        rarity: \"\"\n    )\n} \n\npub fun    getXtingles(owner:PublicAccount, id:UInt64) : MetadataCollectionItem? {\n    let xtinglesCap= owner.getCapability\u003c\u0026{Collectible.CollectionPublic}\u003e(Collectible.CollectionPublicPath)\n    if !xtinglesCap.check() {\n        return nil\n    }\n    let collection = xtinglesCap.borrow()!\n\n    let nft=collection.borrowCollectible(id:id)!\n    var image=nft.metadata.link\n\n    let prefix=\"https://\"\n    if image.slice(from:0, upTo:prefix.length) != prefix {\n        image=\"ipfs://\".concat(image)\n    }\n    return MetadataCollectionItem(\n        id: nft.id,\n        name: nft.metadata.name.concat(\" #\").concat(nft.metadata.edition.toString()),\n        image: image,\n        url: \"http://xtingles.com\",\n        listPrice: nil,\n        listToken: nil,\n        contentType: \"video\",\n        rarity: \"\"\n    )\n} \n\npub fun    getGGVouhcer(owner:PublicAccount, id:UInt64) : MetadataCollectionItem? {\n    let goatsCap = owner.getCapability\u003c\u0026{GoatedGoatsVouchers.GoatsVoucherCollectionPublic}\u003e(GoatedGoatsVouchers.CollectionPublicPath)\n    if !goatsCap.check() {\n        return nil\n    }\n    let goatsImageUrl= GoatedGoatsVouchers.getCollectionMetadata()[\"mediaURL\"]!\n    let collection = goatsCap.borrow()!\n    return MetadataCollectionItem(\n        id: id,\n        name: \"Goated Goat Base Goat Voucher #\".concat(id.toString()),\n        image: goatsImageUrl, \n        url: \"https://goatedgoats.com/\",\n        listPrice: nil,\n        listToken: nil,\n        contentType: \"image\",\n        rarity: \"\"\n\n    )\n}\npub fun    getGGTraitVoucher(owner:PublicAccount, id:UInt64) : MetadataCollectionItem? {\n    let goatsTraitCap = owner.getCapability\u003c\u0026{TraitPacksVouchers.PackVoucherCollectionPublic}\u003e(TraitPacksVouchers.CollectionPublicPath)\n    if !goatsTraitCap.check() {\n        return nil\n    }\n    let goatsImageUrl= TraitPacksVouchers.getCollectionMetadata()[\"mediaURL\"]!\n    let collection = goatsTraitCap.borrow()!\n    return MetadataCollectionItem(\n        id: id,\n        name: \"Goated Goat Trait Pack Voucher #\".concat(id.toString()),\n        image: goatsImageUrl, \n        url: \"https://goatedgoats.com/\",\n        listPrice: nil,\n        listToken: nil,\n        contentType: \"image\",\n        rarity: \"\"\n\n    )\n\n} \n\npub fun    getGG(owner:PublicAccount, id:UInt64) : MetadataCollectionItem? {\n    return getItemForMetadataStandard(path: GoatedGoats.CollectionPublicPath, owner: owner, externalFixedUrl: \"https://goatedgoats.com\", id:id)\n} \n\npub fun    getGGT(owner:PublicAccount, id:UInt64) : MetadataCollectionItem? {\n    return getItemForMetadataStandard(path: GoatedGoatsTrait.CollectionPublicPath, owner: owner, externalFixedUrl: \"https://goatedgoats.com\", id:id)\n} \n\npub fun    getGGTP(owner:PublicAccount, id:UInt64) : MetadataCollectionItem? {\n    return  getItemForMetadataStandard(path: GoatedGoatsTraitPack.CollectionPublicPath, owner: owner, externalFixedUrl: \"https://goatedgoats.com\", id:id)\n} \n\npub fun    getBitku(owner:PublicAccount, id:UInt64) : MetadataCollectionItem? {\n\n    let address=owner.address!\n    let bitkuCap = owner.getCapability\u003c\u0026{HaikuNFT.HaikuCollectionPublic}\u003e(HaikuNFT.HaikuCollectionPublicPath)\n    if !bitkuCap.check() {\n        return nil\n    }\n    let collection = bitkuCap.borrow()!\n    let nft = collection.borrowHaiku(id: id)!\n    return MetadataCollectionItem(\n        id: id,\n        name: \"Bitku #\".concat(id.toString()),\n        image: nft.text,\n        url: \"https://bitku.art/#\".concat(address.toString()).concat(\"/\").concat(id.toString()),\n        listPrice: nil,\n        listToken: nil,\n        contentType: \"text\",\n        rarity: \"\"\n    )\n} \n\npub fun    getKLKNT(owner:PublicAccount, id:UInt64) : MetadataCollectionItem? {\n    let klktnCap = owner.getCapability\u003c\u0026{KlktnNFT.KlktnNFTCollectionPublic}\u003e(KlktnNFT.CollectionPublicPath)\n    if !klktnCap.check() {\n        return nil\n    }\n    let collection = klktnCap.borrow()!\n    let nft = collection.borrowKlktnNFT(id: id)!\n\n    let metadata=nft.getNFTMetadata()\n    /*\n    Result: {\"uri\": \"ipfs://bafybeifsiousmtmcruuelgyiku3xa5hmw7ylsyqfdvpjsea7r4xa74bhym\", \"name\": \"Kevin Woo - What is KLKTN?\", \"mimeType\": \"video/mp4\", \"media\": \"https://ipfs.io/ipfs/bafybeifsiousmtmcruuelgyiku3xa5hmw7ylsyqfdvpjsea7r4xa74bhym/fb91ad34d61dde04f02ad240f0ca924902d8b4a3da25daaf0bb1ed769977848c.mp4\", \"description\": \"K-pop sensation Kevin Woo has partnered up with KLKTN to enhance his artist to fan interactions and experiences within his fandom. Join our chat to learn more: https://discord.gg/UJxb4erfUw\"}\n\n    */\n    return MetadataCollectionItem(\n        id: id,\n        name: metadata[\"name\"]!,\n        image: metadata[\"media\"]!,\n        url: \"https://klktn.com/\",\n        listPrice: nil,\n        listToken: nil,\n        contentType: \"video\", //metadata[\"mimeType\"]!,\n        rarity: \"\"\n    )\n}\n\npub fun    getMynft(owner:PublicAccount, id:UInt64) : MetadataCollectionItem? {\n    let mynftCap = owner.getCapability\u003c\u0026{Mynft.MynftCollectionPublic}\u003e(Mynft.CollectionPublicPath)\n    if !mynftCap.check() {\n        return nil\n    }\n    let collection = mynftCap.borrow()!\n    let nft = collection.borrowArt(id: id)!\n    let metadata=nft.metadata\n\n    var image= metadata.ipfsLink\n    if image == \"\" {\n        image=\"https://arweave.net/\".concat(metadata.arLink)\n    }\n\n    return MetadataCollectionItem(\n        id: id,\n        name: metadata.name,\n        image: image,\n        url: \"http://mynft.io\",\n        listPrice: nil,\n        listToken: nil,\n        contentType: metadata.type,\n        rarity: \"\"\n    )\n}\n\npub fun    getNeoA(owner:PublicAccount, id:UInt64) : MetadataCollectionItem? {\n    return getItemForMetadataStandard(path: NeoAvatar.CollectionPublicPath, owner: owner, externalFixedUrl: \"https://neocollectibles.xyz\", id:id)\n}\npub fun    getNeoV(owner:PublicAccount, id:UInt64) : MetadataCollectionItem? {\n    let address=owner.address!\n    return getItemForMetadataStandard(path: NeoVoucher.CollectionPublicPath, owner: owner, externalFixedUrl: \"https://neocollectibles.xyz/member/\".concat(address.toString()), id:id)\n}\n\npub fun    getNeoM(owner:PublicAccount, id:UInt64) : MetadataCollectionItem? {\n    let address=owner.address!\n    return getItemForMetadataStandard(path: NeoMember.CollectionPublicPath, owner: owner, externalFixedUrl: \"https://neocollectibles.xyz/member/\".concat(address.toString()), id:id)\n} \n\npub fun    getBYCP(owner:PublicAccount, id:UInt64) : MetadataCollectionItem? {\n    let barterYardCap= owner.getCapability\u003c\u0026{BarterYardPackNFT.BarterYardPackNFTCollectionPublic}\u003e(BarterYardPackNFT.CollectionPublicPath)\n    if !barterYardCap.check() {\n        return nil\n    }\n    let collection = barterYardCap.borrow()!\n    let nft = collection.borrowBarterYardPackNFT(id: id)!\n\n    if let displayView = nft.resolveView(Type\u003cMetadataViews.Display\u003e()) {\n        let display = displayView as! MetadataViews.Display\n        return MetadataCollectionItem(\n            id: id,\n            name: display.name,\n            image: display.thumbnail.uri(),\n            url: \"https://www.barteryard.club\",\n            listPrice: nil,\n            listToken: nil,\n            contentType: \"image\",\n            rarity: \"\"\n        )\n    }\n    return nil\n} \n\npub fun    getBYCW(owner:PublicAccount, id:UInt64) : MetadataCollectionItem? {\n    return getItemForMetadataStandard(path: BarterYardClubWerewolf.CollectionPublicPath, owner: owner, externalFixedUrl: \"https://barteryard.club\", id:id)\n} \n\npub fun    getMomentables(owner:PublicAccount, id:UInt64) : MetadataCollectionItem? {\n    let momentablesCap = owner.getCapability\u003c\u0026{Momentables.MomentablesCollectionPublic}\u003e(Momentables.CollectionPublicPath)\n    if !momentablesCap.check() {\n        return nil\n    }\n    let collection = momentablesCap.borrow()!\n\n    let nft = collection.borrowMomentables(id: id)!\n    let traits=nft.getTraits()\n    let commonTrait=traits[\"common\"]!\n\n    return MetadataCollectionItem(\n        id: id,\n        name: nft.name,\n        image: \"ipfs://\".concat(nft.imageCID),\n        url: \"https://www.cryptopharaohs.world/\",\n        listPrice: nil,\n        listToken: nil,\n        contentType: \"image\",\n        rarity: commonTrait[\"type\"] ?? \"\",\n    )\n} \n\npub fun    getZeeds(owner:PublicAccount, id:UInt64) : MetadataCollectionItem? {\n\n    let zeedzCap = owner.getCapability\u003c\u0026{ZeedzINO.ZeedzCollectionPublic}\u003e(ZeedzINO.CollectionPublicPath)\n    if !zeedzCap.check() {\n        return nil\n    }\n    let collection = zeedzCap.borrow()!\n    let nft = collection.borrowZeedle(id: id)!\n\n    return MetadataCollectionItem(\n        id: id,\n        name: nft.name,\n        image: \"ipfs://\".concat(nft.imageURI),\n        url: \"http://zeedz.io\",\n        listPrice: nil,\n        listToken: nil,\n        contentType: \"image\",\n        rarity: nft.rarity\n    )\n}\n\n\npub fun    getDayNFT(owner:PublicAccount, id:UInt64) : MetadataCollectionItem? {\n    return getItemForMetadataStandard(path: DayNFT.CollectionPublicPath, owner: owner, externalFixedUrl: \"https://day-nft.io\", id:id)\n} \n\npub fun    getNecryptolis(owner:PublicAccount, id:UInt64) : MetadataCollectionItem? {\n    return getItemForMetadataStandard(path: Necryptolis.ResolverCollectionPublicPath, owner: owner, externalFixedUrl: \"https://www.necryptolis.com\", id:id)\n}\n\npub fun    getFlowverseSocks(owner:PublicAccount, id:UInt64) : MetadataCollectionItem? {\n    let raribleCap = owner.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(RaribleNFT.collectionPublicPath)\n    if !raribleCap.check() {\n        return nil\n    }\n\n    let sockIds : [UInt64] = [14813, 15013, 14946, 14808, 14899, 14792, 15016, 14961, 14816, 14796, 14992, 14977, 14815, 14863, 14817, 14814, 14875, 14960, 14985, 14850, 14849, 14966, 14826, 14972, 14795, 15021, 14950, 14847, 14970, 14833, 14786, 15010, 14953, 14799, 14883, 14947, 14844, 14801, 14886, 15015, 15023, 15027, 15029, 14802, 14810, 14948, 14955, 14957, 14988, 15007, 15009, 14837, 15024, 14803, 14973, 14969, 15002, 15017, 14797, 14894, 14881, 15025, 14791, 14979, 14789, 14993, 14873, 14939, 15005, 15006, 14869, 14889, 15004, 15008, 15026, 14990, 14998, 14898, 14819, 14840, 14974, 15019, 14856, 14838, 14787, 14876, 14996, 14798, 14855, 14824, 14843, 14959, 15020, 14862, 14822, 14897, 14830, 14790, 14867, 14878, 14991, 14835, 14818, 14892, 14800, 15000, 14857, 14986, 14805, 14812, 14962]\n\n    if !sockIds.contains(id) {\n        return nil\n    }\n\n    let collection = raribleCap.borrow()!\n    collection.borrowNFT(id:id)!\n\n    return MetadataCollectionItem(\n        id: id,\n        name: \"Flowverse socks\",\n        image: \"https://img.rarible.com/prod/video/upload/t_video_big/prod-itemAnimations/FLOW-A.01ab36aaf654a13e.RaribleNFT:15029/b1cedf3\",\n        url: \"https://www.flowverse.co/socks\",\n        listPrice: nil,\n        listToken: nil,\n        contentType: \"video\",\n        rarity: \"\"\n    )\n}\n\npub fun    getFloat(owner:PublicAccount, id:UInt64) : MetadataCollectionItem? {\n    let address=owner.address!\n    return getItemForMetadataStandard(path: FLOAT.FLOATCollectionPublicPath, owner: owner, externalFixedUrl: \"https://floats.city/\".concat(address.toString()), id:id)\n}\n\npub fun    getMintStore(owner:PublicAccount, id:UInt64) : MetadataCollectionItem? {\n    let mintStoreCap = owner.getCapability\u003c\u0026{MintStoreItem.MintStoreItemCollectionPublic}\u003e(MintStoreItem.CollectionPublicPath)\n    if !mintStoreCap.check() {\n        return nil\n    }\n    let collection = mintStoreCap.borrow()!\n    let nft = collection.borrowMintStoreItem(id: id)!\n    let display= nft.resolveView(Type\u003cMetadataViews.Display\u003e())! as! MetadataViews.Display\n\n    let merchantName = MintStoreItem.getMerchant(merchantID:nft.data.merchantID)!\n    let editionData = MintStoreItem.EditionData(editionID: nft.data.editionID)!\n    var external_domain = \"\"\n    switch merchantName {\n    case \"Bulls\":\n        external_domain =  \"https://bulls.mint.store\"\n        break;\n    case \"Charlotte Hornets\":\n        external_domain =  \"https://hornets.mint.store\"\n        break;\n    default:\n        external_domain =  \"\"\n    }\n    if editionData!.metadata[\"nftType\"]! == \"Type C\" {\n        external_domain =  \"https://misa.art/collections/nft\"\n    }\n\n    let name=editionData.name\n    let image = editionData.metadata[\"thumbnail\"] ?? \"\"\n    return MetadataCollectionItem(\n        id: id,\n        name: name,\n        image: image,\n        url: external_domain,\n        listPrice: nil,\n        listToken: nil,\n        contentType: \"image\",\n        rarity: \"\"\n    )\n}\n\npub fun    getSomePlace(owner:PublicAccount, id:UInt64) : MetadataCollectionItem? {\n    let somePlaceCap =owner.getCapability\u003c\u0026{SomePlaceCollectible.CollectibleCollectionPublic}\u003e(SomePlaceCollectible.CollectionPublicPath)\n    if !somePlaceCap.check() {\n        return nil\n    }\n    let collection = somePlaceCap.borrow()!\n    let nft = collection.borrowCollectible(id: id)!\n    let setID = nft.setID\n    let setMetadata = SomePlaceCollectible.getMetadataForSetID(setID: setID)!\n    let editionMetadata = SomePlaceCollectible.getMetadataForNFTByUUID(uuid: nft.id)!\n    return MetadataCollectionItem(\n        id: id,\n        name: editionMetadata.getMetadata()[\"title\"] ?? setMetadata.getMetadata()[\"title\"] ?? \"\",\n        image: editionMetadata.getMetadata()[\"mediaURL\"] ?? setMetadata.getMetadata()[\"mediaURL\"] ?? \"\",\n        url: \"https://some.place\",\n        listPrice: nil,\n        listToken: nil,\n        contentType: \"image\",\n        rarity: \"\"\n    )\n}\n\n\npub fun    getBl0xPack(owner:PublicAccount, id:UInt64) : MetadataCollectionItem? {\n    return getItemForMetadataStandard(path: Bl0xPack.CollectionPublicPath, owner: owner, externalFixedUrl: \"http://bl0x.xyz\", id:id)\n}\n\npub fun    getBl0x(owner:PublicAccount, id:UInt64) : MetadataCollectionItem? {\n    return getItemForMetadataStandard(path: Bl0x.CollectionPublicPath, owner: owner, externalFixedUrl: \"http://bl0x.xyz\", id:id)\n}\n\n\n//This uses a view from Neo until we agree on another for ExternalDomainViewUrl\npub fun getItemForMetadataStandard(path: PublicPath, owner:PublicAccount, externalFixedUrl: String, id:UInt64) : MetadataCollectionItem? {\n    let resolverCollectionCap= owner.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(path)\n    if !resolverCollectionCap.check() {\n        return nil\n    }\n    let collection = resolverCollectionCap.borrow()!\n    let nft = collection.borrowViewResolver(id: id)!\n\n    if let displayView = nft.resolveView(Type\u003cMetadataViews.Display\u003e()) {\n        let display = displayView as! MetadataViews.Display\n        var externalUrl=externalFixedUrl\n        if let externalUrlView = nft.resolveView(Type\u003cMetadataViews.ExternalURL\u003e()) {\n            let url= externalUrlView! as! MetadataViews.ExternalURL\n            externalUrl=url.url\n        }\n\n        return MetadataCollectionItem(\n            id: id,\n            name: display.name,\n            image: display.thumbnail.uri(),\n            url: externalUrl,\n            listPrice: nil,\n            listToken: nil,\n            contentType: \"image\",\n            rarity: \"\"\n        )\n    }\n    return nil\n}\n\n/*\npub fun main(user: String) : {String: [UInt64]} {\n    let resolvingAddress = FIND.resolve(user)\n    if resolvingAddress == nil {\n        return {}\n    }\n    let address = resolvingAddress!\n\n    return getNFTIDs(ownerAddress: address)\n}\n*/\n\n\npub fun main(address: Address, ids: {String:[UInt64]}): [MetadataCollectionItem] {\n\n    return getNFTs(ownerAddress:address, ids:ids)\n}",
               "spec": {
                  "order": [
                     "address",
                     "ids"
                  ],
                  "parameters": {
                     "address": "Address",
                     "ids": "{String: [UInt64]}"
                  }
               }
            },
            "getName": {
               "code": "import FIND from 0x097bafa4e0b48eef\n\npub fun main(address: Address) : String?{\n    return FIND.reverseLookup(address)\n}",
               "spec": {
                  "order": [
                     "address"
                  ],
                  "parameters": {
                     "address": "Address"
                  }
               }
            },
            "getNameDetails": {
               "code": "import FIND from 0x097bafa4e0b48eef\nimport Profile from 0x097bafa4e0b48eef\nimport FindRelatedAccounts from 0x097bafa4e0b48eef\n\npub struct FINDReport {\n    pub let profile:Profile.UserReport?\n    pub let bids: [FIND.BidInfo]\n    pub let relatedAccounts: { String: [Address]}\n    pub let leases: [FIND.LeaseInformation]\n    pub let privateMode: Bool\n    pub let activatedAccount: Bool \n\n\n    init(profile: Profile.UserReport?, relatedAccounts: { String: [Address]}, bids: [FIND.BidInfo], leases : [FIND.LeaseInformation], privateMode: Bool, activatedAccount: Bool ) {\n        self.profile=profile\n        self.bids=bids\n        self.leases=leases\n        self.relatedAccounts=relatedAccounts\n        self.privateMode=privateMode\n        self.activatedAccount=activatedAccount\n    }\n}\n\npub struct NameReport {\n    pub let status: String\n    pub let cost: UFix64 \n    pub let leaseStatus: FIND.LeaseInformation?\n    pub let userReport: FINDReport? \n\n    init(status: String, cost: UFix64, leaseStatus: FIND.LeaseInformation?, userReport: FINDReport? ) {\n        self.status=status \n        self.cost=cost \n        self.leaseStatus=leaseStatus\n        self.userReport=userReport\n    }\n}\n\npub fun main(user: String) : NameReport? {\n\n    var findReport: FINDReport? = nil\n    var nameLease: FIND.LeaseInformation? = nil\n    if let address=FIND.resolve(user) {\n        let account=getAccount(address)\n        if account.balance != 0.0 {\n            let bidCap = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n            let leaseCap = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n            let profile=account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath).borrow()\n\n            var profileReport = profile?.asReport() \n            if profileReport != nil \u0026\u0026 profileReport!.findName != FIND.reverseLookup(address) {\n                profileReport = Profile.UserReport(\n                    findName: \"\",\n                    address: profileReport!.address,\n                    name: profileReport!.name,\n                    gender: profileReport!.gender,\n                    description: profileReport!.description,\n                    tags: profileReport!.tags,\n                    avatar: profileReport!.avatar,\n                    links: profileReport!.links,\n                    wallets: profileReport!.wallets, \n                    following: profileReport!.following,\n                    followers: profileReport!.followers,\n                    allowStoringFollowers: profileReport!.allowStoringFollowers,\n                    createdAt: profileReport!.createdAt\n                )\n            }\n\n            findReport = FINDReport(\n                profile: profileReport,\n                relatedAccounts: FindRelatedAccounts.findRelatedFlowAccounts(address:address),\n                bids: bidCap.borrow()?.getBids() ?? [],\n                leases: leaseCap.borrow()?.getLeaseInformation() ?? [],\n                privateMode: profile?.isPrivateModeEnabled() ?? false, \n                activatedAccount: true\n            )\n            if FIND.validateFindName(user) \u0026\u0026 findReport != nil {\n                for lease in findReport!.leases {\n                    if lease.name == user {\n                        nameLease = lease\n                        break\n                    }\n                }\n            }\n        } else {\n            findReport = FINDReport(\n                profile: nil,\n                relatedAccounts: {},\n                bids: [],\n                leases: [],\n                privateMode: false, \n                activatedAccount: false\n            )\n        }\n        \n    }\n\n    var nameReport : NameReport? = nil \n    if FIND.validateFindName(user) {\n        let status = FIND.status(user)\n        let cost=FIND.calculateCost(user)\n        var s=\"TAKEN\"    \n        if status.status == FIND.LeaseStatus.FREE {\n            s=\"FREE\"\n        } else if status.status == FIND.LeaseStatus.LOCKED {\n            s=\"LOCKED\"\n        }\n        nameReport = NameReport(status: s, cost: cost, leaseStatus: nameLease, userReport: findReport)\n    }\n    \n\n    return nameReport\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "getNameStatus": {
               "code": "import FIND from 0x097bafa4e0b48eef\nimport Profile from 0x097bafa4e0b48eef\n\npub fun main(name: String) :  \u0026{Profile.Public}? {\n    return FIND.lookup(name)\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "getNames": {
               "code": "import FIND from 0x097bafa4e0b48eef\n\npub fun main(address: [Address]) : { Address:String}{\n\n    let items : {Address:String} = {}\n    for a in address {\n        if let name= FIND.reverseLookup(a) {\n            items[a]=name\n        }\n    }\n    return items\n}",
               "spec": {
                  "order": [
                     "address"
                  ],
                  "parameters": {
                     "address": "[Address]"
                  }
               }
            },
            "getNamesWithBids": {
               "code": "import FIND from 0x097bafa4e0b48eef\n\npub fun main(user: String) : [FIND.LeaseInformation] {\n\n    let resolveAddress = FIND.resolve(user) \n    if resolveAddress == nil {return []}\n    let address = resolveAddress!\n    let account=getAccount(address)\n\n    if account.balance == 0.0 {\n        return []\n    }\n\n    let leaseCap = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\n    let leases=leaseCap.borrow()?.getLeaseInformation() ?? []\n\n    var leasesWithBids :[FIND.LeaseInformation] =[]\n    for lease in leases {\n        if lease.latestBidBy != nil {\n            leasesWithBids.append(lease)\n        }\n    }\n\n    return leasesWithBids\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "getNamesWithoutBids": {
               "code": "import FIND from 0x097bafa4e0b48eef\n\n\npub fun main(user: String) : [String] {\n\n    let resolveAddress = FIND.resolve(user) \n    if resolveAddress == nil {return []}\n    let address = resolveAddress!\n    let account=getAccount(address)\n\n    if account.balance == 0.0 {\n        return []\n    }\n\n    let leaseCap = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\n    let leases=leaseCap.borrow()?.getLeaseInformation() ?? []\n\n    var leasesWithBids :[String] =[]\n    for lease in leases {\n        if lease.latestBidBy == nil {\n            leasesWithBids.append(lease.name)\n        }\n    }\n\n    return leasesWithBids\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "getOwnedFindThoughts": {
               "code": "import FindThoughts from 0x097bafa4e0b48eef\nimport MetadataViews from 0x1d7e57aa55817448\nimport FindViews from 0x097bafa4e0b48eef\nimport FindMarket from 0x097bafa4e0b48eef\nimport Profile from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\n\npub fun main(address: Address) : [Thought] {\n    let thoughts : [Thought] = [] \n\n\n        let account = getAccount(address) \n        let cap = account.getCapability\u003c\u0026{FindThoughts.CollectionPublic}\u003e(FindThoughts.CollectionPublicPath) \n        if !cap.check() {\n            return []\n        }\n        let ref = cap.borrow()! \n        for id in ref.getIDs() {\n            let t = ref.borrowThoughtPublic(id) \n            thoughts.append(getThought(t, withQuote: true))\n        }\n    \n    return thoughts\n}\n\npub struct User {\n    pub var name: String?\n    pub let address: Address \n    pub let findName: String? \n    pub var avatar: String? \n    pub let reaction: String\n\n    init(address: Address, reaction: String){\n        self.name = nil\n        self.findName = FIND.reverseLookup(address)\n        self.avatar = nil\n        self.reaction = reaction\n        self.address = address \n        let profileCap = getAccount(address).getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if profileCap.check() {\n            let p = profileCap.borrow()!\n            self.name = p.getName()\n            self.avatar = p.getAvatar()\n        }    \n    }\n}\n\npub struct Thought {\n    pub let id: UInt64 \n    pub let creator: Address \n    pub let creatorName: String? \n    pub var creatorProfileName: String? \n    pub var creatorAvatar: String? \n    pub var header: String?\n    pub var body: String?\n    pub let created: UFix64? \n    pub var lastUpdated: UFix64?\n    pub let medias: {String : String}\n    pub let nft: [FindMarket.NFTInfo]\n    pub var tags: [String]\n    pub var reacted: {String : [User]}\n    pub var reactions: {String : Int}\n    pub var reactedUsers: {String : [String]}\n    pub var quotedThought: Thought?\n    pub var hidden: Bool?\n\n    init(id: UInt64 , creator: Address , creatorName: String? , creatorProfileName: String? , creatorAvatar: String? , header: String? , body: String? , created: UFix64? , lastUpdated: UFix64?, medias: {String : String}, nft: [FindMarket.NFTInfo], tags: [String], reacted: {String : [User]}, reactions: {String : Int}, reactedUsers: {String : [String]}, quotedThought: Thought?, hidden: Bool?) {\n        self.id = id\n        self.creator = creator\n        self.creatorName = creatorName\n        self.creatorProfileName = creatorProfileName\n        self.creatorAvatar = creatorAvatar\n        self.header = header\n        self.body = body\n        self.created = created\n        self.lastUpdated = lastUpdated\n        self.medias = medias\n        self.nft = nft\n        self.tags = tags\n        self.reacted = reacted\n        self.reactions = reactions\n        self.reactedUsers = reactedUsers\n        self.quotedThought = quotedThought\n        self.hidden = hidden\n    }\n}\n\npub fun getThought(_ t: \u0026{FindThoughts.ThoughtPublic}, withQuote: Bool) : Thought {\n\n        var creatorProfileName : String? = nil\n        var creatorAvatar : String? = nil \n        let profileCap = getAccount(t.creator).getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if profileCap.check() {\n            creatorProfileName = profileCap.borrow()!.getName()\n            creatorAvatar = profileCap.borrow()!.getAvatar()\n        }\n\n        let medias : {String : String} = {}\n        for m in t.medias {\n            medias[m.file.uri()] = m.mediaType\n        }\n\n        let nft : [FindMarket.NFTInfo] = [] \n        for n in t.nft {\n            let vr = n.getViewResolver() \n            nft.append(FindMarket.NFTInfo(vr, id: n.id, detail: true))\n        }\n\n        let reacted : {String : [User]} = {}\n        let reactedUsers : {String :[String]} = {}\n        for user in t.reacted.keys {\n            let reaction = t.reacted[user]!\n            let allReacted = reacted[reaction] ?? []\n            let u = User(address: user, reaction: reaction)\n\n            allReacted.append(u)\n            reacted[reaction] = allReacted\n\n            let preReactedUser = reactedUsers[reaction] ?? []\n            preReactedUser.append(u.name ?? u.address.toString())\n            reactedUsers[reaction] = preReactedUser\n        }\n\n        var quotedThought : Thought? = nil \n        if withQuote {\n            if let p = t.getQuotedThought() {\n                if let ref = p.borrowThoughtPublic() {\n                    quotedThought = getThought(ref, withQuote: false)\n                } else {\n                    let creator = p.owner()\n                    var qCreatorProfileName : String? = nil\n                    var qCreatorAvatar : String? = nil \n                    let qProfileCap = getAccount(creator).getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n                    if qProfileCap.check() {\n                        qCreatorProfileName = qProfileCap.borrow()!.getName()\n                        qCreatorAvatar = qProfileCap.borrow()!.getAvatar()\n                    }\n\n                    quotedThought = Thought(\n                        id: p.id , \n                        creator: creator  , \n                        creatorName: FIND.reverseLookup(creator) , \n                        creatorProfileName: qCreatorProfileName , \n                        creatorAvatar: qCreatorAvatar, \n                        header: nil, \n                        body: nil , \n                        created: nil, \n                        lastUpdated: nil, \n                        medias: {}, \n                        nft: [], \n                        tags: [], \n                        reacted: {}, \n                        reactions: {}, \n                        reactedUsers: {},\n                        quotedThought: nil, \n                        hidden: false\n                    )    \n                }\n            }\n        }\n\n        return Thought(\n            id: t.id , \n            creator: t.creator  , \n            creatorName: FIND.reverseLookup(t.creator) , \n            creatorProfileName: creatorProfileName , \n            creatorAvatar: creatorAvatar, \n            header: t.header , \n            body: t.body , \n            created: t.created, \n            lastUpdated: t.lastUpdated, \n            medias: medias, \n            nft: nft, \n            tags: t.tags, \n            reacted: reacted, \n            reactions: t.reactions, \n            reactedUsers: reactedUsers,\n            quotedThought: quotedThought, \n            hidden: t.getHide()\n        )\n\n}",
               "spec": {
                  "order": [
                     "address"
                  ],
                  "parameters": {
                     "address": "Address"
                  }
               }
            },
            "getProfile": {
               "code": "import Profile from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\n\npub fun main(user: String) :  Profile.UserReport? {\n    let resolveAddress = FIND.resolve(user) \n    if resolveAddress == nil {return nil}\n    let address = resolveAddress!\n    let account = getAccount(address)\n    if account.balance == 0.0 {\n        return nil\n    }\n\n    var profileReport = account\n        .getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        .borrow()?.asReport()\n\n    if profileReport != nil \u0026\u0026 profileReport!.findName != FIND.reverseLookup(address) {\n        profileReport = Profile.UserReport(\n            findName: \"\",\n            address: profileReport!.address,\n            name: profileReport!.name,\n            gender: profileReport!.gender,\n            description: profileReport!.description,\n            tags: profileReport!.tags,\n            avatar: profileReport!.avatar,\n            links: profileReport!.links,\n            wallets: profileReport!.wallets, \n            following: profileReport!.following,\n            followers: profileReport!.followers,\n            allowStoringFollowers: profileReport!.allowStoringFollowers,\n            createdAt: profileReport!.createdAt\n        )\n    }\n\n    return profileReport\n\n\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "getRoyaltyChangedIds": {
               "code": "import FindMarket from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\n\npub fun main(marketplace: Address, user: String) : {String : [UInt64]} {\n    if let address = FIND.resolve(user){\n        return FindMarket.getRoyaltiesChangedIds(tenant:marketplace, address: address)\n    }\n    return {}\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "user"
                  ],
                  "parameters": {
                     "marketplace": "Address",
                     "user": "String"
                  }
               }
            },
            "getRoyaltyChangedItems": {
               "code": "import FindMarket from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\n\npub fun main(marketplace: Address, user: String) : {String : FindMarket.SaleItemCollectionReport} {\n    if let address = FIND.resolve(user){\n        return FindMarket.getRoyaltiesChangedItems(tenant:marketplace, address: address)\n    }\n    return {}\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "user"
                  ],
                  "parameters": {
                     "marketplace": "Address",
                     "user": "String"
                  }
               }
            },
            "getShardCollectionsNFTCatalog": {
               "code": "import NonFungibleToken from 0x1d7e57aa55817448\nimport FIND from 0x097bafa4e0b48eef\nimport FINDNFTCatalog from 0x097bafa4e0b48eef\n\npub fun main(user: String) : {String : CollectionLength} {\n\n    if let address = FIND.resolve(user) {\n\n        return getNFTIDs_Catalog(ownerAddress: address, cacheCollections: {})\n\n    }\n    return {}\n\n}\n\npub struct CollectionLength {\n    pub let shard : String \n    pub let length : Int \n    init(shard : String, length : Int ) {\n        self.shard=shard \n        self.length=length\n    }\n}\n\n// Helper function \n\npub fun resolveAddress(user: String) : Address? {\n    return FIND.resolve(user)\n}\n\npub fun getNFTIDs_Catalog(ownerAddress: Address, cacheCollections: {String:CollectionLength}) : {String:CollectionLength} {\n\n    let account = getAuthAccount(ownerAddress)\n\n    let types = FINDNFTCatalog.getCatalogTypeData()\n    for nftType in types.keys {\n\n        let typeData=types[nftType]!\n        let collectionKey=typeData.keys[0]\n        let catalogEntry = FINDNFTCatalog.getCatalogEntry(collectionIdentifier:collectionKey)!\n        let tempPathStr = \"catalog\".concat(collectionKey)\n        let tempPublicPath = PublicPath(identifier: tempPathStr)!\n        account.link\u003c\u0026NonFungibleToken.Collection\u003e(tempPublicPath, target: catalogEntry.collectionData.storagePath)\n        let cap= account.getCapability\u003c\u0026NonFungibleToken.Collection\u003e(tempPublicPath)\n        if cap.check(){\n            let collection = cap.borrow()!\n            let length = collection.ownedNFTs.length\n            if length == 0 {\n                continue\n            }\n            cacheCollections[collectionKey] = CollectionLength(shard: \"NFTCatalog\", length: length)\n        }\n    }\n    return cacheCollections\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "getSocksIDs": {
               "code": "import NonFungibleToken from 0x1d7e57aa55817448\nimport MetadataViews from 0x1d7e57aa55817448\nimport FIND from 0x097bafa4e0b48eef\nimport RaribleNFT from 0x01ab36aaf654a13e\n\npub fun main(user: String, collections: [String]) : {String : ItemReport} {\n    return fetchRaribleNFT(user: user, targetCollections: collections)\n}\n\npub let FlowverseSocksIds : [UInt64] = [14813, 15013, 14946, 14808, 14899, 14792, 15016, 14961, 14816, 14796, 14992, 14977, 14815, 14863, 14817, 14814, 14875, 14960, 14985, 14850, 14849, 14966, 14826, 14972, 14795, 15021, 14950, 14847, 14970, 14833, 14786, 15010, 14953, 14799, 14883, 14947, 14844, 14801, 14886, 15015, 15023, 15027, 15029, 14802, 14810, 14948, 14955, 14957, 14988, 15007, 15009, 14837, 15024, 14803, 14973, 14969, 15002, 15017, 14797, 14894, 14881, 15025, 14791, 14979, 14789, 14993, 14873, 14939, 15005, 15006, 14869, 14889, 15004, 15008, 15026, 14990, 14998, 14898, 14819, 14840, 14974, 15019, 14856, 14838, 14787, 14876, 14996, 14798, 14855, 14824, 14843, 14959, 15020, 14862, 14822, 14897, 14830, 14790, 14867, 14878, 14991, 14835, 14818, 14892, 14800, 15000, 14857, 14986, 14805, 14812, 14962]\n\n    pub struct ItemReport {\n        pub let length : Int // mapping of collection to no. of ids \n        pub let extraIDs : [UInt64]\n        pub let shard : String \n        pub let extraIDsIdentifier : String \n        pub let collectionName: String\n\n        init(length : Int, extraIDs :[UInt64] , shard: String, extraIDsIdentifier: String, collectionName: String) {\n            self.length=length \n            self.extraIDs=extraIDs\n            self.shard=shard\n            self.extraIDsIdentifier=extraIDsIdentifier\n            self.collectionName=collectionName\n        }\n    }\n\npub struct MetadataCollectionItem {\n    pub let id:UInt64\n    pub let name: String\n    pub let collection: String // \u003c- This will be Alias unless they want something else\n    pub let subCollection: String? // \u003c- This will be Alias unless they want something else\n    pub let nftDetailIdentifier: String\n\n    pub let media  : String\n    pub let mediaType : String \n    pub let source : String \n\n    init(id:UInt64, name: String, collection: String, subCollection: String?, media  : String, mediaType : String, source : String, nftDetailIdentifier: String) {\n        self.id=id\n        self.name=name \n        self.collection=collection \n        self.subCollection=subCollection \n        self.media=media \n        self.mediaType=mediaType \n        self.source=source\n        self.nftDetailIdentifier=nftDetailIdentifier\n    }\n}\n\n// Helper function \n\npub fun resolveAddress(user: String) : Address? {\n    return FIND.resolve(user)\n}\n\npub fun getNFTIDs(ownerAddress: Address) : {String:[UInt64]} {\n\n    let account = getAuthAccount(ownerAddress)\n\n    let inventory : {String:[UInt64]}={}\n\n    let tempPathStr = \"RaribleNFT\"\n    let tempPublicPath = PublicPath(identifier: tempPathStr)!\n    account.link\u003c\u0026RaribleNFT.Collection\u003e(tempPublicPath, target: RaribleNFT.collectionStoragePath)\n    let cap= account.getCapability\u003c\u0026RaribleNFT.Collection\u003e(tempPublicPath)\n    if cap.check(){\n            // let rarible : [UInt64] = []\n            let socks : [UInt64] = []\n        for id in cap.borrow()!.getIDs() {\n            if FlowverseSocksIds.contains(id) {\n                socks.append(id)\n            // } else {\n            //     rarible.append(id)\n            }\n        }\n\n        // inventory[\"RaribleNFT\"] = rarible\n        inventory[\"FlowverseSocks\"] = socks\n\n    }\n    \n    return inventory\n}\n\npub fun fetchRaribleNFT(user: String, targetCollections: [String]) : {String : ItemReport} {\n    let source = \"RaribleNFT\"\n    let account = resolveAddress(user: user)\n    if account == nil { return {} }\n\n\n    let extraIDs = getNFTIDs(ownerAddress: account!)\n    let inventory : {String : ItemReport} = {}\n    var fetchedCount : Int = 0\n\n    for project in extraIDs.keys {\n        if extraIDs[project]! == nil || extraIDs[project]!.length \u003c 1{\n            extraIDs.remove(key: project)\n            continue\n        }\n        \n        let collectionLength = extraIDs[project]!.length\n\n        // by pass if this is not the target collection\n        if targetCollections.length \u003e 0 \u0026\u0026 !targetCollections.contains(project) {\n            // inventory[project] = ItemReport(items: [],  length : collectionLength, extraIDs :extraIDs[project]! , shard: source)\n            continue\n        }\n\n        inventory[project] = ItemReport(length : collectionLength, extraIDs :extraIDs[project] ?? [] , shard: source, extraIDsIdentifier: project, collectionName: \"Flowverse Socks V1\")\n\n    }\n\n    return inventory\n\n}",
               "spec": {
                  "order": [
                     "user",
                     "collections"
                  ],
                  "parameters": {
                     "collections": "[String]",
                     "user": "String"
                  }
               }
            },
            "getSocksItems": {
               "code": "import NonFungibleToken from 0x1d7e57aa55817448\nimport MetadataViews from 0x1d7e57aa55817448\nimport FIND from 0x097bafa4e0b48eef\n\nimport RaribleNFT from 0x01ab36aaf654a13e\n\npub fun main(user: String, collectionIDs: {String : [UInt64]}) : {String : [MetadataCollectionItem]} {\n\n    return fetchRaribleNFTs(user: user, collectionIDs: collectionIDs)\n}\npub let FlowverseSocksIds : [UInt64] = [14813, 15013, 14946, 14808, 14899, 14792, 15016, 14961, 14816, 14796, 14992, 14977, 14815, 14863, 14817, 14814, 14875, 14960, 14985, 14850, 14849, 14966, 14826, 14972, 14795, 15021, 14950, 14847, 14970, 14833, 14786, 15010, 14953, 14799, 14883, 14947, 14844, 14801, 14886, 15015, 15023, 15027, 15029, 14802, 14810, 14948, 14955, 14957, 14988, 15007, 15009, 14837, 15024, 14803, 14973, 14969, 15002, 15017, 14797, 14894, 14881, 15025, 14791, 14979, 14789, 14993, 14873, 14939, 15005, 15006, 14869, 14889, 15004, 15008, 15026, 14990, 14998, 14898, 14819, 14840, 14974, 15019, 14856, 14838, 14787, 14876, 14996, 14798, 14855, 14824, 14843, 14959, 15020, 14862, 14822, 14897, 14830, 14790, 14867, 14878, 14991, 14835, 14818, 14892, 14800, 15000, 14857, 14986, 14805, 14812, 14962]\n\npub fun getNFTs(ownerAddress: Address, ids: [UInt64]) : [MetadataViews.NFTView] {\n\n    let account = getAuthAccount(ownerAddress)\n    let results : [MetadataViews.NFTView] = []\n    let tempPathStr = \"RaribleNFT\"\n    let tempPublicPath = PublicPath(identifier: tempPathStr)!\n    account.link\u003c\u0026RaribleNFT.Collection\u003e(tempPublicPath, target: RaribleNFT.collectionStoragePath)\n    let cap= account.getCapability\u003c\u0026RaribleNFT.Collection\u003e(tempPublicPath)\n    if cap.check(){\n        let collection = cap.borrow()!\n        for id in ids {\n\n            let authNFT = (\u0026collection.ownedNFTs[id] as auth \u0026NonFungibleToken.NFT?)!\n            let nft = authNFT as! \u0026RaribleNFT.NFT\n\n            let md = nft.getMetadata()\n\n            let display = MetadataViews.Display(\n                name: md[\"name\"] ?? \"\",\n                description: md[\"description\"] ?? \"\",\n                thumbnail: MetadataViews.HTTPFile(url: md[\"metaURI\"] ?? \"\"),\n            )\n\n            let view =  MetadataViews.NFTView(\n                id : id,\n                uuid: nft.uuid,\n                display: display,\n                externalURL : nil,\n                collectionData : nil,\n                collectionDisplay : nil,\n                royalties : nil,\n                traits : nil\n            )\n            results.append(view)\n        }\n    }\n    \n    return results\n}\n\npub struct CollectionReport {\n    pub let items : {String : [MetadataCollectionItem]} \n    pub let collections : {String : Int} // mapping of collection to no. of ids \n    pub let extraIDs : {String : [UInt64]} \n\n    init(items: {String : [MetadataCollectionItem]},  collections : {String : Int}, extraIDs : {String : [UInt64]} ) {\n        self.items=items \n        self.collections=collections \n        self.extraIDs=extraIDs\n    }\n}\n\npub struct MetadataCollectionItem {\n    pub let id:UInt64\n    pub let name: String\n    pub let collection: String // \u003c- This will be Alias unless they want something else\n    pub let subCollection: String? // \u003c- This will be Alias unless they want something else\n    pub let nftDetailIdentifier: String\n\n    pub let media  : String\n    pub let mediaType : String \n    pub let source : String \n\n    init(id:UInt64, name: String, collection: String, subCollection: String?, media  : String, mediaType : String, source : String, nftDetailIdentifier: String) {\n        self.id=id\n        self.name=name \n        self.collection=collection \n        self.subCollection=subCollection \n        self.media=media \n        self.mediaType=mediaType \n        self.source=source\n        self.nftDetailIdentifier=nftDetailIdentifier\n    }\n}\n\n// Helper function \n\npub fun resolveAddress(user: String) : PublicAccount? {\n    let address = FIND.resolve(user)\n    if address == nil {\n        return nil\n    }\n    return getAccount(address!)\n}\n\npub fun fetchRaribleNFTs(user: String, collectionIDs: {String : [UInt64]}) : {String : [MetadataCollectionItem]} {\n    let source = \"RaribleNFT\"\n    let account = resolveAddress(user: user)\n    if account == nil { return {} }\n    if account!.balance == 0.0 {\n        return {}\n    }\n\n    let items : {String : [MetadataCollectionItem]} = {}\n\n    let fetchingIDs = collectionIDs\n    for project in fetchingIDs.keys {\n\n        var collectionItems : [MetadataCollectionItem] = []\n        for id in fetchingIDs[project]! {\n\n            if !FlowverseSocksIds.contains(id) {\n                continue\n            }\n            \n            let image = \"https://img.rarible.com/prod/video/upload/t_video_big/prod-itemAnimations/FLOW-A.01ab36aaf654a13e.RaribleNFT:15029/b1cedf3\"\n            let item = MetadataCollectionItem(\n                id: id,\n                name: \"Flowverse socks\",\n                collection: \"Flowverse socks\",\n                subCollection: nil, \n                media: image,\n                mediaType: \"video\",\n                source: source, \n                nftDetailIdentifier: project \n            )\n            collectionItems.append(item)\n        }\n\n        if collectionItems.length \u003e 0 {\n            items[project] = collectionItems\n        }\n    }\n    return items\n}",
               "spec": {
                  "order": [
                     "user",
                     "collectionIDs"
                  ],
                  "parameters": {
                     "collectionIDs": "{String: [UInt64]}",
                     "user": "String"
                  }
               }
            },
            "getStatus": {
               "code": "import FIND from 0x097bafa4e0b48eef\nimport Profile from 0x097bafa4e0b48eef\nimport FindRelatedAccounts from 0x097bafa4e0b48eef\nimport FindMarket from 0x097bafa4e0b48eef\nimport FindLeaseMarket from 0x097bafa4e0b48eef\nimport NonFungibleToken from 0x1d7e57aa55817448\nimport MetadataViews from 0x1d7e57aa55817448\nimport EmeraldIdentity from 0x39e42c67cc851cfb\nimport EmeraldIdentityDapper from 0x39e42c67cc851cfb\nimport EmeraldIdentityLilico from 0x39e42c67cc851cfb\nimport TokenForwarding from 0xe544175ee0461c4b\nimport FungibleToken from 0xf233dcee88fe0abe\nimport Wearables from 0xe81193c424cfd3fb\n\npub struct FINDReport{\n    pub let isDapper: Bool\n    pub let profile:Profile.UserReport?\n    pub let bids: [FIND.BidInfo]\n\n    pub let leases: [FIND.LeaseInformation]\n    pub let privateMode: Bool\n    pub let leasesForSale: {String : FindLeaseMarket.SaleItemCollectionReport}\n    pub let leasesBids: {String : FindLeaseMarket.BidItemCollectionReport}\n    pub let itemsForSale: {String : FindMarket.SaleItemCollectionReport}\n    pub let marketBids: {String : FindMarket.BidItemCollectionReport}\n    pub let activatedAccount: Bool\n\n\n    // This is deprecating, moving to accounts\n    pub let relatedAccounts: { String: [Address]}\n\n     pub let lostAndFoundTypes: {String : String}\n    // This is deprecating, moving to accounts\n    // EmeraldID Account Linkage\n    pub let emeraldIDAccounts : {String : Address}\n\n    pub let accounts : [AccountInformation]?\n\n    pub let readyForWearables : Bool?\n\n    init(profile: Profile.UserReport?,\n         relatedAccounts: {String: [Address]},\n         bids: [FIND.BidInfo],\n         leases : [FIND.LeaseInformation],\n         privateMode: Bool,\n         leasesForSale: {String : FindLeaseMarket.SaleItemCollectionReport},\n         leasesBids: {String : FindLeaseMarket.BidItemCollectionReport},\n         itemsForSale: {String : FindMarket.SaleItemCollectionReport},\n         marketBids: {String : FindMarket.BidItemCollectionReport},\n         activatedAccount: Bool,\n         emeraldIDAccounts : {String : Address},\n         isDapper: Bool,\n         accounts: [AccountInformation]?,\n         readyForWearables: Bool?\n         ) {\n\n      self.lostAndFoundTypes={}\n        self.profile=profile\n        self.bids=bids\n        self.leases=leases\n        self.relatedAccounts=relatedAccounts\n        self.privateMode=privateMode\n        self.leasesForSale=leasesForSale\n        self.leasesBids=leasesBids\n        self.itemsForSale=itemsForSale\n        self.marketBids=marketBids\n        self.activatedAccount=activatedAccount\n        self.emeraldIDAccounts=emeraldIDAccounts\n        self.isDapper=isDapper\n        self.accounts=accounts\n        self.readyForWearables=readyForWearables\n    }\n}\n\npub struct AccountInformation {\n    pub let name: String\n    pub let address: String\n    pub let network: String\n    pub let trusted: Bool\n    pub let node: String\n\n    init(name: String, address: String, network: String, trusted: Bool, node: String) {\n        self.name = name\n        self.address = address\n        self.network = network\n        self.trusted = trusted\n        self.node = node\n    }\n}\n\npub struct NameReport {\n    pub let status: String\n    pub let cost: UFix64\n    pub let owner: Address?\n    pub let validUntil: UFix64?\n    pub let lockedUntil: UFix64?\n    pub let registeredTime: UFix64?\n\n    init(status: String, cost: UFix64, owner: Address?, validUntil: UFix64?, lockedUntil: UFix64?, registeredTime: UFix64? ) {\n        self.status=status\n        self.cost=cost\n        self.owner=owner\n        self.validUntil=validUntil\n        self.lockedUntil=lockedUntil\n        self.registeredTime=registeredTime\n    }\n}\n\npub struct Report {\n    pub let FINDReport: FINDReport?\n    pub let NameReport: NameReport?\n\n    init(FINDReport: FINDReport?, NameReport: NameReport?) {\n        self.FINDReport=FINDReport\n        self.NameReport=NameReport\n    }\n}\n\npub fun main(user: String) : Report? {\n\n    var findReport: FINDReport? = nil\n    if let address=FIND.resolve(user) {\n        let account=getAccount(address)\n        if account.balance \u003e 0.0 {\n\n            var isDapper=false\n            if let receiver =account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver).borrow() {\n                 isDapper=receiver.isInstance(Type\u003c@TokenForwarding.Forwarder\u003e())\n            } else {\n                if let duc = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver).borrow() {\n                    isDapper = duc.isInstance(Type\u003c@TokenForwarding.Forwarder\u003e())\n                } else {\n                    isDapper = false\n                }\n            }\n\n            let bidCap = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n            let leaseCap = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n            let profile=account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath).borrow()\n\n            let find= FindMarket.getFindTenantAddress()\n            var items : {String : FindMarket.SaleItemCollectionReport} = FindMarket.getSaleItemReport(tenant:find, address: address, getNFTInfo:true)\n\n            var marketBids : {String : FindMarket.BidItemCollectionReport} = FindMarket.getBidsReport(tenant:find, address: address, getNFTInfo:true)\n\n            let leasesSale : {String : FindLeaseMarket.SaleItemCollectionReport} = FindLeaseMarket.getSaleItemReport(tenant:find, address: address, getLeaseInfo:true)\n\n            let leasesBids : {String : FindLeaseMarket.BidItemCollectionReport} = FindLeaseMarket.getBidsReport(tenant:find, address: address, getLeaseInfo:true)\n\n            var profileReport = profile?.asReport()\n            if profileReport != nil \u0026\u0026 profileReport!.findName != FIND.reverseLookup(address) {\n                profileReport = Profile.UserReport(\n                    findName: \"\",\n                    address: profileReport!.address,\n                    name: profileReport!.name,\n                    gender: profileReport!.gender,\n                    description: profileReport!.description,\n                    tags: profileReport!.tags,\n                    avatar: profileReport!.avatar,\n                    links: profileReport!.links,\n                    wallets: profileReport!.wallets,\n                    following: profileReport!.following,\n                    followers: profileReport!.followers,\n                    allowStoringFollowers: profileReport!.allowStoringFollowers,\n                    createdAt: profileReport!.createdAt\n                )\n            }\n\n            /*\n            // NFTCatalog Output\n            let nftCatalogTypes = FINDNFTCatalog.getCatalogTypeData()\n            let types : {String : NFTCatalog.NFTCollectionData} = {}\n            for type in FindLostAndFoundWrapper.getSpecificRedeemableTypes(user: address, specificType: Type\u003c@NonFungibleToken.NFT\u003e()) {\n                types[type.identifier] = FINDNFTCatalog.getCollectionDataForType(nftTypeIdentifier: type.identifier)\n            }\n            */\n\n            let discordID = EmeraldIdentity.getDiscordFromAccount(account: address)\n                                    ?? EmeraldIdentityDapper.getDiscordFromAccount(account: address)\n                                    ?? EmeraldIdentityLilico.getDiscordFromAccount(account: address)\n                                    ?? \"\"\n\n            let emeraldIDAccounts : {String : Address} = {}\n            emeraldIDAccounts[\"blocto\"] = EmeraldIdentity.getAccountFromDiscord(discordID: discordID)\n            emeraldIDAccounts[\"lilico\"] = EmeraldIdentityLilico.getAccountFromDiscord(discordID: discordID)\n            emeraldIDAccounts[\"dapper\"] = EmeraldIdentityDapper.getAccountFromDiscord(discordID: discordID)\n\n            let accounts : [AccountInformation] = []\n            for wallet in [\"blocto\", \"lilico\", \"dapper\"] {\n                if let w = emeraldIDAccounts[wallet] {\n                    accounts.append(\n                        AccountInformation(\n                            name: wallet,\n                            address: w.toString(),\n                            network: \"Flow\",\n                            trusted: true,\n                            node: \"EmeraldID\")\n                    )\n                }\n            }\n\n            let allAcctsCap = FindRelatedAccounts.getCapability(address)\n            if allAcctsCap.check() {\n                let allAcctsRef = allAcctsCap.borrow()!\n                let allAccts = allAcctsRef.getAllRelatedAccountInfo()\n                for acct in allAccts.values {\n                    // We only verify flow accounts that are mutually linked\n                    var trusted = false\n                    if acct.address != nil {\n                        trusted = allAcctsRef.linked(name: acct.name, network: acct.network, address: acct.address!)\n                    }\n                    accounts.append(\n                        AccountInformation(\n                            name: acct.name,\n                            address: acct.stringAddress!,\n                            network: acct.network,\n                            trusted: trusted,\n                            node: \"FindRelatedAccounts\")\n                    )\n                }\n            }\n\n            let wearableAccount = getAuthAccount(address)\n            var readyForWearables = true\n            let wearablesRef= wearableAccount.borrow\u003c\u0026Wearables.Collection\u003e(from: Wearables.CollectionStoragePath)\n            if wearablesRef == nil {\n                readyForWearables = false\n            }\n\n            let wearablesCap= wearableAccount.getCapability\u003c\u0026Wearables.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(Wearables.CollectionPublicPath)\n            if !wearablesCap.check() {\n                readyForWearables = false\n            }\n\n            let wearablesProviderCap= wearableAccount.getCapability\u003c\u0026Wearables.Collection{NonFungibleToken.Provider,NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(Wearables.CollectionPrivatePath)\n            if !wearablesCap.check() {\n                readyForWearables = false\n            }\n\n            findReport = FINDReport(\n                profile: profileReport,\n                relatedAccounts: FindRelatedAccounts.findRelatedFlowAccounts(address:address),\n                bids: bidCap.borrow()?.getBids() ?? [],\n                leases: leaseCap.borrow()?.getLeaseInformation() ?? [],\n                privateMode: profile?.isPrivateModeEnabled() ?? false,\n                leasesForSale: leasesSale,\n                leasesBids: leasesBids,\n                itemsForSale: items,\n                marketBids: marketBids,\n                activatedAccount: true,\n                emeraldIDAccounts: emeraldIDAccounts,\n                isDapper:isDapper,\n                accounts: accounts,\n                readyForWearables: readyForWearables\n            )\n        } else {\n            findReport = FINDReport(\n                profile: nil,\n                relatedAccounts: {},\n                bids: [],\n                leases: [],\n                privateMode: false,\n                leasesForSale: {},\n                leasesBids: {},\n                itemsForSale: {},\n                marketBids: {},\n                activatedAccount: false,\n                emeraldIDAccounts: {},\n                isDapper: false,\n                accounts: nil,\n                readyForWearables: nil\n            )\n        }\n    }\n\n    var nameReport : NameReport? = nil\n    if FIND.validateFindName(user) {\n        let status = FIND.status(user)\n        let cost=FIND.calculateCost(user)\n        var s=\"TAKEN\"\n        if status.status == FIND.LeaseStatus.FREE {\n            s=\"FREE\"\n        } else if status.status == FIND.LeaseStatus.LOCKED {\n            s=\"LOCKED\"\n        }\n        let findAddr = FIND.getFindNetworkAddress()\n        let network = getAuthAccount(findAddr).borrow\u003c\u0026FIND.Network\u003e(from: FIND.NetworkStoragePath)!\n        let lease =  network.getLease(user)\n        nameReport = NameReport(status: s, cost: cost, owner: lease?.profile?.address, validUntil: lease?.validUntil, lockedUntil: lease?.lockedUntil, registeredTime: lease?.registeredTime)\n    }\n\n\n    return Report(FINDReport: findReport, NameReport: nameReport)\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "getStatusLostAndFound": {
               "code": "import FIND from 0x097bafa4e0b48eef\nimport FINDNFTCatalog from 0x097bafa4e0b48eef\nimport FindLostAndFoundWrapper from 0x097bafa4e0b48eef\nimport NFTCatalog from 0x49a7cda3a1eecc29\nimport NonFungibleToken from 0x1d7e57aa55817448\n\npub fun main(user: String) :  {String : NFTCatalog.NFTCollectionData} {\n    let lostAndFoundTypes: {String : NFTCatalog.NFTCollectionData}={}\n\n    if let address=FIND.resolve(user) {\n        let account=getAccount(address)\n        if account.balance \u003e 0.0 {\n            // NFTCatalog Output\n            let nftCatalogTypes = FINDNFTCatalog.getCatalogTypeData()\n            let types : {String : NFTCatalog.NFTCollectionData} = {}\n            for type in FindLostAndFoundWrapper.getSpecificRedeemableTypes(user: address, specificType: Type\u003c@NonFungibleToken.NFT\u003e()) {\n                types[type.identifier] = FINDNFTCatalog.getCollectionDataForType(nftTypeIdentifier: type.identifier)\n            }\n        }\n    }\n    return lostAndFoundTypes\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "getStoreFrontListings": {
               "code": "import FIND from 0x097bafa4e0b48eef\n\nimport NFTStorefront from 0x4eb8a10cb9f87357\nimport Marketplace from 0xd796ff17107bbff6\nimport Art from 0xd796ff17107bbff6\nimport FlowToken from 0x1654653399040a61\nimport Flovatar from 0x921ea449dffec68a\nimport FlovatarMarketplace from  0x921ea449dffec68a\n\n// This script returns the details for a listing within a storefront\n\npub struct Listing {\n    pub let marketplace : String\n    pub let ftVault: Type\n    pub let price:UFix64\n    pub let nftType: Type\n    pub let nftId: UInt64\n\n    init(marketplace:String, ftVault:Type, price:UFix64, nftType:Type, nftId:UInt64) {\n        self.marketplace=marketplace\n        self.ftVault=ftVault\n        self.price=price\n        self.nftType=nftType\n        self.nftId=nftId\n    }\n}\n\npub fun main(user: String): {UInt64 :[Listing]} {\n\n    let resolveAddress = FIND.resolve(user) \n    if resolveAddress == nil {return {}}\n    let address = resolveAddress!\n    let account=getAccount(address)\n    if account.balance == 0.0 {\n        return {}\n    }\n    let storefrontRef = account.getCapability\u003c\u0026NFTStorefront.Storefront{NFTStorefront.StorefrontPublic}\u003e(NFTStorefront.StorefrontPublicPath).borrow()!\n\n    let listings : {UInt64 : [Listing]} = {}\n\n    for id in storefrontRef.getListingIDs() {\n        let listing = storefrontRef.borrowListing(listingResourceID: id)!\n        let details=listing.getDetails()\n        if details.purchased==true {\n            continue\n        }\n        let uuid=listing.borrowNFT()!.uuid\n\n        let item = Listing( \n            marketplace:\"nftstorefront-\".concat(details.storefrontID.toString()),\n            ftVault: details.salePaymentVaultType, \n            price: details.salePrice,\n            nftType:details.nftType,\n            nftId: details.nftID,\n        )\n        let uuidListings= listings[uuid] ?? []\n        uuidListings.append(item)\n        listings[uuid]= uuidListings\n    }\n\n\n    let versusMarketplace = account.getCapability\u003c\u0026{Marketplace.SalePublic}\u003e(Marketplace.CollectionPublicPath)\n    if versusMarketplace.check() {\n\n        let versusMarket = versusMarketplace.borrow()!\n\n        let saleItems = versusMarket.listSaleItems()\n        for saleItem in saleItems {\n\n            let item = Listing( \n                marketplace:\"versus\",\n                ftVault: Type\u003c@FlowToken.Vault\u003e(),\n                price: saleItem.price,\n                nftType:Type\u003c@Art.NFT\u003e(),\n                nftId: saleItem.id\n            )\n\n            let uuid = versusMarket.getUUIDforSaleItem(tokenID: saleItem.id)\n            //let uuid = art.borrowNFT(id:saleItem.id)!.uuid\n            let uuidListings= listings[uuid] ?? []\n            uuidListings.append(item)\n            listings[uuid]= uuidListings\n\n        }\n    }\n\n\n\n    let flovatarCap = account.getCapability\u003c\u0026{FlovatarMarketplace.SalePublic}\u003e(FlovatarMarketplace.CollectionPublicPath)  \n    if flovatarCap.check(){\n        let saleCollection=flovatarCap.borrow()!\n        for id in saleCollection.getFlovatarIDs() {\n            let price = saleCollection.getFlovatarPrice(tokenId: id)!\n            let flovatar = saleCollection.getFlovatar(tokenId: id)!\n\n            let item = Listing( \n                marketplace:\"flovatar\",\n                ftVault: Type\u003c@FlowToken.Vault\u003e(),\n                price: price,\n                nftType:Type\u003c@Flovatar.NFT\u003e(),\n                nftId: id\n            )\n\n            let uuid =  flovatar.uuid\n            //let uuid = art.borrowNFT(id:saleItem.id)!.uuid\n            let uuidListings= listings[uuid] ?? []\n            uuidListings.append(item)\n            listings[uuid]= uuidListings\n        }\n    }\n    return listings\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "getTenantSaleItem": {
               "code": "import FindMarket from 0x097bafa4e0b48eef\n\npub fun main(tenant: Address) : TenantSaleItems {\n    let tenantCap = FindMarket.getTenantCapability(tenant) ?? panic(\"No tenant capability is set up. Tenant Address : \".concat(tenant.toString()))\n    let tenantRef = tenantCap.borrow() ?? panic(\"Cannot borrow tenant reference. Tenant Address : \".concat(tenant.toString()))\n    let saleItems = tenantRef.getSaleItems()\n    return TenantSaleItems(findSaleItems: saleItems[\"findSaleItems\"]! ,\n                           tenantSaleItems: saleItems[\"tenantSaleItems\"]! ,\n                           findCuts: saleItems[\"findCuts\"]! )\n\n}\n\npub struct TenantSaleItems {\n    pub let findSaleItems : {String : FindMarket.TenantSaleItem}\n    pub let tenantSaleItems : {String : FindMarket.TenantSaleItem}\n    pub let findCuts : {String : FindMarket.TenantSaleItem} \n\n    init(findSaleItems : {String : FindMarket.TenantSaleItem}, \n         tenantSaleItems : {String : FindMarket.TenantSaleItem},\n         findCuts : {String : FindMarket.TenantSaleItem}) {\n             self.findSaleItems = findSaleItems\n             self.tenantSaleItems = tenantSaleItems \n             self.findCuts = findCuts \n         }\n}",
               "spec": {
                  "order": [
                     "tenant"
                  ],
                  "parameters": {
                     "tenant": "Address"
                  }
               }
            },
            "hasCharity": {
               "code": "import CharityNFT from 0x097bafa4e0b48eef\n\npub fun main(user: Address) : Bool {\n    let account=getAccount(user)\n    if account.balance == 0.0 {\n        return false\n    }\n    let charityCap = account.getCapability\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection)\n    return charityCap.check()\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "Address"
                  }
               }
            },
            "isFindUser": {
               "code": "import Profile from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\n\npub fun main(user: Address) : Bool {\n\n    let account=getAccount(user)\n    if account.balance == 0.0 {\n        return false\n    }\n    let leaseCap=account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n    let profileCap=account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\n    return leaseCap.check() \u0026\u0026 profileCap.check()\n\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "Address"
                  }
               }
            },
            "resolve": {
               "code": "import FIND from 0x097bafa4e0b48eef\n\npub fun main(name:String) : Address?{\n\n    return FIND.resolve(name)\n\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "reverseLookup": {
               "code": "import FIND from 0x097bafa4e0b48eef\n\npub fun main(addr:Address) : String?{\n\n    return FIND.reverseLookup(addr)\n\n}",
               "spec": {
                  "order": [
                     "addr"
                  ],
                  "parameters": {
                     "addr": "Address"
                  }
               }
            },
            "sendNFTs": {
               "code": "import NonFungibleToken from 0x1d7e57aa55817448\nimport FungibleToken from 0xf233dcee88fe0abe\nimport TokenForwarding from 0xe544175ee0461c4b\nimport FlowToken from 0x1654653399040a61\nimport MetadataViews from 0x1d7e57aa55817448\nimport NFTCatalog from 0x49a7cda3a1eecc29\nimport FINDNFTCatalog from 0x097bafa4e0b48eef\nimport Profile from 0x097bafa4e0b48eef\nimport FindViews from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\nimport FindAirdropper from 0x097bafa4e0b48eef\nimport FindUtils from 0x097bafa4e0b48eef\n\npub fun main(sender: Address, nftIdentifiers: [String],  allReceivers:[String] , ids: [UInt64], memos: [String]) : [Report] {\n\n     fun logErr(_ i: Int , err: String) : Report {\n        return Report(receiver: allReceivers[i] , address: nil, inputName: nil, findName: nil, avatar: nil, isDapper: nil, type: nftIdentifiers[i], id: ids[i] , message: memos[i] ,receiverLinked: nil , collectionPublicLinked: nil , accountInitialized: nil , nftInPlace: nil, royalties: nil, err: err)\n    }\n\n        let paths : [PublicPath] = []\n        let contractData : {Type : NFTCatalog.NFTCatalogMetadata} = {}\n        let addresses : {String : Address} = {}\n\n        let account = getAuthAccount(sender)\n        let report : [Report] = []\n        for i , typeIdentifier in nftIdentifiers {\n            let checkType = CompositeType(typeIdentifier)\n            if checkType == nil {\n                report.append(logErr(i, err: \"Cannot refer to type with identifier : \".concat(typeIdentifier)))\n                continue\n            }\n            let type = checkType!\n\n            var data : NFTCatalog.NFTCatalogMetadata? = contractData[type]\n            if data == nil {\n                let checkData = FINDNFTCatalog.getMetadataFromType(type)\n                if checkData == nil {\n                    report.append(logErr(i, err: \"NFT Type is not supported by NFT Catalog. Type : \".concat(type.identifier)))\n                    continue\n                }\n                contractData[type] = checkData!\n                data = checkData!\n            }\n\n            let path = data!.collectionData\n\n            let checkCol = account.borrow\u003c\u0026NonFungibleToken.Collection\u003e(from: path.storagePath)\n            if checkCol == nil {\n                report.append(logErr(i, err: \"Cannot borrow collection from sender. Type : \".concat(type.identifier)))\n                continue\n            }\n            let ownedNFTs : \u0026{UInt64 : NonFungibleToken.NFT} = \u0026checkCol!.ownedNFTs as \u0026{UInt64 : NonFungibleToken.NFT}\n            let owned = ownedNFTs.containsKey(ids[i])\n\n            let receiver = allReceivers[i]\n            let id = ids[i]\n            let message = memos[i]\n\n            var user = addresses[receiver]\n            if user == nil {\n                let checkUser = FIND.resolve(receiver)\n                if checkUser == nil {\n                    report.append(logErr(i, err: \"Cannot resolve user with name / address : \".concat(receiver)))\n                    continue\n                }\n                addresses[receiver] = checkUser!\n                user = checkUser!\n            }\n            let checkAcct = getAccount(user!)\n            if checkAcct.balance == 0.0 {\n                report.append(logErr(i, err: \"Account is not an activated account\"))\n                continue\n            }\n\n\n            var isDapper=false\n            if let receiver =getAccount(user!).getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver).borrow() {\n                 isDapper=receiver.isInstance(Type\u003c@TokenForwarding.Forwarder\u003e())\n            } else {\n                if let duc = getAccount(user!).getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver).borrow() {\n                    isDapper = duc.isInstance(Type\u003c@TokenForwarding.Forwarder\u003e())\n                }\n            }\n\n            // check receiver account storage\n            let receiverCap = getAccount(user!).getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(path.publicPath)\n            let collectionPublicCap = getAccount(user!).getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(path.publicPath)\n            let storage = getAuthAccount(user!).type(at: path.storagePath)\n\n            var storageInited = false\n            if storage != nil \u0026\u0026 checkSameContract(collection: storage!, nft: type){\n                storageInited = true\n            }\n\n            var royalties : Royalties? = nil\n            let mv = account.borrow\u003c\u0026{MetadataViews.ResolverCollection}\u003e(from: path.storagePath)\n            if mv != nil {\n                let rv = mv!.borrowViewResolver(id: id)\n                if let r = MetadataViews.getRoyalties(rv) {\n                    royalties = Royalties(r)\n                }\n            }\n\n            var inputName : String? = receiver\n            var findName : String? = FIND.reverseLookup(user!)\n            if FindUtils.hasPrefix(receiver, prefix: \"0x\") {\n                inputName = nil\n            }\n\n            var avatar : String? = nil\n            if let profile = getAccount(user!).getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath).borrow() {\n                avatar = profile.getAvatar()\n            }\n\n            let r = Report(receiver: allReceivers[i] , address: user, inputName: inputName, findName: findName, avatar: avatar, isDapper: isDapper, type: nftIdentifiers[i], id: ids[i] , message: memos[i] ,receiverLinked: receiverCap.check() , collectionPublicLinked: collectionPublicCap.check() , accountInitialized: storageInited , nftInPlace: owned, royalties:royalties, err: nil)\n            report.append(r)\n        }\n\n    return report\n}\n\n\npub struct Report {\n    pub let receiver: String\n    pub let address: Address?\n    pub let inputName: String?\n    pub let findName: String?\n    pub let avatar: String?\n    pub let isDapper: Bool?\n    pub let type: String\n    pub let id: UInt64\n    pub let message: String\n    pub var ok: Bool\n    pub let receiverLinked: Bool?\n    pub let collectionPublicLinked: Bool?\n    pub let accountInitialized: Bool?\n    pub let nftInPlace: Bool?\n    pub let royalties: Royalties?\n    pub let err: String?\n\n    init(receiver: String , address: Address?, inputName: String?, findName: String?, avatar: String?, isDapper: Bool? , type: String, id: UInt64 , message: String ,receiverLinked: Bool? , collectionPublicLinked: Bool? , accountInitialized: Bool? , nftInPlace: Bool?, royalties: Royalties?, err: String?) {\n        self.receiver=receiver\n        self.address=address\n        self.inputName=inputName\n        self.findName=findName\n        self.avatar=avatar\n        self.isDapper=isDapper\n        self.type=type\n        self.id=id\n        self.message=message\n        self.receiverLinked=receiverLinked\n        self.collectionPublicLinked=collectionPublicLinked\n        self.accountInitialized=accountInitialized\n        self.nftInPlace=nftInPlace\n        self.err=err\n        self.royalties=royalties\n        self.ok = false\n        if accountInitialized == true \u0026\u0026 nftInPlace == true {\n            if receiverLinked == true || collectionPublicLinked == true {\n                self.ok = true\n            }\n        }\n    }\n}\n\npub struct Royalties {\n    pub let totalRoyalty: UFix64\n    pub let royalties: [Royalty]\n\n    init(_ royalties: MetadataViews.Royalties) {\n        var totalR = 0.0\n        let array : [Royalty] = []\n        for r in royalties.getRoyalties() {\n            array.append(Royalty(r))\n            totalR = totalR + r.cut\n        }\n        self.totalRoyalty = totalR\n        self.royalties = array\n    }\n}\n\npub struct Royalty {\n    pub let name: String?\n    pub let address: Address\n    pub let cut: UFix64\n    pub let acceptTypes: [String]\n    pub let description: String\n\n    init(_ r: MetadataViews.Royalty) {\n        self.name = FIND.reverseLookup(r.receiver.address)\n        self.address = r.receiver.address\n        self.cut = r.cut\n        self.description = r.description\n        let acceptTypes : [String] = []\n        if r.receiver.check() {\n            let ref = r.receiver.borrow()!\n            let t = ref.getType()\n            if t.isInstance(Type\u003c@FungibleToken.Vault\u003e()) {\n                acceptTypes.append(t.identifier)\n            } else if t == Type\u003c@TokenForwarding.Forwarder\u003e() {\n                acceptTypes.append(Type\u003c@FlowToken.Vault\u003e().identifier)\n            } else if t == Type\u003c@Profile.User\u003e() {\n                let ref = getAccount(r.receiver.address).getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath).borrow()!\n                let wallets = ref.getWallets()\n                for w in wallets {\n                    acceptTypes.append(w.accept.identifier)\n                }\n            }\n        }\n        self.acceptTypes = acceptTypes\n    }\n}\n\npub fun checkSameContract(collection: Type, nft: Type) : Bool {\n    let colType = collection.identifier\n    let croppedCol = colType.slice(from: 0 , upTo : colType.length - \"collection\".length)\n    let nftType = nft.identifier\n    let croppedNft = nftType.slice(from: 0 , upTo : nftType.length - \"nft\".length)\n    if croppedCol == croppedNft {\n        return true\n    }\n    return false\n}",
               "spec": {
                  "order": [
                     "sender",
                     "nftIdentifiers",
                     "allReceivers",
                     "ids",
                     "memos"
                  ],
                  "parameters": {
                     "allReceivers": "[String]",
                     "ids": "[UInt64]",
                     "memos": "[String]",
                     "nftIdentifiers": "[String]",
                     "sender": "Address"
                  }
               }
            }
         },
         "transactions": {
            "acceptDirectOfferSoft": {
               "code": "import FindMarketDirectOfferSoft from 0x097bafa4e0b48eef\nimport NonFungibleToken from 0x1d7e57aa55817448\nimport MetadataViews from 0x1d7e57aa55817448\nimport FindViews from 0x097bafa4e0b48eef\nimport FINDNFTCatalog from 0x097bafa4e0b48eef\nimport FindMarket from 0x097bafa4e0b48eef\n\ntransaction(marketplace:Address, id: UInt64) {\n\n    let market : \u0026FindMarketDirectOfferSoft.SaleItemCollection\n    let pointer : FindViews.AuthNFTPointer\n\n    prepare(account: AuthAccount) {\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e())\n        self.market = account.borrow\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection\u003e(from: storagePath)!\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e())\n        let item = FindMarket.assertOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: id)\n        let nftIdentifier = item.getItemType().identifier\n\n        //If this is nil, there must be something wrong with FIND setup\n        // let privatePath = getPrivatePath(nftIdentifier)\n\n        let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier)) \n        let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n        let privatePath = collection.collectionData.privatePath\n\n\n        let providerCap=account.getCapability\u003c\u0026{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e(privatePath)\n        self.pointer= FindViews.AuthNFTPointer(cap: providerCap, id: item.getItemID())\n    }\n\n    execute {\n        self.market.acceptOffer(self.pointer)\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "acceptDirectOfferSoftDapper": {
               "code": "import FindMarketDirectOfferSoft from 0x097bafa4e0b48eef\nimport NonFungibleToken from 0x1d7e57aa55817448\nimport MetadataViews from 0x1d7e57aa55817448\nimport FindViews from 0x097bafa4e0b48eef\nimport NFTCatalog from 0x49a7cda3a1eecc29\nimport FINDNFTCatalog from 0x097bafa4e0b48eef\nimport FindMarket from 0x097bafa4e0b48eef\nimport FungibleToken from 0xf233dcee88fe0abe\n\ntransaction(marketplace:Address, id: UInt64) {\n\n    let market : \u0026FindMarketDirectOfferSoft.SaleItemCollection\n    let pointer : FindViews.AuthNFTPointer\n\n    prepare(account: AuthAccount) {\n\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e())\n        self.market = account.borrow\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection\u003e(from: storagePath)!\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e())\n        let item = FindMarket.assertOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: id)\n        let nftIdentifier = item.getItemType().identifier\n\n        let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier)) \n        let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n        let nft = collection.collectionData\n\n        let providerCap=account.getCapability\u003c\u0026{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e(nft.privatePath)\n        self.pointer= FindViews.AuthNFTPointer(cap: providerCap, id: item.getItemID())\n\n    }\n\n    execute {\n        self.market.acceptOffer(self.pointer)\n    }\n    \n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "acceptLeaseDirectOfferSoft": {
               "code": "import FindLeaseMarketDirectOfferSoft from 0x097bafa4e0b48eef\nimport NonFungibleToken from 0x1d7e57aa55817448\nimport MetadataViews from 0x1d7e57aa55817448\nimport FindViews from 0x097bafa4e0b48eef\nimport FindMarket from 0x097bafa4e0b48eef\nimport FindLeaseMarket from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\n\ntransaction(leaseName: String) {\n\n    let market : \u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection\n    let pointer : FindLeaseMarket.AuthLeasePointer\n\n    prepare(account: AuthAccount) {\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e())\n        self.market = account.borrow\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(from: storagePath)!\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e())\n        let item = FindLeaseMarket.assertOperationValid(tenant: marketplace, name: leaseName, marketOption: marketOption)\n        let ref = account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from: FIND.LeaseStoragePath) ?? panic(\"Cannot borrow reference to find lease collection. Account : \".concat(account.address.toString()))\n        self.pointer= FindLeaseMarket.AuthLeasePointer(ref: ref, name: leaseName)\n    }\n\n    execute {\n        self.market.acceptOffer(self.pointer)\n    }\n}",
               "spec": {
                  "order": [
                     "leaseName"
                  ],
                  "parameters": {
                     "leaseName": "String"
                  }
               }
            },
            "acceptLeaseDirectOfferSoftDapper": {
               "code": "import FindLeaseMarketDirectOfferSoft from 0x097bafa4e0b48eef\nimport NonFungibleToken from 0x1d7e57aa55817448\nimport MetadataViews from 0x1d7e57aa55817448\nimport FindViews from 0x097bafa4e0b48eef\nimport FindMarket from 0x097bafa4e0b48eef\nimport FindLeaseMarket from 0x097bafa4e0b48eef\nimport FungibleToken from 0xf233dcee88fe0abe\nimport FIND from 0x097bafa4e0b48eef\n\ntransaction(leaseName: String) {\n\n    let market : \u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection\n    let pointer : FindLeaseMarket.AuthLeasePointer\n\n    prepare(account: AuthAccount) {\n\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e())\n        self.market = account.borrow\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(from: storagePath)!\n\n        let ref = account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from: FIND.LeaseStoragePath) ?? panic(\"Cannot borrow reference to Find lease collection. Account : \".concat(account.address.toString()))\n        self.pointer= FindLeaseMarket.AuthLeasePointer(ref: ref, name: leaseName)\n\n    }\n\n    execute {\n        self.market.acceptOffer(self.pointer)\n    }\n\n}",
               "spec": {
                  "order": [
                     "leaseName"
                  ],
                  "parameters": {
                     "leaseName": "String"
                  }
               }
            },
            "acceptMultipleDirectOfferSoft": {
               "code": "import FindMarketDirectOfferSoft from 0x097bafa4e0b48eef\nimport NonFungibleToken from 0x1d7e57aa55817448\nimport MetadataViews from 0x1d7e57aa55817448\nimport FindViews from 0x097bafa4e0b48eef\nimport NFTCatalog from 0x49a7cda3a1eecc29\nimport FINDNFTCatalog from 0x097bafa4e0b48eef\nimport FindMarket from 0x097bafa4e0b48eef\n\ntransaction(marketplace:Address, ids: [UInt64]) {\n\n    let market : \u0026FindMarketDirectOfferSoft.SaleItemCollection\n    let pointer : [FindViews.AuthNFTPointer]\n\n    prepare(account: AuthAccount) {\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e())\n        self.market = account.borrow\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection\u003e(from: storagePath)!\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e())\n\n        var counter = 0\n        self.pointer = []\n        let nfts : {String : NFTCatalog.NFTCollectionData} = {}\n\n        while counter \u003c ids.length {\n            let item = FindMarket.assertOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: ids[counter])\n            var nft : NFTCatalog.NFTCollectionData? = nil\n            let nftIdentifier = item.getItemType().identifier\n\n            if nfts[nftIdentifier] != nil {\n                nft = nfts[nftIdentifier]\n            } else {\n                // nft = getCollectionData(nftIdentifier) \n                let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier)) \n                let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n                nft = collection.collectionData\n                nfts[nftIdentifier] = nft\n            }\n\n            let providerCap=account.getCapability\u003c\u0026{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e(nft!.privatePath)\n            let pointer= FindViews.AuthNFTPointer(cap: providerCap, id: item.getItemID())\n            self.pointer.append(pointer)\n            counter = counter + 1\n        }\n    }\n\n    execute {\n        var counter = 0\n        while counter \u003c ids.length {\n            self.market.acceptOffer(self.pointer[counter])\n            counter = counter + 1\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "ids"
                  ],
                  "parameters": {
                     "ids": "[UInt64]",
                     "marketplace": "Address"
                  }
               }
            },
            "acceptMultipleDirectOfferSoftDapper": {
               "code": "import FindMarketDirectOfferSoft from 0x097bafa4e0b48eef\nimport NonFungibleToken from 0x1d7e57aa55817448\nimport MetadataViews from 0x1d7e57aa55817448\nimport FindViews from 0x097bafa4e0b48eef\nimport NFTCatalog from 0x49a7cda3a1eecc29\nimport FINDNFTCatalog from 0x097bafa4e0b48eef\nimport FindMarket from 0x097bafa4e0b48eef\nimport FungibleToken from 0xf233dcee88fe0abe\n\ntransaction(marketplace:Address, ids: [UInt64]) {\n\n    let market : \u0026FindMarketDirectOfferSoft.SaleItemCollection\n    let pointer : [FindViews.AuthNFTPointer]\n\n    prepare(account: AuthAccount) {\n\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e())\n        self.market = account.borrow\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection\u003e(from: storagePath)!\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e())\n\n        var counter = 0\n        self.pointer = []\n        let nfts : {String : NFTCatalog.NFTCollectionData} = {}\n\n        while counter \u003c ids.length {\n            let item = FindMarket.assertOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: ids[counter])\n            var nft : NFTCatalog.NFTCollectionData? = nil\n            let nftIdentifier = item.getItemType().identifier\n            let ftType = item.getFtType()\n\n            if nfts[nftIdentifier] != nil {\n                nft = nfts[nftIdentifier]\n            } else {\n                // nft = getCollectionData(nftIdentifier) \n                let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier)) \n                let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n                nft = collection.collectionData\n                nfts[nftIdentifier] = nft\n            }\n\n            let providerCap=account.getCapability\u003c\u0026{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e(nft!.privatePath)\n            let pointer= FindViews.AuthNFTPointer(cap: providerCap, id: item.getItemID())\n            self.pointer.append(pointer)\n            counter = counter + 1\n        }\n\n    }\n\n    execute {\n        var counter = 0\n        while counter \u003c ids.length {\n            self.market.acceptOffer(self.pointer[counter])\n            counter = counter + 1\n        }\n    }\n    \n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "ids"
                  ],
                  "parameters": {
                     "ids": "[UInt64]",
                     "marketplace": "Address"
                  }
               }
            },
            "addCuratedCollection": {
               "code": "transaction(name: String, items: [String]) {\n    prepare(account: AuthAccount) {\n\n        let path=/storage/FindCuratedCollections\n        let publicPath=/public/FindCuratedCollections\n\n        var collections : {String: [String]} = {}\n        if account.borrow\u003c\u0026{String: [String]}\u003e(from:path) != nil {\n             collections=account.load\u003c{String: [String]}\u003e(from:path)!\n        }\n        collections[name] = items\n        account.save(collections, to: path)\n        let link = account.getCapability\u003c\u0026{String: [String]}\u003e(publicPath)\n        if !link.check() {\n            account.link\u003c\u0026{String: [String]}\u003e( publicPath, target: path)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "items"
                  ],
                  "parameters": {
                     "items": "[String]",
                     "name": "String"
                  }
               }
            },
            "addRelatedAccount": {
               "code": "import FindRelatedAccounts from 0x097bafa4e0b48eef\n\ntransaction(name: String, network: String, address: String) {\n\n    var relatedAccounts : \u0026FindRelatedAccounts.Accounts?\n\n    prepare(account: AuthAccount) {\n\n        self.relatedAccounts= account.borrow\u003c\u0026FindRelatedAccounts.Accounts\u003e(from:FindRelatedAccounts.storagePath)\n        if self.relatedAccounts == nil {\n            let relatedAccounts \u003c- FindRelatedAccounts.createEmptyAccounts()\n            account.save(\u003c- relatedAccounts, to: FindRelatedAccounts.storagePath)\n            account.link\u003c\u0026FindRelatedAccounts.Accounts{FindRelatedAccounts.Public}\u003e(FindRelatedAccounts.publicPath, target: FindRelatedAccounts.storagePath)\n            self.relatedAccounts = account.borrow\u003c\u0026FindRelatedAccounts.Accounts\u003e(from:FindRelatedAccounts.storagePath)\n        }\n\n        let cap = account.getCapability\u003c\u0026FindRelatedAccounts.Accounts{FindRelatedAccounts.Public}\u003e(FindRelatedAccounts.publicPath)\n        if !cap.check() {\n            account.unlink(FindRelatedAccounts.publicPath)\n            account.link\u003c\u0026FindRelatedAccounts.Accounts{FindRelatedAccounts.Public}\u003e(FindRelatedAccounts.publicPath, target: FindRelatedAccounts.storagePath)\n        }\n    }\n\n    execute {\n        self.relatedAccounts!.addRelatedAccount(name:name, network:network, address: address)\n    }\n\n}",
               "spec": {
                  "order": [
                     "name",
                     "network",
                     "address"
                  ],
                  "parameters": {
                     "address": "String",
                     "name": "String",
                     "network": "String"
                  }
               }
            },
            "addRelatedFlowAccount": {
               "code": "import FindRelatedAccounts from 0x097bafa4e0b48eef\n\ntransaction(name: String, address: Address) {\n\n    var relatedAccounts : \u0026FindRelatedAccounts.Accounts?\n\n    prepare(account: AuthAccount) {\n\n        self.relatedAccounts= account.borrow\u003c\u0026FindRelatedAccounts.Accounts\u003e(from:FindRelatedAccounts.storagePath)\n        if self.relatedAccounts == nil {\n            let relatedAccounts \u003c- FindRelatedAccounts.createEmptyAccounts()\n            account.save(\u003c- relatedAccounts, to: FindRelatedAccounts.storagePath)\n            account.link\u003c\u0026FindRelatedAccounts.Accounts{FindRelatedAccounts.Public}\u003e(FindRelatedAccounts.publicPath, target: FindRelatedAccounts.storagePath)\n            self.relatedAccounts = account.borrow\u003c\u0026FindRelatedAccounts.Accounts\u003e(from:FindRelatedAccounts.storagePath)\n        }\n\n        let cap = account.getCapability\u003c\u0026FindRelatedAccounts.Accounts{FindRelatedAccounts.Public}\u003e(FindRelatedAccounts.publicPath)\n        if !cap.check() {\n            account.unlink(FindRelatedAccounts.publicPath)\n            account.link\u003c\u0026FindRelatedAccounts.Accounts{FindRelatedAccounts.Public}\u003e(FindRelatedAccounts.publicPath, target: FindRelatedAccounts.storagePath)\n        }\n    }\n\n    execute {\n        self.relatedAccounts!.addFlowAccount(name:name, address: address)\n    }\n\n}",
               "spec": {
                  "order": [
                     "name",
                     "address"
                  ],
                  "parameters": {
                     "address": "Address",
                     "name": "String"
                  }
               }
            },
            "alterMarketOption": {
               "code": "import FindMarket from 0x097bafa4e0b48eef\n\ntransaction(marketRule: String , action: String ){\n    prepare(account: AuthAccount){\n        let path = FindMarket.TenantClientStoragePath\n        let tenantRef = account.borrow\u003c\u0026FindMarket.TenantClient\u003e(from: path) ?? panic(\"Cannot borrow Reference.\")\n\n\n        switch action {\n            case \"enable\" :\n                tenantRef.enableMarketOption(marketRule)\n\n            case \"deprecate\" :\n                tenantRef.deprecateMarketOption(marketRule)\n\n            case \"stop\" :\n                tenantRef.stopMarketOption(marketRule)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "marketRule",
                     "action"
                  ],
                  "parameters": {
                     "action": "String",
                     "marketRule": "String"
                  }
               }
            },
            "bidLeaseMarketAuctionSoft": {
               "code": "import FungibleToken from 0xf233dcee88fe0abe\nimport Profile from 0x097bafa4e0b48eef\nimport FTRegistry from 0x097bafa4e0b48eef\nimport FindMarket from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\nimport FindLeaseMarket from 0x097bafa4e0b48eef\nimport FindLeaseMarketAuctionSoft from 0x097bafa4e0b48eef\n\ntransaction(leaseName: String, amount: UFix64) {\n\n    let saleItemsCap: Capability\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic}\u003e\n    let walletReference : \u0026FungibleToken.Vault\n    let bidsReference: \u0026FindLeaseMarketAuctionSoft.MarketBidCollection?\n    let balanceBeforeBid: UFix64\n    let ftVaultType: Type\n\n    prepare(account: AuthAccount) {\n\n        let resolveAddress = FIND.resolve(leaseName)\n        if resolveAddress == nil {panic(\"The address input is not a valid name nor address. Input : \".concat(leaseName))}\n        let address = resolveAddress!\n\n        let leaseMarketplace = FindMarket.getFindTenantAddress()\n        let leaseTenantCapability= FindMarket.getTenantCapability(leaseMarketplace)!\n        let leaseTenant = leaseTenantCapability.borrow()!\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let leaseASBidType= Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e()\n        let leaseASBidPublicPath=leaseTenant.getPublicPath(leaseASBidType)\n        let leaseASBidStoragePath= leaseTenant.getStoragePath(leaseASBidType)\n        let leaseASBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath)\n        if !leaseASBidCap.check() {\n            account.save\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseASBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath, target: leaseASBidStoragePath)\n        }\n\n        self.saleItemsCap= FindLeaseMarketAuctionSoft.getSaleItemCapability(marketplace:leaseMarketplace, user:address) ?? panic(\"cannot find sale item cap\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e())\n\n        let item = FindLeaseMarket.assertOperationValid(tenant: leaseMarketplace, name: leaseName, marketOption: marketOption)\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n\n        self.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account. Account address : \".concat(account.address.toString()))\n        self.ftVaultType = ft.type\n\n        let bidStoragePath=leaseTenant.getStoragePath(Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e())\n\n        self.bidsReference= account.borrow\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(from: bidStoragePath)\n        self.balanceBeforeBid=self.walletReference.balance\n    }\n\n    pre {\n        self.bidsReference != nil : \"This account does not have a bid collection\"\n        self.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n    }\n\n    execute {\n        self.bidsReference!.bid(name:leaseName, amount: amount, vaultType: self.ftVaultType, bidExtraField: {})\n    }\n}",
               "spec": {
                  "order": [
                     "leaseName",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "leaseName": "String"
                  }
               }
            },
            "bidLeaseMarketAuctionSoftDapper": {
               "code": "import Profile from 0x097bafa4e0b48eef\nimport FungibleToken from 0xf233dcee88fe0abe\nimport FTRegistry from 0x097bafa4e0b48eef\nimport FindMarket from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\nimport FindLeaseMarketAuctionSoft from 0x097bafa4e0b48eef\nimport FindLeaseMarket from 0x097bafa4e0b48eef\n\ntransaction(leaseName: String, amount: UFix64) {\n\n    let saleItemsCap: Capability\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic}\u003e\n    let bidsReference: \u0026FindLeaseMarketAuctionSoft.MarketBidCollection?\n    let ftVaultType: Type\n\n    prepare(account: AuthAccount) {\n\n        let resolveAddress = FIND.resolve(leaseName)\n        if resolveAddress == nil {panic(\"The address input is not a valid name nor address. Input : \".concat(leaseName))}\n        let address = resolveAddress!\n\n        let leaseMarketplace = FindMarket.getFindTenantAddress()\n        let leaseTenantCapability= FindMarket.getTenantCapability(leaseMarketplace)!\n        let leaseTenant = leaseTenantCapability.borrow()!\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let leaseASBidType= Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e()\n        let leaseASBidPublicPath=leaseTenant.getPublicPath(leaseASBidType)\n        let leaseASBidStoragePath= leaseTenant.getStoragePath(leaseASBidType)\n        let leaseASBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath)\n        if !leaseASBidCap.check() {\n            account.save\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseASBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath, target: leaseASBidStoragePath)\n        }\n\n        self.saleItemsCap= FindLeaseMarketAuctionSoft.getSaleItemCapability(marketplace:leaseMarketplace, user:address) ?? panic(\"cannot find sale item cap\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e())\n\n        let item = FindLeaseMarket.assertOperationValid(tenant: leaseMarketplace, name: leaseName, marketOption: marketOption)\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n\n        self.ftVaultType = ft.type\n\n        let bidStoragePath=leaseTenant.getStoragePath(Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e())\n\n        self.bidsReference= account.borrow\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(from: bidStoragePath)\n    }\n\n    pre {\n        self.bidsReference != nil : \"This account does not have a bid collection\"\n    }\n\n    execute {\n        self.bidsReference!.bid(name:leaseName, amount: amount, vaultType: self.ftVaultType, bidExtraField: {})\n    }\n}",
               "spec": {
                  "order": [
                     "leaseName",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "leaseName": "String"
                  }
               }
            },
            "bidLeaseMarketDirectOfferSoft": {
               "code": "import Profile from 0x097bafa4e0b48eef\nimport FindMarket from 0x097bafa4e0b48eef\nimport FungibleToken from 0xf233dcee88fe0abe\nimport FTRegistry from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\nimport FindLeaseMarket from 0x097bafa4e0b48eef\nimport FindLeaseMarketDirectOfferSoft from 0x097bafa4e0b48eef\n\ntransaction(leaseName: String, ftAliasOrIdentifier:String, amount: UFix64, validUntil: UFix64?) {\n\n    let bidsReference: \u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection?\n    let ftVaultType: Type\n\n    prepare(account: AuthAccount) {\n\n\n        let resolveAddress = FIND.resolve(leaseName)\n        if resolveAddress == nil {panic(\"The address input is not a valid name nor address. Input : \".concat(leaseName))}\n        let address = resolveAddress!\n\n        let ft = FTRegistry.getFTInfo(ftAliasOrIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftAliasOrIdentifier))\n\n        self.ftVaultType = ft.type\n\n        let walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n        assert(walletReference.balance \u003e amount , message: \"Bidder has to have enough balance in wallet\")\n\n        let leaseMarketplace = FindMarket.getFindTenantAddress()\n        let leaseTenantCapability= FindMarket.getTenantCapability(leaseMarketplace)!\n        let leaseTenant = leaseTenantCapability.borrow()!\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let leaseDOSBidType= Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let leaseDOSBidPublicPath=leaseTenant.getPublicPath(leaseDOSBidType)\n        let leaseDOSBidStoragePath= leaseTenant.getStoragePath(leaseDOSBidType)\n        let leaseDOSBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath)\n        if !leaseDOSBidCap.check() {\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOSBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath, target: leaseDOSBidStoragePath)\n        }\n\n        self.bidsReference= account.borrow\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(from: leaseDOSBidStoragePath)\n\n    }\n\n    pre {\n        self.bidsReference != nil : \"This account does not have a bid collection\"\n    }\n\n    execute {\n        self.bidsReference!.bid(name:leaseName, amount: amount, vaultType: self.ftVaultType, validUntil: validUntil, saleItemExtraField: {}, bidExtraField: {})\n    }\n}",
               "spec": {
                  "order": [
                     "leaseName",
                     "ftAliasOrIdentifier",
                     "amount",
                     "validUntil"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "ftAliasOrIdentifier": "String",
                     "leaseName": "String",
                     "validUntil": "UFix64?"
                  }
               }
            },
            "bidLeaseMarketDirectOfferSoftDapper": {
               "code": "import FungibleToken from 0xf233dcee88fe0abe\nimport Profile from 0x097bafa4e0b48eef\nimport FindMarket from 0x097bafa4e0b48eef\nimport FTRegistry from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\nimport FindLeaseMarket from 0x097bafa4e0b48eef\nimport FindLeaseMarketDirectOfferSoft from 0x097bafa4e0b48eef\n\ntransaction(leaseName: String, ftAliasOrIdentifier:String, amount: UFix64, validUntil: UFix64?) {\n\n    let bidsReference: \u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection?\n    let ftVaultType: Type\n\n    prepare(account: AuthAccount) {\n\n        let ft = FTRegistry.getFTInfo(ftAliasOrIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftAliasOrIdentifier))\n\n        self.ftVaultType = ft.type\n\n        let leaseMarketplace = FindMarket.getFindTenantAddress()\n        let leaseTenantCapability= FindMarket.getTenantCapability(leaseMarketplace)!\n        let leaseTenant = leaseTenantCapability.borrow()!\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let leaseDOSBidType= Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let leaseDOSBidPublicPath=leaseTenant.getPublicPath(leaseDOSBidType)\n        let leaseDOSBidStoragePath= leaseTenant.getStoragePath(leaseDOSBidType)\n        let leaseDOSBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath)\n        if !leaseDOSBidCap.check() {\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOSBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath, target: leaseDOSBidStoragePath)\n        }\n\n        self.bidsReference= account.borrow\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(from: leaseDOSBidStoragePath)\n\n    }\n\n    pre {\n        self.bidsReference != nil : \"This account does not have a bid collection\"\n    }\n\n    execute {\n        self.bidsReference!.bid(name:leaseName, amount: amount, vaultType: self.ftVaultType, validUntil: validUntil, saleItemExtraField: {}, bidExtraField: {})\n    }\n}",
               "spec": {
                  "order": [
                     "leaseName",
                     "ftAliasOrIdentifier",
                     "amount",
                     "validUntil"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "ftAliasOrIdentifier": "String",
                     "leaseName": "String",
                     "validUntil": "UFix64?"
                  }
               }
            },
            "bidMarketAuctionEscrowed": {
               "code": "import FindMarketAuctionEscrow from 0x097bafa4e0b48eef\nimport FungibleToken from 0xf233dcee88fe0abe\nimport NonFungibleToken from 0x1d7e57aa55817448\nimport MetadataViews from 0x1d7e57aa55817448\nimport FindViews from 0x097bafa4e0b48eef\nimport FINDNFTCatalog from 0x097bafa4e0b48eef\nimport FTRegistry from 0x097bafa4e0b48eef\nimport FindMarket from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\nimport Profile from 0x097bafa4e0b48eef\n\ntransaction(marketplace:Address, user: String, id: UInt64, amount: UFix64) {\n\n    let saleItemsCap: Capability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic}\u003e \n    var targetCapability : Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e\n    let walletReference : \u0026FungibleToken.Vault\n    let bidsReference: \u0026FindMarketAuctionEscrow.MarketBidCollection?\n    let balanceBeforeBid: UFix64\n    let pointer: FindViews.ViewReadPointer\n\n    prepare(account: AuthAccount) {\n        let resolveAddress = FIND.resolve(user)\n        if resolveAddress == nil {panic(\"The address input is not a valid name nor address. Input : \".concat(user))}\n        let address = resolveAddress!\n\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n        let tenant = tenantCapability.borrow()!\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        /// auctions that escrow ft\n        let aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\n        let aeBidPublicPath=FindMarket.getPublicPath(aeBidType, name: tenant.name)\n        let aeBidStoragePath= FindMarket.getStoragePath(aeBidType, name:tenant.name)\n        let aeBidCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n        if !aeBidCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n        }\n\n        self.saleItemsCap= FindMarketAuctionEscrow.getSaleItemCapability(marketplace:marketplace, user:address) ?? panic(\"cannot find sale item cap. User address : \".concat(address.toString()))\n\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e())\n        let item = FindMarket.assertOperationValid(tenant: marketplace, address: address, marketOption: marketOption, id: id)\n\n        let nftIdentifier = item.getItemType().identifier\n        let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier)) \n        let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n        let nft = collection.collectionData\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n    \n        self.targetCapability= account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(nft.publicPath)\n        /* Check for nftCapability */\n        if !self.targetCapability.check() {\n            let cd = item.getNFTCollectionData()\n            // should use account.type here instead\n            if account.type(at: cd.storagePath) != nil {\n                let pathIdentifier = nft.publicPath.toString()\n                let findPath = PublicPath(identifier: pathIdentifier.slice(from: \"/public/\".length , upTo: pathIdentifier.length).concat(\"_FIND\"))!\n                account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                    findPath,\n                    target: nft.storagePath\n                )\n                self.targetCapability = account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(findPath)\n            } else {\n                account.save(\u003c- cd.createEmptyCollection(), to: cd.storagePath)\n                account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.publicPath, target: cd.storagePath)\n                account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.providerPath, target: cd.storagePath)\n            }\n\n        }\n        \n        self.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n        \n        let bidSstoragePath=tenant.getStoragePath(Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e())\n\n        self.bidsReference= account.borrow\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection\u003e(from: bidSstoragePath)\n        self.balanceBeforeBid=self.walletReference.balance\n        self.pointer= FindViews.createViewReadPointer(address: address, path:nft.publicPath, id: item.getItemID())\n    }\n\n    pre {\n        self.bidsReference != nil : \"This account does not have a bid collection\"\n        self.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount) \n        self.bidsReference!.bid(item:self.pointer, vault: \u003c- vault, nftCap: self.targetCapability, bidExtraField: {})\n    }\n\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "user",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64",
                     "marketplace": "Address",
                     "user": "String"
                  }
               }
            },
            "bidMarketAuctionSoft": {
               "code": "import FindMarketAuctionSoft from 0x097bafa4e0b48eef\nimport NonFungibleToken from 0x1d7e57aa55817448\nimport FungibleToken from 0xf233dcee88fe0abe\nimport MetadataViews from 0x1d7e57aa55817448\nimport FindViews from 0x097bafa4e0b48eef\nimport FTRegistry from 0x097bafa4e0b48eef\nimport FINDNFTCatalog from 0x097bafa4e0b48eef\nimport FindMarket from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\nimport Profile from 0x097bafa4e0b48eef\n\ntransaction(marketplace:Address, user: String, id: UInt64, amount: UFix64) {\n\n    let saleItemsCap: Capability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic}\u003e \n    var targetCapability : Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e\n    let walletReference : \u0026FungibleToken.Vault\n    let bidsReference: \u0026FindMarketAuctionSoft.MarketBidCollection?\n    let balanceBeforeBid: UFix64\n    let pointer: FindViews.ViewReadPointer\n    let ftVaultType: Type\n\n    prepare(account: AuthAccount) {\n\n        let resolveAddress = FIND.resolve(user)\n        if resolveAddress == nil {panic(\"The address input is not a valid name nor address. Input : \".concat(user))}\n        let address = resolveAddress!\n\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n        let tenant = tenantCapability.borrow()!\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n        if !asBidCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n        }\n\n        self.saleItemsCap= FindMarketAuctionSoft.getSaleItemCapability(marketplace:marketplace, user:address) ?? panic(\"cannot find sale item cap\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e())\n\n        let item = FindMarket.assertOperationValid(tenant: marketplace, address: address, marketOption: marketOption, id: id)\n\n        let nftIdentifier = item.getItemType().identifier\n        let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier)) \n        let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n        let nft = collection.collectionData\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n    \n        self.targetCapability= account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(nft.publicPath)\n        /* Check for nftCapability */\n        if !self.targetCapability.check() {\n            let cd = item.getNFTCollectionData()\n            // should use account.type here instead\n            if account.type(at: cd.storagePath) != nil {\n                let pathIdentifier = nft.publicPath.toString()\n                let findPath = PublicPath(identifier: pathIdentifier.slice(from: \"/public/\".length , upTo: pathIdentifier.length).concat(\"_FIND\"))!\n                account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                    findPath,\n                    target: nft.storagePath\n                )\n                self.targetCapability = account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(findPath)\n            } else {\n                account.save(\u003c- cd.createEmptyCollection(), to: cd.storagePath)\n                account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.publicPath, target: cd.storagePath)\n                account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.providerPath, target: cd.storagePath)\n            }\n\n        }\n        \n        self.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account. Account address : \".concat(account.address.toString()))\n        self.ftVaultType = ft.type\n\n        let bidStoragePath=tenant.getStoragePath(Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e())\n\n        self.bidsReference= account.borrow\u003c\u0026FindMarketAuctionSoft.MarketBidCollection\u003e(from: bidStoragePath)\n        self.balanceBeforeBid=self.walletReference.balance\n        self.pointer= FindViews.createViewReadPointer(address: address, path:nft.publicPath, id: item.getItemID())\n    }\n\n    pre {\n        self.bidsReference != nil : \"This account does not have a bid collection\"\n        self.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n    }\n\n    execute {\n        self.bidsReference!.bid(item:self.pointer, amount: amount, vaultType: self.ftVaultType, nftCap: self.targetCapability, bidExtraField: {})\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "user",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64",
                     "marketplace": "Address",
                     "user": "String"
                  }
               }
            },
            "bidMarketAuctionSoftDapper": {
               "code": "import FindMarketAuctionSoft from 0x097bafa4e0b48eef\nimport NonFungibleToken from 0x1d7e57aa55817448\nimport FungibleToken from 0xf233dcee88fe0abe\nimport MetadataViews from 0x1d7e57aa55817448\nimport FindViews from 0x097bafa4e0b48eef\nimport FTRegistry from 0x097bafa4e0b48eef\nimport FINDNFTCatalog from 0x097bafa4e0b48eef\nimport FindMarket from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\nimport Profile from 0x097bafa4e0b48eef\n\ntransaction(marketplace:Address, user: String, id: UInt64, amount: UFix64) {\n\n    let saleItemsCap: Capability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic}\u003e \n    var targetCapability : Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e\n    let bidsReference: \u0026FindMarketAuctionSoft.MarketBidCollection?\n    let pointer: FindViews.ViewReadPointer\n    let ftVaultType: Type\n\n    prepare(account: AuthAccount) {\n\n        let resolveAddress = FIND.resolve(user)\n        if resolveAddress == nil {panic(\"The address input is not a valid name nor address. Input : \".concat(user))}\n        let address = resolveAddress!\n\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n        let tenant = tenantCapability.borrow()!\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n        if !asBidCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n        }\n\n        self.saleItemsCap= FindMarketAuctionSoft.getSaleItemCapability(marketplace:marketplace, user:address) ?? panic(\"cannot find sale item cap\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e())\n\n        let item = FindMarket.assertOperationValid(tenant: marketplace, address: address, marketOption: marketOption, id: id)\n\n        let nftIdentifier = item.getItemType().identifier\n        let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier)) \n        let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n        let nft = collection.collectionData\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n    \n        self.targetCapability= account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(nft.publicPath)\n        /* Check for nftCapability */\n        if !self.targetCapability.check() {\n            let cd = item.getNFTCollectionData()\n            // should use account.type here instead\n            if account.type(at: cd.storagePath) != nil {\n                let pathIdentifier = nft.publicPath.toString()\n                let findPath = PublicPath(identifier: pathIdentifier.slice(from: \"/public/\".length , upTo: pathIdentifier.length).concat(\"_FIND\"))!\n                account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                    findPath,\n                    target: nft.storagePath\n                )\n                self.targetCapability = account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(findPath)\n            } else {\n                account.save(\u003c- cd.createEmptyCollection(), to: cd.storagePath)\n                account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.publicPath, target: cd.storagePath)\n                account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.providerPath, target: cd.storagePath)\n            }\n\n        }\n        \n        self.ftVaultType = ft.type\n\n        let bidStoragePath=tenant.getStoragePath(Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e())\n\n        self.bidsReference= account.borrow\u003c\u0026FindMarketAuctionSoft.MarketBidCollection\u003e(from: bidStoragePath)\n        self.pointer= FindViews.createViewReadPointer(address: address, path:nft.publicPath, id: item.getItemID())\n    }\n\n    pre {\n        self.bidsReference != nil : \"This account does not have a bid collection\"\n    }\n\n    execute {\n        self.bidsReference!.bid(item:self.pointer, amount: amount, vaultType: self.ftVaultType, nftCap: self.targetCapability, bidExtraField: {})\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "user",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64",
                     "marketplace": "Address",
                     "user": "String"
                  }
               }
            },
            "bidMarketDirectOfferEscrowed": {
               "code": "import Profile from 0x097bafa4e0b48eef\nimport FindMarket from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferEscrow from 0x097bafa4e0b48eef\nimport FungibleToken from 0xf233dcee88fe0abe\nimport NonFungibleToken from 0x1d7e57aa55817448\nimport MetadataViews from 0x1d7e57aa55817448\nimport FindViews from 0x097bafa4e0b48eef\nimport FTRegistry from 0x097bafa4e0b48eef\nimport FINDNFTCatalog from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\n\ntransaction(marketplace:Address, user: String, nftAliasOrIdentifier: String, id: UInt64, ftAliasOrIdentifier:String, amount: UFix64, validUntil: UFix64?) {\n\n    var targetCapability : Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e\n    let walletReference : \u0026FungibleToken.Vault\n    let bidsReference: \u0026FindMarketDirectOfferEscrow.MarketBidCollection?\n    let pointer: FindViews.ViewReadPointer\n\n    prepare(account: AuthAccount) {\n\n        let resolveAddress = FIND.resolve(user)\n        if resolveAddress == nil {panic(\"The address input is not a valid name nor address. Input : \".concat(user))}\n        let address = resolveAddress!\n\n        let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftAliasOrIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftAliasOrIdentifier)) \n        let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n        let nft = collection.collectionData\n\n        let ft = FTRegistry.getFTInfo(ftAliasOrIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftAliasOrIdentifier))\n        \n        self.targetCapability= account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(nft.publicPath)\n        self.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n        let tenant = tenantCapability.borrow()!\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        let doeBidPublicPath=FindMarket.getPublicPath(doeBidType, name: tenant.name)\n        let doeBidStoragePath= FindMarket.getStoragePath(doeBidType, name:tenant.name)\n        let doeBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n        if !doeBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n        }\n\n        self.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection\u003e(from: doeBidStoragePath)\n        self.pointer= FindViews.createViewReadPointer(address: address, path:nft.publicPath, id: id)\n\n        /* Check for nftCapability */\n        if !self.targetCapability.check() {\n            let cd = self.pointer.getNFTCollectionData()\n            // should use account.type here instead\n            if account.type(at: cd.storagePath) != nil {\n                let pathIdentifier = nft.publicPath.toString()\n                let findPath = PublicPath(identifier: pathIdentifier.slice(from: \"/public/\".length , upTo: pathIdentifier.length).concat(\"_FIND\"))!\n                account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                    findPath,\n                    target: nft.storagePath\n                )\n                self.targetCapability = account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(findPath)\n            } else {\n                account.save(\u003c- cd.createEmptyCollection(), to: cd.storagePath)\n                account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.publicPath, target: cd.storagePath)\n                account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.providerPath, target: cd.storagePath)\n            }\n\n        }\n    }\n\n    pre {\n        self.bidsReference != nil : \"This account does not have a bid collection\"\n        self.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount) \n        self.bidsReference!.bid(item:self.pointer, vault: \u003c- vault, nftCap: self.targetCapability, validUntil: validUntil, saleItemExtraField: {}, bidExtraField: {})\n    }\n\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "user",
                     "nftAliasOrIdentifier",
                     "id",
                     "ftAliasOrIdentifier",
                     "amount",
                     "validUntil"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "ftAliasOrIdentifier": "String",
                     "id": "UInt64",
                     "marketplace": "Address",
                     "nftAliasOrIdentifier": "String",
                     "user": "String",
                     "validUntil": "UFix64?"
                  }
               }
            },
            "bidMarketDirectOfferSoft": {
               "code": "import Profile from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferSoft from 0x097bafa4e0b48eef\nimport FindMarket from 0x097bafa4e0b48eef\nimport FungibleToken from 0xf233dcee88fe0abe\nimport NonFungibleToken from 0x1d7e57aa55817448\nimport MetadataViews from 0x1d7e57aa55817448\nimport FindViews from 0x097bafa4e0b48eef\nimport FTRegistry from 0x097bafa4e0b48eef\nimport FINDNFTCatalog from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\n\ntransaction(marketplace:Address, user: String, nftAliasOrIdentifier: String, id: UInt64, ftAliasOrIdentifier:String, amount: UFix64, validUntil: UFix64?) {\n\n    var targetCapability : Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e\n    let walletReference : \u0026FungibleToken.Vault\n    let bidsReference: \u0026FindMarketDirectOfferSoft.MarketBidCollection?\n    let balanceBeforeBid: UFix64\n    let pointer: FindViews.ViewReadPointer\n    let ftVaultType: Type\n\n    prepare(account: AuthAccount) {\n        \n        let resolveAddress = FIND.resolve(user)\n        if resolveAddress == nil {panic(\"The address input is not a valid name nor address. Input : \".concat(user))}\n        let address = resolveAddress!\n\n        let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftAliasOrIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftAliasOrIdentifier)) \n        let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n        let nft = collection.collectionData\n\n        let ft = FTRegistry.getFTInfo(ftAliasOrIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftAliasOrIdentifier))\n\n        self.ftVaultType = ft.type\n\n        self.targetCapability= account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(nft.publicPath)\n        self.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n        let tenant = tenantCapability.borrow()!\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n        if !dosBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n        }\n\n        self.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection\u003e(from: dosBidStoragePath)\n        self.balanceBeforeBid=self.walletReference.balance\n        self.pointer= FindViews.createViewReadPointer(address: address, path:nft.publicPath, id: id)\n\n        /* Check for nftCapability */\n        if !self.targetCapability.check() {\n            let cd = self.pointer.getNFTCollectionData()\n            // should use account.type here instead\n            if account.type(at: cd.storagePath) != nil {\n                let pathIdentifier = nft.publicPath.toString()\n                let findPath = PublicPath(identifier: pathIdentifier.slice(from: \"/public/\".length , upTo: pathIdentifier.length).concat(\"_FIND\"))!\n                account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                    findPath,\n                    target: nft.storagePath\n                )\n                self.targetCapability = account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(findPath)\n            } else {\n                account.save(\u003c- cd.createEmptyCollection(), to: cd.storagePath)\n                account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.publicPath, target: cd.storagePath)\n                account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.providerPath, target: cd.storagePath)\n            }\n\n        }\n    }\n\n    pre {\n        self.bidsReference != nil : \"This account does not have a bid collection\"\n        self.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n    }\n\n    execute {\n        self.bidsReference!.bid(item:self.pointer, amount: amount, vaultType: self.ftVaultType, nftCap: self.targetCapability, validUntil: validUntil, saleItemExtraField: {}, bidExtraField: {})\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "user",
                     "nftAliasOrIdentifier",
                     "id",
                     "ftAliasOrIdentifier",
                     "amount",
                     "validUntil"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "ftAliasOrIdentifier": "String",
                     "id": "UInt64",
                     "marketplace": "Address",
                     "nftAliasOrIdentifier": "String",
                     "user": "String",
                     "validUntil": "UFix64?"
                  }
               }
            },
            "bidMarketDirectOfferSoftDapper": {
               "code": "import Profile from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferSoft from 0x097bafa4e0b48eef\nimport FindMarket from 0x097bafa4e0b48eef\nimport FungibleToken from 0xf233dcee88fe0abe\nimport NonFungibleToken from 0x1d7e57aa55817448\nimport MetadataViews from 0x1d7e57aa55817448\nimport FindViews from 0x097bafa4e0b48eef\nimport FINDNFTCatalog from 0x097bafa4e0b48eef\nimport FTRegistry from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\n\ntransaction(marketplace:Address, user: String, nftAliasOrIdentifier: String, id: UInt64, ftAliasOrIdentifier: String, amount: UFix64, validUntil: UFix64?) {\n\n    var targetCapability : Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e\n    let bidsReference: \u0026FindMarketDirectOfferSoft.MarketBidCollection?\n    let pointer: FindViews.ViewReadPointer\n    let ftVaultType: Type\n\n    prepare(account: AuthAccount) {\n        \n        let resolveAddress = FIND.resolve(user)\n        if resolveAddress == nil {panic(\"The address input is not a valid name nor address. Input : \".concat(user))}\n        let address = resolveAddress!\n\n        let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftAliasOrIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftAliasOrIdentifier)) \n        let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n        let nft = collection.collectionData\n\n        let ft = FTRegistry.getFTInfo(ftAliasOrIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftAliasOrIdentifier))\n\n        self.ftVaultType = ft.type\n\n        self.targetCapability= account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(nft.publicPath)\n\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n        let tenant = tenantCapability.borrow()!\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n        if !dosBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n        }\n\n        self.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection\u003e(from: dosBidStoragePath)\n        self.pointer= FindViews.createViewReadPointer(address: address, path:nft.publicPath, id: id)\n\n        /* Check for nftCapability */\n        if !self.targetCapability.check() {\n            let cd = self.pointer.getNFTCollectionData()\n            // should use account.type here instead\n            if account.type(at: cd.storagePath) != nil {\n                let pathIdentifier = nft.publicPath.toString()\n                let findPath = PublicPath(identifier: pathIdentifier.slice(from: \"/public/\".length , upTo: pathIdentifier.length).concat(\"_FIND\"))!\n                account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                    findPath,\n                    target: nft.storagePath\n                )\n                self.targetCapability = account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(findPath)\n            } else {\n                account.save(\u003c- cd.createEmptyCollection(), to: cd.storagePath)\n                account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.publicPath, target: cd.storagePath)\n                account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.providerPath, target: cd.storagePath)\n            }\n\n        }\n    }\n\n    pre {\n        self.bidsReference != nil : \"This account does not have a bid collection\"\n    }\n\n    execute {\n        self.bidsReference!.bid(item:self.pointer, amount: amount, vaultType: self.ftVaultType, nftCap: self.targetCapability, validUntil: validUntil, saleItemExtraField: {}, bidExtraField: {})\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "user",
                     "nftAliasOrIdentifier",
                     "id",
                     "ftAliasOrIdentifier",
                     "amount",
                     "validUntil"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "ftAliasOrIdentifier": "String",
                     "id": "UInt64",
                     "marketplace": "Address",
                     "nftAliasOrIdentifier": "String",
                     "user": "String",
                     "validUntil": "UFix64?"
                  }
               }
            },
            "bidMultipleMarketDirectOfferEscrowed": {
               "code": "import FindMarket from 0x097bafa4e0b48eef\nimport FindMarketSale from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferEscrow from 0x097bafa4e0b48eef\nimport FungibleToken from 0xf233dcee88fe0abe\nimport NonFungibleToken from 0x1d7e57aa55817448\nimport MetadataViews from 0x1d7e57aa55817448\nimport FindViews from 0x097bafa4e0b48eef\nimport FTRegistry from 0x097bafa4e0b48eef\nimport NFTCatalog from 0x49a7cda3a1eecc29\nimport FINDNFTCatalog from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\n\ntransaction(marketplace:Address, users: [String], nftAliasOrIdentifiers: [String], ids: [UInt64], ftAliasOrIdentifiers:[String], amounts: [UFix64], validUntil: UFix64?) {\n\n    let targetCapability : [Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e]\n    let walletReference : [\u0026FungibleToken.Vault]\n    let bidsReference: \u0026FindMarketDirectOfferEscrow.MarketBidCollection?\n    let pointer: [FindViews.ViewReadPointer]\n\n    prepare(account: AuthAccount) {\n\n        if nftAliasOrIdentifiers.length != users.length {\n            panic(\"The length of arrays passed in has to be the same\")\n        } else if nftAliasOrIdentifiers.length != ids.length {\n            panic(\"The length of arrays passed in has to be the same\")\n        } else if nftAliasOrIdentifiers.length != ftAliasOrIdentifiers.length {\n            panic(\"The length of arrays passed in has to be the same\")\n        } else if nftAliasOrIdentifiers.length != amounts.length {\n            panic(\"The length of arrays passed in has to be the same\")\n        }\n\n        let addresses : {String : Address} = {}\n        let nfts : {String : NFTCatalog.NFTCollectionData} = {}\n        let fts : {String : FTRegistry.FTInfo} = {}\n\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketSale.SaleItemCollection\u003e())\n        let vaultRefs : {StoragePath : \u0026FungibleToken.Vault} = {}\n\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n        let tenant = tenantCapability.borrow()!\n        let bidStoragePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e())\n\n        self.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection\u003e(from: bidStoragePath)\n        self.walletReference = []\n        self.pointer = []\n        self.targetCapability = []\n\n        var counter = 0\n        while counter \u003c users.length {\n            var resolveAddress : Address? = nil\n            if addresses[users[counter]] != nil {\n                resolveAddress = addresses[users[counter]]!\n            } else {\n                let address = FIND.resolve(users[counter])\n                if address == nil {\n                    panic(\"The address input is not a valid name nor address. Input : \".concat(users[counter]))\n                }\n                addresses[users[counter]] = address!\n                resolveAddress = address!\n            }\n            let address = resolveAddress!\n\n            var nft : NFTCatalog.NFTCollectionData? = nil\n            var ft : FTRegistry.FTInfo? = nil\n            let nftIdentifier = nftAliasOrIdentifiers[counter]\n            let ftIdentifier = ftAliasOrIdentifiers[counter]\n\n            if nfts[nftIdentifier] != nil {\n                nft = nfts[nftIdentifier]\n            } else {\n                let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier))\n                let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])!\n                nft =  collection.collectionData\n\n                nfts[nftIdentifier] = nft\n            }\n\n            if fts[ftIdentifier] != nil {\n                ft = fts[ftIdentifier]\n            } else {\n                ft = FTRegistry.getFTInfo(ftIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftIdentifier))\n                fts[ftIdentifier] = ft\n            }\n\n            if vaultRefs[ft!.vaultPath] != nil {\n                self.walletReference.append(vaultRefs[ft!.vaultPath]!)\n            } else {\n                let walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft!.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n                vaultRefs[ft!.vaultPath] = walletReference\n                self.walletReference.append(walletReference)\n            }\n\n            let pointer= FindViews.createViewReadPointer(address: address, path:nft!.publicPath, id: ids[counter])\n            self.pointer.append(pointer)\n\n            var targetCapability= account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(nft!.publicPath)\n            /* Check for nftCapability */\n            if !targetCapability.check() {\n                let cd = pointer.getNFTCollectionData()\n                // should use account.type here instead\n                if account.type(at: cd.storagePath) != nil {\n                    let pathIdentifier = nft!.publicPath.toString()\n                    let findPath = PublicPath(identifier: pathIdentifier.slice(from: \"/public/\".length , upTo: pathIdentifier.length).concat(\"_FIND\"))!\n                    account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                        findPath,\n                        target: nft!.storagePath\n                    )\n                    targetCapability = account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(findPath)\n                } else {\n                    account.save(\u003c- cd.createEmptyCollection(), to: cd.storagePath)\n                    account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.publicPath, target: cd.storagePath)\n                    account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.providerPath, target: cd.storagePath)\n                }\n\n            }\n            self.targetCapability.append(targetCapability)\n            counter = counter + 1\n        }\n    }\n\n    pre {\n        self.bidsReference != nil : \"This account does not have a bid collection\"\n    }\n\n    execute {\n        var counter = 0\n        while counter \u003c ids.length {\n            if self.walletReference[counter].balance \u003c amounts[counter] {\n                panic(\"Your wallet does not have enough funds to pay for this item. Fund Type : \".concat(ftAliasOrIdentifiers[counter]).concat(\"Required Amount : \").concat(amounts[counter].toString()))\n            }\n            let vault \u003c- self.walletReference[counter].withdraw(amount: amounts[counter])\n            self.bidsReference!.bid(item:self.pointer[counter], vault: \u003c- vault, nftCap: self.targetCapability[counter], validUntil: validUntil, saleItemExtraField: {}, bidExtraField: {})\n            counter = counter + 1\n        }\n    }\n\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "users",
                     "nftAliasOrIdentifiers",
                     "ids",
                     "ftAliasOrIdentifiers",
                     "amounts",
                     "validUntil"
                  ],
                  "parameters": {
                     "amounts": "[UFix64]",
                     "ftAliasOrIdentifiers": "[String]",
                     "ids": "[UInt64]",
                     "marketplace": "Address",
                     "nftAliasOrIdentifiers": "[String]",
                     "users": "[String]",
                     "validUntil": "UFix64?"
                  }
               }
            },
            "bidMultipleMarketDirectOfferSoft": {
               "code": "import FindMarketDirectOfferSoft from 0x097bafa4e0b48eef\nimport FindMarket from 0x097bafa4e0b48eef\nimport FungibleToken from 0xf233dcee88fe0abe\nimport NonFungibleToken from 0x1d7e57aa55817448\nimport MetadataViews from 0x1d7e57aa55817448\nimport FindViews from 0x097bafa4e0b48eef\nimport FTRegistry from 0x097bafa4e0b48eef\nimport NFTCatalog from 0x49a7cda3a1eecc29\nimport FINDNFTCatalog from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\n\ntransaction(marketplace:Address, users: [String], nftAliasOrIdentifiers: [String], ids: [UInt64], ftAliasOrIdentifiers:[String], amounts: [UFix64], validUntil: UFix64?) {\n\n    let targetCapability : [Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e]\n    let walletReference : [\u0026FungibleToken.Vault]\n    let bidsReference: \u0026FindMarketDirectOfferSoft.MarketBidCollection?\n    let pointer: [FindViews.ViewReadPointer]\n    let ftVaultType: [Type]\n    let totalPrice : {String : UFix64}\n\n    prepare(account: AuthAccount) {\n\n        if nftAliasOrIdentifiers.length != users.length {\n            panic(\"The length of arrays passed in has to be the same\")\n        } else if nftAliasOrIdentifiers.length != ids.length {\n            panic(\"The length of arrays passed in has to be the same\")\n        } else if nftAliasOrIdentifiers.length != ftAliasOrIdentifiers.length {\n            panic(\"The length of arrays passed in has to be the same\")\n        } else if nftAliasOrIdentifiers.length != amounts.length {\n            panic(\"The length of arrays passed in has to be the same\")\n        }\n\n        let addresses : {String : Address} = {}\n        let nfts : {String : NFTCatalog.NFTCollectionData} = {}\n        let fts : {String : FTRegistry.FTInfo} = {}\n        let vaultRefs : {StoragePath : \u0026FungibleToken.Vault} = {}\n        \n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n        let tenant = tenantCapability.borrow()!\n        let bidStoragePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n        self.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection\u003e(from: bidStoragePath)\n        self.walletReference = []\n        self.pointer = []\n        self.targetCapability = []\n        self.ftVaultType = []\n        self.totalPrice = {}\n\n        var counter = 0\n        while counter \u003c users.length {\n            var resolveAddress : Address? = nil\n            if addresses[users[counter]] != nil {\n                resolveAddress = addresses[users[counter]]!\n            } else {\n                let address = FIND.resolve(users[counter])\n                if address == nil {\n                    panic(\"The address input is not a valid name nor address. Input : \".concat(users[counter]))\n                }\n                addresses[users[counter]] = address!\n                resolveAddress = address!\n            }\n            let address = resolveAddress!\n\n            var nft : NFTCatalog.NFTCollectionData? = nil\n            var ft : FTRegistry.FTInfo? = nil\n            let nftIdentifier = nftAliasOrIdentifiers[counter]\n            let ftIdentifier = ftAliasOrIdentifiers[counter]\n\n            if nfts[nftIdentifier] != nil {\n                nft = nfts[nftIdentifier]\n            } else {\n                let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier)) \n                let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n                nft = collection.collectionData\n                nfts[nftIdentifier] = nft\n            }\n\n            if fts[ftIdentifier] != nil {\n                ft = fts[ftIdentifier]\n            } else {\n                ft = FTRegistry.getFTInfo(ftIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftIdentifier))\n                fts[ftIdentifier] = ft \n            }\n        \n            if vaultRefs[ft!.vaultPath] != nil {\n                self.walletReference.append(vaultRefs[ft!.vaultPath]!)\n                self.ftVaultType.append(vaultRefs[ft!.vaultPath]!.getType())\n            } else {\n                let walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft!.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n                vaultRefs[ft!.vaultPath] = walletReference\n                self.walletReference.append(walletReference)\n                self.ftVaultType.append(ft!.type)\n            }\n\n            if self.totalPrice[ftIdentifier] == nil {\n                self.totalPrice[ftIdentifier] = amounts[counter]\n            } else {\n                self.totalPrice[ftIdentifier] = self.totalPrice[ftIdentifier]! + amounts[counter]\n            }\n\n            let pointer= FindViews.createViewReadPointer(address: address, path:nft!.publicPath, id: ids[counter])\n            self.pointer.append(pointer)\n\n            var targetCapability= account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(nft!.publicPath)\n\n            /* Check for nftCapability */\n            if !targetCapability.check() {\n                let cd = pointer.getNFTCollectionData()\n                // should use account.type here instead\n                if account.type(at: cd.storagePath) != nil {\n                    let pathIdentifier = nft!.publicPath.toString()\n                    let findPath = PublicPath(identifier: pathIdentifier.slice(from: \"/public/\".length , upTo: pathIdentifier.length).concat(\"_FIND\"))!\n                    account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                        findPath,\n                        target: nft!.storagePath\n                    )\n                    targetCapability = account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(findPath)\n                } else {\n                    account.save(\u003c- cd.createEmptyCollection(), to: cd.storagePath)\n                    account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.publicPath, target: cd.storagePath)\n                    account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.providerPath, target: cd.storagePath)\n                }\n\n            }\n            self.targetCapability.append(targetCapability)\n            counter = counter + 1\n        }\n    }\n\n    pre {\n        self.bidsReference != nil : \"This account does not have a bid collection\"\n    }\n\n    execute {\n        var counter = 0\n        while counter \u003c ids.length {\n            if self.walletReference[counter].balance \u003c self.totalPrice[ftAliasOrIdentifiers[counter]]! {\n                panic(\"Your wallet does not have enough funds to pay for this item. Vault Type : \".concat(self.ftVaultType[counter].getType().identifier).concat(\" . Required : \".concat(self.totalPrice[ftAliasOrIdentifiers[counter]]!.toString())))\n            }    \n            self.bidsReference!.bid(item:self.pointer[counter], amount: amounts[counter], vaultType: self.ftVaultType[counter], nftCap: self.targetCapability[counter], validUntil: validUntil, saleItemExtraField: {}, bidExtraField: {})\n            counter = counter + 1 \n        }\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "users",
                     "nftAliasOrIdentifiers",
                     "ids",
                     "ftAliasOrIdentifiers",
                     "amounts",
                     "validUntil"
                  ],
                  "parameters": {
                     "amounts": "[UFix64]",
                     "ftAliasOrIdentifiers": "[String]",
                     "ids": "[UInt64]",
                     "marketplace": "Address",
                     "nftAliasOrIdentifiers": "[String]",
                     "users": "[String]",
                     "validUntil": "UFix64?"
                  }
               }
            },
            "bidMultipleMarketDirectOfferSoftDapper": {
               "code": "import FindMarketSale from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferSoft from 0x097bafa4e0b48eef\nimport FindMarket from 0x097bafa4e0b48eef\nimport FungibleToken from 0xf233dcee88fe0abe\nimport NonFungibleToken from 0x1d7e57aa55817448\nimport MetadataViews from 0x1d7e57aa55817448\nimport FindViews from 0x097bafa4e0b48eef\nimport NFTCatalog from 0x49a7cda3a1eecc29\nimport FINDNFTCatalog from 0x097bafa4e0b48eef\nimport FTRegistry from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\n\ntransaction(marketplace:Address, users: [String], nftAliasOrIdentifiers: [String], ids: [UInt64], ftAliasOrIdentifiers: [String], amounts: [UFix64], validUntil: UFix64?) {\n\n    let targetCapability : [Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e]\n    let bidsReference: \u0026FindMarketDirectOfferSoft.MarketBidCollection?\n    let pointer: [FindViews.ViewReadPointer]\n    let walletReference : [\u0026FungibleToken.Vault]\n    let ftVaultType: [Type]\n    let walletBalances : {Type : UFix64}\n\n    prepare(account: AuthAccount) {\n\n        if nftAliasOrIdentifiers.length != users.length {\n            panic(\"The length of arrays passed in has to be the same\")\n        } else if nftAliasOrIdentifiers.length != ids.length {\n            panic(\"The length of arrays passed in has to be the same\")\n        } else if nftAliasOrIdentifiers.length != amounts.length {\n            panic(\"The length of arrays passed in has to be the same\")\n        }\n        \n        let addresses : {String : Address} = {}\n        let nfts : {String : NFTCatalog.NFTCollectionData} = {}\n        let fts : {String : FTRegistry.FTInfo} = {}\n\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketSale.SaleItemCollection\u003e())\n        let vaultType : {String : Type} = {}\n\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n        let tenant = tenantCapability.borrow()!\n        let bidStoragePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n        self.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection\u003e(from: bidStoragePath)\n        \n        self.pointer = []\n        self.targetCapability = []\n        self.walletReference = []\n        self.ftVaultType = []\n        self.walletBalances = {}\n\n        var counter = 0\n        while counter \u003c users.length {\n            var resolveAddress : Address? = nil\n            if addresses[users[counter]] != nil {\n                resolveAddress = addresses[users[counter]]!\n            } else {\n                let address = FIND.resolve(users[counter])\n                if address == nil {\n                    panic(\"The address input is not a valid name nor address. Input : \".concat(users[counter]))\n                }\n                addresses[users[counter]] = address!\n                resolveAddress = address!\n            }\n            let address = resolveAddress!\n\n            var nft : NFTCatalog.NFTCollectionData? = nil\n            var ft : FTRegistry.FTInfo? = nil\n            let nftIdentifier = nftAliasOrIdentifiers[counter]\n            let ftIdentifier = ftAliasOrIdentifiers[counter]\n\n            if nfts[nftIdentifier] != nil {\n                nft = nfts[nftIdentifier]\n            } else {\n                let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier)) \n                let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n                nft = collection.collectionData\n                nfts[nftIdentifier] = nft\n            }\n\n            if fts[ftIdentifier] != nil {\n                ft = fts[ftIdentifier]\n            } else {\n                ft = FTRegistry.getFTInfo(ftIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftIdentifier))\n                fts[ftIdentifier] = ft \n            }\n        \n            self.ftVaultType.append(fts[ftIdentifier]!.type)\n\n\n            let pointer= FindViews.createViewReadPointer(address: address, path:nft!.publicPath, id: ids[counter])\n            self.pointer.append(pointer)\n\n            var targetCapability= account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(nft!.publicPath)\n\n            /* Check for nftCapability */\n            if !targetCapability.check() {\n                let cd = pointer.getNFTCollectionData()\n                // should use account.type here instead\n                if account.type(at: cd.storagePath) != nil {\n                    let pathIdentifier = nft!.publicPath.toString()\n                    let findPath = PublicPath(identifier: pathIdentifier.slice(from: \"/public/\".length , upTo: pathIdentifier.length).concat(\"_FIND\"))!\n                    account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                        findPath,\n                        target: nft!.storagePath\n                    )\n                    targetCapability = account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(findPath)\n                } else {\n                    account.save(\u003c- cd.createEmptyCollection(), to: cd.storagePath)\n                    account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.publicPath, target: cd.storagePath)\n                    account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.providerPath, target: cd.storagePath)\n                }\n\n            }\n            self.targetCapability.append(targetCapability)\n            counter = counter + 1\n        }\n    }\n\n    pre {\n        self.bidsReference != nil : \"This account does not have a bid collection\"\n    }\n\n    execute {\n        var counter = 0\n        while counter \u003c ids.length {\n            self.bidsReference!.bid(item:self.pointer[counter], amount: amounts[counter], vaultType: self.ftVaultType[counter], nftCap: self.targetCapability[counter], validUntil: validUntil, saleItemExtraField: {}, bidExtraField: {})\n            counter = counter + 1\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "users",
                     "nftAliasOrIdentifiers",
                     "ids",
                     "ftAliasOrIdentifiers",
                     "amounts",
                     "validUntil"
                  ],
                  "parameters": {
                     "amounts": "[UFix64]",
                     "ftAliasOrIdentifiers": "[String]",
                     "ids": "[UInt64]",
                     "marketplace": "Address",
                     "nftAliasOrIdentifiers": "[String]",
                     "users": "[String]",
                     "validUntil": "UFix64?"
                  }
               }
            },
            "bidName": {
               "code": "import FUSD from 0x3c5959b568896393\nimport FIND from 0x097bafa4e0b48eef\n\ntransaction(name: String, amount: UFix64) {\n\n    let vaultRef : \u0026FUSD.Vault?\n    let bidRef : \u0026FIND.BidCollection?\n\n    prepare(account: AuthAccount) {\n\n        self.vaultRef = account.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault)\n        self.bidRef = account.borrow\u003c\u0026FIND.BidCollection\u003e(from: FIND.BidStoragePath)\n    }\n\n    pre{\n        self.vaultRef != nil : \"Could not borrow reference to the fusdVault!\" \n        self.bidRef != nil : \"Could not borrow reference to the bid collection!\" \n    }\n\n    execute {\n        let vault \u003c- self.vaultRef!.withdraw(amount: amount) as! @FUSD.Vault\n        self.bidRef!.bid(name: name, vault: \u003c- vault)\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "name": "String"
                  }
               }
            },
            "burnNFTs": {
               "code": "import NonFungibleToken from 0x1d7e57aa55817448\nimport MetadataViews from 0x1d7e57aa55817448\nimport NFTCatalog from 0x49a7cda3a1eecc29\nimport FINDNFTCatalog from 0x097bafa4e0b48eef\nimport FindViews from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\nimport FindFurnace from 0x097bafa4e0b48eef\n\ntransaction(types: [String] , ids: [UInt64], messages: [String]) {\n\n    let authPointers : [FindViews.AuthNFTPointer]\n\n    prepare(account : AuthAccount) {\n\n        self.authPointers = []\n\n        let contractData : {Type : NFTCatalog.NFTCatalogMetadata} = {}\n\n\n        for i , typeIdentifier in types {\n            let type = CompositeType(typeIdentifier) ?? panic(\"Cannot refer to type with identifier : \".concat(typeIdentifier))\n\n            var data : NFTCatalog.NFTCatalogMetadata? = contractData[type]\n            if data == nil {\n                data = FINDNFTCatalog.getMetadataFromType(type) ?? panic(\"NFT Type is not supported by NFT Catalog. Type : \".concat(type.identifier))\n                contractData[type] = data\n            }\n\n            let path = data!.collectionData\n\n            var providerCap=account.getCapability\u003c\u0026{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e(path.privatePath)\n            if !providerCap.check() {\n                let newCap = account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                    path.privatePath,\n                    target: path.storagePath\n                )\n                if newCap == nil {\n                    // If linking is not successful, we link it using finds custom link \n                    let pathIdentifier = path.privatePath.toString()\n                    let findPath = PrivatePath(identifier: pathIdentifier.slice(from: \"/private/\".length , upTo: pathIdentifier.length).concat(\"_FIND\"))!\n                    account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                        findPath,\n                        target: path.storagePath\n                    )\n                    providerCap = account.getCapability\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(findPath)\n                }\n            }\n            let pointer = FindViews.AuthNFTPointer(cap: providerCap, id: ids[i])\n            self.authPointers.append(pointer)\n        }\n    }\n\n    execute {\n        let ctx : {String : String} = {\n            \"tenant\" : \"find\"\n        }\n        for i,  pointer in self.authPointers {\n            let id = ids[i] \n            ctx[\"message\"] = messages[i]\n\n            // burn thru furnace\n            FindFurnace.burn(pointer: pointer, context: ctx)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "types",
                     "ids",
                     "messages"
                  ],
                  "parameters": {
                     "ids": "[UInt64]",
                     "messages": "[String]",
                     "types": "[String]"
                  }
               }
            },
            "buyAddon": {
               "code": "import FUSD from 0x3c5959b568896393\nimport FIND from 0x097bafa4e0b48eef\n\n\ntransaction(name: String, addon:String, amount:UFix64) {\n\n    let leases : \u0026FIND.LeaseCollection?\n    let vaultRef : \u0026FUSD.Vault? \n\n    prepare(account: AuthAccount) {\n\n        self.leases= account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)\n        self.vaultRef = account.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault)\n\n    }\n\n    pre{\n        self.leases != nil : \"Could not borrow reference to the leases collection\"\n        self.vaultRef != nil : \"Could not borrow reference to the fusdVault!\"\n    }\n\n    execute {\n        let vault \u003c- self.vaultRef!.withdraw(amount: amount) as! @FUSD.Vault\n        self.leases!.buyAddon(name: name, addon: addon, vault: \u003c- vault)\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "addon",
                     "amount"
                  ],
                  "parameters": {
                     "addon": "String",
                     "amount": "UFix64",
                     "name": "String"
                  }
               }
            },
            "buyAddonDapper": {
               "code": "import DapperUtilityCoin from 0xead892083b3e2c6c\nimport FIND from 0x097bafa4e0b48eef\n\n\ntransaction(merchAccount: Address, name: String, addon:String, amount:UFix64) {\n\n    let finLeases : \u0026FIND.LeaseCollection\n    let mainDapperUtilityCoinVault: \u0026DapperUtilityCoin.Vault\n    let balanceBeforeTransfer: UFix64\n\n    prepare(dapper: AuthAccount, account: AuthAccount) {\n        self.mainDapperUtilityCoinVault = dapper.borrow\u003c\u0026DapperUtilityCoin.Vault\u003e(from: /storage/dapperUtilityCoinVault) ?? panic(\"Cannot borrow DapperUtilityCoin vault from account storage\".concat(dapper.address.toString()))\n        self.balanceBeforeTransfer = self.mainDapperUtilityCoinVault.balance\n        self.finLeases= account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath) ?? panic(\"Could not borrow reference to find lease collection\")\n\n    }\n\n    execute {\n        let vault \u003c- self.mainDapperUtilityCoinVault.withdraw(amount: amount) as! @DapperUtilityCoin.Vault\n        self.finLeases.buyAddonDapper(merchAccount: merchAccount, name: name, addon: addon, vault: \u003c- vault)\n    }\n\n    post {\n        self.mainDapperUtilityCoinVault.balance == self.balanceBeforeTransfer: \"DapperUtilityCoin leakage\"\n    }\n}",
               "spec": {
                  "order": [
                     "merchAccount",
                     "name",
                     "addon",
                     "amount"
                  ],
                  "parameters": {
                     "addon": "String",
                     "amount": "UFix64",
                     "merchAccount": "Address",
                     "name": "String"
                  }
               }
            },
            "buyFindPack": {
               "code": "import FindPack from 0x097bafa4e0b48eef\nimport FungibleToken from 0xf233dcee88fe0abe\nimport NonFungibleToken from 0x1d7e57aa55817448\nimport MetadataViews from 0x1d7e57aa55817448\nimport FlowToken from 0x1654653399040a61\nimport FUSD from 0x3c5959b568896393\nimport Profile from 0x097bafa4e0b48eef\n\ntransaction(packTypeName: String, packTypeId:UInt64, numberOfPacks:UInt64, totalAmount: UFix64) {\n    let packs: \u0026FindPack.Collection{FindPack.CollectionPublic}\n\n    let userPacks: Capability\u003c\u0026FindPack.Collection{NonFungibleToken.Receiver}\u003e\n    let salePrice: UFix64\n    let packsLeft: UInt64\n\n    let userFlowTokenVault: \u0026FlowToken.Vault\n\n    let paymentVault: @FungibleToken.Vault\n    let balanceBeforeTransfer:UFix64\n\n    prepare(account: AuthAccount) {\n\n        let findPackCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(FindPack.CollectionPublicPath)\n        if !findPackCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e( \u003c- FindPack.createEmptyCollection(), to: FindPack.CollectionStoragePath)\n            account.link\u003c\u0026FindPack.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                FindPack.CollectionPublicPath,\n                target: FindPack.CollectionStoragePath\n            )\n        }\n\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:account.address.toString(), createdAt: \"find\")\n\n            //Add exising FUSD or create a new one and add it\n            let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n            if !fusdReceiver.check() {\n                let fusd \u003c- FUSD.createEmptyVault()\n                account.save(\u003c- fusd, to: /storage/fusdVault)\n                account.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n                account.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n            }\n\n            let fusdWallet=Profile.Wallet(\n                name:\"FUSD\", \n                receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver),\n                balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance),\n                accept: Type\u003c@FUSD.Vault\u003e(),\n                names: [\"fusd\", \"stablecoin\"]\n            )\n\n            profile.addWallet(fusdWallet)\n\n            let flowWallet=Profile.Wallet(\n                name:\"Flow\", \n                receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver),\n                balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance),\n                accept: Type\u003c@FlowToken.Vault\u003e(),\n                names: [\"flow\"]\n            )\n            profile.addWallet(flowWallet)\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n\n\n        }\n\n        self.userPacks=account.getCapability\u003c\u0026FindPack.Collection{NonFungibleToken.Receiver}\u003e(FindPack.CollectionPublicPath)\n        self.packs=FindPack.getPacksCollection(packTypeName: packTypeName, packTypeId:packTypeId)\n\n        self.salePrice= FindPack.getCurrentPrice(packTypeName: packTypeName, packTypeId:packTypeId, user:account.address) ?? panic (\"Cannot buy the pack now\") \n        self.packsLeft= UInt64(self.packs.getPacksLeft())\n\n\n        self.userFlowTokenVault = account.borrow\u003c\u0026FlowToken.Vault\u003e(from: /storage/flowTokenVault) ?? panic(\"Cannot borrow FlowToken vault from account storage\")\n        self.balanceBeforeTransfer = self.userFlowTokenVault.balance\n\n        if self.balanceBeforeTransfer \u003c totalAmount {\n            panic(\"Your account does not have enough funds has \".concat(self.balanceBeforeTransfer.toString()).concat(\" needs \").concat(totalAmount.toString()))\n        }\n        self.paymentVault \u003c- self.userFlowTokenVault.withdraw(amount: totalAmount)\n    }\n\n    pre {\n        self.salePrice * UFix64(numberOfPacks) == totalAmount: \"unexpected sending amount\"\n        self.packsLeft \u003e= numberOfPacks : \"Rats! there are no packs left\"\n        self.userPacks.check() : \"User need a receiver to put the pack in\"\n    }\n\n    execute {\n        var counter = numberOfPacks\n        while counter \u003e 0 {\n            let purchasingVault \u003c- self.paymentVault.withdraw(amount: self.salePrice)\n            self.packs.buy(packTypeName: packTypeName, typeId:packTypeId, vault: \u003c- purchasingVault, collectionCapability: self.userPacks)\n            counter = counter - 1\n        }\n        if self.paymentVault.balance != 0.0 {\n            panic(\"paymentVault balance is non-zero after paying\")\n        }\n        destroy self.paymentVault\n    }\n\n}",
               "spec": {
                  "order": [
                     "packTypeName",
                     "packTypeId",
                     "numberOfPacks",
                     "totalAmount"
                  ],
                  "parameters": {
                     "numberOfPacks": "UInt64",
                     "packTypeId": "UInt64",
                     "packTypeName": "String",
                     "totalAmount": "UFix64"
                  }
               }
            },
            "buyFindPackWithReservation": {
               "code": "import FindPack from 0x097bafa4e0b48eef\nimport FungibleToken from 0xf233dcee88fe0abe\nimport NonFungibleToken from 0x1d7e57aa55817448\nimport MetadataViews from 0x1d7e57aa55817448\nimport FlowToken from 0x1654653399040a61\nimport FUSD from 0x3c5959b568896393\nimport Profile from 0x097bafa4e0b48eef\n\ntransaction(packTypeName: String, packTypeId:UInt64, packId: UInt64, amount: UFix64, signature:String) {\n    let packs: \u0026FindPack.Collection{FindPack.CollectionPublic}\n\n    let userPacks: Capability\u003c\u0026FindPack.Collection{NonFungibleToken.Receiver}\u003e\n    let salePrice: UFix64\n    let packsLeft: UInt64\n\n    let userFlowTokenVault: \u0026FlowToken.Vault\n\n    let paymentVault: @FungibleToken.Vault\n    let balanceBeforeTransfer:UFix64\n\n    prepare(account: AuthAccount) {\n\n        let findPackCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(FindPack.CollectionPublicPath)\n        if !findPackCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e( \u003c- FindPack.createEmptyCollection(), to: FindPack.CollectionStoragePath)\n            account.link\u003c\u0026FindPack.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                FindPack.CollectionPublicPath,\n                target: FindPack.CollectionStoragePath\n            )\n        }\n\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:account.address.toString(), createdAt: \"find\")\n\n            //Add exising FUSD or create a new one and add it\n            let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n            if !fusdReceiver.check() {\n                let fusd \u003c- FUSD.createEmptyVault()\n                account.save(\u003c- fusd, to: /storage/fusdVault)\n                account.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n                account.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n            }\n\n            let fusdWallet=Profile.Wallet(\n                name:\"FUSD\", \n                receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver),\n                balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance),\n                accept: Type\u003c@FUSD.Vault\u003e(),\n                names: [\"fusd\", \"stablecoin\"]\n            )\n\n            profile.addWallet(fusdWallet)\n\n            let flowWallet=Profile.Wallet(\n                name:\"Flow\", \n                receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver),\n                balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance),\n                accept: Type\u003c@FlowToken.Vault\u003e(),\n                names: [\"flow\"]\n            )\n            profile.addWallet(flowWallet)\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n\n\n        }\n\n        self.userPacks=account.getCapability\u003c\u0026FindPack.Collection{NonFungibleToken.Receiver}\u003e(FindPack.CollectionPublicPath)\n        self.packs=FindPack.getPacksCollection(packTypeName: packTypeName, packTypeId:packTypeId)\n\n        self.salePrice= FindPack.getCurrentPrice(packTypeName: packTypeName, packTypeId:packTypeId, user:account.address) ?? panic (\"Cannot buy the pack now\") \n\n        self.packsLeft= UInt64(self.packs.getPacksLeft())\n\n\n        self.userFlowTokenVault = account.borrow\u003c\u0026FlowToken.Vault\u003e(from: /storage/flowTokenVault) ?? panic(\"Cannot borrow FlowToken vault from account storage\")\n        self.balanceBeforeTransfer = self.userFlowTokenVault.balance\n\n        if self.balanceBeforeTransfer \u003c amount {\n            panic(\"Your account does not have enough funds has \".concat(self.balanceBeforeTransfer.toString()).concat(\" needs \").concat(amount.toString()))\n        }\n        self.paymentVault \u003c- self.userFlowTokenVault.withdraw(amount: amount)\n    }\n\n    pre {\n        self.salePrice == amount: \"unexpected sending amount\"\n        self.packs.contains(packId): \"The pack does not exist. ID : \".concat(packId.toString())\n        self.userPacks.check() : \"User need a receiver to put the pack in\"\n    }\n\n    execute {\n        self.packs.buyWithSignature(packId:packId, signature: signature, vault: \u003c- self.paymentVault, collectionCapability: self.userPacks)\n    }\n\n}",
               "spec": {
                  "order": [
                     "packTypeName",
                     "packTypeId",
                     "packId",
                     "amount",
                     "signature"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "packId": "UInt64",
                     "packTypeId": "UInt64",
                     "packTypeName": "String",
                     "signature": "String"
                  }
               }
            },
            "buyForSaleMultiple": {
               "code": "import FUSD from 0x3c5959b568896393\nimport FindMarket from 0x097bafa4e0b48eef\nimport FindMarketSale from 0x097bafa4e0b48eef\nimport NonFungibleToken from 0x1d7e57aa55817448\nimport MetadataViews from 0x1d7e57aa55817448\nimport NFTCatalog from 0x49a7cda3a1eecc29\nimport FINDNFTCatalog from 0x097bafa4e0b48eef\nimport FTRegistry from 0x097bafa4e0b48eef\nimport FungibleToken from 0xf233dcee88fe0abe\nimport FIND from 0x097bafa4e0b48eef\n\ntransaction(marketplace:Address, users: [Address], ids: [AnyStruct], amounts: [UFix64]) {\n\n    let targetCapability : [Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e]\n    var walletReference : [\u0026FungibleToken.Vault]\n\n    let saleItems: [\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}]\n    let leaseNames: [String]\n    let leaseBidReference: \u0026FIND.BidCollection\n    var totalPrice : UFix64\n    let prices : [UFix64]\n    let buyer : Address\n\n    prepare(account: AuthAccount) {\n\n        if users.length != ids.length {\n            panic(\"The array length of users and ids should be the same\")\n        }\n\n        var counter = 0\n        self.walletReference= []\n        self.targetCapability = []\n\n        self.saleItems = []\n        let nfts : {String : NFTCatalog.NFTCollectionData} = {}\n        let fts : {String : FTRegistry.FTInfo} = {}\n        let saleItems : {Address : \u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}} = {}\n\n        let saleItemType = Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let marketOption = FindMarket.getMarketOptionFromType(saleItemType)\n\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath)\n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        self.buyer = account.address\n        self.leaseNames = []\n        self.leaseBidReference = account.borrow\u003c\u0026FIND.BidCollection\u003e(from: FIND.BidStoragePath) ?? panic(\"Could not borrow reference to the bid collection!\" )\n\n        var vaultType : Type? = nil\n\n        self.totalPrice = 0.0\n        self.prices = []\n\n        while counter \u003c users.length {\n\n            let address=users[counter]\n\n            if let name = ids[counter] as? String {\n                let targetAddress = FIND.lookupAddress(name) ?? panic(\"Cannot look up address for name : \".concat(name))\n                let leaseCap = getAccount(targetAddress).getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n                let leaseRef = leaseCap.borrow() ?? panic(\"Cannot borrow reference from name owner. Name : \".concat(name))\n                let nameInfo = leaseRef.getLease(name)!\n                let price = nameInfo.salePrice ?? panic(\"Name is not listed for sale. Name : \".concat(name))\n                self.prices.append(price)\n                self.leaseNames.append(name)\n\n                self.walletReference.append(\n                    account.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault) ?? panic(\"No suitable wallet linked for this account\")\n                )\n            }\n\n            if let id = ids[counter] as? UInt64 {\n                if saleItems[address] == nil {\n                    let saleItem = getAccount(address).getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath).borrow() ?? panic(\"cannot find target sale item cap. ID : \".concat(id.toString()))\n                    self.saleItems.append(saleItem)\n                    saleItems[address] = saleItem\n                } else {\n                    self.saleItems.append(saleItems[address]!)\n                }\n\n                let item=saleItems[address]!.borrowSaleItem(id)\n\n                self.prices.append(item.getBalance())\n                self.totalPrice = self.totalPrice + self.prices[counter]\n\n                var nft : NFTCatalog.NFTCollectionData? = nil\n                var ft : FTRegistry.FTInfo? = nil\n                let nftIdentifier = item.getItemType().identifier\n                let ftIdentifier = item.getFtType().identifier\n\n                if nfts[nftIdentifier] != nil {\n                    nft = nfts[nftIdentifier]\n                } else {\n                    let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier))\n                    let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])!\n                    nft = collection.collectionData\n                    nfts[nftIdentifier] = nft\n                }\n\n                if fts[ftIdentifier] != nil {\n                    ft = fts[ftIdentifier]\n                } else {\n                    ft = FTRegistry.getFTInfo(ftIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftIdentifier))\n                    fts[ftIdentifier] = ft\n                }\n\n                self.walletReference.append(\n                    account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft!.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n                )\n\n                var targetCapability= account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(nft!.publicPath)\n                /* Check for nftCapability */\n                if !targetCapability.check() {\n                    let cd = item.getNFTCollectionData()\n                    // should use account.type here instead\n                    if account.type(at: cd.storagePath) != nil {\n                        let pathIdentifier = nft!.publicPath.toString()\n                        let findPath = PublicPath(identifier: pathIdentifier.slice(from: \"/public/\".length , upTo: pathIdentifier.length).concat(\"_FIND\"))!\n                        account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                            findPath,\n                            target: nft!.storagePath\n                        )\n                        targetCapability = account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(findPath)\n                    } else {\n                        account.save(\u003c- cd.createEmptyCollection(), to: cd.storagePath)\n                        account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.publicPath, target: cd.storagePath)\n                        account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.providerPath, target: cd.storagePath)\n                    }\n\n                }\n                self.targetCapability.append(targetCapability)\n            }\n            counter = counter + 1\n        }\n\n\n    }\n\n    execute {\n        var counter = 0\n        var nameCounter = 0\n        for i, input in ids {\n\n            if let name = input as? String {\n                if self.prices[i] != amounts[i] {\n                    panic(\"Please pass in the correct price of the name. Required : \".concat(self.prices[i].toString()).concat(\" . Name : \".concat(name)))\n                }\n                if self.walletReference[i].balance \u003c amounts[i] {\n                    panic(\"Your wallet does not have enough funds to pay for this name. Required : \".concat(self.prices[i].toString()).concat(\" . Name : \".concat(name)))\n                }\n\n                let vault \u003c- self.walletReference[i].withdraw(amount: self.prices[i]) as! @FUSD.Vault\n                self.leaseBidReference.bid(name: name, vault: \u003c- vault)\n                nameCounter = nameCounter + 1\n                continue\n            }\n\n            let id = input as! UInt64\n            if self.prices[i] != amounts[i] {\n                panic(\"Please pass in the correct price of the buy items. Required : \".concat(self.prices[i].toString()).concat(\" . saleItem ID : \".concat(id.toString())))\n            }\n            if self.walletReference[i].balance \u003c amounts[i] {\n                panic(\"Your wallet does not have enough funds to pay for this item. Required : \".concat(self.prices[i].toString()).concat(\" . saleItem ID : \".concat(id.toString())))\n            }\n\n            self.saleItems[counter].buy(id:id, vault: \u003c- self.walletReference[i].withdraw(amount: amounts[i])\n            , nftCap: self.targetCapability[counter])\n            counter = counter + 1\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "users",
                     "ids",
                     "amounts"
                  ],
                  "parameters": {
                     "amounts": "[UFix64]",
                     "ids": "[AnyStruct]",
                     "marketplace": "Address",
                     "users": "[Address]"
                  }
               }
            },
            "buyLeaseForSale": {
               "code": "import FindMarket from 0x097bafa4e0b48eef\nimport FTRegistry from 0x097bafa4e0b48eef\nimport FungibleToken from 0xf233dcee88fe0abe\nimport FIND from 0x097bafa4e0b48eef\nimport FindLeaseMarketSale from 0x097bafa4e0b48eef\nimport FindLeaseMarket from 0x097bafa4e0b48eef\n\ntransaction(leaseName: String, amount: UFix64) {\n\n    let walletReference : \u0026FungibleToken.Vault\n\n    let saleItemsCap: Capability\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e\n    let buyer: Address\n\n    prepare(account: AuthAccount) {\n\n        let resolveAddress = FIND.resolve(leaseName)\n        if resolveAddress == nil {\n            panic(\"The address input is not a valid name nor address. Input : \".concat(leaseName))\n        }\n        let address = resolveAddress!\n        let leaseMarketplace = FindMarket.getFindTenantAddress()\n        let leaseTenantCapability= FindMarket.getTenantCapability(leaseMarketplace)!\n        let leaseTenant = leaseTenantCapability.borrow()!\n\n        let leaseSaleItemType= Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()\n        let leasePublicPath=leaseTenant.getPublicPath(leaseSaleItemType)\n        let leaseStoragePath= leaseTenant.getStoragePath(leaseSaleItemType)\n        let leaseSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath)\n        if !leaseSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketSale.SaleItemCollection\u003e(\u003c- FindLeaseMarketSale.createEmptySaleItemCollection(leaseTenantCapability), to: leaseStoragePath)\n            account.link\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath, target: leaseStoragePath)\n        }\n\n        self.saleItemsCap= getAccount(address).getCapability\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath)\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e())\n\n        let item= FindLeaseMarket.assertOperationValid(tenant: leaseMarketplace, name: leaseName, marketOption: marketOption)\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n\n        self.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n        self.buyer = account.address\n    }\n\n    pre {\n        self.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount)\n        self.saleItemsCap.borrow()!.buy(name:leaseName, vault: \u003c- vault, to: self.buyer)\n    }\n}",
               "spec": {
                  "order": [
                     "leaseName",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "leaseName": "String"
                  }
               }
            },
            "buyLeaseForSaleDapper": {
               "code": "import FindMarket from 0x097bafa4e0b48eef\nimport FTRegistry from 0x097bafa4e0b48eef\nimport FungibleToken from 0xf233dcee88fe0abe\nimport FIND from 0x097bafa4e0b48eef\nimport Profile from 0x097bafa4e0b48eef\nimport FindLeaseMarketSale from 0x097bafa4e0b48eef\nimport FindLeaseMarket from 0x097bafa4e0b48eef\n\ntransaction(sellerAccount: Address, leaseName: String, amount: UFix64) {\n\n    let to : Address\n    let walletReference : \u0026FungibleToken.Vault\n\n    let saleItemCollection: \u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\n    let balanceBeforeTransfer: UFix64\n\n    prepare(dapper: AuthAccount, account: AuthAccount) {\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath) ?? panic(\"You do not have a profile set up, initialize the user first\")\n\n        let address = FIND.resolve(leaseName) ?? panic(\"The address input is not a valid name nor address. Input : \".concat(leaseName))\n\n        if address != sellerAccount {\n            panic(\"address does not resolve to seller\")\n        }\n\n        let leaseMarketplace = FindMarket.getTenantAddress(\"find\") ?? panic(\"Cannot find find tenant\")\n        let saleItemsCap= FindLeaseMarketSale.getSaleItemCapability(marketplace: leaseMarketplace, user:address) ?? panic(\"cannot find sale item cap for find\")\n\n        let leaseTenantCapability= FindMarket.getTenantCapability(leaseMarketplace)!\n        let leaseTenant = leaseTenantCapability.borrow()!\n\n        let leaseSaleItemType= Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()\n        let leasePublicPath=FindMarket.getPublicPath(leaseSaleItemType, name: \"find\")\n        let leaseStoragePath= FindMarket.getStoragePath(leaseSaleItemType, name:\"find\")\n        let leaseSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath)\n        if !leaseSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketSale.SaleItemCollection\u003e(\u003c- FindLeaseMarketSale.createEmptySaleItemCollection(leaseTenantCapability), to: leaseStoragePath)\n            account.link\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath, target: leaseStoragePath)\n        }\n\n        self.to= account.address\n\n        self.saleItemCollection = saleItemsCap.borrow()!\n        let item = self.saleItemCollection.borrowSaleItem(leaseName)\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n        self.walletReference = dapper.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n        self.balanceBeforeTransfer = self.walletReference.balance\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount)\n        self.saleItemCollection.buy(name:leaseName, vault: \u003c- vault, to: self.to)\n    }\n\n    // Check that all dapper Coin was routed back to Dapper\n    post {\n        self.walletReference.balance == self.balanceBeforeTransfer: \"Dapper Coin leakage\"\n    }\n}",
               "spec": {
                  "order": [
                     "sellerAccount",
                     "leaseName",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "leaseName": "String",
                     "sellerAccount": "Address"
                  }
               }
            },
            "buyMultipleNFTForSale": {
               "code": "import FindMarket from 0x097bafa4e0b48eef\nimport FindMarketSale from 0x097bafa4e0b48eef\nimport NonFungibleToken from 0x1d7e57aa55817448\nimport MetadataViews from 0x1d7e57aa55817448\nimport NFTCatalog from 0x49a7cda3a1eecc29\nimport FINDNFTCatalog from 0x097bafa4e0b48eef\nimport FTRegistry from 0x097bafa4e0b48eef\nimport FungibleToken from 0xf233dcee88fe0abe\n\ntransaction(marketplace:Address, users: [Address], ids: [UInt64], amounts: [UFix64]) {\n\n    let targetCapability : [Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e]\n    var walletReference : [\u0026FungibleToken.Vault]\n\n    let saleItems: [\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}]\n    var totalPrice : UFix64\n    let prices : [UFix64]\n    prepare(account: AuthAccount) {\n\n        if users.length != ids.length {\n            panic(\"The array length of users and ids should be the same\")\n        }\n\n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n\n        var counter = 0\n        self.walletReference= []\n        self.targetCapability = []\n\n        self.saleItems = []\n        let nfts : {String : NFTCatalog.NFTCollectionData} = {}\n        let fts : {String : FTRegistry.FTInfo} = {}\n        let saleItems : {Address : \u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}} = {}\n\n        let saleItemType = Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let marketOption = FindMarket.getMarketOptionFromType(saleItemType)\n\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        var vaultType : Type? = nil\n\n        self.totalPrice = 0.0\n        self.prices = []\n\n        while counter \u003c users.length {\n\n            let address=users[counter]\n\n            if saleItems[address] == nil {\n                let saleItem = getAccount(address).getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath).borrow() ?? panic(\"cannot find sale item cap\")\n                self.saleItems.append(saleItem)\n                saleItems[address] = saleItem \n            } else {\n                self.saleItems.append(saleItems[address]!)\n            }\n\n\n            // let item= FindMarket.assertOperationValid(tenant: marketplace, address: address, marketOption: marketOption, id: ids[counter])\n            let item=saleItems[address]!.borrowSaleItem(ids[counter])\n\n            self.prices.append(item.getBalance())\n            self.totalPrice = self.totalPrice + self.prices[counter]\n\n            var nft : NFTCatalog.NFTCollectionData? = nil\n            var ft : FTRegistry.FTInfo? = nil\n            let nftIdentifier = item.getItemType().identifier\n            let ftIdentifier = item.getFtType().identifier\n\n            if nfts[nftIdentifier] != nil {\n                nft = nfts[nftIdentifier]\n            } else {\n                let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier)) \n                let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n                nft = collection.collectionData\n                nfts[nftIdentifier] = nft\n            }\n\n            if fts[ftIdentifier] != nil {\n                ft = fts[ftIdentifier]\n            } else {\n                ft = FTRegistry.getFTInfo(ftIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftIdentifier))\n                fts[ftIdentifier] = ft \n            }\n\n            self.walletReference.append(\n                account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft!.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n            )\n\n            var targetCapability= account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(nft!.publicPath)\n            /* Check for nftCapability */\n            if !targetCapability.check() {\n                let cd = item.getNFTCollectionData()\n                // should use account.type here instead\n                if account.type(at: cd.storagePath) != nil {\n                    let pathIdentifier = nft!.publicPath.toString()\n                    let findPath = PublicPath(identifier: pathIdentifier.slice(from: \"/public/\".length , upTo: pathIdentifier.length).concat(\"_FIND\"))!\n                    account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                        findPath,\n                        target: nft!.storagePath\n                    )\n                    targetCapability = account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(findPath)\n                } else {\n                    account.save(\u003c- cd.createEmptyCollection(), to: cd.storagePath)\n                    account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.publicPath, target: cd.storagePath)\n                    account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.providerPath, target: cd.storagePath)\n                }\n\n            }\n            self.targetCapability.append(targetCapability)\n            counter = counter + 1\n        }\n\n\n    }\n\n    execute {\n        var counter = 0\n        while counter \u003c users.length {\n            if self.prices[counter] != amounts[counter] {\n                panic(\"Please pass in the correct price of the buy items. Required : \".concat(self.prices[counter].toString()).concat(\" . saleItem ID : \".concat(ids[counter].toString())))\n            }\n            if self.walletReference[counter].balance \u003c amounts[counter] {\n                panic(\"Your wallet does not have enough funds to pay for this item. Required : \".concat(self.prices[counter].toString()).concat(\" . saleItem ID : \".concat(ids[counter].toString())))\n            }\n\n            self.saleItems[counter].buy(id:ids[counter], vault: \u003c- self.walletReference[counter].withdraw(amount: amounts[counter]) \n            , nftCap: self.targetCapability[counter])\n            counter = counter + 1\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "users",
                     "ids",
                     "amounts"
                  ],
                  "parameters": {
                     "amounts": "[UFix64]",
                     "ids": "[UInt64]",
                     "marketplace": "Address",
                     "users": "[Address]"
                  }
               }
            },
            "buyMultipleNFTForSaleDapper": {
               "code": "import FindMarket from 0x097bafa4e0b48eef\nimport FindMarketSale from 0x097bafa4e0b48eef\nimport NonFungibleToken from 0x1d7e57aa55817448\nimport MetadataViews from 0x1d7e57aa55817448\nimport NFTCatalog from 0x49a7cda3a1eecc29\nimport FINDNFTCatalog from 0x097bafa4e0b48eef\nimport FTRegistry from 0x097bafa4e0b48eef\nimport FungibleToken from 0xf233dcee88fe0abe\n\ntransaction(marketplace:Address, users: [Address], ids: [UInt64], amounts: [UFix64]) {\n\n    let targetCapability : [Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e]\n    var walletReference : [\u0026FungibleToken.Vault]\n    let walletBalance : {Type : UFix64}\n\n    let saleItems: [\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}]\n    var totalPrice : UFix64\n    let prices : [UFix64]\n    prepare(dapper: AuthAccount, account: AuthAccount) {\n\n        if users.length != ids.length {\n            panic(\"The array length of users and ids should be the same\")\n        }\n\n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n\n        var counter = 0\n        self.walletReference= []\n        self.targetCapability = []\n        self.walletBalance = {}\n\n        self.saleItems = []\n        let nfts : {String : NFTCatalog.NFTCollectionData} = {}\n        let fts : {String : FTRegistry.FTInfo} = {}\n        let saleItems : {Address : \u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}} = {}\n\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketSale.SaleItemCollection\u003e())\n\n        let saleItemType = Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath)\n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n        var vaultType : Type? = nil\n\n        self.totalPrice = 0.0\n        self.prices = []\n\n        while counter \u003c users.length {\n\n            let address=users[counter]\n\n            if saleItems[address] == nil {\n                let saleItem = getAccount(address).getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath).borrow() ?? panic(\"cannot find sale item cap\")\n                self.saleItems.append(saleItem)\n                saleItems[address] = saleItem\n            } else {\n                self.saleItems.append(saleItems[address]!)\n            }\n\n\n            // let item= FindMarket.assertOperationValid(tenant: marketplace, address: address, marketOption: marketOption, id: ids[counter])\n            let item=saleItems[address]!.borrowSaleItem(ids[counter])\n\n            self.prices.append(item.getBalance())\n            self.totalPrice = self.totalPrice + self.prices[counter]\n\n            var nft : NFTCatalog.NFTCollectionData? = nil\n            var ft : FTRegistry.FTInfo? = nil\n            let nftIdentifier = item.getItemType().identifier\n            let ftIdentifier = item.getFtType().identifier\n\n            if nfts[nftIdentifier] != nil {\n                nft = nfts[nftIdentifier]\n            } else {\n                let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier))\n                let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])!\n                nft = collection.collectionData\n                nfts[nftIdentifier] = nft\n            }\n\n            if fts[ftIdentifier] != nil {\n                ft = fts[ftIdentifier]\n            } else {\n                ft = FTRegistry.getFTInfo(ftIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftIdentifier))\n                fts[ftIdentifier] = ft\n            }\n\n            let dapperVault = dapper.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft!.vaultPath) ?? panic(\"Cannot borrow Dapper Coin Vault : \".concat(ft!.type.identifier))\n\n            self.walletReference.append(\n                dapperVault\n            )\n\n            if self.walletBalance[dapperVault.getType()] == nil {\n                self.walletBalance[dapperVault.getType()] = dapperVault.balance\n            }\n\n            var targetCapability= account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(nft!.publicPath)\n            /* Check for nftCapability */\n            if !targetCapability.check() {\n                let cd = item.getNFTCollectionData()\n                // should use account.type here instead\n                if account.type(at: cd.storagePath) != nil {\n                    let pathIdentifier = nft!.publicPath.toString()\n                    let findPath = PublicPath(identifier: pathIdentifier.slice(from: \"/public/\".length , upTo: pathIdentifier.length).concat(\"_FIND\"))!\n                    account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                        findPath,\n                        target: nft!.storagePath\n                    )\n                    targetCapability = account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(findPath)\n                } else {\n                    account.save(\u003c- cd.createEmptyCollection(), to: cd.storagePath)\n                    account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.publicPath, target: cd.storagePath)\n                    account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.providerPath, target: cd.storagePath)\n                }\n\n            }\n            self.targetCapability.append(targetCapability)\n            counter = counter + 1\n        }\n\n\n    }\n\n    execute {\n        var counter = 0\n        while counter \u003c users.length {\n            if self.prices[counter] != amounts[counter] {\n                panic(\"Please pass in the correct price of the buy items. Required : \".concat(self.prices[counter].toString()).concat(\" . saleItem ID : \".concat(ids[counter].toString())))\n            }\n            if self.walletReference[counter].balance \u003c amounts[counter] {\n                panic(\"Your wallet does not have enough funds to pay for this item. Required : \".concat(self.prices[counter].toString()).concat(\" . saleItem ID : \".concat(ids[counter].toString())))\n            }\n\n            self.saleItems[counter].buy(id:ids[counter], vault: \u003c- self.walletReference[counter].withdraw(amount: amounts[counter]) , nftCap: self.targetCapability[counter])\n            counter = counter + 1\n        }\n\n        // post\n        for vault in self.walletReference {\n            if vault.balance != self.walletBalance[vault.getType()] {\n                panic(\"Dapper Coin Leakage : \".concat(vault.getType().identifier))\n            }\n        }\n    }\n\n\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "users",
                     "ids",
                     "amounts"
                  ],
                  "parameters": {
                     "amounts": "[UFix64]",
                     "ids": "[UInt64]",
                     "marketplace": "Address",
                     "users": "[Address]"
                  }
               }
            },
            "buyNFTForSale": {
               "code": "import FindMarket from 0x097bafa4e0b48eef\nimport FindMarketSale from 0x097bafa4e0b48eef\nimport NonFungibleToken from 0x1d7e57aa55817448\nimport MetadataViews from 0x1d7e57aa55817448\nimport FINDNFTCatalog from 0x097bafa4e0b48eef\nimport FTRegistry from 0x097bafa4e0b48eef\nimport FungibleToken from 0xf233dcee88fe0abe\nimport FIND from 0x097bafa4e0b48eef\ntransaction(marketplace:Address, user: String, id: UInt64, amount: UFix64) {\n\n    var targetCapability : Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e\n    let walletReference : \u0026FungibleToken.Vault\n\n    let saleItemsCap: Capability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic}\u003e\n\n    prepare(account: AuthAccount) {\n\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath)\n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        let resolveAddress = FIND.resolve(user)\n        if resolveAddress == nil {\n            panic(\"The address input is not a valid name nor address. Input : \".concat(user))\n        }\n        let address = resolveAddress!\n        self.saleItemsCap= FindMarketSale.getSaleItemCapability(marketplace: marketplace, user:address) ?? panic(\"cannot find sale item cap\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketSale.SaleItem\u003e())\n\n        let item= FindMarket.assertOperationValid(tenant: marketplace, address: address, marketOption: marketOption, id: id)\n\n        let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: item.getItemType().identifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(item.getItemType().identifier))\n        let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])!\n        let nft = collection.collectionData\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n\n        self.targetCapability= account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(nft.publicPath)\n        /* Check for nftCapability */\n        if !self.targetCapability.check() {\n            let cd = item.getNFTCollectionData()\n            // should use account.type here instead\n            if account.type(at: cd.storagePath) != nil {\n                let pathIdentifier = nft.publicPath.toString()\n                let findPath = PublicPath(identifier: pathIdentifier.slice(from: \"/public/\".length , upTo: pathIdentifier.length).concat(\"_FIND\"))!\n                account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                    findPath,\n                    target: nft.storagePath\n                )\n                self.targetCapability = account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(findPath)\n            } else {\n                account.save(\u003c- cd.createEmptyCollection(), to: cd.storagePath)\n                account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.publicPath, target: cd.storagePath)\n                account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.providerPath, target: cd.storagePath)\n            }\n\n        }\n\n        self.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n    }\n\n    pre {\n        self.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount)\n        self.saleItemsCap.borrow()!.buy(id:id, vault: \u003c- vault, nftCap: self.targetCapability)\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "user",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64",
                     "marketplace": "Address",
                     "user": "String"
                  }
               }
            },
            "buyNFTForSaleDapper": {
               "code": "import FindMarket from 0x097bafa4e0b48eef\nimport Profile from 0x097bafa4e0b48eef\nimport FindMarketSale from 0x097bafa4e0b48eef\nimport NFTCatalog from 0x49a7cda3a1eecc29\nimport FINDNFTCatalog from 0x097bafa4e0b48eef\nimport FTRegistry from 0x097bafa4e0b48eef\nimport NonFungibleToken from 0x1d7e57aa55817448\nimport MetadataViews from 0x1d7e57aa55817448\nimport FungibleToken from 0xf233dcee88fe0abe\nimport DapperStorageRent from 0xa08e88e23f332538\nimport TopShot from 0x0b2a3299cc857e29\n\n//first argument is the address to the merchant that gets the funds\ntransaction(address: Address, marketplace:Address, id: UInt64, amount: UFix64) {\n\n    let targetCapability : Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e\n    let walletReference : \u0026FungibleToken.Vault\n    let receiver : Address\n\n    let saleItemsCap: Capability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic}\u003e\n    let balanceBeforeTransfer: UFix64\n    prepare(dapper: AuthAccount, account: AuthAccount) {\n        self.receiver=account.address\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath)\n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        self.saleItemsCap= FindMarketSale.getSaleItemCapability(marketplace: marketplace, user:address) ?? panic(\"cannot find sale item cap\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketSale.SaleItemCollection\u003e())\n\n        //we do some security check to verify that this tenant can do this operation. This will ensure that the onefootball tenant can only sell using DUC and not some other token. But we can change this with transactions later and not have to modify code/transactions\n        let item= FindMarket.assertOperationValid(tenant: marketplace, address: address, marketOption: marketOption, id: id)\n           let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: item.getItemType().identifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(item.getItemType().identifier))\n        let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])!\n        let nft = collection.collectionData\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n\n        self.targetCapability= account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(nft.publicPath)\n\n        if !self.targetCapability.check() {\n            let cd = item.getNFTCollectionData()\n            if let storage = account.borrow\u003c\u0026AnyResource\u003e(from: cd.storagePath) {\n                if let st = account.borrow\u003c\u0026TopShot.Collection\u003e(from: cd.storagePath) {\n                    // here means the topShot is not linked in the way it should be. We can relink that for our use\n                    account.unlink(cd.publicPath)\n                    account.link\u003c\u0026TopShot.Collection{TopShot.MomentCollectionPublic,NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}\u003e(cd.publicPath, target: cd.storagePath)\n                } else {\n                    panic(\"This collection public link is not set up properly.\")\n                }\n            } else {\n                account.save(\u003c- cd.createEmptyCollection(), to: cd.storagePath)\n                account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.publicPath, target: cd.storagePath)\n                account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.providerPath, target: cd.storagePath)\n            }\n        }\n\n        self.walletReference = dapper.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n        self.balanceBeforeTransfer = self.walletReference.balance\n    }\n\n    pre {\n        self.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount)\n        self.saleItemsCap.borrow()!.buy(id:id, vault: \u003c- vault, nftCap: self.targetCapability)\n        DapperStorageRent.tryRefill(self.receiver)\n    }\n\n    // Check that all dapper Coin was routed back to Dapper\n    post {\n        self.walletReference.balance == self.balanceBeforeTransfer: \"Dapper Coin leakage\"\n    }\n}",
               "spec": {
                  "order": [
                     "address",
                     "marketplace",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "address": "Address",
                     "amount": "UFix64",
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "cancelAllLeaseMarketAuctionSoft": {
               "code": "import FindMarket from 0x097bafa4e0b48eef\nimport FindLeaseMarketAuctionSoft from 0x097bafa4e0b48eef\n\ntransaction() {\n\n    let saleItems : \u0026FindLeaseMarketAuctionSoft.SaleItemCollection?\n\n    prepare(account: AuthAccount) {\n        let leaseMarketplace = FindMarket.getFindTenantAddress()\n        let tenant = FindMarket.getTenant(leaseMarketplace)\n        self.saleItems= account.borrow\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e()))\n\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to the saleItem.\"\n    }\n\n    execute {\n        let leaseNames = self.saleItems!.getNameSales()\n        for lease in leaseNames {\n            self.saleItems!.cancel(lease)\n        }\n    }\n}",
               "spec": {
                  "order": [],
                  "parameters": {}
               }
            },
            "cancelAllLeaseMarketDirectOfferSoft": {
               "code": "import FindMarket from 0x097bafa4e0b48eef\nimport FindLeaseMarketDirectOfferSoft from 0x097bafa4e0b48eef\n\ntransaction() {\n\n    let saleItems : \u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection?\n\n    prepare(account: AuthAccount) {\n\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenant=FindMarket.getTenant(marketplace)\n        self.saleItems= account.borrow\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e()))\n\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to saleItem.\"\n    }\n\n    execute{\n        let nameLeases = self.saleItems!.getNameSales()\n        for nameLease in nameLeases {\n            self.saleItems!.cancel(nameLease)\n        }\n    }\n\n}",
               "spec": {
                  "order": [],
                  "parameters": {}
               }
            },
            "cancelAllMarketAuctionEscrowed": {
               "code": "import FindMarket from 0x097bafa4e0b48eef\nimport FindMarketAuctionEscrow from 0x097bafa4e0b48eef\n\ntransaction(marketplace:Address) {\n\n    let saleItems : \u0026FindMarketAuctionEscrow.SaleItemCollection?\n\n    prepare(account: AuthAccount) {\n        let tenant = FindMarket.getTenant(marketplace)\n        self.saleItems= account.borrow\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()))\n\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to the saleItem capability.\"\n    }\n\n    execute {\n        let ids = self.saleItems!.getIds()\n        for id in ids {\n            self.saleItems!.cancel(id)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace"
                  ],
                  "parameters": {
                     "marketplace": "Address"
                  }
               }
            },
            "cancelAllMarketAuctionSoft": {
               "code": "import FindMarket from 0x097bafa4e0b48eef\nimport FindMarketAuctionSoft from 0x097bafa4e0b48eef\n\ntransaction(marketplace:Address) {\n\n    let saleItems : \u0026FindMarketAuctionSoft.SaleItemCollection?\n\n    prepare(account: AuthAccount) {\n        let tenant = FindMarket.getTenant(marketplace)\n        self.saleItems= account.borrow\u003c\u0026FindMarketAuctionSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()))\n\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to the saleItem.\"\n    }\n\n    execute {\n        let ids = self.saleItems!.getIds()\n        for id in ids {\n            self.saleItems!.cancel(id)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace"
                  ],
                  "parameters": {
                     "marketplace": "Address"
                  }
               }
            },
            "cancelAllMarketDirectOfferEscrowed": {
               "code": "import FindMarket from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferEscrow from 0x097bafa4e0b48eef\n\ntransaction(marketplace:Address) {\n\n    let saleItems : \u0026FindMarketDirectOfferEscrow.SaleItemCollection?\n\n    prepare(account: AuthAccount) {\n\n        let tenant=FindMarket.getTenant(marketplace)\n        self.saleItems= account.borrow\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()))\n\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to saleItem.\"\n    }\n\n    execute{\n        let ids = self.saleItems!.getIds()\n        for id in ids {\n            self.saleItems!.cancel(id)\n        }\n    }\n\n}",
               "spec": {
                  "order": [
                     "marketplace"
                  ],
                  "parameters": {
                     "marketplace": "Address"
                  }
               }
            },
            "cancelAllMarketDirectOfferSoft": {
               "code": "import FindMarket from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferSoft from 0x097bafa4e0b48eef\n\ntransaction(marketplace:Address) {\n\n    let saleItems : \u0026FindMarketDirectOfferSoft.SaleItemCollection?\n\n    prepare(account: AuthAccount) {\n\n        let tenant=FindMarket.getTenant(marketplace)\n        self.saleItems= account.borrow\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()))\n\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to saleItem.\"\n    }\n\n    execute{\n        let ids = self.saleItems!.getIds()\n        for id in ids {\n            self.saleItems!.cancel(id)\n        }\n    }\n\n}",
               "spec": {
                  "order": [
                     "marketplace"
                  ],
                  "parameters": {
                     "marketplace": "Address"
                  }
               }
            },
            "cancelAllMarketListings": {
               "code": "import FindMarket from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferEscrow from 0x097bafa4e0b48eef\nimport FindMarketAuctionEscrow from 0x097bafa4e0b48eef\nimport FindMarketAuctionSoft from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferSoft from 0x097bafa4e0b48eef\nimport FindMarketSale from 0x097bafa4e0b48eef\n\ntransaction(marketplace:Address) {\n    prepare(account: AuthAccount) {\n\n        let tenant=FindMarket.getTenant(marketplace)\n\n        if let saleItems= account.borrow\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e())) {\n            var ids = saleItems.getIds()\n            for id in ids {\n                saleItems.cancel(id)\n            }\n        }\n\n        if let saleItem2= account.borrow\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e())) {\n            var ids = saleItem2.getIds()\n            for id in ids {\n                saleItem2.cancel(id)\n            }\n        }\n\n        if let saleItems3= account.borrow\u003c\u0026FindMarketAuctionSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e())) {\n            var ids = saleItems3.getIds()\n            for id in ids {\n                saleItems3.cancel(id)\n            }\n        }\n\n        if let saleItems4= account.borrow\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e())) {\n            var ids = saleItems4.getIds()\n            for id in ids {\n                saleItems4.cancel(id)\n            }\n        }\n\n        if let saleItems5= account.borrow\u003c\u0026FindMarketSale.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketSale.SaleItemCollection\u003e())) {\n            var ids = saleItems5.getIds()\n            for id in ids {\n                saleItems5.delist(id)\n            }\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace"
                  ],
                  "parameters": {
                     "marketplace": "Address"
                  }
               }
            },
            "cancelLeaseMarketAuctionSoft": {
               "code": "import FindMarket from 0x097bafa4e0b48eef\nimport FindLeaseMarketAuctionSoft from 0x097bafa4e0b48eef\n\ntransaction(leaseNames: [String]) {\n\n    let saleItems : \u0026FindLeaseMarketAuctionSoft.SaleItemCollection?\n\n    prepare(account: AuthAccount) {\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenant=FindMarket.getTenant(marketplace)\n        self.saleItems= account.borrow\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e()))\n    }\n\n    pre{\n        self.saleItems != nil\n    }\n\n    execute{\n        for leaseName in leaseNames {\n            self.saleItems!.cancel(leaseName)\n        }\n    }\n\n}",
               "spec": {
                  "order": [
                     "leaseNames"
                  ],
                  "parameters": {
                     "leaseNames": "[String]"
                  }
               }
            },
            "cancelLeaseMarketDirectOfferSoft": {
               "code": "import FindMarket from 0x097bafa4e0b48eef\nimport FindLeaseMarketDirectOfferSoft from 0x097bafa4e0b48eef\n\ntransaction(leaseNames: [String]) {\n\n    let saleItems : \u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection?\n\n    prepare(account: AuthAccount) {\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenant=FindMarket.getTenant(marketplace)\n        self.saleItems= account.borrow\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e()))\n\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute {\n        for leaseName in leaseNames {\n            self.saleItems!.cancel(leaseName)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "leaseNames"
                  ],
                  "parameters": {
                     "leaseNames": "[String]"
                  }
               }
            },
            "cancelMarketAuctionEscrowed": {
               "code": "import FindMarket from 0x097bafa4e0b48eef\nimport FindMarketAuctionEscrow from 0x097bafa4e0b48eef\n\ntransaction(marketplace:Address, ids: [UInt64]) {\n\n    let saleItems : \u0026FindMarketAuctionEscrow.SaleItemCollection?\n\n    prepare(account: AuthAccount) {\n\n        let tenant=FindMarket.getTenant(marketplace)\n        self.saleItems= account.borrow\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()))\n\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        for id in ids {\n            self.saleItems!.cancel(id)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "ids"
                  ],
                  "parameters": {
                     "ids": "[UInt64]",
                     "marketplace": "Address"
                  }
               }
            },
            "cancelMarketAuctionSoft": {
               "code": "import FindMarket from 0x097bafa4e0b48eef\nimport FindMarketAuctionSoft from 0x097bafa4e0b48eef\n\ntransaction(marketplace:Address, ids: [UInt64]) {\n\n    let saleItems : \u0026FindMarketAuctionSoft.SaleItemCollection?\n\n    prepare(account: AuthAccount) {\n        let tenant=FindMarket.getTenant(marketplace)\n        self.saleItems= account.borrow\u003c\u0026FindMarketAuctionSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()))\n    }\n\n    pre{\n        self.saleItems != nil \n    }\n\n    execute{\n        for id in ids {\n            self.saleItems!.cancel(id)\n        }\n    }\n\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "ids"
                  ],
                  "parameters": {
                     "ids": "[UInt64]",
                     "marketplace": "Address"
                  }
               }
            },
            "cancelMarketDirectOfferEscrowed": {
               "code": "import FindMarket from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferEscrow from 0x097bafa4e0b48eef\n\ntransaction(marketplace:Address, ids: [UInt64]) {\n\n    let saleItems : \u0026FindMarketDirectOfferEscrow.SaleItemCollection?\n\n    prepare(account: AuthAccount) {\n\n        let tenant=FindMarket.getTenant(marketplace)\n        self.saleItems= account.borrow\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()))\n\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        for id in ids {\n            self.saleItems!.cancel(id)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "ids"
                  ],
                  "parameters": {
                     "ids": "[UInt64]",
                     "marketplace": "Address"
                  }
               }
            },
            "cancelMarketDirectOfferSoft": {
               "code": "import FindMarket from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferSoft from 0x097bafa4e0b48eef\n\ntransaction(marketplace:Address, ids: [UInt64]) {\n\n    let saleItems : \u0026FindMarketDirectOfferSoft.SaleItemCollection?\n\n    prepare(account: AuthAccount) {\n\n        let tenant=FindMarket.getTenant(marketplace)\n        self.saleItems= account.borrow\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()))\n\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute {\n        for id in ids {\n            self.saleItems!.cancel(id)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "ids"
                  ],
                  "parameters": {
                     "ids": "[UInt64]",
                     "marketplace": "Address"
                  }
               }
            },
            "cancelMarketListings": {
               "code": "import FindMarket from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferEscrow from 0x097bafa4e0b48eef\nimport FindMarketAuctionEscrow from 0x097bafa4e0b48eef\nimport FindMarketAuctionSoft from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferSoft from 0x097bafa4e0b48eef\nimport FindMarketSale from 0x097bafa4e0b48eef\n\ntransaction(marketplace:Address, ids: {String : [UInt64]}) {\n    prepare(account: AuthAccount) {\n\n        let tenant=FindMarket.getTenant(marketplace)\n\n        var saleType = Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        if let ids = ids[FindMarket.getMarketOptionFromType(saleType)] {\n            let saleItems= account.borrow\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection\u003e(from: tenant.getStoragePath(saleType))!\n            for id in ids {\n                saleItems.cancel(id)\n            }\n        }\n\n        saleType = Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        if let ids = ids[FindMarket.getMarketOptionFromType(saleType)] {\n            let saleItems= account.borrow\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection\u003e(from: tenant.getStoragePath(saleType))!\n            for id in ids {\n                saleItems.cancel(id)\n            }\n        }\n\n        saleType = Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        if let ids = ids[FindMarket.getMarketOptionFromType(saleType)] {\n            let saleItems= account.borrow\u003c\u0026FindMarketAuctionSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(saleType))!\n            for id in ids {\n                saleItems.cancel(id)\n            }\n        }\n\n        saleType = Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n        if let ids = ids[FindMarket.getMarketOptionFromType(saleType)] {\n            let saleItems= account.borrow\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(saleType))!\n            for id in ids {\n                saleItems.cancel(id)\n            }\n        }\n\n        saleType = Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        if let ids = ids[FindMarket.getMarketOptionFromType(saleType)] {\n            let saleItems= account.borrow\u003c\u0026FindMarketSale.SaleItemCollection\u003e(from: tenant.getStoragePath(saleType))!\n            for id in ids {\n                saleItems.delist(id)\n            }\n        }\n\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "ids"
                  ],
                  "parameters": {
                     "ids": "{String: [UInt64]}",
                     "marketplace": "Address"
                  }
               }
            },
            "cancelNameAuction": {
               "code": "import FIND from 0x097bafa4e0b48eef\n\ntransaction(names: [String]) {\n\n    let finLeases : \u0026FIND.LeaseCollection?\n\n    prepare(account: AuthAccount) {\n        self.finLeases= account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)\n    }\n\n    pre{\n        self.finLeases != nil : \"Cannot borrow reference to find leases collection\"\n    }\n\n    execute {\n        for name in names {\n            self.finLeases!.cancel(name)\n            self.finLeases!.delistAuction(name)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "names"
                  ],
                  "parameters": {
                     "names": "[String]"
                  }
               }
            },
            "cancelNameBid": {
               "code": "import FIND from 0x097bafa4e0b48eef\n\ntransaction(names: [String]) {\n\n    let bids : \u0026FIND.BidCollection?\n\n    prepare(account: AuthAccount) {\n        self.bids = account.borrow\u003c\u0026FIND.BidCollection\u003e(from: FIND.BidStoragePath)\n    }\n\n    pre{\n        self.bids != nil : \"Cannot borrow reference to find bid collection\"\n    }\n\n    execute {\n        for name in names {\n            self.bids!.cancelBid(name)\n        }\n    }\n\n}",
               "spec": {
                  "order": [
                     "names"
                  ],
                  "parameters": {
                     "names": "[String]"
                  }
               }
            },
            "createCharity": {
               "code": "import NonFungibleToken from 0x1d7e57aa55817448\nimport MetadataViews from 0x1d7e57aa55817448\nimport CharityNFT from 0x097bafa4e0b48eef\n\n//This transaction will prepare the art collection\ntransaction() {\n    prepare(account: AuthAccount) {\n\n        let stdCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath)\n        if !stdCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- CharityNFT.createEmptyCollection(), to: CharityNFT.CollectionStoragePath)\n            account.link\u003c\u0026{NonFungibleToken.CollectionPublic, MetadataViews.ResolverCollection}\u003e(CharityNFT.CollectionPublicPath, target: CharityNFT.CollectionStoragePath)\n        }\n\n        let charityCap = account.getCapability\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection)\n        if !charityCap.check() {\n            account.link\u003c\u0026{CharityNFT.CollectionPublic, MetadataViews.ResolverCollection}\u003e(/public/findCharityNFTCollection, target: CharityNFT.CollectionStoragePath)\n        }\n    }\n}",
               "spec": {
                  "order": [],
                  "parameters": {}
               }
            },
            "createProfile": {
               "code": "import FungibleToken from 0xf233dcee88fe0abe\nimport NonFungibleToken from 0x1d7e57aa55817448\nimport FUSD from 0x3c5959b568896393\nimport FiatToken from 0xb19436aae4d94622\nimport FlowToken from 0x1654653399040a61\nimport MetadataViews from 0x1d7e57aa55817448\nimport FIND from 0x097bafa4e0b48eef\nimport FindPack from 0x097bafa4e0b48eef\nimport Profile from 0x097bafa4e0b48eef\nimport FindMarket from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferEscrow from 0x097bafa4e0b48eef\nimport Dandy from 0x097bafa4e0b48eef\nimport FindThoughts from 0x097bafa4e0b48eef\n\ntransaction(name: String) {\n    prepare(account: AuthAccount) {\n        //if we do not have a profile it might be stored under a different address so we will just remove it\n        let profileCapFirst = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if profileCapFirst.check() {\n            return \n        }\n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n        //SYNC with register\n        //Add exising FUSD or create a new one and add it\n        let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n        if !fusdReceiver.check() {\n            let fusd \u003c- FUSD.createEmptyVault()\n            account.save(\u003c- fusd, to: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n        }\n\n        let usdcCap = account.getCapability\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e(FiatToken.VaultReceiverPubPath)\n        if !usdcCap.check() {\n                account.save( \u003c-FiatToken.createEmptyVault(), to: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e( FiatToken.VaultReceiverPubPath, target: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FiatToken.ResourceId}\u003e( FiatToken.VaultUUIDPubPath, target: FiatToken.VaultStoragePath)\n                account.link\u003c\u0026FiatToken.Vault{FungibleToken.Balance}\u003e( FiatToken.VaultBalancePubPath, target:FiatToken.VaultStoragePath)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let dandyCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        let thoughtsCap= account.getCapability\u003c\u0026{FindThoughts.CollectionPublic}\u003e(FindThoughts.CollectionPublicPath)\n        if !thoughtsCap.check() {\n            account.save(\u003c- FindThoughts.createEmptyCollection(), to: FindThoughts.CollectionStoragePath)\n            account.link\u003c\u0026FindThoughts.Collection{FindThoughts.CollectionPublic , MetadataViews.ResolverCollection}\u003e(\n                FindThoughts.CollectionPublicPath,\n                target: FindThoughts.CollectionStoragePath\n            )\n        }\n\n        let findPackCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(FindPack.CollectionPublicPath)\n        if !findPackCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e( \u003c- FindPack.createEmptyCollection(), to: FindPack.CollectionStoragePath)\n            account.link\u003c\u0026FindPack.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                FindPack.CollectionPublicPath,\n                target: FindPack.CollectionStoragePath\n            )\n        }\n\n        var created=false\n        var updated=false\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        if !profile.hasWallet(\"Flow\") {\n            let flowWallet=Profile.Wallet( name:\"Flow\", receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), tags: [\"flow\"])\n    \n            profile.addWallet(flowWallet)\n            updated=true\n        }\n        if !profile.hasWallet(\"FUSD\") {\n            profile.addWallet(Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), tags: [\"fusd\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if !profile.hasWallet(\"USDC\") {\n            profile.addWallet(Profile.Wallet( name:\"USDC\", receiver:usdcCap, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(FiatToken.VaultBalancePubPath), accept: Type\u003c@FiatToken.Vault\u003e(), tags: [\"usdc\", \"stablecoin\"]))\n            updated=true\n        }\n\n         //If find name not set and we have a profile set it.\n        if profile.getFindName() == \"\" {\n            if let findName = FIND.reverseLookup(account.address) {\n                profile.setFindName(findName)\n                // If name is set, it will emit Updated Event, there is no need to emit another update event below. \n                updated=false\n            }\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else if updated {\n            profile.emitUpdatedEvent()\n        }\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let tenantCapability= FindMarket.getTenantCapability(FindMarket.getFindTenantAddress())!\n\n        let tenant = tenantCapability.borrow()!\n\n        let doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        let doeSalePublicPath=FindMarket.getPublicPath(doeSaleType, name: tenant.name)\n        let doeSaleStoragePath= FindMarket.getStoragePath(doeSaleType, name:tenant.name)\n        let doeSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n        if !doeSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n        }\n        //SYNC with register\n\n    }\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "createProfileDapper": {
               "code": "import FungibleToken from 0xf233dcee88fe0abe\nimport NonFungibleToken from 0x1d7e57aa55817448\nimport MetadataViews from 0x1d7e57aa55817448\nimport FIND from 0x097bafa4e0b48eef\nimport Dandy from 0x097bafa4e0b48eef\nimport Profile from 0x097bafa4e0b48eef\nimport FindMarket from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferSoft from 0x097bafa4e0b48eef\nimport DapperUtilityCoin from 0xead892083b3e2c6c\nimport FlowUtilityToken from 0xead892083b3e2c6c\nimport FindLeaseMarketDirectOfferSoft from 0x097bafa4e0b48eef\nimport FindLeaseMarket from 0x097bafa4e0b48eef\n\ntransaction(name: String) {\n    prepare(account: AuthAccount) {\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let dandyCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        var created=false\n        var updated=false\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        if !profile.hasWallet(\"DUC\") {\n            let ducReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver)\n            profile.addWallet(Profile.Wallet( name:\"DUC\", receiver:ducReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/dapperUtilityCoinBalance), accept: Type\u003c@DapperUtilityCoin.Vault\u003e(), tags: [\"duc\", \"dapperUtilityCoin\",\"dapper\"]))\n            updated=true\n        }\n\n        if !profile.hasWallet(\"FUT\") {\n            let futReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowUtilityTokenReceiver)\n            profile.addWallet(Profile.Wallet( name:\"FUT\", receiver:futReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowUtilityTokenBalance), accept: Type\u003c@FlowUtilityToken.Vault\u003e(), tags: [\"fut\", \"flowUtilityToken\",\"dapper\"]))\n            updated=true\n        }\n\n        profile.emitCreatedEvent()\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let tenantCapability= FindMarket.getTenantCapability(FindMarket.getFindTenantAddress())!\n\n        let tenant = tenantCapability.borrow()!\n\n        let dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n        let dosSalePublicPath=FindMarket.getPublicPath(dosSaleType, name: tenant.name)\n        let dosSaleStoragePath= FindMarket.getStoragePath(dosSaleType, name:tenant.name)\n        let dosSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath)\n        if !dosSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n        }\n\n        let leaseTenantCapability= FindMarket.getTenantCapability(FindMarket.getFindTenantAddress())!\n        let leaseTenant = leaseTenantCapability.borrow()!\n\n        let leaseDOSSaleItemType= Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e()\n        let leaseDOSPublicPath=leaseTenant.getPublicPath(leaseDOSSaleItemType)\n        let leaseDOSStoragePath= leaseTenant.getStoragePath(leaseDOSSaleItemType)\n        let leaseDOSSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath)\n        if !leaseDOSSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOSStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath, target: leaseDOSStoragePath)\n        }\n\n    }\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "deleteFindThoughts": {
               "code": "import FindThoughts from 0x097bafa4e0b48eef\n\ntransaction(ids: [UInt64]) {\n\n    let collection : \u0026FindThoughts.Collection\n\n    prepare(account: AuthAccount) {\n\n        self.collection=account.borrow\u003c\u0026FindThoughts.Collection\u003e(from: FindThoughts.CollectionStoragePath) ?? panic(\"Cannot borrow thoughts reference from path\")\n    }\n\n    execute {\n        for id in ids {\n            self.collection.delete(id)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "ids"
                  ],
                  "parameters": {
                     "ids": "[UInt64]"
                  }
               }
            },
            "delistAllLeaseSale": {
               "code": "import FindLeaseMarketSale from 0x097bafa4e0b48eef\nimport FindMarket from 0x097bafa4e0b48eef\nimport FindLeaseMarket from 0x097bafa4e0b48eef\n\ntransaction() {\n    prepare(account: AuthAccount) {\n        // Get all the saleItems Id\n\n        let tenant = FindMarket.getTenant(FindMarket.getFindTenantAddress())\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindLeaseMarketSale.SaleItem\u003e())\n        let cap = FindLeaseMarket.getSaleItemCollectionCapability(tenantRef: tenant, marketOption: marketOption, address: account.address)\n        let ref = cap.borrow() ?? panic(\"Cannot borrow reference to the capability.\")\n\n        let listingType=Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()\n        let saleItems= account.borrow\u003c\u0026FindLeaseMarketSale.SaleItemCollection\u003e(from: tenant.getStoragePath(listingType))!\n        let leases = ref.getNameSales()\n        for lease in leases {\n            saleItems.delist(lease)\n        }\n    }\n}",
               "spec": {
                  "order": [],
                  "parameters": {}
               }
            },
            "delistAllNFTSale": {
               "code": "import FindMarketSale from 0x097bafa4e0b48eef\nimport FindMarket from 0x097bafa4e0b48eef\n\ntransaction(marketplace:Address) {\n\n    let saleItems : \u0026FindMarketSale.SaleItemCollection?\n\n    prepare(account: AuthAccount) {\n        let tenant = FindMarket.getTenant(marketplace)\n        self.saleItems= account.borrow\u003c\u0026FindMarketSale.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketSale.SaleItemCollection\u003e())) \n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        let ids = self.saleItems!.getIds()\n        for id in ids {\n            self.saleItems!.delist(id)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace"
                  ],
                  "parameters": {
                     "marketplace": "Address"
                  }
               }
            },
            "delistAllNameSale": {
               "code": "import FIND from 0x097bafa4e0b48eef\n\ntransaction() {\n\n    let finLeases : \u0026FIND.LeaseCollection?\n\n    prepare(acct: AuthAccount) {\n        self.finLeases= acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)\n\n    }\n\n    pre{\n        self.finLeases != nil : \"Cannot borrow reference to find lease collection\"\n    }\n\n    execute{\n        let leases = self.finLeases!.getLeaseInformation()\n        for lease in leases {\n            if lease.salePrice != nil {\n                self.finLeases!.delistSale(lease.name)\n            }\n        }\n    }\n}",
               "spec": {
                  "order": [],
                  "parameters": {}
               }
            },
            "delistLeaseSale": {
               "code": "import FindMarket from 0x097bafa4e0b48eef\nimport FindLeaseMarketSale from 0x097bafa4e0b48eef\n\ntransaction(leases: [String]) {\n    let saleItems : \u0026FindLeaseMarketSale.SaleItemCollection?\n\n    prepare(account: AuthAccount) {\n\n        let tenant=FindMarket.getTenant(FindMarket.getFindTenantAddress())\n        self.saleItems= account.borrow\u003c\u0026FindLeaseMarketSale.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()))\n\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        for lease in leases {\n            self.saleItems!.delist(lease)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "leases"
                  ],
                  "parameters": {
                     "leases": "[String]"
                  }
               }
            },
            "delistNFTSale": {
               "code": "import FindMarket from 0x097bafa4e0b48eef\nimport FindMarketSale from 0x097bafa4e0b48eef\n\n//Remove one or more listings from a marketplace\ntransaction(marketplace:Address, ids: [UInt64]) {\n\n    let saleItems : \u0026FindMarketSale.SaleItemCollection?\n\n    prepare(account: AuthAccount) {\n        let tenant=FindMarket.getTenant(marketplace)\n        self.saleItems= account.borrow\u003c\u0026FindMarketSale.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketSale.SaleItemCollection\u003e()))\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        for id in ids {\n            self.saleItems!.delist(id)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "ids"
                  ],
                  "parameters": {
                     "ids": "[UInt64]",
                     "marketplace": "Address"
                  }
               }
            },
            "delistNameSale": {
               "code": "import FIND from 0x097bafa4e0b48eef\n\ntransaction(names: [String]) {\n\n    let finLeases : \u0026FIND.LeaseCollection?\n\n    prepare(acct: AuthAccount) {\n        self.finLeases= acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)\n    }\n\n    pre{\n        self.finLeases != nil : \"Cannot borrow reference to find lease collection\"\n    }\n\n    execute{\n        for name in names {\n            self.finLeases!.delistSale(name)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "names"
                  ],
                  "parameters": {
                     "names": "[String]"
                  }
               }
            },
            "editFindThought": {
               "code": "import FindThoughts from 0x097bafa4e0b48eef\n\ntransaction(id: UInt64, header: String , body: String, tags: [String]) {\n\n    let collection : \u0026FindThoughts.Collection\n\n    prepare(account: AuthAccount) {\n\n        self.collection=account.borrow\u003c\u0026FindThoughts.Collection\u003e(from: FindThoughts.CollectionStoragePath) ?? panic(\"Cannot borrow thoughts reference from path\")\n    }\n\n    execute {\n        let thought = self.collection.borrow(id)\n        thought.edit(header: header , body: body, tags: tags)\n    }\n}",
               "spec": {
                  "order": [
                     "id",
                     "header",
                     "body",
                     "tags"
                  ],
                  "parameters": {
                     "body": "String",
                     "header": "String",
                     "id": "UInt64",
                     "tags": "[String]"
                  }
               }
            },
            "editProfile": {
               "code": "import FungibleToken from 0xf233dcee88fe0abe\nimport FUSD from 0x3c5959b568896393\nimport FlowToken from 0x1654653399040a61\nimport FIND from 0x097bafa4e0b48eef\nimport Profile from 0x097bafa4e0b48eef\n\ntransaction(name:String, description: String, avatar: String, tags:[String], allowStoringFollowers: Bool, linkTitles : {String: String}, linkTypes: {String:String}, linkUrls : {String:String}, removeLinks : [String]) {\n    \n    let profile : \u0026Profile.User\n\n    prepare(account: AuthAccount) {\n\n        self.profile =account.borrow\u003c\u0026Profile.User\u003e(from:Profile.storagePath) ?? panic(\"Cannot borrow reference to profile\")\n\n        //Add exising FUSD or create a new one and add it\n        let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n        if !fusdReceiver.check() {\n            let fusd \u003c- FUSD.createEmptyVault()\n            account.save(\u003c- fusd, to: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n        }\n\n\n        var hasFusdWallet=false\n        var hasFlowWallet=false\n        let wallets=self.profile.getWallets()\n        for wallet in wallets {\n            if wallet.name==\"FUSD\" {\n                hasFusdWallet=true\n            }\n\n            if wallet.name ==\"Flow\" {\n                hasFlowWallet=true\n            }\n        }\n\n        if !hasFlowWallet {\n            let flowWallet=Profile.Wallet(\n                name:\"Flow\", \n                receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver),\n                balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance),\n                accept: Type\u003c@FlowToken.Vault\u003e(),\n                tags: [\"flow\"]\n            )\n            self.profile.addWallet(flowWallet)\n        }\n\n        if !hasFusdWallet {\n            let fusdWallet=Profile.Wallet(\n                name:\"FUSD\", \n                receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver),\n                balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance),\n                accept: Type\u003c@FUSD.Vault\u003e(),\n                tags: [\"fusd\", \"stablecoin\"]\n            )\n            self.profile.addWallet(fusdWallet)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n    }\n\n    execute{\n        self.profile!.setName(name)\n        self.profile!.setDescription(description)\n        self.profile!.setAvatar(avatar)\n        self.profile!.setTags(tags)\n\n        for link in removeLinks {\n            self.profile!.removeLink(link)\n        }\n\n        for titleName in linkTitles.keys {\n            let title=linkTitles[titleName]!\n            let url = linkUrls[titleName]!\n            let type = linkTypes[titleName]!\n\n            self.profile!.addLinkWithName(name:titleName, link: Profile.Link(title: title, type: type, url: url))\n        }\n        self.profile!.emitUpdatedEvent()\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "description",
                     "avatar",
                     "tags",
                     "allowStoringFollowers",
                     "linkTitles",
                     "linkTypes",
                     "linkUrls",
                     "removeLinks"
                  ],
                  "parameters": {
                     "allowStoringFollowers": "Bool",
                     "avatar": "String",
                     "description": "String",
                     "linkTitles": "{String: String}",
                     "linkTypes": "{String: String}",
                     "linkUrls": "{String: String}",
                     "name": "String",
                     "removeLinks": "[String]",
                     "tags": "[String]"
                  }
               }
            },
            "editProfileDapper": {
               "code": "import FIND from 0x097bafa4e0b48eef\nimport Profile from 0x097bafa4e0b48eef\n\ntransaction(name:String, description: String, avatar: String, tags:[String], allowStoringFollowers: Bool, linkTitles : {String: String}, linkTypes: {String:String}, linkUrls : {String:String}, removeLinks : [String]) {\n    \n    let profile : \u0026Profile.User\n\n    prepare(account: AuthAccount) {\n\n        self.profile =account.borrow\u003c\u0026Profile.User\u003e(from:Profile.storagePath) ?? panic(\"You do not have a profile set up, initialize the user first\")\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n\n        }\n\n    }\n\n    execute{\n        self.profile.setName(name)\n        self.profile.setDescription(description)\n        self.profile.setAvatar(avatar)\n        self.profile.setTags(tags)\n\n        for link in removeLinks {\n            self.profile.removeLink(link)\n        }\n\n        for titleName in linkTitles.keys {\n            let title=linkTitles[titleName]!\n            let url = linkUrls[titleName]!\n            let type = linkTypes[titleName]!\n\n            self.profile.addLinkWithName(name:titleName, link: Profile.Link(title: title, type: type, url: url))\n        }\n        self.profile.emitUpdatedEvent()\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "description",
                     "avatar",
                     "tags",
                     "allowStoringFollowers",
                     "linkTitles",
                     "linkTypes",
                     "linkUrls",
                     "removeLinks"
                  ],
                  "parameters": {
                     "allowStoringFollowers": "Bool",
                     "avatar": "String",
                     "description": "String",
                     "linkTitles": "{String: String}",
                     "linkTypes": "{String: String}",
                     "linkUrls": "{String: String}",
                     "name": "String",
                     "removeLinks": "[String]",
                     "tags": "[String]"
                  }
               }
            },
            "follow": {
               "code": "import FungibleToken from 0xf233dcee88fe0abe\nimport FUSD from 0x3c5959b568896393\nimport FlowToken from 0x1654653399040a61\nimport FIND from 0x097bafa4e0b48eef\nimport Profile from 0x097bafa4e0b48eef\n\n// map of {User in string (find name or address) : [tag]}\ntransaction(follows:{String : [String]}) {\n\n    let profile : \u0026Profile.User\n\n    prepare(account: AuthAccount) {\n\n        self.profile =account.borrow\u003c\u0026Profile.User\u003e(from:Profile.storagePath) ?? panic(\"Cannot borrow reference to profile\")\n\n        //Add exising FUSD or create a new one and add it\n        let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n        if !fusdReceiver.check() {\n            let fusd \u003c- FUSD.createEmptyVault()\n            account.save(\u003c- fusd, to: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n        }\n\n\n        var hasFusdWallet=false\n        var hasFlowWallet=false\n        let wallets=self.profile.getWallets()\n        for wallet in wallets {\n            if wallet.name==\"FUSD\" {\n                hasFusdWallet=true\n            }\n\n            if wallet.name ==\"Flow\" {\n                hasFlowWallet=true\n            }\n        }\n\n        if !hasFlowWallet {\n            let flowWallet=Profile.Wallet(\n                name:\"Flow\",\n                receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver),\n                balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance),\n                accept: Type\u003c@FlowToken.Vault\u003e(),\n                tags: [\"flow\"]\n            )\n            self.profile.addWallet(flowWallet)\n        }\n\n        if !hasFusdWallet {\n            let fusdWallet=Profile.Wallet(\n                name:\"FUSD\",\n                receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver),\n                balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance),\n                accept: Type\u003c@FUSD.Vault\u003e(),\n                tags: [\"fusd\", \"stablecoin\"]\n            )\n            self.profile.addWallet(fusdWallet)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n    }\n\n    execute{\n        for key in follows.keys {\n            let user = FIND.resolve(key) ?? panic(key.concat(\" cannot be resolved. It is either an invalid .find name or address\"))\n            let tags = follows[key]!\n            self.profile.follow(user, tags: tags)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "follows"
                  ],
                  "parameters": {
                     "follows": "{String: [String]}"
                  }
               }
            },
            "followDapper": {
               "code": "import FungibleToken from 0xf233dcee88fe0abe\nimport FUSD from 0x3c5959b568896393\nimport FlowToken from 0x1654653399040a61\nimport FIND from 0x097bafa4e0b48eef\nimport Profile from 0x097bafa4e0b48eef\n\n// map of {User in string (find name or address) : [tag]}\ntransaction(follows:{String : [String]}) {\n\n    let profile : \u0026Profile.User\n\n    prepare(account: AuthAccount) {\n\n        self.profile =account.borrow\u003c\u0026Profile.User\u003e(from:Profile.storagePath) ?? panic(\"You do not have a profile set up, initialize the user first\")\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n\n        }\n    }\n\n    execute{\n        for key in follows.keys {\n            let user = FIND.resolve(key) ?? panic(key.concat(\" cannot be resolved. It is either an invalid .find name or address\"))\n            let tags = follows[key]!\n            self.profile.follow(user, tags: tags)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "follows"
                  ],
                  "parameters": {
                     "follows": "{String: [String]}"
                  }
               }
            },
            "fulfillLeaseMarketAuctionSoft": {
               "code": "import FindLeaseMarketAuctionSoft from 0x097bafa4e0b48eef\nimport FungibleToken from 0xf233dcee88fe0abe\nimport FTRegistry from 0x097bafa4e0b48eef\nimport FindMarket from 0x097bafa4e0b48eef\nimport FindLeaseMarket from 0x097bafa4e0b48eef\n\ntransaction(leaseName: String, amount:UFix64) {\n\n    let walletReference : \u0026FungibleToken.Vault\n    let bidsReference: \u0026FindLeaseMarketAuctionSoft.MarketBidCollection\n    let requiredAmount: UFix64\n\n    prepare(account: AuthAccount) {\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e())\n\n        self.bidsReference= account.borrow\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"This account does not have a bid collection\")\n\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e())\n        let item = FindLeaseMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, name: leaseName)\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n\n        self.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n        self.requiredAmount = self.bidsReference.getBalance(leaseName)\n    }\n\n    pre{\n        self.walletReference.balance \u003e self.requiredAmount : \"Your wallet does not have enough funds to pay for this item\"\n        self.requiredAmount == amount : \"Amount needed to fulfill is \".concat(self.requiredAmount.toString()).concat(\" you sent in \").concat(amount.toString())\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount)\n        self.bidsReference.fulfillAuction(name: leaseName, vault: \u003c- vault)\n    }\n}",
               "spec": {
                  "order": [
                     "leaseName",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "leaseName": "String"
                  }
               }
            },
            "fulfillLeaseMarketAuctionSoftDapper": {
               "code": "import FindLeaseMarketAuctionSoft from 0x097bafa4e0b48eef\nimport FungibleToken from 0xf233dcee88fe0abe\nimport FTRegistry from 0x097bafa4e0b48eef\nimport FindMarket from 0x097bafa4e0b48eef\nimport FindLeaseMarket from 0x097bafa4e0b48eef\n\ntransaction(leaseName: String, amount:UFix64) {\n\n    let walletReference : \u0026FungibleToken.Vault\n    let bidsReference: \u0026FindLeaseMarketAuctionSoft.MarketBidCollection\n    let requiredAmount: UFix64\n    let mainDapperCoinVault: \u0026FungibleToken.Vault\n    let balanceBeforeTransfer: UFix64\n\n    prepare(dapper: AuthAccount, account: AuthAccount) {\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e())\n\n        self.bidsReference= account.borrow\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"This account does not have a bid collection\")\n\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e())\n        let item = FindLeaseMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, name: leaseName)\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n\n        self.mainDapperCoinVault = dapper.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"Cannot borrow Dapper Coin vault from account storage. Type : \".concat(ft.type.identifier))\n        self.balanceBeforeTransfer = self.mainDapperCoinVault.balance\n\n        self.walletReference = dapper.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n        self.requiredAmount = self.bidsReference.getBalance(leaseName)\n    }\n\n    pre{\n        self.walletReference.balance \u003e self.requiredAmount : \"Your wallet does not have enough funds to pay for this item\"\n        self.requiredAmount == amount : \"Amount needed to fulfill is \".concat(self.requiredAmount.toString()).concat(\" you sent in \").concat(amount.toString())\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount)\n        self.bidsReference.fulfillAuction(name: leaseName, vault: \u003c- vault)\n    }\n\n    // Check that all dapper Coin was routed back to Dapper\n    post {\n        self.mainDapperCoinVault.balance == self.balanceBeforeTransfer: \"Dapper Coin leakage\"\n    }\n}",
               "spec": {
                  "order": [
                     "leaseName",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "leaseName": "String"
                  }
               }
            },
            "fulfillLeaseMarketDirectOfferSoft": {
               "code": "import FindLeaseMarketDirectOfferSoft from 0x097bafa4e0b48eef\nimport FungibleToken from 0xf233dcee88fe0abe\nimport FTRegistry from 0x097bafa4e0b48eef\nimport FindMarket from 0x097bafa4e0b48eef\nimport FindLeaseMarket from 0x097bafa4e0b48eef\n\ntransaction(leaseName: String, amount:UFix64) {\n\n    let walletReference : \u0026FungibleToken.Vault\n    let bidsReference: \u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection\n    let requiredAmount:UFix64\n\n    prepare(account: AuthAccount) {\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e())\n        self.bidsReference= account.borrow\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"Cannot borrow direct offer soft bid collection\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e())\n        let item = FindLeaseMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, name: leaseName)\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n\n          self.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n\n        self.requiredAmount = self.bidsReference.getBalance(leaseName)\n    }\n\n    pre {\n        self.walletReference.balance \u003e self.requiredAmount : \"Your wallet does not have enough funds to pay for this item\"\n        self.requiredAmount == amount : \"Amount needed to fulfill is \".concat(amount.toString())\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount)\n        self.bidsReference.fulfillDirectOffer(name: leaseName, vault: \u003c- vault)\n    }\n}",
               "spec": {
                  "order": [
                     "leaseName",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "leaseName": "String"
                  }
               }
            },
            "fulfillLeaseMarketDirectOfferSoftDapper": {
               "code": "import FindLeaseMarketDirectOfferSoft from 0x097bafa4e0b48eef\nimport FungibleToken from 0xf233dcee88fe0abe\nimport FTRegistry from 0x097bafa4e0b48eef\nimport FindMarket from 0x097bafa4e0b48eef\nimport FindLeaseMarket from 0x097bafa4e0b48eef\n\ntransaction(leaseName: String, amount:UFix64) {\n\n    let walletReference : \u0026FungibleToken.Vault\n    let bidsReference: \u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection\n    let requiredAmount:UFix64\n    let mainDapperCoinVault: \u0026FungibleToken.Vault\n    let balanceBeforeTransfer: UFix64\n\n    prepare(dapper: AuthAccount, account: AuthAccount) {\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e())\n        self.bidsReference= account.borrow\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"Cannot borrow direct offer soft bid collection\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e())\n        let item = FindLeaseMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, name: leaseName)\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n\n        self.mainDapperCoinVault = dapper.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"Cannot borrow Dapper Coin vault from account storage. Type : \".concat(ft.type.identifier))\n        self.balanceBeforeTransfer = self.mainDapperCoinVault.balance\n\n          self.walletReference = dapper.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n\n        self.requiredAmount = self.bidsReference.getBalance(leaseName)\n    }\n\n    pre {\n        self.walletReference.balance \u003e self.requiredAmount : \"Your wallet does not have enough funds to pay for this item\"\n        self.requiredAmount == amount : \"Amount needed to fulfill is \".concat(amount.toString())\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount)\n        self.bidsReference.fulfillDirectOffer(name: leaseName, vault: \u003c- vault)\n    }\n\n    // Check that all dapper Coin was routed back to Dapper\n    post {\n        self.mainDapperCoinVault.balance == self.balanceBeforeTransfer: \"Dapper Coin leakage\"\n    }\n}",
               "spec": {
                  "order": [
                     "leaseName",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "leaseName": "String"
                  }
               }
            },
            "fulfillMarketAuctionEscrowed": {
               "code": "import FindMarketAuctionEscrow from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\n\ntransaction(marketplace:Address, owner: String, id: UInt64) {\n\n    let saleItem : Capability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic}\u003e?\n\n    prepare(account: AuthAccount) {\n        let resolveAddress = FIND.resolve(owner)\n        if resolveAddress == nil { \n            panic(\"The address input is not a valid name nor address. Input : \".concat(owner))\n        }\n        let address = resolveAddress!\n        self.saleItem = FindMarketAuctionEscrow.getSaleItemCapability(marketplace:marketplace, user:address)\n\n    }\n\n    pre{\n        self.saleItem != nil : \"This saleItem capability does not exist. Sale item ID: \".concat(id.toString())\n        self.saleItem!.check() : \"Cannot borrow reference to saleItem. Sale item ID: \".concat(id.toString())\n    }\n\n    execute {\n        self.saleItem!.borrow()!.fulfillAuction(id)\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "owner",
                     "id"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "marketplace": "Address",
                     "owner": "String"
                  }
               }
            },
            "fulfillMarketAuctionEscrowedFromBidder": {
               "code": "import FindMarketAuctionEscrow from 0x097bafa4e0b48eef\nimport FindMarket from 0x097bafa4e0b48eef\n\ntransaction(marketplace:Address, id: UInt64) {\n\n    let bidsReference : \u0026FindMarketAuctionEscrow.MarketBidCollection?\n\n    prepare(account: AuthAccount) {\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e())\n        self.bidsReference= account.borrow\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection\u003e(from: storagePath)\n\n        \n    }\n\n    pre{\n        self.bidsReference != nil : \"Cannot borrow reference to bid collection.\"\n    }\n\n    execute{\n        self.bidsReference!.fulfillAuction(id)\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "fulfillMarketAuctionSoft": {
               "code": "import FindMarketAuctionSoft from 0x097bafa4e0b48eef\nimport FungibleToken from 0xf233dcee88fe0abe\nimport FTRegistry from 0x097bafa4e0b48eef\nimport FindMarket from 0x097bafa4e0b48eef\n\ntransaction(marketplace:Address, id: UInt64, amount:UFix64) {\n\n    let walletReference : \u0026FungibleToken.Vault\n    let bidsReference: \u0026FindMarketAuctionSoft.MarketBidCollection\n    let requiredAmount: UFix64\n\n    prepare(account: AuthAccount) {\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e())\n\n        self.bidsReference= account.borrow\u003c\u0026FindMarketAuctionSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"This account does not have a bid collection\")\n\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e())\n        let item = FindMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: id)\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n    \n        self.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n        self.requiredAmount = self.bidsReference.getBalance(id)\n    }\n\n    pre{\n        self.walletReference.balance \u003e self.requiredAmount : \"Your wallet does not have enough funds to pay for this item\"\n        self.requiredAmount == amount : \"Amount needed to fulfill is \".concat(self.requiredAmount.toString()).concat(\" you sent in \").concat(amount.toString())\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount) \n        self.bidsReference.fulfillAuction(id: id, vault: \u003c- vault)\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "fulfillMarketAuctionSoftDapper": {
               "code": "import FindMarketAuctionSoft from 0x097bafa4e0b48eef\nimport FungibleToken from 0xf233dcee88fe0abe\nimport FTRegistry from 0x097bafa4e0b48eef\nimport FindMarket from 0x097bafa4e0b48eef\n\ntransaction(marketplace:Address, id: UInt64, amount:UFix64) {\n\n    let walletReference : \u0026FungibleToken.Vault\n    let bidsReference: \u0026FindMarketAuctionSoft.MarketBidCollection\n    let requiredAmount: UFix64\n    let mainDapperCoinVault: \u0026FungibleToken.Vault\n    let balanceBeforeTransfer: UFix64\n\n    prepare(dapper: AuthAccount, account: AuthAccount) {\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e())\n\n        self.bidsReference= account.borrow\u003c\u0026FindMarketAuctionSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"This account does not have a bid collection\")\n\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e())\n        let item = FindMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: id)\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n    \n        self.mainDapperCoinVault = dapper.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"Cannot borrow Dapper Coin vault from account storage. Type : \".concat(ft.type.identifier))\n        self.balanceBeforeTransfer = self.mainDapperCoinVault.balance\n\n        self.walletReference = dapper.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n        self.requiredAmount = self.bidsReference.getBalance(id)\n    }\n\n    pre{\n        self.walletReference.balance \u003e self.requiredAmount : \"Your wallet does not have enough funds to pay for this item\"\n        self.requiredAmount == amount : \"Amount needed to fulfill is \".concat(self.requiredAmount.toString()).concat(\" you sent in \").concat(amount.toString())\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount) \n        self.bidsReference.fulfillAuction(id: id, vault: \u003c- vault)\n    }\n\n    // Check that all dapper Coin was routed back to Dapper\n    post {\n        self.mainDapperCoinVault.balance == self.balanceBeforeTransfer: \"Dapper Coin leakage\"\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "fulfillMarketDirectOfferEscrowed": {
               "code": "import FindMarketDirectOfferEscrow from 0x097bafa4e0b48eef\nimport NonFungibleToken from 0x1d7e57aa55817448\nimport MetadataViews from 0x1d7e57aa55817448\nimport FindViews from 0x097bafa4e0b48eef\nimport NFTCatalog from 0x49a7cda3a1eecc29\nimport FINDNFTCatalog from 0x097bafa4e0b48eef\nimport FindMarket from 0x097bafa4e0b48eef\n\ntransaction(marketplace:Address, id: UInt64) {\n\n    let market : \u0026FindMarketDirectOfferEscrow.SaleItemCollection?\n    let pointer : FindViews.AuthNFTPointer\n\n    prepare(account: AuthAccount) {\n\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e())\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e())\n\n        let item = FindMarket.assertOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: id)\n\n        let nftIdentifier = item.getItemType().identifier\n        let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier)) \n        let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n        let nft = collection.collectionData\n\n    \n        var providerCap=account.getCapability\u003c\u0026{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e(nft.privatePath)\n\n        /* Ben : Question -\u003e Either client will have to provide the path here or agree that we set it up for the user */\n        if !providerCap.check() {\n            let newCap = account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                    nft.privatePath,\n                    target: nft.storagePath\n            )\n            if newCap == nil {\n                // If linking is not successful, we link it using finds custom link \n                let pathIdentifier = nft.privatePath.toString()\n                let findPath = PrivatePath(identifier: pathIdentifier.slice(from: \"/private/\".length , upTo: pathIdentifier.length).concat(\"_FIND\"))!\n                account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                    findPath,\n                    target: nft.storagePath\n                )\n                providerCap = account.getCapability\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(findPath)\n            }\n        }\n\n        self.pointer= FindViews.AuthNFTPointer(cap: providerCap, id: item.getItemID())\n        self.market = account.borrow\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection\u003e(from: storagePath)\n\n    }\n\n    pre{\n        self.market != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        self.market!.acceptDirectOffer(self.pointer)\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "fulfillMarketDirectOfferSoft": {
               "code": "import FindMarketDirectOfferSoft from 0x097bafa4e0b48eef\nimport FungibleToken from 0xf233dcee88fe0abe\nimport FTRegistry from 0x097bafa4e0b48eef\nimport FindMarket from 0x097bafa4e0b48eef\n\ntransaction(marketplace:Address, id: UInt64, amount:UFix64) {\n\n    let walletReference : \u0026FungibleToken.Vault\n    let bidsReference: \u0026FindMarketDirectOfferSoft.MarketBidCollection\n    let requiredAmount:UFix64\n\n    prepare(account: AuthAccount) {\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n        self.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"Cannot borrow direct offer soft bid collection\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n        let item = FindMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: id)\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n\n      self.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n\n        self.requiredAmount = self.bidsReference.getBalance(id)\n    }\n\n    pre {\n        self.walletReference.balance \u003e self.requiredAmount : \"Your wallet does not have enough funds to pay for this item\"\n        self.requiredAmount == amount : \"Amount needed to fulfill is \".concat(amount.toString())\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount) \n        self.bidsReference.fulfillDirectOffer(id: id, vault: \u003c- vault)\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "fulfillMarketDirectOfferSoftDapper": {
               "code": "import FindMarketDirectOfferSoft from 0x097bafa4e0b48eef\nimport FungibleToken from 0xf233dcee88fe0abe\nimport FTRegistry from 0x097bafa4e0b48eef\nimport FindMarket from 0x097bafa4e0b48eef\n\ntransaction(marketplace:Address, id: UInt64, amount:UFix64) {\n\n    let walletReference : \u0026FungibleToken.Vault\n    let bidsReference: \u0026FindMarketDirectOfferSoft.MarketBidCollection\n    let requiredAmount:UFix64\n    let mainDapperCoinVault: \u0026FungibleToken.Vault\n    let balanceBeforeTransfer: UFix64\n\n    prepare(dapper: AuthAccount, account: AuthAccount) {\n\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n        self.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"Cannot borrow direct offer soft bid collection\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n        let item = FindMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: id)\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n\n        self.mainDapperCoinVault = dapper.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"Cannot borrow Dapper Coin vault from account storage. Type : \".concat(ft.type.identifier))\n        self.balanceBeforeTransfer = self.mainDapperCoinVault.balance\n\n          self.walletReference = dapper.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n\n        self.requiredAmount = self.bidsReference.getBalance(id)\n    }\n\n    pre {\n        self.walletReference.balance \u003e self.requiredAmount : \"Your wallet does not have enough funds to pay for this item\"\n        self.requiredAmount == amount : \"Amount needed to fulfill is \".concat(amount.toString())\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount) \n        self.bidsReference.fulfillDirectOffer(id: id, vault: \u003c- vault)\n    }\n\n    // Check that all dapper Coin was routed back to Dapper\n    post {\n        self.mainDapperCoinVault.balance == self.balanceBeforeTransfer: \"Dapper Coin leakage\"\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "fulfillMultipleMarketDirectOfferEscrowed": {
               "code": "import FindMarketDirectOfferEscrow from 0x097bafa4e0b48eef\nimport NonFungibleToken from 0x1d7e57aa55817448\nimport MetadataViews from 0x1d7e57aa55817448\nimport FindViews from 0x097bafa4e0b48eef\nimport NFTCatalog from 0x49a7cda3a1eecc29\nimport FINDNFTCatalog from 0x097bafa4e0b48eef\nimport FindMarket from 0x097bafa4e0b48eef\n\ntransaction(marketplace:Address, ids: [UInt64]) {\n\n    let market : \u0026FindMarketDirectOfferEscrow.SaleItemCollection?\n    let pointer : [FindViews.AuthNFTPointer]\n\n    prepare(account: AuthAccount) {\n\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e())\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e())\n        self.market = account.borrow\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection\u003e(from: storagePath)\n        self.pointer = []\n\n        let nfts : {String : NFTCatalog.NFTCollectionData} = {}\n        var counter = 0\n        while counter \u003c ids.length {\n            let item = FindMarket.assertOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: ids[counter])\n\n            var nft : NFTCatalog.NFTCollectionData? = nil\n            let nftIdentifier = item.getItemType().identifier\n\n            if nfts[nftIdentifier] != nil {\n                nft = nfts[nftIdentifier]\n            } else {\n                let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier)) \n                let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n                nft = collection.collectionData\n                nfts[nftIdentifier] = nft\n            }\n        \n            var providerCap=account.getCapability\u003c\u0026{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e(nft!.privatePath)\n\n            /* Ben : Question -\u003e Either client will have to provide the path here or agree that we set it up for the user */\n            if !providerCap.check() {\n                let newCap = account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                        nft!.privatePath,\n                        target: nft!.storagePath\n                )\n                if newCap == nil {\n                    // If linking is not successful, we link it using finds custom link \n                    let pathIdentifier = nft!.privatePath.toString()\n                    let findPath = PrivatePath(identifier: pathIdentifier.slice(from: \"/private/\".length , upTo: pathIdentifier.length).concat(\"_FIND\"))!\n                    account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                        findPath,\n                        target: nft!.storagePath\n                    )\n                    providerCap = account.getCapability\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(findPath)\n                }\n            }\n\n            let pointer= FindViews.AuthNFTPointer(cap: providerCap, id: item.getItemID())\n            self.pointer.append(pointer)\n            counter = counter + 1\n        }\n\n    }\n\n    pre{\n        self.market != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        var counter = 0\n        while counter \u003c ids.length {\n            self.market!.acceptDirectOffer(self.pointer[counter])\n            counter = counter + 1\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "ids"
                  ],
                  "parameters": {
                     "ids": "[UInt64]",
                     "marketplace": "Address"
                  }
               }
            },
            "fulfillMultipleMarketDirectOfferSoft": {
               "code": "import FindMarketDirectOfferSoft from 0x097bafa4e0b48eef\nimport FungibleToken from 0xf233dcee88fe0abe\nimport FTRegistry from 0x097bafa4e0b48eef\nimport FindMarket from 0x097bafa4e0b48eef\n\ntransaction(marketplace:Address, ids: [UInt64], amounts:[UFix64]) {\n\n    let walletReference : [\u0026FungibleToken.Vault]\n    let bidsReference: \u0026FindMarketDirectOfferSoft.MarketBidCollection\n    let requiredAmount: [UFix64]\n\n    prepare(account: AuthAccount) {\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n        self.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"Cannot borrow direct offer soft bid collection\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n\n        var counter = 0\n        self.requiredAmount = []\n        self.walletReference = []\n        let fts : {String : FTRegistry.FTInfo} = {}\n        let vaultRefs : {StoragePath : \u0026FungibleToken.Vault} = {}\n\n\n        while counter \u003c ids.length {\n            let item = FindMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: ids[counter])\n\n            var ft : FTRegistry.FTInfo? = nil\n            let ftIdentifier = item.getFtType().identifier\n            if fts[ftIdentifier] != nil {\n                ft = fts[ftIdentifier]\n            } else {\n                ft = FTRegistry.getFTInfoByTypeIdentifier(ftIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftIdentifier))\n                fts[ftIdentifier] = ft\n            }\n\n            if vaultRefs[ft!.vaultPath] != nil {\n                self.walletReference.append(vaultRefs[ft!.vaultPath]!)\n            } else {\n                let walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft!.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n                vaultRefs[ft!.vaultPath] = walletReference\n                self.walletReference.append(walletReference)\n            }\n            let requiredAmount = self.bidsReference.getBalance(ids[counter])\n            self.requiredAmount.append(requiredAmount)\n            counter = counter + 1\n        }\n    }\n\n    execute {\n        var counter = 0\n        while counter \u003c ids.length {\n            if self.walletReference[counter].balance \u003c self.requiredAmount[counter] {\n                panic(\"Your wallet does not have enough funds to pay for this item. Item ID: \".concat(ids[counter].toString()))\n            }\n            if self.requiredAmount[counter] != amounts[counter] {\n                panic(\"Amount needed to fulfill is \".concat(amounts[counter].toString()))\n            }\n            let vault \u003c- self.walletReference[counter].withdraw(amount: amounts[counter]) \n            self.bidsReference.fulfillDirectOffer(id: ids[counter], vault: \u003c- vault)\n            counter = counter + 1\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "ids",
                     "amounts"
                  ],
                  "parameters": {
                     "amounts": "[UFix64]",
                     "ids": "[UInt64]",
                     "marketplace": "Address"
                  }
               }
            },
            "fulfillMultipleMarketDirectOfferSoftDapper": {
               "code": "import FindMarketDirectOfferSoft from 0x097bafa4e0b48eef\nimport FungibleToken from 0xf233dcee88fe0abe\nimport FTRegistry from 0x097bafa4e0b48eef\nimport FindMarket from 0x097bafa4e0b48eef\n\ntransaction(marketplace:Address, ids: [UInt64], amounts:[UFix64]) {\n\n    let walletReference : [\u0026FungibleToken.Vault]\n    let bidsReference: \u0026FindMarketDirectOfferSoft.MarketBidCollection\n    let requiredAmount: [UFix64]\n    let balanceBeforeTransfer: {Type : UFix64}\n\n    prepare(dapper: AuthAccount, account: AuthAccount) {\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n        self.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"Cannot borrow direct offer soft bid collection\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n\n        var counter = 0\n        self.requiredAmount = []\n        self.walletReference = []\n        self.balanceBeforeTransfer = {}\n        let fts : {String : FTRegistry.FTInfo} = {}\n        let vaultRefs : {StoragePath : \u0026FungibleToken.Vault} = {}\n\n\n        while counter \u003c ids.length {\n            let item = FindMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: ids[counter])\n\n            var ft : FTRegistry.FTInfo? = nil\n            let ftIdentifier = item.getFtType().identifier\n            if fts[ftIdentifier] != nil {\n                ft = fts[ftIdentifier]\n            } else {\n                ft = FTRegistry.getFTInfoByTypeIdentifier(ftIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftIdentifier))\n                fts[ftIdentifier] = ft\n            }\n\n            if vaultRefs[ft!.vaultPath] != nil {\n                let vaultRef = vaultRefs[ft!.vaultPath]!\n                self.walletReference.append(vaultRef)\n            } else {\n                let walletReference = dapper.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft!.vaultPath) ?? panic(\"Cannot borrow Dapper Coin Vault. Type : \".concat(ft!.type.identifier))\n                vaultRefs[ft!.vaultPath] = walletReference\n                self.walletReference.append(walletReference)\n                self.balanceBeforeTransfer[walletReference.getType()] = walletReference.balance\n            }\n            let requiredAmount = self.bidsReference.getBalance(ids[counter])\n            self.requiredAmount.append(requiredAmount)\n            counter = counter + 1\n        }\n    }\n\n    execute {\n        var counter = 0\n        while counter \u003c ids.length {\n            if self.walletReference[counter].balance \u003c self.requiredAmount[counter] {\n                panic(\"Your wallet does not have enough funds to pay for this item. Item ID: \".concat(ids[counter].toString()))\n            }\n            if self.requiredAmount[counter] != amounts[counter] {\n                panic(\"Amount needed to fulfill is \".concat(amounts[counter].toString()))\n            }\n            let vault \u003c- self.walletReference[counter].withdraw(amount: amounts[counter]) \n            self.bidsReference.fulfillDirectOffer(id: ids[counter], vault: \u003c- vault)\n            counter = counter + 1\n        }\n        // Check that all dapper Coin was routed back to Dapper\n        for vault in self.walletReference {\n            if self.balanceBeforeTransfer[vault.getType()]! != vault.balance {\n                panic(\"Dapper Coin leakage. Type : \".concat(vault.getType().identifier))\n            }\n        }\n    }\n\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "ids",
                     "amounts"
                  ],
                  "parameters": {
                     "amounts": "[UFix64]",
                     "ids": "[UInt64]",
                     "marketplace": "Address"
                  }
               }
            },
            "fulfillName": {
               "code": "import FIND from 0x097bafa4e0b48eef\nimport Profile from 0x097bafa4e0b48eef\n\ntransaction(name: String) {\n\n    let finLeases : \u0026FIND.LeaseCollection?\n\n    prepare(account: AuthAccount) {\n        self.finLeases= account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath) \n    }\n\n    pre{\n        self.finLeases != nil : \"Cannot borrow reference to find lease collection\"\n    }\n\n    execute{\n        self.finLeases!.fulfill(name)\n    }\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "fulfillNameAuction": {
               "code": "import FIND from 0x097bafa4e0b48eef\nimport Profile from 0x097bafa4e0b48eef\n\ntransaction(owner: Address, name: String) {\n\n    let leases : \u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}?\n\n    prepare(account: AuthAccount) {\n        self.leases = getAccount(owner).getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath).borrow()\n    }\n\n    pre{\n        self.leases != nil : \"Cannot borrow reference to lease collection reference. Account address: \".concat(owner.toString())\n    }\n\n    execute{\n        self.leases!.fulfillAuction(name)\n    }\n}",
               "spec": {
                  "order": [
                     "owner",
                     "name"
                  ],
                  "parameters": {
                     "name": "String",
                     "owner": "Address"
                  }
               }
            },
            "fulfillNameAuctionBidder": {
               "code": "import FIND from 0x097bafa4e0b48eef\nimport FungibleToken from 0xf233dcee88fe0abe\nimport FUSD from 0x3c5959b568896393\nimport Profile from 0x097bafa4e0b48eef\n\ntransaction(owner: Address, name: String) {\n\n    let leaseCollectionOwner : \u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}?\n\n    prepare(account: AuthAccount) {\n\n\n    //Add exising FUSD or create a new one and add it\n        let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n        if !fusdReceiver.check() {\n            let fusd \u003c- FUSD.createEmptyVault()\n            account.save(\u003c- fusd, to: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n\n            let fusdWallet=Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), tags: [\"fusd\", \"stablecoin\"])\n\n            profile.addWallet(fusdWallet)\n\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n        }\n\n        self.leaseCollectionOwner = getAccount(owner).getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath).borrow()\n\n    }\n\n    pre{\n        self.leaseCollectionOwner != nil : \"Cannot borrow reference to find lease collection. Account address: \".concat(owner.toString())\n    }\n\n    execute {\n        self.leaseCollectionOwner!.fulfillAuction(name)\n    }\n}",
               "spec": {
                  "order": [
                     "owner",
                     "name"
                  ],
                  "parameters": {
                     "name": "String",
                     "owner": "Address"
                  }
               }
            },
            "hideFindThoughts": {
               "code": "import FindThoughts from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\n\ntransaction(ids: [UInt64], hide: [Bool]) {\n\n    let collection : \u0026FindThoughts.Collection\n\n    prepare(account: AuthAccount) {\n        self.collection=account.borrow\u003c\u0026FindThoughts.Collection\u003e(from: FindThoughts.CollectionStoragePath) ?? panic(\"Cannot borrow thoughts reference from path\")\n    }\n\n    execute {\n        for i, id in ids {\n            self.collection.hide(id: id, hide: hide[i])\n        }\n\n    }\n}",
               "spec": {
                  "order": [
                     "ids",
                     "hide"
                  ],
                  "parameters": {
                     "hide": "[Bool]",
                     "ids": "[UInt64]"
                  }
               }
            },
            "increaseBidLeaseMarketAuctionSoft": {
               "code": "import FindLeaseMarketAuctionSoft from 0x097bafa4e0b48eef\nimport FungibleToken from 0xf233dcee88fe0abe\nimport FTRegistry from 0x097bafa4e0b48eef\nimport FindMarket from 0x097bafa4e0b48eef\nimport FindLeaseMarket from 0x097bafa4e0b48eef\n\ntransaction(leaseName: String, amount: UFix64) {\n\n    let bidsReference: \u0026FindLeaseMarketAuctionSoft.MarketBidCollection\n\n    prepare(account: AuthAccount) {\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e())\n        self.bidsReference= account.borrow\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"Bid resource does not exist\")\n        // get Bidding Fungible Token Vault\n          let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e())\n        let item = FindLeaseMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, name: leaseName)\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n\n    }\n\n    execute {\n        self.bidsReference.increaseBid(name: leaseName, increaseBy: amount)\n    }\n\n}",
               "spec": {
                  "order": [
                     "leaseName",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "leaseName": "String"
                  }
               }
            },
            "increaseBidLeaseMarketDirectOfferSoft": {
               "code": "import FindLeaseMarketDirectOfferSoft from 0x097bafa4e0b48eef\nimport FindMarket from 0x097bafa4e0b48eef\nimport FindLeaseMarket from 0x097bafa4e0b48eef\n\ntransaction(leaseName: String, amount: UFix64) {\n\n    let bidsReference: \u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection\n\n    prepare(account: AuthAccount) {\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e())\n        self.bidsReference= account.borrow\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"Bid resource does not exist\")\n        // get Bidding Fungible Token Vault\n          let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e())\n        let item = FindLeaseMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, name: leaseName)\n    }\n\n    execute {\n        self.bidsReference.increaseBid(name: leaseName, increaseBy: amount)\n    }\n}",
               "spec": {
                  "order": [
                     "leaseName",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "leaseName": "String"
                  }
               }
            },
            "increaseBidMarketAuctionEscrowed": {
               "code": "import FindMarketAuctionEscrow from 0x097bafa4e0b48eef\nimport FungibleToken from 0xf233dcee88fe0abe\nimport FTRegistry from 0x097bafa4e0b48eef\nimport FindMarket from 0x097bafa4e0b48eef\n\ntransaction(marketplace:Address, id: UInt64, amount: UFix64) {\n\n    let walletReference : \u0026FungibleToken.Vault\n    let bidsReference: \u0026FindMarketAuctionEscrow.MarketBidCollection\n    let balanceBeforeBid: UFix64\n\n    prepare(account: AuthAccount) {\n\n        // Get the accepted vault type from BidInfo\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e())\n        self.bidsReference= account.borrow\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection\u003e(from: storagePath) ?? panic(\"This account does not have a bid collection\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e())\n        let item = FindMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: id)\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n        self.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n        self.balanceBeforeBid = self.walletReference.balance\n    }\n\n    pre {\n        self.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount) \n        self.bidsReference.increaseBid(id: id, vault: \u003c- vault)\n    }\n\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "increaseBidMarketAuctionSoft": {
               "code": "import FindMarketAuctionSoft from 0x097bafa4e0b48eef\nimport FungibleToken from 0xf233dcee88fe0abe\nimport FTRegistry from 0x097bafa4e0b48eef\nimport FindMarket from 0x097bafa4e0b48eef\n\ntransaction(marketplace:Address, id: UInt64, amount: UFix64) {\n\n    let bidsReference: \u0026FindMarketAuctionSoft.MarketBidCollection\n\n\n    prepare(account: AuthAccount) {\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e())\n        self.bidsReference= account.borrow\u003c\u0026FindMarketAuctionSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"Bid resource does not exist\")\n        // get Bidding Fungible Token Vault\n          let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e())\n        let item = FindMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: id)\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n        if !ft.tag.contains(\"dapper\") {\n            let walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n        }\n    }\n\n    execute {\n        self.bidsReference.increaseBid(id: id, increaseBy: amount)\n    }\n\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "increaseBidMarketDirectOfferEscrowed": {
               "code": "import FindMarketDirectOfferEscrow from 0x097bafa4e0b48eef\nimport FungibleToken from 0xf233dcee88fe0abe\nimport FTRegistry from 0x097bafa4e0b48eef\nimport FindMarket from 0x097bafa4e0b48eef\n\ntransaction(marketplace:Address, id: UInt64, amount: UFix64) {\n\n    let walletReference : \u0026FungibleToken.Vault\n    let bidsReference: \u0026FindMarketDirectOfferEscrow.MarketBidCollection\n    let balanceBeforeBid: UFix64\n\n    prepare(account: AuthAccount) {\n        let tenant=FindMarket.getTenantCapability(marketplace)!.borrow() ?? panic(\"Cannot borrow reference to tenant\")\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e())\n        self.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection\u003e(from: storagePath) ?? panic(\"This account does not have a bid collection\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e())\n        let item = FindMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: id)\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n        self.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n        self.balanceBeforeBid=self.walletReference.balance\n    }\n\n    pre {\n        self.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount) \n        self.bidsReference!.increaseBid(id: id, vault: \u003c- vault)\n    }\n\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "increaseBidMarketDirectOfferSoft": {
               "code": "import FindMarketDirectOfferSoft from 0x097bafa4e0b48eef\nimport FindMarket from 0x097bafa4e0b48eef\n\ntransaction(marketplace: Address, id: UInt64, amount: UFix64) {\n\n    let bidsReference: \u0026FindMarketDirectOfferSoft.MarketBidCollection\n\n    prepare(account: AuthAccount) {\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n        self.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"Bid resource does not exist\")\n        // get Bidding Fungible Token Vault\n          let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n        let item = FindMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: id)\n    }\n\n    execute {\n        self.bidsReference.increaseBid(id: id, increaseBy: amount)\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "increaseNameBid": {
               "code": "import FIND from 0x097bafa4e0b48eef\nimport FungibleToken from 0xf233dcee88fe0abe\nimport FUSD from 0x3c5959b568896393\n\ntransaction(name: String, amount: UFix64) {\n\n    let vaultRef : \u0026FUSD.Vault?\n    let bids : \u0026FIND.BidCollection?\n\n    prepare(account: AuthAccount) {\n\n        \n        let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        self.vaultRef = account.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault)\n        self.bids = account.borrow\u003c\u0026FIND.BidCollection\u003e(from: FIND.BidStoragePath)\n    }\n\n    pre{\n        self.vaultRef != nil : \"Could not borrow reference to the fusdVault!\"\n        self.bids != nil : \"Could not borrow reference to bid collection\"\n    }\n\n    execute{\n        let vault \u003c- self.vaultRef!.withdraw(amount: amount) as! @FUSD.Vault\n        self.bids!.increaseBid(name: name, vault: \u003c- vault)\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "name": "String"
                  }
               }
            },
            "initDapperAccount": {
               "code": "import FungibleToken from 0xf233dcee88fe0abe\nimport DapperUtilityCoin from 0xead892083b3e2c6c\nimport FlowUtilityToken from 0xead892083b3e2c6c \nimport TokenForwarding from 0xe544175ee0461c4b\n\ntransaction(dapperAddress: Address) {\n    prepare(account: AuthAccount) {\n\n        let dapper=getAccount(dapperAddress)\n        //this is only for emulator\n        let ducReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver)\n        if !ducReceiver.check() {\n            // Create a new Forwarder resource for DUC and store it in the new account's storage\n            let ducForwarder \u003c- TokenForwarding.createNewForwarder(recipient: dapper.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver))\n            account.save(\u003c-ducForwarder, to: /storage/dapperUtilityCoinVault)\n            // Publish a Receiver capability for the new account, which is linked to the DUC Forwarder\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver,target: /storage/dapperUtilityCoinVault)\n        }\n\n        //this is only for emulator\n        let futReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowUtilityTokenReceiver)\n        if !futReceiver.check() {\n            // Create a new Forwarder resource for FUT and store it in the new account's storage\n            let futForwarder \u003c- TokenForwarding.createNewForwarder(recipient: dapper.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowUtilityTokenReceiver))\n            account.save(\u003c-futForwarder, to: /storage/flowUtilityTokenVault)\n            // Publish a Receiver capability for the new account, which is linked to the FUT Forwarder\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowUtilityTokenReceiver,target: /storage/flowUtilityTokenVault)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "dapperAddress"
                  ],
                  "parameters": {
                     "dapperAddress": "Address"
                  }
               }
            },
            "initMerchantAccount": {
               "code": "import TokenForwarding from 0xe544175ee0461c4b\nimport FungibleToken from 0xf233dcee88fe0abe\nimport DapperUtilityCoin from 0xead892083b3e2c6c\nimport FlowUtilityToken from 0xead892083b3e2c6c\nimport FungibleTokenSwitchboard from 0xf233dcee88fe0abe\nimport FiatToken from 0xb19436aae4d94622\nimport FUSD from 0x3c5959b568896393\nimport FlowToken from 0x1654653399040a61\n\n/**\n This is a transaction to set up an merchant account\n\n It has to be a blocto account since dapper will not allow us to run this account on a merchan account\n\n The only input parameter to this is your merchant account at dapper\n\n // 1. run this transaction in a lilico/blocto account your \"credit account\"\n // 2. use the path = /public/fungibleTokenSwitchboardPublic on this account as royalty receiver, it will be able to handle all the common FT\n**/\n\ntransaction(dapperMerchantAccountAddress: Address) {\n\n    prepare(acct: AuthAccount) {\n        // Get a Receiver reference for the Dapper account that will be the recipient of the forwarded DUC and FUT\n        let dapper = getAccount(dapperMerchantAccountAddress)\n\n        //FUSD\n        let fusdReceiver = acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n        if !fusdReceiver.check() {\n            let fusd \u003c- FUSD.createEmptyVault()\n            acct.save(\u003c- fusd, to: /storage/fusdVault)\n            acct.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n            acct.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n        }\n\n        //USDC\n        let usdcCap = acct.getCapability\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e(FiatToken.VaultReceiverPubPath)\n        if !usdcCap.check() {\n            acct.save( \u003c-FiatToken.createEmptyVault(), to: FiatToken.VaultStoragePath)\n            acct.link\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e( FiatToken.VaultReceiverPubPath, target: FiatToken.VaultStoragePath)\n            acct.link\u003c\u0026FiatToken.Vault{FiatToken.ResourceId}\u003e( FiatToken.VaultUUIDPubPath, target: FiatToken.VaultStoragePath)\n            acct.link\u003c\u0026FiatToken.Vault{FungibleToken.Balance}\u003e( FiatToken.VaultBalancePubPath, target:FiatToken.VaultStoragePath)\n        }\n\n        //We have to first check if the SIGNER has forwarder created.\n        //If not then we create a forwarder with the capability to DAPPER's receiver\n        //Dapper utility token\n\n        let ducReceiver = acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver)\n        let dapperDUCReceiver = dapper.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver)\n        if !ducReceiver.check(){\n            let ducForwarder \u003c- TokenForwarding.createNewForwarder(recipient: dapperDUCReceiver)\n            acct.save(\u003c-ducForwarder, to: /storage/dapperUtilityCoinReceiver)\n            acct.link\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver, target: /storage/dapperUtilityCoinReceiver)\n        }\n\n        //We have to first check if the SIGNER has forwarder created.\n        //If not then we create a forwarder with the capability to DAPPER's receiver\n        //FlowUtility token\n\n        let futReceiver = acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowUtilityTokenReceiver)\n        let dapperFUTReceiver = dapper.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowUtilityTokenReceiver)\n        if !futReceiver.check(){\n            let futForwarder \u003c- TokenForwarding.createNewForwarder(recipient: dapperFUTReceiver)\n            acct.save(\u003c-futForwarder, to: /storage/flowUtilityTokenReceiver)\n            acct.link\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowUtilityTokenReceiver, target: /storage/flowUtilityTokenReceiver)\n        }\n\n        let switchboard \u003c- FungibleTokenSwitchboard.createSwitchboard()\n\n        //We add the direct forwarder to the merchant account to the switchboard so that the chain will be\n        //switchboard --\u003e merchant account forwarder --\u003e dapper\n        //the alternative would be \n        //switchboard --\u003e our forwarder --\u003e merchant account forwarder --\u003e dapper\n        switchboard.addNewVaultWrapper(capability: dapperDUCReceiver, type: Type\u003c@DapperUtilityCoin.Vault\u003e())\n        switchboard.addNewVaultWrapper(capability: dapperFUTReceiver, type: Type\u003c@FlowUtilityToken.Vault\u003e())\n        switchboard.addNewVault(capability: usdcCap)\n        switchboard.addNewVault(capability: fusdReceiver)\n        switchboard.addNewVault(capability: acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver))\n\n        acct.save(\u003c- switchboard, to: FungibleTokenSwitchboard.StoragePath)\n        acct.link\u003c\u0026FungibleTokenSwitchboard.Switchboard{FungibleToken.Receiver}\u003e( FungibleTokenSwitchboard.ReceiverPublicPath, target: FungibleTokenSwitchboard.StoragePath)\n        acct.link\u003c\u0026FungibleTokenSwitchboard.Switchboard{FungibleTokenSwitchboard.SwitchboardPublic, FungibleToken.Receiver}\u003e(\n            FungibleTokenSwitchboard.PublicPath,\n            target: FungibleTokenSwitchboard.StoragePath\n        )\n    }\n}",
               "spec": {
                  "order": [
                     "dapperMerchantAccountAddress"
                  ],
                  "parameters": {
                     "dapperMerchantAccountAddress": "Address"
                  }
               }
            },
            "initSwitchboard": {
               "code": "import FungibleToken from 0xf233dcee88fe0abe\nimport FlowToken from 0x1654653399040a61\nimport FUSD from 0x3c5959b568896393\nimport FiatToken from 0xb19436aae4d94622\nimport TokenForwarding from 0xe544175ee0461c4b\nimport FungibleTokenSwitchboard from 0xf233dcee88fe0abe\nimport DapperUtilityCoin from 0xead892083b3e2c6c\nimport FlowUtilityToken from 0xead892083b3e2c6c\n\ntransaction(dapperAddress: Address) {\n    prepare(acct: AuthAccount) {\n\n        let dapper = getAccount(dapperAddress)\n\n        //FUSD\n        let fusdReceiver = acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n        if !fusdReceiver.check() {\n            let fusd \u003c- FUSD.createEmptyVault()\n            acct.save(\u003c- fusd, to: /storage/fusdVault)\n            acct.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n            acct.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n        }\n\n        //USDC\n        let usdcCap = acct.getCapability\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e(FiatToken.VaultReceiverPubPath)\n        if !usdcCap.check() {\n            acct.save( \u003c-FiatToken.createEmptyVault(), to: FiatToken.VaultStoragePath)\n            acct.link\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e( FiatToken.VaultReceiverPubPath, target: FiatToken.VaultStoragePath)\n            acct.link\u003c\u0026FiatToken.Vault{FiatToken.ResourceId}\u003e( FiatToken.VaultUUIDPubPath, target: FiatToken.VaultStoragePath)\n            acct.link\u003c\u0026FiatToken.Vault{FungibleToken.Balance}\u003e( FiatToken.VaultBalancePubPath, target:FiatToken.VaultStoragePath)\n        }\n\n\n        //Dapper utility token\n        let dapperDUCReceiver = dapper.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver)\n        let DUCReceiver = acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver)\n        if !DUCReceiver.check(){\n            let ducForwarder \u003c- TokenForwarding.createNewForwarder(recipient: dapperDUCReceiver)\n            acct.save(\u003c-ducForwarder, to: /storage/dapperUtilityCoinReceiver)\n            acct.link\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver, target: /storage/dapperUtilityCoinReceiver)\n        }\n\n        //FlowUtility token\n        let dapperFUTReceiver = dapper.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowUtilityTokenReceiver)\n        let FUTReceiver = acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowUtilityTokenReceiver)\n        if !FUTReceiver.check(){\n            let futForwarder \u003c- TokenForwarding.createNewForwarder(recipient: dapperFUTReceiver)\n            acct.save(\u003c-futForwarder, to: /storage/flowUtilityTokenReceiver)\n            acct.link\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowUtilityTokenReceiver, target: /storage/flowUtilityTokenReceiver)\n        }\n\n        let switchboardRef = acct.borrow\u003c\u0026FungibleTokenSwitchboard.Switchboard\u003e(from: FungibleTokenSwitchboard.StoragePath)\n        if switchboardRef == nil{\n            let sb \u003c- FungibleTokenSwitchboard.createSwitchboard()\n            acct.save(\u003c- sb, to: FungibleTokenSwitchboard.StoragePath)\n            acct.link\u003c\u0026FungibleTokenSwitchboard.Switchboard{FungibleToken.Receiver}\u003e( FungibleTokenSwitchboard.ReceiverPublicPath, target: FungibleTokenSwitchboard.StoragePath)\n            acct.link\u003c\u0026FungibleTokenSwitchboard.Switchboard{FungibleTokenSwitchboard.SwitchboardPublic, FungibleToken.Receiver}\u003e(\n                FungibleTokenSwitchboard.PublicPath,\n                target: FungibleTokenSwitchboard.StoragePath\n            )\n        }\n        let switchboard = acct.borrow\u003c\u0026FungibleTokenSwitchboard.Switchboard\u003e(from: FungibleTokenSwitchboard.StoragePath)!\n        let types = switchboard.getVaultTypes()\n        if !types.contains(Type\u003c@DapperUtilityCoin.Vault\u003e()) {\n            switchboard.addNewVaultWrapper(capability: dapperDUCReceiver, type: Type\u003c@DapperUtilityCoin.Vault\u003e())\n        }\n        if !types.contains(Type\u003c@FlowUtilityToken.Vault\u003e()) {\n            switchboard.addNewVaultWrapper(capability: dapperFUTReceiver, type: Type\u003c@FlowUtilityToken.Vault\u003e())\n        }\n        if !types.contains(usdcCap.borrow()!.getType()) {\n            switchboard.addNewVault(capability: usdcCap)\n        }\n        if !types.contains(fusdReceiver.borrow()!.getType()) {\n            switchboard.addNewVault(capability: fusdReceiver)\n        }\n        let flowTokenCap = acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver)\n        if !types.contains(flowTokenCap.borrow()!.getType()) {\n            switchboard.addNewVault(capability: flowTokenCap)\n        }\n\n    }\n}",
               "spec": {
                  "order": [
                     "dapperAddress"
                  ],
                  "parameters": {
                     "dapperAddress": "Address"
                  }
               }
            },
            "initWearables": {
               "code": "import Wearables from 0xe81193c424cfd3fb\nimport NonFungibleToken from 0x1d7e57aa55817448\nimport MetadataViews from 0x1d7e57aa55817448\n\ntransaction() {\n    prepare(account: AuthAccount) {\n\n        let wearablesRef= account.borrow\u003c\u0026Wearables.Collection\u003e(from: Wearables.CollectionStoragePath)\n        if wearablesRef == nil {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Wearables.createEmptyCollection(), to: Wearables.CollectionStoragePath)\n            account.unlink(Wearables.CollectionPublicPath)\n            account.link\u003c\u0026Wearables.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                Wearables.CollectionPublicPath,\n                target: Wearables.CollectionStoragePath\n            )\n            account.unlink(Wearables.CollectionPrivatePath)\n            account.link\u003c\u0026Wearables.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                Wearables.CollectionPrivatePath,\n                target: Wearables.CollectionStoragePath\n            )\n            return\n        }\n\n        let wearablesCap= account.getCapability\u003c\u0026Wearables.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(Wearables.CollectionPublicPath)\n        if !wearablesCap.check() {\n            account.unlink(Wearables.CollectionPublicPath)\n            account.link\u003c\u0026Wearables.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                Wearables.CollectionPublicPath,\n                target: Wearables.CollectionStoragePath\n            )\n        }\n\n        let wearablesProviderCap= account.getCapability\u003c\u0026Wearables.Collection{NonFungibleToken.Provider,NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(Wearables.CollectionPrivatePath)\n        if !wearablesProviderCap.check() {\n            account.unlink(Wearables.CollectionPrivatePath)\n            account.link\u003c\u0026Wearables.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                Wearables.CollectionPrivatePath,\n                target: Wearables.CollectionStoragePath\n            )\n        }\n\n    }\n}",
               "spec": {
                  "order": [],
                  "parameters": {}
               }
            },
            "linkDUCVaultReceiver": {
               "code": "import TokenForwarding from 0xe544175ee0461c4b\nimport FungibleToken from 0xf233dcee88fe0abe\n\n\ntransaction() {\n    prepare(account: AuthAccount) {\n        account.unlink(/public/dapperUtilityCoinReceiver)\n        account.link\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver,target: /storage/dapperUtilityCoinVault)\n    }\n}",
               "spec": {
                  "order": [],
                  "parameters": {}
               }
            },
            "listForSaleMultiple": {
               "code": "import FIND from 0x097bafa4e0b48eef\nimport FUSD from 0x3c5959b568896393\nimport FindMarket from 0x097bafa4e0b48eef\nimport FindMarketSale from 0x097bafa4e0b48eef\nimport NonFungibleToken from 0x1d7e57aa55817448\nimport MetadataViews from 0x1d7e57aa55817448\nimport FindViews from 0x097bafa4e0b48eef\nimport NFTCatalog from 0x49a7cda3a1eecc29\nimport FINDNFTCatalog from 0x097bafa4e0b48eef\nimport FTRegistry from 0x097bafa4e0b48eef\n\ntransaction(marketplace:Address, nftAliasOrIdentifiers: [String], ids: [AnyStruct], ftAliasOrIdentifiers: [String], directSellPrices:[UFix64], validUntil: UFix64?) {\n\n    let saleItems : \u0026FindMarketSale.SaleItemCollection?\n    let pointers : [FindViews.AuthNFTPointer]\n    let leaseNames : [String]\n    let vaultTypes : [Type]\n    let finLeases : \u0026FIND.LeaseCollection\n\n    prepare(account: AuthAccount) {\n\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n        let tenant = tenantCapability.borrow()!\n        self.vaultTypes= []\n        self.pointers= []\n        self.leaseNames= []\n        self.finLeases= account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath) ?? panic(\"Cannot borrow reference to find lease collection\")\n\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath)\n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n        self.saleItems= account.borrow\u003c\u0026FindMarketSale.SaleItemCollection\u003e(from: storagePath)!\n\n        var counter = 0\n\n        let nfts : {String : NFTCatalog.NFTCollectionData} = {}\n        let fts : {String : FTRegistry.FTInfo} = {}\n\n        while counter \u003c ids.length {\n            var ft : FTRegistry.FTInfo? = nil\n\n            if fts[ftAliasOrIdentifiers[counter]] != nil {\n                ft = fts[ftAliasOrIdentifiers[counter]]\n            } else {\n                ft = FTRegistry.getFTInfo(ftAliasOrIdentifiers[counter]) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftAliasOrIdentifiers[counter]))\n                fts[ftAliasOrIdentifiers[counter]] = ft\n            }\n\n            if let name = ids[counter] as? String {\n                if nftAliasOrIdentifiers[counter] != Type\u003c@FIND.Lease\u003e().identifier {\n                    panic(\"Lease does not match with identifiers\")\n                }\n                if ftAliasOrIdentifiers[counter] != Type\u003c@FUSD.Vault\u003e().identifier {\n                    panic(\"Listing of leases only supports FUSD at the moment\")\n                }\n                self.leaseNames.append(name)\n            }\n\n            if let id = ids[counter] as? UInt64 {\n                // Get supported NFT and FT Information from Registries from input alias\n                var nft : NFTCatalog.NFTCollectionData? = nil\n\n                if nfts[nftAliasOrIdentifiers[counter]] != nil {\n                    nft = nfts[nftAliasOrIdentifiers[counter]]\n                } else {\n                    let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftAliasOrIdentifiers[counter])?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftAliasOrIdentifiers[counter]))\n                    let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])!\n                    nft = collection.collectionData\n                    nfts[nftAliasOrIdentifiers[counter]] = nft\n                }\n\n                var providerCap=account.getCapability\u003c\u0026{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e(nft!.privatePath)\n\n                /* Ben : Question -\u003e Either client will have to provide the path here or agree that we set it up for the user */\n                if !providerCap.check() {\n                    let newCap = account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                            nft!.privatePath,\n                            target: nft!.storagePath\n                    )\n                    if newCap == nil {\n                        // If linking is not successful, we link it using finds custom link\n                        let pathIdentifier = nft!.privatePath.toString()\n                        let findPath = PrivatePath(identifier: pathIdentifier.slice(from: \"/private/\".length , upTo: pathIdentifier.length).concat(\"_FIND\"))!\n                        account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                            findPath,\n                            target: nft!.storagePath\n                        )\n                        providerCap = account.getCapability\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(findPath)\n                    }\n                }\n                // Get the salesItemRef from tenant\n                self.pointers.append(FindViews.AuthNFTPointer(cap: providerCap, id: id))\n            }\n\n            self.vaultTypes.append(ft!.type)\n            counter = counter + 1\n        }\n    }\n\n    execute{\n        var counter = 0\n        var nameCounter = 0\n        for identifier in nftAliasOrIdentifiers {\n            let vc = counter + nameCounter\n            if identifier == Type\u003c@FIND.Lease\u003e().identifier {\n                self.finLeases.listForSale(name: self.leaseNames[nameCounter],  directSellPrice:directSellPrices[vc])\n                nameCounter = nameCounter + 1\n                continue\n            }\n\n            self.saleItems!.listForSale(pointer: self.pointers[counter], vaultType: self.vaultTypes[vc], directSellPrice: directSellPrices[vc], validUntil: validUntil, extraField: {})\n            counter = counter + 1\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "nftAliasOrIdentifiers",
                     "ids",
                     "ftAliasOrIdentifiers",
                     "directSellPrices",
                     "validUntil"
                  ],
                  "parameters": {
                     "directSellPrices": "[UFix64]",
                     "ftAliasOrIdentifiers": "[String]",
                     "ids": "[AnyStruct]",
                     "marketplace": "Address",
                     "nftAliasOrIdentifiers": "[String]",
                     "validUntil": "UFix64?"
                  }
               }
            },
            "listLeaseForAuctionSoft": {
               "code": "import FindMarket from 0x097bafa4e0b48eef\nimport FTRegistry from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\nimport FindLeaseMarketAuctionSoft from 0x097bafa4e0b48eef\nimport FindLeaseMarket from 0x097bafa4e0b48eef\n\ntransaction(leaseName: String, ftAliasOrIdentifier:String, price:UFix64, auctionReservePrice: UFix64, auctionDuration: UFix64, auctionExtensionOnLateBid: UFix64, minimumBidIncrement: UFix64, auctionValidUntil: UFix64?) {\n\n    let saleItems : \u0026FindLeaseMarketAuctionSoft.SaleItemCollection?\n    let pointer : FindLeaseMarket.AuthLeasePointer\n    let vaultType : Type\n\n    prepare(account: AuthAccount) {\n\n        // Get supported NFT and FT Information from Registries from input alias\n        let ft = FTRegistry.getFTInfo(ftAliasOrIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftAliasOrIdentifier))\n\n        let leaseMarketplace = FindMarket.getFindTenantAddress()\n        let leaseTenantCapability= FindMarket.getTenantCapability(leaseMarketplace)!\n        let leaseTenant = leaseTenantCapability.borrow()!\n\n        let leaseASSaleItemType= Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e()\n        let leaseASPublicPath=leaseTenant.getPublicPath(leaseASSaleItemType)\n        let leaseASStoragePath= leaseTenant.getStoragePath(leaseASSaleItemType)\n        let leaseASSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath)\n        if !leaseASSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseASStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath, target: leaseASStoragePath)\n        }\n\n        self.saleItems= account.borrow\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(from: leaseASStoragePath)\n        let ref = account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from: FIND.LeaseStoragePath)!\n        self.pointer= FindLeaseMarket.AuthLeasePointer(ref: ref, name: leaseName)\n        self.vaultType= ft.type\n\n    }\n\n    pre{\n        // Ben : panic on some unreasonable inputs in trxn\n        minimumBidIncrement \u003e 0.0 :\"Minimum bid increment should be larger than 0.\"\n        (auctionReservePrice - auctionReservePrice) % minimumBidIncrement == 0.0 : \"Acution ReservePrice should be in step of minimum bid increment.\"\n        auctionDuration \u003e 0.0 : \"Auction Duration should be greater than 0.\"\n        auctionExtensionOnLateBid \u003e 0.0 : \"Auction Duration should be greater than 0.\"\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        self.saleItems!.listForAuction(pointer: self.pointer, vaultType: self.vaultType, auctionStartPrice: price, auctionReservePrice: auctionReservePrice, auctionDuration: auctionDuration, auctionExtensionOnLateBid: auctionExtensionOnLateBid, minimumBidIncrement: minimumBidIncrement, auctionValidUntil: auctionValidUntil, saleItemExtraField: {})\n\n    }\n}",
               "spec": {
                  "order": [
                     "leaseName",
                     "ftAliasOrIdentifier",
                     "price",
                     "auctionReservePrice",
                     "auctionDuration",
                     "auctionExtensionOnLateBid",
                     "minimumBidIncrement",
                     "auctionValidUntil"
                  ],
                  "parameters": {
                     "auctionDuration": "UFix64",
                     "auctionExtensionOnLateBid": "UFix64",
                     "auctionReservePrice": "UFix64",
                     "auctionValidUntil": "UFix64?",
                     "ftAliasOrIdentifier": "String",
                     "leaseName": "String",
                     "minimumBidIncrement": "UFix64",
                     "price": "UFix64"
                  }
               }
            },
            "listLeaseForAuctionSoftDapper": {
               "code": "import FindMarket from 0x097bafa4e0b48eef\nimport FTRegistry from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\nimport FindLeaseMarketAuctionSoft from 0x097bafa4e0b48eef\nimport FindLeaseMarket from 0x097bafa4e0b48eef\n\ntransaction(leaseName: String, ftAliasOrIdentifier: String, price:UFix64, auctionReservePrice: UFix64, auctionDuration: UFix64, auctionExtensionOnLateBid: UFix64, minimumBidIncrement: UFix64, auctionValidUntil: UFix64?) {\n\n    let saleItems : \u0026FindLeaseMarketAuctionSoft.SaleItemCollection?\n    let pointer : FindLeaseMarket.AuthLeasePointer\n    let vaultType : Type\n\n    prepare(account: AuthAccount) {\n\n        // Get supported NFT and FT Information from Registries from input alias\n        let ft = FTRegistry.getFTInfo(ftAliasOrIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftAliasOrIdentifier))\n\n        let leaseMarketplace = FindMarket.getFindTenantAddress()\n        let leaseTenantCapability= FindMarket.getTenantCapability(leaseMarketplace)!\n        let leaseTenant = leaseTenantCapability.borrow()!\n\n        let leaseASSaleItemType= Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e()\n        let leaseASPublicPath=leaseTenant.getPublicPath(leaseASSaleItemType)\n        let leaseASStoragePath= leaseTenant.getStoragePath(leaseASSaleItemType)\n        let leaseASSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath)\n        if !leaseASSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseASStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath, target: leaseASStoragePath)\n        }\n\n        self.saleItems= account.borrow\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(from: leaseASStoragePath)\n        let ref= account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from: FIND.LeaseStoragePath)!\n        self.pointer= FindLeaseMarket.AuthLeasePointer(ref: ref, name: leaseName)\n        self.vaultType= ft.type\n    }\n\n    pre{\n        // Ben : panic on some unreasonable inputs in trxn\n        minimumBidIncrement \u003e 0.0 :\"Minimum bid increment should be larger than 0.\"\n        (auctionReservePrice - auctionReservePrice) % minimumBidIncrement == 0.0 : \"Acution ReservePrice should be in step of minimum bid increment.\"\n        auctionDuration \u003e 0.0 : \"Auction Duration should be greater than 0.\"\n        auctionExtensionOnLateBid \u003e 0.0 : \"Auction Duration should be greater than 0.\"\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        self.saleItems!.listForAuction(pointer: self.pointer, vaultType: self.vaultType, auctionStartPrice: price, auctionReservePrice: auctionReservePrice, auctionDuration: auctionDuration, auctionExtensionOnLateBid: auctionExtensionOnLateBid, minimumBidIncrement: minimumBidIncrement, auctionValidUntil: auctionValidUntil, saleItemExtraField: {})\n\n    }\n}",
               "spec": {
                  "order": [
                     "leaseName",
                     "ftAliasOrIdentifier",
                     "price",
                     "auctionReservePrice",
                     "auctionDuration",
                     "auctionExtensionOnLateBid",
                     "minimumBidIncrement",
                     "auctionValidUntil"
                  ],
                  "parameters": {
                     "auctionDuration": "UFix64",
                     "auctionExtensionOnLateBid": "UFix64",
                     "auctionReservePrice": "UFix64",
                     "auctionValidUntil": "UFix64?",
                     "ftAliasOrIdentifier": "String",
                     "leaseName": "String",
                     "minimumBidIncrement": "UFix64",
                     "price": "UFix64"
                  }
               }
            },
            "listLeaseForSale": {
               "code": "import FindMarket from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\nimport FTRegistry from 0x097bafa4e0b48eef\nimport FindLeaseMarketSale from 0x097bafa4e0b48eef\nimport FindLeaseMarket from 0x097bafa4e0b48eef\n\ntransaction(leaseName: String, ftAliasOrIdentifier: String, directSellPrice:UFix64, validUntil: UFix64?) {\n\n    let saleItems : \u0026FindLeaseMarketSale.SaleItemCollection?\n    let pointer : FindLeaseMarket.AuthLeasePointer\n    let vaultType : Type\n\n    prepare(account: AuthAccount) {\n\n        // Get the salesItemRef from tenant\n        let leaseMarketplace = FindMarket.getFindTenantAddress()\n        let leaseTenantCapability= FindMarket.getTenantCapability(leaseMarketplace)!\n        let leaseTenant = leaseTenantCapability.borrow()!\n\n        let leaseSaleItemType= Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()\n        let leasePublicPath=leaseTenant.getPublicPath(leaseSaleItemType)\n        let leaseStoragePath= leaseTenant.getStoragePath(leaseSaleItemType)\n        let leaseSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath)\n        if !leaseSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketSale.SaleItemCollection\u003e(\u003c- FindLeaseMarketSale.createEmptySaleItemCollection(leaseTenantCapability), to: leaseStoragePath)\n            account.link\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath, target: leaseStoragePath)\n        }\n\n        self.saleItems= account.borrow\u003c\u0026FindLeaseMarketSale.SaleItemCollection\u003e(from: leaseStoragePath)!\n\n        // Get supported NFT and FT Information from Registries from input alias\n        let ft = FTRegistry.getFTInfo(ftAliasOrIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftAliasOrIdentifier))\n        self.vaultType= ft.type\n\n        let lease=account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from: FIND.LeaseStoragePath)!\n\n\n        self.pointer= FindLeaseMarket.AuthLeasePointer(ref:lease, name: leaseName)\n\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        self.saleItems!.listForSale(pointer: self.pointer, vaultType: self.vaultType, directSellPrice: directSellPrice, validUntil: validUntil, extraField: {})\n    }\n}",
               "spec": {
                  "order": [
                     "leaseName",
                     "ftAliasOrIdentifier",
                     "directSellPrice",
                     "validUntil"
                  ],
                  "parameters": {
                     "directSellPrice": "UFix64",
                     "ftAliasOrIdentifier": "String",
                     "leaseName": "String",
                     "validUntil": "UFix64?"
                  }
               }
            },
            "listLeaseForSaleDapper": {
               "code": "import FindMarket from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\nimport FTRegistry from 0x097bafa4e0b48eef\nimport FindLeaseMarketSale from 0x097bafa4e0b48eef\nimport FindLeaseMarket from 0x097bafa4e0b48eef\n\ntransaction(leaseName: String, ftAliasOrIdentifier: String, directSellPrice:UFix64, validUntil: UFix64?) {\n\n    let saleItems : \u0026FindLeaseMarketSale.SaleItemCollection?\n    let pointer : FindLeaseMarket.AuthLeasePointer\n    let vaultType : Type\n\n    prepare(account: AuthAccount) {\n\n        // Get the salesItemRef from tenant\n        let leaseMarketplace = FindMarket.getFindTenantAddress()\n        let leaseTenantCapability= FindMarket.getTenantCapability(leaseMarketplace)!\n        let leaseTenant = leaseTenantCapability.borrow()!\n\n        let leaseSaleItemType= Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()\n        let leasePublicPath=leaseTenant.getPublicPath(leaseSaleItemType)\n        let leaseStoragePath= leaseTenant.getStoragePath(leaseSaleItemType)\n        let leaseSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath)\n        if !leaseSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketSale.SaleItemCollection\u003e(\u003c- FindLeaseMarketSale.createEmptySaleItemCollection(leaseTenantCapability), to: leaseStoragePath)\n            account.link\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath, target: leaseStoragePath)\n        }\n\n        self.saleItems= account.borrow\u003c\u0026FindLeaseMarketSale.SaleItemCollection\u003e(from: leaseStoragePath)!\n\n        // Get supported NFT and FT Information from Registries from input alias\n        let ft = FTRegistry.getFTInfo(ftAliasOrIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftAliasOrIdentifier))\n        self.vaultType= ft.type\n\n        let ref=account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from: FIND.LeaseStoragePath)!\n\n        self.pointer= FindLeaseMarket.AuthLeasePointer(ref: ref, name: leaseName)\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        self.saleItems!.listForSale(pointer: self.pointer, vaultType: self.vaultType, directSellPrice: directSellPrice, validUntil: validUntil, extraField: {})\n\n    }\n\n}",
               "spec": {
                  "order": [
                     "leaseName",
                     "ftAliasOrIdentifier",
                     "directSellPrice",
                     "validUntil"
                  ],
                  "parameters": {
                     "directSellPrice": "UFix64",
                     "ftAliasOrIdentifier": "String",
                     "leaseName": "String",
                     "validUntil": "UFix64?"
                  }
               }
            },
            "listMultipleNFTForSale": {
               "code": "import FindMarket from 0x097bafa4e0b48eef\nimport FindMarketSale from 0x097bafa4e0b48eef\nimport NonFungibleToken from 0x1d7e57aa55817448\nimport MetadataViews from 0x1d7e57aa55817448\nimport FindViews from 0x097bafa4e0b48eef\nimport NFTCatalog from 0x49a7cda3a1eecc29\nimport FINDNFTCatalog from 0x097bafa4e0b48eef\nimport FTRegistry from 0x097bafa4e0b48eef\n\ntransaction(marketplace:Address, nftAliasOrIdentifiers: [String], ids: [UInt64], ftAliasOrIdentifiers: [String], directSellPrices:[UFix64], validUntil: UFix64?) {\n    \n    let saleItems : \u0026FindMarketSale.SaleItemCollection?\n    let pointers : [FindViews.AuthNFTPointer]\n    let vaultTypes : [Type]\n\n    prepare(account: AuthAccount) {\n\n        if nftAliasOrIdentifiers.length != ids.length {\n            panic(\"The length of arrays passed in has to be the same\")\n        } else if nftAliasOrIdentifiers.length != ftAliasOrIdentifiers.length {\n            panic(\"The length of arrays passed in has to be the same\")\n        } else if nftAliasOrIdentifiers.length != directSellPrices.length {\n            panic(\"The length of arrays passed in has to be the same\")\n        }\n        \n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n        let tenant = tenantCapability.borrow()!\n        self.saleItems= account.borrow\u003c\u0026FindMarketSale.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketSale.SaleItemCollection\u003e()))\n        self.vaultTypes= []\n        self.pointers= []\n\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        var counter = 0\n\n        let nfts : {String : NFTCatalog.NFTCollectionData} = {}\n        let fts : {String : FTRegistry.FTInfo} = {}\n\n        while counter \u003c ids.length {\n            // Get supported NFT and FT Information from Registries from input alias\n            var nft : NFTCatalog.NFTCollectionData? = nil\n            var ft : FTRegistry.FTInfo? = nil\n\n            if nfts[nftAliasOrIdentifiers[counter]] != nil {\n                nft = nfts[nftAliasOrIdentifiers[counter]]\n            } else {\n                let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftAliasOrIdentifiers[counter])?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftAliasOrIdentifiers[counter])) \n                let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n                nft = collection.collectionData\n                nfts[nftAliasOrIdentifiers[counter]] = nft\n            }\n\n            if fts[ftAliasOrIdentifiers[counter]] != nil {\n                ft = fts[ftAliasOrIdentifiers[counter]]\n            } else {\n                ft = FTRegistry.getFTInfo(ftAliasOrIdentifiers[counter]) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftAliasOrIdentifiers[counter]))\n                fts[ftAliasOrIdentifiers[counter]] = ft \n            }\n\n            var providerCap=account.getCapability\u003c\u0026{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e(nft!.privatePath)\n\n            /* Ben : Question -\u003e Either client will have to provide the path here or agree that we set it up for the user */\n            if !providerCap.check() {\n                let newCap = account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                        nft!.privatePath,\n                        target: nft!.storagePath\n                )\n                if newCap == nil {\n                    // If linking is not successful, we link it using finds custom link \n                    let pathIdentifier = nft!.privatePath.toString()\n                    let findPath = PrivatePath(identifier: pathIdentifier.slice(from: \"/private/\".length , upTo: pathIdentifier.length).concat(\"_FIND\"))!\n                    account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                        findPath,\n                        target: nft!.storagePath\n                    )\n                    providerCap = account.getCapability\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(findPath)\n                }\n            }\n            // Get the salesItemRef from tenant\n            self.pointers.append(FindViews.AuthNFTPointer(cap: providerCap, id: ids[counter]))\n            self.vaultTypes.append(ft!.type)\n            counter = counter + 1\n        }\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        var counter = 0\n        while counter \u003c ids.length {\n            self.saleItems!.listForSale(pointer: self.pointers[counter], vaultType: self.vaultTypes[counter], directSellPrice: directSellPrices[counter], validUntil: validUntil, extraField: {})\n            counter = counter + 1\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "nftAliasOrIdentifiers",
                     "ids",
                     "ftAliasOrIdentifiers",
                     "directSellPrices",
                     "validUntil"
                  ],
                  "parameters": {
                     "directSellPrices": "[UFix64]",
                     "ftAliasOrIdentifiers": "[String]",
                     "ids": "[UInt64]",
                     "marketplace": "Address",
                     "nftAliasOrIdentifiers": "[String]",
                     "validUntil": "UFix64?"
                  }
               }
            },
            "listMultipleNFTForSaleDapper": {
               "code": "import FindMarket from 0x097bafa4e0b48eef\nimport FindMarketSale from 0x097bafa4e0b48eef\nimport NonFungibleToken from 0x1d7e57aa55817448\nimport MetadataViews from 0x1d7e57aa55817448\nimport FindViews from 0x097bafa4e0b48eef\nimport NFTCatalog from 0x49a7cda3a1eecc29\nimport FINDNFTCatalog from 0x097bafa4e0b48eef\nimport FTRegistry from 0x097bafa4e0b48eef\n\ntransaction(marketplace:Address, nftAliasOrIdentifiers: [String], ids: [UInt64], ftAliasOrIdentifiers: [String], directSellPrices:[UFix64], validUntil: UFix64?) {\n    \n    let saleItems : \u0026FindMarketSale.SaleItemCollection?\n    let pointers : [FindViews.AuthNFTPointer]\n    let vaultTypes : [Type]\n    \n    prepare(account: AuthAccount) {\n\n        if nftAliasOrIdentifiers.length != ids.length {\n            panic(\"The length of arrays passed in has to be the same\")\n        } else if nftAliasOrIdentifiers.length != directSellPrices.length {\n            panic(\"The length of arrays passed in has to be the same\")\n        }\n\n\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n        let tenant = tenantCapability.borrow()!\n        self.saleItems= account.borrow\u003c\u0026FindMarketSale.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketSale.SaleItemCollection\u003e()))\n        self.pointers= []\n        self.vaultTypes= []\n\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        let nfts : {String : NFTCatalog.NFTCollectionData} = {}\n        let fts : {String : FTRegistry.FTInfo} = {}\n\n        var counter = 0\n        while counter \u003c ids.length {\n            // Get supported NFT and FT Information from Registries from input alias\n            var nft : NFTCatalog.NFTCollectionData? = nil\n\n            if nfts[nftAliasOrIdentifiers[counter]] != nil {\n                nft = nfts[nftAliasOrIdentifiers[counter]]\n            } else {\n                let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftAliasOrIdentifiers[counter])?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftAliasOrIdentifiers[counter])) \n                let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n                nft = collection.collectionData\n                nfts[nftAliasOrIdentifiers[counter]] = nft\n            }\n\n            if fts[ftAliasOrIdentifiers[counter]] != nil {\n                let ft = fts[ftAliasOrIdentifiers[counter]]!\n                self.vaultTypes.append(ft.type)\n            } else {\n                let ft = FTRegistry.getFTInfo(ftAliasOrIdentifiers[counter]) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftAliasOrIdentifiers[counter]))\n                fts[ftAliasOrIdentifiers[counter]] = ft \n                self.vaultTypes.append(ft.type)\n            }\n\n\n\n            var providerCap=account.getCapability\u003c\u0026{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e(nft!.privatePath)\n\n            /* Ben : Question -\u003e Either client will have to provide the path here or agree that we set it up for the user */\n            if !providerCap.check() {\n                let newCap = account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                        nft!.privatePath,\n                        target: nft!.storagePath\n                )\n                if newCap == nil {\n                    // If linking is not successful, we link it using finds custom link \n                    let pathIdentifier = nft!.privatePath.toString()\n                    let findPath = PrivatePath(identifier: pathIdentifier.slice(from: \"/private/\".length , upTo: pathIdentifier.length).concat(\"_FIND\"))!\n                    account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                        findPath,\n                        target: nft!.storagePath\n                    )\n                    providerCap = account.getCapability\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(findPath)\n                }\n            }\n            // Get the salesItemRef from tenant\n            self.pointers.append(FindViews.AuthNFTPointer(cap: providerCap, id: ids[counter]))\n            counter = counter + 1\n        }\n\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        var counter = 0\n        while counter \u003c ids.length {\n            self.saleItems!.listForSale(pointer: self.pointers[counter], vaultType: self.vaultTypes[counter], directSellPrice: directSellPrices[counter], validUntil: validUntil, extraField: {})\n            counter = counter + 1\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "nftAliasOrIdentifiers",
                     "ids",
                     "ftAliasOrIdentifiers",
                     "directSellPrices",
                     "validUntil"
                  ],
                  "parameters": {
                     "directSellPrices": "[UFix64]",
                     "ftAliasOrIdentifiers": "[String]",
                     "ids": "[UInt64]",
                     "marketplace": "Address",
                     "nftAliasOrIdentifiers": "[String]",
                     "validUntil": "UFix64?"
                  }
               }
            },
            "listNFTForAuctionEscrowed": {
               "code": "import FindMarket from 0x097bafa4e0b48eef\nimport FindMarketAuctionEscrow from 0x097bafa4e0b48eef\nimport NonFungibleToken from 0x1d7e57aa55817448\nimport MetadataViews from 0x1d7e57aa55817448\nimport FindViews from 0x097bafa4e0b48eef\nimport FINDNFTCatalog from 0x097bafa4e0b48eef\nimport FTRegistry from 0x097bafa4e0b48eef\n\ntransaction(marketplace:Address, nftAliasOrIdentifier:String, id: UInt64, ftAliasOrIdentifier:String, price:UFix64, auctionReservePrice: UFix64, auctionDuration: UFix64, auctionExtensionOnLateBid: UFix64, minimumBidIncrement: UFix64, auctionStartTime: UFix64?, auctionValidUntil: UFix64?) {\n    \n    let saleItems : \u0026FindMarketAuctionEscrow.SaleItemCollection?\n    let vaultType : Type\n    let pointer : FindViews.AuthNFTPointer\n    \n    prepare(account: AuthAccount) {\n\n\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n        let tenant = tenantCapability.borrow()!\n        let path=FindMarket.getStoragePath(Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(), name: tenant.name)\n\n        /// auctions that escrow ft\n        let aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        let aeSalePublicPath=FindMarket.getPublicPath(aeSaleType, name: tenant.name)\n        let aeSaleStoragePath= FindMarket.getStoragePath(aeSaleType, name:tenant.name)\n        let aeSaleCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n        if !aeSaleCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n        }\n\n        // Get supported NFT and FT Information from Registries from input alias\n        let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftAliasOrIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftAliasOrIdentifier)) \n        let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n        let nft = collection.collectionData\n\n        let ft = FTRegistry.getFTInfo(ftAliasOrIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftAliasOrIdentifier))\n\n        var providerCap=account.getCapability\u003c\u0026{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e(nft.privatePath)\n        \n        /* Ben : Question -\u003e Either client will have to provide the path here or agree that we set it up for the user */\n        if !providerCap.check() {\n            let newCap = account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                    nft.privatePath,\n                    target: nft.storagePath\n            )\n            if newCap == nil {\n                // If linking is not successful, we link it using finds custom link \n                let pathIdentifier = nft.privatePath.toString()\n                let findPath = PrivatePath(identifier: pathIdentifier.slice(from: \"/private/\".length , upTo: pathIdentifier.length).concat(\"_FIND\"))!\n                account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                    findPath,\n                    target: nft.storagePath\n                )\n                providerCap = account.getCapability\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(findPath)\n            }\n        }\n\n        self.saleItems= account.borrow\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection\u003e(from: path)\n        self.pointer= FindViews.AuthNFTPointer(cap: providerCap, id: id)\n        self.vaultType= ft.type\n    }\n\n    pre{\n        // Ben : panic on some unreasonable inputs in trxn \n        minimumBidIncrement \u003e 0.0 : \"Minimum bid increment should be larger than 0.\"\n        (auctionReservePrice - auctionReservePrice) % minimumBidIncrement == 0.0 : \"Acution ReservePrice should be in step of minimum bid increment.\" \n        auctionDuration \u003e 0.0 : \"Auction Duration should be greater than 0.\"\n        auctionExtensionOnLateBid \u003e 0.0 : \"Auction Duration should be greater than 0.\"\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute {\n        self.saleItems!.listForAuction(pointer: self.pointer, vaultType: self.vaultType, auctionStartPrice: price, auctionReservePrice: auctionReservePrice, auctionDuration: auctionDuration, auctionExtensionOnLateBid: auctionExtensionOnLateBid, minimumBidIncrement: minimumBidIncrement, auctionStartTime: auctionStartTime, auctionValidUntil:auctionValidUntil, saleItemExtraField: {})\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "nftAliasOrIdentifier",
                     "id",
                     "ftAliasOrIdentifier",
                     "price",
                     "auctionReservePrice",
                     "auctionDuration",
                     "auctionExtensionOnLateBid",
                     "minimumBidIncrement",
                     "auctionStartTime",
                     "auctionValidUntil"
                  ],
                  "parameters": {
                     "auctionDuration": "UFix64",
                     "auctionExtensionOnLateBid": "UFix64",
                     "auctionReservePrice": "UFix64",
                     "auctionStartTime": "UFix64?",
                     "auctionValidUntil": "UFix64?",
                     "ftAliasOrIdentifier": "String",
                     "id": "UInt64",
                     "marketplace": "Address",
                     "minimumBidIncrement": "UFix64",
                     "nftAliasOrIdentifier": "String",
                     "price": "UFix64"
                  }
               }
            },
            "listNFTForAuctionSoft": {
               "code": "import FindMarket from 0x097bafa4e0b48eef\nimport FindMarketAuctionSoft from 0x097bafa4e0b48eef\nimport NonFungibleToken from 0x1d7e57aa55817448\nimport MetadataViews from 0x1d7e57aa55817448\nimport FindViews from 0x097bafa4e0b48eef\nimport FTRegistry from 0x097bafa4e0b48eef\nimport FINDNFTCatalog from 0x097bafa4e0b48eef\n\ntransaction(marketplace:Address, nftAliasOrIdentifier:String, id: UInt64, ftAliasOrIdentifier:String, price:UFix64, auctionReservePrice: UFix64, auctionDuration: UFix64, auctionExtensionOnLateBid: UFix64, minimumBidIncrement: UFix64, auctionValidUntil: UFix64?) {\n    \n    let saleItems : \u0026FindMarketAuctionSoft.SaleItemCollection?\n    let pointer : FindViews.AuthNFTPointer\n    let vaultType : Type\n    \n    prepare(account: AuthAccount) {\n\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n        let tenant = tenantCapability.borrow()!\n\n         /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n        }\n\n        // Get supported NFT and FT Information from Registries from input alias\n        let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftAliasOrIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftAliasOrIdentifier)) \n        let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n        let nft = collection.collectionData\n\n        let ft = FTRegistry.getFTInfo(ftAliasOrIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftAliasOrIdentifier))\n\n        var providerCap = account.getCapability\u003c\u0026{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e(nft.privatePath)\n\n        /* Ben : Question -\u003e Either client will have to provide the path here or agree that we set it up for the user */\n        if !providerCap.check() {\n            let newCap = account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                    nft.privatePath,\n                    target: nft.storagePath\n            )\n            if newCap == nil {\n                // If linking is not successful, we link it using finds custom link \n                let pathIdentifier = nft.privatePath.toString()\n                let findPath = PrivatePath(identifier: pathIdentifier.slice(from: \"/private/\".length , upTo: pathIdentifier.length).concat(\"_FIND\"))!\n                account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                    findPath,\n                    target: nft.storagePath\n                )\n                providerCap = account.getCapability\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(findPath)\n            }\n        }\n        \n        self.saleItems= account.borrow\u003c\u0026FindMarketAuctionSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()))\n        self.pointer= FindViews.AuthNFTPointer(cap: providerCap, id: id)\n        self.vaultType= ft.type\n\n        \n\n    }\n\n    pre{\n        // Ben : panic on some unreasonable inputs in trxn \n        minimumBidIncrement \u003e 0.0 :\"Minimum bid increment should be larger than 0.\"\n        (auctionReservePrice - auctionReservePrice) % minimumBidIncrement == 0.0 : \"Acution ReservePrice should be in step of minimum bid increment.\" \n        auctionDuration \u003e 0.0 : \"Auction Duration should be greater than 0.\"\n        auctionExtensionOnLateBid \u003e 0.0 : \"Auction Duration should be greater than 0.\"\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        self.saleItems!.listForAuction(pointer: self.pointer, vaultType: self.vaultType, auctionStartPrice: price, auctionReservePrice: auctionReservePrice, auctionDuration: auctionDuration, auctionExtensionOnLateBid: auctionExtensionOnLateBid, minimumBidIncrement: minimumBidIncrement, auctionValidUntil: auctionValidUntil, saleItemExtraField: {})\n\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "nftAliasOrIdentifier",
                     "id",
                     "ftAliasOrIdentifier",
                     "price",
                     "auctionReservePrice",
                     "auctionDuration",
                     "auctionExtensionOnLateBid",
                     "minimumBidIncrement",
                     "auctionValidUntil"
                  ],
                  "parameters": {
                     "auctionDuration": "UFix64",
                     "auctionExtensionOnLateBid": "UFix64",
                     "auctionReservePrice": "UFix64",
                     "auctionValidUntil": "UFix64?",
                     "ftAliasOrIdentifier": "String",
                     "id": "UInt64",
                     "marketplace": "Address",
                     "minimumBidIncrement": "UFix64",
                     "nftAliasOrIdentifier": "String",
                     "price": "UFix64"
                  }
               }
            },
            "listNFTForAuctionSoftDapper": {
               "code": "import FindMarket from 0x097bafa4e0b48eef\nimport FindMarketAuctionSoft from 0x097bafa4e0b48eef\nimport NonFungibleToken from 0x1d7e57aa55817448\nimport MetadataViews from 0x1d7e57aa55817448\nimport FindViews from 0x097bafa4e0b48eef\nimport FINDNFTCatalog from 0x097bafa4e0b48eef\nimport FTRegistry from 0x097bafa4e0b48eef\n\ntransaction(marketplace:Address, nftAliasOrIdentifier:String, id: UInt64, ftAliasOrIdentifier:String, price:UFix64, auctionReservePrice: UFix64, auctionDuration: UFix64, auctionExtensionOnLateBid: UFix64, minimumBidIncrement: UFix64, auctionValidUntil: UFix64?) {\n    \n    let saleItems : \u0026FindMarketAuctionSoft.SaleItemCollection?\n    let pointer : FindViews.AuthNFTPointer\n    let vaultType : Type\n    \n    prepare(account: AuthAccount) {\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n        let tenant = tenantCapability.borrow()!\n\n         /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n        }\n\n        // Get supported NFT and FT Information from Registries from input alias\n        let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftAliasOrIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftAliasOrIdentifier)) \n        let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n        let nft = collection.collectionData\n\n        let ft = FTRegistry.getFTInfo(ftAliasOrIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftAliasOrIdentifier))\n\n        var providerCap = account.getCapability\u003c\u0026{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e(nft.privatePath)\n\n        /* Ben : Question -\u003e Either client will have to provide the path here or agree that we set it up for the user */\n        if !providerCap.check() {\n            let newCap = account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                    nft.privatePath,\n                    target: nft.storagePath\n            )\n            if newCap == nil {\n                // If linking is not successful, we link it using finds custom link \n                let pathIdentifier = nft.privatePath.toString()\n                let findPath = PrivatePath(identifier: pathIdentifier.slice(from: \"/private/\".length , upTo: pathIdentifier.length).concat(\"_FIND\"))!\n                account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                    findPath,\n                    target: nft.storagePath\n                )\n                providerCap = account.getCapability\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(findPath)\n            }\n        }\n        \n\n        self.saleItems= account.borrow\u003c\u0026FindMarketAuctionSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()))\n        self.pointer= FindViews.AuthNFTPointer(cap: providerCap, id: id)    \n        self.vaultType= ft.type    \n    }\n\n    pre{\n        // Ben : panic on some unreasonable inputs in trxn \n        minimumBidIncrement \u003e 0.0 :\"Minimum bid increment should be larger than 0.\"\n        (auctionReservePrice - auctionReservePrice) % minimumBidIncrement == 0.0 : \"Acution ReservePrice should be in step of minimum bid increment.\" \n        auctionDuration \u003e 0.0 : \"Auction Duration should be greater than 0.\"\n        auctionExtensionOnLateBid \u003e 0.0 : \"Auction Duration should be greater than 0.\"\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        self.saleItems!.listForAuction(pointer: self.pointer, vaultType: self.vaultType, auctionStartPrice: price, auctionReservePrice: auctionReservePrice, auctionDuration: auctionDuration, auctionExtensionOnLateBid: auctionExtensionOnLateBid, minimumBidIncrement: minimumBidIncrement, auctionValidUntil: auctionValidUntil, saleItemExtraField: {})\n\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "nftAliasOrIdentifier",
                     "id",
                     "ftAliasOrIdentifier",
                     "price",
                     "auctionReservePrice",
                     "auctionDuration",
                     "auctionExtensionOnLateBid",
                     "minimumBidIncrement",
                     "auctionValidUntil"
                  ],
                  "parameters": {
                     "auctionDuration": "UFix64",
                     "auctionExtensionOnLateBid": "UFix64",
                     "auctionReservePrice": "UFix64",
                     "auctionValidUntil": "UFix64?",
                     "ftAliasOrIdentifier": "String",
                     "id": "UInt64",
                     "marketplace": "Address",
                     "minimumBidIncrement": "UFix64",
                     "nftAliasOrIdentifier": "String",
                     "price": "UFix64"
                  }
               }
            },
            "listNFTForSale": {
               "code": "import FindMarket from 0x097bafa4e0b48eef\nimport FindMarketSale from 0x097bafa4e0b48eef\nimport NonFungibleToken from 0x1d7e57aa55817448\nimport MetadataViews from 0x1d7e57aa55817448\nimport FindViews from 0x097bafa4e0b48eef\nimport FINDNFTCatalog from 0x097bafa4e0b48eef\nimport FTRegistry from 0x097bafa4e0b48eef\n\ntransaction(marketplace:Address, nftAliasOrIdentifier: String, id: UInt64, ftAliasOrIdentifier: String, directSellPrice:UFix64, validUntil: UFix64?) {\n\n    let saleItems : \u0026FindMarketSale.SaleItemCollection?\n    let pointer : FindViews.AuthNFTPointer\n    let vaultType : Type\n\n    prepare(account: AuthAccount) {\n\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath)\n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n        // Get supported NFT and FT Information from Registries from input alias\n        let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier:nftAliasOrIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftAliasOrIdentifier))\n        let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])!\n        let nft = collection.collectionData\n\n        let ft = FTRegistry.getFTInfo(ftAliasOrIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftAliasOrIdentifier))\n\n        var providerCap=account.getCapability\u003c\u0026{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e(nft.privatePath)\n\n        /* Ben : Question -\u003e Either client will have to provide the path here or agree that we set it up for the user */\n        if !providerCap.check() {\n            let newCap = account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                nft.privatePath,\n                target: nft.storagePath\n            )\n            if newCap == nil {\n                // If linking is not successful, we link it using finds custom link\n                let pathIdentifier = nft.privatePath.toString()\n                let findPath = PrivatePath(identifier: pathIdentifier.slice(from: \"/private/\".length , upTo: pathIdentifier.length).concat(\"_FIND\"))!\n                account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                    findPath,\n                    target: nft.storagePath\n                )\n                providerCap = account.getCapability\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(findPath)\n            }\n        }\n        // Get the salesItemRef from tenant\n        self.saleItems= account.borrow\u003c\u0026FindMarketSale.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketSale.SaleItemCollection\u003e()))\n        self.pointer= FindViews.AuthNFTPointer(cap: providerCap, id: id)\n        self.vaultType= ft.type\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        self.saleItems!.listForSale(pointer: self.pointer, vaultType: self.vaultType, directSellPrice: directSellPrice, validUntil: validUntil, extraField: {})\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "nftAliasOrIdentifier",
                     "id",
                     "ftAliasOrIdentifier",
                     "directSellPrice",
                     "validUntil"
                  ],
                  "parameters": {
                     "directSellPrice": "UFix64",
                     "ftAliasOrIdentifier": "String",
                     "id": "UInt64",
                     "marketplace": "Address",
                     "nftAliasOrIdentifier": "String",
                     "validUntil": "UFix64?"
                  }
               }
            },
            "listNFTForSaleDapper": {
               "code": "import FindMarket from 0x097bafa4e0b48eef\nimport FindMarketSale from 0x097bafa4e0b48eef\nimport FINDNFTCatalog from 0x097bafa4e0b48eef\nimport FTRegistry from 0x097bafa4e0b48eef\nimport FindViews from 0x097bafa4e0b48eef\nimport NonFungibleToken from 0x1d7e57aa55817448\nimport MetadataViews from 0x1d7e57aa55817448\nimport FlowUtilityToken from 0xead892083b3e2c6c\nimport TokenForwarding from 0xe544175ee0461c4b\nimport FungibleToken from 0xf233dcee88fe0abe\n\ntransaction(marketplace:Address, nftAliasOrIdentifier: String, id: UInt64, ftAliasOrIdentifier: String, directSellPrice:UFix64, validUntil: UFix64?) {\n    \n    let saleItems : \u0026FindMarketSale.SaleItemCollection?\n    let pointer : FindViews.AuthNFTPointer\n    let vaultType : Type\n    \n    prepare(account: AuthAccount) {\n\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n\n        let tenant = tenantCapability.borrow()!\n\n        //TODO:how do we fix this on testnet/mainnet\n        let dapper=getAccount(FindViews.getDapperAddress())\n\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        // Get supported NFT and FT Information from Registries from input alias\n        let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftAliasOrIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftAliasOrIdentifier)) \n        let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n        let nft = collection.collectionData\n\n        let ft = FTRegistry.getFTInfo(ftAliasOrIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftAliasOrIdentifier))\n\n        let futReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowUtilityTokenReceiver)\n        if ft.type == Type\u003c@FlowUtilityToken.Vault\u003e() \u0026\u0026 !futReceiver.check() {\n            // Create a new Forwarder resource for FUT and store it in the new account's storage\n            let futForwarder \u003c- TokenForwarding.createNewForwarder(recipient: dapper.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowUtilityTokenReceiver))\n            account.save(\u003c-futForwarder, to: /storage/flowUtilityTokenVault)\n            // Publish a Receiver capability for the new account, which is linked to the FUT Forwarder\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowUtilityTokenReceiver,target: /storage/flowUtilityTokenVault)\n        }\n\n\n        let providerCap=account.getCapability\u003c\u0026{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e(nft.privatePath)\n\n        if !providerCap.check() {\n            account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                nft.privatePath,\n                target: nft.storagePath\n            )\n        }\n        // Get the salesItemRef from tenant\n        self.saleItems= account.borrow\u003c\u0026FindMarketSale.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketSale.SaleItemCollection\u003e()))\n        self.pointer= FindViews.AuthNFTPointer(cap: providerCap, id: id)\n        self.vaultType= ft.type\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        self.saleItems!.listForSale(pointer: self.pointer, vaultType: self.vaultType, directSellPrice: directSellPrice, validUntil: validUntil, extraField: {})\n\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "nftAliasOrIdentifier",
                     "id",
                     "ftAliasOrIdentifier",
                     "directSellPrice",
                     "validUntil"
                  ],
                  "parameters": {
                     "directSellPrice": "UFix64",
                     "ftAliasOrIdentifier": "String",
                     "id": "UInt64",
                     "marketplace": "Address",
                     "nftAliasOrIdentifier": "String",
                     "validUntil": "UFix64?"
                  }
               }
            },
            "listNameForAuction": {
               "code": "import FIND from 0x097bafa4e0b48eef\n\ntransaction(name: String, auctionStartPrice: UFix64, auctionReservePrice: UFix64, auctionDuration: UFix64, auctionExtensionOnLateBid: UFix64) {\n    \n    let finLeases : \u0026FIND.LeaseCollection?\n\n    prepare(acct: AuthAccount) {\n        self.finLeases= acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)\n    }\n\n    pre{\n        self.finLeases != nil : \"Cannot borrow reference to find lease collection\"\n    }\n\n    execute{\n        self.finLeases!.listForAuction(name: name, auctionStartPrice: auctionStartPrice, auctionReservePrice: auctionReservePrice, auctionDuration: auctionDuration,  auctionExtensionOnLateBid: auctionExtensionOnLateBid)\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "auctionStartPrice",
                     "auctionReservePrice",
                     "auctionDuration",
                     "auctionExtensionOnLateBid"
                  ],
                  "parameters": {
                     "auctionDuration": "UFix64",
                     "auctionExtensionOnLateBid": "UFix64",
                     "auctionReservePrice": "UFix64",
                     "auctionStartPrice": "UFix64",
                     "name": "String"
                  }
               }
            },
            "listNameForSale": {
               "code": "import FIND from 0x097bafa4e0b48eef\n\ntransaction(name: String, directSellPrice:UFix64) {\n\n    let finLeases : \u0026FIND.LeaseCollection?\n\n    prepare(acct: AuthAccount) {\n        self.finLeases= acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)\n    }\n\n    pre{\n        self.finLeases != nil : \"Cannot borrow reference to find lease collection\"\n    }\n\n    execute{\n        self.finLeases!.listForSale(name: name,  directSellPrice:directSellPrice)\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "directSellPrice"
                  ],
                  "parameters": {
                     "directSellPrice": "UFix64",
                     "name": "String"
                  }
               }
            },
            "moveNameTO": {
               "code": "import Profile from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\n\n\ntransaction(name: String, receiver:String) {\n\n\n    let receiverAddress:Address?\n    let sender : \u0026FIND.LeaseCollection\n\n    prepare(acct: AuthAccount) {\n        self.sender= acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath) ?? panic(\"You do not have a profile set up, initialize the user first\")\n        self.receiverAddress=FIND.resolve(receiver)\n    } \n\n    pre{\n        self.receiverAddress != nil : \"The input pass in is not a valid name or address. Input : \".concat(receiver)\n    }\n\n    execute {\n        let receiver=getAccount(self.receiverAddress!)\n        let receiverLease = receiver.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        let receiverProfile = receiver.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\n        if !receiverLease.check() || !receiverProfile.check() {\n            panic(\"Not a valid FIND user\")\n        }\n\n        self.sender.move(name:name, profile:receiverProfile, to: receiverLease)\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "receiver"
                  ],
                  "parameters": {
                     "name": "String",
                     "receiver": "String"
                  }
               }
            },
            "moveNameToDapper": {
               "code": "import Profile from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\n\n\ntransaction(name: String, receiver:String) {\n\n\n    let receiverAddress:Address?\n    let sender : \u0026FIND.LeaseCollection\n\n    prepare(acct: AuthAccount) {\n        self.sender= acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath) ?? panic(\"You do not have a profile set up, initialize the user first\")\n        self.receiverAddress=FIND.resolve(receiver)\n    } \n\n    pre{\n        self.receiverAddress != nil : \"The input pass in is not a valid name or address. Input : \".concat(receiver)\n    }\n\n    execute {\n        let receiver=getAccount(self.receiverAddress!)\n        let receiverLease = receiver.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        let receiverProfile = receiver.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\n        if !receiverLease.check() || !receiverProfile.check() {\n            panic(\"Not a valid FIND user\")\n        }\n\n        self.sender.move(name:name, profile:receiverProfile, to: receiverLease)\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "receiver"
                  ],
                  "parameters": {
                     "name": "String",
                     "receiver": "String"
                  }
               }
            },
            "openBl0xPack": {
               "code": "import Bl0x from 0x7620acf6d7f2468a\nimport Bl0xPack from 0x7620acf6d7f2468a\nimport FungibleToken from 0xf233dcee88fe0abe\nimport NonFungibleToken from 0x1d7e57aa55817448\nimport MetadataViews from 0x1d7e57aa55817448\n\n/// A transaction to open a pack with a given id\n/// @param packId: The id of the pack to open\ntransaction(packId:UInt64) {\n\n    let packs: \u0026Bl0xPack.Collection\n    var receiver: Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e\n\n    prepare(account: AuthAccount) {\n        self.packs=account.borrow\u003c\u0026Bl0xPack.Collection\u003e(from: Bl0xPack.CollectionStoragePath)!\n        self.receiver = account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(Bl0x.CollectionPublicPath)\n        if !self.receiver.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Bl0x.createEmptyCollection(), to: Bl0x.CollectionStoragePath)\n            account.link\u003c\u0026Bl0x.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                Bl0x.CollectionPublicPath,\n                target: Bl0x.CollectionStoragePath\n            )\n            account.link\u003c\u0026Bl0x.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                Bl0x.CollectionPrivatePath,\n                target: Bl0x.CollectionStoragePath\n            )\n\n            self.receiver = account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(Bl0x.CollectionPublicPath)\n        }\n\n    }\n\n    pre {\n        self.receiver.check() : \"The receiver collection for the packs is not set up properly\"\n    }\n    execute {\n        self.packs.open(packId: packId, receiverCap:self.receiver)\n    }\n\n    post {\n        !self.packs.getIDs().contains(packId) : \"The pack is still present in the users collection\"\n    }\n}",
               "spec": {
                  "order": [
                     "packId"
                  ],
                  "parameters": {
                     "packId": "UInt64"
                  }
               }
            },
            "openFindPack": {
               "code": "import FindPack from 0x097bafa4e0b48eef\nimport FINDNFTCatalog from 0x097bafa4e0b48eef\nimport NFTCatalog from 0x49a7cda3a1eecc29\nimport FungibleToken from 0xf233dcee88fe0abe\nimport NonFungibleToken from 0x1d7e57aa55817448\nimport MetadataViews from 0x1d7e57aa55817448\n\n/// A transaction to open a pack with a given id\n/// @param packId: The id of the pack to open\ntransaction(packId:UInt64) {\n\n    let packs: \u0026FindPack.Collection\n    let receiver: { Type : Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e}\n\n    prepare(account: AuthAccount) {\n        self.packs=account.borrow\u003c\u0026FindPack.Collection\u003e(from: FindPack.CollectionStoragePath)!\n\n        let packData = self.packs.borrowFindPack(id: packId) ?? panic(\"You do not own this pack. ID : \".concat(packId.toString()))\n        let packMetadata = packData.getMetadata()\n        let types = packMetadata.itemTypes\n\n        self.receiver = {}\n\n        // check the account setup for receiving nfts\n        for type in types {\n            let collection = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: type.identifier)\n            if collection == nil || collection!.length == 0 {\n                panic(\"Type : \".concat(type.identifier).concat(\" is not supported in NFTCatalog at the moment\"))\n            }\n            let collectionInfo = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collection!.keys[0])!.collectionData\n\n            let cap = account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(collectionInfo.publicPath)\n            if !cap.check() {\n                let newCollection \u003c- FindPack.createEmptyCollectionFromPackData(packData: packMetadata, type: type)\n                account.save(\u003c- newCollection, to: collectionInfo.storagePath)\n                account.link\u003c\u0026{NonFungibleToken.Receiver, NonFungibleToken.CollectionPublic, MetadataViews.ResolverCollection}\u003e(\n                    collectionInfo.publicPath, target: collectionInfo.storagePath)\n            }\n            self.receiver[type] = cap\n        }\n\n    }\n\n    execute {\n        self.packs.open(packId: packId, receiverCap:self.receiver)\n    }\n\n    post {\n        !self.packs.getIDs().contains(packId) : \"The pack is still present in the users collection\"\n    }\n}",
               "spec": {
                  "order": [
                     "packId"
                  ],
                  "parameters": {
                     "packId": "UInt64"
                  }
               }
            },
            "orderForge": {
               "code": "import FindForge from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\nimport MetadataViews from 0x1d7e57aa55817448\n\n\ntransaction(name: String, mintType:String, minterCut: UFix64, collectionDisplay: MetadataViews.NFTCollectionDisplay) {\n\n    let leases : \u0026FIND.LeaseCollection?\n\n    prepare(account: AuthAccount) {\n\n        self.leases= account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)\n\n    }\n\n    pre{\n        self.leases != nil : \"Could not borrow reference to the leases collection\"\n    }\n\n    execute {\n        let lease = self.leases!.borrow(name)\n        var mintCut : UFix64? = minterCut\n        if minterCut == 0.0 {\n            mintCut = nil\n        } \n        FindForge.orderForge(lease: lease, mintType: mintType, minterCut: mintCut, collectionDisplay: collectionDisplay)\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "mintType",
                     "minterCut",
                     "collectionDisplay"
                  ],
                  "parameters": {
                     "collectionDisplay": "MetadataViews.NFTCollectionDisplay",
                     "mintType": "String",
                     "minterCut": "UFix64",
                     "name": "String"
                  }
               }
            },
            "publishFindThought": {
               "code": "import MetadataViews from 0x1d7e57aa55817448\nimport FindThoughts from 0x097bafa4e0b48eef\nimport FINDNFTCatalog from 0x097bafa4e0b48eef\nimport FindViews from 0x097bafa4e0b48eef\nimport FindUtils from 0x097bafa4e0b48eef\n\ntransaction(header: String , body: String , tags: [String], mediaHash: String?, mediaType: String?, quoteNFTOwner: Address?, quoteNFTType: String?, quoteNFTId: UInt64?, quoteCreator: Address?, quoteId: UInt64?) {\n\n    let collection : \u0026FindThoughts.Collection\n\n    prepare(account: AuthAccount) {\n        let thoughtsCap= account.getCapability\u003c\u0026{FindThoughts.CollectionPublic}\u003e(FindThoughts.CollectionPublicPath)\n        if !thoughtsCap.check() {\n            account.save(\u003c- FindThoughts.createEmptyCollection(), to: FindThoughts.CollectionStoragePath)\n            account.link\u003c\u0026FindThoughts.Collection{FindThoughts.CollectionPublic , MetadataViews.ResolverCollection}\u003e(\n                FindThoughts.CollectionPublicPath,\n                target: FindThoughts.CollectionStoragePath\n            )\n        }\n        self.collection=account.borrow\u003c\u0026FindThoughts.Collection\u003e(from: FindThoughts.CollectionStoragePath) ?? panic(\"Cannot borrow thoughts reference from path\")\n    }\n\n    execute {\n\n        var media : MetadataViews.Media? = nil \n        if mediaHash != nil {\n            var file : {MetadataViews.File}? = nil  \n            if FindUtils.hasPrefix(mediaHash!, prefix: \"ipfs://\") {\n                file = MetadataViews.IPFSFile(cid: mediaHash!.slice(from: \"ipfs://\".length , upTo: mediaHash!.length), path: nil) \n            } else {\n                file = MetadataViews.HTTPFile(url: mediaHash!) \n            }\n            media = MetadataViews.Media(file: file!, mediaType: mediaType!)\n        }\n\n        var nftPointer : FindViews.ViewReadPointer? = nil \n        if quoteNFTOwner != nil {\n                let path = FINDNFTCatalog.getCollectionDataForType(nftTypeIdentifier: quoteNFTType!)?.publicPath ?? panic(\"This nft type is not supported by NFT Catalog. Type : \".concat(quoteNFTType!))\n                let cap = getAccount(quoteNFTOwner!).getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(path)\n                nftPointer = FindViews.ViewReadPointer(cap: cap, id: quoteNFTId!)\n        }\n\n        var quote : FindThoughts.ThoughtPointer? = nil \n        if quoteCreator != nil {\n            quote = FindThoughts.ThoughtPointer(creator: quoteCreator!, id: quoteId!)\n        }\n\n        self.collection.publish(header: header, body: body, tags: tags, media: media, nftPointer: nftPointer, quote: quote)\n    }\n}",
               "spec": {
                  "order": [
                     "header",
                     "body",
                     "tags",
                     "mediaHash",
                     "mediaType",
                     "quoteNFTOwner",
                     "quoteNFTType",
                     "quoteNFTId",
                     "quoteCreator",
                     "quoteId"
                  ],
                  "parameters": {
                     "body": "String",
                     "header": "String",
                     "mediaHash": "String?",
                     "mediaType": "String?",
                     "quoteCreator": "Address?",
                     "quoteId": "UInt64?",
                     "quoteNFTId": "UInt64?",
                     "quoteNFTOwner": "Address?",
                     "quoteNFTType": "String?",
                     "tags": "[String]"
                  }
               }
            },
            "reactToFindThoughts": {
               "code": "import MetadataViews from 0x1d7e57aa55817448\nimport FindThoughts from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\n\ntransaction(users: [String], ids: [UInt64] , reactions: [String], undoReactionUsers: [String], undoReactionIds: [UInt64]) {\n\n    let collection : \u0026FindThoughts.Collection\n\n    prepare(account: AuthAccount) {\n        let thoughtsCap= account.getCapability\u003c\u0026{FindThoughts.CollectionPublic}\u003e(FindThoughts.CollectionPublicPath)\n        if !thoughtsCap.check() {\n            account.save(\u003c- FindThoughts.createEmptyCollection(), to: FindThoughts.CollectionStoragePath)\n            account.link\u003c\u0026FindThoughts.Collection{FindThoughts.CollectionPublic , MetadataViews.ResolverCollection}\u003e(\n                FindThoughts.CollectionPublicPath,\n                target: FindThoughts.CollectionStoragePath\n            )\n        }\n        self.collection=account.borrow\u003c\u0026FindThoughts.Collection\u003e(from: FindThoughts.CollectionStoragePath) ?? panic(\"Cannot borrow thoughts reference from path\")\n    }\n\n    execute {\n        for i, user in users {\n            let address = FIND.resolve(user) ?? panic(\"Cannot resolve user : \".concat(user))\n            self.collection.react(user: address, id: ids[i], reaction: reactions[i])\n        }\n\n        for i, user in undoReactionUsers {\n            let address = FIND.resolve(user) ?? panic(\"Cannot resolve user : \".concat(user))\n            self.collection.react(user: address, id: undoReactionIds[i], reaction: nil)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "users",
                     "ids",
                     "reactions",
                     "undoReactionUsers",
                     "undoReactionIds"
                  ],
                  "parameters": {
                     "ids": "[UInt64]",
                     "reactions": "[String]",
                     "undoReactionIds": "[UInt64]",
                     "undoReactionUsers": "[String]",
                     "users": "[String]"
                  }
               }
            },
            "redeemAllLostAndFoundNFTs": {
               "code": "import FindLostAndFoundWrapper from 0x097bafa4e0b48eef\nimport LostAndFound from 0x473d6a2c37eab5be\nimport FINDNFTCatalog from 0x097bafa4e0b48eef\nimport NFTCatalog from 0x49a7cda3a1eecc29\nimport NonFungibleToken from 0x1d7e57aa55817448\nimport MetadataViews from 0x1d7e57aa55817448\nimport FIND from 0x097bafa4e0b48eef\n\n//IMPORT\n\ntransaction() {\n\n    let ids : {String : [UInt64]}\n    let nftInfos : {String : NFTCatalog.NFTCollectionData}\n    let receiverAddress : Address\n\n    prepare(account: AuthAccount){\n\n        //LINK\n\n\n        self.nftInfos = {}\n        self.ids = FindLostAndFoundWrapper.getTicketIDs(user: account.address, specificType: Type\u003c@NonFungibleToken.NFT\u003e())\n\n        for type in self.ids.keys{ \n            if self.nftInfos[type] == nil {\n                let collections = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: type) ?? panic(\"NFT type is not supported at the moment. Type : \".concat(type))\n                self.nftInfos[type] = FINDNFTCatalog.getCatalogEntry(collectionIdentifier: collections.keys[0])!.collectionData\n            }\n        }\n\n        self.receiverAddress = account.address\n    }\n\n    execute{\n        for type in self.ids.keys{ \n            let path = self.nftInfos[type]!.publicPath\n            for id in self.ids[type]! {\n                FindLostAndFoundWrapper.redeemNFT(type: CompositeType(type)!, ticketID: id, receiverAddress: self.receiverAddress, collectionPublicPath: path)\n            }\n        }\n    }\n}",
               "spec": {
                  "order": [],
                  "parameters": {}
               }
            },
            "redeemAllLostAndFoundNFTsOnBehalf": {
               "code": "import FindLostAndFoundWrapper from 0x097bafa4e0b48eef\nimport LostAndFound from 0x473d6a2c37eab5be\nimport FINDNFTCatalog from 0x097bafa4e0b48eef\nimport NFTCatalog from 0x49a7cda3a1eecc29\nimport NonFungibleToken from 0x1d7e57aa55817448\nimport MetadataViews from 0x1d7e57aa55817448\nimport FIND from 0x097bafa4e0b48eef\n\n//IMPORT\n\ntransaction(receiverAddress: Address) {\n\n    let ids : {String : [UInt64]}\n    let nftInfos : {String : NFTCatalog.NFTCollectionData}\n    let receiverAddress : Address\n\n    prepare(account: AuthAccount){\n        self.receiverAddress = receiverAddress\n\n        self.nftInfos = {}\n        self.ids = FindLostAndFoundWrapper.getTicketIDs(user: receiverAddress, specificType: Type\u003c@NonFungibleToken.NFT\u003e())\n\n        for type in self.ids.keys{ \n            if self.nftInfos[type] == nil {\n                let collections = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: type) ?? panic(\"NFT type is not supported at the moment. Type : \".concat(type))\n                self.nftInfos[type] = FINDNFTCatalog.getCatalogEntry(collectionIdentifier: collections.keys[0])!.collectionData\n            }\n        }\n\n    }\n\n    execute{\n        for type in self.ids.keys{ \n            let path = self.nftInfos[type]!.publicPath\n            for id in self.ids[type]! {\n                FindLostAndFoundWrapper.redeemNFT(type: CompositeType(type)!, ticketID: id, receiverAddress: self.receiverAddress, collectionPublicPath: path)\n            }\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "receiverAddress"
                  ],
                  "parameters": {
                     "receiverAddress": "Address"
                  }
               }
            },
            "redeemLostAndFoundNFTs": {
               "code": "import FindLostAndFoundWrapper from 0x097bafa4e0b48eef\nimport LostAndFound from 0x473d6a2c37eab5be\nimport FINDNFTCatalog from 0x097bafa4e0b48eef\nimport NFTCatalog from 0x49a7cda3a1eecc29\nimport NonFungibleToken from 0x1d7e57aa55817448\nimport MetadataViews from 0x1d7e57aa55817448\nimport FindViews from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\n\n//IMPORT\n\ntransaction(ids: {String : [UInt64]}) {\n\n    let nftInfos : {String : NFTCatalog.NFTCollectionData}\n    let receiverAddress : Address\n\n    prepare(account: AuthAccount){\n\n        //LINK\n        self.nftInfos = {}\n\n        for type in ids.keys{ \n            if self.nftInfos[type] == nil {\n                let collections = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: type) ?? panic(\"NFT type is not supported at the moment. Type : \".concat(type))\n                self.nftInfos[type] = FINDNFTCatalog.getCatalogEntry(collectionIdentifier: collections.keys[0])!.collectionData\n            }\n        }\n\n        self.receiverAddress = account.address\n    }\n\n    execute{\n        for type in ids.keys{ \n            let path = self.nftInfos[type]!.publicPath\n            for id in ids[type]! {\n                FindLostAndFoundWrapper.redeemNFT(type: CompositeType(type)!, ticketID: id, receiverAddress:self.receiverAddress, collectionPublicPath: path)\n            }\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "ids"
                  ],
                  "parameters": {
                     "ids": "{String: [UInt64]}"
                  }
               }
            },
            "redeemLostAndFoundNFTsOnBehalf": {
               "code": "import FindLostAndFoundWrapper from 0x097bafa4e0b48eef\nimport LostAndFound from 0x473d6a2c37eab5be\nimport FINDNFTCatalog from 0x097bafa4e0b48eef\nimport NFTCatalog from 0x49a7cda3a1eecc29\nimport NonFungibleToken from 0x1d7e57aa55817448\nimport MetadataViews from 0x1d7e57aa55817448\nimport FindViews from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\nimport Bl0xPack from 0x7620acf6d7f2468a\n\n//IMPORT\n\ntransaction(receiverAddress: Address, ids: {String : [UInt64]}) {\n\n    let nftInfos : {String : NFTCatalog.NFTCollectionData}\n    let receiverAddress : Address\n\n    prepare(account: AuthAccount){\n\n        self.receiverAddress = receiverAddress\n\n        self.nftInfos = {}\n\n        for type in ids.keys{ \n            if self.nftInfos[type] == nil {\n                let collections = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: type) ?? panic(\"NFT type is not supported at the moment. Type : \".concat(type))\n                self.nftInfos[type] = FINDNFTCatalog.getCatalogEntry(collectionIdentifier: collections.keys[0])!.collectionData\n            }\n        }\n\n    }\n\n    execute{\n        for type in ids.keys{ \n            let path = self.nftInfos[type]!.publicPath\n            for id in ids[type]! {\n                FindLostAndFoundWrapper.redeemNFT(type: CompositeType(type)!, ticketID: id, receiverAddress:self.receiverAddress, collectionPublicPath: path)\n            }\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "receiverAddress",
                     "ids"
                  ],
                  "parameters": {
                     "ids": "{String: [UInt64]}",
                     "receiverAddress": "Address"
                  }
               }
            },
            "register": {
               "code": "import FUSD from 0x3c5959b568896393\nimport FIND from 0x097bafa4e0b48eef\n\ntransaction(name: String, amount: UFix64) {\n\n    let vaultRef : \u0026FUSD.Vault?\n    let leases : \u0026FIND.LeaseCollection?\n    let price : UFix64\n\n    prepare(account: AuthAccount) {\n\n        self.price=FIND.calculateCost(name)\n        log(\"The cost for registering this name is \".concat(self.price.toString()))\n        self.vaultRef = account.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault)\n        self.leases=account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from: FIND.LeaseStoragePath)\n    }\n\n    pre{\n        self.vaultRef != nil : \"Could not borrow reference to the fusdVault!\"\n        self.leases != nil : \"Could not borrow reference to find lease collection\"\n        self.price == amount : \"Calculated cost : \".concat(self.price.toString()).concat(\" does not match expected cost : \").concat(amount.toString())\n    }\n\n    execute{\n        let payVault \u003c- self.vaultRef!.withdraw(amount: self.price) as! @FUSD.Vault\n        self.leases!.register(name: name, vault: \u003c- payVault)\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "name": "String"
                  }
               }
            },
            "registerDapper": {
               "code": "import DapperUtilityCoin from 0xead892083b3e2c6c\nimport FIND from 0x097bafa4e0b48eef\n\ntransaction(merchAccount: Address, name: String, amount: UFix64) {\n\n    let finLeases : \u0026FIND.LeaseCollection\n    let mainDapperUtilityCoinVault: \u0026DapperUtilityCoin.Vault\n    let balanceBeforeTransfer: UFix64\n    let price : UFix64\n\n    prepare(dapper: AuthAccount, account: AuthAccount) {\n\n        self.price=FIND.calculateCost(name)\n        log(\"The cost for registering this name is \".concat(self.price.toString()))\n        self.mainDapperUtilityCoinVault = dapper.borrow\u003c\u0026DapperUtilityCoin.Vault\u003e(from: /storage/dapperUtilityCoinVault) ?? panic(\"Cannot borrow DapperUtilityCoin vault from account storage\".concat(dapper.address.toString()))\n        self.balanceBeforeTransfer = self.mainDapperUtilityCoinVault.balance\n        self.finLeases= account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath) ?? panic(\"Could not borrow reference to find lease collection\")\n    }\n\n    pre{\n        self.price == amount : \"Calculated cost : \".concat(self.price.toString()).concat(\" does not match expected cost : \").concat(amount.toString())\n    }\n\n    execute{\n        let payVault \u003c- self.mainDapperUtilityCoinVault.withdraw(amount: self.price) as! @DapperUtilityCoin.Vault\n        self.finLeases.registerDapper(merchAccount: merchAccount, name: name, vault: \u003c- payVault)\n    }\n\n    post {\n        self.mainDapperUtilityCoinVault.balance == self.balanceBeforeTransfer: \"DapperUtilityCoin leakage\"\n    }\n}",
               "spec": {
                  "order": [
                     "merchAccount",
                     "name",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "merchAccount": "Address",
                     "name": "String"
                  }
               }
            },
            "registerGift": {
               "code": "import FUSD from 0x3c5959b568896393\nimport Profile from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\n\ntransaction(name: String, amount: UFix64, recipient: String) {\n\n    let price : UFix64 \n    let vaultRef : \u0026FUSD.Vault? \n    let receiverLease : Capability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e\n    let receiverProfile : Capability\u003c\u0026{Profile.Public}\u003e\n    let leases : \u0026FIND.LeaseCollection?\n\n    prepare(acct: AuthAccount) {\n\n        let resolveAddress = FIND.resolve(recipient)\n        if resolveAddress == nil {panic(\"The input pass in is not a valid name or address. Input : \".concat(recipient))}\n        let address = resolveAddress!\n\n        self.price=FIND.calculateCost(name)\n        log(\"The cost for registering this name is \".concat(self.price.toString()))\n\n        self.vaultRef = acct.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault)\n\n        self.leases=acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from: FIND.LeaseStoragePath)\n\n        let receiver = getAccount(address)\n        self.receiverLease = receiver.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        self.receiverProfile = receiver.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\n    }\n\n    pre{\n        self.price == amount : \"Calculated cost : \".concat(self.price.toString()).concat(\" does not match expected cost\").concat(amount.toString())\n        self.vaultRef != nil : \"Cannot borrow reference to fusd Vault!\"\n        self.receiverLease.check() : \"Lease capability is invalid\"\n        self.receiverProfile.check() : \"Profile capability is invalid\"\n        self.leases != nil : \"Cannot borrow refernce to find lease collection\"\n    }\n\n    execute{\n        let payVault \u003c- self.vaultRef!.withdraw(amount: self.price) as! @FUSD.Vault\n        self.leases!.register(name: name, vault: \u003c- payVault)\n        self.leases!.move(name: name, profile: self.receiverProfile, to: self.receiverLease)\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "amount",
                     "recipient"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "name": "String",
                     "recipient": "String"
                  }
               }
            },
            "rejectNameDirectOffer": {
               "code": "import FIND from 0x097bafa4e0b48eef\n\ntransaction(names: [String]) {\n\n    let finLeases : \u0026FIND.LeaseCollection? \n\n    prepare(account: AuthAccount) {\n        self.finLeases= account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)\n    }\n\n    pre{\n        self.finLeases != nil : \"Cannot borrow reference to find lease collection\"\n    }\n\n    execute{\n        for name in names {\n            self.finLeases!.cancel(name)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "names"
                  ],
                  "parameters": {
                     "names": "[String]"
                  }
               }
            },
            "relistMarketListings": {
               "code": "import FindMarket from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferEscrow from 0x097bafa4e0b48eef\nimport FindMarketAuctionEscrow from 0x097bafa4e0b48eef\nimport FindMarketAuctionSoft from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferSoft from 0x097bafa4e0b48eef\nimport FindMarketSale from 0x097bafa4e0b48eef\n\ntransaction(marketplace:Address, ids: {String : [UInt64]}) {\n    prepare(account: AuthAccount) {\n\n        let tenant=FindMarket.getTenant(marketplace)\n\n        var saleType = Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        if let ids = ids[FindMarket.getMarketOptionFromType(saleType)] {\n            let saleItems= account.borrow\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection\u003e(from: tenant.getStoragePath(saleType))!\n            for id in ids {\n                saleItems.relist(id)\n            }\n        }\n\n        saleType = Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        if let ids = ids[FindMarket.getMarketOptionFromType(saleType)] {\n            let saleItems= account.borrow\u003c\u0026FindMarketAuctionSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(saleType))!\n            for id in ids {\n                saleItems.relist(id)\n            }\n        }\n\n        saleType = Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        if let ids = ids[FindMarket.getMarketOptionFromType(saleType)] {\n            let saleItems= account.borrow\u003c\u0026FindMarketSale.SaleItemCollection\u003e(from: tenant.getStoragePath(saleType))!\n            for id in ids {\n                saleItems.relist(id)\n            }\n        }\n\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "ids"
                  ],
                  "parameters": {
                     "ids": "{String: [UInt64]}",
                     "marketplace": "Address"
                  }
               }
            },
            "removeCurratedCollection": {
               "code": "transaction(name: String) {\n    prepare(account: AuthAccount) {\n\n        let path=/storage/FindCuratedCollections\n        let publicPath=/public/FindCuratedCollections\n\n        var collections : {String: [String]} = {}\n        if account.borrow\u003c\u0026{String: [String]}\u003e(from:path) != nil {\n             collections=account.load\u003c{String: [String]}\u003e(from:path)!\n        }\n        collections.remove(key: name)\n        account.save(collections, to: path)\n        let link = account.getCapability\u003c\u0026{String: [String]}\u003e(publicPath)\n        if !link.check() {\n            account.link\u003c\u0026{String: [String]}\u003e( publicPath, target: path)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "removeMarketOption": {
               "code": "import FindMarket from 0x097bafa4e0b48eef\n\ntransaction(saleItemName: String){\n    \n    prepare(account: AuthAccount){\n        let path = FindMarket.TenantClientStoragePath\n        let tenantRef = account.borrow\u003c\u0026FindMarket.TenantClient\u003e(from: path) ?? panic(\"Cannot borrow Reference.\")\n\n        tenantRef.removeMarketOption(name: saleItemName)\n    }\n}",
               "spec": {
                  "order": [
                     "saleItemName"
                  ],
                  "parameters": {
                     "saleItemName": "String"
                  }
               }
            },
            "removeRelatedAccount": {
               "code": "import FindRelatedAccounts from 0x097bafa4e0b48eef\n\ntransaction(name: String, network: String, address: String) {\n\n    var relatedAccounts : \u0026FindRelatedAccounts.Accounts?\n\n    prepare(account: AuthAccount) {\n\n        self.relatedAccounts= account.borrow\u003c\u0026FindRelatedAccounts.Accounts\u003e(from:FindRelatedAccounts.storagePath)\n        if self.relatedAccounts == nil {\n            let relatedAccounts \u003c- FindRelatedAccounts.createEmptyAccounts()\n            account.save(\u003c- relatedAccounts, to: FindRelatedAccounts.storagePath)\n            account.link\u003c\u0026FindRelatedAccounts.Accounts{FindRelatedAccounts.Public}\u003e(FindRelatedAccounts.publicPath, target: FindRelatedAccounts.storagePath)\n            self.relatedAccounts = account.borrow\u003c\u0026FindRelatedAccounts.Accounts\u003e(from:FindRelatedAccounts.storagePath)\n        }\n\n        let cap = account.getCapability\u003c\u0026FindRelatedAccounts.Accounts{FindRelatedAccounts.Public}\u003e(FindRelatedAccounts.publicPath)\n        if !cap.check() {\n            account.unlink(FindRelatedAccounts.publicPath)\n            account.link\u003c\u0026FindRelatedAccounts.Accounts{FindRelatedAccounts.Public}\u003e(FindRelatedAccounts.publicPath, target: FindRelatedAccounts.storagePath)\n        }\n    }\n\n    execute {\n        self.relatedAccounts!.removeRelatedAccount(name:name, network:network, address: address)\n    }\n\n}",
               "spec": {
                  "order": [
                     "name",
                     "network",
                     "address"
                  ],
                  "parameters": {
                     "address": "String",
                     "name": "String",
                     "network": "String"
                  }
               }
            },
            "removeRelatedAccountDapper": {
               "code": "import FindRelatedAccounts from 0x097bafa4e0b48eef\n\ntransaction(name: String, network: String, address: String){\n\n    var relatedAccounts : \u0026FindRelatedAccounts.Accounts?\n\n    prepare(account: AuthAccount) {\n\n        self.relatedAccounts= account.borrow\u003c\u0026FindRelatedAccounts.Accounts\u003e(from:FindRelatedAccounts.storagePath)\n        if self.relatedAccounts == nil {\n            let relatedAccounts \u003c- FindRelatedAccounts.createEmptyAccounts()\n            account.save(\u003c- relatedAccounts, to: FindRelatedAccounts.storagePath)\n            account.link\u003c\u0026FindRelatedAccounts.Accounts{FindRelatedAccounts.Public}\u003e(FindRelatedAccounts.publicPath, target: FindRelatedAccounts.storagePath)\n            self.relatedAccounts= account.borrow\u003c\u0026FindRelatedAccounts.Accounts\u003e(from:FindRelatedAccounts.storagePath)\n        }\n\n        let cap = account.getCapability\u003c\u0026FindRelatedAccounts.Accounts{FindRelatedAccounts.Public}\u003e(FindRelatedAccounts.publicPath)\n        if !cap.check() {\n            account.unlink(FindRelatedAccounts.publicPath)\n            account.link\u003c\u0026FindRelatedAccounts.Accounts{FindRelatedAccounts.Public}\u003e(FindRelatedAccounts.publicPath, target: FindRelatedAccounts.storagePath)\n        }\n\n    }\n\n    execute{\n        self.relatedAccounts!.removeRelatedAccount(name: name, network: network, address: address)\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "network",
                     "address"
                  ],
                  "parameters": {
                     "address": "String",
                     "name": "String",
                     "network": "String"
                  }
               }
            },
            "removeTenantRule": {
               "code": "import FindMarket from 0x097bafa4e0b48eef\n\ntransaction(optionName: String, tenantRuleName: String){\n    prepare(account: AuthAccount){\n        let path = FindMarket.TenantClientStoragePath\n        let tenantRef = account.borrow\u003c\u0026FindMarket.TenantClient\u003e(from: path) ?? panic(\"Cannot borrow Reference.\")\n\n        tenantRef.removeTenantRule(optionName: optionName, tenantRuleName: tenantRuleName)\n    }\n}",
               "spec": {
                  "order": [
                     "optionName",
                     "tenantRuleName"
                  ],
                  "parameters": {
                     "optionName": "String",
                     "tenantRuleName": "String"
                  }
               }
            },
            "remove_find_market_1": {
               "code": "import FindMarketAdmin from 0x097bafa4e0b48eef\n\n//signed by admin to link tenantClient to a new tenant\ntransaction(tenant: Address) {\n    //versus account\n    prepare(account: AuthAccount) {\n        let adminClient=account.borrow\u003c\u0026FindMarketAdmin.AdminProxy\u003e(from: FindMarketAdmin.AdminProxyStoragePath)!\n\n        adminClient.removeFindMarketTenant(tenant: tenant)\n    }\n}",
               "spec": {
                  "order": [
                     "tenant"
                  ],
                  "parameters": {
                     "tenant": "Address"
                  }
               }
            },
            "remove_find_market_2": {
               "code": "import FindMarket from 0x097bafa4e0b48eef\n\n\n//Transaction that is signed by find to create a find market tenant for find\ntransaction() {\n    prepare(account: AuthAccount) {\n        //in finds case the\n        destroy account.load\u003c@FindMarket.TenantClient\u003e(from:FindMarket.TenantClientStoragePath)\n        account.unlink(FindMarket.TenantClientPublicPath)\n    }\n}",
               "spec": {
                  "order": [],
                  "parameters": {}
               }
            },
            "renewName": {
               "code": "import FUSD from 0x3c5959b568896393\nimport FIND from 0x097bafa4e0b48eef\n\ntransaction(name: String, amount: UFix64) {\n\n    let price : UFix64\n    let vaultRef : \u0026FUSD.Vault? \n    let finLeases : \u0026FIND.LeaseCollection? \n\n    prepare(acct: AuthAccount) {\n        self.price=FIND.calculateCost(name)\n        self.vaultRef = acct.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault)\n        self.finLeases= acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)\n    }\n\n    pre{\n        self.price == amount : \"expected renew cost : \".concat(self.price.toString()).concat(\" is not the same as calculated renew cost : \").concat(amount.toString())\n        self.vaultRef != nil : \"Could not borrow reference to the fusdVault!\"\n        self.finLeases != nil : \"Could not borrow reference to find lease collection\"\n    }\n\n    execute{\n        let payVault \u003c- self.vaultRef!.withdraw(amount: self.price) as! @FUSD.Vault\n        let finToken= self.finLeases!.borrow(name)\n        finToken.extendLease(\u003c- payVault)\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "name": "String"
                  }
               }
            },
            "renewNameDapper": {
               "code": "import DapperUtilityCoin from 0xead892083b3e2c6c\nimport FIND from 0x097bafa4e0b48eef\n\ntransaction(merchAccount: Address, name: String, amount: UFix64) {\n\n    let price : UFix64\n    let finLeases : \u0026FIND.LeaseCollection\n    let mainDapperUtilityCoinVault: \u0026DapperUtilityCoin.Vault\n    let balanceBeforeTransfer: UFix64\n\n    prepare(dapper: AuthAccount, acct: AuthAccount) {\n        self.price=FIND.calculateCost(name)\n        self.mainDapperUtilityCoinVault = dapper.borrow\u003c\u0026DapperUtilityCoin.Vault\u003e(from: /storage/dapperUtilityCoinVault) ?? panic(\"Cannot borrow DapperUtilityCoin vault from account storage\".concat(dapper.address.toString()))\n        self.balanceBeforeTransfer = self.mainDapperUtilityCoinVault.balance\n        self.finLeases= acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath) ?? panic(\"Could not borrow reference to find lease collection\")\n    }\n\n    pre{\n        self.price == amount : \"expected renew cost : \".concat(self.price.toString()).concat(\" is not the same as calculated renew cost : \").concat(amount.toString())\n    }\n\n    execute{\n        let payVault \u003c- self.mainDapperUtilityCoinVault.withdraw(amount: self.price) as! @DapperUtilityCoin.Vault\n        let finToken= self.finLeases.borrow(name)\n        finToken.extendLeaseDapper(merchAccount: merchAccount, vault: \u003c- payVault)\n    }\n\n    post {\n        self.mainDapperUtilityCoinVault.balance == self.balanceBeforeTransfer: \"DapperUtilityCoin leakage\"\n    }\n}",
               "spec": {
                  "order": [
                     "merchAccount",
                     "name",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "merchAccount": "Address",
                     "name": "String"
                  }
               }
            },
            "retractOfferLeaseMarketDirectOfferSoft": {
               "code": "import FindMarket from 0x097bafa4e0b48eef\nimport FindLeaseMarketDirectOfferSoft from 0x097bafa4e0b48eef\n\ntransaction(leaseName: String) {\n    let bidsReference: \u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection?\n\n    prepare(account: AuthAccount) {\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e())\n        self.bidsReference= account.borrow\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(from: storagePath)\n    }\n\n    pre{\n        self.bidsReference != nil : \"Bid resource does not exist\"\n    }\n\n    execute {\n        self.bidsReference!.cancelBid(leaseName)\n    }\n}",
               "spec": {
                  "order": [
                     "leaseName"
                  ],
                  "parameters": {
                     "leaseName": "String"
                  }
               }
            },
            "retractOfferMarketDirectOfferEscrowed": {
               "code": "import FindMarket from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferEscrow from 0x097bafa4e0b48eef\n\ntransaction(marketplace:Address, id: UInt64) {\n    let bidsReference: \u0026FindMarketDirectOfferEscrow.MarketBidCollection? \n\n    prepare(account: AuthAccount) {\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e())\n        self.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection\u003e(from: storagePath) \n    }\n\n    pre{\n        self.bidsReference != nil : \"This account does not have a bid collection\"\n    }\n\n    execute {\n        self.bidsReference!.cancelBid(id)\n    }\n\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "retractOfferMarketDirectOfferSoft": {
               "code": "import FindMarket from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferSoft from 0x097bafa4e0b48eef\n\ntransaction(marketplace:Address, id: UInt64) {\n    let bidsReference: \u0026FindMarketDirectOfferSoft.MarketBidCollection?\n\n    prepare(account: AuthAccount) {\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n        self.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection\u003e(from: storagePath) \n    }\n\n    pre{\n        self.bidsReference != nil : \"Bid resource does not exist\"\n    }\n\n    execute {\n        self.bidsReference!.cancelBid(id)\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "sendCharity": {
               "code": "import NonFungibleToken from 0x1d7e57aa55817448\nimport CharityNFT from 0x097bafa4e0b48eef\n\n//mint an art and add it to a users collection\ntransaction(\n    id: UInt64,\n    recipient: Address\n) {\n    let receiverCap: Capability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e\n    let charityCollection: \u0026NonFungibleToken.Collection\n\n    prepare(account: AuthAccount) {\n        self.charityCollection =account.borrow\u003c\u0026NonFungibleToken.Collection\u003e(from: CharityNFT.CollectionStoragePath)!\n        self.receiverCap= getAccount(recipient).getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath)\n    }\n\n    pre{\n        self.receiverCap.check() : \"Receiver doesn't have receiving vault set up properly.\"\n    }\n\n    execute {\n        let nft \u003c- self.charityCollection.withdraw(withdrawID: id)\n        self.receiverCap.borrow()!.deposit(token: \u003c- nft)\n    }\n}",
               "spec": {
                  "order": [
                     "id",
                     "recipient"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "recipient": "Address"
                  }
               }
            },
            "sendDandy": {
               "code": "import FIND from 0x097bafa4e0b48eef\nimport NonFungibleToken from 0x1d7e57aa55817448\nimport Dandy from 0x097bafa4e0b48eef\n\ntransaction(user: String, id: UInt64) {\n\n    let address : Address\n    let cap : Capability\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic}\u003e\n    let senderRef : \u0026Dandy.Collection\n\n    prepare(account: AuthAccount) {\n        self.address = FIND.resolve(user) ?? panic(\"Cannot find user with this name / address\")\n        self.cap = getAccount(self.address).getCapability\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n\n        self.senderRef = account.borrow\u003c\u0026Dandy.Collection\u003e(from: Dandy.CollectionStoragePath) ?? panic(\"Cannot borrow reference to sender Collection.\")\n    }\n\n    pre{\n        self.cap.check() : \"Cannot borrow reference to receiver Collection. Receiver account : \".concat(self.address.toString())\n        self.senderRef != nil : \"Cannot borrow reference to sender Collection.\"\n    }\n\n    execute{\n        self.cap.borrow()!.deposit(token: \u003c- self.senderRef!.withdraw(withdrawID: id))\n    }\n}",
               "spec": {
                  "order": [
                     "user",
                     "id"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "user": "String"
                  }
               }
            },
            "sendFT": {
               "code": "import FungibleToken from 0xf233dcee88fe0abe\nimport Sender from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\nimport FTRegistry from 0x097bafa4e0b48eef\n\n\ntransaction(name: String, amount: UFix64, ftAliasOrIdentifier: String, tag: String, message:String) {\n\n    var token : \u0026Sender.Token\n    let walletReference : \u0026FungibleToken.Vault? \n\n    prepare(account: AuthAccount) {\n\n        let ft = FTRegistry.getFTInfo(ftAliasOrIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftAliasOrIdentifier))\n        self.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath)\n\n        if account.borrow\u003c\u0026Sender.Token\u003e(from: Sender.storagePath) == nil {\n            account.save(\u003c- Sender.create(), to: Sender.storagePath)\n        }\n\n        self.token =account.borrow\u003c\u0026Sender.Token\u003e(from: Sender.storagePath)!\n    }\n\n    pre{\n        self.walletReference != nil : \"No suitable wallet linked for this account\"\n    }\n\n    execute{\n        let vault \u003c- self.walletReference!.withdraw(amount: amount)\n        FIND.depositWithTagAndMessage(to: name, message: message, tag: tag, vault: \u003c- vault, from: self.token)\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "amount",
                     "ftAliasOrIdentifier",
                     "tag",
                     "message"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "ftAliasOrIdentifier": "String",
                     "message": "String",
                     "name": "String",
                     "tag": "String"
                  }
               }
            },
            "sendFTWithTag": {
               "code": "import NonFungibleToken from 0x1d7e57aa55817448\nimport MetadataViews from 0x1d7e57aa55817448\nimport FlowToken from 0x1654653399040a61\nimport FungibleToken from 0xf233dcee88fe0abe\nimport FUSD from 0x3c5959b568896393\nimport Profile from 0x097bafa4e0b48eef\nimport Sender from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\nimport CharityNFT from 0x097bafa4e0b48eef\n\n\ntransaction(name: String, amount: UFix64, type: String, tag:String) {\n\n    prepare(account: AuthAccount) {\n\n        let stdCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath)\n        if !stdCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- CharityNFT.createEmptyCollection(), to: CharityNFT.CollectionStoragePath)\n            account.link\u003c\u0026{NonFungibleToken.CollectionPublic, MetadataViews.ResolverCollection}\u003e(CharityNFT.CollectionPublicPath, target: CharityNFT.CollectionStoragePath)\n        }\n\n        let charityCap = account.getCapability\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection)\n        if !charityCap.check() {\n            account.link\u003c\u0026{CharityNFT.CollectionPublic, MetadataViews.ResolverCollection}\u003e(/public/findCharityNFTCollection, target: CharityNFT.CollectionStoragePath)\n        }\n\n      let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n        if !fusdReceiver.check() {\n            let fusd \u003c- FUSD.createEmptyVault()\n            account.save(\u003c- fusd, to: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profileName = account.address.toString()\n\n            let profile \u003c-Profile.createUser(name:profileName, createdAt: \"find\")\n\n            let fusdWallet=Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), names: [\"fusd\", \"stablecoin\"])\n\n            profile.addWallet(fusdWallet)\n\n            let flowWallet=Profile.Wallet(\n                name:\"Flow\", \n                receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver),\n                balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance),\n                accept: Type\u003c@FlowToken.Vault\u003e(),\n                names: [\"flow\"]\n            )\n    \n            profile.addWallet(flowWallet)\n            profile.addCollection(Profile.ResourceCollection(\"FINDLeases\",leaseCollection, Type\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(), [\"find\", \"leases\"]))\n            profile.addCollection(Profile.ResourceCollection(\"FINDBids\", bidCollection, Type\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(), [\"find\", \"bids\"]))\n\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n        }\n\n        if account.borrow\u003c\u0026Sender.Token\u003e(from: Sender.storagePath) == nil {\n            account.save(\u003c- Sender.create(), to: Sender.storagePath)\n        }\n\n        let token =account.borrow\u003c\u0026Sender.Token\u003e(from: Sender.storagePath)!\n\n\n        if type == \"fusd\" {\n            let vaultRef = account.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault) ?? panic(\"Could not borrow reference to the fusdVault!\")\n            let vault \u003c- vaultRef.withdraw(amount: amount)\n            FIND.depositWithTagAndMessage(to: name, message: \"\", tag: tag, vault: \u003c- vault, from: token)\n            return \n        }\n\n        let vaultRef = account.borrow\u003c\u0026FlowToken.Vault\u003e(from: /storage/flowTokenVault) ?? panic(\"Could not borrow reference to the fusdVault!\")\n        let vault \u003c- vaultRef.withdraw(amount: amount)\n        FIND.depositWithTagAndMessage(to: name, message: \"\", tag: tag, vault: \u003c- vault, from: token)\n    }\n\n}",
               "spec": {
                  "order": [
                     "name",
                     "amount",
                     "type",
                     "tag"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "name": "String",
                     "tag": "String",
                     "type": "String"
                  }
               }
            },
            "sendFindPacks": {
               "code": "import FindPack from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\nimport NonFungibleToken from 0x1d7e57aa55817448\nimport FindAirdropper from 0x097bafa4e0b48eef\nimport Admin from 0x097bafa4e0b48eef\n\ntransaction(packInfo: FindPack.AirdropInfo) {\n\n    prepare(account: AuthAccount) {\n\n        let pathIdentifier = \"FindPack_\".concat(packInfo.packTypeName).concat(\"_\").concat(packInfo.packTypeId.toString())\n\n        let pathCollection = FindPack.getPacksCollection(packTypeName: packInfo.packTypeName, packTypeId: packInfo.packTypeId)\n        let adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n\n        let ids = pathCollection.getIDs()\n        for i, user in packInfo.users {\n            let id = ids[i]\n\n            let address = FIND.resolve(user)\n            if address == nil {\n                panic(\"User cannot be resolved : \".concat(user))\n            }\n\n            let uAccount = getAccount(address!)\n            let userPacks=uAccount.getCapability\u003c\u0026FindPack.Collection{NonFungibleToken.Receiver}\u003e(FindPack.CollectionPublicPath).borrow() ?? panic(\"Could not find userPacks for \".concat(user))\n            let pointer = adminRef.getAuthPointer(pathIdentifier: pathIdentifier, id: id)\n            let ctx : {String : String } = {\"message\" : packInfo.message, \"tenant\" : \"find\"}\n            FindAirdropper.safeAirdrop(pointer: pointer, receiver: address!, path: FindPack.CollectionPublicPath, context: ctx , deepValidation: true)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "packInfo"
                  ],
                  "parameters": {
                     "packInfo": "FindPack.AirdropInfo"
                  }
               }
            },
            "sendNFTs": {
               "code": "import NonFungibleToken from 0x1d7e57aa55817448\nimport FungibleToken from 0xf233dcee88fe0abe\nimport FlowStorageFees from 0xe467b9dd11fa00df\nimport FlowToken from 0x1654653399040a61\nimport MetadataViews from 0x1d7e57aa55817448\nimport NFTCatalog from 0x49a7cda3a1eecc29\nimport FINDNFTCatalog from 0x097bafa4e0b48eef\nimport FindViews from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\nimport FindAirdropper from 0x097bafa4e0b48eef\nimport FTRegistry from 0x097bafa4e0b48eef\nimport Profile from 0x097bafa4e0b48eef\nimport Sender from 0x097bafa4e0b48eef\n\ntransaction(nftIdentifiers: [String], allReceivers: [String] , ids:[UInt64], memos: [String], donationTypes: [String?], donationAmounts: [UFix64?], findDonationType: String?, findDonationAmount: UFix64?) {\n\n    let authPointers : [FindViews.AuthNFTPointer]\n    let paths : [PublicPath]\n    let flowVault : \u0026FungibleToken.Vault\n    let flowTokenRepayment : Capability\u003c\u0026FlowToken.Vault{FungibleToken.Receiver}\u003e\n    let defaultTokenAvailableBalance : UFix64\n\n    let royalties: [MetadataViews.Royalties?]\n    let totalRoyalties: [UFix64]\n    let vaultRefs: {String : \u0026FungibleToken.Vault}\n    var token : \u0026Sender.Token\n\n    prepare(account : AuthAccount) {\n\n        self.authPointers = []\n        self.paths = []\n        self.royalties = []\n        self.totalRoyalties = []\n        self.vaultRefs = {}\n\n\n        let contractData : {Type : NFTCatalog.NFTCatalogMetadata} = {}\n\n\n        for i , typeIdentifier in nftIdentifiers {\n            let type = CompositeType(typeIdentifier) ?? panic(\"Cannot refer to type with identifier : \".concat(typeIdentifier))\n\n            var data : NFTCatalog.NFTCatalogMetadata? = contractData[type]\n            if data == nil {\n                data = FINDNFTCatalog.getMetadataFromType(type) ?? panic(\"NFT Type is not supported by NFT Catalog. Type : \".concat(type.identifier))\n                contractData[type] = data\n            }\n\n            let path = data!.collectionData\n\n            var providerCap=account.getCapability\u003c\u0026{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e(path.privatePath)\n            if !providerCap.check() {\n                let newCap = account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                    path.privatePath,\n                    target: path.storagePath\n                )\n                if newCap == nil {\n                    // If linking is not successful, we link it using finds custom link\n                    let pathIdentifier = path.privatePath.toString()\n                    let findPath = PrivatePath(identifier: pathIdentifier.slice(from: \"/private/\".length , upTo: pathIdentifier.length).concat(\"_FIND\"))!\n                    account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                        findPath,\n                        target: path.storagePath\n                    )\n                    providerCap = account.getCapability\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(findPath)\n                }\n            }\n            let pointer = FindViews.AuthNFTPointer(cap: providerCap, id: ids[i])\n\n            if let dt = donationTypes[i] {\n                self.royalties.append(pointer.getRoyalty())\n                self.totalRoyalties.append(pointer.getTotalRoyaltiesCut())\n\n                // get the vault for donation\n                if self.vaultRefs[dt] == nil {\n                    let info = FTRegistry.getFTInfo(dt) ?? panic(\"This token type is not supported at the moment : \".concat(dt))\n                    let ftPath = info.vaultPath\n                    let ref = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ftPath) ?? panic(\"Cannot borrow vault reference for type : \".concat(dt))\n                    self.vaultRefs[dt] = ref\n                }\n\n            } else {\n                self.royalties.append(nil)\n                self.totalRoyalties.append(0.0)\n            }\n\n            self.authPointers.append(pointer)\n            self.paths.append(path.publicPath)\n        }\n\n        self.flowVault = account.borrow\u003c\u0026FlowToken.Vault\u003e(from: /storage/flowTokenVault) ?? panic(\"Cannot borrow reference to sender's flow vault\")\n        self.flowTokenRepayment = account.getCapability\u003c\u0026FlowToken.Vault{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver)\n        self.defaultTokenAvailableBalance = FlowStorageFees.defaultTokenAvailableBalance(account.address)\n\n        // get the vault for find donation\n        if let dt = findDonationType {\n            if self.vaultRefs[dt] == nil {\n                let info = FTRegistry.getFTInfo(dt) ?? panic(\"This token type is not supported at the moment : \".concat(dt))\n                let ftPath = info.vaultPath\n                let ref = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ftPath) ?? panic(\"Cannot borrow vault reference for type : \".concat(dt))\n                self.vaultRefs[dt] = ref\n            }\n        }\n\n        if account.borrow\u003c\u0026Sender.Token\u003e(from: Sender.storagePath) == nil {\n            account.save(\u003c- Sender.create(), to: Sender.storagePath)\n        }\n\n        self.token =account.borrow\u003c\u0026Sender.Token\u003e(from: Sender.storagePath)!\n\n    }\n\n    execute {\n        let addresses : {String : Address} = {}\n        let estimatedStorageFee = 0.0002 * UFix64(self.authPointers.length)\n        // we pass in the least amount as possible for storage fee here\n        let tempVault \u003c- self.flowVault.withdraw(amount: 0.0)\n        var vaultRef = \u0026tempVault as \u0026FungibleToken.Vault\n        if self.defaultTokenAvailableBalance \u003c= estimatedStorageFee {\n            vaultRef = self.flowVault as \u0026FungibleToken.Vault\n        } else {\n            tempVault.deposit(from: \u003c- self.flowVault.withdraw(amount: estimatedStorageFee))\n        }\n\n        let ctx : {String : String} = {\n            \"tenant\" : \"find\"\n        }\n\n        for i,  pointer in self.authPointers {\n            let receiver = allReceivers[i]\n            let id = ids[i]\n            ctx[\"message\"] = memos[i]\n            let path = self.paths[i]\n\n            var user = addresses[receiver]\n            if user == nil {\n                user = FIND.resolve(receiver) ?? panic(\"Cannot resolve user with name / address : \".concat(receiver))\n                addresses[receiver] = user\n            }\n\n            // airdrop thru airdropper\n            FindAirdropper.forcedAirdrop(pointer: pointer, receiver: user!, path: path, context: ctx, storagePayment: vaultRef, flowTokenRepayment: self.flowTokenRepayment, deepValidation: true)\n        }\n        self.flowVault.deposit(from: \u003c- tempVault)\n\n        // This is hard coded for spliting at the front end for now. So if there are no royalties, all goes to find\n        // AND This does not support different ft types for now.\n        var goesToFindFund = 0.0\n        for i , type in donationTypes {\n            if type == nil {\n                continue\n            }\n            let amount = donationAmounts[i]!\n            let royalties = self.royalties[i]!\n            let totalRoyalties = self.totalRoyalties[i]\n            let vaultRef = self.vaultRefs[type!]!\n            var noRoyalty = false\n            if totalRoyalties == 0.0 {\n                goesToFindFund = goesToFindFund + amount\n                continue\n            }\n\n            let balance = vaultRef.balance\n            var totalPaid = 0.0\n\n            for j, r in royalties.getRoyalties() {\n                var cap : Capability\u003c\u0026{FungibleToken.Receiver}\u003e = r.receiver\n                if !r.receiver.check(){\n                    // try to grab from profile\n                    if let ref = getAccount(r.receiver.address).getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath).borrow() {\n                        if ref.hasWallet(vaultRef.getType().identifier) {\n                            cap = getAccount(r.receiver.address).getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n                        } else if let ftInfo = FTRegistry.getFTInfo(vaultRef.getType().identifier) {\n                            cap = getAccount(r.receiver.address).getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(ftInfo.receiverPath)\n                        }\n                    }\n\n                }\n\n                if cap.check() {\n                    let individualAmount = r.cut / totalRoyalties * amount\n                    let vault \u003c- vaultRef.withdraw(amount: individualAmount)\n                    cap.borrow()!.deposit(from: \u003c- vault)\n\n                    totalPaid = totalPaid + individualAmount\n                }\n            }\n\n            assert(totalPaid \u003c= amount, message: \"Amount paid is greater than expected\" )\n\n        }\n\n        // for donating to find\n        if findDonationType != nil {\n            vaultRef = self.vaultRefs[findDonationType!]!\n            let vault \u003c- vaultRef.withdraw(amount: findDonationAmount! + goesToFindFund)\n            FIND.depositWithTagAndMessage(to: \"find\", message: \"donation to .find\", tag: \"donation\", vault: \u003c- vault, from: self.token)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "nftIdentifiers",
                     "allReceivers",
                     "ids",
                     "memos",
                     "donationTypes",
                     "donationAmounts",
                     "findDonationType",
                     "findDonationAmount"
                  ],
                  "parameters": {
                     "allReceivers": "[String]",
                     "donationAmounts": "[UFix64?]",
                     "donationTypes": "[String?]",
                     "findDonationAmount": "UFix64?",
                     "findDonationType": "String?",
                     "ids": "[UInt64]",
                     "memos": "[String]",
                     "nftIdentifiers": "[String]"
                  }
               }
            },
            "sendNFTsSafe": {
               "code": "import NonFungibleToken from 0x1d7e57aa55817448\nimport FungibleToken from 0xf233dcee88fe0abe\nimport MetadataViews from 0x1d7e57aa55817448\nimport NFTCatalog from 0x49a7cda3a1eecc29\nimport FINDNFTCatalog from 0x097bafa4e0b48eef\nimport FindViews from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\nimport FindAirdropper from 0x097bafa4e0b48eef\nimport FTRegistry from 0x097bafa4e0b48eef\nimport Profile from 0x097bafa4e0b48eef\nimport Sender from 0x097bafa4e0b48eef\n\ntransaction(nftIdentifiers: [String], allReceivers: [String] , ids:[UInt64], memos: [String], donationTypes: [String?], donationAmounts: [UFix64?], findDonationType: String?, findDonationAmount: UFix64?) {\n\n    let authPointers : [FindViews.AuthNFTPointer]\n    let paths : [PublicPath]\n    let royalties: [MetadataViews.Royalties?]\n    let totalRoyalties: [UFix64]\n    let vaultRefs: {String : \u0026FungibleToken.Vault}\n    var token : \u0026Sender.Token\n\n    prepare(account : AuthAccount) {\n\n        self.authPointers = []\n        self.paths = []\n        self.royalties = []\n        self.totalRoyalties = []\n        self.vaultRefs = {}\n\n        let contractData : {Type : NFTCatalog.NFTCatalogMetadata} = {}\n\n\n        for i , typeIdentifier in nftIdentifiers {\n            let type = CompositeType(typeIdentifier) ?? panic(\"Cannot refer to type with identifier : \".concat(typeIdentifier))\n\n            var data : NFTCatalog.NFTCatalogMetadata? = contractData[type]\n            if data == nil {\n                data = FINDNFTCatalog.getMetadataFromType(type) ?? panic(\"NFT Type is not supported by NFT Catalog. Type : \".concat(type.identifier))\n                contractData[type] = data\n            }\n\n            let path = data!.collectionData\n\n            var providerCap=account.getCapability\u003c\u0026{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e(path.privatePath)\n            if !providerCap.check() {\n                let newCap = account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                    path.privatePath,\n                    target: path.storagePath\n                )\n                if newCap == nil {\n                    // If linking is not successful, we link it using finds custom link\n                    let pathIdentifier = path.privatePath.toString()\n                    let findPath = PrivatePath(identifier: pathIdentifier.slice(from: \"/private/\".length , upTo: pathIdentifier.length).concat(\"_FIND\"))!\n                    account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                        findPath,\n                        target: path.storagePath\n                    )\n                    providerCap = account.getCapability\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(findPath)\n                }\n            }\n            let pointer = FindViews.AuthNFTPointer(cap: providerCap, id: ids[i])\n\n            if let dt = donationTypes[i] {\n                self.royalties.append(pointer.getRoyalty())\n                self.totalRoyalties.append(pointer.getTotalRoyaltiesCut())\n\n                // get the vault for donation\n                if self.vaultRefs[dt] == nil {\n                    let info = FTRegistry.getFTInfo(dt) ?? panic(\"This token type is not supported at the moment : \".concat(dt))\n                    let ftPath = info.vaultPath\n                    let ref = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ftPath) ?? panic(\"Cannot borrow vault reference for type : \".concat(dt))\n                    self.vaultRefs[dt] = ref\n                }\n\n            } else {\n                self.royalties.append(nil)\n                self.totalRoyalties.append(0.0)\n            }\n\n\n            self.authPointers.append(pointer)\n            self.paths.append(path.publicPath)\n        }\n\n        // get the vault for find donation\n        if let dt = findDonationType {\n            if self.vaultRefs[dt] == nil {\n                let info = FTRegistry.getFTInfo(dt) ?? panic(\"This token type is not supported at the moment : \".concat(dt))\n                let ftPath = info.vaultPath\n                let ref = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ftPath) ?? panic(\"Cannot borrow vault reference for type : \".concat(dt))\n                self.vaultRefs[dt] = ref\n            }\n        }\n\n        if account.borrow\u003c\u0026Sender.Token\u003e(from: Sender.storagePath) == nil {\n            account.save(\u003c- Sender.create(), to: Sender.storagePath)\n        }\n\n        self.token =account.borrow\u003c\u0026Sender.Token\u003e(from: Sender.storagePath)!\n\n    }\n\n    execute {\n        let addresses : {String : Address} = {}\n\n        let ctx : {String : String} = {\n            \"tenant\" : \"find\"\n        }\n\n        for i,  pointer in self.authPointers {\n            let receiver = allReceivers[i]\n            let id = ids[i]\n            ctx[\"message\"] = memos[i]\n            let path = self.paths[i]\n\n            var user = addresses[receiver]\n            if user == nil {\n                user = FIND.resolve(receiver) ?? panic(\"Cannot resolve user with name / address : \".concat(receiver))\n                addresses[receiver] = user\n            }\n\n            // airdrop thru airdropper\n            FindAirdropper.safeAirdrop(pointer: pointer, receiver: user!, path: path, context: ctx, deepValidation: true)\n        }\n\n\n        // This is hard coded for spliting at the front end for now. So if there are no royalties, all goes to find\n        // AND This does not support different ft types for now.\n        var goesToFindFund = 0.0\n        for i , type in donationTypes {\n            if type == nil {\n                continue\n            }\n            let amount = donationAmounts[i]!\n            let royalties = self.royalties[i]!\n            let totalRoyalties = self.totalRoyalties[i]\n            let vaultRef = self.vaultRefs[type!]!\n            if totalRoyalties == 0.0 {\n                goesToFindFund = goesToFindFund + amount\n                continue\n            }\n\n            let balance = vaultRef.balance\n            var totalPaid = 0.0\n\n            for j, r in royalties.getRoyalties() {\n                var cap : Capability\u003c\u0026{FungibleToken.Receiver}\u003e = r.receiver\n                if !r.receiver.check(){\n                    // try to grab from profile\n                    if let ref = getAccount(r.receiver.address).getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath).borrow() {\n                        if ref.hasWallet(vaultRef.getType().identifier) {\n                            cap = getAccount(r.receiver.address).getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n                        } else if let ftInfo = FTRegistry.getFTInfo(vaultRef.getType().identifier) {\n                            cap = getAccount(r.receiver.address).getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(ftInfo.receiverPath)\n                        }\n                    }\n\n                }\n\n                if cap.check() {\n                    let individualAmount = r.cut / totalRoyalties * amount\n                    let vault \u003c- vaultRef.withdraw(amount: individualAmount)\n                    cap.borrow()!.deposit(from: \u003c- vault)\n\n                    totalPaid = totalPaid + individualAmount\n                }\n            }\n\n            assert(totalPaid \u003c= amount, message: \"Amount paid is greater than expected\" )\n\n        }\n\n\n        // for donating to find\n        if findDonationType != nil {\n            let vaultRef = self.vaultRefs[findDonationType!]!\n            let vault \u003c- vaultRef.withdraw(amount: findDonationAmount! + goesToFindFund)\n            FIND.depositWithTagAndMessage(to: \"find\", message: \"donation to .find\", tag: \"donation\", vault: \u003c- vault, from: self.token)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "nftIdentifiers",
                     "allReceivers",
                     "ids",
                     "memos",
                     "donationTypes",
                     "donationAmounts",
                     "findDonationType",
                     "findDonationAmount"
                  ],
                  "parameters": {
                     "allReceivers": "[String]",
                     "donationAmounts": "[UFix64?]",
                     "donationTypes": "[String?]",
                     "findDonationAmount": "UFix64?",
                     "findDonationType": "String?",
                     "ids": "[UInt64]",
                     "memos": "[String]",
                     "nftIdentifiers": "[String]"
                  }
               }
            },
            "sendNFTsSubsidize": {
               "code": "import NonFungibleToken from 0x1d7e57aa55817448\nimport FungibleToken from 0xf233dcee88fe0abe\nimport FlowStorageFees from 0xe467b9dd11fa00df\nimport FlowToken from 0x1654653399040a61\nimport MetadataViews from 0x1d7e57aa55817448\nimport NFTCatalog from 0x49a7cda3a1eecc29\nimport FINDNFTCatalog from 0x097bafa4e0b48eef\nimport FindViews from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\nimport FindAirdropper from 0x097bafa4e0b48eef\nimport FTRegistry from 0x097bafa4e0b48eef\nimport Profile from 0x097bafa4e0b48eef\nimport Sender from 0x097bafa4e0b48eef\n\ntransaction(nftIdentifiers: [String], allReceivers: [String] , ids:[UInt64], memos: [String], donationTypes: [String?], donationAmounts: [UFix64?], findDonationType: String?, findDonationAmount: UFix64?) {\n\n    let authPointers : [FindViews.AuthNFTPointer]\n    let paths : [PublicPath]\n    let flowVault : \u0026FungibleToken.Vault\n    let flowTokenRepayment : Capability\u003c\u0026FlowToken.Vault{FungibleToken.Receiver}\u003e\n    let defaultTokenAvailableBalance : UFix64\n\n    let royalties: [MetadataViews.Royalties?]\n    let totalRoyalties: [UFix64]\n    let vaultRefs: {String : \u0026FungibleToken.Vault}\n    var token : \u0026Sender.Token\n\n    prepare(account : AuthAccount) {\n\n        self.authPointers = []\n        self.paths = []\n        self.royalties = []\n        self.totalRoyalties = []\n        self.vaultRefs = {}\n\n        let contractData : {Type : NFTCatalog.NFTCatalogMetadata} = {}\n\n\n        for i , typeIdentifier in nftIdentifiers {\n            let type = CompositeType(typeIdentifier) ?? panic(\"Cannot refer to type with identifier : \".concat(typeIdentifier))\n\n            var data : NFTCatalog.NFTCatalogMetadata? = contractData[type]\n            if data == nil {\n                data = FINDNFTCatalog.getMetadataFromType(type) ?? panic(\"NFT Type is not supported by NFT Catalog. Type : \".concat(type.identifier))\n                contractData[type] = data\n            }\n\n            let path = data!.collectionData\n\n            var providerCap=account.getCapability\u003c\u0026{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e(path.privatePath)\n            if !providerCap.check() {\n                let newCap = account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                    path.privatePath,\n                    target: path.storagePath\n                )\n                if newCap == nil {\n                    // If linking is not successful, we link it using finds custom link\n                    let pathIdentifier = path.privatePath.toString()\n                    let findPath = PrivatePath(identifier: pathIdentifier.slice(from: \"/private/\".length , upTo: pathIdentifier.length).concat(\"_FIND\"))!\n                    account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                        findPath,\n                        target: path.storagePath\n                    )\n                    providerCap = account.getCapability\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(findPath)\n                }\n            }\n            let pointer = FindViews.AuthNFTPointer(cap: providerCap, id: ids[i])\n\n            if let dt = donationTypes[i] {\n                self.royalties.append(pointer.getRoyalty())\n                self.totalRoyalties.append(pointer.getTotalRoyaltiesCut())\n\n                // get the vault for donation\n                if self.vaultRefs[dt] == nil {\n                    let info = FTRegistry.getFTInfo(dt) ?? panic(\"This token type is not supported at the moment : \".concat(dt))\n                    let ftPath = info.vaultPath\n                    let ref = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ftPath) ?? panic(\"Cannot borrow vault reference for type : \".concat(dt))\n                    self.vaultRefs[dt] = ref\n                }\n\n            } else {\n                self.royalties.append(nil)\n                self.totalRoyalties.append(0.0)\n            }\n\n\n            self.authPointers.append(pointer)\n            self.paths.append(path.publicPath)\n        }\n\n        self.flowVault = account.borrow\u003c\u0026FlowToken.Vault\u003e(from: /storage/flowTokenVault) ?? panic(\"Cannot borrow reference to sender's flow vault\")\n        self.flowTokenRepayment = account.getCapability\u003c\u0026FlowToken.Vault{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver)\n        self.defaultTokenAvailableBalance = FlowStorageFees.defaultTokenAvailableBalance(account.address)\n\n        // get the vault for find donation\n        if let dt = findDonationType {\n            if self.vaultRefs[dt] == nil {\n                let info = FTRegistry.getFTInfo(dt) ?? panic(\"This token type is not supported at the moment : \".concat(dt))\n                let ftPath = info.vaultPath\n                let ref = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ftPath) ?? panic(\"Cannot borrow vault reference for type : \".concat(dt))\n                self.vaultRefs[dt] = ref\n            }\n        }\n\n        if account.borrow\u003c\u0026Sender.Token\u003e(from: Sender.storagePath) == nil {\n            account.save(\u003c- Sender.create(), to: Sender.storagePath)\n        }\n\n        self.token =account.borrow\u003c\u0026Sender.Token\u003e(from: Sender.storagePath)!\n\n\n    }\n\n    execute {\n        let addresses : {String : Address} = {}\n        let estimatedStorageFee = 0.0002 * UFix64(self.authPointers.length)\n        // we pass in the least amount as possible for storage fee here\n        let tempVault \u003c- self.flowVault.withdraw(amount: 0.0)\n        var vaultRef = \u0026tempVault as \u0026FungibleToken.Vault\n        if self.defaultTokenAvailableBalance \u003c= estimatedStorageFee {\n            vaultRef = self.flowVault as \u0026FungibleToken.Vault\n        } else {\n            tempVault.deposit(from: \u003c- self.flowVault.withdraw(amount: estimatedStorageFee))\n        }\n\n        let ctx : {String : String} = {\n            \"tenant\" : \"find\"\n        }\n\n        for i,  pointer in self.authPointers {\n            let receiver = allReceivers[i]\n            let id = ids[i]\n            ctx[\"message\"] = memos[i]\n            let path = self.paths[i]\n\n            var user = addresses[receiver]\n            if user == nil {\n                user = FIND.resolve(receiver) ?? panic(\"Cannot resolve user with name / address : \".concat(receiver))\n                addresses[receiver] = user\n            }\n\n            // airdrop thru airdropper\n            FindAirdropper.subsidizedAirdrop(pointer: pointer, receiver: user!, path: path, context: ctx, storagePayment: vaultRef, flowTokenRepayment: self.flowTokenRepayment, deepValidation: true)\n        }\n        self.flowVault.deposit(from: \u003c- tempVault)\n\n        // This is hard coded for spliting at the front end for now. So if there are no royalties, all goes to find\n        // AND This does not support different ft types for now.\n        var goesToFindFund = 0.0\n        for i , type in donationTypes {\n            if type == nil {\n                continue\n            }\n            let amount = donationAmounts[i]!\n            let royalties = self.royalties[i]!\n            let totalRoyalties = self.totalRoyalties[i]\n            let vaultRef = self.vaultRefs[type!]!\n            if totalRoyalties == 0.0 {\n                goesToFindFund = goesToFindFund + amount\n                continue\n            }\n\n            let balance = vaultRef.balance\n            var totalPaid = 0.0\n\n            for j, r in royalties.getRoyalties() {\n                var cap : Capability\u003c\u0026{FungibleToken.Receiver}\u003e = r.receiver\n                if !r.receiver.check(){\n                    // try to grab from profile\n                    if let ref = getAccount(r.receiver.address).getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath).borrow() {\n                        if ref.hasWallet(vaultRef.getType().identifier) {\n                            cap = getAccount(r.receiver.address).getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n                        } else if let ftInfo = FTRegistry.getFTInfo(vaultRef.getType().identifier) {\n                            cap = getAccount(r.receiver.address).getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(ftInfo.receiverPath)\n                        }\n                    }\n\n                }\n\n                if cap.check() {\n                    let individualAmount = r.cut / totalRoyalties * amount\n                    let vault \u003c- vaultRef.withdraw(amount: individualAmount)\n                    cap.borrow()!.deposit(from: \u003c- vault)\n\n                    totalPaid = totalPaid + individualAmount\n                }\n            }\n\n            assert(totalPaid \u003c= amount, message: \"Amount paid is greater than expected\" )\n\n        }\n\n\n        // for donating to find\n        if findDonationType != nil {\n            vaultRef = self.vaultRefs[findDonationType!]!\n            let vault \u003c- vaultRef.withdraw(amount: findDonationAmount! + goesToFindFund)\n            FIND.depositWithTagAndMessage(to: \"find\", message: \"donation to .find\", tag: \"donation\", vault: \u003c- vault, from: self.token)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "nftIdentifiers",
                     "allReceivers",
                     "ids",
                     "memos",
                     "donationTypes",
                     "donationAmounts",
                     "findDonationType",
                     "findDonationAmount"
                  ],
                  "parameters": {
                     "allReceivers": "[String]",
                     "donationAmounts": "[UFix64?]",
                     "donationTypes": "[String?]",
                     "findDonationAmount": "UFix64?",
                     "findDonationType": "String?",
                     "ids": "[UInt64]",
                     "memos": "[String]",
                     "nftIdentifiers": "[String]"
                  }
               }
            },
            "sendWearables": {
               "code": "import NonFungibleToken from 0x1d7e57aa55817448\nimport MetadataViews from 0x1d7e57aa55817448\nimport FindViews from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\nimport FindAirdropper from 0x097bafa4e0b48eef\nimport Wearables from 0xe81193c424cfd3fb\n\ntransaction(allReceivers: [String] , ids:[UInt64], memos: [String]) {\n\n    let authPointers : [FindViews.AuthNFTPointer]\n\n    prepare(account : AuthAccount) {\n\n        self.authPointers = []\n        let privatePath = Wearables.CollectionPrivatePath\n        let storagePath = Wearables.CollectionStoragePath\n\n        for id in ids {\n\n            var providerCap=account.getCapability\u003c\u0026{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e(privatePath)\n            if !providerCap.check() {\n                let newCap = account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                    privatePath,\n                    target: storagePath\n                )\n                if newCap == nil {\n                    // If linking is not successful, we link it using finds custom link\n                    let pathIdentifier = privatePath.toString()\n                    let findPath = PrivatePath(identifier: pathIdentifier.slice(from: \"/private/\".length , upTo: pathIdentifier.length).concat(\"_FIND\"))!\n                    account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                        findPath,\n                        target: storagePath\n                    )\n                    providerCap = account.getCapability\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(findPath)\n                }\n            }\n            let pointer = FindViews.AuthNFTPointer(cap: providerCap, id: id)\n\n            self.authPointers.append(pointer)\n        }\n\n    }\n\n    execute {\n        let addresses : {String : Address} = {}\n        let publicPath = Wearables.CollectionPublicPath\n\n        let ctx : {String : String} = {\n            \"tenant\" : \"find\"\n        }\n\n        for i,  pointer in self.authPointers {\n            let receiver = allReceivers[i]\n            let id = ids[i]\n            ctx[\"message\"] = memos[i]\n\n            var user = addresses[receiver]\n            if user == nil {\n                user = FIND.resolve(receiver) ?? panic(\"Cannot resolve user with name / address : \".concat(receiver))\n                addresses[receiver] = user\n            }\n\n            // airdrop thru airdropper\n            FindAirdropper.safeAirdrop(pointer: pointer, receiver: user!, path: publicPath, context: ctx, deepValidation: true)\n        }\n\n    }\n}",
               "spec": {
                  "order": [
                     "allReceivers",
                     "ids",
                     "memos"
                  ],
                  "parameters": {
                     "allReceivers": "[String]",
                     "ids": "[UInt64]",
                     "memos": "[String]"
                  }
               }
            },
            "setMainName": {
               "code": "import Profile from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\n\n\ntransaction(name: String) {\n\n    let leaseCollectionOwner : Capability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e\n    let profile : \u0026Profile.User\n\n    prepare(acct: AuthAccount) {\n        self.leaseCollectionOwner = acct.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        self.profile =acct.borrow\u003c\u0026Profile.User\u003e(from:Profile.storagePath)!\n    }\n\n    pre{\n        self.leaseCollectionOwner.check() : \"Not a find user\"\n        self.leaseCollectionOwner.borrow()!.getLease(name) != nil : \"You do not own this lease so you cannot set it as main name\"\n    }\n\n    execute{\n        self.profile.setFindName(name)\n    }\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "setMarketOptionFlowDandy": {
               "code": "import FindMarket from 0x097bafa4e0b48eef\nimport FlowToken from 0x1654653399040a61\nimport Dandy from 0x097bafa4e0b48eef\n\ntransaction(){\n    prepare(account: AuthAccount){\n        let path = FindMarket.TenantClientStoragePath\n        let tenantRef = account.borrow\u003c\u0026FindMarket.TenantClient\u003e(from: path) ?? panic(\"Cannot borrow Reference.\")\n\n        tenantRef.setMarketOption(name:\"FlowDandy\", cut: nil, rules:[\n            FindMarket.TenantRule(name:\"Flow\", types:[Type\u003c@FlowToken.Vault\u003e()], ruleType: \"ft\", allow: true),\n            FindMarket.TenantRule(name:\"Dandy\", types:[ Type\u003c@Dandy.NFT\u003e()], ruleType: \"nft\", allow: true)\n            ]\n        )\n    }\n}",
               "spec": {
                  "order": [],
                  "parameters": {}
               }
            },
            "setPrivateMode": {
               "code": "import Profile from 0x097bafa4e0b48eef\n\ntransaction(mode: Bool) {\n\n    let profile : \u0026Profile.User?\n\n    prepare(acct: AuthAccount) {\n        self.profile =acct.borrow\u003c\u0026Profile.User\u003e(from:Profile.storagePath)\n    }\n\n    pre{\n        self.profile != nil : \"Cannot borrow reference to profile\"\n    }\n\n    execute{\n        self.profile!.setPrivateMode(mode)\n        self.profile!.emitUpdatedEvent()\n    }\n}",
               "spec": {
                  "order": [
                     "mode"
                  ],
                  "parameters": {
                     "mode": "Bool"
                  }
               }
            },
            "setPrivateModeDapper": {
               "code": "import Profile from 0x097bafa4e0b48eef\n\ntransaction(mode: Bool) {\n\n    let profile : \u0026Profile.User?\n\n    prepare(acct: AuthAccount) {\n        self.profile =acct.borrow\u003c\u0026Profile.User\u003e(from:Profile.storagePath)\n    }\n\n    pre{\n        self.profile != nil : \"Cannot borrow reference to profile\"\n    }\n\n    execute{\n        self.profile!.setPrivateMode(mode)\n        self.profile!.emitUpdatedEvent()\n    }\n}",
               "spec": {
                  "order": [
                     "mode"
                  ],
                  "parameters": {
                     "mode": "Bool"
                  }
               }
            },
            "setProfile": {
               "code": "import Profile from 0x097bafa4e0b48eef\n\ntransaction(avatar: String) {\n\n    let profile : \u0026Profile.User?\n\n    prepare(acct: AuthAccount) {\n        self.profile =acct.borrow\u003c\u0026Profile.User\u003e(from:Profile.storagePath)\n    }\n\n    pre{\n        self.profile != nil : \"Cannot borrow reference to profile\"\n    }\n\n    execute{\n        self.profile!.setAvatar(avatar)\n        self.profile!.emitUpdatedEvent()\n    }\n}",
               "spec": {
                  "order": [
                     "avatar"
                  ],
                  "parameters": {
                     "avatar": "String"
                  }
               }
            },
            "setRelatedAccount": {
               "code": "import FindRelatedAccounts from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\n\ntransaction(name: String, target: String) {\n\n    var relatedAccounts : \u0026FindRelatedAccounts.Accounts?\n    let address : Address?\n\n    prepare(account: AuthAccount) {\n\n\n        self.address = FIND.resolve(target)\n\n        self.relatedAccounts= account.borrow\u003c\u0026FindRelatedAccounts.Accounts\u003e(from:FindRelatedAccounts.storagePath)\n        if self.relatedAccounts == nil {\n            let relatedAccounts \u003c- FindRelatedAccounts.createEmptyAccounts()\n            account.save(\u003c- relatedAccounts, to: FindRelatedAccounts.storagePath)\n            account.link\u003c\u0026FindRelatedAccounts.Accounts{FindRelatedAccounts.Public}\u003e(FindRelatedAccounts.publicPath, target: FindRelatedAccounts.storagePath)\n            self.relatedAccounts= account.borrow\u003c\u0026FindRelatedAccounts.Accounts\u003e(from:FindRelatedAccounts.storagePath)\n        }\n\n        let cap = account.getCapability\u003c\u0026FindRelatedAccounts.Accounts{FindRelatedAccounts.Public}\u003e(FindRelatedAccounts.publicPath)\n        if !cap.check() {\n            account.unlink(FindRelatedAccounts.publicPath)\n            account.link\u003c\u0026FindRelatedAccounts.Accounts{FindRelatedAccounts.Public}\u003e(FindRelatedAccounts.publicPath, target: FindRelatedAccounts.storagePath)\n        }\n    }\n\n    pre{\n        self.address != nil : \"The input pass in is not a valid name or address. Input : \".concat(target)\n    }\n\n    execute{\n        self.relatedAccounts!.addFlowAccount(name: name, address: self.address!)\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "target"
                  ],
                  "parameters": {
                     "name": "String",
                     "target": "String"
                  }
               }
            },
            "setRelatedAccountDapper": {
               "code": "import FindRelatedAccounts from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\n\ntransaction(name: String, target: String) {\n\n    var relatedAccounts : \u0026FindRelatedAccounts.Accounts?\n    let address : Address?\n\n    prepare(account: AuthAccount) {\n\n\n        self.address = FIND.resolve(target)\n\n        self.relatedAccounts= account.borrow\u003c\u0026FindRelatedAccounts.Accounts\u003e(from:FindRelatedAccounts.storagePath)\n        if self.relatedAccounts == nil {\n            let relatedAccounts \u003c- FindRelatedAccounts.createEmptyAccounts()\n            account.save(\u003c- relatedAccounts, to: FindRelatedAccounts.storagePath)\n            account.link\u003c\u0026FindRelatedAccounts.Accounts{FindRelatedAccounts.Public}\u003e(FindRelatedAccounts.publicPath, target: FindRelatedAccounts.storagePath)\n            self.relatedAccounts= account.borrow\u003c\u0026FindRelatedAccounts.Accounts\u003e(from:FindRelatedAccounts.storagePath)\n        }\n\n        let cap = account.getCapability\u003c\u0026FindRelatedAccounts.Accounts{FindRelatedAccounts.Public}\u003e(FindRelatedAccounts.publicPath)\n        if !cap.check() {\n            account.unlink(FindRelatedAccounts.publicPath)\n            account.link\u003c\u0026FindRelatedAccounts.Accounts{FindRelatedAccounts.Public}\u003e(FindRelatedAccounts.publicPath, target: FindRelatedAccounts.storagePath)\n        }\n    }\n\n    pre{\n        self.address != nil : \"The input pass in is not a valid name or address. Input : \".concat(target)\n    }\n\n    execute{\n        self.relatedAccounts!.addFlowAccount(name: name, address: self.address!)\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "target"
                  ],
                  "parameters": {
                     "name": "String",
                     "target": "String"
                  }
               }
            },
            "setSellDandyRules": {
               "code": "import FindMarket from 0x097bafa4e0b48eef\nimport FlowToken from 0x1654653399040a61\nimport FUSD from 0x3c5959b568896393\nimport Dandy from 0x097bafa4e0b48eef\n\ntransaction(){\n    prepare(account: AuthAccount){\n        let path = FindMarket.TenantClientStoragePath\n        let tenantRef = account.borrow\u003c\u0026FindMarket.TenantClient\u003e(from: path) ?? panic(\"Cannot borrow Reference.\")\n\n        tenantRef.setMarketOption(name:\"FUSDDandy\", cut: nil, rules:[\n            FindMarket.TenantRule(name:\"FUSD\", types:[Type\u003c@FUSD.Vault\u003e()], ruleType: \"ft\", allow: true),\n            FindMarket.TenantRule(name:\"Dandy\", types:[ Type\u003c@Dandy.NFT\u003e()], ruleType: \"nft\", allow: true)\n            ]\n        )\n\n        tenantRef.setMarketOption(name:\"FlowDandy\", cut: nil, rules:[\n            FindMarket.TenantRule(name:\"Flow\", types:[Type\u003c@FlowToken.Vault\u003e()], ruleType: \"ft\", allow: true),\n            FindMarket.TenantRule(name:\"Dandy\", types:[ Type\u003c@Dandy.NFT\u003e()], ruleType: \"nft\", allow: true)\n            ]\n        )\n\n    }\n}",
               "spec": {
                  "order": [],
                  "parameters": {}
               }
            },
            "setTenantRuleFUSD": {
               "code": "import FindMarket from 0x097bafa4e0b48eef\nimport FUSD from 0x3c5959b568896393\n\ntransaction(optionName: String){\n    prepare(account: AuthAccount){\n        let path = FindMarket.TenantClientStoragePath\n        let tenantRef = account.borrow\u003c\u0026FindMarket.TenantClient\u003e(from: path) ?? panic(\"Cannot borrow Reference.\")\n\n        tenantRef.setTenantRule(optionName: optionName, tenantRule:\n            FindMarket.TenantRule(name:\"FUSD\", types:[Type\u003c@FUSD.Vault\u003e()], ruleType: \"ft\", allow: true)\n        )\n    }\n}",
               "spec": {
                  "order": [
                     "optionName"
                  ],
                  "parameters": {
                     "optionName": "String"
                  }
               }
            },
            "startNameAuction": {
               "code": "import FIND from 0x097bafa4e0b48eef\n\ntransaction(name: String) {\n\n    let finLeases : \u0026FIND.LeaseCollection?\n\n    prepare(account: AuthAccount) {\n        self.finLeases= account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)\n    }\n\n    pre{\n        self.finLeases != nil : \"Cannot borrow reference to find lease collection\"\n    }\n\n    execute{\n        self.finLeases!.startAuction(name)\n    }\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "storeCuratedCollections": {
               "code": "transaction(collections: {String :  [String]}) {\n    prepare(account: AuthAccount) {\n\n        let path=/storage/FindCuratedCollections\n        let publicPath=/public/FindCuratedCollections\n\n        if account.borrow\u003c\u0026{String: [String]}\u003e(from:path) != nil {\n             account.load\u003c{String: [String]}\u003e(from:path)\n        }\n        account.save(collections, to: path)\n\n        let link = account.getCapability\u003c\u0026{String: [String]}\u003e(publicPath)\n        if !link.check() {\n            account.link\u003c\u0026{String: [String]}\u003e( publicPath, target: path)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "collections"
                  ],
                  "parameters": {
                     "collections": "{String: [String]}"
                  }
               }
            },
            "tenantsetExtraCut": {
               "code": "import FindMarket from 0x097bafa4e0b48eef\nimport FindMarketCutStruct from 0x097bafa4e0b48eef\n\ntransaction(ftTypes: [String], category: String, cuts: [FindMarketCutStruct.ThresholdCut]){\n    prepare(account: AuthAccount){\n\n        let types : [Type] = []\n        for t in ftTypes {\n            types.append(CompositeType(t)!)\n        }\n\n        let allCuts = FindMarketCutStruct.Cuts(cuts)\n\n        let clientRef = account.borrow\u003c\u0026FindMarket.TenantClient\u003e(from: FindMarket.TenantClientStoragePath) ?? panic(\"Cannot borrow Tenant Client Reference.\")\n        clientRef.setExtraCut(types: types, category: category, cuts: allCuts)\n    }\n}",
               "spec": {
                  "order": [
                     "ftTypes",
                     "category",
                     "cuts"
                  ],
                  "parameters": {
                     "category": "String",
                     "cuts": "[FindMarketCutStruct.ThresholdCut]",
                     "ftTypes": "[String]"
                  }
               }
            },
            "tenantsetLeaseOptionDapper": {
               "code": "import FindMarket from 0x097bafa4e0b48eef\nimport DapperUtilityCoin from 0xead892083b3e2c6c\nimport FlowUtilityToken from 0xead892083b3e2c6c\nimport FindLeaseMarketSale from 0x097bafa4e0b48eef\nimport FindLeaseMarketAuctionSoft from 0x097bafa4e0b48eef\nimport FindLeaseMarketDirectOfferSoft from 0x097bafa4e0b48eef\nimport MetadataViews from 0x1d7e57aa55817448\nimport FungibleToken from 0xf233dcee88fe0abe\nimport FungibleTokenSwitchboard from 0xf233dcee88fe0abe\n\ntransaction(nftName: String, nftType: String, cut: UFix64){\n    prepare(account: AuthAccount){\n\n        let defaultRules : [FindMarket.TenantRule] = [\n            FindMarket.TenantRule(\n                name: \"Dapper\",\n                types:[Type\u003c@DapperUtilityCoin.Vault\u003e(), Type\u003c@FlowUtilityToken.Vault\u003e()],\n                ruleType: \"ft\",\n                allow:true\n            ),\n            FindMarket.TenantRule(\n                name: \"Soft\",\n                types:[Type\u003c@FindLeaseMarketSale.SaleItem\u003e(),\n                Type\u003c@FindLeaseMarketAuctionSoft.SaleItem\u003e(),\n                Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItem\u003e()\n                ],\n                ruleType: \"listing\",\n                allow:true\n            )\n        ]\n\n        defaultRules.append(\n            FindMarket.TenantRule(\n                name: nftName,\n                types:[CompositeType(nftType)!],\n                ruleType: \"nft\",\n                allow:true\n            )\n        )\n\n        var royalty : MetadataViews.Royalty? = nil\n        if cut != 0.0 {\n            royalty = MetadataViews.Royalty(\n                receiver: account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(FungibleTokenSwitchboard.ReceiverPublicPath),\n                cut: cut,\n                description: \"tenant\"\n            )\n        }\n\n        let saleItem = FindMarket.TenantSaleItem(\n            name: \"Dapper\".concat(nftName).concat(\"Soft\"),\n            cut: royalty,\n            rules: defaultRules,\n            status: \"active\"\n        )\n\n        let clientRef = account.borrow\u003c\u0026FindMarket.TenantClient\u003e(from: FindMarket.TenantClientStoragePath) ?? panic(\"Cannot borrow Tenant Client Reference.\")\n        clientRef.setMarketOption(saleItem: saleItem)\n    }\n}",
               "spec": {
                  "order": [
                     "nftName",
                     "nftType",
                     "cut"
                  ],
                  "parameters": {
                     "cut": "UFix64",
                     "nftName": "String",
                     "nftType": "String"
                  }
               }
            },
            "tenantsetMarketOption": {
               "code": "import FindMarket from 0x097bafa4e0b48eef\nimport FlowToken from 0x1654653399040a61\nimport FUSD from 0x3c5959b568896393\nimport FiatToken from 0xb19436aae4d94622\nimport FindMarketSale from 0x097bafa4e0b48eef\nimport FindMarketAuctionEscrow from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferEscrow from 0x097bafa4e0b48eef\nimport MetadataViews from 0x1d7e57aa55817448\nimport FungibleToken from 0xf233dcee88fe0abe\nimport FungibleTokenSwitchboard from 0xf233dcee88fe0abe\n\ntransaction(nftName: String, nftType: String, cut: UFix64){\n    prepare(account: AuthAccount){\n\n        let defaultRules : [FindMarket.TenantRule] = [\n            FindMarket.TenantRule(\n                name: \"Flow\",\n                types:[\n                    Type\u003c@FlowToken.Vault\u003e()\n                    ],\n                ruleType: \"ft\",\n                allow:true\n            ),\n            FindMarket.TenantRule(\n                name: nftName,\n                types:[CompositeType(nftType)!],\n                ruleType: \"nft\",\n                allow:true\n            ),\n                FindMarket.TenantRule(\n                name: \"Escrow\",\n                types:[Type\u003c@FindMarketSale.SaleItem\u003e(), Type\u003c@FindMarketAuctionEscrow.SaleItem\u003e(), Type\u003c@FindMarketDirectOfferEscrow.SaleItem\u003e()],\n                ruleType: \"listing\",\n                allow:true\n            )\n        ]\n\n        var royalty : MetadataViews.Royalty? = nil\n        if cut != 0.0 {\n            royalty = MetadataViews.Royalty(\n                receiver: account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(FungibleTokenSwitchboard.ReceiverPublicPath),\n                cut: cut,\n                description: \"tenant\"\n            )\n        }\n\n        let saleItem = FindMarket.TenantSaleItem(\n            name: \"Flow\".concat(nftName).concat(\"Escrow\"),\n            cut: royalty,\n            rules: defaultRules,\n            status: \"active\"\n        )\n\n        let clientRef = account.borrow\u003c\u0026FindMarket.TenantClient\u003e(from: FindMarket.TenantClientStoragePath) ?? panic(\"Cannot borrow Tenant Client Reference.\")\n        clientRef.setMarketOption(saleItem: saleItem)\n    }\n}",
               "spec": {
                  "order": [
                     "nftName",
                     "nftType",
                     "cut"
                  ],
                  "parameters": {
                     "cut": "UFix64",
                     "nftName": "String",
                     "nftType": "String"
                  }
               }
            },
            "tenantsetMarketOptionDUC": {
               "code": "import FindMarket from 0x097bafa4e0b48eef\nimport DapperUtilityCoin from 0xead892083b3e2c6c\nimport FlowUtilityToken from 0xead892083b3e2c6c\nimport FindLeaseMarketSale from 0x097bafa4e0b48eef\nimport FindLeaseMarketAuctionSoft from 0x097bafa4e0b48eef\nimport FindLeaseMarketDirectOfferSoft from 0x097bafa4e0b48eef\nimport MetadataViews from 0x1d7e57aa55817448\nimport FungibleToken from 0xf233dcee88fe0abe\nimport FungibleTokenSwitchboard from 0xf233dcee88fe0abe\n\ntransaction(nftName: String, nftType: String, cut: UFix64){\n    prepare(account: AuthAccount){\n\n        let defaultRules : [FindMarket.TenantRule] = [\n            FindMarket.TenantRule(\n                name: \"Dapper\",\n                types:[\n                    // Type\u003c@FlowUtilityToken.Vault\u003e(),\n                    Type\u003c@DapperUtilityCoin.Vault\u003e()\n                ],\n                ruleType: \"ft\",\n                allow:true\n            ),\n            FindMarket.TenantRule(\n                name: \"Soft\",\n                types:[\n                    Type\u003c@FindLeaseMarketSale.SaleItem\u003e(),\n                    Type\u003c@FindLeaseMarketAuctionSoft.SaleItem\u003e(),\n                    Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItem\u003e()\n                ],\n                ruleType: \"listing\",\n                allow:true\n            )\n        ]\n\n        defaultRules.append(\n            FindMarket.TenantRule(\n                name: nftName,\n                types:[CompositeType(nftType)!],\n                ruleType: \"nft\",\n                allow:true\n            )\n        )\n\n        var royalty : MetadataViews.Royalty? = nil\n        if cut != 0.0 {\n            royalty = MetadataViews.Royalty(\n                receiver: account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(FungibleTokenSwitchboard.ReceiverPublicPath),\n                cut: cut,\n                description: \"tenant\"\n            )\n        }\n\n        let saleItem = FindMarket.TenantSaleItem(\n            name: \"Dapper\".concat(nftName).concat(\"Soft\"),\n            cut: royalty,\n            rules: defaultRules,\n            status: \"active\"\n        )\n\n        let clientRef = account.borrow\u003c\u0026FindMarket.TenantClient\u003e(from: FindMarket.TenantClientStoragePath) ?? panic(\"Cannot borrow Tenant Client Reference.\")\n        clientRef.setMarketOption(saleItem: saleItem)\n    }\n}",
               "spec": {
                  "order": [
                     "nftName",
                     "nftType",
                     "cut"
                  ],
                  "parameters": {
                     "cut": "UFix64",
                     "nftName": "String",
                     "nftType": "String"
                  }
               }
            },
            "tenantsetMarketOptionDapper": {
               "code": "import FindMarket from 0x097bafa4e0b48eef\nimport DapperUtilityCoin from 0xead892083b3e2c6c\nimport FlowUtilityToken from 0xead892083b3e2c6c\nimport FindMarketSale from 0x097bafa4e0b48eef\nimport FindMarketAuctionSoft from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferSoft from 0x097bafa4e0b48eef\nimport MetadataViews from 0x1d7e57aa55817448\nimport FungibleToken from 0xf233dcee88fe0abe\nimport FungibleTokenSwitchboard from 0xf233dcee88fe0abe\n\ntransaction(nftName: String, nftType: String, cut: UFix64){\n    prepare(account: AuthAccount){\n\n        let defaultRules : [FindMarket.TenantRule] = [\n            FindMarket.TenantRule(\n                name: \"Dapper\",\n                types:[\n                    Type\u003c@FlowUtilityToken.Vault\u003e(),\n                    Type\u003c@DapperUtilityCoin.Vault\u003e()\n                ],\n                ruleType: \"ft\",\n                allow:true\n            ),\n            FindMarket.TenantRule(\n                name: \"Soft\",\n                types:[\n                    Type\u003c@FindMarketSale.SaleItem\u003e(),\n                    Type\u003c@FindMarketAuctionSoft.SaleItem\u003e(),\n                    Type\u003c@FindMarketDirectOfferSoft.SaleItem\u003e()\n                ],\n                ruleType: \"listing\",\n                allow:true\n            )\n        ]\n\n        defaultRules.append(\n            FindMarket.TenantRule(\n                name: nftName,\n                types:[CompositeType(nftType)!],\n                ruleType: \"nft\",\n                allow:true\n            )\n        )\n\n        var royalty : MetadataViews.Royalty? = nil\n        if cut != 0.0 {\n            royalty = MetadataViews.Royalty(\n                receiver: account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(FungibleTokenSwitchboard.ReceiverPublicPath),\n                cut: cut,\n                description: \"tenant\"\n            )\n        }\n\n        let saleItem = FindMarket.TenantSaleItem(\n            name: \"Dapper\".concat(nftName).concat(\"Soft\"),\n            cut: royalty,\n            rules: defaultRules,\n            status: \"active\"\n        )\n\n        let clientRef = account.borrow\u003c\u0026FindMarket.TenantClient\u003e(from: FindMarket.TenantClientStoragePath) ?? panic(\"Cannot borrow Tenant Client Reference.\")\n        clientRef.setMarketOption(saleItem: saleItem)\n    }\n}",
               "spec": {
                  "order": [
                     "nftName",
                     "nftType",
                     "cut"
                  ],
                  "parameters": {
                     "cut": "UFix64",
                     "nftName": "String",
                     "nftType": "String"
                  }
               }
            },
            "testInitFUSDVault": {
               "code": "import FungibleToken from 0xf233dcee88fe0abe\nimport FUSD from 0x3c5959b568896393\nimport FiatToken from 0xb19436aae4d94622\n\n\ntransaction() {\n    prepare(account: AuthAccount) {\n        let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n        if !fusdReceiver.check() {\n            let fusd \u003c- FUSD.createEmptyVault()\n            account.save(\u003c- fusd, to: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n        }\n\n    }\n}",
               "spec": {
                  "order": [],
                  "parameters": {}
               }
            },
            "unfollow": {
               "code": "import FIND from 0x097bafa4e0b48eef\nimport Profile from 0x097bafa4e0b48eef\n\n// array of [User in string (find name or address)]\ntransaction(unfollows:[String]) {\n\n    let profile : \u0026Profile.User\n\n    prepare(account: AuthAccount) {\n\n        self.profile =account.borrow\u003c\u0026Profile.User\u003e(from:Profile.storagePath) ?? panic(\"Cannot borrow reference to profile\")\n\n    }\n\n    execute{\n        for key in unfollows {\n            let user = FIND.resolve(key) ?? panic(key.concat(\" cannot be resolved. It is either an invalid .find name or address\"))\n            self.profile.unfollow(user)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "unfollows"
                  ],
                  "parameters": {
                     "unfollows": "[String]"
                  }
               }
            },
            "unlinkDUCVaultReceiver": {
               "code": "import TokenForwarding from 0xe544175ee0461c4b\n\n\ntransaction() {\n    prepare(account: AuthAccount) {\n        account.unlink(/public/dapperUtilityCoinReceiver)\n    }\n}",
               "spec": {
                  "order": [],
                  "parameters": {}
               }
            },
            "updateRelatedAccount": {
               "code": "import FindRelatedAccounts from 0x097bafa4e0b48eef\n\ntransaction(name: String, network: String, oldAddress:String, address: String) {\n\n    var relatedAccounts : \u0026FindRelatedAccounts.Accounts?\n\n    prepare(account: AuthAccount) {\n\n        self.relatedAccounts= account.borrow\u003c\u0026FindRelatedAccounts.Accounts\u003e(from:FindRelatedAccounts.storagePath)\n        if self.relatedAccounts == nil {\n            let relatedAccounts \u003c- FindRelatedAccounts.createEmptyAccounts()\n            account.save(\u003c- relatedAccounts, to: FindRelatedAccounts.storagePath)\n            account.link\u003c\u0026FindRelatedAccounts.Accounts{FindRelatedAccounts.Public}\u003e(FindRelatedAccounts.publicPath, target: FindRelatedAccounts.storagePath)\n            self.relatedAccounts = account.borrow\u003c\u0026FindRelatedAccounts.Accounts\u003e(from:FindRelatedAccounts.storagePath)\n        }\n\n        let cap = account.getCapability\u003c\u0026FindRelatedAccounts.Accounts{FindRelatedAccounts.Public}\u003e(FindRelatedAccounts.publicPath)\n        if !cap.check() {\n            account.unlink(FindRelatedAccounts.publicPath)\n            account.link\u003c\u0026FindRelatedAccounts.Accounts{FindRelatedAccounts.Public}\u003e(FindRelatedAccounts.publicPath, target: FindRelatedAccounts.storagePath)\n        }\n    }\n\n    execute {\n        self.relatedAccounts!.updateRelatedAccount(name:name, network:network, oldAddress: oldAddress, address: address)\n    }\n\n}",
               "spec": {
                  "order": [
                     "name",
                     "network",
                     "oldAddress",
                     "address"
                  ],
                  "parameters": {
                     "address": "String",
                     "name": "String",
                     "network": "String",
                     "oldAddress": "String"
                  }
               }
            },
            "updateRelatedFlowAccount": {
               "code": "import FindRelatedAccounts from 0x097bafa4e0b48eef\n\ntransaction(name: String, oldAddress: Address, address: Address) {\n\n    var relatedAccounts : \u0026FindRelatedAccounts.Accounts?\n\n    prepare(account: AuthAccount) {\n\n        self.relatedAccounts= account.borrow\u003c\u0026FindRelatedAccounts.Accounts\u003e(from:FindRelatedAccounts.storagePath)\n        if self.relatedAccounts == nil {\n            let relatedAccounts \u003c- FindRelatedAccounts.createEmptyAccounts()\n            account.save(\u003c- relatedAccounts, to: FindRelatedAccounts.storagePath)\n            account.link\u003c\u0026FindRelatedAccounts.Accounts{FindRelatedAccounts.Public}\u003e(FindRelatedAccounts.publicPath, target: FindRelatedAccounts.storagePath)\n            self.relatedAccounts = account.borrow\u003c\u0026FindRelatedAccounts.Accounts\u003e(from:FindRelatedAccounts.storagePath)\n        }\n\n        let cap = account.getCapability\u003c\u0026FindRelatedAccounts.Accounts{FindRelatedAccounts.Public}\u003e(FindRelatedAccounts.publicPath)\n        if !cap.check() {\n            account.unlink(FindRelatedAccounts.publicPath)\n            account.link\u003c\u0026FindRelatedAccounts.Accounts{FindRelatedAccounts.Public}\u003e(FindRelatedAccounts.publicPath, target: FindRelatedAccounts.storagePath)\n        }\n    }\n\n    execute {\n        self.relatedAccounts!.updateFlowAccount(name:name, oldAddress: oldAddress, address: address)\n    }\n\n}",
               "spec": {
                  "order": [
                     "name",
                     "oldAddress",
                     "address"
                  ],
                  "parameters": {
                     "address": "Address",
                     "name": "String",
                     "oldAddress": "Address"
                  }
               }
            }
         }
      },
      "testnet": {
         "scripts": {
            "batchParty": {
               "code": "import MetadataViews from  0x631e88ae7f1d7c20\nimport PartyFavorz from 0x3e5b4c627064625d\n\npub fun main(users:[Address]) : AnyStruct {\n\n    let viewType= Type\u003cMetadataViews.Display\u003e()\n\n    let addressNames : {Address : [String]} = {}\n    let addresses:  {Address: [String] }={}\n    for  user in users {\n        let account=getAccount(user)\n        let aeraCap = account.getCapability\u003c\u0026PartyFavorz.Collection{MetadataViews.ResolverCollection}\u003e(\n            PartyFavorz.CollectionPublicPath\n        )\n        if !aeraCap.check() {\n            continue\n        }\n        let ref = aeraCap.borrow()!\n        let names : [String] = []\n        for id in ref.getIDs() {\n            let resolver=ref.borrowViewResolver(id: id)\n            if let display = MetadataViews.getDisplay(resolver) {\n                names.append(display.name)\n            }\n        }\n\n        addressNames[user]=names\n    }\n    return addressNames\n}",
               "spec": {
                  "order": [
                     "users"
                  ],
                  "parameters": {
                     "users": "[Address]"
                  }
               }
            },
            "getAlchemy1IDs": {
               "code": "import MetadataViews from 0x631e88ae7f1d7c20\nimport FIND from 0x35717efbbce11c74\n// /* Alchemy Mainnet Wrapper */\n// import AlchemyMetadataWrapperMainnetShard1 from 0xeb8cb4c3157d5dac\n// import AlchemyMetadataWrapperMainnetShard2 from 0xeb8cb4c3157d5dac\n// import AlchemyMetadataWrapperMainnetShard3 from 0xeb8cb4c3157d5dac\n// import AlchemyMetadataWrapperMainnetShard4 from 0xeb8cb4c3157d5dac\n\n// /* Alchemy Testnet Wrapper */\n\nimport AlchemyMetadataWrapperTestnetShard1 from 0x5ff2c7b4c40de11\n// import AlchemyMetadataWrapperTestnetShard2 from 0x5ff2c7b4c40de11\n// import AlchemyMetadataWrapperTestnetShard3 from 0x5ff2c7b4c40de11\n\n\n\n\n    pub fun main(user: String, collections: [String]) : {String : ItemReport}  {\n        return fetchAlchemyShard1(user: user, targetCollections:collections)\n    }\n\n\n    pub struct ItemReport {\n        pub let length : Int // mapping of collection to no. of ids \n        pub let extraIDs : [UInt64]\n        pub let shard : String \n        pub let extraIDsIdentifier : String \n        pub let collectionName: String\n\n        init(length : Int, extraIDs :[UInt64] , shard: String, extraIDsIdentifier: String, collectionName: String) {\n            self.length=length \n            self.extraIDs=extraIDs\n            self.shard=shard\n            self.extraIDsIdentifier=extraIDsIdentifier\n            self.collectionName=collectionName\n        }\n    }\n\n    // Helper function \n\n    pub fun resolveAddress(user: String) : Address? {\n        return FIND.resolve(user)\n    }\n\n\n    pub fun fetchAlchemyShard1(user: String, targetCollections: [String]) : {String : ItemReport} {\n        let source = \"Shard1\"\n        let account = resolveAddress(user: user)\n        if account == nil { return {} }\n\n\n        let extraIDs = AlchemyMetadataWrapperTestnetShard1.getNFTIDs(ownerAddress: account!)\n        let inventory : {String : ItemReport} = {}\n        var fetchedCount : Int = 0\n\n        for project in extraIDs.keys {\n            if extraIDs[project]! == nil || extraIDs[project]!.length \u003c 1{\n                extraIDs.remove(key: project)\n                continue\n            }\n            \n            let collectionLength = extraIDs[project]!.length\n\n            // by pass if this is not the target collection\n            if targetCollections.length \u003e 0 \u0026\u0026 !targetCollections.contains(project) {\n                // inventory[project] = ItemReport(items: [],  length : collectionLength, extraIDs :extraIDs[project]! , shard: source)\n                continue\n            }\n\n            inventory[project] = ItemReport(length : collectionLength, extraIDs :extraIDs[project] ?? [] , shard: source, extraIDsIdentifier: project, collectionName: project)\n\n        }\n\n        return inventory\n\n    }",
               "spec": {
                  "order": [
                     "user",
                     "collections"
                  ],
                  "parameters": {
                     "collections": "[String]",
                     "user": "String"
                  }
               }
            },
            "getAlchemy1Items": {
               "code": "import MetadataViews from 0x631e88ae7f1d7c20\nimport FIND from 0x35717efbbce11c74\n\n// /* Alchemy Mainnet Wrapper */\n// import AlchemyMetadataWrapperMainnetShard1 from 0xeb8cb4c3157d5dac\n// import AlchemyMetadataWrapperMainnetShard2 from 0xeb8cb4c3157d5dac\n// import AlchemyMetadataWrapperMainnetShard3 from 0xeb8cb4c3157d5dac\n// import AlchemyMetadataWrapperMainnetShard4 from 0xeb8cb4c3157d5dac\n\n// /* Alchemy Testnet Wrapper */\n\nimport AlchemyMetadataWrapperTestnetShard1 from 0x5ff2c7b4c40de11\n// import AlchemyMetadataWrapperTestnetShard2 from 0x5ff2c7b4c40de11\n// import AlchemyMetadataWrapperTestnetShard3 from 0x5ff2c7b4c40de11\n\npub fun main(user: String, collectionIDs: {String : [UInt64]}) : {String : [MetadataCollectionItem]} {\n    return fetchAlchemyCollectionShard1(user: user, collectionIDs: collectionIDs)\n}\n\n    pub struct CollectionReport {\n        pub let items : {String : [MetadataCollectionItem]} \n        pub let collections : {String : Int} // mapping of collection to no. of ids \n        pub let extraIDs : {String : [UInt64]} \n\n        init(items: {String : [MetadataCollectionItem]},  collections : {String : Int}, extraIDs : {String : [UInt64]} ) {\n            self.items=items \n            self.collections=collections \n            self.extraIDs=extraIDs\n        }\n    }\n\n    pub struct MetadataCollectionItem {\n        pub let id:UInt64\n        pub let name: String\n        pub let collection: String // \u003c- This will be Alias unless they want something else\n        pub let subCollection: String? // \u003c- This will be Alias unless they want something else\n        pub let nftDetailIdentifier: String\n\n        pub let media  : String\n        pub let mediaType : String \n        pub let source : String \n\n        init(id:UInt64, name: String, collection: String, subCollection: String?, media  : String, mediaType : String, source : String, nftDetailIdentifier: String) {\n            self.id=id\n            self.name=name \n            self.collection=collection \n            self.subCollection=subCollection \n            self.media=media \n            self.mediaType=mediaType \n            self.source=source\n            self.nftDetailIdentifier=nftDetailIdentifier\n        }\n    }\n\n    // Helper function \n\n    pub fun resolveAddress(user: String) : PublicAccount? {\n        let address = FIND.resolve(user)\n        if address == nil {\n            return nil\n        }\n        return getAccount(address!)\n    }\n\n        \n    //////////////////////////////////////////////////////////////\n    // Fetch Specific Collections in Shard 1\n    //////////////////////////////////////////////////////////////\n    pub fun fetchAlchemyCollectionShard1(user: String, collectionIDs: {String : [UInt64]}) : {String : [MetadataCollectionItem]} {\n        let source = \"Shard1\"\n        let account = resolveAddress(user: user)\n        if account == nil { return {} }\n        if account!.balance == 0.0 {\n            return {}\n        }\n\n        let items : {String : [MetadataCollectionItem]} = {}\n        \n        let fetchingIDs = collectionIDs\n\n        for project in fetchingIDs.keys {\n            // For passing bugs\n            if project == \"Xtingles_NFT\" {\n                fetchingIDs[\"Xtingles\"] = fetchingIDs.remove(key: project)\n            }\n\n            if project == \"RCRDSHPNFT\" {\n                fetchingIDs.remove(key: project)\n            }\n        }\n\n        for project in fetchingIDs.keys {\n            let returnedNFTs = AlchemyMetadataWrapperTestnetShard1.getNFTs(ownerAddress: account!.address, ids: {project : fetchingIDs[project]!})\n\n            var collectionItems : [MetadataCollectionItem] = []\n            for nft in returnedNFTs {\n                if nft == nil {\n                    continue\n                }\n\n                var media = \"\"\n                var mediaType = \"\"\n                if nft!.media.length \u003e 0 \u0026\u0026 nft!.media[0]?.uri != nil {\n                    let m = nft!.media[0]!\n                    mediaType = m.mimetype ?? \"\"\n                    media = m.uri!\n                }\n\n                let item = MetadataCollectionItem(\n                    id: nft!.id,\n                    name: nft!.title ?? \"\",\n                    collection: nft!.contract.name,\n                    subCollection: nil, \n                    media: media,\n                    mediaType: mediaType,\n                    source: source ,\n                    nftDetailIdentifier: project\n                )\n                collectionItems.append(item)\n            }\n\n            if collectionItems.length \u003e 0 {\n                items[project] = collectionItems\n            }\n        }\n        return items\n    }",
               "spec": {
                  "order": [
                     "user",
                     "collectionIDs"
                  ],
                  "parameters": {
                     "collectionIDs": "{String: [UInt64]}",
                     "user": "String"
                  }
               }
            },
            "getAlchemy2IDs": {
               "code": "import MetadataViews from 0x631e88ae7f1d7c20\nimport FIND from 0x35717efbbce11c74\n// /* Alchemy Mainnet Wrapper */\n// import AlchemyMetadataWrapperMainnetShard1 from 0xeb8cb4c3157d5dac\n// import AlchemyMetadataWrapperMainnetShard2 from 0xeb8cb4c3157d5dac\n// import AlchemyMetadataWrapperMainnetShard3 from 0xeb8cb4c3157d5dac\n// import AlchemyMetadataWrapperMainnetShard4 from 0xeb8cb4c3157d5dac\n\n// /* Alchemy Testnet Wrapper */\n\n// import AlchemyMetadataWrapperTestnetShard1 from 0x5ff2c7b4c40de11\nimport AlchemyMetadataWrapperTestnetShard2 from 0x5ff2c7b4c40de11\n// import AlchemyMetadataWrapperTestnetShard3 from 0x5ff2c7b4c40de11\n\n    pub fun main(user: String, collections: [String]) : {String : ItemReport} {\n        return fetchAlchemyShard2(user: user, targetCollections:collections)\n    }\n\n    pub struct ItemReport {\n        pub let length : Int // mapping of collection to no. of ids \n        pub let extraIDs : [UInt64]\n        pub let shard : String \n        pub let extraIDsIdentifier : String \n        pub let collectionName: String\n\n        init(length : Int, extraIDs :[UInt64] , shard: String, extraIDsIdentifier: String, collectionName: String) {\n            self.length=length \n            self.extraIDs=extraIDs\n            self.shard=shard\n            self.extraIDsIdentifier=extraIDsIdentifier\n            self.collectionName=collectionName\n        }\n    }\n\n    // Helper function \n\n    pub fun resolveAddress(user: String) : Address? {\n        return FIND.resolve(user)\n    }\n\n\n    pub fun fetchAlchemyShard2(user: String, targetCollections: [String]) : {String : ItemReport} {\n        let source = \"Shard2\"\n        let account = resolveAddress(user: user)\n        if account == nil { return {} }\n\n\n        let extraIDs = AlchemyMetadataWrapperTestnetShard2.getNFTIDs(ownerAddress: account!)\n        let inventory : {String : ItemReport} = {}\n        var fetchedCount : Int = 0\n\n        for project in extraIDs.keys {\n            if extraIDs[project]! == nil || extraIDs[project]!.length \u003c 1{\n                extraIDs.remove(key: project)\n                continue\n            }\n            \n            let collectionLength = extraIDs[project]!.length\n\n            // by pass if this is not the target collection\n            if targetCollections.length \u003e 0 \u0026\u0026 !targetCollections.contains(project) {\n                // inventory[project] = ItemReport(items: [],  length : collectionLength, extraIDs :extraIDs[project]! , shard: source)\n                continue\n            }\n\n            inventory[project] = ItemReport(length : collectionLength, extraIDs :extraIDs[project] ?? [] , shard: source, extraIDsIdentifier: project, collectionName: project)\n\n        }\n\n        return inventory\n\n    }\n\n    pub fun rename(_ name: String) : String {\n        if name == \"MintStoreItem.NBA ALL STAR \" {\n            return \"MintStoreItem\"\n        }\n        return name\n    }",
               "spec": {
                  "order": [
                     "user",
                     "collections"
                  ],
                  "parameters": {
                     "collections": "[String]",
                     "user": "String"
                  }
               }
            },
            "getAlchemy2Items": {
               "code": "import MetadataViews from 0x631e88ae7f1d7c20\nimport FIND from 0x35717efbbce11c74\n\n// /* Alchemy Mainnet Wrapper */\n// import AlchemyMetadataWrapperMainnetShard1 from 0xeb8cb4c3157d5dac\n// import AlchemyMetadataWrapperMainnetShard2 from 0xeb8cb4c3157d5dac\n// import AlchemyMetadataWrapperMainnetShard3 from 0xeb8cb4c3157d5dac\n// import AlchemyMetadataWrapperMainnetShard4 from 0xeb8cb4c3157d5dac\n\n// /* Alchemy Testnet Wrapper */\n\n// import AlchemyMetadataWrapperTestnetShard1 from 0x5ff2c7b4c40de11\nimport AlchemyMetadataWrapperTestnetShard2 from 0x5ff2c7b4c40de11\n// import AlchemyMetadataWrapperTestnetShard3 from 0x5ff2c7b4c40de11\n\npub fun main(user: String, collectionIDs: {String : [UInt64]}) : {String : [MetadataCollectionItem]} {\n    return fetchAlchemyCollectionShard2(user: user, collectionIDs: collectionIDs)\n}\n\n    pub struct CollectionReport {\n        pub let items : {String : [MetadataCollectionItem]} \n        pub let collections : {String : Int} // mapping of collection to no. of ids \n        pub let extraIDs : {String : [UInt64]} \n\n        init(items: {String : [MetadataCollectionItem]},  collections : {String : Int}, extraIDs : {String : [UInt64]} ) {\n            self.items=items \n            self.collections=collections \n            self.extraIDs=extraIDs\n        }\n    }\n\n    pub struct MetadataCollectionItem {\n        pub let id:UInt64\n        pub let name: String\n        pub let collection: String // \u003c- This will be Alias unless they want something else\n        pub let subCollection: String? // \u003c- This will be Alias unless they want something else\n        pub let nftDetailIdentifier: String\n\n        pub let media  : String\n        pub let mediaType : String \n        pub let source : String \n\n        init(id:UInt64, name: String, collection: String, subCollection: String?, media  : String, mediaType : String, source : String, nftDetailIdentifier: String) {\n            self.id=id\n            self.name=name \n            self.collection=collection \n            self.subCollection=subCollection \n            self.media=media \n            self.mediaType=mediaType \n            self.source=source\n            self.nftDetailIdentifier=nftDetailIdentifier\n        }\n    }\n\n    // Helper function \n\n    pub fun resolveAddress(user: String) : PublicAccount? {\n        let address = FIND.resolve(user)\n        if address == nil {\n            return nil\n        }\n        return getAccount(address!)\n    }\n\n\n    ////////////////////////////////////////////////////////////\n    // Fetch Specific Collections in Shard 2\n    ////////////////////////////////////////////////////////////\n    pub fun fetchAlchemyCollectionShard2(user: String, collectionIDs: {String : [UInt64]}) : {String : [MetadataCollectionItem]} {\n        let source = \"Shard2\"\n        let account = resolveAddress(user: user)\n        if account == nil { return {} }\n        if account!.balance == 0.0 {\n            return {}\n        }\n        \n        let items : {String : [MetadataCollectionItem]} = {}\n        \n        let fetchingIDs = collectionIDs\n\n        for project in fetchingIDs.keys {\n            // For passing bugs\n            if project == \"Xtingles_NFT\" {\n                fetchingIDs[\"Xtingles\"] = fetchingIDs.remove(key: project)\n            }\n\n            if project == \"RCRDSHPNFT\" {\n                fetchingIDs.remove(key: project)\n            }\n        }\n\n        for project in fetchingIDs.keys {\n            let returnedNFTs = AlchemyMetadataWrapperTestnetShard2.getNFTs(ownerAddress: account!.address, ids: {rename(project) : fetchingIDs[project]!})\n\n            var collectionItems : [MetadataCollectionItem] = []\n            for nft in returnedNFTs {\n                if nft == nil {\n                    continue\n                }\n\n                var media = \"\"\n                var mediaType = \"\"\n                if nft!.media.length \u003e 0 \u0026\u0026 nft!.media[0]?.uri != nil {\n                    let m = nft!.media[0]!\n                    mediaType = m.mimetype ?? \"\"\n                    media = m.uri!\n                }\n\n                let item = MetadataCollectionItem(\n                    id: nft!.id,\n                    name: nft!.title ?? \"\",\n                    collection: nft!.contract.name,\n                    subCollection: nil, \n                    media: media,\n                    mediaType: mediaType,\n                    source: source ,\n                    nftDetailIdentifier: project\n                )\n                collectionItems.append(item)\n            }\n\n            if collectionItems.length \u003e 0 {\n                items[project] = collectionItems\n            }\n        }\n        return items\n    }\n\n    pub fun rename(_ name: String) : String {\n        if name == \"MintStoreItem.NBA ALL STAR \" {\n            return \"MintStoreItem\"\n        }\n        return name\n    }",
               "spec": {
                  "order": [
                     "user",
                     "collectionIDs"
                  ],
                  "parameters": {
                     "collectionIDs": "{String: [UInt64]}",
                     "user": "String"
                  }
               }
            },
            "getAlchemy3IDs": {
               "code": "import MetadataViews from 0x631e88ae7f1d7c20\nimport FIND from 0x35717efbbce11c74\n// /* Alchemy Mainnet Wrapper */\n// import AlchemyMetadataWrapperMainnetShard1 from 0xeb8cb4c3157d5dac\n// import AlchemyMetadataWrapperMainnetShard2 from 0xeb8cb4c3157d5dac\n// import AlchemyMetadataWrapperMainnetShard3 from 0xeb8cb4c3157d5dac\n// import AlchemyMetadataWrapperMainnetShard4 from 0xeb8cb4c3157d5dac\n\n// /* Alchemy Testnet Wrapper */\n\n// import AlchemyMetadataWrapperTestnetShard1 from 0x5ff2c7b4c40de11\n// import AlchemyMetadataWrapperTestnetShard2 from 0x5ff2c7b4c40de11\nimport AlchemyMetadataWrapperTestnetShard3 from 0x5ff2c7b4c40de11\n\n    pub fun main(user: String, collections: [String]) : {String : ItemReport} {\n        return fetchAlchemyShard3(user: user, targetCollections:collections)\n    }\n\n    pub struct ItemReport {\n        pub let length : Int // mapping of collection to no. of ids \n        pub let extraIDs : [UInt64]\n        pub let shard : String \n        pub let extraIDsIdentifier : String \n        pub let collectionName: String\n\n        init(length : Int, extraIDs :[UInt64] , shard: String, extraIDsIdentifier: String, collectionName: String) {\n            self.length=length \n            self.extraIDs=extraIDs\n            self.shard=shard\n            self.extraIDsIdentifier=extraIDsIdentifier\n            self.collectionName=collectionName\n        }\n    }\n\n    // Helper function \n\n    pub fun resolveAddress(user: String) : Address? {\n        return FIND.resolve(user)\n    }\n            \n    pub fun fetchAlchemyShard3(user: String, targetCollections: [String]) : {String : ItemReport} {\n        let source = \"Shard3\"\n        let account = resolveAddress(user: user)\n        if account == nil { return {} }\n\n\n        let extraIDs = AlchemyMetadataWrapperTestnetShard3.getNFTIDs(ownerAddress: account!)\n        let inventory : {String : ItemReport} = {}\n        var fetchedCount : Int = 0\n\n        for project in extraIDs.keys {\n            if extraIDs[project]! == nil || extraIDs[project]!.length \u003c 1{\n                extraIDs.remove(key: project)\n                continue\n            }\n            \n            let collectionLength = extraIDs[project]!.length\n\n            // by pass if this is not the target collection\n            if targetCollections.length \u003e 0 \u0026\u0026 !targetCollections.contains(project) {\n                // inventory[project] = ItemReport(items: [],  length : collectionLength, extraIDs :extraIDs[project]! , shard: source)\n                continue\n            }\n\n            inventory[project] = ItemReport(length : collectionLength, extraIDs :extraIDs[project] ?? [] , shard: source, extraIDsIdentifier: project, collectionName: project)\n\n        }\n\n        return inventory\n\n    }",
               "spec": {
                  "order": [
                     "user",
                     "collections"
                  ],
                  "parameters": {
                     "collections": "[String]",
                     "user": "String"
                  }
               }
            },
            "getAlchemy3Items": {
               "code": "import MetadataViews from 0x631e88ae7f1d7c20\nimport FIND from 0x35717efbbce11c74\n\n// /* Alchemy Mainnet Wrapper */\n// import AlchemyMetadataWrapperMainnetShard1 from 0xeb8cb4c3157d5dac\n// import AlchemyMetadataWrapperMainnetShard2 from 0xeb8cb4c3157d5dac\n// import AlchemyMetadataWrapperMainnetShard3 from 0xeb8cb4c3157d5dac\n// import AlchemyMetadataWrapperMainnetShard4 from 0xeb8cb4c3157d5dac\n\n// /* Alchemy Testnet Wrapper */\n\n// import AlchemyMetadataWrapperTestnetShard1 from 0x5ff2c7b4c40de11\n// import AlchemyMetadataWrapperTestnetShard2 from 0x5ff2c7b4c40de11\nimport AlchemyMetadataWrapperTestnetShard3 from 0x5ff2c7b4c40de11\n\npub fun main(user: String, collectionIDs: {String : [UInt64]}) : {String : [MetadataCollectionItem]} {\n    return fetchAlchemyCollectionShard3(user: user, collectionIDs: collectionIDs)\n}\n\n    pub struct CollectionReport {\n        pub let items : {String : [MetadataCollectionItem]} \n        pub let collections : {String : Int} // mapping of collection to no. of ids \n        pub let extraIDs : {String : [UInt64]} \n\n        init(items: {String : [MetadataCollectionItem]},  collections : {String : Int}, extraIDs : {String : [UInt64]} ) {\n            self.items=items \n            self.collections=collections \n            self.extraIDs=extraIDs\n        }\n    }\n\n    pub struct MetadataCollectionItem {\n        pub let id:UInt64\n        pub let name: String\n        pub let collection: String // \u003c- This will be Alias unless they want something else\n        pub let subCollection: String? // \u003c- This will be Alias unless they want something else\n        pub let nftDetailIdentifier: String\n\n        pub let media  : String\n        pub let mediaType : String \n        pub let source : String \n\n        init(id:UInt64, name: String, collection: String, subCollection: String?, media  : String, mediaType : String, source : String, nftDetailIdentifier: String) {\n            self.id=id\n            self.name=name \n            self.collection=collection \n            self.subCollection=subCollection \n            self.media=media \n            self.mediaType=mediaType \n            self.source=source\n            self.nftDetailIdentifier=nftDetailIdentifier\n        }\n    }\n\n    // Helper function \n\n    pub fun resolveAddress(user: String) : PublicAccount? {\n        let address = FIND.resolve(user)\n        if address == nil {\n            return nil\n        }\n        return getAccount(address!)\n    }\n\n\n    //////////////////////////////////////////////////////////////\n    // Fetch Specific Collections in Shard 3\n    //////////////////////////////////////////////////////////////\n    pub fun fetchAlchemyCollectionShard3(user: String, collectionIDs: {String : [UInt64]}) : {String : [MetadataCollectionItem]} {\n        let source = \"Shard3\"\n        let account = resolveAddress(user: user)\n        if account == nil { return {} }\n        if account!.balance == 0.0 {\n            return {}\n        }\n        \n        let items : {String : [MetadataCollectionItem]} = {}\n        \n        let fetchingIDs = collectionIDs\n\n        for project in fetchingIDs.keys {\n            // For passing bugs\n            if project == \"Xtingles_NFT\" {\n                fetchingIDs[\"Xtingles\"] = fetchingIDs.remove(key: project)\n            }\n\n            if project == \"RCRDSHPNFT\" {\n                fetchingIDs.remove(key: project)\n            }\n        }\n\n        for project in fetchingIDs.keys {\n            let returnedNFTs = AlchemyMetadataWrapperTestnetShard3.getNFTs(ownerAddress: account!.address, ids: {project : fetchingIDs[project]!})\n\n            var collectionItems : [MetadataCollectionItem] = []\n            for nft in returnedNFTs {\n                if nft == nil {\n                    continue\n                }\n\n                var media = \"\"\n                var mediaType = \"\"\n                if nft!.media.length \u003e 0 \u0026\u0026 nft!.media[0]?.uri != nil {\n                    let m = nft!.media[0]!\n                    mediaType = m.mimetype ?? \"\"\n                    media = m.uri!\n                }\n\n                let item = MetadataCollectionItem(\n                    id: nft!.id,\n                    name: nft!.title ?? \"\",\n                    collection: nft!.contract.name,\n                    subCollection: nil, \n                    media: media,\n                    mediaType: mediaType,\n                    source: source ,\n                    nftDetailIdentifier: project\n                )\n                collectionItems.append(item)\n            }\n\n            if collectionItems.length \u003e 0 {\n                items[project] = collectionItems\n            }\n        }\n        return items\n    }",
               "spec": {
                  "order": [
                     "user",
                     "collectionIDs"
                  ],
                  "parameters": {
                     "collectionIDs": "{String: [UInt64]}",
                     "user": "String"
                  }
               }
            },
            "getAlchemy4IDs": {
               "code": "import MetadataViews from 0x631e88ae7f1d7c20\nimport FIND from 0x35717efbbce11c74\n// /* Alchemy Mainnet Wrapper */\n// import AlchemyMetadataWrapperMainnetShard1 from 0xeb8cb4c3157d5dac\n// import AlchemyMetadataWrapperMainnetShard2 from 0xeb8cb4c3157d5dac\n// import AlchemyMetadataWrapperMainnetShard3 from 0xeb8cb4c3157d5dac\n// import AlchemyMetadataWrapperMainnetShard4 from 0xeb8cb4c3157d5dac\n\n// /* Alchemy Testnet Wrapper */\n\n// import AlchemyMetadataWrapperTestnetShard1 from 0x5ff2c7b4c40de11\n// import AlchemyMetadataWrapperTestnetShard2 from 0x5ff2c7b4c40de11\n// import AlchemyMetadataWrapperTestnetShard3 from 0x5ff2c7b4c40de11\n\n    pub fun main(user: String, collections: [String]) : {String : ItemReport}  {\n        return {}\n    }\n\n\n    pub struct ItemReport {\n        pub let length : Int // mapping of collection to no. of ids \n        pub let extraIDs : [UInt64]\n        pub let shard : String \n        pub let extraIDsIdentifier : String \n        pub let collectionName: String\n\n        init(length : Int, extraIDs :[UInt64] , shard: String, extraIDsIdentifier: String, collectionName: String) {\n            self.length=length \n            self.extraIDs=extraIDs\n            self.shard=shard\n            self.extraIDsIdentifier=extraIDsIdentifier\n            self.collectionName=collectionName\n        }\n    }",
               "spec": {
                  "order": [
                     "user",
                     "collections"
                  ],
                  "parameters": {
                     "collections": "[String]",
                     "user": "String"
                  }
               }
            },
            "getAlchemy4Items": {
               "code": "import MetadataViews from 0x631e88ae7f1d7c20\nimport FIND from 0x35717efbbce11c74\n\n// /* Alchemy Mainnet Wrapper */\n// import AlchemyMetadataWrapperMainnetShard1 from 0xeb8cb4c3157d5dac\n// import AlchemyMetadataWrapperMainnetShard2 from 0xeb8cb4c3157d5dac\n// import AlchemyMetadataWrapperMainnetShard3 from 0xeb8cb4c3157d5dac\n// import AlchemyMetadataWrapperMainnetShard4 from 0xeb8cb4c3157d5dac\n\n// /* Alchemy Testnet Wrapper */\n\n// import AlchemyMetadataWrapperTestnetShard1 from 0x5ff2c7b4c40de11\n// import AlchemyMetadataWrapperTestnetShard2 from 0x5ff2c7b4c40de11\n// import AlchemyMetadataWrapperTestnetShard3 from 0x5ff2c7b4c40de11\n\npub fun main(user: String, collectionIDs: {String : [UInt64]}) : {String : [MetadataCollectionItem]} {\n    return {}\n}\n\n    pub struct MetadataCollectionItem {\n        pub let id:UInt64\n        pub let name: String\n        pub let collection: String // \u003c- This will be Alias unless they want something else\n        pub let subCollection: String? // \u003c- This will be Alias unless they want something else\n        pub let nftDetailIdentifier: String\n\n        pub let media  : String\n        pub let mediaType : String \n        pub let source : String \n\n        init(id:UInt64, name: String, collection: String, subCollection: String?, media  : String, mediaType : String, source : String, nftDetailIdentifier: String) {\n            self.id=id\n            self.name=name \n            self.collection=collection \n            self.subCollection=subCollection \n            self.media=media \n            self.mediaType=mediaType \n            self.source=source\n            self.nftDetailIdentifier=nftDetailIdentifier\n        }\n    }",
               "spec": {
                  "order": [
                     "user",
                     "collectionIDs"
                  ],
                  "parameters": {
                     "collectionIDs": "{String: [UInt64]}",
                     "user": "String"
                  }
               }
            },
            "getAllFindPackSaleDetails": {
               "code": "import FindPack from 0x35717efbbce11c74\nimport FTRegistry from 0x35717efbbce11c74\nimport MetadataViews from 0x631e88ae7f1d7c20\n\npub fun main(packTypeName: String) : {UInt64 : Report} {\n    let packs = FindPack.getMetadataByName(packTypeName: packTypeName)\n    let packData : {UInt64 : Report} = {}\n    for packTypeId in packs.keys {\n        if let metadata = FindPack.getMetadataById(packTypeName: packTypeName, typeId: packTypeId) {\n            let packsLeft = FindPack.getPacksCollection(packTypeName: packTypeName, packTypeId: packTypeId).getPacksLeft()\n            packData[packTypeId] = Report(metadata, packsLeft: packsLeft)\n        }\n    }\n    return packData\n}\n\npub struct Report {\n        pub let name: String\n        pub let description: String\n\n        pub let thumbnailHash: String?\n        pub let thumbnailUrl:String?\n\n        pub let walletType: String\n        pub let walletAlias: String?\n\n        pub let openTime: UFix64\n        pub var saleEnded: Bool\n        pub let saleInfos: [SaleInfo]\n\n        pub let storageRequirement: UInt64\n        pub let collectionDisplay: MetadataViews.NFTCollectionDisplay\n\n        pub let itemTypes: [Type]\n\n        pub let extraData : {String : AnyStruct}\n        pub let packFields: {String : String}\n        pub let requiresReservation: Bool\n\n        pub let packsLeft : Int \n\n        init(_ md: FindPack.Metadata, packsLeft: Int) {\n            self.packsLeft = packsLeft\n            self.name=md.name\n            self.description=md.description\n            self.thumbnailHash=md.thumbnailHash\n            self.thumbnailUrl=md.thumbnailUrl\n            self.walletType=md.walletType.identifier\n            self.walletAlias=FTRegistry.getFTInfoByTypeIdentifier(md.walletType.identifier)?.alias\n            self.openTime=md.openTime\n            self.storageRequirement=md.storageRequirement\n            self.itemTypes=md.itemTypes\n            self.extraData=md.extraData\n            self.packFields=md.packFields\n            self.requiresReservation=md.requiresReservation\n            self.saleInfos=convertSaleInfo(md.saleInfos)\n            self.collectionDisplay=md.collectionDisplay\n            self.saleEnded=true\n            if self.packsLeft != 0 {\n                self.saleEnded=false\n            } else {\n                let currentTime = getCurrentBlock().timestamp\n                var saleEnded = true\n                for saleInfo in self.saleInfos{\n                    if saleInfo.endTime == nil || saleInfo.endTime! \u003e currentTime {\n                        saleEnded=true\n                        break\n                    }\n                }\n            }\n        }\n}\n\npub struct SaleInfo {\n        pub let name : String\n        pub let startTime : UFix64 \n        pub let endTime : UFix64?\n        pub let price : UFix64\n        pub let purchaseLimit : UInt64?\n        pub let purchaseRecord : {Address : UInt64}\n        pub let verifiers : [String]\n        pub let verifyAll : Bool \n\n        init(_ si: FindPack.SaleInfo) {\n            self.name=si.name\n            self.startTime=si.startTime\n            self.endTime=si.endTime\n            self.price=si.price\n            self.purchaseLimit=si.purchaseLimit\n            self.purchaseRecord=si.purchaseRecord\n\n            var verifierDesc : [String] = []\n            for verifier in si.verifiers {\n                verifierDesc.append(verifier.description)\n            }\n            self.verifiers=verifierDesc\n            self.verifyAll=si.verifyAll\n        }\n}\n\npub fun convertSaleInfo(_ info: [FindPack.SaleInfo]) : [SaleInfo] {\n    let res : [SaleInfo] = []\n    for i in info {\n        res.append(SaleInfo(i))\n    }\n    return res\n}",
               "spec": {
                  "order": [
                     "packTypeName"
                  ],
                  "parameters": {
                     "packTypeName": "String"
                  }
               }
            },
            "getAllNFTViews": {
               "code": "import MetadataViews from 0x631e88ae7f1d7c20\nimport FINDNFTCatalog from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\n\n//Fetch a single view from a nft on a given path\npub fun main(user: String, aliasOrIdentifier:String, id: UInt64) : {String : AnyStruct} {\n\n    let publicPath = getPublicPath(aliasOrIdentifier)\n    let resolveAddress = FIND.resolve(user) \n    if resolveAddress == nil {return {}}\n    let address = resolveAddress!\n\n    let pp = publicPath\n    let account = getAccount(address)\n    if account.balance == 0.0 {\n        return {}\n    }\n    let collection= account.getCapability(pp).borrow\u003c\u0026{MetadataViews.ResolverCollection}\u003e()!\n\n    let nft=collection.borrowViewResolver(id: id)\n    let view : {String : AnyStruct} = {}\n    for v in nft.getViews() {\n        if v != Type\u003cMetadataViews.NFTCollectionData\u003e() {\n            view[v.identifier] = nft.resolveView(v)\n        }\n    }\n    return view\n}\n\npub fun getPublicPath(_ nftIdentifier: String) : PublicPath {\n    let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier)) \n    let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n    return collection.collectionData.publicPath\n}",
               "spec": {
                  "order": [
                     "user",
                     "aliasOrIdentifier",
                     "id"
                  ],
                  "parameters": {
                     "aliasOrIdentifier": "String",
                     "id": "UInt64",
                     "user": "String"
                  }
               }
            },
            "getAllRelatedAccounts": {
               "code": "import FindRelatedAccounts from 0x35717efbbce11c74\n\npub fun main(user: Address) : {String : {String : [String]}} {\n    let account = getAccount(user)\n    let cap= account.getCapability\u003c\u0026FindRelatedAccounts.Accounts{FindRelatedAccounts.Public}\u003e(FindRelatedAccounts.publicPath)\n    let ref = cap.borrow()! \n    return ref.getAllRelatedAccounts()\n\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "Address"
                  }
               }
            },
            "getCatalog": {
               "code": "import NFTCatalog from 0x324c34e1c517e4db\nimport FINDNFTCatalog from 0x35717efbbce11c74\n\npub fun main() : {String : NFTCatalog.NFTCatalogMetadata} {\n    return FINDNFTCatalog.getCatalog() \n}",
               "spec": {
                  "order": [],
                  "parameters": {}
               }
            },
            "getCatalogCollectionDisplay": {
               "code": "import MetadataViews from 0x631e88ae7f1d7c20\nimport NFTCatalog from 0x324c34e1c517e4db\nimport FINDNFTCatalog from 0x35717efbbce11c74\n\npub fun main(collectionIdentifier : String, type: String?) : NFTCatalogMetadata? {\n    if let catalog = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier) {\n        return NFTCatalogMetadata(\n            contractName : catalog.contractName, \n            contractAddress : catalog.contractAddress, \n            nftType: catalog.nftType, \n            collectionDisplay : catalog.collectionDisplay\n        )\n    }\n\n    // if we have type identifier here: loop thru the items in that specific type\n    // otherwise we just loop over the entire catalog to get the collection display\n    var types : [String] = FINDNFTCatalog.getCatalogTypeData().keys \n    if type != nil {\n        types = [type!]\n    }\n\n    for identifier in types {\n        if let collections : [String] = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: identifier)?.keys {\n            for ci in collections {\n                let catalog = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : ci)! \n                if catalog.collectionDisplay.name == collectionIdentifier {\n                    return NFTCatalogMetadata(\n                        contractName : catalog.contractName, \n                        contractAddress : catalog.contractAddress, \n                        nftType: catalog.nftType, \n                        collectionDisplay : catalog.collectionDisplay\n                    )\n                }\n            }\n        }\n    }\n\n    return nil\n}\n\npub struct NFTCatalogMetadata {\n    pub let contractName : String\n    pub let contractAddress : Address\n    pub let nftType: String\n    pub let collectionDisplay: MetadataViews.NFTCollectionDisplay\n\n    init (contractName : String, contractAddress : Address, nftType: Type, collectionDisplay : MetadataViews.NFTCollectionDisplay) {\n        self.contractName = contractName\n        self.contractAddress = contractAddress\n        self.nftType = nftType.identifier\n        self.collectionDisplay = collectionDisplay\n    }\n}",
               "spec": {
                  "order": [
                     "collectionIdentifier",
                     "type"
                  ],
                  "parameters": {
                     "collectionIdentifier": "String",
                     "type": "String?"
                  }
               }
            },
            "getCatalogEntry": {
               "code": "import NFTCatalog from 0x324c34e1c517e4db\nimport FINDNFTCatalog from 0x35717efbbce11c74\n\npub fun main(collectionIdentifier : String) : NFTCatalog.NFTCatalogMetadata? {\n    return FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier) \n}",
               "spec": {
                  "order": [
                     "collectionIdentifier"
                  ],
                  "parameters": {
                     "collectionIdentifier": "String"
                  }
               }
            },
            "getCatalogTypeData": {
               "code": "import NFTCatalog from 0x324c34e1c517e4db\nimport FINDNFTCatalog from 0x35717efbbce11c74\n\npub fun main() : {String : {String : Bool}} {\n    return FINDNFTCatalog.getCatalogTypeData() \n}",
               "spec": {
                  "order": [],
                  "parameters": {}
               }
            },
            "getCheckRoyalty": {
               "code": "import MetadataViews from 0x631e88ae7f1d7c20\nimport FIND from 0x35717efbbce11c74\nimport FINDNFTCatalog from 0x35717efbbce11c74\n\npub fun main(name: String, id: UInt64, nftAliasOrIdentifier: String, viewIdentifier: String) : AnyStruct? {\n\n    let address =FIND.resolve(name)!\n\n    // Get collection public path from NFT Registry\n    let collectionPublicPath = getPublicPath(nftAliasOrIdentifier)\n    let collection= getAuthAccount(address).borrow\u003c\u0026{MetadataViews.ResolverCollection}\u003e(from: collectionPublicPath)!\n\n    let nft=collection.borrowViewResolver(id: id)\n    return nft.resolveView(CompositeType(viewIdentifier)!)\n}\n\npub fun getPublicPath(_ nftIdentifier: String) : StoragePath {\n    let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier)) \n    let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n    return collection.collectionData.storagePath\n}",
               "spec": {
                  "order": [
                     "name",
                     "id",
                     "nftAliasOrIdentifier",
                     "viewIdentifier"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "name": "String",
                     "nftAliasOrIdentifier": "String",
                     "viewIdentifier": "String"
                  }
               }
            },
            "getCollectionForType": {
               "code": "import NFTCatalog from 0x324c34e1c517e4db\nimport FINDNFTCatalog from 0x35717efbbce11c74\n\npub fun main(nftTypeIdentifier : String) : {String : Bool}? {\n    return FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftTypeIdentifier)\n}",
               "spec": {
                  "order": [
                     "nftTypeIdentifier"
                  ],
                  "parameters": {
                     "nftTypeIdentifier": "String"
                  }
               }
            },
            "getCollectionIndex": {
               "code": "import MetadataViews from 0x631e88ae7f1d7c20\nimport FINDNFTCatalog from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\n\npub fun main(user: String) : {String : [UInt64]} {\n\n    if let address = FIND.resolve(user) {\n        var resultMap : {String : [UInt64]} = {}\n        let account = getAccount(address)\n        for nftInfo in FINDNFTCatalog.getCatalog().values {\n            let publicPath = nftInfo.collectionData.publicPath\n\n            if let subCollections = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftInfo.nftType.identifier) {\n                if subCollections.length \u003c 1 {\n                    continue\n                } else if subCollections.length == 1 {\n                    let collection = nftInfo.nftType.identifier\n                    let resolverCollectionCap= account.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(publicPath)\n                    if resolverCollectionCap.check() {\n                        let collection = resolverCollectionCap.borrow()!\n                        resultMap[nftInfo.collectionDisplay.name] = collection.getIDs()\n                    }\n                } else {\n                    let collection = nftInfo.nftType.identifier\n                    let resolverCollectionCap= account.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(publicPath)\n\n                    let array : [UInt64] = []\n                    if resolverCollectionCap.check() {\n                        let collection = resolverCollectionCap.borrow()!\n                        for id in collection.getIDs() {\n                            let vr = collection.borrowViewResolver(id: id)\n                            if let sc = vr.resolveView(Type\u003cMetadataViews.NFTCollectionDisplay\u003e()) {\n                                let scv = sc as! MetadataViews.NFTCollectionDisplay\n                                if scv.name == nftInfo.collectionDisplay.name {\n                                    array.append(id)\n                                }\n                            }\n                        }\n                    }\n                    resultMap[nftInfo.collectionDisplay.name] = array\n                }\n            } \n\n        }\n\n        return resultMap\n    }\n    return {}\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "getCuratedCollections": {
               "code": "pub fun main(address: Address) : \u0026{String: [String]}? {\n    let account=getAccount(address)\n\n    if account.balance == 0.0 {\n        return nil\n    }\n\n    let publicPath=/public/FindCuratedCollections\n    let link = account.getCapability\u003c\u0026{String: [String]}\u003e(publicPath)\n    if link.check() {\n        return link.borrow()\n    }\n    return nil\n}",
               "spec": {
                  "order": [
                     "address"
                  ],
                  "parameters": {
                     "address": "Address"
                  }
               }
            },
            "getDandiesIDsFor": {
               "code": "import Dandy from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\n\npub fun main(user: String, minter: String) : [UInt64] {\n    let address = FIND.resolve(user)\n    if address == nil {\n        return []\n    }\n    let account = getAccount(address!)\n    if account.balance == 0.0 {\n        return []\n    }\n    let cap = account.getCapability\u003c\u0026Dandy.Collection{Dandy.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n    let ref = cap.borrow() ?? panic(\"Cannot borrow reference to Dandy Collection. Account address : \".concat(address!.toString()))\n\n    return ref.getIDsFor(minter: minter)\n}",
               "spec": {
                  "order": [
                     "user",
                     "minter"
                  ],
                  "parameters": {
                     "minter": "String",
                     "user": "String"
                  }
               }
            },
            "getDandiesMinters": {
               "code": "import Dandy from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\n\npub fun main(user: String) : [String] {\n    let address = FIND.resolve(user)\n    if address == nil {\n        return []\n    }\n    let account = getAccount(address!)\n    if account.balance == 0.0 {\n        return []\n    }\n    let cap = account.getCapability\u003c\u0026Dandy.Collection{Dandy.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n    let ref = cap.borrow() ?? panic(\"Cannot borrow reference to Dandy Collection. Account address : \".concat(address!.toString()))\n\n    return ref.getMinters()\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "getFTInfo": {
               "code": "import FTRegistry from 0x35717efbbce11c74\n\npub fun main(aliasOrIdentifier: String) : FTRegistry.FTInfo?{\n\n    return FTRegistry.getFTInfo(aliasOrIdentifier)\n\n}",
               "spec": {
                  "order": [
                     "aliasOrIdentifier"
                  ],
                  "parameters": {
                     "aliasOrIdentifier": "String"
                  }
               }
            },
            "getFTInfoAll": {
               "code": "import FTRegistry from 0x35717efbbce11c74\n\npub fun main() : {String: FTRegistry.FTInfo}{\n\n    return FTRegistry.getFTInfoAll()\n\n}",
               "spec": {
                  "order": [],
                  "parameters": {}
               }
            },
            "getFindPackSaleDetailsWithUser": {
               "code": "import FindPack from 0x35717efbbce11c74\nimport FTRegistry from 0x35717efbbce11c74\nimport FlowStorageFees from 0x8c5303eaa26202d6\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FIND from 0x35717efbbce11c74\n\npub fun main(packTypeName: String, packTypeId: UInt64, user: Address) : Report? {\n    if let metadata = FindPack.getMetadataById(packTypeName: packTypeName, typeId: packTypeId) {\n        let packsLeft = FindPack.getPacksCollection(packTypeName: packTypeName, packTypeId: packTypeId).getPacksLeft()\n        return Report(metadata, user: user, packsLeft:packsLeft)\n    }\n\n    return nil\n}\n\npub struct Report {\n        pub let name: String\n        pub let description: String\n\n        pub let thumbnailHash: String?\n        pub let thumbnailUrl:String?\n\n        pub let walletType: String\n        pub let walletAlias: String?\n\n        pub let openTime: UFix64\n\n        pub let storageRequirement: UInt64\n        pub let collectionDisplay: MetadataViews.NFTCollectionDisplay\n\n        pub let itemTypes: [Type]\n\n        pub let extraData : {String : AnyStruct}\n        pub let packFields: {String : String}\n        pub let requiresReservation: Bool\n        pub let storageFlowNeeded: UFix64? \n\n        pub let userQualifiedSale : UserSaleInfo?\n        pub let saleInfos: [SaleInfo]\n        pub let packsLeft : Int \n\n        init(_ md: FindPack.Metadata, user: Address, packsLeft: Int) {\n            self.packsLeft=packsLeft\n            self.name=md.name\n            self.description=md.description\n            self.thumbnailHash=md.thumbnailHash\n            self.thumbnailUrl=md.thumbnailUrl\n            self.walletType=md.walletType.identifier\n            self.walletAlias=FTRegistry.getFTInfoByTypeIdentifier(md.walletType.identifier)?.alias\n            self.openTime=md.openTime\n            self.storageRequirement=md.storageRequirement\n            self.itemTypes=md.itemTypes\n            self.extraData=md.extraData\n            self.packFields=md.packFields\n            self.requiresReservation=md.requiresReservation\n            self.userQualifiedSale=getSoonestQualifiedSale(md.saleInfos, user: user)\n            self.storageFlowNeeded=getRequiredFlow(md.storageRequirement, user: user)\n            self.collectionDisplay=md.collectionDisplay\n            self.saleInfos=convertSaleInfo(md.saleInfos)\n        }\n}\n\npub struct UserSaleInfo {\n        pub let name : String\n        pub let startTime : UFix64 \n        pub let endTime : UFix64?\n        pub let price : UFix64\n        pub let purchaseLimit : UInt64?\n        pub let userPurchaseRecord : UInt64\n        pub let canBuyNow : Bool\n\n        init(_ si: FindPack.SaleInfo, user: Address, timeStamp: UFix64) {\n            self.name=si.name\n            self.startTime=si.startTime\n            self.endTime=si.endTime\n            self.price=si.price\n            self.purchaseLimit=si.purchaseLimit\n            self.userPurchaseRecord=si.purchaseRecord[user] ?? 0\n            self.canBuyNow= si.startTime\u003c=timeStamp\n        }\n}\n\npub fun getSoonestQualifiedSale(_ infos: [FindPack.SaleInfo], user: Address) : UserSaleInfo? {\n    let res : [UserSaleInfo] = []\n    let currentTime = getCurrentBlock().timestamp\n    var availableOption : FindPack.SaleInfo? = nil \n    var soonestOption : FindPack.SaleInfo? = nil \n\n    // check for the sale option that is available to the user, and is with the lowest price\n    for info in infos {\n        if info.checkBuyable(addr: user, time: currentTime){\n            if availableOption == nil || availableOption!.price \u003e info!.price {\n                availableOption = info\n            }\n        } else {\n            let endTime = info.endTime ?? UFix64.max\n            if currentTime \u003e endTime {\n                continue\n            }\n\n    // if there is no option available, get the soonest option available to the user, again, lowest price\n            if info.checkBuyable(addr: user, time: info.startTime) {\n                if soonestOption == nil || soonestOption!.startTime \u003e info.startTime {\n                    soonestOption = info\n                } else if soonestOption!.startTime == info.startTime \u0026\u0026 soonestOption!.price \u003e info.price {\n                    soonestOption = info\n                }\n            }\n        }\n    }\n\n    if availableOption != nil {\n        return UserSaleInfo(availableOption!, user: user, timeStamp: currentTime)\n    } else if soonestOption != nil {\n        return UserSaleInfo(soonestOption!, user: user, timeStamp: currentTime)\n    }\n    return nil\n}\n\npub fun getRequiredFlow(_ requiresReservation: UInt64, user: Address) : UFix64? {\n\n    let account = getAccount(user)\n    if account.storageCapacity \u003e account.storageUsed {\n        if account.storageCapacity - account.storageUsed \u003e requiresReservation {\n            return nil\n        }\n    }\n    return FlowStorageFees.storageCapacityToFlow(FlowStorageFees.convertUInt64StorageBytesToUFix64Megabytes(account.storageUsed + requiresReservation))\n}\n\npub struct SaleInfo {\n        pub let name : String\n        pub let startTime : UFix64 \n        pub let endTime : UFix64?\n        pub let price : UFix64\n        pub let purchaseLimit : UInt64?\n        pub let purchaseRecord : {Address : UInt64}\n        pub let verifiers : [String]\n        pub let verifyAll : Bool \n\n        init(_ si: FindPack.SaleInfo) {\n            self.name=si.name\n            self.startTime=si.startTime\n            self.endTime=si.endTime\n            self.price=si.price\n            self.purchaseLimit=si.purchaseLimit\n            self.purchaseRecord=si.purchaseRecord\n\n            var verifierDesc : [String] = []\n            for verifier in si.verifiers {\n                verifierDesc.append(verifier.description)\n            }\n            self.verifiers=verifierDesc\n            self.verifyAll=si.verifyAll\n        }\n}\n\npub fun convertSaleInfo(_ info: [FindPack.SaleInfo]) : [SaleInfo] {\n    let res : [SaleInfo] = []\n    for i in info {\n        res.append(SaleInfo(i))\n    }\n    return res\n}",
               "spec": {
                  "order": [
                     "packTypeName",
                     "packTypeId",
                     "user"
                  ],
                  "parameters": {
                     "packTypeId": "UInt64",
                     "packTypeName": "String",
                     "user": "Address"
                  }
               }
            },
            "getFindThoughts": {
               "code": "import FindThoughts from 0x35717efbbce11c74\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FindViews from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\nimport Profile from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\n\npub fun main(addresses: [Address], ids: [UInt64]) : [Thought] {\n    let thoughts : [Thought] = [] \n\n    for i, address in addresses {\n        let account = getAccount(address) \n        let cap = account.getCapability\u003c\u0026{FindThoughts.CollectionPublic}\u003e(FindThoughts.CollectionPublicPath) \n        if !cap.check() {\n            continue\n        }\n        let ref = cap.borrow()! \n        let t = ref.borrowThoughtPublic(ids[i]) \n        thoughts.append(getThought(t, withQuote: true))\n        \n    }\n    return thoughts\n}\n\npub struct User {\n    pub var name: String?\n    pub let address: Address \n    pub let findName: String? \n    pub var avatar: String? \n    pub let reaction: String\n\n    init(address: Address, reaction: String){\n        self.name = nil\n        self.findName = FIND.reverseLookup(address)\n        self.avatar = nil\n        self.reaction = reaction\n        self.address = address \n        let profileCap = getAccount(address).getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if profileCap.check() {\n            let p = profileCap.borrow()!\n            self.name = p.getName()\n            self.avatar = p.getAvatar()\n        }    \n    }\n}\n\npub struct Thought {\n    pub let id: UInt64 \n    pub let creator: Address \n    pub let creatorName: String? \n    pub var creatorProfileName: String? \n    pub var creatorAvatar: String? \n    pub var header: String?\n    pub var body: String?\n    pub let created: UFix64? \n    pub var lastUpdated: UFix64?\n    pub let medias: {String : String}\n    pub let nft: [FindMarket.NFTInfo]\n    pub var tags: [String]\n    pub var reacted: {String : [User]}\n    pub var reactions: {String : Int}\n    pub var reactedUsers: {String : [String]}\n    pub var quotedThought: Thought?\n    pub let hidden: Bool?\n\n    init(id: UInt64 , creator: Address , creatorName: String? , creatorProfileName: String? , creatorAvatar: String? , header: String? , body: String? , created: UFix64? , lastUpdated: UFix64?, medias: {String : String}, nft: [FindMarket.NFTInfo], tags: [String], reacted: {String : [User]}, reactions: {String : Int}, reactedUsers: {String : [String]}, quotedThought: Thought?, hidden: Bool?) {\n        self.id = id\n        self.creator = creator\n        self.creatorName = creatorName\n        self.creatorProfileName = creatorProfileName\n        self.creatorAvatar = creatorAvatar\n        self.header = header\n        self.body = body\n        self.created = created\n        self.lastUpdated = lastUpdated\n        self.medias = medias\n        self.nft = nft\n        self.tags = tags\n        self.reacted = reacted\n        self.reactions = reactions\n        self.reactedUsers = reactedUsers\n        self.quotedThought = quotedThought\n        self.hidden = hidden\n    }\n}\n\npub fun getThought(_ t: \u0026{FindThoughts.ThoughtPublic}, withQuote: Bool) : Thought {\n\n        var creatorProfileName : String? = nil\n        var creatorAvatar : String? = nil \n        let profileCap = getAccount(t.creator).getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if profileCap.check() {\n            creatorProfileName = profileCap.borrow()!.getName()\n            creatorAvatar = profileCap.borrow()!.getAvatar()\n        }\n\n        let medias : {String : String} = {}\n        for m in t.medias {\n            medias[m.file.uri()] = m.mediaType\n        }\n\n        let nft : [FindMarket.NFTInfo] = [] \n        for n in t.nft {\n            let vr = n.getViewResolver() \n            nft.append(FindMarket.NFTInfo(vr, id: n.id, detail: true))\n        }\n\n        let reacted : {String : [User]} = {}\n        let reactedUsers : {String :[String]} = {}\n        for user in t.reacted.keys {\n            let reaction = t.reacted[user]!\n            let allReacted = reacted[reaction] ?? []\n            let u = User(address: user, reaction: reaction)\n\n            allReacted.append(u)\n            reacted[reaction] = allReacted\n\n            let preReactedUser = reactedUsers[reaction] ?? []\n            preReactedUser.append(u.name ?? u.address.toString())\n            reactedUsers[reaction] = preReactedUser\n        }\n\n        var quotedThought : Thought? = nil \n        if withQuote {\n            if let p = t.getQuotedThought() {\n                if let ref = p.borrowThoughtPublic() {\n                    quotedThought = getThought(ref, withQuote: false)\n                } else {\n                    let creator = p.owner()\n                    var qCreatorProfileName : String? = nil\n                    var qCreatorAvatar : String? = nil \n                    let qProfileCap = getAccount(creator).getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n                    if qProfileCap.check() {\n                        qCreatorProfileName = qProfileCap.borrow()!.getName()\n                        qCreatorAvatar = qProfileCap.borrow()!.getAvatar()\n                    }\n\n                    quotedThought = Thought(\n                        id: p.id , \n                        creator: creator  , \n                        creatorName: FIND.reverseLookup(creator) , \n                        creatorProfileName: qCreatorProfileName , \n                        creatorAvatar: qCreatorAvatar, \n                        header: nil, \n                        body: nil , \n                        created: nil, \n                        lastUpdated: nil, \n                        medias: {}, \n                        nft: [], \n                        tags: [], \n                        reacted: {}, \n                        reactions: {}, \n                        reactedUsers: {},\n                        quotedThought: nil, \n                        hidden: nil\n                    )\n                }\n            }\n        }\n\n        return Thought(\n            id: t.id , \n            creator: t.creator  , \n            creatorName: FIND.reverseLookup(t.creator) , \n            creatorProfileName: creatorProfileName , \n            creatorAvatar: creatorAvatar, \n            header: t.header , \n            body: t.body , \n            created: t.created, \n            lastUpdated: t.lastUpdated, \n            medias: medias, \n            nft: nft, \n            tags: t.tags, \n            reacted: reacted, \n            reactions: t.reactions, \n            reactedUsers: reactedUsers,\n            quotedThought: quotedThought,\n            hidden: t.getHide()\n        )\n\n}",
               "spec": {
                  "order": [
                     "addresses",
                     "ids"
                  ],
                  "parameters": {
                     "addresses": "[Address]",
                     "ids": "[UInt64]"
                  }
               }
            },
            "getItem": {
               "code": "import MetadataViews from 0x631e88ae7f1d7c20\nimport FIND from 0x35717efbbce11c74\nimport FINDNFTCatalog from 0x35717efbbce11c74\n\npub struct MetadataCollectionItem {\n    pub let id:UInt64\n    pub let uuid:UInt64\n    pub let name: String\n    pub let description: String?\n    pub let image: String\n    pub let url: String\n    pub let contentType:String\n    pub let rarity:String\n    pub let minter:String?\n    pub let type:Type\n\n\n    init(id:UInt64, uuid:UInt64, name:String, description:String?, image:String, url:String, contentType: String, rarity: String, minter:String?, type:Type) {\n        self.id=id\n        self.uuid=uuid\n        self.name=name\n        self.description=description\n        self.minter=minter\n        self.url=url\n        self.type=type\n        self.image=image\n        self.contentType=contentType\n        self.rarity=rarity\n    }\n}\n\n\npub fun main(user: String, aliasOrIdentifier: String, id:UInt64) : MetadataCollectionItem?{\n\n    let publicPath = getPublicPath(aliasOrIdentifier)\n\n    let resolveAddress = FIND.resolve(user) \n    if resolveAddress == nil {return nil}\n    let address = resolveAddress!\n    let account=getAccount(address)\n    if account.balance == 0.0 {\n        return nil\n    }\n    let resolverCollectionCap= account.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(publicPath)\n    if !resolverCollectionCap.check() {\n        return nil\n    }\n\n    let collection = resolverCollectionCap.borrow()!\n    let nft = collection.borrowViewResolver(id: id)!\n\n    if let displayView = nft.resolveView(Type\u003cMetadataViews.Display\u003e()) {\n        let display = displayView as! MetadataViews.Display\n\n        var externalUrl=\"\"\n        if let externalUrlView = nft.resolveView(Type\u003cMetadataViews.ExternalURL\u003e()) {\n            let edvu= externalUrlView as! MetadataViews.ExternalURL\n            externalUrl=edvu.url\n        }\n        let item = MetadataCollectionItem(\n            id: id,\n            uuid: nft.uuid,\n            name: display.name,\n            description:display.description,\n            image: display.thumbnail.uri(),\n            url: externalUrl,\n            contentType: \"image\",\n            rarity: \"\",\n            minter: \"\",\n            type: nft.getType()\n        )\n        return item\n    }\n    return nil\n}\n\npub fun getPublicPath(_ nftIdentifier: String) : PublicPath {\n    let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier)) \n    let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n    return collection.collectionData.publicPath\n}",
               "spec": {
                  "order": [
                     "user",
                     "aliasOrIdentifier",
                     "id"
                  ],
                  "parameters": {
                     "aliasOrIdentifier": "String",
                     "id": "UInt64",
                     "user": "String"
                  }
               }
            },
            "getLeases": {
               "code": "import FIND from 0x35717efbbce11c74\n\npub fun main() : [FIND.NetworkLease] {\n    return FIND.getLeases()\n}",
               "spec": {
                  "order": [],
                  "parameters": {}
               }
            },
            "getListings": {
               "code": "import FindMarket from 0x35717efbbce11c74 \nimport FIND from 0x35717efbbce11c74 \n\npub fun main(marketplace:Address, user: String) : {String : FindMarket.SaleItemCollectionReport} {\n    let resolveAddress = FIND.resolve(user)\n    if resolveAddress == nil { return {}}\n    let address = resolveAddress!\n        return FindMarket.getSaleItemReport(tenant:marketplace, address: address, getNFTInfo:false)\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "user"
                  ],
                  "parameters": {
                     "marketplace": "Address",
                     "user": "String"
                  }
               }
            },
            "getLostAndFoundNFTs": {
               "code": "import LostAndFoundHelper from 0xbe4635353f55bbd4\nimport FindLostAndFoundWrapper from 0x35717efbbce11c74\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport FIND from 0x35717efbbce11c74\nimport FINDNFTCatalog from 0x35717efbbce11c74\n\npub fun main(user: String) : Report {\n\n    if let address = FIND.resolve(user) {\n        let runTimeType = Type\u003c@NonFungibleToken.NFT\u003e()\n\n        let ticketsInfo = FindLostAndFoundWrapper.getTickets(user: address, specificType: runTimeType)\n\n        let ticketIds : {String : [UInt64]} = {}\n        let NFTCatalogTicketInfo : {String : [LostAndFoundHelper.Ticket]} = {}\n        for type in ticketsInfo.keys {\n            // check if this type is in NFTCatalog\n            let nftCatalog = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: type)\n            var inNFTCatalog : Bool = true \n            if nftCatalog == nil {\n                inNFTCatalog = false\n            }\n\n            // append id in array\n            let id : [UInt64] = []\n            for ticket in ticketsInfo[type]! {\n                if ticket.ticketID != nil {\n                    id.append(ticket.ticketID!)\n                }\n            }\n            ticketIds[type] = id\n\n            // If it is in NFT Catalog, add it in NFTCatalogTicketInfo\n            if inNFTCatalog {\n                NFTCatalogTicketInfo[type] = ticketsInfo.remove(key: type)\n            }\n        }\n\n        return Report(nftCatalogTicketInfo : NFTCatalogTicketInfo, ticketInfo : ticketsInfo, ticketIds : ticketIds, error: nil)\n    }\n    return logErr(\"Cannot resolve user. User : \".concat(user))\n}\n\n\npub struct Report {\n\n    pub let nftCatalogTicketInfo : {String : [LostAndFoundHelper.Ticket]}\n    pub let ticketInfo : {String : [LostAndFoundHelper.Ticket]}\n    pub let ticketIds : {String : [UInt64]}\n    pub let error : String?\n\n    init(nftCatalogTicketInfo : {String : [LostAndFoundHelper.Ticket]}, ticketInfo : {String : [LostAndFoundHelper.Ticket]}, ticketIds : {String : [UInt64]}, error: String?) {\n        self.nftCatalogTicketInfo = nftCatalogTicketInfo\n        self.ticketInfo = ticketInfo\n        self.ticketIds = ticketIds\n        self.error = error\n    }\n}\n\npub fun logErr(_ err: String) : Report {\n    return Report(nftCatalogTicketInfo: {}, ticketInfo : {}, ticketIds : {} , error: err)\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "getLostAndFoundRedeemableNFTTypes": {
               "code": "import FindLostAndFoundWrapper from 0x35717efbbce11c74\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport FIND from 0x35717efbbce11c74\n\npub fun main(user: String) : Report {\n\n    if let address = FIND.resolve(user){\n        let type : Type = Type\u003c@NonFungibleToken.NFT\u003e()\n        return Report(nftTypes: typeToStringArray(FindLostAndFoundWrapper.getSpecificRedeemableTypes(user: address, specificType: type)), err: nil)\n    }\n    return logErr(\"cannot resolve user\")\n\n}\n\npub fun typeToStringArray(_ array: [Type]) : [String] {\n    let res : [String] = []\n    for type in array {\n        res.append(type.identifier)\n    }\n    return res\n}\n\npub struct Report {\n    pub let nftTypes : [String]\n    pub let err : String? \n\n    init(nftTypes : [String] , err : String? ) {\n        self.nftTypes = nftTypes\n        self.err = err\n    }\n}\n\npub fun logErr(_ err: String) : Report{\n    return Report(nftTypes: [], err: err)\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "getLostAndFoundRequiredStorageType": {
               "code": "import FindLostAndFoundWrapper from 0x35717efbbce11c74\nimport FINDNFTCatalog from 0x35717efbbce11c74\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FIND from 0x35717efbbce11c74\n\npub fun main(user: String) : Report {\n\n    if let address = FIND.resolve(user){\n        let runTimeType : Type = Type\u003c@NonFungibleToken.NFT\u003e()\n\n        let types = FindLostAndFoundWrapper.getSpecificRedeemableTypes(user: address, specificType: runTimeType)\n\n        let account = getAuthAccount(address)\n\n        let initiableStorage : [String] = []\n        let relinkableStorage : [String] = []\n        let initiatedStorage : [String] = []\n        let problematicStorage : [String] = []\n        let notSupportedType : [String] = []\n        for type in types {\n\n            let nftInfo = FINDNFTCatalog.getCollectionDataForType(nftTypeIdentifier: type.identifier)\n\n            if nftInfo == nil {\n                initiableStorage.append(type.identifier)\n                continue\n            }\n\n            let storageType = account.type(at: nftInfo!.storagePath)\n            if storageType == nil {\n                initiableStorage.append(type.identifier)\n                continue\n            } \n            \n            let storageTypeIdentifier = storageType!.identifier.slice(from: 0 , upTo: storageType!.identifier.length - \".Collection\".length)\n            let typeIdentifier = type.identifier.slice(from: 0 , upTo: type.identifier.length - \".NFT\".length)\n            if storageTypeIdentifier != typeIdentifier {\n                problematicStorage.append(type.identifier)\n            } else {\n\n                // check if relink needed\n                if account.getCapability\u003c\u0026{NonFungibleToken.Receiver, NonFungibleToken.CollectionPublic, MetadataViews.ResolverCollection}\u003e(nftInfo!.publicPath).check() {\n                    initiatedStorage.append(type.identifier)\n                } else {\n                    relinkableStorage.append(type.identifier)\n                }\n\n            }\n        }\n        return Report(initiableStorage: initiableStorage, relinkableStorage: relinkableStorage ,initiatedStorage: initiatedStorage, problematicStorage: problematicStorage, notSupportedType: notSupportedType, err: nil)\n    }\n    return logErr(\"cannot resolve user\")\n\n}\n\npub struct Report {\n\n    pub let initiableStorage : [String] \n    pub let relinkableStorage : [String]\n    pub let initiatedStorage : [String] \n    pub let problematicStorage : [String] \n    pub let notSupportedType : [String] \n\n    pub let err : String? \n\n    init(initiableStorage : [String] , relinkableStorage : [String] , initiatedStorage : [String], problematicStorage : [String] , notSupportedType : [String] , err : String? ) {\n        self.initiableStorage = initiableStorage\n        self.relinkableStorage = relinkableStorage\n        self.initiatedStorage = initiatedStorage\n        self.problematicStorage = problematicStorage\n        self.notSupportedType = notSupportedType\n        self.err = err\n    }\n\n}\n\npub fun logErr(_ err: String) : Report {\n    return Report(initiableStorage: [] , relinkableStorage : [] , initiatedStorage : [] , problematicStorage: [], notSupportedType: [], err: err)\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "getMarketBlockedNFT": {
               "code": "import FindMarket from 0x35717efbbce11c74 \n\npub fun main() : {String : [String] } {\n    let mapping : {String : [String] } = {}\n\n    let findAddress=FindMarket.getFindTenantAddress()\n    let tenantCap = FindMarket.getTenantCapability(findAddress)!\n    let tenantRef = tenantCap.borrow() ?? panic(\"This tenant is not set up. Tenant : \".concat(tenantCap.address.toString()))\n    let marketTypes = FindMarket.getSaleItemTypes()\n    for marketType in marketTypes {\n        let list : [String] = []\n        for type in tenantRef.getBlockedNFT(marketType: marketType) {\n            list.append(type.identifier)\n        }\n        mapping[FindMarket.getMarketOptionFromType(marketType)] = list\n    }\n\nreturn mapping\n}",
               "spec": {
                  "order": [],
                  "parameters": {}
               }
            },
            "getMetadataForBuyAddonDapper": {
               "code": "import FIND from 0x35717efbbce11c74\n\npub fun main(merchAccount: Address, name: String, addon:String, amount:UFix64) : PurchaseData {\n    let description = \"Purchase addon \".concat(addon).concat(\" for name :\").concat(name).concat(\" for Dapper Credit \").concat(amount.toString())\n    let imageURL = \"https://i.imgur.com/8W8NoO1.png\"\n\n    return PurchaseData(\n            id: 0, \n            name: name, \n            amount: amount, \n            description: description, \n            imageURL: imageURL\n            )\n\n\n}\n\npub struct PurchaseData {\n    pub let id: UInt64\n    pub let name: String\n    pub let amount: UFix64\n    pub let description: String\n    pub let imageURL: String\n\n    init(id: UInt64, name: String, amount: UFix64, description: String, imageURL: String) {\n        self.id = id\n        self.name = name\n        self.amount = amount\n        self.description = description\n        self.imageURL = imageURL\n    }\n}",
               "spec": {
                  "order": [
                     "merchAccount",
                     "name",
                     "addon",
                     "amount"
                  ],
                  "parameters": {
                     "addon": "String",
                     "amount": "UFix64",
                     "merchAccount": "Address",
                     "name": "String"
                  }
               }
            },
            "getMetadataForBuyLeaseForSaleDapper": {
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\nimport Profile from 0x35717efbbce11c74\nimport DapperUtilityCoin from 0x82ec283f88a62e65\nimport FindLeaseMarketSale from 0x35717efbbce11c74\nimport FindLeaseMarket from 0x35717efbbce11c74\n\npub fun main(sellerAccount: Address, leaseName: String, amount: UFix64) :PurchaseData{\n\n    let address = FIND.resolve(leaseName) ?? panic(\"The address input is not a valid name nor address. Input : \".concat(leaseName))\n    let leaseMarketplace = FindMarket.getFindTenantAddress()\n    let leaseTenant = FindMarket.getTenant(leaseMarketplace)\n    let storagePath = leaseTenant.getStoragePath(Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e())\n    let saleItemRef = getAuthAccount(address).borrow\u003c\u0026FindLeaseMarketSale.SaleItemCollection\u003e(from: storagePath) ?? panic(\"Cannot borrow reference to sale item\")\n    let saleItem = saleItemRef.borrow(leaseName)\n\n    let description = \"Name :\".concat(leaseName).concat(\" for Dapper Credit \").concat(amount.toString())\n    let imageURL = \"https://i.imgur.com/8W8NoO1.png\"\n\n    return PurchaseData(\n            id: saleItem.getId(),\n            name: leaseName,\n            amount: amount,\n            description: description,\n            imageURL: imageURL\n            )\n}\n\npub struct PurchaseData {\n    pub let id: UInt64\n    pub let name: String\n    pub let amount: UFix64\n    pub let description: String\n    pub let imageURL: String\n\n    init(id: UInt64, name: String, amount: UFix64, description: String, imageURL: String) {\n        self.id = id\n        self.name = name\n        self.amount = amount\n        self.description = description\n        self.imageURL = imageURL\n    }\n}",
               "spec": {
                  "order": [
                     "sellerAccount",
                     "leaseName",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "leaseName": "String",
                     "sellerAccount": "Address"
                  }
               }
            },
            "getMetadataForBuyNFTForSaleDapper": {
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FindMarketSale from 0x35717efbbce11c74\n\n\npub fun main(address: Address, marketplace:Address, id: UInt64, amount: UFix64) : PurchaseData {\n\n    let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketSale.SaleItemCollection\u003e())\n    let item= FindMarket.assertOperationValid(tenant: marketplace, address: address, marketOption: marketOption, id: id)\n    let display = item.getDisplay()\n    let itemID = item.getItemID()\n    let amount = item.getBalance()\n\n\n    return PurchaseData(\n        id: itemID,\n        name: display.name,\n        amount: amount,\n        description: display.description,\n        imageURL: display.thumbnail.uri()\n    )\n}\n\npub struct PurchaseData {\n    pub let id: UInt64\n    pub let name: String\n    pub let amount: UFix64\n    pub let description: String\n    pub let imageURL: String\n\n    init(id: UInt64, name: String, amount: UFix64, description: String, imageURL: String) {\n        self.id = id\n        self.name = name\n        self.amount = amount\n        self.description = description\n        self.imageURL = imageURL\n    }\n}",
               "spec": {
                  "order": [
                     "address",
                     "marketplace",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "address": "Address",
                     "amount": "UFix64",
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "getMetadataForRegisterDapper": {
               "code": "import FIND from 0x35717efbbce11c74\n\npub fun main(merchAccount: Address, name: String, amount: UFix64) : PurchaseData {\n\n    let description = \"Name :\".concat(name).concat(\" for Dapper Credit \").concat(amount.toString())\n    let imageURL = \"https://ik.imagekit.io/xyvsisxky/tr:ot-\".concat(name).concat(\",ots-55,otc-58B792,ox-N166,oy-N24,ott-b/https://i.imgur.com/8W8NoO1.png\")\n\n    return PurchaseData(\n            id: 0, \n            name: name, \n            amount: amount, \n            description: description, \n            imageURL: imageURL\n            )\n\n}\n\npub struct PurchaseData {\n    pub let id: UInt64\n    pub let name: String\n    pub let amount: UFix64\n    pub let description: String\n    pub let imageURL: String\n\n    init(id: UInt64, name: String, amount: UFix64, description: String, imageURL: String) {\n        self.id = id\n        self.name = name\n        self.amount = amount\n        self.description = description\n        self.imageURL = imageURL\n    }\n}",
               "spec": {
                  "order": [
                     "merchAccount",
                     "name",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "merchAccount": "Address",
                     "name": "String"
                  }
               }
            },
            "getMetadataForRenewNameDapper": {
               "code": "import FIND from 0x35717efbbce11c74\n\npub fun main(merchAccount: Address, name: String, amount: UFix64) : PurchaseData {\n\n    let description = \"Renew name :\".concat(name).concat(\" for Dapper Credit \").concat(amount.toString())\n    let imageURL = \"https://ik.imagekit.io/xyvsisxky/tr:ot-\".concat(name).concat(\",ots-55,otc-58B792,ox-N166,oy-N24,ott-b/https://i.imgur.com/8W8NoO1.png\")\n\n    return PurchaseData(\n            id: 0, \n            name: name, \n            amount: amount, \n            description: description, \n            imageURL: imageURL\n            )\n}\n\npub struct PurchaseData {\n    pub let id: UInt64\n    pub let name: String\n    pub let amount: UFix64\n    pub let description: String\n    pub let imageURL: String\n\n    init(id: UInt64, name: String, amount: UFix64, description: String, imageURL: String) {\n        self.id = id\n        self.name = name\n        self.amount = amount\n        self.description = description\n        self.imageURL = imageURL\n    }\n}",
               "spec": {
                  "order": [
                     "merchAccount",
                     "name",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "merchAccount": "Address",
                     "name": "String"
                  }
               }
            },
            "getMetadataForSaleItem": {
               "code": "import FindMarketSale from 0x35717efbbce11c74\n\npub struct PurchaseData {\n    pub let id: UInt64\n    pub let name: String\n    pub let amount: UFix64\n    pub let description: String\n    pub let imageURL: String\n\n    init(id: UInt64, name: String, amount: UFix64, description: String, imageURL: String) {\n        self.id = id\n        self.name = name\n        self.amount = amount\n        self.description = description\n        self.imageURL = imageURL\n    }\n}\npub fun main(merchantAddress: Address, marketplace:Address, address: Address, id: UInt64, amount: UFix64) : PurchaseData{\n    let saleItemsCap= FindMarketSale.getSaleItemCapability(marketplace: marketplace, user:address) ?? panic(\"cannot find sale item cap\")\n    let saleItemCollection = saleItemsCap.borrow()!\n    let item = saleItemCollection.borrowSaleItem(id)\n\n    let display = item.getDisplay()\n\n    var thumbnail = replacePrefix(display.thumbnail.uri(), prefix: \"ipfs://\", replace:\"https://find.mypinata.clloud/ipfs/\")\n    return PurchaseData(\n        id: id, \n        name: display.name, \n        amount: amount,\n        description: display.description, \n        imageURL: thumbnail\n    )\n}\n\npub fun replacePrefix(_ original: String, prefix:String, replace:String) : String {\n    if original.length \u003c prefix.length  {\n        return original\n    }\n    let oprefix = original.slice(from:0, upTo:prefix.length)\n    if oprefix != prefix {\n        return original\n    }\n    let rest = original.slice(from:prefix.length, upTo: original.length)\n    return replace.concat(rest)\n}",
               "spec": {
                  "order": [
                     "merchantAddress",
                     "marketplace",
                     "address",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "address": "Address",
                     "amount": "UFix64",
                     "id": "UInt64",
                     "marketplace": "Address",
                     "merchantAddress": "Address"
                  }
               }
            },
            "getNFTCatalogIDs": {
               "code": "import MetadataViews from 0x631e88ae7f1d7c20\nimport FIND from 0x35717efbbce11c74\nimport FINDNFTCatalog from 0x35717efbbce11c74\n\npub fun main(user: String, collections: [String]) : {String : ItemReport} {\n    return fetchNFTCatalog(user: user, targetCollections:collections)\n}\n\npub struct ItemReport {\n    pub let length : Int // mapping of collection to no. of ids \n    pub let extraIDs : [UInt64]\n    pub let shard : String \n    pub let extraIDsIdentifier : String \n    pub let collectionName: String\n\n    init(length : Int, extraIDs :[UInt64] , shard: String, extraIDsIdentifier: String, collectionName: String) {\n        self.length=length \n        self.extraIDs=extraIDs\n        self.shard=shard\n        self.extraIDsIdentifier=extraIDsIdentifier\n        self.collectionName=collectionName\n    }\n}\n\npub struct NFTView {\n    pub let id: UInt64\n    pub let display: MetadataViews.Display?\n    pub let editions: MetadataViews.Editions?\n    pub let collectionDisplay: MetadataViews.NFTCollectionDisplay?\n    pub let nftType: Type\n\n    init(\n        id : UInt64,\n        display : MetadataViews.Display?,\n        editions : MetadataViews.Editions?,\n        collectionDisplay: MetadataViews.NFTCollectionDisplay?,\n        nftType: Type\n    ) {\n        self.id = id\n        self.display = display\n        self.editions = editions\n        self.collectionDisplay = collectionDisplay\n        self.nftType = nftType\n    }\n}\n\npub struct NFTIDs {\n    pub let ids: [UInt64]\n    pub let collectionName: String \n\n    init(ids: [UInt64], collectionName: String ) {\n        self.ids = ids\n        self.collectionName = collectionName\n    }\n}\n\n// Helper function \n\npub fun resolveAddress(user: String) : Address? {\n    return FIND.resolve(user)\n}\n\npub fun getNFTIDs(ownerAddress: Address) : {String : NFTIDs} {\n\n    let account = getAuthAccount(ownerAddress)\n\n    if account.balance == 0.0 {\n        return {}\n    }\n\n    let inventory : {String:NFTIDs}={}\n    let types = FINDNFTCatalog.getCatalogTypeData()\n    for nftType in types.keys {\n\n        let typeData=types[nftType]!\n        let collectionKey=typeData.keys[0]\n        let catalogEntry = FINDNFTCatalog.getCatalogEntry(collectionIdentifier:collectionKey)!\n\n        var collectionName = collectionKey\n        if typeData.length == 1 {\n            collectionName = catalogEntry.collectionDisplay.name\n        }\n\n        let storagePath = catalogEntry.collectionData.storagePath\n        let ref= account.borrow\u003c\u0026{MetadataViews.ResolverCollection}\u003e(from: storagePath)\n        if ref != nil {\n            inventory[collectionKey] = NFTIDs(ids: ref!.getIDs(), collectionName: collectionName)\n        }\n\n    }\n    return inventory\n}\n\npub fun fetchNFTCatalog(user: String, targetCollections: [String]) : {String : ItemReport} {\n    let source = \"NFTCatalog\"\n    let account = resolveAddress(user: user)\n    if account == nil { return {} }\n\n\n    let extraIDs = getNFTIDs(ownerAddress: account!)\n    let inventory : {String : ItemReport} = {}\n    var fetchedCount : Int = 0\n\n    for project in extraIDs.keys {\n\n        let catalogEntry = FINDNFTCatalog.getCatalogEntry(collectionIdentifier:project)!\n        let projectName = catalogEntry.contractName\n\n        if extraIDs[project]! == nil || extraIDs[project]!.ids.length \u003c 1{\n            extraIDs.remove(key: project)\n            continue\n        }\n        \n        let collectionLength = extraIDs[project]!.ids.length\n\n        // by pass if this is not the target collection\n        if targetCollections.length \u003e 0 \u0026\u0026 !targetCollections.contains(project) {\n            // inventory[project] = ItemReport(length : collectionLength, extraIDs :extraIDs[project]! , shard: source)\n            continue\n        }\n\n        inventory[catalogEntry.contractName] = ItemReport(length : collectionLength, extraIDs :extraIDs[project]?.ids ?? [] , shard: source, extraIDsIdentifier: project, collectionName: extraIDs[project]!.collectionName)\n\n    }\n\n    return inventory\n\n}",
               "spec": {
                  "order": [
                     "user",
                     "collections"
                  ],
                  "parameters": {
                     "collections": "[String]",
                     "user": "String"
                  }
               }
            },
            "getNFTCatalogItems": {
               "code": "import MetadataViews from 0x631e88ae7f1d7c20\nimport FIND from 0x35717efbbce11c74\nimport FindViews from 0x35717efbbce11c74\n\nimport FINDNFTCatalog from 0x35717efbbce11c74\n\npub fun main(user: String, collectionIDs: {String : [UInt64]}) : {String : [MetadataCollectionItem]} {\n    return fetchNFTCatalog(user: user, collectionIDs: collectionIDs)\n}\n\npub struct NFTView {\n    pub let id: UInt64\n    pub let display: MetadataViews.Display?\n    pub let edition: UInt64?\n    pub let collectionDisplay: MetadataViews.NFTCollectionDisplay?\n    pub let soulBounded: Bool\n    pub let nftType: Type\n\n    init(\n        id : UInt64,\n        display : MetadataViews.Display?,\n        edition : UInt64?,\n        collectionDisplay: MetadataViews.NFTCollectionDisplay?,\n        soulBounded: Bool ,\n        nftType: Type\n    ) {\n        self.id = id\n        self.display = display\n        self.edition = edition\n        self.collectionDisplay = collectionDisplay\n        self.soulBounded = soulBounded\n        self.nftType = nftType\n    }\n}\n\npub fun getNFTs(ownerAddress: Address, ids: {String : [UInt64]}) : [NFTView] {\n\n    let account = getAuthAccount(ownerAddress)\n\n    if account.balance == 0.0 {\n        return []\n    }\n\n    let results : [NFTView] = []\n    for collectionKey in ids.keys {\n        let catalogEntry = FINDNFTCatalog.getCatalogEntry(collectionIdentifier:collectionKey)!\n        let storagePath = catalogEntry.collectionData.storagePath\n        let ref= account.borrow\u003c\u0026{MetadataViews.ResolverCollection}\u003e(from: storagePath)\n        if ref != nil{\n            for id in ids[collectionKey]! {\n                // results.append(MetadataViews.getNFTView(id:id, viewResolver: ref!.borrowViewResolver(id:id)!))\n                let viewResolver = ref!.borrowViewResolver(id:id)!\n\n                var e : UInt64? = nil\n                if let editions =  MetadataViews.getEditions(viewResolver) {\n                    if editions.infoList.length \u003e 0 {\n                        e = editions.infoList[0].number\n                    }\n                }\n\n                if let v = viewResolver.resolveView(Type\u003cMetadataViews.Edition\u003e()) {\n                    if let edition = v as? MetadataViews.Edition {\n                        e = edition.number\n                    }\n                }\n\n                results.append(\n                    NFTView(\n                        id : id,\n                        display: MetadataViews.getDisplay(viewResolver),\n                        edition : e,\n                        collectionDisplay : MetadataViews.getNFTCollectionDisplay(viewResolver),\n                        soulBounded : FindViews.checkSoulBound(viewResolver),\n                        nftType : viewResolver.getType()\n                    )\n                )\n            }\n        }\n    }\n    return results\n}\n\npub struct CollectionReport {\n    pub let items : {String : [MetadataCollectionItem]}\n    pub let collections : {String : Int} // mapping of collection to no. of ids\n    pub let extraIDs : {String : [UInt64]}\n\n    init(items: {String : [MetadataCollectionItem]},  collections : {String : Int}, extraIDs : {String : [UInt64]} ) {\n        self.items=items\n        self.collections=collections\n        self.extraIDs=extraIDs\n    }\n}\n\npub struct MetadataCollectionItem {\n    pub let id:UInt64\n    pub let name: String\n    pub let edition: UInt64?\n    pub let collection: String // \u003c- This will be Alias unless they want something else\n    pub let subCollection: String? // \u003c- This will be Alias unless they want something else\n    pub let nftDetailIdentifier: String\n    pub let soulBounded: Bool\n\n    pub let media  : String\n    pub let mediaType : String\n    pub let source : String\n\n    init(id:UInt64, name: String, edition: UInt64?, collection: String, subCollection: String?, media  : String, mediaType : String, source : String, nftDetailIdentifier: String, soulBounded: Bool ) {\n        self.id=id\n        self.name=name\n        self.edition=edition\n        self.collection=collection\n        self.subCollection=subCollection\n        self.media=media\n        self.mediaType=mediaType\n        self.source=source\n        self.nftDetailIdentifier=nftDetailIdentifier\n        self.soulBounded=soulBounded\n    }\n}\n\n// Helper function\n\npub fun resolveAddress(user: String) : PublicAccount? {\n    let address = FIND.resolve(user)\n    if address == nil {\n        return nil\n    }\n    return getAccount(address!)\n}\n\n\n//////////////////////////////////////////////////////////////\n// Fetch Specific Collections in FIND Catalog\n//////////////////////////////////////////////////////////////\npub fun fetchNFTCatalog(user: String, collectionIDs: {String : [UInt64]}) : {String : [MetadataCollectionItem]} {\n    let source = \"NFTCatalog\"\n    let account = resolveAddress(user: user)\n    if account == nil { return {} }\n\n    let items : {String : [MetadataCollectionItem]} = {}\n\n    let fetchingIDs = collectionIDs\n\n\n    for project in fetchingIDs.keys {\n\n        let catalogEntry = FINDNFTCatalog.getCatalogEntry(collectionIdentifier:project)!\n        let projectName = catalogEntry.contractName\n\n        let returnedNFTs = getNFTs(ownerAddress: account!.address, ids: {project : fetchingIDs[project]!})\n\n        var collectionItems : [MetadataCollectionItem] = []\n        for nft in returnedNFTs {\n            if nft == nil {\n                continue\n            }\n\n            var subCollection = \"\"\n            if project != nft.collectionDisplay!.name {\n             subCollection = nft.collectionDisplay!.name\n            }\n\n            var name = nft.display!.name\n            if name == \"\" {\n                name = projectName\n            }\n\n            let item = MetadataCollectionItem(\n                id: nft.id,\n                name: name,\n                edition: nft.edition,\n                collection: project,\n                subCollection: subCollection,\n                media: nft.display!.thumbnail.uri(),\n                mediaType: \"image/png\",\n                source: source,\n                nftDetailIdentifier: nft.nftType.identifier,\n                soulBounded: nft.soulBounded\n            )\n            collectionItems.append(item)\n        }\n\n        if collectionItems.length \u003e 0 {\n            items[project] = collectionItems\n        }\n    }\n    return items\n}",
               "spec": {
                  "order": [
                     "user",
                     "collectionIDs"
                  ],
                  "parameters": {
                     "collectionIDs": "{String: [UInt64]}",
                     "user": "String"
                  }
               }
            },
            "getNFTCatalogItemsWithMetadata": {
               "code": "import MetadataViews from 0x631e88ae7f1d7c20\nimport FIND from 0x35717efbbce11c74\nimport FindViews from 0x35717efbbce11c74\n\nimport FINDNFTCatalog from 0x35717efbbce11c74\n\npub fun main(user: String, collectionIDs: {String : [UInt64]}) : {String : [MetadataCollectionItem]} {\n    return fetchNFTCatalog(user: user, collectionIDs: collectionIDs)\n}\n\npub struct NFTView {\n    pub let id: UInt64\n    pub let display: MetadataViews.Display?\n    pub let collectionDisplay: MetadataViews.NFTCollectionDisplay?\n    pub var rarity:MetadataViews.Rarity?\n    pub var editions: MetadataViews.Editions?\n    pub var serial: UInt64?\n    pub var traits: MetadataViews.Traits?\n    pub let soulBounded: Bool \n    pub let nftType: Type\n\n    init(\n        id : UInt64,\n        display : MetadataViews.Display?,\n        editions : MetadataViews.Editions?,\n        rarity:MetadataViews.Rarity?,\n        serial: UInt64?,\n        traits: MetadataViews.Traits?,\n        collectionDisplay: MetadataViews.NFTCollectionDisplay?,\n        soulBounded: Bool ,\n        nftType: Type\n    ) {\n        self.id = id\n        self.display = display\n        self.editions = editions\n        self.rarity = rarity\n        self.serial = serial\n        self.traits = traits\n        self.collectionDisplay = collectionDisplay\n        self.soulBounded = soulBounded\n        self.nftType = nftType\n    }\n}\n\npub fun getNFTs(ownerAddress: Address, ids: {String : [UInt64]}) : [NFTView] {\n\n    let account = getAuthAccount(ownerAddress)\n\n    if account.balance == 0.0 {\n        return []\n    }\n\n    let results : [NFTView] = []\n    for collectionKey in ids.keys {\n        let catalogEntry = FINDNFTCatalog.getCatalogEntry(collectionIdentifier:collectionKey)!\n        let storagePath = catalogEntry.collectionData.storagePath\n        let ref= account.borrow\u003c\u0026{MetadataViews.ResolverCollection}\u003e(from: storagePath)\n        if ref != nil{\n            for id in ids[collectionKey]! {\n                // results.append(MetadataViews.getNFTView(id:id, viewResolver: ref!.borrowViewResolver(id:id)!))\n                let viewResolver = ref!.borrowViewResolver(id:id)!\n\n                var traitsStruct : MetadataViews.Traits? = nil \n\n                if let traits = MetadataViews.getTraits(viewResolver) {\n                    if let trait = getTrait(viewResolver) {\n                        var check = false \n                        for item in traits.traits {\n                            if item.name == trait.name {\n                                check = true \n                                break\n                            }\n                            if !check {\n                                let array = traits.traits\n                                array.append(trait)\n\n                                traitsStruct = cleanUpTraits(array)\n                            }\n                        }\n                    } else {\n                        traitsStruct = cleanUpTraits(traits.traits)\n                    }\n                } else {\n                    if let trait = getTrait(viewResolver) {\n                        traitsStruct = cleanUpTraits([trait])\n                    }\n                }\n\n                var editionStruct : MetadataViews.Editions? = nil \n\n                if let editions = MetadataViews.getEditions(viewResolver) {\n                    if let edition = getEdition(viewResolver) {\n                        var check = false\n                        for item in editions.infoList {\n                            if item.name == edition.name \u0026\u0026 item.number == edition.number \u0026\u0026 item.max == edition.max {\n                                check = true\n                                break\n                            }\n                        }\n                        // If the edition does not exist in editions, add it in\n                        if !check {\n                            let array = editions.infoList \n                            array.append(edition)\n                            editionStruct = MetadataViews.Editions(array)\n                        }\n                    } else {\n                    // If edition does not exist OR edition is already in editions , append it to views and continue\n                        editionStruct = editions\n                    }\n                } else if let edition = getEdition(viewResolver) {\n                        editionStruct = MetadataViews.Editions([edition])\n                }\n\n                results.append(\n                    NFTView(\n                        id : id,\n                        display: MetadataViews.getDisplay(viewResolver),\n                        editions : editionStruct,\n                        rarity : MetadataViews.getRarity(viewResolver),\n                        serial :  MetadataViews.getSerial(viewResolver)?.number,\n                        traits : traitsStruct,\n                        collectionDisplay : MetadataViews.getNFTCollectionDisplay(viewResolver),\n                        soulBounded : FindViews.checkSoulBound(viewResolver),\n                        nftType : viewResolver.getType()\n                    )\n                )\n            }\n        }\n    }\n    return results\n}\n\npub struct CollectionReport {\n    pub let items : {String : [MetadataCollectionItem]} \n    pub let collections : {String : Int} // mapping of collection to no. of ids \n    pub let extraIDs : {String : [UInt64]} \n\n    init(items: {String : [MetadataCollectionItem]},  collections : {String : Int}, extraIDs : {String : [UInt64]} ) {\n        self.items=items \n        self.collections=collections \n        self.extraIDs=extraIDs\n    }\n}\n\npub struct MetadataCollectionItem {\n    pub let id:UInt64\n    pub let name: String\n    pub let collection: String // \u003c- This will be Alias unless they want something else\n    pub let subCollection: String? // \u003c- This will be Alias unless they want something else\n    pub let nftDetailIdentifier: String\n    pub let soulBounded: Bool \n\n    pub let media  : String\n    pub let mediaType : String \n    pub let source : String \n\n    pub var rarity:MetadataViews.Rarity?\n    pub var editions: MetadataViews.Editions?\n    pub var serial: UInt64?\n    pub var traits: MetadataViews.Traits?\n\n    init(id:UInt64, \n         name: String, \n         collection: String, \n         subCollection: String?, \n         media  : String, \n         mediaType : String, \n         source : String, \n         nftDetailIdentifier: String, \n         editions : MetadataViews.Editions?,\n         rarity:MetadataViews.Rarity?,\n         serial: UInt64?,\n         traits: MetadataViews.Traits?,\n         soulBounded: Bool \n         ) {\n        self.id=id\n        self.name=name \n        self.collection=collection \n        self.subCollection=subCollection \n        self.media=media \n        self.mediaType=mediaType \n        self.source=source\n        self.nftDetailIdentifier=nftDetailIdentifier\n        self.editions=editions\n        self.rarity=rarity\n        self.serial=serial\n        self.traits=traits\n        self.soulBounded=soulBounded\n    }\n}\n\n// Helper function \n\npub fun resolveAddress(user: String) : PublicAccount? {\n    let address = FIND.resolve(user)\n    if address == nil {\n        return nil\n    }\n    return getAccount(address!)\n}\n\n\n//////////////////////////////////////////////////////////////\n// Fetch Specific Collections in Find Catalog\n//////////////////////////////////////////////////////////////\npub fun fetchNFTCatalog(user: String, collectionIDs: {String : [UInt64]}) : {String : [MetadataCollectionItem]} {\n    let source = \"NFTCatalog\"\n    let account = resolveAddress(user: user)\n    if account == nil { return {} }\n\n    let items : {String : [MetadataCollectionItem]} = {}\n\n    let fetchingIDs = collectionIDs\n\n\n    for project in fetchingIDs.keys {\n\n        let catalogEntry = FINDNFTCatalog.getCatalogEntry(collectionIdentifier:project)!\n        let projectName = catalogEntry.contractName\n\n        let returnedNFTs = getNFTs(ownerAddress: account!.address, ids: {project : fetchingIDs[project]!})\n\n        var collectionItems : [MetadataCollectionItem] = []\n        for nft in returnedNFTs {\n            if nft == nil {\n                continue\n            }\n\n            var subCollection = \"\"\n            if project != nft!.collectionDisplay!.name {\n             subCollection = nft!.collectionDisplay!.name\n            }\n\n            var name = nft!.display!.name \n            if name == \"\" {\n                name = projectName\n            }\n\n            if nft.editions != nil \u0026\u0026 nft.editions!.infoList.length \u003e 0 {\n                let edition = nft.editions!.infoList[0].number.toString()\n                // check if the name ends with \"editionNumber\"\n                // If the name ends with \"editionNumber\", we do not concat the edition\n                if name.length \u003e edition.length \u0026\u0026 name.slice(from: name.length - edition.length, upTo: name.length) != edition {\n                    name = name.concat(\"#\").concat(nft.editions!.infoList[0].number.toString())\n                }\n            }\n            \n            let item = MetadataCollectionItem(\n                id: nft!.id,\n                name: name,\n                collection: project,\n                subCollection: subCollection, \n                media: nft!.display!.thumbnail.uri(),\n                mediaType: \"image/png\",\n                source: source, \n                nftDetailIdentifier: nft!.nftType.identifier, \n                editions : nft!.editions,\n                rarity: nft!.rarity,\n                serial: nft!.serial,\n                traits: nft!.traits,\n                soulBounded: nft.soulBounded\n            )\n            collectionItems.append(item)\n        }\n\n        if collectionItems.length \u003e 0 {\n            items[project] = collectionItems\n        }\n    }\n    return items\n}\n\npub fun cleanUpTraits(_ traits: [MetadataViews.Trait]) : MetadataViews.Traits {\n    let dateValues  = {\"Date\" : true, \"Numeric\":false, \"Number\":false, \"date\":true, \"numeric\":false, \"number\":false}\n\n    let array : [MetadataViews.Trait] = []\n\n    for i , trait in traits {\n        let displayType = trait.displayType ?? \"string\"\n        if let isDate = dateValues[displayType] {\n            if isDate {\n                array.append(MetadataViews.Trait(name: trait.name, value: trait.value, displayType: \"Date\", rarity: trait.rarity))\n            } else {\n                array.append(MetadataViews.Trait(name: trait.name, value: trait.value, displayType: \"Numeric\", rarity: trait.rarity))\n            }\n        } else {\n            if let value = trait.value as? Bool {\n                if value {\n                    array.append(MetadataViews.Trait(name: trait.name, value: trait.value, displayType: \"Bool\", rarity: trait.rarity))\n                }else {\n                    array.append(MetadataViews.Trait(name: trait.name, value: trait.value, displayType: \"Bool\", rarity: trait.rarity))\n                }\n            } else if let value = trait.value as? String {\n                array.append(MetadataViews.Trait(name: trait.name, value: trait.value, displayType: \"String\", rarity: trait.rarity))\n            } else {\n                array.append(MetadataViews.Trait(name: trait.name, value: trait.value, displayType: \"String\", rarity: trait.rarity))\n            }\n        }\n    }\n    return MetadataViews.Traits(array)\n}\n\npub fun getTrait(_ viewResolver: \u0026{MetadataViews.Resolver}) : MetadataViews.Trait? {\n    if let view = viewResolver.resolveView(Type\u003cMetadataViews.Trait\u003e()) {\n        if let v = view as? MetadataViews.Trait {\n            return v\n        }\n    }\n    return nil\n}\n\npub fun getEdition(_ viewResolver: \u0026{MetadataViews.Resolver}) : MetadataViews.Edition? {\n    if let view = viewResolver.resolveView(Type\u003cMetadataViews.Edition\u003e()) {\n        if let v = view as? MetadataViews.Edition {\n            return v\n        }\n    }\n    return nil\n}",
               "spec": {
                  "order": [
                     "user",
                     "collectionIDs"
                  ],
                  "parameters": {
                     "collectionIDs": "{String: [UInt64]}",
                     "user": "String"
                  }
               }
            },
            "getNFTDetailsNFTCatalog": {
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FindViews from 0x35717efbbce11c74\nimport FindUtils from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FINDNFTCatalog from 0x35717efbbce11c74\nimport FTRegistry from 0x35717efbbce11c74\nimport FindUserStatus from 0x35717efbbce11c74\n\npub struct NFTDetailReport {\n    pub let findMarket: {String : FindMarket.SaleItemInformation}\n    pub let storefront: FindUserStatus.StorefrontListing?\n    pub let storefrontV2: FindUserStatus.StorefrontListing?\n    pub let flowty: FindUserStatus.FlowtyListing?\n    pub let flowtyRental: FindUserStatus.FlowtyRental?\n    pub let flovatar: FindUserStatus.FlovatarListing?\n    pub let flovatarComponent: FindUserStatus.FlovatarComponentListing?\n    pub let nftDetail: NFTDetail?\n    pub let allowedListingActions: {String : ListingTypeReport}\n    pub let dapperAllowedListingActions: {String : ListingTypeReport}\n    pub let linkedForMarket : Bool?\n\n\n    init(findMarket:{String : FindMarket.SaleItemInformation}, storefront: FindUserStatus.StorefrontListing?, storefrontV2: FindUserStatus.StorefrontListing?, flowty: FindUserStatus.FlowtyListing?, flowtyRental: FindUserStatus.FlowtyRental? , flovatar: FindUserStatus.FlovatarListing? , flovatarComponent: FindUserStatus.FlovatarComponentListing? , nftDetail: NFTDetail?, allowedListingActions: {String : ListingTypeReport}, dapperAllowedListingActions: {String : ListingTypeReport}, linkedForMarket : Bool?) {\n        self.findMarket=findMarket\n        self.storefront=storefront\n        self.storefrontV2=storefrontV2\n        self.flowty=flowty\n        self.flowtyRental=flowtyRental\n        self.flovatar=flovatar\n        self.flovatarComponent=flovatarComponent\n        self.nftDetail=nftDetail\n        self.allowedListingActions=allowedListingActions\n        self.dapperAllowedListingActions=dapperAllowedListingActions\n        self.linkedForMarket = linkedForMarket\n    }\n}\n\n\npub struct ListingTypeReport {\n    pub let ftAlias: [String]\n    pub let ftIdentifiers: [String]\n    pub let listingType: String\n    pub let status: String\n    pub let ListingDetails: [ListingRoyalties]\n\n    init(listingType: String, ftAlias: [String], ftIdentifiers: [String],  status: String , ListingDetails: [ListingRoyalties]) {\n        self.listingType=listingType\n        self.status=status\n        self.ListingDetails=ListingDetails\n        self.ftAlias=ftAlias\n        self.ftIdentifiers=ftIdentifiers\n    }\n}\n\npub struct NFTDetail {\n    pub let id: UInt64\n    pub let uuid: UInt64\n    pub let name:String\n    pub let description:String\n    pub let thumbnail:String\n    pub let type: String\n    pub var externalViewURL: String?\n    pub var rarity:MetadataViews.Rarity?\n    pub var editions: [MetadataViews.Edition]\n    pub var serial: UInt64?\n    pub var traits: [MetadataViews.Trait]\n    pub var media : {String: String} //url to mediaType\n    pub var collection : NFTCollectionDisplay?\n    pub var license : String?\n    pub var data: {String : AnyStruct?}\n    pub var soulBounded: Bool\n    pub var views :[String]\n\n    init(_ pointer: FindViews.ViewReadPointer, views: {String : AnyStruct}, resolvedViews: [Type]){\n\n        self.type=pointer.itemType.identifier\n        self.id=pointer.id\n        self.uuid=pointer.getUUID()\n\n        // Display\n        let display = views[\"Display\"] ?? panic(\"Could not find display\")\n        let d = display as! MetadataViews.Display\n        self.name=d.name\n        self.description=d.description\n        self.thumbnail=d.thumbnail.uri()\n        views.remove(key: \"Display\")\n\n        // External URL\n        self.externalViewURL = nil\n        if let externalURL = views[\"ExternalURL\"] {\n            if let e = externalURL as? MetadataViews.ExternalURL {\n                self.externalViewURL = e.url\n            }\n        }\n        views.remove(key: \"ExternalURL\")\n\n        // Edition\n        self.editions=[]\n        if let editions = views[\"Editions\"] {\n            if let e = editions as? MetadataViews.Editions {\n                if e.infoList.length \u003e 0 {\n                    self.editions=e.infoList\n                }\n            }\n        }\n        views.remove(key: \"Editions\")\n\n        // Serial\n        self.serial=nil\n        if let serial = views[\"Serial\"] {\n            if let s = serial as? MetadataViews.Serial {\n                self.serial=s.number\n            }\n        }\n        views.remove(key: \"Serial\")\n\n        // subCollection\n        self.collection=nil\n        if let grouping = views[\"NFTCollectionDisplay\"] {\n            if let sc = grouping as? MetadataViews.NFTCollectionDisplay {\n                self.collection=NFTCollectionDisplay(sc)\n            }\n        }\n        views.remove(key: \"NFTCollectionDisplay\")\n\n        // Medias\n        self.media={}\n        if let medias= views[\"Medias\"] {\n            if let ms = medias as? MetadataViews.Medias {\n                for m in ms.items {\n                    let url = m.file.uri()\n                    let type = m.mediaType\n                    self.media[url] = type\n                }\n            }\n        }\n        views.remove(key: \"Medias\")\n\n        // Rarity\n        self.rarity=nil\n        if let rarity= views[\"Rarity\"] {\n            if let r = rarity as? MetadataViews.Rarity {\n                self.rarity = r\n            }\n        }\n        views.remove(key: \"Rarity\")\n\n        // Traits\n        self.traits=[]\n        if let traits = views[\"Traits\"] {\n            if let t = traits as? MetadataViews.Traits {\n                if t.traits.length \u003e 0 {\n                    self.traits=t.traits\n                }\n            }\n        }\n        views.remove(key: \"Traits\")\n\n        // License\n        self.license= nil\n        if let license= views[\"License\"] {\n            if let l = license as? MetadataViews.License {\n                self.license = l.spdxIdentifier\n            }\n        }\n        views.remove(key: \"License\")\n\n        self.soulBounded = false\n        if let soulBound= views[\"SoulBound\"] {\n            self.soulBounded = true\n        }\n        views.remove(key: \"SoulBound\")\n\n        self.views=[]\n\n        for view in pointer.getViews() {\n            if defaultViews().contains(view) {\n                continue\n            }\n            if resolvedViews.contains(view) {\n                continue\n            }\n            self.views.append(view.identifier)\n        }\n        self.data=views\n\n    }\n}\n\npub struct ListingRoyalties {\n\n    pub let ftAlias: String?\n    pub let ftIdentifier: String\n    pub let royalties: [Royalties]\n\n    init(ftAlias: String?, ftIdentifier: String, royalties: [Royalties]) {\n        self.ftAlias=ftAlias\n        self.ftIdentifier=ftIdentifier\n        self.royalties=royalties\n    }\n}\n\npub struct Royalties {\n\n    pub let royaltyName: String\n    pub let address: Address\n    pub let findName: String?\n    pub let cut: UFix64\n\n    init(royaltyName: String , address: Address, findName: String?, cut: UFix64) {\n        self.royaltyName=royaltyName\n        self.address=address\n        self.findName=findName\n        self.cut=cut\n    }\n}\n\npub struct NFTCollectionDisplay {\n    // Name that should be used when displaying this NFT collection.\n    pub let name: String\n\n    // Description that should be used to give an overview of this collection.\n    pub let description: String\n\n    // External link to a URL to view more information about this collection.\n    pub let externalURL: String\n\n    // Square-sized image to represent this collection.\n    pub let squareImage: {String : String}\n\n    // Banner-sized image for this collection, recommended to have a size near 1200x630.\n    pub let bannerImage: {String : String}\n\n    // Social links to reach this collection's social homepages.\n    // Possible keys may be \"instagram\", \"twitter\", \"discord\", etc.\n    pub let socials: {String: String}\n\n    init(\n        _ nftCD : MetadataViews.NFTCollectionDisplay\n    ) {\n        self.name = nftCD.name\n        self.description = nftCD.description\n        self.externalURL = nftCD.externalURL.url\n\n        let squareImage = {nftCD.squareImage.file.uri() : nftCD.squareImage.mediaType}\n        self.squareImage = squareImage\n\n        let bannerImage = {nftCD.bannerImage.file.uri() : nftCD.bannerImage.mediaType}\n        self.bannerImage = bannerImage\n\n        let socials : {String : String} = {}\n        for key in nftCD.socials.keys{\n            socials[key] = nftCD.socials[key]!.url\n        }\n        self.socials = socials\n    }\n}\n\npub var counter = 0\n\npub fun main(user: String, project:String, id: UInt64, views: [String]) : NFTDetailReport?{\n    let resolveAddress = FIND.resolve(user)\n    if resolveAddress == nil {\n        return nil\n    }\n    let address = resolveAddress!\n\n    let account = getAuthAccount(address)\n\n    if account.balance \u003e 0.0 {\n        // check link for market\n        let linkedForMarket = account.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(getPublicPath(project)).check()\n\n        let storagePath = getStoragePath(project)\n        let publicPath = PublicPath(identifier: \"find_temp_path_\".concat(counter.toString()))!\n        counter = counter + 1\n        account.link\u003c\u0026{MetadataViews.ResolverCollection}\u003e(publicPath, target: storagePath)\n        let cap = account.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(publicPath)\n        if !cap.check() {\n            panic(\"The user does not set up collection correctly.\")\n        }\n        let pointer = FindViews.ViewReadPointer(cap: cap, id: id)\n\n        let nftDetail = getNFTDetail(pointer:pointer, views: views)\n        if nftDetail == nil {\n            return nil\n        }\n\n\n        let findAddress=FindMarket.getFindTenantAddress()\n        var findMarket=FindMarket.getNFTListing(tenant:findAddress, address: address, id: nftDetail!.uuid, getNFTInfo:false)\n\n        var report : {String : ListingTypeReport} = {}\n        var dapperReport : {String : ListingTypeReport} = {}\n\n        // check if that's soulBound, if yes, the report will be nil\n        if !pointer.checkSoulBound() {\n            let tenantCap = FindMarket.getTenantCapability(findAddress)!\n            let tenantRef = tenantCap.borrow() ?? panic(\"This tenant is not set up. Tenant : \".concat(tenantCap.address.toString()))\n\n            let marketTypes = FindMarket.getSaleItemTypes()\n\n            for marketType in marketTypes {\n                if let allowedListing = tenantRef.getAllowedListings(nftType: pointer.getItemType(), marketType: marketType) {\n                    report[FindMarket.getMarketOptionFromType(marketType)] = createListingTypeReport(allowedListing, pointer: pointer, tenantRef: tenantRef, dapper: false)\n                    dapperReport[FindMarket.getMarketOptionFromType(marketType)] = createListingTypeReport(allowedListing, pointer: pointer, tenantRef: tenantRef, dapper: true)\n                }\n            }\n        }\n\n        let nftType = pointer.itemType\n        let listingsV1 = FindUserStatus.getStorefrontListing(user: address, id : id, type: nftType)\n        let listingsV2 = FindUserStatus.getStorefrontV2Listing(user: address, id : id, type: nftType)\n        let flowty = FindUserStatus.getFlowtyListing(user: address, id : id, type: nftType)\n        let flowtyRental = FindUserStatus.getFlowtyRentals(user: address, id : id, type: nftType)\n        let flovatar = FindUserStatus.getFlovatarListing(user: address, id : id, type: nftType)\n        let flovatarComponent = FindUserStatus.getFlovatarComponentListing(user: address, id : id, type: nftType)\n\n        return NFTDetailReport(findMarket:findMarket, storefront:listingsV1, storefrontV2: listingsV2, flowty:flowty, flowtyRental:flowtyRental, flovatar:flovatar, flovatarComponent:flovatarComponent, nftDetail: nftDetail, allowedListingActions: report, dapperAllowedListingActions: dapperReport, linkedForMarket : linkedForMarket)\n    }\n    return nil\n\n}\n\npub let resolvedAddresses : {Address : String} = {}\n\npub var nftRoyalties : [Royalties]? = nil\n\npub fun reverseLookup(_ addr: Address) : String? {\n\n    if let name = resolvedAddresses[addr] {\n        if name == \"\" {\n            return nil\n        } else {\n            return name\n        }\n    }\n    let name = FIND.reverseLookup(addr)\n    if name == nil {\n        resolvedAddresses[addr] = \"\"\n    } else {\n        resolvedAddresses[addr] = name\n    }\n    return name\n\n}\n\npub fun getNFTDetail(pointer: FindViews.ViewReadPointer, views: [String]) : NFTDetail? {\n\n    if !pointer.valid() {\n        return nil\n    }\n\n    var nftViews: {String : AnyStruct} = {}\n    var resolvedViews: [Type] = []\n    let viewResolver = pointer.getViewResolver()\n\n    let defaultViews = defaultViews()\n    for view in views {\n        if let runTimeType = CompositeType(view) {\n            if !defaultViews.contains(runTimeType) {\n                defaultViews.append(runTimeType)\n            }\n        }\n    }\n\n\n    for runTimeType in defaultViews {\n        // Resolve arrayed views to ensure we didn't miss any stuff\n        if runTimeType == Type\u003cMetadataViews.Editions\u003e() {\n            if let editions = MetadataViews.getEditions(viewResolver) {\n                if let edition = getEdition(viewResolver) {\n                    var check = false\n                    for item in editions.infoList {\n                        if item.name == edition.name \u0026\u0026 item.number == edition.number \u0026\u0026 item.max == edition.max {\n                            check = true\n                            break\n                        }\n                    }\n                    // If the edition does not exist in editions, add it in\n                    if !check {\n                        let array = editions.infoList\n                        array.append(edition)\n                        nftViews[\"Editions\"] = MetadataViews.Editions(array)\n                        resolvedViews.append(runTimeType)\n                        continue\n                    }\n                }\n                // If edition does not exist OR edition is already in editions , append it to views and continue\n                nftViews[\"Editions\"] = editions\n                resolvedViews.append(runTimeType)\n                continue\n            }\n        }\n\n        if runTimeType == Type\u003cMetadataViews.Edition\u003e() {\n            // If the editions does not exist, check if there is edition, if there is, add it in as editions\n            if nftViews[\"Editions\"] == nil {\n                if let edition = getEdition(viewResolver) {\n                    nftViews[\"Editions\"] = MetadataViews.Editions([edition])\n                    resolvedViews.append(runTimeType)\n                }\n            }\n            continue\n        }\n\n        if runTimeType == Type\u003cMetadataViews.Medias\u003e() {\n            if let medias = MetadataViews.getMedias(viewResolver) {\n                if let media = getMedia(viewResolver) {\n                    var check = false\n                    let uri = media.file.uri()\n                    for item in medias.items {\n                        if item.file.uri() == uri {\n                            check = true\n                            break\n                        }\n                        if !check {\n                            let array = medias.items\n                            array.append(media)\n                            nftViews[\"Medias\"] = MetadataViews.Medias(array)\n                            resolvedViews.append(runTimeType)\n                            continue\n                        }\n                    }\n                }\n                nftViews[\"Medias\"] = medias\n                resolvedViews.append(runTimeType)\n                continue\n            }\n        }\n\n        if runTimeType == Type\u003cMetadataViews.Media\u003e() {\n            if nftViews[\"Medias\"] == nil {\n                if let media = getMedia(viewResolver) {\n                    nftViews[\"Medias\"] = MetadataViews.Medias([media])\n                    resolvedViews.append(runTimeType)\n                }\n            }\n            continue\n        }\n\n        if runTimeType == Type\u003cMetadataViews.Traits\u003e() {\n            if let traits = MetadataViews.getTraits(viewResolver) {\n                if let trait = getTrait(viewResolver) {\n                    var check = false\n                    for item in traits.traits {\n                        if item.name == trait.name {\n                            check = true\n                            break\n                        }\n                        if !check {\n                            let array = traits.traits\n                            array.append(trait)\n\n                            nftViews[\"Traits\"] = cleanUpTraits(array)\n                            resolvedViews.append(runTimeType)\n                            continue\n                        }\n                    }\n                }\n                nftViews[\"Traits\"] = cleanUpTraits(traits.traits)\n                resolvedViews.append(runTimeType)\n                continue\n            }\n        }\n\n        if runTimeType == Type\u003cMetadataViews.Trait\u003e() {\n            if nftViews[\"Traits\"] == nil {\n                if let trait = getTrait(viewResolver) {\n                    nftViews[\"Traits\"] = MetadataViews.Traits([trait])\n                    resolvedViews.append(runTimeType)\n                }\n            }\n            continue\n        }\n\n        if let view = pointer.resolveView(runTimeType) {\n            let name = FindUtils.splitString(runTimeType.identifier, sep: \".\")[3]\n            nftViews[name] = view\n            resolvedViews.append(runTimeType)\n        }\n    }\n\n    return NFTDetail(pointer, views: nftViews, resolvedViews: resolvedViews)\n\n\n}\n\npub fun getEdition(_ viewResolver: \u0026{MetadataViews.Resolver}) : MetadataViews.Edition? {\n    if let view = viewResolver.resolveView(Type\u003cMetadataViews.Edition\u003e()) {\n        if let v = view as? MetadataViews.Edition {\n            return v\n        }\n    }\n    return nil\n}\n\npub fun getMedia(_ viewResolver: \u0026{MetadataViews.Resolver}) : MetadataViews.Media? {\n    if let view = viewResolver.resolveView(Type\u003cMetadataViews.Media\u003e()) {\n        if let v = view as? MetadataViews.Media {\n            return v\n        }\n    }\n    return nil\n}\n\npub fun getTrait(_ viewResolver: \u0026{MetadataViews.Resolver}) : MetadataViews.Trait? {\n    if let view = viewResolver.resolveView(Type\u003cMetadataViews.Trait\u003e()) {\n        if let v = view as? MetadataViews.Trait {\n            return v\n        }\n    }\n    return nil\n}\n\n/* Helper Function */\npub fun resolveRoyalties(_ pointer: FindViews.ViewReadPointer) : [Royalties] {\n    let array : [Royalties] = []\n    for royalty in pointer.getRoyalty().getRoyalties() {\n        let address = royalty.receiver.address\n        array.append(Royalties(royaltyName: royalty.description, address: address, findName: reverseLookup(address), cut: royalty.cut))\n    }\n\n    return array\n}\n\npub fun resolveMarketplaceRoyalties(tenantRef: \u0026FindMarket.Tenant{FindMarket.TenantPublic}, listing: Type, nft: Type, ft: Type) : [Royalties] {\n\n    let cuts = tenantRef.getCuts(name:\"\", listingType: listing, nftType:nft, ftType:ft)\n\n    let royalties :[Royalties] = []\n\n    for allCuts in cuts.values {\n        for cut in allCuts.cuts {\n            royalties.append(Royalties(royaltyName: cut.getName(), address: cut.getAddress(), findName: reverseLookup(cut.getAddress()), cut: cut.getCut()))\n        }\n    }\n\n    return royalties\n}\n\npub fun createListingTypeReport(_ allowedListing: FindMarket.AllowedListing, pointer: FindViews.ViewReadPointer, tenantRef: \u0026FindMarket.Tenant{FindMarket.TenantPublic}, dapper: Bool) : ListingTypeReport? {\n    let listingType = allowedListing.listingType.identifier\n    var ftAlias : [String] = []\n    var ftIdentifier : [String] = []\n    var listingDetails : [ListingRoyalties] = []\n    for ft in allowedListing.ftTypes {\n        var alias : String? = nil\n        let ftInfo = FTRegistry.getFTInfo(ft.identifier) ?? panic(ft.identifier.concat(\" is not added to FTRegistry yet.\"))\n        switch dapper {\n            case true :\n                if !ftInfo.tag.contains(\"dapper\") {\n                    continue\n                }\n\n            case false :\n                if ftInfo.tag.contains(\"dapper\") {\n                    continue\n                }\n        }\n        alias = ftInfo.alias\n        ftAlias.append(ftInfo.alias)\n        ftIdentifier.append(ft.identifier)\n\n        // getRoyalties\n        var nftR = nftRoyalties\n        if nftR == nil {\n            nftRoyalties = resolveRoyalties(pointer)\n            nftR = nftRoyalties\n        }\n\n        let findR = resolveMarketplaceRoyalties(tenantRef: tenantRef, listing: allowedListing.listingType , nft: pointer.getItemType(), ft: ft)\n        findR.appendAll(nftR!)\n\n        listingDetails.append(ListingRoyalties(ftAlias: alias, ftIdentifier: ft.identifier, royalties: findR))\n    }\n\n    if ftIdentifier.length == 0 {\n        return nil\n    }\n\n    return ListingTypeReport(listingType: listingType, ftAlias: ftAlias, ftIdentifiers: ftIdentifier,  status: allowedListing.status , ListingDetails: listingDetails)\n}\n\npub fun defaultViews() : [Type] {\n    return [\n    Type\u003cMetadataViews.Display\u003e() ,\n    Type\u003cMetadataViews.Editions\u003e() ,\n    Type\u003cMetadataViews.Edition\u003e() ,\n    Type\u003cMetadataViews.Serial\u003e() ,\n    Type\u003cMetadataViews.Medias\u003e() ,\n    Type\u003cMetadataViews.Media\u003e() ,\n    Type\u003cMetadataViews.License\u003e() ,\n    Type\u003cMetadataViews.ExternalURL\u003e() ,\n    Type\u003cMetadataViews.NFTCollectionDisplay\u003e() ,\n    Type\u003cMetadataViews.Traits\u003e() ,\n    Type\u003cMetadataViews.Trait\u003e() ,\n    Type\u003cMetadataViews.Rarity\u003e(),\n    Type\u003cFindViews.SoulBound\u003e()\n    ]\n}\n\npub fun getStoragePath(_ nftIdentifier: String) : StoragePath {\n    if let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys {\n        let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])!\n        return collection.collectionData.storagePath\n    }\n\n    if let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier :nftIdentifier) {\n        return collection.collectionData.storagePath\n    }\n    panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier))\n}\n\npub fun getPublicPath(_ nftIdentifier: String) : PublicPath {\n    if let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys {\n        let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])!\n        return collection.collectionData.publicPath\n    }\n\n    if let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier :nftIdentifier) {\n        return collection.collectionData.publicPath\n    }\n    panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier))\n}\n\npub fun cleanUpTraits(_ traits: [MetadataViews.Trait]) : MetadataViews.Traits {\n    let dateValues  = {\"Date\" : true, \"Numeric\":false, \"Number\":false, \"date\":true, \"numeric\":false, \"number\":false}\n\n    let array : [MetadataViews.Trait] = []\n\n    for i , trait in traits {\n        let displayType = trait.displayType ?? \"string\"\n        if let isDate = dateValues[displayType] {\n            if isDate {\n                array.append(MetadataViews.Trait(name: trait.name, value: trait.value, displayType: \"Date\", rarity: trait.rarity))\n            } else {\n                array.append(MetadataViews.Trait(name: trait.name, value: trait.value, displayType: \"Numeric\", rarity: trait.rarity))\n            }\n        } else {\n            if let value = trait.value as? Bool {\n                if value {\n                    array.append(MetadataViews.Trait(name: trait.name, value: trait.value, displayType: \"Bool\", rarity: trait.rarity))\n                }else {\n                    array.append(MetadataViews.Trait(name: trait.name, value: trait.value, displayType: \"Bool\", rarity: trait.rarity))\n                }\n            } else if let value = trait.value as? String {\n                array.append(MetadataViews.Trait(name: trait.name, value: trait.value, displayType: \"String\", rarity: trait.rarity))\n            } else {\n                array.append(MetadataViews.Trait(name: trait.name, value: trait.value, displayType: \"String\", rarity: trait.rarity))\n            }\n        }\n    }\n    return MetadataViews.Traits(array)\n}",
               "spec": {
                  "order": [
                     "user",
                     "project",
                     "id",
                     "views"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "project": "String",
                     "user": "String",
                     "views": "[String]"
                  }
               }
            },
            "getNFTDetailsShard1": {
               "code": "import FIND from 0x35717efbbce11c74\nimport AlchemyMetadataWrapperTestnetShard1 from 0x5ff2c7b4c40de11\n// import AlchemyMetadataWrapperTestnetShard2 from 0x5ff2c7b4c40de11\n// import AlchemyMetadataWrapperTestnetShard3 from 0x5ff2c7b4c40de11\n\npub fun main(user: String , project: String, id: UInt64, views: [String]) : AlchemyMetadataWrapperTestnetShard1.NFTData? {\n\n    if let address = FIND.resolve(user) {\n        let ids : {String:[UInt64]} = {project : [id]}\n        let res = AlchemyMetadataWrapperTestnetShard1.getNFTs(ownerAddress: address, ids: ids)\n        if res.length == 0 || res[0] == nil {\n            return nil\n        }\n        return res[0]!\n    }\n    return nil\n\n}",
               "spec": {
                  "order": [
                     "user",
                     "project",
                     "id",
                     "views"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "project": "String",
                     "user": "String",
                     "views": "[String]"
                  }
               }
            },
            "getNFTDetailsShard2": {
               "code": "import FIND from 0x35717efbbce11c74\n// import AlchemyMetadataWrapperTestnetShard1 from 0x5ff2c7b4c40de11\nimport AlchemyMetadataWrapperTestnetShard2 from 0x5ff2c7b4c40de11\n// import AlchemyMetadataWrapperTestnetShard3 from 0x5ff2c7b4c40de11\n\npub fun main(user: String , project: String, id: UInt64, views: [String]) : AlchemyMetadataWrapperTestnetShard2.NFTData? {\n\n    if let address = FIND.resolve(user) {\n        let ids : {String:[UInt64]} = {project : [id]}\n        let res = AlchemyMetadataWrapperTestnetShard2.getNFTs(ownerAddress: address, ids: ids)\n        if res.length == 0 || res[0] == nil {\n            return nil\n        }\n        return res[0]!\n    }\n    return nil\n\n}",
               "spec": {
                  "order": [
                     "user",
                     "project",
                     "id",
                     "views"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "project": "String",
                     "user": "String",
                     "views": "[String]"
                  }
               }
            },
            "getNFTDetailsShard3": {
               "code": "import FIND from 0x35717efbbce11c74\n// import AlchemyMetadataWrapperTestnetShard1 from 0x5ff2c7b4c40de11\n// import AlchemyMetadataWrapperTestnetShard2 from 0x5ff2c7b4c40de11\nimport AlchemyMetadataWrapperTestnetShard3 from 0x5ff2c7b4c40de11\n\npub fun main(user: String , project: String, id: UInt64, views: [String]) : AlchemyMetadataWrapperTestnetShard3.NFTData? {\n\n    if let address = FIND.resolve(user) {\n        let ids : {String:[UInt64]} = {project : [id]}\n        let res = AlchemyMetadataWrapperTestnetShard3.getNFTs(ownerAddress: address, ids: ids)\n        if res.length == 0 || res[0] == nil {\n            return nil\n        }\n        return res[0]!\n    }\n    return nil\n\n}",
               "spec": {
                  "order": [
                     "user",
                     "project",
                     "id",
                     "views"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "project": "String",
                     "user": "String",
                     "views": "[String]"
                  }
               }
            },
            "getNFTDetailsShard4": {
               "code": "import FIND from 0x35717efbbce11c74\nimport AlchemyMetadataWrapperTestnetShard3 from 0x5ff2c7b4c40de11\n\npub fun main(user: String , project: String, id: UInt64, views: [String]): AlchemyMetadataWrapperTestnetShard3.NFTData? {\n\n    return nil\n\n}",
               "spec": {
                  "order": [
                     "user",
                     "project",
                     "id",
                     "views"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "project": "String",
                     "user": "String",
                     "views": "[String]"
                  }
               }
            },
            "getNFTDetailsSocks": {
               "code": "import FIND from 0x35717efbbce11c74\n\npub fun main(user: String , project: String, id: UInt64, views: [String]) : NFTData? {\n\n    return nil\n}\n\npub struct NFTData {\n    pub let contract: NFTContractData\n    pub let id: UInt64\n    pub let uuid: UInt64?\n    pub let title: String?\n    pub let description: String?\n    pub let external_domain_view_url: String?\n    pub let token_uri: String?\n    pub let media: [NFTMedia?]\n    pub let metadata: {String: String?}\n\n    init(\n        contract: NFTContractData,\n        id: UInt64,\n        uuid: UInt64?,\n        title: String?,\n        description: String?,\n        external_domain_view_url: String?,\n        token_uri: String?,\n        media: [NFTMedia?],\n        metadata: {String: String?}\n    ) {\n        self.contract = contract\n        self.id = id\n        self.uuid = uuid\n        self.title = title\n        self.description = description\n        self.external_domain_view_url = external_domain_view_url\n        self.token_uri = token_uri\n        self.media = media\n        self.metadata = metadata\n    }\n}\n\npub struct NFTContractData {\n    pub let name: String\n    pub let address: Address\n    pub let storage_path: String\n    pub let public_path: String\n    pub let public_collection_name: String\n    pub let external_domain: String\n\n    init(\n        name: String,\n        address: Address,\n        storage_path: String,\n        public_path: String,\n        public_collection_name: String,\n        external_domain: String\n    ) {\n        self.name = name\n        self.address = address\n        self.storage_path = storage_path\n        self.public_path = public_path\n        self.public_collection_name = public_collection_name\n        self.external_domain = external_domain\n    }\n}\n\npub struct NFTMedia {\n    pub let uri: String?\n    pub let mimetype: String?\n\n    init(\n        uri: String?,\n        mimetype: String?\n    ) {\n        self.uri = uri\n        self.mimetype = mimetype\n    }\n}",
               "spec": {
                  "order": [
                     "user",
                     "project",
                     "id",
                     "views"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "project": "String",
                     "user": "String",
                     "views": "[String]"
                  }
               }
            },
            "getNFTView": {
               "code": "import MetadataViews from 0x631e88ae7f1d7c20\nimport FINDNFTCatalog from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\n\n//Fetch a single view from a nft on a given path\npub fun main(user: String, aliasOrIdentifier:String, id: UInt64, identifier: String) : AnyStruct? {\n\n    let publicPath = getPublicPath(aliasOrIdentifier)\n    let resolveAddress = FIND.resolve(user) \n    if resolveAddress == nil {return []}\n    let address = resolveAddress!\n\n    let pp = publicPath\n    let account = getAccount(address)\n    if account.balance == 0.0 {\n        return nil\n    }\n    let collection= account.getCapability(pp).borrow\u003c\u0026{MetadataViews.ResolverCollection}\u003e()!\n\n    let nft=collection.borrowViewResolver(id: id)\n    for v in nft.getViews() {\n        if v.identifier== identifier {\n            return nft.resolveView(v)\n        }\n    }\n    return nil\n}\n\npub fun getPublicPath(_ nftIdentifier: String) : PublicPath {\n    let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier)) \n    let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n    return collection.collectionData.publicPath\n}",
               "spec": {
                  "order": [
                     "user",
                     "aliasOrIdentifier",
                     "id",
                     "identifier"
                  ],
                  "parameters": {
                     "aliasOrIdentifier": "String",
                     "id": "UInt64",
                     "identifier": "String",
                     "user": "String"
                  }
               }
            },
            "getNFTViews": {
               "code": "import MetadataViews from 0x631e88ae7f1d7c20\nimport NFTCatalog from 0x324c34e1c517e4db\nimport FINDNFTCatalog from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\n\n//get all the views for an nft and address/path/id\npub fun main(user: String, aliasOrIdentifier:String, id: UInt64) : [String] {\n    let nftInfo = getCollectionData(aliasOrIdentifier) \n\n    let resolveAddress = FIND.resolve(user) \n    if resolveAddress == nil {return []}\n    let address = resolveAddress!\n    let pp = nftInfo.publicPath\n    let collection= getAccount(address).getCapability(pp).borrow\u003c\u0026{MetadataViews.ResolverCollection}\u003e()!\n    let nft=collection.borrowViewResolver(id: id)\n    let views:[String]=[]\n    for v in nft.getViews() {\n        views.append(v.identifier)\n    }\n    return views\n}\n\npub fun getCollectionData(_ nftIdentifier: String) : NFTCatalog.NFTCollectionData {\n    let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier)) \n    let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n    return collection.collectionData\n}",
               "spec": {
                  "order": [
                     "user",
                     "aliasOrIdentifier",
                     "id"
                  ],
                  "parameters": {
                     "aliasOrIdentifier": "String",
                     "id": "UInt64",
                     "user": "String"
                  }
               }
            },
            "getName": {
               "code": "import FIND from 0x35717efbbce11c74\n\npub fun main(address: Address) : String?{\n    return FIND.reverseLookup(address)\n}",
               "spec": {
                  "order": [
                     "address"
                  ],
                  "parameters": {
                     "address": "Address"
                  }
               }
            },
            "getNameDetails": {
               "code": "import FIND from 0x35717efbbce11c74\nimport Profile from 0x35717efbbce11c74\nimport FindRelatedAccounts from 0x35717efbbce11c74\n\npub struct FINDReport {\n    pub let profile:Profile.UserReport?\n    pub let bids: [FIND.BidInfo]\n    pub let relatedAccounts: { String: [Address]}\n    pub let leases: [FIND.LeaseInformation]\n    pub let privateMode: Bool\n    pub let activatedAccount: Bool \n\n\n    init(profile: Profile.UserReport?, relatedAccounts: { String: [Address]}, bids: [FIND.BidInfo], leases : [FIND.LeaseInformation], privateMode: Bool, activatedAccount: Bool ) {\n        self.profile=profile\n        self.bids=bids\n        self.leases=leases\n        self.relatedAccounts=relatedAccounts\n        self.privateMode=privateMode\n        self.activatedAccount=activatedAccount\n    }\n}\n\npub struct NameReport {\n    pub let status: String\n    pub let cost: UFix64 \n    pub let leaseStatus: FIND.LeaseInformation?\n    pub let userReport: FINDReport? \n\n    init(status: String, cost: UFix64, leaseStatus: FIND.LeaseInformation?, userReport: FINDReport? ) {\n        self.status=status \n        self.cost=cost \n        self.leaseStatus=leaseStatus\n        self.userReport=userReport\n    }\n}\n\npub fun main(user: String) : NameReport? {\n\n    var findReport: FINDReport? = nil\n    var nameLease: FIND.LeaseInformation? = nil\n    if let address=FIND.resolve(user) {\n        let account=getAccount(address)\n        if account.balance != 0.0 {\n            let bidCap = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n            let leaseCap = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n            let profile=account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath).borrow()\n\n            var profileReport = profile?.asReport() \n            if profileReport != nil \u0026\u0026 profileReport!.findName != FIND.reverseLookup(address) {\n                profileReport = Profile.UserReport(\n                    findName: \"\",\n                    address: profileReport!.address,\n                    name: profileReport!.name,\n                    gender: profileReport!.gender,\n                    description: profileReport!.description,\n                    tags: profileReport!.tags,\n                    avatar: profileReport!.avatar,\n                    links: profileReport!.links,\n                    wallets: profileReport!.wallets, \n                    following: profileReport!.following,\n                    followers: profileReport!.followers,\n                    allowStoringFollowers: profileReport!.allowStoringFollowers,\n                    createdAt: profileReport!.createdAt\n                )\n            }\n\n            findReport = FINDReport(\n                profile: profileReport,\n                relatedAccounts: FindRelatedAccounts.findRelatedFlowAccounts(address:address),\n                bids: bidCap.borrow()?.getBids() ?? [],\n                leases: leaseCap.borrow()?.getLeaseInformation() ?? [],\n                privateMode: profile?.isPrivateModeEnabled() ?? false, \n                activatedAccount: true\n            )\n            if FIND.validateFindName(user) \u0026\u0026 findReport != nil {\n                for lease in findReport!.leases {\n                    if lease.name == user {\n                        nameLease = lease\n                        break\n                    }\n                }\n            }\n        } else {\n            findReport = FINDReport(\n                profile: nil,\n                relatedAccounts: {},\n                bids: [],\n                leases: [],\n                privateMode: false, \n                activatedAccount: false\n            )\n        }\n        \n    }\n\n    var nameReport : NameReport? = nil \n    if FIND.validateFindName(user) {\n        let status = FIND.status(user)\n        let cost=FIND.calculateCost(user)\n        var s=\"TAKEN\"    \n        if status.status == FIND.LeaseStatus.FREE {\n            s=\"FREE\"\n        } else if status.status == FIND.LeaseStatus.LOCKED {\n            s=\"LOCKED\"\n        }\n        nameReport = NameReport(status: s, cost: cost, leaseStatus: nameLease, userReport: findReport)\n    }\n    \n\n    return nameReport\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "getNameStatus": {
               "code": "import FIND from 0x35717efbbce11c74\nimport Profile from 0x35717efbbce11c74\n\npub fun main(name: String) :  \u0026{Profile.Public}? {\n    return FIND.lookup(name)\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "getNames": {
               "code": "import FIND from 0x35717efbbce11c74\n\npub fun main(address: [Address]) : { Address:String}{\n\n    let items : {Address:String} = {}\n    for a in address {\n        if let name= FIND.reverseLookup(a) {\n            items[a]=name\n        }\n    }\n    return items\n}",
               "spec": {
                  "order": [
                     "address"
                  ],
                  "parameters": {
                     "address": "[Address]"
                  }
               }
            },
            "getNamesWithBids": {
               "code": "import FIND from 0x35717efbbce11c74\n\npub fun main(user: String) : [FIND.LeaseInformation] {\n\n    let resolveAddress = FIND.resolve(user) \n    if resolveAddress == nil {return []}\n    let address = resolveAddress!\n    let account=getAccount(address)\n\n    if account.balance == 0.0 {\n        return []\n    }\n\n    let leaseCap = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\n    let leases=leaseCap.borrow()?.getLeaseInformation() ?? []\n\n    var leasesWithBids :[FIND.LeaseInformation] =[]\n    for lease in leases {\n        if lease.latestBidBy != nil {\n            leasesWithBids.append(lease)\n        }\n    }\n\n    return leasesWithBids\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "getNamesWithoutBids": {
               "code": "import FIND from 0x35717efbbce11c74\n\n\npub fun main(user: String) : [String] {\n\n    let resolveAddress = FIND.resolve(user) \n    if resolveAddress == nil {return []}\n    let address = resolveAddress!\n    let account=getAccount(address)\n\n    if account.balance == 0.0 {\n        return []\n    }\n\n    let leaseCap = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\n    let leases=leaseCap.borrow()?.getLeaseInformation() ?? []\n\n    var leasesWithBids :[String] =[]\n    for lease in leases {\n        if lease.latestBidBy == nil {\n            leasesWithBids.append(lease.name)\n        }\n    }\n\n    return leasesWithBids\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "getOwnedFindThoughts": {
               "code": "import FindThoughts from 0x35717efbbce11c74\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FindViews from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\nimport Profile from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\n\npub fun main(address: Address) : [Thought] {\n    let thoughts : [Thought] = [] \n\n\n        let account = getAccount(address) \n        let cap = account.getCapability\u003c\u0026{FindThoughts.CollectionPublic}\u003e(FindThoughts.CollectionPublicPath) \n        if !cap.check() {\n            return []\n        }\n        let ref = cap.borrow()! \n        for id in ref.getIDs() {\n            let t = ref.borrowThoughtPublic(id) \n            thoughts.append(getThought(t, withQuote: true))\n        }\n    \n    return thoughts\n}\n\npub struct User {\n    pub var name: String?\n    pub let address: Address \n    pub let findName: String? \n    pub var avatar: String? \n    pub let reaction: String\n\n    init(address: Address, reaction: String){\n        self.name = nil\n        self.findName = FIND.reverseLookup(address)\n        self.avatar = nil\n        self.reaction = reaction\n        self.address = address \n        let profileCap = getAccount(address).getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if profileCap.check() {\n            let p = profileCap.borrow()!\n            self.name = p.getName()\n            self.avatar = p.getAvatar()\n        }    \n    }\n}\n\npub struct Thought {\n    pub let id: UInt64 \n    pub let creator: Address \n    pub let creatorName: String? \n    pub var creatorProfileName: String? \n    pub var creatorAvatar: String? \n    pub var header: String?\n    pub var body: String?\n    pub let created: UFix64? \n    pub var lastUpdated: UFix64?\n    pub let medias: {String : String}\n    pub let nft: [FindMarket.NFTInfo]\n    pub var tags: [String]\n    pub var reacted: {String : [User]}\n    pub var reactions: {String : Int}\n    pub var reactedUsers: {String : [String]}\n    pub var quotedThought: Thought?\n    pub var hidden: Bool?\n\n    init(id: UInt64 , creator: Address , creatorName: String? , creatorProfileName: String? , creatorAvatar: String? , header: String? , body: String? , created: UFix64? , lastUpdated: UFix64?, medias: {String : String}, nft: [FindMarket.NFTInfo], tags: [String], reacted: {String : [User]}, reactions: {String : Int}, reactedUsers: {String : [String]}, quotedThought: Thought?, hidden: Bool?) {\n        self.id = id\n        self.creator = creator\n        self.creatorName = creatorName\n        self.creatorProfileName = creatorProfileName\n        self.creatorAvatar = creatorAvatar\n        self.header = header\n        self.body = body\n        self.created = created\n        self.lastUpdated = lastUpdated\n        self.medias = medias\n        self.nft = nft\n        self.tags = tags\n        self.reacted = reacted\n        self.reactions = reactions\n        self.reactedUsers = reactedUsers\n        self.quotedThought = quotedThought\n        self.hidden = hidden\n    }\n}\n\npub fun getThought(_ t: \u0026{FindThoughts.ThoughtPublic}, withQuote: Bool) : Thought {\n\n        var creatorProfileName : String? = nil\n        var creatorAvatar : String? = nil \n        let profileCap = getAccount(t.creator).getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if profileCap.check() {\n            creatorProfileName = profileCap.borrow()!.getName()\n            creatorAvatar = profileCap.borrow()!.getAvatar()\n        }\n\n        let medias : {String : String} = {}\n        for m in t.medias {\n            medias[m.file.uri()] = m.mediaType\n        }\n\n        let nft : [FindMarket.NFTInfo] = [] \n        for n in t.nft {\n            let vr = n.getViewResolver() \n            nft.append(FindMarket.NFTInfo(vr, id: n.id, detail: true))\n        }\n\n        let reacted : {String : [User]} = {}\n        let reactedUsers : {String :[String]} = {}\n        for user in t.reacted.keys {\n            let reaction = t.reacted[user]!\n            let allReacted = reacted[reaction] ?? []\n            let u = User(address: user, reaction: reaction)\n\n            allReacted.append(u)\n            reacted[reaction] = allReacted\n\n            let preReactedUser = reactedUsers[reaction] ?? []\n            preReactedUser.append(u.name ?? u.address.toString())\n            reactedUsers[reaction] = preReactedUser\n        }\n\n        var quotedThought : Thought? = nil \n        if withQuote {\n            if let p = t.getQuotedThought() {\n                if let ref = p.borrowThoughtPublic() {\n                    quotedThought = getThought(ref, withQuote: false)\n                } else {\n                    let creator = p.owner()\n                    var qCreatorProfileName : String? = nil\n                    var qCreatorAvatar : String? = nil \n                    let qProfileCap = getAccount(creator).getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n                    if qProfileCap.check() {\n                        qCreatorProfileName = qProfileCap.borrow()!.getName()\n                        qCreatorAvatar = qProfileCap.borrow()!.getAvatar()\n                    }\n\n                    quotedThought = Thought(\n                        id: p.id , \n                        creator: creator  , \n                        creatorName: FIND.reverseLookup(creator) , \n                        creatorProfileName: qCreatorProfileName , \n                        creatorAvatar: qCreatorAvatar, \n                        header: nil, \n                        body: nil , \n                        created: nil, \n                        lastUpdated: nil, \n                        medias: {}, \n                        nft: [], \n                        tags: [], \n                        reacted: {}, \n                        reactions: {}, \n                        reactedUsers: {},\n                        quotedThought: nil, \n                        hidden: false\n                    )    \n                }\n            }\n        }\n\n        return Thought(\n            id: t.id , \n            creator: t.creator  , \n            creatorName: FIND.reverseLookup(t.creator) , \n            creatorProfileName: creatorProfileName , \n            creatorAvatar: creatorAvatar, \n            header: t.header , \n            body: t.body , \n            created: t.created, \n            lastUpdated: t.lastUpdated, \n            medias: medias, \n            nft: nft, \n            tags: t.tags, \n            reacted: reacted, \n            reactions: t.reactions, \n            reactedUsers: reactedUsers,\n            quotedThought: quotedThought, \n            hidden: t.getHide()\n        )\n\n}",
               "spec": {
                  "order": [
                     "address"
                  ],
                  "parameters": {
                     "address": "Address"
                  }
               }
            },
            "getProfile": {
               "code": "import Profile from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\n\npub fun main(user: String) :  Profile.UserReport? {\n    let resolveAddress = FIND.resolve(user) \n    if resolveAddress == nil {return nil}\n    let address = resolveAddress!\n    let account = getAccount(address)\n    if account.balance == 0.0 {\n        return nil\n    }\n\n    var profileReport = account\n        .getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        .borrow()?.asReport()\n\n    if profileReport != nil \u0026\u0026 profileReport!.findName != FIND.reverseLookup(address) {\n        profileReport = Profile.UserReport(\n            findName: \"\",\n            address: profileReport!.address,\n            name: profileReport!.name,\n            gender: profileReport!.gender,\n            description: profileReport!.description,\n            tags: profileReport!.tags,\n            avatar: profileReport!.avatar,\n            links: profileReport!.links,\n            wallets: profileReport!.wallets, \n            following: profileReport!.following,\n            followers: profileReport!.followers,\n            allowStoringFollowers: profileReport!.allowStoringFollowers,\n            createdAt: profileReport!.createdAt\n        )\n    }\n\n    return profileReport\n\n\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "getRoyaltyChangedIds": {
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\n\npub fun main(marketplace: Address, user: String) : {String : [UInt64]} {\n    if let address = FIND.resolve(user){\n        return FindMarket.getRoyaltiesChangedIds(tenant:marketplace, address: address)\n    }\n    return {}\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "user"
                  ],
                  "parameters": {
                     "marketplace": "Address",
                     "user": "String"
                  }
               }
            },
            "getRoyaltyChangedItems": {
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\n\npub fun main(marketplace: Address, user: String) : {String : FindMarket.SaleItemCollectionReport} {\n    if let address = FIND.resolve(user){\n        return FindMarket.getRoyaltiesChangedItems(tenant:marketplace, address: address)\n    }\n    return {}\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "user"
                  ],
                  "parameters": {
                     "marketplace": "Address",
                     "user": "String"
                  }
               }
            },
            "getShardCollectionsNFTCatalog": {
               "code": "import NonFungibleToken from 0x631e88ae7f1d7c20\nimport FIND from 0x35717efbbce11c74\nimport FINDNFTCatalog from 0x35717efbbce11c74\n\npub fun main(user: String) : {String : CollectionLength} {\n\n    if let address = FIND.resolve(user) {\n\n        return getNFTIDs_Catalog(ownerAddress: address, cacheCollections: {})\n\n    }\n    return {}\n\n}\n\npub struct CollectionLength {\n    pub let shard : String \n    pub let length : Int \n    init(shard : String, length : Int ) {\n        self.shard=shard \n        self.length=length\n    }\n}\n\n// Helper function \n\npub fun resolveAddress(user: String) : Address? {\n    return FIND.resolve(user)\n}\n\npub fun getNFTIDs_Catalog(ownerAddress: Address, cacheCollections: {String:CollectionLength}) : {String:CollectionLength} {\n\n    let account = getAuthAccount(ownerAddress)\n\n    let types = FINDNFTCatalog.getCatalogTypeData()\n    for nftType in types.keys {\n\n        let typeData=types[nftType]!\n        let collectionKey=typeData.keys[0]\n        let catalogEntry = FINDNFTCatalog.getCatalogEntry(collectionIdentifier:collectionKey)!\n        let tempPathStr = \"catalog\".concat(collectionKey)\n        let tempPublicPath = PublicPath(identifier: tempPathStr)!\n        account.link\u003c\u0026NonFungibleToken.Collection\u003e(tempPublicPath, target: catalogEntry.collectionData.storagePath)\n        let cap= account.getCapability\u003c\u0026NonFungibleToken.Collection\u003e(tempPublicPath)\n        if cap.check(){\n            let collection = cap.borrow()!\n            let length = collection.ownedNFTs.length\n            if length == 0 {\n                continue\n            }\n            cacheCollections[collectionKey] = CollectionLength(shard: \"NFTCatalog\", length: length)\n        }\n    }\n    return cacheCollections\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "getSocksIDs": {
               "code": "import NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FIND from 0x35717efbbce11c74\n\n\npub fun main(user: String, collections: [String]) : {String : ItemReport} {\n    return {}\n}\n\n\n    pub struct ItemReport {\n        pub let length : Int // mapping of collection to no. of ids \n        pub let extraIDs : [UInt64]\n        pub let shard : String \n        pub let extraIDsIdentifier : String \n        pub let collectionName: String\n\n        init(length : Int, extraIDs :[UInt64] , shard: String, extraIDsIdentifier: String, collectionName: String) {\n            self.length=length \n            self.extraIDs=extraIDs\n            self.shard=shard\n            self.extraIDsIdentifier=extraIDsIdentifier\n            self.collectionName=collectionName\n        }\n    }",
               "spec": {
                  "order": [
                     "user",
                     "collections"
                  ],
                  "parameters": {
                     "collections": "[String]",
                     "user": "String"
                  }
               }
            },
            "getSocksItems": {
               "code": "import NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FIND from 0x35717efbbce11c74\n\npub fun main(user: String, collectionIDs: {String : [UInt64]}) : {String : [MetadataCollectionItem]} {\n\n    return {}\n}\n\npub struct CollectionReport {\n    pub let items : {String : [MetadataCollectionItem]} \n    pub let collections : {String : Int} // mapping of collection to no. of ids \n    pub let extraIDs : {String : [UInt64]} \n\n    init(items: {String : [MetadataCollectionItem]},  collections : {String : Int}, extraIDs : {String : [UInt64]} ) {\n        self.items=items \n        self.collections=collections \n        self.extraIDs=extraIDs\n    }\n}\n\npub struct MetadataCollectionItem {\n    pub let id:UInt64\n    pub let name: String\n    pub let collection: String // \u003c- This will be Alias unless they want something else\n    pub let subCollection: String? // \u003c- This will be Alias unless they want something else\n    pub let nftDetailIdentifier: String\n\n    pub let media  : String\n    pub let mediaType : String \n    pub let source : String \n\n    init(id:UInt64, name: String, collection: String, subCollection: String?, media  : String, mediaType : String, source : String, nftDetailIdentifier: String) {\n        self.id=id\n        self.name=name \n        self.collection=collection \n        self.subCollection=subCollection \n        self.media=media \n        self.mediaType=mediaType \n        self.source=source\n        self.nftDetailIdentifier=nftDetailIdentifier\n    }\n}\n\n// Helper function \n\npub fun resolveAddress(user: String) : PublicAccount? {\n    let address = FIND.resolve(user)\n    if address == nil {\n        return nil\n    }\n    return getAccount(address!)\n}",
               "spec": {
                  "order": [
                     "user",
                     "collectionIDs"
                  ],
                  "parameters": {
                     "collectionIDs": "{String: [UInt64]}",
                     "user": "String"
                  }
               }
            },
            "getStatus": {
               "code": "import FIND from 0x35717efbbce11c74\nimport Profile from 0x35717efbbce11c74\nimport FindRelatedAccounts from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\nimport FindLeaseMarket from 0x35717efbbce11c74\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport EmeraldIdentity from 0xfe433270356d985c\nimport EmeraldIdentityDapper from 0xc9d218cc626cd7f5\nimport EmeraldIdentityLilico from 0xc9d218cc626cd7f5\nimport TokenForwarding from 0x51ea0e37c27a1f1a\nimport FungibleToken from 0x9a0766d93b6608b7\nimport Wearables from 0x1e0493ee604e7598\n\npub struct FINDReport{\n    pub let isDapper: Bool\n    pub let profile:Profile.UserReport?\n    pub let bids: [FIND.BidInfo]\n\n    pub let leases: [FIND.LeaseInformation]\n    pub let privateMode: Bool\n    pub let leasesForSale: {String : FindLeaseMarket.SaleItemCollectionReport}\n    pub let leasesBids: {String : FindLeaseMarket.BidItemCollectionReport}\n    pub let itemsForSale: {String : FindMarket.SaleItemCollectionReport}\n    pub let marketBids: {String : FindMarket.BidItemCollectionReport}\n    pub let activatedAccount: Bool\n\n\n    // This is deprecating, moving to accounts\n    pub let relatedAccounts: { String: [Address]}\n\n     pub let lostAndFoundTypes: {String : String}\n    // This is deprecating, moving to accounts\n    // EmeraldID Account Linkage\n    pub let emeraldIDAccounts : {String : Address}\n\n    pub let accounts : [AccountInformation]?\n\n    pub let readyForWearables : Bool?\n\n    init(profile: Profile.UserReport?,\n         relatedAccounts: {String: [Address]},\n         bids: [FIND.BidInfo],\n         leases : [FIND.LeaseInformation],\n         privateMode: Bool,\n         leasesForSale: {String : FindLeaseMarket.SaleItemCollectionReport},\n         leasesBids: {String : FindLeaseMarket.BidItemCollectionReport},\n         itemsForSale: {String : FindMarket.SaleItemCollectionReport},\n         marketBids: {String : FindMarket.BidItemCollectionReport},\n         activatedAccount: Bool,\n         emeraldIDAccounts : {String : Address},\n         isDapper: Bool,\n         accounts: [AccountInformation]?,\n         readyForWearables: Bool?\n         ) {\n\n      self.lostAndFoundTypes={}\n        self.profile=profile\n        self.bids=bids\n        self.leases=leases\n        self.relatedAccounts=relatedAccounts\n        self.privateMode=privateMode\n        self.leasesForSale=leasesForSale\n        self.leasesBids=leasesBids\n        self.itemsForSale=itemsForSale\n        self.marketBids=marketBids\n        self.activatedAccount=activatedAccount\n        self.emeraldIDAccounts=emeraldIDAccounts\n        self.isDapper=isDapper\n        self.accounts=accounts\n        self.readyForWearables=readyForWearables\n    }\n}\n\npub struct AccountInformation {\n    pub let name: String\n    pub let address: String\n    pub let network: String\n    pub let trusted: Bool\n    pub let node: String\n\n    init(name: String, address: String, network: String, trusted: Bool, node: String) {\n        self.name = name\n        self.address = address\n        self.network = network\n        self.trusted = trusted\n        self.node = node\n    }\n}\n\npub struct NameReport {\n    pub let status: String\n    pub let cost: UFix64\n    pub let owner: Address?\n    pub let validUntil: UFix64?\n    pub let lockedUntil: UFix64?\n    pub let registeredTime: UFix64?\n\n    init(status: String, cost: UFix64, owner: Address?, validUntil: UFix64?, lockedUntil: UFix64?, registeredTime: UFix64? ) {\n        self.status=status\n        self.cost=cost\n        self.owner=owner\n        self.validUntil=validUntil\n        self.lockedUntil=lockedUntil\n        self.registeredTime=registeredTime\n    }\n}\n\npub struct Report {\n    pub let FINDReport: FINDReport?\n    pub let NameReport: NameReport?\n\n    init(FINDReport: FINDReport?, NameReport: NameReport?) {\n        self.FINDReport=FINDReport\n        self.NameReport=NameReport\n    }\n}\n\npub fun main(user: String) : Report? {\n\n    var findReport: FINDReport? = nil\n    if let address=FIND.resolve(user) {\n        let account=getAccount(address)\n        if account.balance \u003e 0.0 {\n\n            var isDapper=false\n            if let receiver =account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver).borrow() {\n                 isDapper=receiver.isInstance(Type\u003c@TokenForwarding.Forwarder\u003e())\n            } else {\n                if let duc = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver).borrow() {\n                    isDapper = duc.isInstance(Type\u003c@TokenForwarding.Forwarder\u003e())\n                } else {\n                    isDapper = false\n                }\n            }\n\n            let bidCap = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n            let leaseCap = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n            let profile=account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath).borrow()\n\n            let find= FindMarket.getFindTenantAddress()\n            var items : {String : FindMarket.SaleItemCollectionReport} = FindMarket.getSaleItemReport(tenant:find, address: address, getNFTInfo:true)\n\n            var marketBids : {String : FindMarket.BidItemCollectionReport} = FindMarket.getBidsReport(tenant:find, address: address, getNFTInfo:true)\n\n            let leasesSale : {String : FindLeaseMarket.SaleItemCollectionReport} = FindLeaseMarket.getSaleItemReport(tenant:find, address: address, getLeaseInfo:true)\n\n            let leasesBids : {String : FindLeaseMarket.BidItemCollectionReport} = FindLeaseMarket.getBidsReport(tenant:find, address: address, getLeaseInfo:true)\n\n            var profileReport = profile?.asReport()\n            if profileReport != nil \u0026\u0026 profileReport!.findName != FIND.reverseLookup(address) {\n                profileReport = Profile.UserReport(\n                    findName: \"\",\n                    address: profileReport!.address,\n                    name: profileReport!.name,\n                    gender: profileReport!.gender,\n                    description: profileReport!.description,\n                    tags: profileReport!.tags,\n                    avatar: profileReport!.avatar,\n                    links: profileReport!.links,\n                    wallets: profileReport!.wallets,\n                    following: profileReport!.following,\n                    followers: profileReport!.followers,\n                    allowStoringFollowers: profileReport!.allowStoringFollowers,\n                    createdAt: profileReport!.createdAt\n                )\n            }\n\n            /*\n            // NFTCatalog Output\n            let nftCatalogTypes = FINDNFTCatalog.getCatalogTypeData()\n            let types : {String : NFTCatalog.NFTCollectionData} = {}\n            for type in FindLostAndFoundWrapper.getSpecificRedeemableTypes(user: address, specificType: Type\u003c@NonFungibleToken.NFT\u003e()) {\n                types[type.identifier] = FINDNFTCatalog.getCollectionDataForType(nftTypeIdentifier: type.identifier)\n            }\n            */\n\n            let discordID = EmeraldIdentity.getDiscordFromAccount(account: address)\n                                    ?? EmeraldIdentityDapper.getDiscordFromAccount(account: address)\n                                    ?? EmeraldIdentityLilico.getDiscordFromAccount(account: address)\n                                    ?? \"\"\n\n            let emeraldIDAccounts : {String : Address} = {}\n            emeraldIDAccounts[\"blocto\"] = EmeraldIdentity.getAccountFromDiscord(discordID: discordID)\n            emeraldIDAccounts[\"lilico\"] = EmeraldIdentityLilico.getAccountFromDiscord(discordID: discordID)\n            emeraldIDAccounts[\"dapper\"] = EmeraldIdentityDapper.getAccountFromDiscord(discordID: discordID)\n\n            let accounts : [AccountInformation] = []\n            for wallet in [\"blocto\", \"lilico\", \"dapper\"] {\n                if let w = emeraldIDAccounts[wallet] {\n                    accounts.append(\n                        AccountInformation(\n                            name: wallet,\n                            address: w.toString(),\n                            network: \"Flow\",\n                            trusted: true,\n                            node: \"EmeraldID\")\n                    )\n                }\n            }\n\n            let allAcctsCap = FindRelatedAccounts.getCapability(address)\n            if allAcctsCap.check() {\n                let allAcctsRef = allAcctsCap.borrow()!\n                let allAccts = allAcctsRef.getAllRelatedAccountInfo()\n                for acct in allAccts.values {\n                    // We only verify flow accounts that are mutually linked\n                    var trusted = false\n                    if acct.address != nil {\n                        trusted = allAcctsRef.linked(name: acct.name, network: acct.network, address: acct.address!)\n                    }\n                    accounts.append(\n                        AccountInformation(\n                            name: acct.name,\n                            address: acct.stringAddress!,\n                            network: acct.network,\n                            trusted: trusted,\n                            node: \"FindRelatedAccounts\")\n                    )\n                }\n            }\n\n            let wearableAccount = getAuthAccount(address)\n            var readyForWearables = true\n            let wearablesRef= wearableAccount.borrow\u003c\u0026Wearables.Collection\u003e(from: Wearables.CollectionStoragePath)\n            if wearablesRef == nil {\n                readyForWearables = false\n            }\n\n            let wearablesCap= wearableAccount.getCapability\u003c\u0026Wearables.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(Wearables.CollectionPublicPath)\n            if !wearablesCap.check() {\n                readyForWearables = false\n            }\n\n            let wearablesProviderCap= wearableAccount.getCapability\u003c\u0026Wearables.Collection{NonFungibleToken.Provider,NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(Wearables.CollectionPrivatePath)\n            if !wearablesCap.check() {\n                readyForWearables = false\n            }\n\n            findReport = FINDReport(\n                profile: profileReport,\n                relatedAccounts: FindRelatedAccounts.findRelatedFlowAccounts(address:address),\n                bids: bidCap.borrow()?.getBids() ?? [],\n                leases: leaseCap.borrow()?.getLeaseInformation() ?? [],\n                privateMode: profile?.isPrivateModeEnabled() ?? false,\n                leasesForSale: leasesSale,\n                leasesBids: leasesBids,\n                itemsForSale: items,\n                marketBids: marketBids,\n                activatedAccount: true,\n                emeraldIDAccounts: emeraldIDAccounts,\n                isDapper:isDapper,\n                accounts: accounts,\n                readyForWearables: readyForWearables\n            )\n        } else {\n            findReport = FINDReport(\n                profile: nil,\n                relatedAccounts: {},\n                bids: [],\n                leases: [],\n                privateMode: false,\n                leasesForSale: {},\n                leasesBids: {},\n                itemsForSale: {},\n                marketBids: {},\n                activatedAccount: false,\n                emeraldIDAccounts: {},\n                isDapper: false,\n                accounts: nil,\n                readyForWearables: nil\n            )\n        }\n    }\n\n    var nameReport : NameReport? = nil\n    if FIND.validateFindName(user) {\n        let status = FIND.status(user)\n        let cost=FIND.calculateCost(user)\n        var s=\"TAKEN\"\n        if status.status == FIND.LeaseStatus.FREE {\n            s=\"FREE\"\n        } else if status.status == FIND.LeaseStatus.LOCKED {\n            s=\"LOCKED\"\n        }\n        let findAddr = FIND.getFindNetworkAddress()\n        let network = getAuthAccount(findAddr).borrow\u003c\u0026FIND.Network\u003e(from: FIND.NetworkStoragePath)!\n        let lease =  network.getLease(user)\n        nameReport = NameReport(status: s, cost: cost, owner: lease?.profile?.address, validUntil: lease?.validUntil, lockedUntil: lease?.lockedUntil, registeredTime: lease?.registeredTime)\n    }\n\n\n    return Report(FINDReport: findReport, NameReport: nameReport)\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "getStatusLostAndFound": {
               "code": "import FIND from 0x35717efbbce11c74\nimport FINDNFTCatalog from 0x35717efbbce11c74\nimport FindLostAndFoundWrapper from 0x35717efbbce11c74\nimport NFTCatalog from 0x324c34e1c517e4db\nimport NonFungibleToken from 0x631e88ae7f1d7c20\n\npub fun main(user: String) :  {String : NFTCatalog.NFTCollectionData} {\n    let lostAndFoundTypes: {String : NFTCatalog.NFTCollectionData}={}\n\n    if let address=FIND.resolve(user) {\n        let account=getAccount(address)\n        if account.balance \u003e 0.0 {\n            // NFTCatalog Output\n            let nftCatalogTypes = FINDNFTCatalog.getCatalogTypeData()\n            let types : {String : NFTCatalog.NFTCollectionData} = {}\n            for type in FindLostAndFoundWrapper.getSpecificRedeemableTypes(user: address, specificType: Type\u003c@NonFungibleToken.NFT\u003e()) {\n                types[type.identifier] = FINDNFTCatalog.getCollectionDataForType(nftTypeIdentifier: type.identifier)\n            }\n        }\n    }\n    return lostAndFoundTypes\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "getTenantSaleItem": {
               "code": "import FindMarket from 0x35717efbbce11c74\n\npub fun main(tenant: Address) : TenantSaleItems {\n    let tenantCap = FindMarket.getTenantCapability(tenant) ?? panic(\"No tenant capability is set up. Tenant Address : \".concat(tenant.toString()))\n    let tenantRef = tenantCap.borrow() ?? panic(\"Cannot borrow tenant reference. Tenant Address : \".concat(tenant.toString()))\n    let saleItems = tenantRef.getSaleItems()\n    return TenantSaleItems(findSaleItems: saleItems[\"findSaleItems\"]! ,\n                           tenantSaleItems: saleItems[\"tenantSaleItems\"]! ,\n                           findCuts: saleItems[\"findCuts\"]! )\n\n}\n\npub struct TenantSaleItems {\n    pub let findSaleItems : {String : FindMarket.TenantSaleItem}\n    pub let tenantSaleItems : {String : FindMarket.TenantSaleItem}\n    pub let findCuts : {String : FindMarket.TenantSaleItem} \n\n    init(findSaleItems : {String : FindMarket.TenantSaleItem}, \n         tenantSaleItems : {String : FindMarket.TenantSaleItem},\n         findCuts : {String : FindMarket.TenantSaleItem}) {\n             self.findSaleItems = findSaleItems\n             self.tenantSaleItems = tenantSaleItems \n             self.findCuts = findCuts \n         }\n}",
               "spec": {
                  "order": [
                     "tenant"
                  ],
                  "parameters": {
                     "tenant": "Address"
                  }
               }
            },
            "hasCharity": {
               "code": "import CharityNFT from 0x35717efbbce11c74\n\npub fun main(user: Address) : Bool {\n    let account=getAccount(user)\n    if account.balance == 0.0 {\n        return false\n    }\n    let charityCap = account.getCapability\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection)\n    return charityCap.check()\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "Address"
                  }
               }
            },
            "isFindUser": {
               "code": "import Profile from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\n\npub fun main(user: Address) : Bool {\n\n    let account=getAccount(user)\n    if account.balance == 0.0 {\n        return false\n    }\n    let leaseCap=account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n    let profileCap=account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\n    return leaseCap.check() \u0026\u0026 profileCap.check()\n\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "Address"
                  }
               }
            },
            "resolve": {
               "code": "import FIND from 0x35717efbbce11c74\n\npub fun main(name:String) : Address?{\n\n    return FIND.resolve(name)\n\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "reverseLookup": {
               "code": "import FIND from 0x35717efbbce11c74\n\npub fun main(addr:Address) : String?{\n\n    return FIND.reverseLookup(addr)\n\n}",
               "spec": {
                  "order": [
                     "addr"
                  ],
                  "parameters": {
                     "addr": "Address"
                  }
               }
            },
            "sendNFTs": {
               "code": "import NonFungibleToken from 0x631e88ae7f1d7c20\nimport FungibleToken from 0x9a0766d93b6608b7\nimport TokenForwarding from 0x51ea0e37c27a1f1a\nimport FlowToken from 0x7e60df042a9c0868\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport NFTCatalog from 0x324c34e1c517e4db\nimport FINDNFTCatalog from 0x35717efbbce11c74\nimport Profile from 0x35717efbbce11c74\nimport FindViews from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\nimport FindAirdropper from 0x35717efbbce11c74\nimport FindUtils from 0x35717efbbce11c74\n\npub fun main(sender: Address, nftIdentifiers: [String],  allReceivers:[String] , ids: [UInt64], memos: [String]) : [Report] {\n\n     fun logErr(_ i: Int , err: String) : Report {\n        return Report(receiver: allReceivers[i] , address: nil, inputName: nil, findName: nil, avatar: nil, isDapper: nil, type: nftIdentifiers[i], id: ids[i] , message: memos[i] ,receiverLinked: nil , collectionPublicLinked: nil , accountInitialized: nil , nftInPlace: nil, royalties: nil, err: err)\n    }\n\n        let paths : [PublicPath] = []\n        let contractData : {Type : NFTCatalog.NFTCatalogMetadata} = {}\n        let addresses : {String : Address} = {}\n\n        let account = getAuthAccount(sender)\n        let report : [Report] = []\n        for i , typeIdentifier in nftIdentifiers {\n            let checkType = CompositeType(typeIdentifier)\n            if checkType == nil {\n                report.append(logErr(i, err: \"Cannot refer to type with identifier : \".concat(typeIdentifier)))\n                continue\n            }\n            let type = checkType!\n\n            var data : NFTCatalog.NFTCatalogMetadata? = contractData[type]\n            if data == nil {\n                let checkData = FINDNFTCatalog.getMetadataFromType(type)\n                if checkData == nil {\n                    report.append(logErr(i, err: \"NFT Type is not supported by NFT Catalog. Type : \".concat(type.identifier)))\n                    continue\n                }\n                contractData[type] = checkData!\n                data = checkData!\n            }\n\n            let path = data!.collectionData\n\n            let checkCol = account.borrow\u003c\u0026NonFungibleToken.Collection\u003e(from: path.storagePath)\n            if checkCol == nil {\n                report.append(logErr(i, err: \"Cannot borrow collection from sender. Type : \".concat(type.identifier)))\n                continue\n            }\n            let ownedNFTs : \u0026{UInt64 : NonFungibleToken.NFT} = \u0026checkCol!.ownedNFTs as \u0026{UInt64 : NonFungibleToken.NFT}\n            let owned = ownedNFTs.containsKey(ids[i])\n\n            let receiver = allReceivers[i]\n            let id = ids[i]\n            let message = memos[i]\n\n            var user = addresses[receiver]\n            if user == nil {\n                let checkUser = FIND.resolve(receiver)\n                if checkUser == nil {\n                    report.append(logErr(i, err: \"Cannot resolve user with name / address : \".concat(receiver)))\n                    continue\n                }\n                addresses[receiver] = checkUser!\n                user = checkUser!\n            }\n            let checkAcct = getAccount(user!)\n            if checkAcct.balance == 0.0 {\n                report.append(logErr(i, err: \"Account is not an activated account\"))\n                continue\n            }\n\n\n            var isDapper=false\n            if let receiver =getAccount(user!).getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver).borrow() {\n                 isDapper=receiver.isInstance(Type\u003c@TokenForwarding.Forwarder\u003e())\n            } else {\n                if let duc = getAccount(user!).getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver).borrow() {\n                    isDapper = duc.isInstance(Type\u003c@TokenForwarding.Forwarder\u003e())\n                }\n            }\n\n            // check receiver account storage\n            let receiverCap = getAccount(user!).getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(path.publicPath)\n            let collectionPublicCap = getAccount(user!).getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(path.publicPath)\n            let storage = getAuthAccount(user!).type(at: path.storagePath)\n\n            var storageInited = false\n            if storage != nil \u0026\u0026 checkSameContract(collection: storage!, nft: type){\n                storageInited = true\n            }\n\n            var royalties : Royalties? = nil\n            let mv = account.borrow\u003c\u0026{MetadataViews.ResolverCollection}\u003e(from: path.storagePath)\n            if mv != nil {\n                let rv = mv!.borrowViewResolver(id: id)\n                if let r = MetadataViews.getRoyalties(rv) {\n                    royalties = Royalties(r)\n                }\n            }\n\n            var inputName : String? = receiver\n            var findName : String? = FIND.reverseLookup(user!)\n            if FindUtils.hasPrefix(receiver, prefix: \"0x\") {\n                inputName = nil\n            }\n\n            var avatar : String? = nil\n            if let profile = getAccount(user!).getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath).borrow() {\n                avatar = profile.getAvatar()\n            }\n\n            let r = Report(receiver: allReceivers[i] , address: user, inputName: inputName, findName: findName, avatar: avatar, isDapper: isDapper, type: nftIdentifiers[i], id: ids[i] , message: memos[i] ,receiverLinked: receiverCap.check() , collectionPublicLinked: collectionPublicCap.check() , accountInitialized: storageInited , nftInPlace: owned, royalties:royalties, err: nil)\n            report.append(r)\n        }\n\n    return report\n}\n\n\npub struct Report {\n    pub let receiver: String\n    pub let address: Address?\n    pub let inputName: String?\n    pub let findName: String?\n    pub let avatar: String?\n    pub let isDapper: Bool?\n    pub let type: String\n    pub let id: UInt64\n    pub let message: String\n    pub var ok: Bool\n    pub let receiverLinked: Bool?\n    pub let collectionPublicLinked: Bool?\n    pub let accountInitialized: Bool?\n    pub let nftInPlace: Bool?\n    pub let royalties: Royalties?\n    pub let err: String?\n\n    init(receiver: String , address: Address?, inputName: String?, findName: String?, avatar: String?, isDapper: Bool? , type: String, id: UInt64 , message: String ,receiverLinked: Bool? , collectionPublicLinked: Bool? , accountInitialized: Bool? , nftInPlace: Bool?, royalties: Royalties?, err: String?) {\n        self.receiver=receiver\n        self.address=address\n        self.inputName=inputName\n        self.findName=findName\n        self.avatar=avatar\n        self.isDapper=isDapper\n        self.type=type\n        self.id=id\n        self.message=message\n        self.receiverLinked=receiverLinked\n        self.collectionPublicLinked=collectionPublicLinked\n        self.accountInitialized=accountInitialized\n        self.nftInPlace=nftInPlace\n        self.err=err\n        self.royalties=royalties\n        self.ok = false\n        if accountInitialized == true \u0026\u0026 nftInPlace == true {\n            if receiverLinked == true || collectionPublicLinked == true {\n                self.ok = true\n            }\n        }\n    }\n}\n\npub struct Royalties {\n    pub let totalRoyalty: UFix64\n    pub let royalties: [Royalty]\n\n    init(_ royalties: MetadataViews.Royalties) {\n        var totalR = 0.0\n        let array : [Royalty] = []\n        for r in royalties.getRoyalties() {\n            array.append(Royalty(r))\n            totalR = totalR + r.cut\n        }\n        self.totalRoyalty = totalR\n        self.royalties = array\n    }\n}\n\npub struct Royalty {\n    pub let name: String?\n    pub let address: Address\n    pub let cut: UFix64\n    pub let acceptTypes: [String]\n    pub let description: String\n\n    init(_ r: MetadataViews.Royalty) {\n        self.name = FIND.reverseLookup(r.receiver.address)\n        self.address = r.receiver.address\n        self.cut = r.cut\n        self.description = r.description\n        let acceptTypes : [String] = []\n        if r.receiver.check() {\n            let ref = r.receiver.borrow()!\n            let t = ref.getType()\n            if t.isInstance(Type\u003c@FungibleToken.Vault\u003e()) {\n                acceptTypes.append(t.identifier)\n            } else if t == Type\u003c@TokenForwarding.Forwarder\u003e() {\n                acceptTypes.append(Type\u003c@FlowToken.Vault\u003e().identifier)\n            } else if t == Type\u003c@Profile.User\u003e() {\n                let ref = getAccount(r.receiver.address).getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath).borrow()!\n                let wallets = ref.getWallets()\n                for w in wallets {\n                    acceptTypes.append(w.accept.identifier)\n                }\n            }\n        }\n        self.acceptTypes = acceptTypes\n    }\n}\n\npub fun checkSameContract(collection: Type, nft: Type) : Bool {\n    let colType = collection.identifier\n    let croppedCol = colType.slice(from: 0 , upTo : colType.length - \"collection\".length)\n    let nftType = nft.identifier\n    let croppedNft = nftType.slice(from: 0 , upTo : nftType.length - \"nft\".length)\n    if croppedCol == croppedNft {\n        return true\n    }\n    return false\n}",
               "spec": {
                  "order": [
                     "sender",
                     "nftIdentifiers",
                     "allReceivers",
                     "ids",
                     "memos"
                  ],
                  "parameters": {
                     "allReceivers": "[String]",
                     "ids": "[UInt64]",
                     "memos": "[String]",
                     "nftIdentifiers": "[String]",
                     "sender": "Address"
                  }
               }
            }
         },
         "transactions": {
            "acceptDirectOfferSoft": {
               "code": "import FindMarketDirectOfferSoft from 0x35717efbbce11c74\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FindViews from 0x35717efbbce11c74\nimport FINDNFTCatalog from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\n\ntransaction(marketplace:Address, id: UInt64) {\n\n    let market : \u0026FindMarketDirectOfferSoft.SaleItemCollection\n    let pointer : FindViews.AuthNFTPointer\n\n    prepare(account: AuthAccount) {\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e())\n        self.market = account.borrow\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection\u003e(from: storagePath)!\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e())\n        let item = FindMarket.assertOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: id)\n        let nftIdentifier = item.getItemType().identifier\n\n        //If this is nil, there must be something wrong with FIND setup\n        // let privatePath = getPrivatePath(nftIdentifier)\n\n        let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier)) \n        let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n        let privatePath = collection.collectionData.privatePath\n\n\n        let providerCap=account.getCapability\u003c\u0026{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e(privatePath)\n        self.pointer= FindViews.AuthNFTPointer(cap: providerCap, id: item.getItemID())\n    }\n\n    execute {\n        self.market.acceptOffer(self.pointer)\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "acceptDirectOfferSoftDapper": {
               "code": "import FindMarketDirectOfferSoft from 0x35717efbbce11c74\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FindViews from 0x35717efbbce11c74\nimport NFTCatalog from 0x324c34e1c517e4db\nimport FINDNFTCatalog from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\n\ntransaction(marketplace:Address, id: UInt64) {\n\n    let market : \u0026FindMarketDirectOfferSoft.SaleItemCollection\n    let pointer : FindViews.AuthNFTPointer\n\n    prepare(account: AuthAccount) {\n\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e())\n        self.market = account.borrow\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection\u003e(from: storagePath)!\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e())\n        let item = FindMarket.assertOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: id)\n        let nftIdentifier = item.getItemType().identifier\n\n        let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier)) \n        let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n        let nft = collection.collectionData\n\n        let providerCap=account.getCapability\u003c\u0026{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e(nft.privatePath)\n        self.pointer= FindViews.AuthNFTPointer(cap: providerCap, id: item.getItemID())\n\n    }\n\n    execute {\n        self.market.acceptOffer(self.pointer)\n    }\n    \n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "acceptLeaseDirectOfferSoft": {
               "code": "import FindLeaseMarketDirectOfferSoft from 0x35717efbbce11c74\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FindViews from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\nimport FindLeaseMarket from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\n\ntransaction(leaseName: String) {\n\n    let market : \u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection\n    let pointer : FindLeaseMarket.AuthLeasePointer\n\n    prepare(account: AuthAccount) {\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e())\n        self.market = account.borrow\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(from: storagePath)!\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e())\n        let item = FindLeaseMarket.assertOperationValid(tenant: marketplace, name: leaseName, marketOption: marketOption)\n        let ref = account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from: FIND.LeaseStoragePath) ?? panic(\"Cannot borrow reference to find lease collection. Account : \".concat(account.address.toString()))\n        self.pointer= FindLeaseMarket.AuthLeasePointer(ref: ref, name: leaseName)\n    }\n\n    execute {\n        self.market.acceptOffer(self.pointer)\n    }\n}",
               "spec": {
                  "order": [
                     "leaseName"
                  ],
                  "parameters": {
                     "leaseName": "String"
                  }
               }
            },
            "acceptLeaseDirectOfferSoftDapper": {
               "code": "import FindLeaseMarketDirectOfferSoft from 0x35717efbbce11c74\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FindViews from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\nimport FindLeaseMarket from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FIND from 0x35717efbbce11c74\n\ntransaction(leaseName: String) {\n\n    let market : \u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection\n    let pointer : FindLeaseMarket.AuthLeasePointer\n\n    prepare(account: AuthAccount) {\n\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e())\n        self.market = account.borrow\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(from: storagePath)!\n\n        let ref = account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from: FIND.LeaseStoragePath) ?? panic(\"Cannot borrow reference to Find lease collection. Account : \".concat(account.address.toString()))\n        self.pointer= FindLeaseMarket.AuthLeasePointer(ref: ref, name: leaseName)\n\n    }\n\n    execute {\n        self.market.acceptOffer(self.pointer)\n    }\n\n}",
               "spec": {
                  "order": [
                     "leaseName"
                  ],
                  "parameters": {
                     "leaseName": "String"
                  }
               }
            },
            "acceptMultipleDirectOfferSoft": {
               "code": "import FindMarketDirectOfferSoft from 0x35717efbbce11c74\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FindViews from 0x35717efbbce11c74\nimport NFTCatalog from 0x324c34e1c517e4db\nimport FINDNFTCatalog from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\n\ntransaction(marketplace:Address, ids: [UInt64]) {\n\n    let market : \u0026FindMarketDirectOfferSoft.SaleItemCollection\n    let pointer : [FindViews.AuthNFTPointer]\n\n    prepare(account: AuthAccount) {\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e())\n        self.market = account.borrow\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection\u003e(from: storagePath)!\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e())\n\n        var counter = 0\n        self.pointer = []\n        let nfts : {String : NFTCatalog.NFTCollectionData} = {}\n\n        while counter \u003c ids.length {\n            let item = FindMarket.assertOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: ids[counter])\n            var nft : NFTCatalog.NFTCollectionData? = nil\n            let nftIdentifier = item.getItemType().identifier\n\n            if nfts[nftIdentifier] != nil {\n                nft = nfts[nftIdentifier]\n            } else {\n                // nft = getCollectionData(nftIdentifier) \n                let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier)) \n                let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n                nft = collection.collectionData\n                nfts[nftIdentifier] = nft\n            }\n\n            let providerCap=account.getCapability\u003c\u0026{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e(nft!.privatePath)\n            let pointer= FindViews.AuthNFTPointer(cap: providerCap, id: item.getItemID())\n            self.pointer.append(pointer)\n            counter = counter + 1\n        }\n    }\n\n    execute {\n        var counter = 0\n        while counter \u003c ids.length {\n            self.market.acceptOffer(self.pointer[counter])\n            counter = counter + 1\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "ids"
                  ],
                  "parameters": {
                     "ids": "[UInt64]",
                     "marketplace": "Address"
                  }
               }
            },
            "acceptMultipleDirectOfferSoftDapper": {
               "code": "import FindMarketDirectOfferSoft from 0x35717efbbce11c74\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FindViews from 0x35717efbbce11c74\nimport NFTCatalog from 0x324c34e1c517e4db\nimport FINDNFTCatalog from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\n\ntransaction(marketplace:Address, ids: [UInt64]) {\n\n    let market : \u0026FindMarketDirectOfferSoft.SaleItemCollection\n    let pointer : [FindViews.AuthNFTPointer]\n\n    prepare(account: AuthAccount) {\n\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e())\n        self.market = account.borrow\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection\u003e(from: storagePath)!\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e())\n\n        var counter = 0\n        self.pointer = []\n        let nfts : {String : NFTCatalog.NFTCollectionData} = {}\n\n        while counter \u003c ids.length {\n            let item = FindMarket.assertOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: ids[counter])\n            var nft : NFTCatalog.NFTCollectionData? = nil\n            let nftIdentifier = item.getItemType().identifier\n            let ftType = item.getFtType()\n\n            if nfts[nftIdentifier] != nil {\n                nft = nfts[nftIdentifier]\n            } else {\n                // nft = getCollectionData(nftIdentifier) \n                let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier)) \n                let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n                nft = collection.collectionData\n                nfts[nftIdentifier] = nft\n            }\n\n            let providerCap=account.getCapability\u003c\u0026{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e(nft!.privatePath)\n            let pointer= FindViews.AuthNFTPointer(cap: providerCap, id: item.getItemID())\n            self.pointer.append(pointer)\n            counter = counter + 1\n        }\n\n    }\n\n    execute {\n        var counter = 0\n        while counter \u003c ids.length {\n            self.market.acceptOffer(self.pointer[counter])\n            counter = counter + 1\n        }\n    }\n    \n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "ids"
                  ],
                  "parameters": {
                     "ids": "[UInt64]",
                     "marketplace": "Address"
                  }
               }
            },
            "addCuratedCollection": {
               "code": "transaction(name: String, items: [String]) {\n    prepare(account: AuthAccount) {\n\n        let path=/storage/FindCuratedCollections\n        let publicPath=/public/FindCuratedCollections\n\n        var collections : {String: [String]} = {}\n        if account.borrow\u003c\u0026{String: [String]}\u003e(from:path) != nil {\n             collections=account.load\u003c{String: [String]}\u003e(from:path)!\n        }\n        collections[name] = items\n        account.save(collections, to: path)\n        let link = account.getCapability\u003c\u0026{String: [String]}\u003e(publicPath)\n        if !link.check() {\n            account.link\u003c\u0026{String: [String]}\u003e( publicPath, target: path)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "items"
                  ],
                  "parameters": {
                     "items": "[String]",
                     "name": "String"
                  }
               }
            },
            "addRelatedAccount": {
               "code": "import FindRelatedAccounts from 0x35717efbbce11c74\n\ntransaction(name: String, network: String, address: String) {\n\n    var relatedAccounts : \u0026FindRelatedAccounts.Accounts?\n\n    prepare(account: AuthAccount) {\n\n        self.relatedAccounts= account.borrow\u003c\u0026FindRelatedAccounts.Accounts\u003e(from:FindRelatedAccounts.storagePath)\n        if self.relatedAccounts == nil {\n            let relatedAccounts \u003c- FindRelatedAccounts.createEmptyAccounts()\n            account.save(\u003c- relatedAccounts, to: FindRelatedAccounts.storagePath)\n            account.link\u003c\u0026FindRelatedAccounts.Accounts{FindRelatedAccounts.Public}\u003e(FindRelatedAccounts.publicPath, target: FindRelatedAccounts.storagePath)\n            self.relatedAccounts = account.borrow\u003c\u0026FindRelatedAccounts.Accounts\u003e(from:FindRelatedAccounts.storagePath)\n        }\n\n        let cap = account.getCapability\u003c\u0026FindRelatedAccounts.Accounts{FindRelatedAccounts.Public}\u003e(FindRelatedAccounts.publicPath)\n        if !cap.check() {\n            account.unlink(FindRelatedAccounts.publicPath)\n            account.link\u003c\u0026FindRelatedAccounts.Accounts{FindRelatedAccounts.Public}\u003e(FindRelatedAccounts.publicPath, target: FindRelatedAccounts.storagePath)\n        }\n    }\n\n    execute {\n        self.relatedAccounts!.addRelatedAccount(name:name, network:network, address: address)\n    }\n\n}",
               "spec": {
                  "order": [
                     "name",
                     "network",
                     "address"
                  ],
                  "parameters": {
                     "address": "String",
                     "name": "String",
                     "network": "String"
                  }
               }
            },
            "addRelatedFlowAccount": {
               "code": "import FindRelatedAccounts from 0x35717efbbce11c74\n\ntransaction(name: String, address: Address) {\n\n    var relatedAccounts : \u0026FindRelatedAccounts.Accounts?\n\n    prepare(account: AuthAccount) {\n\n        self.relatedAccounts= account.borrow\u003c\u0026FindRelatedAccounts.Accounts\u003e(from:FindRelatedAccounts.storagePath)\n        if self.relatedAccounts == nil {\n            let relatedAccounts \u003c- FindRelatedAccounts.createEmptyAccounts()\n            account.save(\u003c- relatedAccounts, to: FindRelatedAccounts.storagePath)\n            account.link\u003c\u0026FindRelatedAccounts.Accounts{FindRelatedAccounts.Public}\u003e(FindRelatedAccounts.publicPath, target: FindRelatedAccounts.storagePath)\n            self.relatedAccounts = account.borrow\u003c\u0026FindRelatedAccounts.Accounts\u003e(from:FindRelatedAccounts.storagePath)\n        }\n\n        let cap = account.getCapability\u003c\u0026FindRelatedAccounts.Accounts{FindRelatedAccounts.Public}\u003e(FindRelatedAccounts.publicPath)\n        if !cap.check() {\n            account.unlink(FindRelatedAccounts.publicPath)\n            account.link\u003c\u0026FindRelatedAccounts.Accounts{FindRelatedAccounts.Public}\u003e(FindRelatedAccounts.publicPath, target: FindRelatedAccounts.storagePath)\n        }\n    }\n\n    execute {\n        self.relatedAccounts!.addFlowAccount(name:name, address: address)\n    }\n\n}",
               "spec": {
                  "order": [
                     "name",
                     "address"
                  ],
                  "parameters": {
                     "address": "Address",
                     "name": "String"
                  }
               }
            },
            "alterMarketOption": {
               "code": "import FindMarket from 0x35717efbbce11c74\n\ntransaction(marketRule: String , action: String ){\n    prepare(account: AuthAccount){\n        let path = FindMarket.TenantClientStoragePath\n        let tenantRef = account.borrow\u003c\u0026FindMarket.TenantClient\u003e(from: path) ?? panic(\"Cannot borrow Reference.\")\n\n\n        switch action {\n            case \"enable\" :\n                tenantRef.enableMarketOption(marketRule)\n\n            case \"deprecate\" :\n                tenantRef.deprecateMarketOption(marketRule)\n\n            case \"stop\" :\n                tenantRef.stopMarketOption(marketRule)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "marketRule",
                     "action"
                  ],
                  "parameters": {
                     "action": "String",
                     "marketRule": "String"
                  }
               }
            },
            "bidLeaseMarketAuctionSoft": {
               "code": "import FungibleToken from 0x9a0766d93b6608b7\nimport Profile from 0x35717efbbce11c74\nimport FTRegistry from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\nimport FindLeaseMarket from 0x35717efbbce11c74\nimport FindLeaseMarketAuctionSoft from 0x35717efbbce11c74\n\ntransaction(leaseName: String, amount: UFix64) {\n\n    let saleItemsCap: Capability\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic}\u003e\n    let walletReference : \u0026FungibleToken.Vault\n    let bidsReference: \u0026FindLeaseMarketAuctionSoft.MarketBidCollection?\n    let balanceBeforeBid: UFix64\n    let ftVaultType: Type\n\n    prepare(account: AuthAccount) {\n\n        let resolveAddress = FIND.resolve(leaseName)\n        if resolveAddress == nil {panic(\"The address input is not a valid name nor address. Input : \".concat(leaseName))}\n        let address = resolveAddress!\n\n        let leaseMarketplace = FindMarket.getFindTenantAddress()\n        let leaseTenantCapability= FindMarket.getTenantCapability(leaseMarketplace)!\n        let leaseTenant = leaseTenantCapability.borrow()!\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let leaseASBidType= Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e()\n        let leaseASBidPublicPath=leaseTenant.getPublicPath(leaseASBidType)\n        let leaseASBidStoragePath= leaseTenant.getStoragePath(leaseASBidType)\n        let leaseASBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath)\n        if !leaseASBidCap.check() {\n            account.save\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseASBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath, target: leaseASBidStoragePath)\n        }\n\n        self.saleItemsCap= FindLeaseMarketAuctionSoft.getSaleItemCapability(marketplace:leaseMarketplace, user:address) ?? panic(\"cannot find sale item cap\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e())\n\n        let item = FindLeaseMarket.assertOperationValid(tenant: leaseMarketplace, name: leaseName, marketOption: marketOption)\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n\n        self.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account. Account address : \".concat(account.address.toString()))\n        self.ftVaultType = ft.type\n\n        let bidStoragePath=leaseTenant.getStoragePath(Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e())\n\n        self.bidsReference= account.borrow\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(from: bidStoragePath)\n        self.balanceBeforeBid=self.walletReference.balance\n    }\n\n    pre {\n        self.bidsReference != nil : \"This account does not have a bid collection\"\n        self.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n    }\n\n    execute {\n        self.bidsReference!.bid(name:leaseName, amount: amount, vaultType: self.ftVaultType, bidExtraField: {})\n    }\n}",
               "spec": {
                  "order": [
                     "leaseName",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "leaseName": "String"
                  }
               }
            },
            "bidLeaseMarketAuctionSoftDapper": {
               "code": "import Profile from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FTRegistry from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\nimport FindLeaseMarketAuctionSoft from 0x35717efbbce11c74\nimport FindLeaseMarket from 0x35717efbbce11c74\n\ntransaction(leaseName: String, amount: UFix64) {\n\n    let saleItemsCap: Capability\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic}\u003e\n    let bidsReference: \u0026FindLeaseMarketAuctionSoft.MarketBidCollection?\n    let ftVaultType: Type\n\n    prepare(account: AuthAccount) {\n\n        let resolveAddress = FIND.resolve(leaseName)\n        if resolveAddress == nil {panic(\"The address input is not a valid name nor address. Input : \".concat(leaseName))}\n        let address = resolveAddress!\n\n        let leaseMarketplace = FindMarket.getFindTenantAddress()\n        let leaseTenantCapability= FindMarket.getTenantCapability(leaseMarketplace)!\n        let leaseTenant = leaseTenantCapability.borrow()!\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let leaseASBidType= Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e()\n        let leaseASBidPublicPath=leaseTenant.getPublicPath(leaseASBidType)\n        let leaseASBidStoragePath= leaseTenant.getStoragePath(leaseASBidType)\n        let leaseASBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath)\n        if !leaseASBidCap.check() {\n            account.save\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseASBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath, target: leaseASBidStoragePath)\n        }\n\n        self.saleItemsCap= FindLeaseMarketAuctionSoft.getSaleItemCapability(marketplace:leaseMarketplace, user:address) ?? panic(\"cannot find sale item cap\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e())\n\n        let item = FindLeaseMarket.assertOperationValid(tenant: leaseMarketplace, name: leaseName, marketOption: marketOption)\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n\n        self.ftVaultType = ft.type\n\n        let bidStoragePath=leaseTenant.getStoragePath(Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e())\n\n        self.bidsReference= account.borrow\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(from: bidStoragePath)\n    }\n\n    pre {\n        self.bidsReference != nil : \"This account does not have a bid collection\"\n    }\n\n    execute {\n        self.bidsReference!.bid(name:leaseName, amount: amount, vaultType: self.ftVaultType, bidExtraField: {})\n    }\n}",
               "spec": {
                  "order": [
                     "leaseName",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "leaseName": "String"
                  }
               }
            },
            "bidLeaseMarketDirectOfferSoft": {
               "code": "import Profile from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FTRegistry from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\nimport FindLeaseMarket from 0x35717efbbce11c74\nimport FindLeaseMarketDirectOfferSoft from 0x35717efbbce11c74\n\ntransaction(leaseName: String, ftAliasOrIdentifier:String, amount: UFix64, validUntil: UFix64?) {\n\n    let bidsReference: \u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection?\n    let ftVaultType: Type\n\n    prepare(account: AuthAccount) {\n\n\n        let resolveAddress = FIND.resolve(leaseName)\n        if resolveAddress == nil {panic(\"The address input is not a valid name nor address. Input : \".concat(leaseName))}\n        let address = resolveAddress!\n\n        let ft = FTRegistry.getFTInfo(ftAliasOrIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftAliasOrIdentifier))\n\n        self.ftVaultType = ft.type\n\n        let walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n        assert(walletReference.balance \u003e amount , message: \"Bidder has to have enough balance in wallet\")\n\n        let leaseMarketplace = FindMarket.getFindTenantAddress()\n        let leaseTenantCapability= FindMarket.getTenantCapability(leaseMarketplace)!\n        let leaseTenant = leaseTenantCapability.borrow()!\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let leaseDOSBidType= Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let leaseDOSBidPublicPath=leaseTenant.getPublicPath(leaseDOSBidType)\n        let leaseDOSBidStoragePath= leaseTenant.getStoragePath(leaseDOSBidType)\n        let leaseDOSBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath)\n        if !leaseDOSBidCap.check() {\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOSBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath, target: leaseDOSBidStoragePath)\n        }\n\n        self.bidsReference= account.borrow\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(from: leaseDOSBidStoragePath)\n\n    }\n\n    pre {\n        self.bidsReference != nil : \"This account does not have a bid collection\"\n    }\n\n    execute {\n        self.bidsReference!.bid(name:leaseName, amount: amount, vaultType: self.ftVaultType, validUntil: validUntil, saleItemExtraField: {}, bidExtraField: {})\n    }\n}",
               "spec": {
                  "order": [
                     "leaseName",
                     "ftAliasOrIdentifier",
                     "amount",
                     "validUntil"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "ftAliasOrIdentifier": "String",
                     "leaseName": "String",
                     "validUntil": "UFix64?"
                  }
               }
            },
            "bidLeaseMarketDirectOfferSoftDapper": {
               "code": "import FungibleToken from 0x9a0766d93b6608b7\nimport Profile from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\nimport FTRegistry from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\nimport FindLeaseMarket from 0x35717efbbce11c74\nimport FindLeaseMarketDirectOfferSoft from 0x35717efbbce11c74\n\ntransaction(leaseName: String, ftAliasOrIdentifier:String, amount: UFix64, validUntil: UFix64?) {\n\n    let bidsReference: \u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection?\n    let ftVaultType: Type\n\n    prepare(account: AuthAccount) {\n\n        let ft = FTRegistry.getFTInfo(ftAliasOrIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftAliasOrIdentifier))\n\n        self.ftVaultType = ft.type\n\n        let leaseMarketplace = FindMarket.getFindTenantAddress()\n        let leaseTenantCapability= FindMarket.getTenantCapability(leaseMarketplace)!\n        let leaseTenant = leaseTenantCapability.borrow()!\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let leaseDOSBidType= Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let leaseDOSBidPublicPath=leaseTenant.getPublicPath(leaseDOSBidType)\n        let leaseDOSBidStoragePath= leaseTenant.getStoragePath(leaseDOSBidType)\n        let leaseDOSBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath)\n        if !leaseDOSBidCap.check() {\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOSBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath, target: leaseDOSBidStoragePath)\n        }\n\n        self.bidsReference= account.borrow\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(from: leaseDOSBidStoragePath)\n\n    }\n\n    pre {\n        self.bidsReference != nil : \"This account does not have a bid collection\"\n    }\n\n    execute {\n        self.bidsReference!.bid(name:leaseName, amount: amount, vaultType: self.ftVaultType, validUntil: validUntil, saleItemExtraField: {}, bidExtraField: {})\n    }\n}",
               "spec": {
                  "order": [
                     "leaseName",
                     "ftAliasOrIdentifier",
                     "amount",
                     "validUntil"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "ftAliasOrIdentifier": "String",
                     "leaseName": "String",
                     "validUntil": "UFix64?"
                  }
               }
            },
            "bidMarketAuctionEscrowed": {
               "code": "import FindMarketAuctionEscrow from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FindViews from 0x35717efbbce11c74\nimport FINDNFTCatalog from 0x35717efbbce11c74\nimport FTRegistry from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\nimport Profile from 0x35717efbbce11c74\n\ntransaction(marketplace:Address, user: String, id: UInt64, amount: UFix64) {\n\n    let saleItemsCap: Capability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic}\u003e \n    var targetCapability : Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e\n    let walletReference : \u0026FungibleToken.Vault\n    let bidsReference: \u0026FindMarketAuctionEscrow.MarketBidCollection?\n    let balanceBeforeBid: UFix64\n    let pointer: FindViews.ViewReadPointer\n\n    prepare(account: AuthAccount) {\n        let resolveAddress = FIND.resolve(user)\n        if resolveAddress == nil {panic(\"The address input is not a valid name nor address. Input : \".concat(user))}\n        let address = resolveAddress!\n\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n        let tenant = tenantCapability.borrow()!\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        /// auctions that escrow ft\n        let aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\n        let aeBidPublicPath=FindMarket.getPublicPath(aeBidType, name: tenant.name)\n        let aeBidStoragePath= FindMarket.getStoragePath(aeBidType, name:tenant.name)\n        let aeBidCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n        if !aeBidCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n        }\n\n        self.saleItemsCap= FindMarketAuctionEscrow.getSaleItemCapability(marketplace:marketplace, user:address) ?? panic(\"cannot find sale item cap. User address : \".concat(address.toString()))\n\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e())\n        let item = FindMarket.assertOperationValid(tenant: marketplace, address: address, marketOption: marketOption, id: id)\n\n        let nftIdentifier = item.getItemType().identifier\n        let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier)) \n        let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n        let nft = collection.collectionData\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n    \n        self.targetCapability= account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(nft.publicPath)\n        /* Check for nftCapability */\n        if !self.targetCapability.check() {\n            let cd = item.getNFTCollectionData()\n            // should use account.type here instead\n            if account.type(at: cd.storagePath) != nil {\n                let pathIdentifier = nft.publicPath.toString()\n                let findPath = PublicPath(identifier: pathIdentifier.slice(from: \"/public/\".length , upTo: pathIdentifier.length).concat(\"_FIND\"))!\n                account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                    findPath,\n                    target: nft.storagePath\n                )\n                self.targetCapability = account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(findPath)\n            } else {\n                account.save(\u003c- cd.createEmptyCollection(), to: cd.storagePath)\n                account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.publicPath, target: cd.storagePath)\n                account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.providerPath, target: cd.storagePath)\n            }\n\n        }\n        \n        self.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n        \n        let bidSstoragePath=tenant.getStoragePath(Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e())\n\n        self.bidsReference= account.borrow\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection\u003e(from: bidSstoragePath)\n        self.balanceBeforeBid=self.walletReference.balance\n        self.pointer= FindViews.createViewReadPointer(address: address, path:nft.publicPath, id: item.getItemID())\n    }\n\n    pre {\n        self.bidsReference != nil : \"This account does not have a bid collection\"\n        self.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount) \n        self.bidsReference!.bid(item:self.pointer, vault: \u003c- vault, nftCap: self.targetCapability, bidExtraField: {})\n    }\n\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "user",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64",
                     "marketplace": "Address",
                     "user": "String"
                  }
               }
            },
            "bidMarketAuctionSoft": {
               "code": "import FindMarketAuctionSoft from 0x35717efbbce11c74\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport FungibleToken from 0x9a0766d93b6608b7\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FindViews from 0x35717efbbce11c74\nimport FTRegistry from 0x35717efbbce11c74\nimport FINDNFTCatalog from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\nimport Profile from 0x35717efbbce11c74\n\ntransaction(marketplace:Address, user: String, id: UInt64, amount: UFix64) {\n\n    let saleItemsCap: Capability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic}\u003e \n    var targetCapability : Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e\n    let walletReference : \u0026FungibleToken.Vault\n    let bidsReference: \u0026FindMarketAuctionSoft.MarketBidCollection?\n    let balanceBeforeBid: UFix64\n    let pointer: FindViews.ViewReadPointer\n    let ftVaultType: Type\n\n    prepare(account: AuthAccount) {\n\n        let resolveAddress = FIND.resolve(user)\n        if resolveAddress == nil {panic(\"The address input is not a valid name nor address. Input : \".concat(user))}\n        let address = resolveAddress!\n\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n        let tenant = tenantCapability.borrow()!\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n        if !asBidCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n        }\n\n        self.saleItemsCap= FindMarketAuctionSoft.getSaleItemCapability(marketplace:marketplace, user:address) ?? panic(\"cannot find sale item cap\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e())\n\n        let item = FindMarket.assertOperationValid(tenant: marketplace, address: address, marketOption: marketOption, id: id)\n\n        let nftIdentifier = item.getItemType().identifier\n        let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier)) \n        let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n        let nft = collection.collectionData\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n    \n        self.targetCapability= account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(nft.publicPath)\n        /* Check for nftCapability */\n        if !self.targetCapability.check() {\n            let cd = item.getNFTCollectionData()\n            // should use account.type here instead\n            if account.type(at: cd.storagePath) != nil {\n                let pathIdentifier = nft.publicPath.toString()\n                let findPath = PublicPath(identifier: pathIdentifier.slice(from: \"/public/\".length , upTo: pathIdentifier.length).concat(\"_FIND\"))!\n                account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                    findPath,\n                    target: nft.storagePath\n                )\n                self.targetCapability = account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(findPath)\n            } else {\n                account.save(\u003c- cd.createEmptyCollection(), to: cd.storagePath)\n                account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.publicPath, target: cd.storagePath)\n                account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.providerPath, target: cd.storagePath)\n            }\n\n        }\n        \n        self.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account. Account address : \".concat(account.address.toString()))\n        self.ftVaultType = ft.type\n\n        let bidStoragePath=tenant.getStoragePath(Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e())\n\n        self.bidsReference= account.borrow\u003c\u0026FindMarketAuctionSoft.MarketBidCollection\u003e(from: bidStoragePath)\n        self.balanceBeforeBid=self.walletReference.balance\n        self.pointer= FindViews.createViewReadPointer(address: address, path:nft.publicPath, id: item.getItemID())\n    }\n\n    pre {\n        self.bidsReference != nil : \"This account does not have a bid collection\"\n        self.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n    }\n\n    execute {\n        self.bidsReference!.bid(item:self.pointer, amount: amount, vaultType: self.ftVaultType, nftCap: self.targetCapability, bidExtraField: {})\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "user",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64",
                     "marketplace": "Address",
                     "user": "String"
                  }
               }
            },
            "bidMarketAuctionSoftDapper": {
               "code": "import FindMarketAuctionSoft from 0x35717efbbce11c74\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport FungibleToken from 0x9a0766d93b6608b7\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FindViews from 0x35717efbbce11c74\nimport FTRegistry from 0x35717efbbce11c74\nimport FINDNFTCatalog from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\nimport Profile from 0x35717efbbce11c74\n\ntransaction(marketplace:Address, user: String, id: UInt64, amount: UFix64) {\n\n    let saleItemsCap: Capability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic}\u003e \n    var targetCapability : Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e\n    let bidsReference: \u0026FindMarketAuctionSoft.MarketBidCollection?\n    let pointer: FindViews.ViewReadPointer\n    let ftVaultType: Type\n\n    prepare(account: AuthAccount) {\n\n        let resolveAddress = FIND.resolve(user)\n        if resolveAddress == nil {panic(\"The address input is not a valid name nor address. Input : \".concat(user))}\n        let address = resolveAddress!\n\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n        let tenant = tenantCapability.borrow()!\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n        if !asBidCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n        }\n\n        self.saleItemsCap= FindMarketAuctionSoft.getSaleItemCapability(marketplace:marketplace, user:address) ?? panic(\"cannot find sale item cap\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e())\n\n        let item = FindMarket.assertOperationValid(tenant: marketplace, address: address, marketOption: marketOption, id: id)\n\n        let nftIdentifier = item.getItemType().identifier\n        let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier)) \n        let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n        let nft = collection.collectionData\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n    \n        self.targetCapability= account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(nft.publicPath)\n        /* Check for nftCapability */\n        if !self.targetCapability.check() {\n            let cd = item.getNFTCollectionData()\n            // should use account.type here instead\n            if account.type(at: cd.storagePath) != nil {\n                let pathIdentifier = nft.publicPath.toString()\n                let findPath = PublicPath(identifier: pathIdentifier.slice(from: \"/public/\".length , upTo: pathIdentifier.length).concat(\"_FIND\"))!\n                account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                    findPath,\n                    target: nft.storagePath\n                )\n                self.targetCapability = account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(findPath)\n            } else {\n                account.save(\u003c- cd.createEmptyCollection(), to: cd.storagePath)\n                account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.publicPath, target: cd.storagePath)\n                account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.providerPath, target: cd.storagePath)\n            }\n\n        }\n        \n        self.ftVaultType = ft.type\n\n        let bidStoragePath=tenant.getStoragePath(Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e())\n\n        self.bidsReference= account.borrow\u003c\u0026FindMarketAuctionSoft.MarketBidCollection\u003e(from: bidStoragePath)\n        self.pointer= FindViews.createViewReadPointer(address: address, path:nft.publicPath, id: item.getItemID())\n    }\n\n    pre {\n        self.bidsReference != nil : \"This account does not have a bid collection\"\n    }\n\n    execute {\n        self.bidsReference!.bid(item:self.pointer, amount: amount, vaultType: self.ftVaultType, nftCap: self.targetCapability, bidExtraField: {})\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "user",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64",
                     "marketplace": "Address",
                     "user": "String"
                  }
               }
            },
            "bidMarketDirectOfferEscrowed": {
               "code": "import Profile from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\nimport FindMarketDirectOfferEscrow from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FindViews from 0x35717efbbce11c74\nimport FTRegistry from 0x35717efbbce11c74\nimport FINDNFTCatalog from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\n\ntransaction(marketplace:Address, user: String, nftAliasOrIdentifier: String, id: UInt64, ftAliasOrIdentifier:String, amount: UFix64, validUntil: UFix64?) {\n\n    var targetCapability : Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e\n    let walletReference : \u0026FungibleToken.Vault\n    let bidsReference: \u0026FindMarketDirectOfferEscrow.MarketBidCollection?\n    let pointer: FindViews.ViewReadPointer\n\n    prepare(account: AuthAccount) {\n\n        let resolveAddress = FIND.resolve(user)\n        if resolveAddress == nil {panic(\"The address input is not a valid name nor address. Input : \".concat(user))}\n        let address = resolveAddress!\n\n        let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftAliasOrIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftAliasOrIdentifier)) \n        let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n        let nft = collection.collectionData\n\n        let ft = FTRegistry.getFTInfo(ftAliasOrIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftAliasOrIdentifier))\n        \n        self.targetCapability= account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(nft.publicPath)\n        self.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n        let tenant = tenantCapability.borrow()!\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        let doeBidPublicPath=FindMarket.getPublicPath(doeBidType, name: tenant.name)\n        let doeBidStoragePath= FindMarket.getStoragePath(doeBidType, name:tenant.name)\n        let doeBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n        if !doeBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n        }\n\n        self.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection\u003e(from: doeBidStoragePath)\n        self.pointer= FindViews.createViewReadPointer(address: address, path:nft.publicPath, id: id)\n\n        /* Check for nftCapability */\n        if !self.targetCapability.check() {\n            let cd = self.pointer.getNFTCollectionData()\n            // should use account.type here instead\n            if account.type(at: cd.storagePath) != nil {\n                let pathIdentifier = nft.publicPath.toString()\n                let findPath = PublicPath(identifier: pathIdentifier.slice(from: \"/public/\".length , upTo: pathIdentifier.length).concat(\"_FIND\"))!\n                account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                    findPath,\n                    target: nft.storagePath\n                )\n                self.targetCapability = account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(findPath)\n            } else {\n                account.save(\u003c- cd.createEmptyCollection(), to: cd.storagePath)\n                account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.publicPath, target: cd.storagePath)\n                account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.providerPath, target: cd.storagePath)\n            }\n\n        }\n    }\n\n    pre {\n        self.bidsReference != nil : \"This account does not have a bid collection\"\n        self.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount) \n        self.bidsReference!.bid(item:self.pointer, vault: \u003c- vault, nftCap: self.targetCapability, validUntil: validUntil, saleItemExtraField: {}, bidExtraField: {})\n    }\n\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "user",
                     "nftAliasOrIdentifier",
                     "id",
                     "ftAliasOrIdentifier",
                     "amount",
                     "validUntil"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "ftAliasOrIdentifier": "String",
                     "id": "UInt64",
                     "marketplace": "Address",
                     "nftAliasOrIdentifier": "String",
                     "user": "String",
                     "validUntil": "UFix64?"
                  }
               }
            },
            "bidMarketDirectOfferSoft": {
               "code": "import Profile from 0x35717efbbce11c74\nimport FindMarketDirectOfferSoft from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FindViews from 0x35717efbbce11c74\nimport FTRegistry from 0x35717efbbce11c74\nimport FINDNFTCatalog from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\n\ntransaction(marketplace:Address, user: String, nftAliasOrIdentifier: String, id: UInt64, ftAliasOrIdentifier:String, amount: UFix64, validUntil: UFix64?) {\n\n    var targetCapability : Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e\n    let walletReference : \u0026FungibleToken.Vault\n    let bidsReference: \u0026FindMarketDirectOfferSoft.MarketBidCollection?\n    let balanceBeforeBid: UFix64\n    let pointer: FindViews.ViewReadPointer\n    let ftVaultType: Type\n\n    prepare(account: AuthAccount) {\n        \n        let resolveAddress = FIND.resolve(user)\n        if resolveAddress == nil {panic(\"The address input is not a valid name nor address. Input : \".concat(user))}\n        let address = resolveAddress!\n\n        let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftAliasOrIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftAliasOrIdentifier)) \n        let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n        let nft = collection.collectionData\n\n        let ft = FTRegistry.getFTInfo(ftAliasOrIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftAliasOrIdentifier))\n\n        self.ftVaultType = ft.type\n\n        self.targetCapability= account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(nft.publicPath)\n        self.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n        let tenant = tenantCapability.borrow()!\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n        if !dosBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n        }\n\n        self.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection\u003e(from: dosBidStoragePath)\n        self.balanceBeforeBid=self.walletReference.balance\n        self.pointer= FindViews.createViewReadPointer(address: address, path:nft.publicPath, id: id)\n\n        /* Check for nftCapability */\n        if !self.targetCapability.check() {\n            let cd = self.pointer.getNFTCollectionData()\n            // should use account.type here instead\n            if account.type(at: cd.storagePath) != nil {\n                let pathIdentifier = nft.publicPath.toString()\n                let findPath = PublicPath(identifier: pathIdentifier.slice(from: \"/public/\".length , upTo: pathIdentifier.length).concat(\"_FIND\"))!\n                account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                    findPath,\n                    target: nft.storagePath\n                )\n                self.targetCapability = account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(findPath)\n            } else {\n                account.save(\u003c- cd.createEmptyCollection(), to: cd.storagePath)\n                account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.publicPath, target: cd.storagePath)\n                account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.providerPath, target: cd.storagePath)\n            }\n\n        }\n    }\n\n    pre {\n        self.bidsReference != nil : \"This account does not have a bid collection\"\n        self.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n    }\n\n    execute {\n        self.bidsReference!.bid(item:self.pointer, amount: amount, vaultType: self.ftVaultType, nftCap: self.targetCapability, validUntil: validUntil, saleItemExtraField: {}, bidExtraField: {})\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "user",
                     "nftAliasOrIdentifier",
                     "id",
                     "ftAliasOrIdentifier",
                     "amount",
                     "validUntil"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "ftAliasOrIdentifier": "String",
                     "id": "UInt64",
                     "marketplace": "Address",
                     "nftAliasOrIdentifier": "String",
                     "user": "String",
                     "validUntil": "UFix64?"
                  }
               }
            },
            "bidMarketDirectOfferSoftDapper": {
               "code": "import Profile from 0x35717efbbce11c74\nimport FindMarketDirectOfferSoft from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FindViews from 0x35717efbbce11c74\nimport FINDNFTCatalog from 0x35717efbbce11c74\nimport FTRegistry from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\n\ntransaction(marketplace:Address, user: String, nftAliasOrIdentifier: String, id: UInt64, ftAliasOrIdentifier: String, amount: UFix64, validUntil: UFix64?) {\n\n    var targetCapability : Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e\n    let bidsReference: \u0026FindMarketDirectOfferSoft.MarketBidCollection?\n    let pointer: FindViews.ViewReadPointer\n    let ftVaultType: Type\n\n    prepare(account: AuthAccount) {\n        \n        let resolveAddress = FIND.resolve(user)\n        if resolveAddress == nil {panic(\"The address input is not a valid name nor address. Input : \".concat(user))}\n        let address = resolveAddress!\n\n        let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftAliasOrIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftAliasOrIdentifier)) \n        let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n        let nft = collection.collectionData\n\n        let ft = FTRegistry.getFTInfo(ftAliasOrIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftAliasOrIdentifier))\n\n        self.ftVaultType = ft.type\n\n        self.targetCapability= account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(nft.publicPath)\n\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n        let tenant = tenantCapability.borrow()!\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n        if !dosBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n        }\n\n        self.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection\u003e(from: dosBidStoragePath)\n        self.pointer= FindViews.createViewReadPointer(address: address, path:nft.publicPath, id: id)\n\n        /* Check for nftCapability */\n        if !self.targetCapability.check() {\n            let cd = self.pointer.getNFTCollectionData()\n            // should use account.type here instead\n            if account.type(at: cd.storagePath) != nil {\n                let pathIdentifier = nft.publicPath.toString()\n                let findPath = PublicPath(identifier: pathIdentifier.slice(from: \"/public/\".length , upTo: pathIdentifier.length).concat(\"_FIND\"))!\n                account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                    findPath,\n                    target: nft.storagePath\n                )\n                self.targetCapability = account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(findPath)\n            } else {\n                account.save(\u003c- cd.createEmptyCollection(), to: cd.storagePath)\n                account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.publicPath, target: cd.storagePath)\n                account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.providerPath, target: cd.storagePath)\n            }\n\n        }\n    }\n\n    pre {\n        self.bidsReference != nil : \"This account does not have a bid collection\"\n    }\n\n    execute {\n        self.bidsReference!.bid(item:self.pointer, amount: amount, vaultType: self.ftVaultType, nftCap: self.targetCapability, validUntil: validUntil, saleItemExtraField: {}, bidExtraField: {})\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "user",
                     "nftAliasOrIdentifier",
                     "id",
                     "ftAliasOrIdentifier",
                     "amount",
                     "validUntil"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "ftAliasOrIdentifier": "String",
                     "id": "UInt64",
                     "marketplace": "Address",
                     "nftAliasOrIdentifier": "String",
                     "user": "String",
                     "validUntil": "UFix64?"
                  }
               }
            },
            "bidMultipleMarketDirectOfferEscrowed": {
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FindMarketSale from 0x35717efbbce11c74\nimport FindMarketDirectOfferEscrow from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FindViews from 0x35717efbbce11c74\nimport FTRegistry from 0x35717efbbce11c74\nimport NFTCatalog from 0x324c34e1c517e4db\nimport FINDNFTCatalog from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\n\ntransaction(marketplace:Address, users: [String], nftAliasOrIdentifiers: [String], ids: [UInt64], ftAliasOrIdentifiers:[String], amounts: [UFix64], validUntil: UFix64?) {\n\n    let targetCapability : [Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e]\n    let walletReference : [\u0026FungibleToken.Vault]\n    let bidsReference: \u0026FindMarketDirectOfferEscrow.MarketBidCollection?\n    let pointer: [FindViews.ViewReadPointer]\n\n    prepare(account: AuthAccount) {\n\n        if nftAliasOrIdentifiers.length != users.length {\n            panic(\"The length of arrays passed in has to be the same\")\n        } else if nftAliasOrIdentifiers.length != ids.length {\n            panic(\"The length of arrays passed in has to be the same\")\n        } else if nftAliasOrIdentifiers.length != ftAliasOrIdentifiers.length {\n            panic(\"The length of arrays passed in has to be the same\")\n        } else if nftAliasOrIdentifiers.length != amounts.length {\n            panic(\"The length of arrays passed in has to be the same\")\n        }\n\n        let addresses : {String : Address} = {}\n        let nfts : {String : NFTCatalog.NFTCollectionData} = {}\n        let fts : {String : FTRegistry.FTInfo} = {}\n\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketSale.SaleItemCollection\u003e())\n        let vaultRefs : {StoragePath : \u0026FungibleToken.Vault} = {}\n\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n        let tenant = tenantCapability.borrow()!\n        let bidStoragePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e())\n\n        self.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection\u003e(from: bidStoragePath)\n        self.walletReference = []\n        self.pointer = []\n        self.targetCapability = []\n\n        var counter = 0\n        while counter \u003c users.length {\n            var resolveAddress : Address? = nil\n            if addresses[users[counter]] != nil {\n                resolveAddress = addresses[users[counter]]!\n            } else {\n                let address = FIND.resolve(users[counter])\n                if address == nil {\n                    panic(\"The address input is not a valid name nor address. Input : \".concat(users[counter]))\n                }\n                addresses[users[counter]] = address!\n                resolveAddress = address!\n            }\n            let address = resolveAddress!\n\n            var nft : NFTCatalog.NFTCollectionData? = nil\n            var ft : FTRegistry.FTInfo? = nil\n            let nftIdentifier = nftAliasOrIdentifiers[counter]\n            let ftIdentifier = ftAliasOrIdentifiers[counter]\n\n            if nfts[nftIdentifier] != nil {\n                nft = nfts[nftIdentifier]\n            } else {\n                let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier))\n                let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])!\n                nft =  collection.collectionData\n\n                nfts[nftIdentifier] = nft\n            }\n\n            if fts[ftIdentifier] != nil {\n                ft = fts[ftIdentifier]\n            } else {\n                ft = FTRegistry.getFTInfo(ftIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftIdentifier))\n                fts[ftIdentifier] = ft\n            }\n\n            if vaultRefs[ft!.vaultPath] != nil {\n                self.walletReference.append(vaultRefs[ft!.vaultPath]!)\n            } else {\n                let walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft!.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n                vaultRefs[ft!.vaultPath] = walletReference\n                self.walletReference.append(walletReference)\n            }\n\n            let pointer= FindViews.createViewReadPointer(address: address, path:nft!.publicPath, id: ids[counter])\n            self.pointer.append(pointer)\n\n            var targetCapability= account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(nft!.publicPath)\n            /* Check for nftCapability */\n            if !targetCapability.check() {\n                let cd = pointer.getNFTCollectionData()\n                // should use account.type here instead\n                if account.type(at: cd.storagePath) != nil {\n                    let pathIdentifier = nft!.publicPath.toString()\n                    let findPath = PublicPath(identifier: pathIdentifier.slice(from: \"/public/\".length , upTo: pathIdentifier.length).concat(\"_FIND\"))!\n                    account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                        findPath,\n                        target: nft!.storagePath\n                    )\n                    targetCapability = account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(findPath)\n                } else {\n                    account.save(\u003c- cd.createEmptyCollection(), to: cd.storagePath)\n                    account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.publicPath, target: cd.storagePath)\n                    account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.providerPath, target: cd.storagePath)\n                }\n\n            }\n            self.targetCapability.append(targetCapability)\n            counter = counter + 1\n        }\n    }\n\n    pre {\n        self.bidsReference != nil : \"This account does not have a bid collection\"\n    }\n\n    execute {\n        var counter = 0\n        while counter \u003c ids.length {\n            if self.walletReference[counter].balance \u003c amounts[counter] {\n                panic(\"Your wallet does not have enough funds to pay for this item. Fund Type : \".concat(ftAliasOrIdentifiers[counter]).concat(\"Required Amount : \").concat(amounts[counter].toString()))\n            }\n            let vault \u003c- self.walletReference[counter].withdraw(amount: amounts[counter])\n            self.bidsReference!.bid(item:self.pointer[counter], vault: \u003c- vault, nftCap: self.targetCapability[counter], validUntil: validUntil, saleItemExtraField: {}, bidExtraField: {})\n            counter = counter + 1\n        }\n    }\n\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "users",
                     "nftAliasOrIdentifiers",
                     "ids",
                     "ftAliasOrIdentifiers",
                     "amounts",
                     "validUntil"
                  ],
                  "parameters": {
                     "amounts": "[UFix64]",
                     "ftAliasOrIdentifiers": "[String]",
                     "ids": "[UInt64]",
                     "marketplace": "Address",
                     "nftAliasOrIdentifiers": "[String]",
                     "users": "[String]",
                     "validUntil": "UFix64?"
                  }
               }
            },
            "bidMultipleMarketDirectOfferSoft": {
               "code": "import FindMarketDirectOfferSoft from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FindViews from 0x35717efbbce11c74\nimport FTRegistry from 0x35717efbbce11c74\nimport NFTCatalog from 0x324c34e1c517e4db\nimport FINDNFTCatalog from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\n\ntransaction(marketplace:Address, users: [String], nftAliasOrIdentifiers: [String], ids: [UInt64], ftAliasOrIdentifiers:[String], amounts: [UFix64], validUntil: UFix64?) {\n\n    let targetCapability : [Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e]\n    let walletReference : [\u0026FungibleToken.Vault]\n    let bidsReference: \u0026FindMarketDirectOfferSoft.MarketBidCollection?\n    let pointer: [FindViews.ViewReadPointer]\n    let ftVaultType: [Type]\n    let totalPrice : {String : UFix64}\n\n    prepare(account: AuthAccount) {\n\n        if nftAliasOrIdentifiers.length != users.length {\n            panic(\"The length of arrays passed in has to be the same\")\n        } else if nftAliasOrIdentifiers.length != ids.length {\n            panic(\"The length of arrays passed in has to be the same\")\n        } else if nftAliasOrIdentifiers.length != ftAliasOrIdentifiers.length {\n            panic(\"The length of arrays passed in has to be the same\")\n        } else if nftAliasOrIdentifiers.length != amounts.length {\n            panic(\"The length of arrays passed in has to be the same\")\n        }\n\n        let addresses : {String : Address} = {}\n        let nfts : {String : NFTCatalog.NFTCollectionData} = {}\n        let fts : {String : FTRegistry.FTInfo} = {}\n        let vaultRefs : {StoragePath : \u0026FungibleToken.Vault} = {}\n        \n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n        let tenant = tenantCapability.borrow()!\n        let bidStoragePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n        self.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection\u003e(from: bidStoragePath)\n        self.walletReference = []\n        self.pointer = []\n        self.targetCapability = []\n        self.ftVaultType = []\n        self.totalPrice = {}\n\n        var counter = 0\n        while counter \u003c users.length {\n            var resolveAddress : Address? = nil\n            if addresses[users[counter]] != nil {\n                resolveAddress = addresses[users[counter]]!\n            } else {\n                let address = FIND.resolve(users[counter])\n                if address == nil {\n                    panic(\"The address input is not a valid name nor address. Input : \".concat(users[counter]))\n                }\n                addresses[users[counter]] = address!\n                resolveAddress = address!\n            }\n            let address = resolveAddress!\n\n            var nft : NFTCatalog.NFTCollectionData? = nil\n            var ft : FTRegistry.FTInfo? = nil\n            let nftIdentifier = nftAliasOrIdentifiers[counter]\n            let ftIdentifier = ftAliasOrIdentifiers[counter]\n\n            if nfts[nftIdentifier] != nil {\n                nft = nfts[nftIdentifier]\n            } else {\n                let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier)) \n                let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n                nft = collection.collectionData\n                nfts[nftIdentifier] = nft\n            }\n\n            if fts[ftIdentifier] != nil {\n                ft = fts[ftIdentifier]\n            } else {\n                ft = FTRegistry.getFTInfo(ftIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftIdentifier))\n                fts[ftIdentifier] = ft \n            }\n        \n            if vaultRefs[ft!.vaultPath] != nil {\n                self.walletReference.append(vaultRefs[ft!.vaultPath]!)\n                self.ftVaultType.append(vaultRefs[ft!.vaultPath]!.getType())\n            } else {\n                let walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft!.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n                vaultRefs[ft!.vaultPath] = walletReference\n                self.walletReference.append(walletReference)\n                self.ftVaultType.append(ft!.type)\n            }\n\n            if self.totalPrice[ftIdentifier] == nil {\n                self.totalPrice[ftIdentifier] = amounts[counter]\n            } else {\n                self.totalPrice[ftIdentifier] = self.totalPrice[ftIdentifier]! + amounts[counter]\n            }\n\n            let pointer= FindViews.createViewReadPointer(address: address, path:nft!.publicPath, id: ids[counter])\n            self.pointer.append(pointer)\n\n            var targetCapability= account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(nft!.publicPath)\n\n            /* Check for nftCapability */\n            if !targetCapability.check() {\n                let cd = pointer.getNFTCollectionData()\n                // should use account.type here instead\n                if account.type(at: cd.storagePath) != nil {\n                    let pathIdentifier = nft!.publicPath.toString()\n                    let findPath = PublicPath(identifier: pathIdentifier.slice(from: \"/public/\".length , upTo: pathIdentifier.length).concat(\"_FIND\"))!\n                    account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                        findPath,\n                        target: nft!.storagePath\n                    )\n                    targetCapability = account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(findPath)\n                } else {\n                    account.save(\u003c- cd.createEmptyCollection(), to: cd.storagePath)\n                    account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.publicPath, target: cd.storagePath)\n                    account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.providerPath, target: cd.storagePath)\n                }\n\n            }\n            self.targetCapability.append(targetCapability)\n            counter = counter + 1\n        }\n    }\n\n    pre {\n        self.bidsReference != nil : \"This account does not have a bid collection\"\n    }\n\n    execute {\n        var counter = 0\n        while counter \u003c ids.length {\n            if self.walletReference[counter].balance \u003c self.totalPrice[ftAliasOrIdentifiers[counter]]! {\n                panic(\"Your wallet does not have enough funds to pay for this item. Vault Type : \".concat(self.ftVaultType[counter].getType().identifier).concat(\" . Required : \".concat(self.totalPrice[ftAliasOrIdentifiers[counter]]!.toString())))\n            }    \n            self.bidsReference!.bid(item:self.pointer[counter], amount: amounts[counter], vaultType: self.ftVaultType[counter], nftCap: self.targetCapability[counter], validUntil: validUntil, saleItemExtraField: {}, bidExtraField: {})\n            counter = counter + 1 \n        }\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "users",
                     "nftAliasOrIdentifiers",
                     "ids",
                     "ftAliasOrIdentifiers",
                     "amounts",
                     "validUntil"
                  ],
                  "parameters": {
                     "amounts": "[UFix64]",
                     "ftAliasOrIdentifiers": "[String]",
                     "ids": "[UInt64]",
                     "marketplace": "Address",
                     "nftAliasOrIdentifiers": "[String]",
                     "users": "[String]",
                     "validUntil": "UFix64?"
                  }
               }
            },
            "bidMultipleMarketDirectOfferSoftDapper": {
               "code": "import FindMarketSale from 0x35717efbbce11c74\nimport FindMarketDirectOfferSoft from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FindViews from 0x35717efbbce11c74\nimport NFTCatalog from 0x324c34e1c517e4db\nimport FINDNFTCatalog from 0x35717efbbce11c74\nimport FTRegistry from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\n\ntransaction(marketplace:Address, users: [String], nftAliasOrIdentifiers: [String], ids: [UInt64], ftAliasOrIdentifiers: [String], amounts: [UFix64], validUntil: UFix64?) {\n\n    let targetCapability : [Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e]\n    let bidsReference: \u0026FindMarketDirectOfferSoft.MarketBidCollection?\n    let pointer: [FindViews.ViewReadPointer]\n    let walletReference : [\u0026FungibleToken.Vault]\n    let ftVaultType: [Type]\n    let walletBalances : {Type : UFix64}\n\n    prepare(account: AuthAccount) {\n\n        if nftAliasOrIdentifiers.length != users.length {\n            panic(\"The length of arrays passed in has to be the same\")\n        } else if nftAliasOrIdentifiers.length != ids.length {\n            panic(\"The length of arrays passed in has to be the same\")\n        } else if nftAliasOrIdentifiers.length != amounts.length {\n            panic(\"The length of arrays passed in has to be the same\")\n        }\n        \n        let addresses : {String : Address} = {}\n        let nfts : {String : NFTCatalog.NFTCollectionData} = {}\n        let fts : {String : FTRegistry.FTInfo} = {}\n\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketSale.SaleItemCollection\u003e())\n        let vaultType : {String : Type} = {}\n\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n        let tenant = tenantCapability.borrow()!\n        let bidStoragePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n        self.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection\u003e(from: bidStoragePath)\n        \n        self.pointer = []\n        self.targetCapability = []\n        self.walletReference = []\n        self.ftVaultType = []\n        self.walletBalances = {}\n\n        var counter = 0\n        while counter \u003c users.length {\n            var resolveAddress : Address? = nil\n            if addresses[users[counter]] != nil {\n                resolveAddress = addresses[users[counter]]!\n            } else {\n                let address = FIND.resolve(users[counter])\n                if address == nil {\n                    panic(\"The address input is not a valid name nor address. Input : \".concat(users[counter]))\n                }\n                addresses[users[counter]] = address!\n                resolveAddress = address!\n            }\n            let address = resolveAddress!\n\n            var nft : NFTCatalog.NFTCollectionData? = nil\n            var ft : FTRegistry.FTInfo? = nil\n            let nftIdentifier = nftAliasOrIdentifiers[counter]\n            let ftIdentifier = ftAliasOrIdentifiers[counter]\n\n            if nfts[nftIdentifier] != nil {\n                nft = nfts[nftIdentifier]\n            } else {\n                let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier)) \n                let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n                nft = collection.collectionData\n                nfts[nftIdentifier] = nft\n            }\n\n            if fts[ftIdentifier] != nil {\n                ft = fts[ftIdentifier]\n            } else {\n                ft = FTRegistry.getFTInfo(ftIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftIdentifier))\n                fts[ftIdentifier] = ft \n            }\n        \n            self.ftVaultType.append(fts[ftIdentifier]!.type)\n\n\n            let pointer= FindViews.createViewReadPointer(address: address, path:nft!.publicPath, id: ids[counter])\n            self.pointer.append(pointer)\n\n            var targetCapability= account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(nft!.publicPath)\n\n            /* Check for nftCapability */\n            if !targetCapability.check() {\n                let cd = pointer.getNFTCollectionData()\n                // should use account.type here instead\n                if account.type(at: cd.storagePath) != nil {\n                    let pathIdentifier = nft!.publicPath.toString()\n                    let findPath = PublicPath(identifier: pathIdentifier.slice(from: \"/public/\".length , upTo: pathIdentifier.length).concat(\"_FIND\"))!\n                    account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                        findPath,\n                        target: nft!.storagePath\n                    )\n                    targetCapability = account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(findPath)\n                } else {\n                    account.save(\u003c- cd.createEmptyCollection(), to: cd.storagePath)\n                    account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.publicPath, target: cd.storagePath)\n                    account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.providerPath, target: cd.storagePath)\n                }\n\n            }\n            self.targetCapability.append(targetCapability)\n            counter = counter + 1\n        }\n    }\n\n    pre {\n        self.bidsReference != nil : \"This account does not have a bid collection\"\n    }\n\n    execute {\n        var counter = 0\n        while counter \u003c ids.length {\n            self.bidsReference!.bid(item:self.pointer[counter], amount: amounts[counter], vaultType: self.ftVaultType[counter], nftCap: self.targetCapability[counter], validUntil: validUntil, saleItemExtraField: {}, bidExtraField: {})\n            counter = counter + 1\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "users",
                     "nftAliasOrIdentifiers",
                     "ids",
                     "ftAliasOrIdentifiers",
                     "amounts",
                     "validUntil"
                  ],
                  "parameters": {
                     "amounts": "[UFix64]",
                     "ftAliasOrIdentifiers": "[String]",
                     "ids": "[UInt64]",
                     "marketplace": "Address",
                     "nftAliasOrIdentifiers": "[String]",
                     "users": "[String]",
                     "validUntil": "UFix64?"
                  }
               }
            },
            "bidName": {
               "code": "import FUSD from 0xe223d8a629e49c68\nimport FIND from 0x35717efbbce11c74\n\ntransaction(name: String, amount: UFix64) {\n\n    let vaultRef : \u0026FUSD.Vault?\n    let bidRef : \u0026FIND.BidCollection?\n\n    prepare(account: AuthAccount) {\n\n        self.vaultRef = account.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault)\n        self.bidRef = account.borrow\u003c\u0026FIND.BidCollection\u003e(from: FIND.BidStoragePath)\n    }\n\n    pre{\n        self.vaultRef != nil : \"Could not borrow reference to the fusdVault!\" \n        self.bidRef != nil : \"Could not borrow reference to the bid collection!\" \n    }\n\n    execute {\n        let vault \u003c- self.vaultRef!.withdraw(amount: amount) as! @FUSD.Vault\n        self.bidRef!.bid(name: name, vault: \u003c- vault)\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "name": "String"
                  }
               }
            },
            "burnNFTs": {
               "code": "import NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport NFTCatalog from 0x324c34e1c517e4db\nimport FINDNFTCatalog from 0x35717efbbce11c74\nimport FindViews from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\nimport FindFurnace from 0x35717efbbce11c74\n\ntransaction(types: [String] , ids: [UInt64], messages: [String]) {\n\n    let authPointers : [FindViews.AuthNFTPointer]\n\n    prepare(account : AuthAccount) {\n\n        self.authPointers = []\n\n        let contractData : {Type : NFTCatalog.NFTCatalogMetadata} = {}\n\n\n        for i , typeIdentifier in types {\n            let type = CompositeType(typeIdentifier) ?? panic(\"Cannot refer to type with identifier : \".concat(typeIdentifier))\n\n            var data : NFTCatalog.NFTCatalogMetadata? = contractData[type]\n            if data == nil {\n                data = FINDNFTCatalog.getMetadataFromType(type) ?? panic(\"NFT Type is not supported by NFT Catalog. Type : \".concat(type.identifier))\n                contractData[type] = data\n            }\n\n            let path = data!.collectionData\n\n            var providerCap=account.getCapability\u003c\u0026{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e(path.privatePath)\n            if !providerCap.check() {\n                let newCap = account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                    path.privatePath,\n                    target: path.storagePath\n                )\n                if newCap == nil {\n                    // If linking is not successful, we link it using finds custom link \n                    let pathIdentifier = path.privatePath.toString()\n                    let findPath = PrivatePath(identifier: pathIdentifier.slice(from: \"/private/\".length , upTo: pathIdentifier.length).concat(\"_FIND\"))!\n                    account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                        findPath,\n                        target: path.storagePath\n                    )\n                    providerCap = account.getCapability\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(findPath)\n                }\n            }\n            let pointer = FindViews.AuthNFTPointer(cap: providerCap, id: ids[i])\n            self.authPointers.append(pointer)\n        }\n    }\n\n    execute {\n        let ctx : {String : String} = {\n            \"tenant\" : \"find\"\n        }\n        for i,  pointer in self.authPointers {\n            let id = ids[i] \n            ctx[\"message\"] = messages[i]\n\n            // burn thru furnace\n            FindFurnace.burn(pointer: pointer, context: ctx)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "types",
                     "ids",
                     "messages"
                  ],
                  "parameters": {
                     "ids": "[UInt64]",
                     "messages": "[String]",
                     "types": "[String]"
                  }
               }
            },
            "buyAddon": {
               "code": "import FUSD from 0xe223d8a629e49c68\nimport FIND from 0x35717efbbce11c74\n\n\ntransaction(name: String, addon:String, amount:UFix64) {\n\n    let leases : \u0026FIND.LeaseCollection?\n    let vaultRef : \u0026FUSD.Vault? \n\n    prepare(account: AuthAccount) {\n\n        self.leases= account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)\n        self.vaultRef = account.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault)\n\n    }\n\n    pre{\n        self.leases != nil : \"Could not borrow reference to the leases collection\"\n        self.vaultRef != nil : \"Could not borrow reference to the fusdVault!\"\n    }\n\n    execute {\n        let vault \u003c- self.vaultRef!.withdraw(amount: amount) as! @FUSD.Vault\n        self.leases!.buyAddon(name: name, addon: addon, vault: \u003c- vault)\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "addon",
                     "amount"
                  ],
                  "parameters": {
                     "addon": "String",
                     "amount": "UFix64",
                     "name": "String"
                  }
               }
            },
            "buyAddonDapper": {
               "code": "import DapperUtilityCoin from 0x82ec283f88a62e65\nimport FIND from 0x35717efbbce11c74\n\n\ntransaction(merchAccount: Address, name: String, addon:String, amount:UFix64) {\n\n    let finLeases : \u0026FIND.LeaseCollection\n    let mainDapperUtilityCoinVault: \u0026DapperUtilityCoin.Vault\n    let balanceBeforeTransfer: UFix64\n\n    prepare(dapper: AuthAccount, account: AuthAccount) {\n        self.mainDapperUtilityCoinVault = dapper.borrow\u003c\u0026DapperUtilityCoin.Vault\u003e(from: /storage/dapperUtilityCoinVault) ?? panic(\"Cannot borrow DapperUtilityCoin vault from account storage\".concat(dapper.address.toString()))\n        self.balanceBeforeTransfer = self.mainDapperUtilityCoinVault.balance\n        self.finLeases= account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath) ?? panic(\"Could not borrow reference to find lease collection\")\n\n    }\n\n    execute {\n        let vault \u003c- self.mainDapperUtilityCoinVault.withdraw(amount: amount) as! @DapperUtilityCoin.Vault\n        self.finLeases.buyAddonDapper(merchAccount: merchAccount, name: name, addon: addon, vault: \u003c- vault)\n    }\n\n    post {\n        self.mainDapperUtilityCoinVault.balance == self.balanceBeforeTransfer: \"DapperUtilityCoin leakage\"\n    }\n}",
               "spec": {
                  "order": [
                     "merchAccount",
                     "name",
                     "addon",
                     "amount"
                  ],
                  "parameters": {
                     "addon": "String",
                     "amount": "UFix64",
                     "merchAccount": "Address",
                     "name": "String"
                  }
               }
            },
            "buyFindPack": {
               "code": "import FindPack from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FlowToken from 0x7e60df042a9c0868\nimport FUSD from 0xe223d8a629e49c68\nimport Profile from 0x35717efbbce11c74\n\ntransaction(packTypeName: String, packTypeId:UInt64, numberOfPacks:UInt64, totalAmount: UFix64) {\n    let packs: \u0026FindPack.Collection{FindPack.CollectionPublic}\n\n    let userPacks: Capability\u003c\u0026FindPack.Collection{NonFungibleToken.Receiver}\u003e\n    let salePrice: UFix64\n    let packsLeft: UInt64\n\n    let userFlowTokenVault: \u0026FlowToken.Vault\n\n    let paymentVault: @FungibleToken.Vault\n    let balanceBeforeTransfer:UFix64\n\n    prepare(account: AuthAccount) {\n\n        let findPackCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(FindPack.CollectionPublicPath)\n        if !findPackCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e( \u003c- FindPack.createEmptyCollection(), to: FindPack.CollectionStoragePath)\n            account.link\u003c\u0026FindPack.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                FindPack.CollectionPublicPath,\n                target: FindPack.CollectionStoragePath\n            )\n        }\n\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:account.address.toString(), createdAt: \"find\")\n\n            //Add exising FUSD or create a new one and add it\n            let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n            if !fusdReceiver.check() {\n                let fusd \u003c- FUSD.createEmptyVault()\n                account.save(\u003c- fusd, to: /storage/fusdVault)\n                account.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n                account.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n            }\n\n            let fusdWallet=Profile.Wallet(\n                name:\"FUSD\", \n                receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver),\n                balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance),\n                accept: Type\u003c@FUSD.Vault\u003e(),\n                names: [\"fusd\", \"stablecoin\"]\n            )\n\n            profile.addWallet(fusdWallet)\n\n            let flowWallet=Profile.Wallet(\n                name:\"Flow\", \n                receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver),\n                balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance),\n                accept: Type\u003c@FlowToken.Vault\u003e(),\n                names: [\"flow\"]\n            )\n            profile.addWallet(flowWallet)\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n\n\n        }\n\n        self.userPacks=account.getCapability\u003c\u0026FindPack.Collection{NonFungibleToken.Receiver}\u003e(FindPack.CollectionPublicPath)\n        self.packs=FindPack.getPacksCollection(packTypeName: packTypeName, packTypeId:packTypeId)\n\n        self.salePrice= FindPack.getCurrentPrice(packTypeName: packTypeName, packTypeId:packTypeId, user:account.address) ?? panic (\"Cannot buy the pack now\") \n        self.packsLeft= UInt64(self.packs.getPacksLeft())\n\n\n        self.userFlowTokenVault = account.borrow\u003c\u0026FlowToken.Vault\u003e(from: /storage/flowTokenVault) ?? panic(\"Cannot borrow FlowToken vault from account storage\")\n        self.balanceBeforeTransfer = self.userFlowTokenVault.balance\n\n        if self.balanceBeforeTransfer \u003c totalAmount {\n            panic(\"Your account does not have enough funds has \".concat(self.balanceBeforeTransfer.toString()).concat(\" needs \").concat(totalAmount.toString()))\n        }\n        self.paymentVault \u003c- self.userFlowTokenVault.withdraw(amount: totalAmount)\n    }\n\n    pre {\n        self.salePrice * UFix64(numberOfPacks) == totalAmount: \"unexpected sending amount\"\n        self.packsLeft \u003e= numberOfPacks : \"Rats! there are no packs left\"\n        self.userPacks.check() : \"User need a receiver to put the pack in\"\n    }\n\n    execute {\n        var counter = numberOfPacks\n        while counter \u003e 0 {\n            let purchasingVault \u003c- self.paymentVault.withdraw(amount: self.salePrice)\n            self.packs.buy(packTypeName: packTypeName, typeId:packTypeId, vault: \u003c- purchasingVault, collectionCapability: self.userPacks)\n            counter = counter - 1\n        }\n        if self.paymentVault.balance != 0.0 {\n            panic(\"paymentVault balance is non-zero after paying\")\n        }\n        destroy self.paymentVault\n    }\n\n}",
               "spec": {
                  "order": [
                     "packTypeName",
                     "packTypeId",
                     "numberOfPacks",
                     "totalAmount"
                  ],
                  "parameters": {
                     "numberOfPacks": "UInt64",
                     "packTypeId": "UInt64",
                     "packTypeName": "String",
                     "totalAmount": "UFix64"
                  }
               }
            },
            "buyFindPackWithReservation": {
               "code": "import FindPack from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FlowToken from 0x7e60df042a9c0868\nimport FUSD from 0xe223d8a629e49c68\nimport Profile from 0x35717efbbce11c74\n\ntransaction(packTypeName: String, packTypeId:UInt64, packId: UInt64, amount: UFix64, signature:String) {\n    let packs: \u0026FindPack.Collection{FindPack.CollectionPublic}\n\n    let userPacks: Capability\u003c\u0026FindPack.Collection{NonFungibleToken.Receiver}\u003e\n    let salePrice: UFix64\n    let packsLeft: UInt64\n\n    let userFlowTokenVault: \u0026FlowToken.Vault\n\n    let paymentVault: @FungibleToken.Vault\n    let balanceBeforeTransfer:UFix64\n\n    prepare(account: AuthAccount) {\n\n        let findPackCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(FindPack.CollectionPublicPath)\n        if !findPackCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e( \u003c- FindPack.createEmptyCollection(), to: FindPack.CollectionStoragePath)\n            account.link\u003c\u0026FindPack.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                FindPack.CollectionPublicPath,\n                target: FindPack.CollectionStoragePath\n            )\n        }\n\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:account.address.toString(), createdAt: \"find\")\n\n            //Add exising FUSD or create a new one and add it\n            let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n            if !fusdReceiver.check() {\n                let fusd \u003c- FUSD.createEmptyVault()\n                account.save(\u003c- fusd, to: /storage/fusdVault)\n                account.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n                account.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n            }\n\n            let fusdWallet=Profile.Wallet(\n                name:\"FUSD\", \n                receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver),\n                balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance),\n                accept: Type\u003c@FUSD.Vault\u003e(),\n                names: [\"fusd\", \"stablecoin\"]\n            )\n\n            profile.addWallet(fusdWallet)\n\n            let flowWallet=Profile.Wallet(\n                name:\"Flow\", \n                receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver),\n                balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance),\n                accept: Type\u003c@FlowToken.Vault\u003e(),\n                names: [\"flow\"]\n            )\n            profile.addWallet(flowWallet)\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n\n\n        }\n\n        self.userPacks=account.getCapability\u003c\u0026FindPack.Collection{NonFungibleToken.Receiver}\u003e(FindPack.CollectionPublicPath)\n        self.packs=FindPack.getPacksCollection(packTypeName: packTypeName, packTypeId:packTypeId)\n\n        self.salePrice= FindPack.getCurrentPrice(packTypeName: packTypeName, packTypeId:packTypeId, user:account.address) ?? panic (\"Cannot buy the pack now\") \n\n        self.packsLeft= UInt64(self.packs.getPacksLeft())\n\n\n        self.userFlowTokenVault = account.borrow\u003c\u0026FlowToken.Vault\u003e(from: /storage/flowTokenVault) ?? panic(\"Cannot borrow FlowToken vault from account storage\")\n        self.balanceBeforeTransfer = self.userFlowTokenVault.balance\n\n        if self.balanceBeforeTransfer \u003c amount {\n            panic(\"Your account does not have enough funds has \".concat(self.balanceBeforeTransfer.toString()).concat(\" needs \").concat(amount.toString()))\n        }\n        self.paymentVault \u003c- self.userFlowTokenVault.withdraw(amount: amount)\n    }\n\n    pre {\n        self.salePrice == amount: \"unexpected sending amount\"\n        self.packs.contains(packId): \"The pack does not exist. ID : \".concat(packId.toString())\n        self.userPacks.check() : \"User need a receiver to put the pack in\"\n    }\n\n    execute {\n        self.packs.buyWithSignature(packId:packId, signature: signature, vault: \u003c- self.paymentVault, collectionCapability: self.userPacks)\n    }\n\n}",
               "spec": {
                  "order": [
                     "packTypeName",
                     "packTypeId",
                     "packId",
                     "amount",
                     "signature"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "packId": "UInt64",
                     "packTypeId": "UInt64",
                     "packTypeName": "String",
                     "signature": "String"
                  }
               }
            },
            "buyForSaleMultiple": {
               "code": "import FUSD from 0xe223d8a629e49c68\nimport FindMarket from 0x35717efbbce11c74\nimport FindMarketSale from 0x35717efbbce11c74\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport NFTCatalog from 0x324c34e1c517e4db\nimport FINDNFTCatalog from 0x35717efbbce11c74\nimport FTRegistry from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FIND from 0x35717efbbce11c74\n\ntransaction(marketplace:Address, users: [Address], ids: [AnyStruct], amounts: [UFix64]) {\n\n    let targetCapability : [Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e]\n    var walletReference : [\u0026FungibleToken.Vault]\n\n    let saleItems: [\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}]\n    let leaseNames: [String]\n    let leaseBidReference: \u0026FIND.BidCollection\n    var totalPrice : UFix64\n    let prices : [UFix64]\n    let buyer : Address\n\n    prepare(account: AuthAccount) {\n\n        if users.length != ids.length {\n            panic(\"The array length of users and ids should be the same\")\n        }\n\n        var counter = 0\n        self.walletReference= []\n        self.targetCapability = []\n\n        self.saleItems = []\n        let nfts : {String : NFTCatalog.NFTCollectionData} = {}\n        let fts : {String : FTRegistry.FTInfo} = {}\n        let saleItems : {Address : \u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}} = {}\n\n        let saleItemType = Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let marketOption = FindMarket.getMarketOptionFromType(saleItemType)\n\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath)\n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        self.buyer = account.address\n        self.leaseNames = []\n        self.leaseBidReference = account.borrow\u003c\u0026FIND.BidCollection\u003e(from: FIND.BidStoragePath) ?? panic(\"Could not borrow reference to the bid collection!\" )\n\n        var vaultType : Type? = nil\n\n        self.totalPrice = 0.0\n        self.prices = []\n\n        while counter \u003c users.length {\n\n            let address=users[counter]\n\n            if let name = ids[counter] as? String {\n                let targetAddress = FIND.lookupAddress(name) ?? panic(\"Cannot look up address for name : \".concat(name))\n                let leaseCap = getAccount(targetAddress).getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n                let leaseRef = leaseCap.borrow() ?? panic(\"Cannot borrow reference from name owner. Name : \".concat(name))\n                let nameInfo = leaseRef.getLease(name)!\n                let price = nameInfo.salePrice ?? panic(\"Name is not listed for sale. Name : \".concat(name))\n                self.prices.append(price)\n                self.leaseNames.append(name)\n\n                self.walletReference.append(\n                    account.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault) ?? panic(\"No suitable wallet linked for this account\")\n                )\n            }\n\n            if let id = ids[counter] as? UInt64 {\n                if saleItems[address] == nil {\n                    let saleItem = getAccount(address).getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath).borrow() ?? panic(\"cannot find target sale item cap. ID : \".concat(id.toString()))\n                    self.saleItems.append(saleItem)\n                    saleItems[address] = saleItem\n                } else {\n                    self.saleItems.append(saleItems[address]!)\n                }\n\n                let item=saleItems[address]!.borrowSaleItem(id)\n\n                self.prices.append(item.getBalance())\n                self.totalPrice = self.totalPrice + self.prices[counter]\n\n                var nft : NFTCatalog.NFTCollectionData? = nil\n                var ft : FTRegistry.FTInfo? = nil\n                let nftIdentifier = item.getItemType().identifier\n                let ftIdentifier = item.getFtType().identifier\n\n                if nfts[nftIdentifier] != nil {\n                    nft = nfts[nftIdentifier]\n                } else {\n                    let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier))\n                    let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])!\n                    nft = collection.collectionData\n                    nfts[nftIdentifier] = nft\n                }\n\n                if fts[ftIdentifier] != nil {\n                    ft = fts[ftIdentifier]\n                } else {\n                    ft = FTRegistry.getFTInfo(ftIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftIdentifier))\n                    fts[ftIdentifier] = ft\n                }\n\n                self.walletReference.append(\n                    account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft!.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n                )\n\n                var targetCapability= account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(nft!.publicPath)\n                /* Check for nftCapability */\n                if !targetCapability.check() {\n                    let cd = item.getNFTCollectionData()\n                    // should use account.type here instead\n                    if account.type(at: cd.storagePath) != nil {\n                        let pathIdentifier = nft!.publicPath.toString()\n                        let findPath = PublicPath(identifier: pathIdentifier.slice(from: \"/public/\".length , upTo: pathIdentifier.length).concat(\"_FIND\"))!\n                        account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                            findPath,\n                            target: nft!.storagePath\n                        )\n                        targetCapability = account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(findPath)\n                    } else {\n                        account.save(\u003c- cd.createEmptyCollection(), to: cd.storagePath)\n                        account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.publicPath, target: cd.storagePath)\n                        account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.providerPath, target: cd.storagePath)\n                    }\n\n                }\n                self.targetCapability.append(targetCapability)\n            }\n            counter = counter + 1\n        }\n\n\n    }\n\n    execute {\n        var counter = 0\n        var nameCounter = 0\n        for i, input in ids {\n\n            if let name = input as? String {\n                if self.prices[i] != amounts[i] {\n                    panic(\"Please pass in the correct price of the name. Required : \".concat(self.prices[i].toString()).concat(\" . Name : \".concat(name)))\n                }\n                if self.walletReference[i].balance \u003c amounts[i] {\n                    panic(\"Your wallet does not have enough funds to pay for this name. Required : \".concat(self.prices[i].toString()).concat(\" . Name : \".concat(name)))\n                }\n\n                let vault \u003c- self.walletReference[i].withdraw(amount: self.prices[i]) as! @FUSD.Vault\n                self.leaseBidReference.bid(name: name, vault: \u003c- vault)\n                nameCounter = nameCounter + 1\n                continue\n            }\n\n            let id = input as! UInt64\n            if self.prices[i] != amounts[i] {\n                panic(\"Please pass in the correct price of the buy items. Required : \".concat(self.prices[i].toString()).concat(\" . saleItem ID : \".concat(id.toString())))\n            }\n            if self.walletReference[i].balance \u003c amounts[i] {\n                panic(\"Your wallet does not have enough funds to pay for this item. Required : \".concat(self.prices[i].toString()).concat(\" . saleItem ID : \".concat(id.toString())))\n            }\n\n            self.saleItems[counter].buy(id:id, vault: \u003c- self.walletReference[i].withdraw(amount: amounts[i])\n            , nftCap: self.targetCapability[counter])\n            counter = counter + 1\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "users",
                     "ids",
                     "amounts"
                  ],
                  "parameters": {
                     "amounts": "[UFix64]",
                     "ids": "[AnyStruct]",
                     "marketplace": "Address",
                     "users": "[Address]"
                  }
               }
            },
            "buyLeaseForSale": {
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FTRegistry from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FIND from 0x35717efbbce11c74\nimport FindLeaseMarketSale from 0x35717efbbce11c74\nimport FindLeaseMarket from 0x35717efbbce11c74\n\ntransaction(leaseName: String, amount: UFix64) {\n\n    let walletReference : \u0026FungibleToken.Vault\n\n    let saleItemsCap: Capability\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e\n    let buyer: Address\n\n    prepare(account: AuthAccount) {\n\n        let resolveAddress = FIND.resolve(leaseName)\n        if resolveAddress == nil {\n            panic(\"The address input is not a valid name nor address. Input : \".concat(leaseName))\n        }\n        let address = resolveAddress!\n        let leaseMarketplace = FindMarket.getFindTenantAddress()\n        let leaseTenantCapability= FindMarket.getTenantCapability(leaseMarketplace)!\n        let leaseTenant = leaseTenantCapability.borrow()!\n\n        let leaseSaleItemType= Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()\n        let leasePublicPath=leaseTenant.getPublicPath(leaseSaleItemType)\n        let leaseStoragePath= leaseTenant.getStoragePath(leaseSaleItemType)\n        let leaseSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath)\n        if !leaseSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketSale.SaleItemCollection\u003e(\u003c- FindLeaseMarketSale.createEmptySaleItemCollection(leaseTenantCapability), to: leaseStoragePath)\n            account.link\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath, target: leaseStoragePath)\n        }\n\n        self.saleItemsCap= getAccount(address).getCapability\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath)\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e())\n\n        let item= FindLeaseMarket.assertOperationValid(tenant: leaseMarketplace, name: leaseName, marketOption: marketOption)\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n\n        self.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n        self.buyer = account.address\n    }\n\n    pre {\n        self.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount)\n        self.saleItemsCap.borrow()!.buy(name:leaseName, vault: \u003c- vault, to: self.buyer)\n    }\n}",
               "spec": {
                  "order": [
                     "leaseName",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "leaseName": "String"
                  }
               }
            },
            "buyLeaseForSaleDapper": {
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FTRegistry from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FIND from 0x35717efbbce11c74\nimport Profile from 0x35717efbbce11c74\nimport FindLeaseMarketSale from 0x35717efbbce11c74\nimport FindLeaseMarket from 0x35717efbbce11c74\n\ntransaction(sellerAccount: Address, leaseName: String, amount: UFix64) {\n\n    let to : Address\n    let walletReference : \u0026FungibleToken.Vault\n\n    let saleItemCollection: \u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\n    let balanceBeforeTransfer: UFix64\n\n    prepare(dapper: AuthAccount, account: AuthAccount) {\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath) ?? panic(\"You do not have a profile set up, initialize the user first\")\n\n        let address = FIND.resolve(leaseName) ?? panic(\"The address input is not a valid name nor address. Input : \".concat(leaseName))\n\n        if address != sellerAccount {\n            panic(\"address does not resolve to seller\")\n        }\n\n        let leaseMarketplace = FindMarket.getTenantAddress(\"find\") ?? panic(\"Cannot find find tenant\")\n        let saleItemsCap= FindLeaseMarketSale.getSaleItemCapability(marketplace: leaseMarketplace, user:address) ?? panic(\"cannot find sale item cap for find\")\n\n        let leaseTenantCapability= FindMarket.getTenantCapability(leaseMarketplace)!\n        let leaseTenant = leaseTenantCapability.borrow()!\n\n        let leaseSaleItemType= Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()\n        let leasePublicPath=FindMarket.getPublicPath(leaseSaleItemType, name: \"find\")\n        let leaseStoragePath= FindMarket.getStoragePath(leaseSaleItemType, name:\"find\")\n        let leaseSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath)\n        if !leaseSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketSale.SaleItemCollection\u003e(\u003c- FindLeaseMarketSale.createEmptySaleItemCollection(leaseTenantCapability), to: leaseStoragePath)\n            account.link\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath, target: leaseStoragePath)\n        }\n\n        self.to= account.address\n\n        self.saleItemCollection = saleItemsCap.borrow()!\n        let item = self.saleItemCollection.borrowSaleItem(leaseName)\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n        self.walletReference = dapper.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n        self.balanceBeforeTransfer = self.walletReference.balance\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount)\n        self.saleItemCollection.buy(name:leaseName, vault: \u003c- vault, to: self.to)\n    }\n\n    // Check that all dapper Coin was routed back to Dapper\n    post {\n        self.walletReference.balance == self.balanceBeforeTransfer: \"Dapper Coin leakage\"\n    }\n}",
               "spec": {
                  "order": [
                     "sellerAccount",
                     "leaseName",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "leaseName": "String",
                     "sellerAccount": "Address"
                  }
               }
            },
            "buyMultipleNFTForSale": {
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FindMarketSale from 0x35717efbbce11c74\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport NFTCatalog from 0x324c34e1c517e4db\nimport FINDNFTCatalog from 0x35717efbbce11c74\nimport FTRegistry from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\n\ntransaction(marketplace:Address, users: [Address], ids: [UInt64], amounts: [UFix64]) {\n\n    let targetCapability : [Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e]\n    var walletReference : [\u0026FungibleToken.Vault]\n\n    let saleItems: [\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}]\n    var totalPrice : UFix64\n    let prices : [UFix64]\n    prepare(account: AuthAccount) {\n\n        if users.length != ids.length {\n            panic(\"The array length of users and ids should be the same\")\n        }\n\n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n\n        var counter = 0\n        self.walletReference= []\n        self.targetCapability = []\n\n        self.saleItems = []\n        let nfts : {String : NFTCatalog.NFTCollectionData} = {}\n        let fts : {String : FTRegistry.FTInfo} = {}\n        let saleItems : {Address : \u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}} = {}\n\n        let saleItemType = Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let marketOption = FindMarket.getMarketOptionFromType(saleItemType)\n\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        var vaultType : Type? = nil\n\n        self.totalPrice = 0.0\n        self.prices = []\n\n        while counter \u003c users.length {\n\n            let address=users[counter]\n\n            if saleItems[address] == nil {\n                let saleItem = getAccount(address).getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath).borrow() ?? panic(\"cannot find sale item cap\")\n                self.saleItems.append(saleItem)\n                saleItems[address] = saleItem \n            } else {\n                self.saleItems.append(saleItems[address]!)\n            }\n\n\n            // let item= FindMarket.assertOperationValid(tenant: marketplace, address: address, marketOption: marketOption, id: ids[counter])\n            let item=saleItems[address]!.borrowSaleItem(ids[counter])\n\n            self.prices.append(item.getBalance())\n            self.totalPrice = self.totalPrice + self.prices[counter]\n\n            var nft : NFTCatalog.NFTCollectionData? = nil\n            var ft : FTRegistry.FTInfo? = nil\n            let nftIdentifier = item.getItemType().identifier\n            let ftIdentifier = item.getFtType().identifier\n\n            if nfts[nftIdentifier] != nil {\n                nft = nfts[nftIdentifier]\n            } else {\n                let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier)) \n                let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n                nft = collection.collectionData\n                nfts[nftIdentifier] = nft\n            }\n\n            if fts[ftIdentifier] != nil {\n                ft = fts[ftIdentifier]\n            } else {\n                ft = FTRegistry.getFTInfo(ftIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftIdentifier))\n                fts[ftIdentifier] = ft \n            }\n\n            self.walletReference.append(\n                account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft!.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n            )\n\n            var targetCapability= account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(nft!.publicPath)\n            /* Check for nftCapability */\n            if !targetCapability.check() {\n                let cd = item.getNFTCollectionData()\n                // should use account.type here instead\n                if account.type(at: cd.storagePath) != nil {\n                    let pathIdentifier = nft!.publicPath.toString()\n                    let findPath = PublicPath(identifier: pathIdentifier.slice(from: \"/public/\".length , upTo: pathIdentifier.length).concat(\"_FIND\"))!\n                    account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                        findPath,\n                        target: nft!.storagePath\n                    )\n                    targetCapability = account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(findPath)\n                } else {\n                    account.save(\u003c- cd.createEmptyCollection(), to: cd.storagePath)\n                    account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.publicPath, target: cd.storagePath)\n                    account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.providerPath, target: cd.storagePath)\n                }\n\n            }\n            self.targetCapability.append(targetCapability)\n            counter = counter + 1\n        }\n\n\n    }\n\n    execute {\n        var counter = 0\n        while counter \u003c users.length {\n            if self.prices[counter] != amounts[counter] {\n                panic(\"Please pass in the correct price of the buy items. Required : \".concat(self.prices[counter].toString()).concat(\" . saleItem ID : \".concat(ids[counter].toString())))\n            }\n            if self.walletReference[counter].balance \u003c amounts[counter] {\n                panic(\"Your wallet does not have enough funds to pay for this item. Required : \".concat(self.prices[counter].toString()).concat(\" . saleItem ID : \".concat(ids[counter].toString())))\n            }\n\n            self.saleItems[counter].buy(id:ids[counter], vault: \u003c- self.walletReference[counter].withdraw(amount: amounts[counter]) \n            , nftCap: self.targetCapability[counter])\n            counter = counter + 1\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "users",
                     "ids",
                     "amounts"
                  ],
                  "parameters": {
                     "amounts": "[UFix64]",
                     "ids": "[UInt64]",
                     "marketplace": "Address",
                     "users": "[Address]"
                  }
               }
            },
            "buyMultipleNFTForSaleDapper": {
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FindMarketSale from 0x35717efbbce11c74\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport NFTCatalog from 0x324c34e1c517e4db\nimport FINDNFTCatalog from 0x35717efbbce11c74\nimport FTRegistry from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\n\ntransaction(marketplace:Address, users: [Address], ids: [UInt64], amounts: [UFix64]) {\n\n    let targetCapability : [Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e]\n    var walletReference : [\u0026FungibleToken.Vault]\n    let walletBalance : {Type : UFix64}\n\n    let saleItems: [\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}]\n    var totalPrice : UFix64\n    let prices : [UFix64]\n    prepare(dapper: AuthAccount, account: AuthAccount) {\n\n        if users.length != ids.length {\n            panic(\"The array length of users and ids should be the same\")\n        }\n\n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n\n        var counter = 0\n        self.walletReference= []\n        self.targetCapability = []\n        self.walletBalance = {}\n\n        self.saleItems = []\n        let nfts : {String : NFTCatalog.NFTCollectionData} = {}\n        let fts : {String : FTRegistry.FTInfo} = {}\n        let saleItems : {Address : \u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}} = {}\n\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketSale.SaleItemCollection\u003e())\n\n        let saleItemType = Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath)\n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n        var vaultType : Type? = nil\n\n        self.totalPrice = 0.0\n        self.prices = []\n\n        while counter \u003c users.length {\n\n            let address=users[counter]\n\n            if saleItems[address] == nil {\n                let saleItem = getAccount(address).getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath).borrow() ?? panic(\"cannot find sale item cap\")\n                self.saleItems.append(saleItem)\n                saleItems[address] = saleItem\n            } else {\n                self.saleItems.append(saleItems[address]!)\n            }\n\n\n            // let item= FindMarket.assertOperationValid(tenant: marketplace, address: address, marketOption: marketOption, id: ids[counter])\n            let item=saleItems[address]!.borrowSaleItem(ids[counter])\n\n            self.prices.append(item.getBalance())\n            self.totalPrice = self.totalPrice + self.prices[counter]\n\n            var nft : NFTCatalog.NFTCollectionData? = nil\n            var ft : FTRegistry.FTInfo? = nil\n            let nftIdentifier = item.getItemType().identifier\n            let ftIdentifier = item.getFtType().identifier\n\n            if nfts[nftIdentifier] != nil {\n                nft = nfts[nftIdentifier]\n            } else {\n                let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier))\n                let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])!\n                nft = collection.collectionData\n                nfts[nftIdentifier] = nft\n            }\n\n            if fts[ftIdentifier] != nil {\n                ft = fts[ftIdentifier]\n            } else {\n                ft = FTRegistry.getFTInfo(ftIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftIdentifier))\n                fts[ftIdentifier] = ft\n            }\n\n            let dapperVault = dapper.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft!.vaultPath) ?? panic(\"Cannot borrow Dapper Coin Vault : \".concat(ft!.type.identifier))\n\n            self.walletReference.append(\n                dapperVault\n            )\n\n            if self.walletBalance[dapperVault.getType()] == nil {\n                self.walletBalance[dapperVault.getType()] = dapperVault.balance\n            }\n\n            var targetCapability= account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(nft!.publicPath)\n            /* Check for nftCapability */\n            if !targetCapability.check() {\n                let cd = item.getNFTCollectionData()\n                // should use account.type here instead\n                if account.type(at: cd.storagePath) != nil {\n                    let pathIdentifier = nft!.publicPath.toString()\n                    let findPath = PublicPath(identifier: pathIdentifier.slice(from: \"/public/\".length , upTo: pathIdentifier.length).concat(\"_FIND\"))!\n                    account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                        findPath,\n                        target: nft!.storagePath\n                    )\n                    targetCapability = account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(findPath)\n                } else {\n                    account.save(\u003c- cd.createEmptyCollection(), to: cd.storagePath)\n                    account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.publicPath, target: cd.storagePath)\n                    account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.providerPath, target: cd.storagePath)\n                }\n\n            }\n            self.targetCapability.append(targetCapability)\n            counter = counter + 1\n        }\n\n\n    }\n\n    execute {\n        var counter = 0\n        while counter \u003c users.length {\n            if self.prices[counter] != amounts[counter] {\n                panic(\"Please pass in the correct price of the buy items. Required : \".concat(self.prices[counter].toString()).concat(\" . saleItem ID : \".concat(ids[counter].toString())))\n            }\n            if self.walletReference[counter].balance \u003c amounts[counter] {\n                panic(\"Your wallet does not have enough funds to pay for this item. Required : \".concat(self.prices[counter].toString()).concat(\" . saleItem ID : \".concat(ids[counter].toString())))\n            }\n\n            self.saleItems[counter].buy(id:ids[counter], vault: \u003c- self.walletReference[counter].withdraw(amount: amounts[counter]) , nftCap: self.targetCapability[counter])\n            counter = counter + 1\n        }\n\n        // post\n        for vault in self.walletReference {\n            if vault.balance != self.walletBalance[vault.getType()] {\n                panic(\"Dapper Coin Leakage : \".concat(vault.getType().identifier))\n            }\n        }\n    }\n\n\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "users",
                     "ids",
                     "amounts"
                  ],
                  "parameters": {
                     "amounts": "[UFix64]",
                     "ids": "[UInt64]",
                     "marketplace": "Address",
                     "users": "[Address]"
                  }
               }
            },
            "buyNFTForSale": {
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FindMarketSale from 0x35717efbbce11c74\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FINDNFTCatalog from 0x35717efbbce11c74\nimport FTRegistry from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FIND from 0x35717efbbce11c74\ntransaction(marketplace:Address, user: String, id: UInt64, amount: UFix64) {\n\n    var targetCapability : Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e\n    let walletReference : \u0026FungibleToken.Vault\n\n    let saleItemsCap: Capability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic}\u003e\n\n    prepare(account: AuthAccount) {\n\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath)\n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        let resolveAddress = FIND.resolve(user)\n        if resolveAddress == nil {\n            panic(\"The address input is not a valid name nor address. Input : \".concat(user))\n        }\n        let address = resolveAddress!\n        self.saleItemsCap= FindMarketSale.getSaleItemCapability(marketplace: marketplace, user:address) ?? panic(\"cannot find sale item cap\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketSale.SaleItem\u003e())\n\n        let item= FindMarket.assertOperationValid(tenant: marketplace, address: address, marketOption: marketOption, id: id)\n\n        let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: item.getItemType().identifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(item.getItemType().identifier))\n        let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])!\n        let nft = collection.collectionData\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n\n        self.targetCapability= account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(nft.publicPath)\n        /* Check for nftCapability */\n        if !self.targetCapability.check() {\n            let cd = item.getNFTCollectionData()\n            // should use account.type here instead\n            if account.type(at: cd.storagePath) != nil {\n                let pathIdentifier = nft.publicPath.toString()\n                let findPath = PublicPath(identifier: pathIdentifier.slice(from: \"/public/\".length , upTo: pathIdentifier.length).concat(\"_FIND\"))!\n                account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                    findPath,\n                    target: nft.storagePath\n                )\n                self.targetCapability = account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(findPath)\n            } else {\n                account.save(\u003c- cd.createEmptyCollection(), to: cd.storagePath)\n                account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.publicPath, target: cd.storagePath)\n                account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.providerPath, target: cd.storagePath)\n            }\n\n        }\n\n        self.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n    }\n\n    pre {\n        self.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount)\n        self.saleItemsCap.borrow()!.buy(id:id, vault: \u003c- vault, nftCap: self.targetCapability)\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "user",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64",
                     "marketplace": "Address",
                     "user": "String"
                  }
               }
            },
            "buyNFTForSaleDapper": {
               "code": "import FindMarket from 0x35717efbbce11c74\nimport Profile from 0x35717efbbce11c74\nimport FindMarketSale from 0x35717efbbce11c74\nimport NFTCatalog from 0x324c34e1c517e4db\nimport FINDNFTCatalog from 0x35717efbbce11c74\nimport FTRegistry from 0x35717efbbce11c74\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FungibleToken from 0x9a0766d93b6608b7\nimport DapperStorageRent from 0x43ee8c22fcf94ea3\nimport TopShot from 0x877931736ee77cff\n\n//first argument is the address to the merchant that gets the funds\ntransaction(address: Address, marketplace:Address, id: UInt64, amount: UFix64) {\n\n    let targetCapability : Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e\n    let walletReference : \u0026FungibleToken.Vault\n    let receiver : Address\n\n    let saleItemsCap: Capability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic}\u003e\n    let balanceBeforeTransfer: UFix64\n    prepare(dapper: AuthAccount, account: AuthAccount) {\n        self.receiver=account.address\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath)\n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        self.saleItemsCap= FindMarketSale.getSaleItemCapability(marketplace: marketplace, user:address) ?? panic(\"cannot find sale item cap\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketSale.SaleItemCollection\u003e())\n\n        //we do some security check to verify that this tenant can do this operation. This will ensure that the onefootball tenant can only sell using DUC and not some other token. But we can change this with transactions later and not have to modify code/transactions\n        let item= FindMarket.assertOperationValid(tenant: marketplace, address: address, marketOption: marketOption, id: id)\n           let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: item.getItemType().identifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(item.getItemType().identifier))\n        let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])!\n        let nft = collection.collectionData\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n\n        self.targetCapability= account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(nft.publicPath)\n\n        if !self.targetCapability.check() {\n            let cd = item.getNFTCollectionData()\n            if let storage = account.borrow\u003c\u0026AnyResource\u003e(from: cd.storagePath) {\n                if let st = account.borrow\u003c\u0026TopShot.Collection\u003e(from: cd.storagePath) {\n                    // here means the topShot is not linked in the way it should be. We can relink that for our use\n                    account.unlink(cd.publicPath)\n                    account.link\u003c\u0026TopShot.Collection{TopShot.MomentCollectionPublic,NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}\u003e(cd.publicPath, target: cd.storagePath)\n                } else {\n                    panic(\"This collection public link is not set up properly.\")\n                }\n            } else {\n                account.save(\u003c- cd.createEmptyCollection(), to: cd.storagePath)\n                account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.publicPath, target: cd.storagePath)\n                account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.providerPath, target: cd.storagePath)\n            }\n        }\n\n        self.walletReference = dapper.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n        self.balanceBeforeTransfer = self.walletReference.balance\n    }\n\n    pre {\n        self.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount)\n        self.saleItemsCap.borrow()!.buy(id:id, vault: \u003c- vault, nftCap: self.targetCapability)\n        DapperStorageRent.tryRefill(self.receiver)\n    }\n\n    // Check that all dapper Coin was routed back to Dapper\n    post {\n        self.walletReference.balance == self.balanceBeforeTransfer: \"Dapper Coin leakage\"\n    }\n}",
               "spec": {
                  "order": [
                     "address",
                     "marketplace",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "address": "Address",
                     "amount": "UFix64",
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "cancelAllLeaseMarketAuctionSoft": {
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FindLeaseMarketAuctionSoft from 0x35717efbbce11c74\n\ntransaction() {\n\n    let saleItems : \u0026FindLeaseMarketAuctionSoft.SaleItemCollection?\n\n    prepare(account: AuthAccount) {\n        let leaseMarketplace = FindMarket.getFindTenantAddress()\n        let tenant = FindMarket.getTenant(leaseMarketplace)\n        self.saleItems= account.borrow\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e()))\n\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to the saleItem.\"\n    }\n\n    execute {\n        let leaseNames = self.saleItems!.getNameSales()\n        for lease in leaseNames {\n            self.saleItems!.cancel(lease)\n        }\n    }\n}",
               "spec": {
                  "order": [],
                  "parameters": {}
               }
            },
            "cancelAllLeaseMarketDirectOfferSoft": {
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FindLeaseMarketDirectOfferSoft from 0x35717efbbce11c74\n\ntransaction() {\n\n    let saleItems : \u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection?\n\n    prepare(account: AuthAccount) {\n\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenant=FindMarket.getTenant(marketplace)\n        self.saleItems= account.borrow\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e()))\n\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to saleItem.\"\n    }\n\n    execute{\n        let nameLeases = self.saleItems!.getNameSales()\n        for nameLease in nameLeases {\n            self.saleItems!.cancel(nameLease)\n        }\n    }\n\n}",
               "spec": {
                  "order": [],
                  "parameters": {}
               }
            },
            "cancelAllMarketAuctionEscrowed": {
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FindMarketAuctionEscrow from 0x35717efbbce11c74\n\ntransaction(marketplace:Address) {\n\n    let saleItems : \u0026FindMarketAuctionEscrow.SaleItemCollection?\n\n    prepare(account: AuthAccount) {\n        let tenant = FindMarket.getTenant(marketplace)\n        self.saleItems= account.borrow\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()))\n\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to the saleItem capability.\"\n    }\n\n    execute {\n        let ids = self.saleItems!.getIds()\n        for id in ids {\n            self.saleItems!.cancel(id)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace"
                  ],
                  "parameters": {
                     "marketplace": "Address"
                  }
               }
            },
            "cancelAllMarketAuctionSoft": {
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FindMarketAuctionSoft from 0x35717efbbce11c74\n\ntransaction(marketplace:Address) {\n\n    let saleItems : \u0026FindMarketAuctionSoft.SaleItemCollection?\n\n    prepare(account: AuthAccount) {\n        let tenant = FindMarket.getTenant(marketplace)\n        self.saleItems= account.borrow\u003c\u0026FindMarketAuctionSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()))\n\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to the saleItem.\"\n    }\n\n    execute {\n        let ids = self.saleItems!.getIds()\n        for id in ids {\n            self.saleItems!.cancel(id)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace"
                  ],
                  "parameters": {
                     "marketplace": "Address"
                  }
               }
            },
            "cancelAllMarketDirectOfferEscrowed": {
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FindMarketDirectOfferEscrow from 0x35717efbbce11c74\n\ntransaction(marketplace:Address) {\n\n    let saleItems : \u0026FindMarketDirectOfferEscrow.SaleItemCollection?\n\n    prepare(account: AuthAccount) {\n\n        let tenant=FindMarket.getTenant(marketplace)\n        self.saleItems= account.borrow\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()))\n\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to saleItem.\"\n    }\n\n    execute{\n        let ids = self.saleItems!.getIds()\n        for id in ids {\n            self.saleItems!.cancel(id)\n        }\n    }\n\n}",
               "spec": {
                  "order": [
                     "marketplace"
                  ],
                  "parameters": {
                     "marketplace": "Address"
                  }
               }
            },
            "cancelAllMarketDirectOfferSoft": {
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FindMarketDirectOfferSoft from 0x35717efbbce11c74\n\ntransaction(marketplace:Address) {\n\n    let saleItems : \u0026FindMarketDirectOfferSoft.SaleItemCollection?\n\n    prepare(account: AuthAccount) {\n\n        let tenant=FindMarket.getTenant(marketplace)\n        self.saleItems= account.borrow\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()))\n\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to saleItem.\"\n    }\n\n    execute{\n        let ids = self.saleItems!.getIds()\n        for id in ids {\n            self.saleItems!.cancel(id)\n        }\n    }\n\n}",
               "spec": {
                  "order": [
                     "marketplace"
                  ],
                  "parameters": {
                     "marketplace": "Address"
                  }
               }
            },
            "cancelAllMarketListings": {
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FindMarketDirectOfferEscrow from 0x35717efbbce11c74\nimport FindMarketAuctionEscrow from 0x35717efbbce11c74\nimport FindMarketAuctionSoft from 0x35717efbbce11c74\nimport FindMarketDirectOfferSoft from 0x35717efbbce11c74\nimport FindMarketSale from 0x35717efbbce11c74\n\ntransaction(marketplace:Address) {\n    prepare(account: AuthAccount) {\n\n        let tenant=FindMarket.getTenant(marketplace)\n\n        if let saleItems= account.borrow\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e())) {\n            var ids = saleItems.getIds()\n            for id in ids {\n                saleItems.cancel(id)\n            }\n        }\n\n        if let saleItem2= account.borrow\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e())) {\n            var ids = saleItem2.getIds()\n            for id in ids {\n                saleItem2.cancel(id)\n            }\n        }\n\n        if let saleItems3= account.borrow\u003c\u0026FindMarketAuctionSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e())) {\n            var ids = saleItems3.getIds()\n            for id in ids {\n                saleItems3.cancel(id)\n            }\n        }\n\n        if let saleItems4= account.borrow\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e())) {\n            var ids = saleItems4.getIds()\n            for id in ids {\n                saleItems4.cancel(id)\n            }\n        }\n\n        if let saleItems5= account.borrow\u003c\u0026FindMarketSale.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketSale.SaleItemCollection\u003e())) {\n            var ids = saleItems5.getIds()\n            for id in ids {\n                saleItems5.delist(id)\n            }\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace"
                  ],
                  "parameters": {
                     "marketplace": "Address"
                  }
               }
            },
            "cancelLeaseMarketAuctionSoft": {
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FindLeaseMarketAuctionSoft from 0x35717efbbce11c74\n\ntransaction(leaseNames: [String]) {\n\n    let saleItems : \u0026FindLeaseMarketAuctionSoft.SaleItemCollection?\n\n    prepare(account: AuthAccount) {\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenant=FindMarket.getTenant(marketplace)\n        self.saleItems= account.borrow\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e()))\n    }\n\n    pre{\n        self.saleItems != nil\n    }\n\n    execute{\n        for leaseName in leaseNames {\n            self.saleItems!.cancel(leaseName)\n        }\n    }\n\n}",
               "spec": {
                  "order": [
                     "leaseNames"
                  ],
                  "parameters": {
                     "leaseNames": "[String]"
                  }
               }
            },
            "cancelLeaseMarketDirectOfferSoft": {
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FindLeaseMarketDirectOfferSoft from 0x35717efbbce11c74\n\ntransaction(leaseNames: [String]) {\n\n    let saleItems : \u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection?\n\n    prepare(account: AuthAccount) {\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenant=FindMarket.getTenant(marketplace)\n        self.saleItems= account.borrow\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e()))\n\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute {\n        for leaseName in leaseNames {\n            self.saleItems!.cancel(leaseName)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "leaseNames"
                  ],
                  "parameters": {
                     "leaseNames": "[String]"
                  }
               }
            },
            "cancelMarketAuctionEscrowed": {
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FindMarketAuctionEscrow from 0x35717efbbce11c74\n\ntransaction(marketplace:Address, ids: [UInt64]) {\n\n    let saleItems : \u0026FindMarketAuctionEscrow.SaleItemCollection?\n\n    prepare(account: AuthAccount) {\n\n        let tenant=FindMarket.getTenant(marketplace)\n        self.saleItems= account.borrow\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()))\n\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        for id in ids {\n            self.saleItems!.cancel(id)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "ids"
                  ],
                  "parameters": {
                     "ids": "[UInt64]",
                     "marketplace": "Address"
                  }
               }
            },
            "cancelMarketAuctionSoft": {
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FindMarketAuctionSoft from 0x35717efbbce11c74\n\ntransaction(marketplace:Address, ids: [UInt64]) {\n\n    let saleItems : \u0026FindMarketAuctionSoft.SaleItemCollection?\n\n    prepare(account: AuthAccount) {\n        let tenant=FindMarket.getTenant(marketplace)\n        self.saleItems= account.borrow\u003c\u0026FindMarketAuctionSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()))\n    }\n\n    pre{\n        self.saleItems != nil \n    }\n\n    execute{\n        for id in ids {\n            self.saleItems!.cancel(id)\n        }\n    }\n\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "ids"
                  ],
                  "parameters": {
                     "ids": "[UInt64]",
                     "marketplace": "Address"
                  }
               }
            },
            "cancelMarketDirectOfferEscrowed": {
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FindMarketDirectOfferEscrow from 0x35717efbbce11c74\n\ntransaction(marketplace:Address, ids: [UInt64]) {\n\n    let saleItems : \u0026FindMarketDirectOfferEscrow.SaleItemCollection?\n\n    prepare(account: AuthAccount) {\n\n        let tenant=FindMarket.getTenant(marketplace)\n        self.saleItems= account.borrow\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()))\n\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        for id in ids {\n            self.saleItems!.cancel(id)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "ids"
                  ],
                  "parameters": {
                     "ids": "[UInt64]",
                     "marketplace": "Address"
                  }
               }
            },
            "cancelMarketDirectOfferSoft": {
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FindMarketDirectOfferSoft from 0x35717efbbce11c74\n\ntransaction(marketplace:Address, ids: [UInt64]) {\n\n    let saleItems : \u0026FindMarketDirectOfferSoft.SaleItemCollection?\n\n    prepare(account: AuthAccount) {\n\n        let tenant=FindMarket.getTenant(marketplace)\n        self.saleItems= account.borrow\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()))\n\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute {\n        for id in ids {\n            self.saleItems!.cancel(id)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "ids"
                  ],
                  "parameters": {
                     "ids": "[UInt64]",
                     "marketplace": "Address"
                  }
               }
            },
            "cancelMarketListings": {
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FindMarketDirectOfferEscrow from 0x35717efbbce11c74\nimport FindMarketAuctionEscrow from 0x35717efbbce11c74\nimport FindMarketAuctionSoft from 0x35717efbbce11c74\nimport FindMarketDirectOfferSoft from 0x35717efbbce11c74\nimport FindMarketSale from 0x35717efbbce11c74\n\ntransaction(marketplace:Address, ids: {String : [UInt64]}) {\n    prepare(account: AuthAccount) {\n\n        let tenant=FindMarket.getTenant(marketplace)\n\n        var saleType = Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        if let ids = ids[FindMarket.getMarketOptionFromType(saleType)] {\n            let saleItems= account.borrow\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection\u003e(from: tenant.getStoragePath(saleType))!\n            for id in ids {\n                saleItems.cancel(id)\n            }\n        }\n\n        saleType = Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        if let ids = ids[FindMarket.getMarketOptionFromType(saleType)] {\n            let saleItems= account.borrow\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection\u003e(from: tenant.getStoragePath(saleType))!\n            for id in ids {\n                saleItems.cancel(id)\n            }\n        }\n\n        saleType = Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        if let ids = ids[FindMarket.getMarketOptionFromType(saleType)] {\n            let saleItems= account.borrow\u003c\u0026FindMarketAuctionSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(saleType))!\n            for id in ids {\n                saleItems.cancel(id)\n            }\n        }\n\n        saleType = Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n        if let ids = ids[FindMarket.getMarketOptionFromType(saleType)] {\n            let saleItems= account.borrow\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(saleType))!\n            for id in ids {\n                saleItems.cancel(id)\n            }\n        }\n\n        saleType = Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        if let ids = ids[FindMarket.getMarketOptionFromType(saleType)] {\n            let saleItems= account.borrow\u003c\u0026FindMarketSale.SaleItemCollection\u003e(from: tenant.getStoragePath(saleType))!\n            for id in ids {\n                saleItems.delist(id)\n            }\n        }\n\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "ids"
                  ],
                  "parameters": {
                     "ids": "{String: [UInt64]}",
                     "marketplace": "Address"
                  }
               }
            },
            "cancelNameAuction": {
               "code": "import FIND from 0x35717efbbce11c74\n\ntransaction(names: [String]) {\n\n    let finLeases : \u0026FIND.LeaseCollection?\n\n    prepare(account: AuthAccount) {\n        self.finLeases= account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)\n    }\n\n    pre{\n        self.finLeases != nil : \"Cannot borrow reference to find leases collection\"\n    }\n\n    execute {\n        for name in names {\n            self.finLeases!.cancel(name)\n            self.finLeases!.delistAuction(name)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "names"
                  ],
                  "parameters": {
                     "names": "[String]"
                  }
               }
            },
            "cancelNameBid": {
               "code": "import FIND from 0x35717efbbce11c74\n\ntransaction(names: [String]) {\n\n    let bids : \u0026FIND.BidCollection?\n\n    prepare(account: AuthAccount) {\n        self.bids = account.borrow\u003c\u0026FIND.BidCollection\u003e(from: FIND.BidStoragePath)\n    }\n\n    pre{\n        self.bids != nil : \"Cannot borrow reference to find bid collection\"\n    }\n\n    execute {\n        for name in names {\n            self.bids!.cancelBid(name)\n        }\n    }\n\n}",
               "spec": {
                  "order": [
                     "names"
                  ],
                  "parameters": {
                     "names": "[String]"
                  }
               }
            },
            "createCharity": {
               "code": "import NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport CharityNFT from 0x35717efbbce11c74\n\n//This transaction will prepare the art collection\ntransaction() {\n    prepare(account: AuthAccount) {\n\n        let stdCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath)\n        if !stdCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- CharityNFT.createEmptyCollection(), to: CharityNFT.CollectionStoragePath)\n            account.link\u003c\u0026{NonFungibleToken.CollectionPublic, MetadataViews.ResolverCollection}\u003e(CharityNFT.CollectionPublicPath, target: CharityNFT.CollectionStoragePath)\n        }\n\n        let charityCap = account.getCapability\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection)\n        if !charityCap.check() {\n            account.link\u003c\u0026{CharityNFT.CollectionPublic, MetadataViews.ResolverCollection}\u003e(/public/findCharityNFTCollection, target: CharityNFT.CollectionStoragePath)\n        }\n    }\n}",
               "spec": {
                  "order": [],
                  "parameters": {}
               }
            },
            "createProfile": {
               "code": "import FungibleToken from 0x9a0766d93b6608b7\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport FUSD from 0xe223d8a629e49c68\nimport FiatToken from 0xa983fecbed621163\nimport FlowToken from 0x7e60df042a9c0868\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FIND from 0x35717efbbce11c74\nimport FindPack from 0x35717efbbce11c74\nimport Profile from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\nimport FindMarketDirectOfferEscrow from 0x35717efbbce11c74\nimport Dandy from 0x35717efbbce11c74\nimport FindThoughts from 0x35717efbbce11c74\n\ntransaction(name: String) {\n    prepare(account: AuthAccount) {\n        //if we do not have a profile it might be stored under a different address so we will just remove it\n        let profileCapFirst = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if profileCapFirst.check() {\n            return \n        }\n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n        //SYNC with register\n        //Add exising FUSD or create a new one and add it\n        let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n        if !fusdReceiver.check() {\n            let fusd \u003c- FUSD.createEmptyVault()\n            account.save(\u003c- fusd, to: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n        }\n\n        let usdcCap = account.getCapability\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e(FiatToken.VaultReceiverPubPath)\n        if !usdcCap.check() {\n                account.save( \u003c-FiatToken.createEmptyVault(), to: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e( FiatToken.VaultReceiverPubPath, target: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FiatToken.ResourceId}\u003e( FiatToken.VaultUUIDPubPath, target: FiatToken.VaultStoragePath)\n                account.link\u003c\u0026FiatToken.Vault{FungibleToken.Balance}\u003e( FiatToken.VaultBalancePubPath, target:FiatToken.VaultStoragePath)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let dandyCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        let thoughtsCap= account.getCapability\u003c\u0026{FindThoughts.CollectionPublic}\u003e(FindThoughts.CollectionPublicPath)\n        if !thoughtsCap.check() {\n            account.save(\u003c- FindThoughts.createEmptyCollection(), to: FindThoughts.CollectionStoragePath)\n            account.link\u003c\u0026FindThoughts.Collection{FindThoughts.CollectionPublic , MetadataViews.ResolverCollection}\u003e(\n                FindThoughts.CollectionPublicPath,\n                target: FindThoughts.CollectionStoragePath\n            )\n        }\n\n        let findPackCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(FindPack.CollectionPublicPath)\n        if !findPackCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e( \u003c- FindPack.createEmptyCollection(), to: FindPack.CollectionStoragePath)\n            account.link\u003c\u0026FindPack.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                FindPack.CollectionPublicPath,\n                target: FindPack.CollectionStoragePath\n            )\n        }\n\n        var created=false\n        var updated=false\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        if !profile.hasWallet(\"Flow\") {\n            let flowWallet=Profile.Wallet( name:\"Flow\", receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), tags: [\"flow\"])\n    \n            profile.addWallet(flowWallet)\n            updated=true\n        }\n        if !profile.hasWallet(\"FUSD\") {\n            profile.addWallet(Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), tags: [\"fusd\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if !profile.hasWallet(\"USDC\") {\n            profile.addWallet(Profile.Wallet( name:\"USDC\", receiver:usdcCap, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(FiatToken.VaultBalancePubPath), accept: Type\u003c@FiatToken.Vault\u003e(), tags: [\"usdc\", \"stablecoin\"]))\n            updated=true\n        }\n\n         //If find name not set and we have a profile set it.\n        if profile.getFindName() == \"\" {\n            if let findName = FIND.reverseLookup(account.address) {\n                profile.setFindName(findName)\n                // If name is set, it will emit Updated Event, there is no need to emit another update event below. \n                updated=false\n            }\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else if updated {\n            profile.emitUpdatedEvent()\n        }\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let tenantCapability= FindMarket.getTenantCapability(FindMarket.getFindTenantAddress())!\n\n        let tenant = tenantCapability.borrow()!\n\n        let doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        let doeSalePublicPath=FindMarket.getPublicPath(doeSaleType, name: tenant.name)\n        let doeSaleStoragePath= FindMarket.getStoragePath(doeSaleType, name:tenant.name)\n        let doeSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n        if !doeSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n        }\n        //SYNC with register\n\n    }\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "createProfileDapper": {
               "code": "import FungibleToken from 0x9a0766d93b6608b7\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FIND from 0x35717efbbce11c74\nimport Dandy from 0x35717efbbce11c74\nimport Profile from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\nimport FindMarketDirectOfferSoft from 0x35717efbbce11c74\nimport DapperUtilityCoin from 0x82ec283f88a62e65\nimport FlowUtilityToken from 0x82ec283f88a62e65\nimport FindLeaseMarketDirectOfferSoft from 0x35717efbbce11c74\nimport FindLeaseMarket from 0x35717efbbce11c74\n\ntransaction(name: String) {\n    prepare(account: AuthAccount) {\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let dandyCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        var created=false\n        var updated=false\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        if !profile.hasWallet(\"DUC\") {\n            let ducReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver)\n            profile.addWallet(Profile.Wallet( name:\"DUC\", receiver:ducReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/dapperUtilityCoinBalance), accept: Type\u003c@DapperUtilityCoin.Vault\u003e(), tags: [\"duc\", \"dapperUtilityCoin\",\"dapper\"]))\n            updated=true\n        }\n\n        if !profile.hasWallet(\"FUT\") {\n            let futReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowUtilityTokenReceiver)\n            profile.addWallet(Profile.Wallet( name:\"FUT\", receiver:futReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowUtilityTokenBalance), accept: Type\u003c@FlowUtilityToken.Vault\u003e(), tags: [\"fut\", \"flowUtilityToken\",\"dapper\"]))\n            updated=true\n        }\n\n        profile.emitCreatedEvent()\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let tenantCapability= FindMarket.getTenantCapability(FindMarket.getFindTenantAddress())!\n\n        let tenant = tenantCapability.borrow()!\n\n        let dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n        let dosSalePublicPath=FindMarket.getPublicPath(dosSaleType, name: tenant.name)\n        let dosSaleStoragePath= FindMarket.getStoragePath(dosSaleType, name:tenant.name)\n        let dosSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath)\n        if !dosSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n        }\n\n        let leaseTenantCapability= FindMarket.getTenantCapability(FindMarket.getFindTenantAddress())!\n        let leaseTenant = leaseTenantCapability.borrow()!\n\n        let leaseDOSSaleItemType= Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e()\n        let leaseDOSPublicPath=leaseTenant.getPublicPath(leaseDOSSaleItemType)\n        let leaseDOSStoragePath= leaseTenant.getStoragePath(leaseDOSSaleItemType)\n        let leaseDOSSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath)\n        if !leaseDOSSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOSStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath, target: leaseDOSStoragePath)\n        }\n\n    }\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "deleteFindThoughts": {
               "code": "import FindThoughts from 0x35717efbbce11c74\n\ntransaction(ids: [UInt64]) {\n\n    let collection : \u0026FindThoughts.Collection\n\n    prepare(account: AuthAccount) {\n\n        self.collection=account.borrow\u003c\u0026FindThoughts.Collection\u003e(from: FindThoughts.CollectionStoragePath) ?? panic(\"Cannot borrow thoughts reference from path\")\n    }\n\n    execute {\n        for id in ids {\n            self.collection.delete(id)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "ids"
                  ],
                  "parameters": {
                     "ids": "[UInt64]"
                  }
               }
            },
            "delistAllLeaseSale": {
               "code": "import FindLeaseMarketSale from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\nimport FindLeaseMarket from 0x35717efbbce11c74\n\ntransaction() {\n    prepare(account: AuthAccount) {\n        // Get all the saleItems Id\n\n        let tenant = FindMarket.getTenant(FindMarket.getFindTenantAddress())\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindLeaseMarketSale.SaleItem\u003e())\n        let cap = FindLeaseMarket.getSaleItemCollectionCapability(tenantRef: tenant, marketOption: marketOption, address: account.address)\n        let ref = cap.borrow() ?? panic(\"Cannot borrow reference to the capability.\")\n\n        let listingType=Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()\n        let saleItems= account.borrow\u003c\u0026FindLeaseMarketSale.SaleItemCollection\u003e(from: tenant.getStoragePath(listingType))!\n        let leases = ref.getNameSales()\n        for lease in leases {\n            saleItems.delist(lease)\n        }\n    }\n}",
               "spec": {
                  "order": [],
                  "parameters": {}
               }
            },
            "delistAllNFTSale": {
               "code": "import FindMarketSale from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\n\ntransaction(marketplace:Address) {\n\n    let saleItems : \u0026FindMarketSale.SaleItemCollection?\n\n    prepare(account: AuthAccount) {\n        let tenant = FindMarket.getTenant(marketplace)\n        self.saleItems= account.borrow\u003c\u0026FindMarketSale.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketSale.SaleItemCollection\u003e())) \n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        let ids = self.saleItems!.getIds()\n        for id in ids {\n            self.saleItems!.delist(id)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace"
                  ],
                  "parameters": {
                     "marketplace": "Address"
                  }
               }
            },
            "delistAllNameSale": {
               "code": "import FIND from 0x35717efbbce11c74\n\ntransaction() {\n\n    let finLeases : \u0026FIND.LeaseCollection?\n\n    prepare(acct: AuthAccount) {\n        self.finLeases= acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)\n\n    }\n\n    pre{\n        self.finLeases != nil : \"Cannot borrow reference to find lease collection\"\n    }\n\n    execute{\n        let leases = self.finLeases!.getLeaseInformation()\n        for lease in leases {\n            if lease.salePrice != nil {\n                self.finLeases!.delistSale(lease.name)\n            }\n        }\n    }\n}",
               "spec": {
                  "order": [],
                  "parameters": {}
               }
            },
            "delistLeaseSale": {
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FindLeaseMarketSale from 0x35717efbbce11c74\n\ntransaction(leases: [String]) {\n    let saleItems : \u0026FindLeaseMarketSale.SaleItemCollection?\n\n    prepare(account: AuthAccount) {\n\n        let tenant=FindMarket.getTenant(FindMarket.getFindTenantAddress())\n        self.saleItems= account.borrow\u003c\u0026FindLeaseMarketSale.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()))\n\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        for lease in leases {\n            self.saleItems!.delist(lease)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "leases"
                  ],
                  "parameters": {
                     "leases": "[String]"
                  }
               }
            },
            "delistNFTSale": {
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FindMarketSale from 0x35717efbbce11c74\n\n//Remove one or more listings from a marketplace\ntransaction(marketplace:Address, ids: [UInt64]) {\n\n    let saleItems : \u0026FindMarketSale.SaleItemCollection?\n\n    prepare(account: AuthAccount) {\n        let tenant=FindMarket.getTenant(marketplace)\n        self.saleItems= account.borrow\u003c\u0026FindMarketSale.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketSale.SaleItemCollection\u003e()))\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        for id in ids {\n            self.saleItems!.delist(id)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "ids"
                  ],
                  "parameters": {
                     "ids": "[UInt64]",
                     "marketplace": "Address"
                  }
               }
            },
            "delistNameSale": {
               "code": "import FIND from 0x35717efbbce11c74\n\ntransaction(names: [String]) {\n\n    let finLeases : \u0026FIND.LeaseCollection?\n\n    prepare(acct: AuthAccount) {\n        self.finLeases= acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)\n    }\n\n    pre{\n        self.finLeases != nil : \"Cannot borrow reference to find lease collection\"\n    }\n\n    execute{\n        for name in names {\n            self.finLeases!.delistSale(name)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "names"
                  ],
                  "parameters": {
                     "names": "[String]"
                  }
               }
            },
            "editFindThought": {
               "code": "import FindThoughts from 0x35717efbbce11c74\n\ntransaction(id: UInt64, header: String , body: String, tags: [String]) {\n\n    let collection : \u0026FindThoughts.Collection\n\n    prepare(account: AuthAccount) {\n\n        self.collection=account.borrow\u003c\u0026FindThoughts.Collection\u003e(from: FindThoughts.CollectionStoragePath) ?? panic(\"Cannot borrow thoughts reference from path\")\n    }\n\n    execute {\n        let thought = self.collection.borrow(id)\n        thought.edit(header: header , body: body, tags: tags)\n    }\n}",
               "spec": {
                  "order": [
                     "id",
                     "header",
                     "body",
                     "tags"
                  ],
                  "parameters": {
                     "body": "String",
                     "header": "String",
                     "id": "UInt64",
                     "tags": "[String]"
                  }
               }
            },
            "editProfile": {
               "code": "import FungibleToken from 0x9a0766d93b6608b7\nimport FUSD from 0xe223d8a629e49c68\nimport FlowToken from 0x7e60df042a9c0868\nimport FIND from 0x35717efbbce11c74\nimport Profile from 0x35717efbbce11c74\n\ntransaction(name:String, description: String, avatar: String, tags:[String], allowStoringFollowers: Bool, linkTitles : {String: String}, linkTypes: {String:String}, linkUrls : {String:String}, removeLinks : [String]) {\n    \n    let profile : \u0026Profile.User\n\n    prepare(account: AuthAccount) {\n\n        self.profile =account.borrow\u003c\u0026Profile.User\u003e(from:Profile.storagePath) ?? panic(\"Cannot borrow reference to profile\")\n\n        //Add exising FUSD or create a new one and add it\n        let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n        if !fusdReceiver.check() {\n            let fusd \u003c- FUSD.createEmptyVault()\n            account.save(\u003c- fusd, to: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n        }\n\n\n        var hasFusdWallet=false\n        var hasFlowWallet=false\n        let wallets=self.profile.getWallets()\n        for wallet in wallets {\n            if wallet.name==\"FUSD\" {\n                hasFusdWallet=true\n            }\n\n            if wallet.name ==\"Flow\" {\n                hasFlowWallet=true\n            }\n        }\n\n        if !hasFlowWallet {\n            let flowWallet=Profile.Wallet(\n                name:\"Flow\", \n                receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver),\n                balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance),\n                accept: Type\u003c@FlowToken.Vault\u003e(),\n                tags: [\"flow\"]\n            )\n            self.profile.addWallet(flowWallet)\n        }\n\n        if !hasFusdWallet {\n            let fusdWallet=Profile.Wallet(\n                name:\"FUSD\", \n                receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver),\n                balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance),\n                accept: Type\u003c@FUSD.Vault\u003e(),\n                tags: [\"fusd\", \"stablecoin\"]\n            )\n            self.profile.addWallet(fusdWallet)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n    }\n\n    execute{\n        self.profile!.setName(name)\n        self.profile!.setDescription(description)\n        self.profile!.setAvatar(avatar)\n        self.profile!.setTags(tags)\n\n        for link in removeLinks {\n            self.profile!.removeLink(link)\n        }\n\n        for titleName in linkTitles.keys {\n            let title=linkTitles[titleName]!\n            let url = linkUrls[titleName]!\n            let type = linkTypes[titleName]!\n\n            self.profile!.addLinkWithName(name:titleName, link: Profile.Link(title: title, type: type, url: url))\n        }\n        self.profile!.emitUpdatedEvent()\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "description",
                     "avatar",
                     "tags",
                     "allowStoringFollowers",
                     "linkTitles",
                     "linkTypes",
                     "linkUrls",
                     "removeLinks"
                  ],
                  "parameters": {
                     "allowStoringFollowers": "Bool",
                     "avatar": "String",
                     "description": "String",
                     "linkTitles": "{String: String}",
                     "linkTypes": "{String: String}",
                     "linkUrls": "{String: String}",
                     "name": "String",
                     "removeLinks": "[String]",
                     "tags": "[String]"
                  }
               }
            },
            "editProfileDapper": {
               "code": "import FIND from 0x35717efbbce11c74\nimport Profile from 0x35717efbbce11c74\n\ntransaction(name:String, description: String, avatar: String, tags:[String], allowStoringFollowers: Bool, linkTitles : {String: String}, linkTypes: {String:String}, linkUrls : {String:String}, removeLinks : [String]) {\n    \n    let profile : \u0026Profile.User\n\n    prepare(account: AuthAccount) {\n\n        self.profile =account.borrow\u003c\u0026Profile.User\u003e(from:Profile.storagePath) ?? panic(\"You do not have a profile set up, initialize the user first\")\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n\n        }\n\n    }\n\n    execute{\n        self.profile.setName(name)\n        self.profile.setDescription(description)\n        self.profile.setAvatar(avatar)\n        self.profile.setTags(tags)\n\n        for link in removeLinks {\n            self.profile.removeLink(link)\n        }\n\n        for titleName in linkTitles.keys {\n            let title=linkTitles[titleName]!\n            let url = linkUrls[titleName]!\n            let type = linkTypes[titleName]!\n\n            self.profile.addLinkWithName(name:titleName, link: Profile.Link(title: title, type: type, url: url))\n        }\n        self.profile.emitUpdatedEvent()\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "description",
                     "avatar",
                     "tags",
                     "allowStoringFollowers",
                     "linkTitles",
                     "linkTypes",
                     "linkUrls",
                     "removeLinks"
                  ],
                  "parameters": {
                     "allowStoringFollowers": "Bool",
                     "avatar": "String",
                     "description": "String",
                     "linkTitles": "{String: String}",
                     "linkTypes": "{String: String}",
                     "linkUrls": "{String: String}",
                     "name": "String",
                     "removeLinks": "[String]",
                     "tags": "[String]"
                  }
               }
            },
            "follow": {
               "code": "import FungibleToken from 0x9a0766d93b6608b7\nimport FUSD from 0xe223d8a629e49c68\nimport FlowToken from 0x7e60df042a9c0868\nimport FIND from 0x35717efbbce11c74\nimport Profile from 0x35717efbbce11c74\n\n// map of {User in string (find name or address) : [tag]}\ntransaction(follows:{String : [String]}) {\n\n    let profile : \u0026Profile.User\n\n    prepare(account: AuthAccount) {\n\n        self.profile =account.borrow\u003c\u0026Profile.User\u003e(from:Profile.storagePath) ?? panic(\"Cannot borrow reference to profile\")\n\n        //Add exising FUSD or create a new one and add it\n        let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n        if !fusdReceiver.check() {\n            let fusd \u003c- FUSD.createEmptyVault()\n            account.save(\u003c- fusd, to: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n        }\n\n\n        var hasFusdWallet=false\n        var hasFlowWallet=false\n        let wallets=self.profile.getWallets()\n        for wallet in wallets {\n            if wallet.name==\"FUSD\" {\n                hasFusdWallet=true\n            }\n\n            if wallet.name ==\"Flow\" {\n                hasFlowWallet=true\n            }\n        }\n\n        if !hasFlowWallet {\n            let flowWallet=Profile.Wallet(\n                name:\"Flow\",\n                receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver),\n                balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance),\n                accept: Type\u003c@FlowToken.Vault\u003e(),\n                tags: [\"flow\"]\n            )\n            self.profile.addWallet(flowWallet)\n        }\n\n        if !hasFusdWallet {\n            let fusdWallet=Profile.Wallet(\n                name:\"FUSD\",\n                receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver),\n                balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance),\n                accept: Type\u003c@FUSD.Vault\u003e(),\n                tags: [\"fusd\", \"stablecoin\"]\n            )\n            self.profile.addWallet(fusdWallet)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n    }\n\n    execute{\n        for key in follows.keys {\n            let user = FIND.resolve(key) ?? panic(key.concat(\" cannot be resolved. It is either an invalid .find name or address\"))\n            let tags = follows[key]!\n            self.profile.follow(user, tags: tags)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "follows"
                  ],
                  "parameters": {
                     "follows": "{String: [String]}"
                  }
               }
            },
            "followDapper": {
               "code": "import FungibleToken from 0x9a0766d93b6608b7\nimport FUSD from 0xe223d8a629e49c68\nimport FlowToken from 0x7e60df042a9c0868\nimport FIND from 0x35717efbbce11c74\nimport Profile from 0x35717efbbce11c74\n\n// map of {User in string (find name or address) : [tag]}\ntransaction(follows:{String : [String]}) {\n\n    let profile : \u0026Profile.User\n\n    prepare(account: AuthAccount) {\n\n        self.profile =account.borrow\u003c\u0026Profile.User\u003e(from:Profile.storagePath) ?? panic(\"You do not have a profile set up, initialize the user first\")\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n\n        }\n    }\n\n    execute{\n        for key in follows.keys {\n            let user = FIND.resolve(key) ?? panic(key.concat(\" cannot be resolved. It is either an invalid .find name or address\"))\n            let tags = follows[key]!\n            self.profile.follow(user, tags: tags)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "follows"
                  ],
                  "parameters": {
                     "follows": "{String: [String]}"
                  }
               }
            },
            "fulfillLeaseMarketAuctionSoft": {
               "code": "import FindLeaseMarketAuctionSoft from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FTRegistry from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\nimport FindLeaseMarket from 0x35717efbbce11c74\n\ntransaction(leaseName: String, amount:UFix64) {\n\n    let walletReference : \u0026FungibleToken.Vault\n    let bidsReference: \u0026FindLeaseMarketAuctionSoft.MarketBidCollection\n    let requiredAmount: UFix64\n\n    prepare(account: AuthAccount) {\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e())\n\n        self.bidsReference= account.borrow\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"This account does not have a bid collection\")\n\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e())\n        let item = FindLeaseMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, name: leaseName)\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n\n        self.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n        self.requiredAmount = self.bidsReference.getBalance(leaseName)\n    }\n\n    pre{\n        self.walletReference.balance \u003e self.requiredAmount : \"Your wallet does not have enough funds to pay for this item\"\n        self.requiredAmount == amount : \"Amount needed to fulfill is \".concat(self.requiredAmount.toString()).concat(\" you sent in \").concat(amount.toString())\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount)\n        self.bidsReference.fulfillAuction(name: leaseName, vault: \u003c- vault)\n    }\n}",
               "spec": {
                  "order": [
                     "leaseName",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "leaseName": "String"
                  }
               }
            },
            "fulfillLeaseMarketAuctionSoftDapper": {
               "code": "import FindLeaseMarketAuctionSoft from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FTRegistry from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\nimport FindLeaseMarket from 0x35717efbbce11c74\n\ntransaction(leaseName: String, amount:UFix64) {\n\n    let walletReference : \u0026FungibleToken.Vault\n    let bidsReference: \u0026FindLeaseMarketAuctionSoft.MarketBidCollection\n    let requiredAmount: UFix64\n    let mainDapperCoinVault: \u0026FungibleToken.Vault\n    let balanceBeforeTransfer: UFix64\n\n    prepare(dapper: AuthAccount, account: AuthAccount) {\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e())\n\n        self.bidsReference= account.borrow\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"This account does not have a bid collection\")\n\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e())\n        let item = FindLeaseMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, name: leaseName)\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n\n        self.mainDapperCoinVault = dapper.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"Cannot borrow Dapper Coin vault from account storage. Type : \".concat(ft.type.identifier))\n        self.balanceBeforeTransfer = self.mainDapperCoinVault.balance\n\n        self.walletReference = dapper.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n        self.requiredAmount = self.bidsReference.getBalance(leaseName)\n    }\n\n    pre{\n        self.walletReference.balance \u003e self.requiredAmount : \"Your wallet does not have enough funds to pay for this item\"\n        self.requiredAmount == amount : \"Amount needed to fulfill is \".concat(self.requiredAmount.toString()).concat(\" you sent in \").concat(amount.toString())\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount)\n        self.bidsReference.fulfillAuction(name: leaseName, vault: \u003c- vault)\n    }\n\n    // Check that all dapper Coin was routed back to Dapper\n    post {\n        self.mainDapperCoinVault.balance == self.balanceBeforeTransfer: \"Dapper Coin leakage\"\n    }\n}",
               "spec": {
                  "order": [
                     "leaseName",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "leaseName": "String"
                  }
               }
            },
            "fulfillLeaseMarketDirectOfferSoft": {
               "code": "import FindLeaseMarketDirectOfferSoft from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FTRegistry from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\nimport FindLeaseMarket from 0x35717efbbce11c74\n\ntransaction(leaseName: String, amount:UFix64) {\n\n    let walletReference : \u0026FungibleToken.Vault\n    let bidsReference: \u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection\n    let requiredAmount:UFix64\n\n    prepare(account: AuthAccount) {\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e())\n        self.bidsReference= account.borrow\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"Cannot borrow direct offer soft bid collection\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e())\n        let item = FindLeaseMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, name: leaseName)\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n\n          self.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n\n        self.requiredAmount = self.bidsReference.getBalance(leaseName)\n    }\n\n    pre {\n        self.walletReference.balance \u003e self.requiredAmount : \"Your wallet does not have enough funds to pay for this item\"\n        self.requiredAmount == amount : \"Amount needed to fulfill is \".concat(amount.toString())\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount)\n        self.bidsReference.fulfillDirectOffer(name: leaseName, vault: \u003c- vault)\n    }\n}",
               "spec": {
                  "order": [
                     "leaseName",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "leaseName": "String"
                  }
               }
            },
            "fulfillLeaseMarketDirectOfferSoftDapper": {
               "code": "import FindLeaseMarketDirectOfferSoft from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FTRegistry from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\nimport FindLeaseMarket from 0x35717efbbce11c74\n\ntransaction(leaseName: String, amount:UFix64) {\n\n    let walletReference : \u0026FungibleToken.Vault\n    let bidsReference: \u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection\n    let requiredAmount:UFix64\n    let mainDapperCoinVault: \u0026FungibleToken.Vault\n    let balanceBeforeTransfer: UFix64\n\n    prepare(dapper: AuthAccount, account: AuthAccount) {\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e())\n        self.bidsReference= account.borrow\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"Cannot borrow direct offer soft bid collection\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e())\n        let item = FindLeaseMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, name: leaseName)\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n\n        self.mainDapperCoinVault = dapper.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"Cannot borrow Dapper Coin vault from account storage. Type : \".concat(ft.type.identifier))\n        self.balanceBeforeTransfer = self.mainDapperCoinVault.balance\n\n          self.walletReference = dapper.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n\n        self.requiredAmount = self.bidsReference.getBalance(leaseName)\n    }\n\n    pre {\n        self.walletReference.balance \u003e self.requiredAmount : \"Your wallet does not have enough funds to pay for this item\"\n        self.requiredAmount == amount : \"Amount needed to fulfill is \".concat(amount.toString())\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount)\n        self.bidsReference.fulfillDirectOffer(name: leaseName, vault: \u003c- vault)\n    }\n\n    // Check that all dapper Coin was routed back to Dapper\n    post {\n        self.mainDapperCoinVault.balance == self.balanceBeforeTransfer: \"Dapper Coin leakage\"\n    }\n}",
               "spec": {
                  "order": [
                     "leaseName",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "leaseName": "String"
                  }
               }
            },
            "fulfillMarketAuctionEscrowed": {
               "code": "import FindMarketAuctionEscrow from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\n\ntransaction(marketplace:Address, owner: String, id: UInt64) {\n\n    let saleItem : Capability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic}\u003e?\n\n    prepare(account: AuthAccount) {\n        let resolveAddress = FIND.resolve(owner)\n        if resolveAddress == nil { \n            panic(\"The address input is not a valid name nor address. Input : \".concat(owner))\n        }\n        let address = resolveAddress!\n        self.saleItem = FindMarketAuctionEscrow.getSaleItemCapability(marketplace:marketplace, user:address)\n\n    }\n\n    pre{\n        self.saleItem != nil : \"This saleItem capability does not exist. Sale item ID: \".concat(id.toString())\n        self.saleItem!.check() : \"Cannot borrow reference to saleItem. Sale item ID: \".concat(id.toString())\n    }\n\n    execute {\n        self.saleItem!.borrow()!.fulfillAuction(id)\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "owner",
                     "id"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "marketplace": "Address",
                     "owner": "String"
                  }
               }
            },
            "fulfillMarketAuctionEscrowedFromBidder": {
               "code": "import FindMarketAuctionEscrow from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\n\ntransaction(marketplace:Address, id: UInt64) {\n\n    let bidsReference : \u0026FindMarketAuctionEscrow.MarketBidCollection?\n\n    prepare(account: AuthAccount) {\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e())\n        self.bidsReference= account.borrow\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection\u003e(from: storagePath)\n\n        \n    }\n\n    pre{\n        self.bidsReference != nil : \"Cannot borrow reference to bid collection.\"\n    }\n\n    execute{\n        self.bidsReference!.fulfillAuction(id)\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "fulfillMarketAuctionSoft": {
               "code": "import FindMarketAuctionSoft from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FTRegistry from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\n\ntransaction(marketplace:Address, id: UInt64, amount:UFix64) {\n\n    let walletReference : \u0026FungibleToken.Vault\n    let bidsReference: \u0026FindMarketAuctionSoft.MarketBidCollection\n    let requiredAmount: UFix64\n\n    prepare(account: AuthAccount) {\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e())\n\n        self.bidsReference= account.borrow\u003c\u0026FindMarketAuctionSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"This account does not have a bid collection\")\n\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e())\n        let item = FindMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: id)\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n    \n        self.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n        self.requiredAmount = self.bidsReference.getBalance(id)\n    }\n\n    pre{\n        self.walletReference.balance \u003e self.requiredAmount : \"Your wallet does not have enough funds to pay for this item\"\n        self.requiredAmount == amount : \"Amount needed to fulfill is \".concat(self.requiredAmount.toString()).concat(\" you sent in \").concat(amount.toString())\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount) \n        self.bidsReference.fulfillAuction(id: id, vault: \u003c- vault)\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "fulfillMarketAuctionSoftDapper": {
               "code": "import FindMarketAuctionSoft from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FTRegistry from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\n\ntransaction(marketplace:Address, id: UInt64, amount:UFix64) {\n\n    let walletReference : \u0026FungibleToken.Vault\n    let bidsReference: \u0026FindMarketAuctionSoft.MarketBidCollection\n    let requiredAmount: UFix64\n    let mainDapperCoinVault: \u0026FungibleToken.Vault\n    let balanceBeforeTransfer: UFix64\n\n    prepare(dapper: AuthAccount, account: AuthAccount) {\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e())\n\n        self.bidsReference= account.borrow\u003c\u0026FindMarketAuctionSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"This account does not have a bid collection\")\n\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e())\n        let item = FindMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: id)\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n    \n        self.mainDapperCoinVault = dapper.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"Cannot borrow Dapper Coin vault from account storage. Type : \".concat(ft.type.identifier))\n        self.balanceBeforeTransfer = self.mainDapperCoinVault.balance\n\n        self.walletReference = dapper.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n        self.requiredAmount = self.bidsReference.getBalance(id)\n    }\n\n    pre{\n        self.walletReference.balance \u003e self.requiredAmount : \"Your wallet does not have enough funds to pay for this item\"\n        self.requiredAmount == amount : \"Amount needed to fulfill is \".concat(self.requiredAmount.toString()).concat(\" you sent in \").concat(amount.toString())\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount) \n        self.bidsReference.fulfillAuction(id: id, vault: \u003c- vault)\n    }\n\n    // Check that all dapper Coin was routed back to Dapper\n    post {\n        self.mainDapperCoinVault.balance == self.balanceBeforeTransfer: \"Dapper Coin leakage\"\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "fulfillMarketDirectOfferEscrowed": {
               "code": "import FindMarketDirectOfferEscrow from 0x35717efbbce11c74\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FindViews from 0x35717efbbce11c74\nimport NFTCatalog from 0x324c34e1c517e4db\nimport FINDNFTCatalog from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\n\ntransaction(marketplace:Address, id: UInt64) {\n\n    let market : \u0026FindMarketDirectOfferEscrow.SaleItemCollection?\n    let pointer : FindViews.AuthNFTPointer\n\n    prepare(account: AuthAccount) {\n\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e())\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e())\n\n        let item = FindMarket.assertOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: id)\n\n        let nftIdentifier = item.getItemType().identifier\n        let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier)) \n        let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n        let nft = collection.collectionData\n\n    \n        var providerCap=account.getCapability\u003c\u0026{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e(nft.privatePath)\n\n        /* Ben : Question -\u003e Either client will have to provide the path here or agree that we set it up for the user */\n        if !providerCap.check() {\n            let newCap = account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                    nft.privatePath,\n                    target: nft.storagePath\n            )\n            if newCap == nil {\n                // If linking is not successful, we link it using finds custom link \n                let pathIdentifier = nft.privatePath.toString()\n                let findPath = PrivatePath(identifier: pathIdentifier.slice(from: \"/private/\".length , upTo: pathIdentifier.length).concat(\"_FIND\"))!\n                account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                    findPath,\n                    target: nft.storagePath\n                )\n                providerCap = account.getCapability\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(findPath)\n            }\n        }\n\n        self.pointer= FindViews.AuthNFTPointer(cap: providerCap, id: item.getItemID())\n        self.market = account.borrow\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection\u003e(from: storagePath)\n\n    }\n\n    pre{\n        self.market != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        self.market!.acceptDirectOffer(self.pointer)\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "fulfillMarketDirectOfferSoft": {
               "code": "import FindMarketDirectOfferSoft from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FTRegistry from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\n\ntransaction(marketplace:Address, id: UInt64, amount:UFix64) {\n\n    let walletReference : \u0026FungibleToken.Vault\n    let bidsReference: \u0026FindMarketDirectOfferSoft.MarketBidCollection\n    let requiredAmount:UFix64\n\n    prepare(account: AuthAccount) {\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n        self.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"Cannot borrow direct offer soft bid collection\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n        let item = FindMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: id)\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n\n      self.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n\n        self.requiredAmount = self.bidsReference.getBalance(id)\n    }\n\n    pre {\n        self.walletReference.balance \u003e self.requiredAmount : \"Your wallet does not have enough funds to pay for this item\"\n        self.requiredAmount == amount : \"Amount needed to fulfill is \".concat(amount.toString())\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount) \n        self.bidsReference.fulfillDirectOffer(id: id, vault: \u003c- vault)\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "fulfillMarketDirectOfferSoftDapper": {
               "code": "import FindMarketDirectOfferSoft from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FTRegistry from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\n\ntransaction(marketplace:Address, id: UInt64, amount:UFix64) {\n\n    let walletReference : \u0026FungibleToken.Vault\n    let bidsReference: \u0026FindMarketDirectOfferSoft.MarketBidCollection\n    let requiredAmount:UFix64\n    let mainDapperCoinVault: \u0026FungibleToken.Vault\n    let balanceBeforeTransfer: UFix64\n\n    prepare(dapper: AuthAccount, account: AuthAccount) {\n\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n        self.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"Cannot borrow direct offer soft bid collection\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n        let item = FindMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: id)\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n\n        self.mainDapperCoinVault = dapper.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"Cannot borrow Dapper Coin vault from account storage. Type : \".concat(ft.type.identifier))\n        self.balanceBeforeTransfer = self.mainDapperCoinVault.balance\n\n          self.walletReference = dapper.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n\n        self.requiredAmount = self.bidsReference.getBalance(id)\n    }\n\n    pre {\n        self.walletReference.balance \u003e self.requiredAmount : \"Your wallet does not have enough funds to pay for this item\"\n        self.requiredAmount == amount : \"Amount needed to fulfill is \".concat(amount.toString())\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount) \n        self.bidsReference.fulfillDirectOffer(id: id, vault: \u003c- vault)\n    }\n\n    // Check that all dapper Coin was routed back to Dapper\n    post {\n        self.mainDapperCoinVault.balance == self.balanceBeforeTransfer: \"Dapper Coin leakage\"\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "fulfillMultipleMarketDirectOfferEscrowed": {
               "code": "import FindMarketDirectOfferEscrow from 0x35717efbbce11c74\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FindViews from 0x35717efbbce11c74\nimport NFTCatalog from 0x324c34e1c517e4db\nimport FINDNFTCatalog from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\n\ntransaction(marketplace:Address, ids: [UInt64]) {\n\n    let market : \u0026FindMarketDirectOfferEscrow.SaleItemCollection?\n    let pointer : [FindViews.AuthNFTPointer]\n\n    prepare(account: AuthAccount) {\n\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e())\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e())\n        self.market = account.borrow\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection\u003e(from: storagePath)\n        self.pointer = []\n\n        let nfts : {String : NFTCatalog.NFTCollectionData} = {}\n        var counter = 0\n        while counter \u003c ids.length {\n            let item = FindMarket.assertOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: ids[counter])\n\n            var nft : NFTCatalog.NFTCollectionData? = nil\n            let nftIdentifier = item.getItemType().identifier\n\n            if nfts[nftIdentifier] != nil {\n                nft = nfts[nftIdentifier]\n            } else {\n                let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier)) \n                let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n                nft = collection.collectionData\n                nfts[nftIdentifier] = nft\n            }\n        \n            var providerCap=account.getCapability\u003c\u0026{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e(nft!.privatePath)\n\n            /* Ben : Question -\u003e Either client will have to provide the path here or agree that we set it up for the user */\n            if !providerCap.check() {\n                let newCap = account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                        nft!.privatePath,\n                        target: nft!.storagePath\n                )\n                if newCap == nil {\n                    // If linking is not successful, we link it using finds custom link \n                    let pathIdentifier = nft!.privatePath.toString()\n                    let findPath = PrivatePath(identifier: pathIdentifier.slice(from: \"/private/\".length , upTo: pathIdentifier.length).concat(\"_FIND\"))!\n                    account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                        findPath,\n                        target: nft!.storagePath\n                    )\n                    providerCap = account.getCapability\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(findPath)\n                }\n            }\n\n            let pointer= FindViews.AuthNFTPointer(cap: providerCap, id: item.getItemID())\n            self.pointer.append(pointer)\n            counter = counter + 1\n        }\n\n    }\n\n    pre{\n        self.market != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        var counter = 0\n        while counter \u003c ids.length {\n            self.market!.acceptDirectOffer(self.pointer[counter])\n            counter = counter + 1\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "ids"
                  ],
                  "parameters": {
                     "ids": "[UInt64]",
                     "marketplace": "Address"
                  }
               }
            },
            "fulfillMultipleMarketDirectOfferSoft": {
               "code": "import FindMarketDirectOfferSoft from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FTRegistry from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\n\ntransaction(marketplace:Address, ids: [UInt64], amounts:[UFix64]) {\n\n    let walletReference : [\u0026FungibleToken.Vault]\n    let bidsReference: \u0026FindMarketDirectOfferSoft.MarketBidCollection\n    let requiredAmount: [UFix64]\n\n    prepare(account: AuthAccount) {\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n        self.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"Cannot borrow direct offer soft bid collection\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n\n        var counter = 0\n        self.requiredAmount = []\n        self.walletReference = []\n        let fts : {String : FTRegistry.FTInfo} = {}\n        let vaultRefs : {StoragePath : \u0026FungibleToken.Vault} = {}\n\n\n        while counter \u003c ids.length {\n            let item = FindMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: ids[counter])\n\n            var ft : FTRegistry.FTInfo? = nil\n            let ftIdentifier = item.getFtType().identifier\n            if fts[ftIdentifier] != nil {\n                ft = fts[ftIdentifier]\n            } else {\n                ft = FTRegistry.getFTInfoByTypeIdentifier(ftIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftIdentifier))\n                fts[ftIdentifier] = ft\n            }\n\n            if vaultRefs[ft!.vaultPath] != nil {\n                self.walletReference.append(vaultRefs[ft!.vaultPath]!)\n            } else {\n                let walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft!.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n                vaultRefs[ft!.vaultPath] = walletReference\n                self.walletReference.append(walletReference)\n            }\n            let requiredAmount = self.bidsReference.getBalance(ids[counter])\n            self.requiredAmount.append(requiredAmount)\n            counter = counter + 1\n        }\n    }\n\n    execute {\n        var counter = 0\n        while counter \u003c ids.length {\n            if self.walletReference[counter].balance \u003c self.requiredAmount[counter] {\n                panic(\"Your wallet does not have enough funds to pay for this item. Item ID: \".concat(ids[counter].toString()))\n            }\n            if self.requiredAmount[counter] != amounts[counter] {\n                panic(\"Amount needed to fulfill is \".concat(amounts[counter].toString()))\n            }\n            let vault \u003c- self.walletReference[counter].withdraw(amount: amounts[counter]) \n            self.bidsReference.fulfillDirectOffer(id: ids[counter], vault: \u003c- vault)\n            counter = counter + 1\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "ids",
                     "amounts"
                  ],
                  "parameters": {
                     "amounts": "[UFix64]",
                     "ids": "[UInt64]",
                     "marketplace": "Address"
                  }
               }
            },
            "fulfillMultipleMarketDirectOfferSoftDapper": {
               "code": "import FindMarketDirectOfferSoft from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FTRegistry from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\n\ntransaction(marketplace:Address, ids: [UInt64], amounts:[UFix64]) {\n\n    let walletReference : [\u0026FungibleToken.Vault]\n    let bidsReference: \u0026FindMarketDirectOfferSoft.MarketBidCollection\n    let requiredAmount: [UFix64]\n    let balanceBeforeTransfer: {Type : UFix64}\n\n    prepare(dapper: AuthAccount, account: AuthAccount) {\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n        self.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"Cannot borrow direct offer soft bid collection\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n\n        var counter = 0\n        self.requiredAmount = []\n        self.walletReference = []\n        self.balanceBeforeTransfer = {}\n        let fts : {String : FTRegistry.FTInfo} = {}\n        let vaultRefs : {StoragePath : \u0026FungibleToken.Vault} = {}\n\n\n        while counter \u003c ids.length {\n            let item = FindMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: ids[counter])\n\n            var ft : FTRegistry.FTInfo? = nil\n            let ftIdentifier = item.getFtType().identifier\n            if fts[ftIdentifier] != nil {\n                ft = fts[ftIdentifier]\n            } else {\n                ft = FTRegistry.getFTInfoByTypeIdentifier(ftIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftIdentifier))\n                fts[ftIdentifier] = ft\n            }\n\n            if vaultRefs[ft!.vaultPath] != nil {\n                let vaultRef = vaultRefs[ft!.vaultPath]!\n                self.walletReference.append(vaultRef)\n            } else {\n                let walletReference = dapper.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft!.vaultPath) ?? panic(\"Cannot borrow Dapper Coin Vault. Type : \".concat(ft!.type.identifier))\n                vaultRefs[ft!.vaultPath] = walletReference\n                self.walletReference.append(walletReference)\n                self.balanceBeforeTransfer[walletReference.getType()] = walletReference.balance\n            }\n            let requiredAmount = self.bidsReference.getBalance(ids[counter])\n            self.requiredAmount.append(requiredAmount)\n            counter = counter + 1\n        }\n    }\n\n    execute {\n        var counter = 0\n        while counter \u003c ids.length {\n            if self.walletReference[counter].balance \u003c self.requiredAmount[counter] {\n                panic(\"Your wallet does not have enough funds to pay for this item. Item ID: \".concat(ids[counter].toString()))\n            }\n            if self.requiredAmount[counter] != amounts[counter] {\n                panic(\"Amount needed to fulfill is \".concat(amounts[counter].toString()))\n            }\n            let vault \u003c- self.walletReference[counter].withdraw(amount: amounts[counter]) \n            self.bidsReference.fulfillDirectOffer(id: ids[counter], vault: \u003c- vault)\n            counter = counter + 1\n        }\n        // Check that all dapper Coin was routed back to Dapper\n        for vault in self.walletReference {\n            if self.balanceBeforeTransfer[vault.getType()]! != vault.balance {\n                panic(\"Dapper Coin leakage. Type : \".concat(vault.getType().identifier))\n            }\n        }\n    }\n\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "ids",
                     "amounts"
                  ],
                  "parameters": {
                     "amounts": "[UFix64]",
                     "ids": "[UInt64]",
                     "marketplace": "Address"
                  }
               }
            },
            "fulfillName": {
               "code": "import FIND from 0x35717efbbce11c74\nimport Profile from 0x35717efbbce11c74\n\ntransaction(name: String) {\n\n    let finLeases : \u0026FIND.LeaseCollection?\n\n    prepare(account: AuthAccount) {\n        self.finLeases= account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath) \n    }\n\n    pre{\n        self.finLeases != nil : \"Cannot borrow reference to find lease collection\"\n    }\n\n    execute{\n        self.finLeases!.fulfill(name)\n    }\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "fulfillNameAuction": {
               "code": "import FIND from 0x35717efbbce11c74\nimport Profile from 0x35717efbbce11c74\n\ntransaction(owner: Address, name: String) {\n\n    let leases : \u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}?\n\n    prepare(account: AuthAccount) {\n        self.leases = getAccount(owner).getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath).borrow()\n    }\n\n    pre{\n        self.leases != nil : \"Cannot borrow reference to lease collection reference. Account address: \".concat(owner.toString())\n    }\n\n    execute{\n        self.leases!.fulfillAuction(name)\n    }\n}",
               "spec": {
                  "order": [
                     "owner",
                     "name"
                  ],
                  "parameters": {
                     "name": "String",
                     "owner": "Address"
                  }
               }
            },
            "fulfillNameAuctionBidder": {
               "code": "import FIND from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FUSD from 0xe223d8a629e49c68\nimport Profile from 0x35717efbbce11c74\n\ntransaction(owner: Address, name: String) {\n\n    let leaseCollectionOwner : \u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}?\n\n    prepare(account: AuthAccount) {\n\n\n    //Add exising FUSD or create a new one and add it\n        let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n        if !fusdReceiver.check() {\n            let fusd \u003c- FUSD.createEmptyVault()\n            account.save(\u003c- fusd, to: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n\n            let fusdWallet=Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), tags: [\"fusd\", \"stablecoin\"])\n\n            profile.addWallet(fusdWallet)\n\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n        }\n\n        self.leaseCollectionOwner = getAccount(owner).getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath).borrow()\n\n    }\n\n    pre{\n        self.leaseCollectionOwner != nil : \"Cannot borrow reference to find lease collection. Account address: \".concat(owner.toString())\n    }\n\n    execute {\n        self.leaseCollectionOwner!.fulfillAuction(name)\n    }\n}",
               "spec": {
                  "order": [
                     "owner",
                     "name"
                  ],
                  "parameters": {
                     "name": "String",
                     "owner": "Address"
                  }
               }
            },
            "hideFindThoughts": {
               "code": "import FindThoughts from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\n\ntransaction(ids: [UInt64], hide: [Bool]) {\n\n    let collection : \u0026FindThoughts.Collection\n\n    prepare(account: AuthAccount) {\n        self.collection=account.borrow\u003c\u0026FindThoughts.Collection\u003e(from: FindThoughts.CollectionStoragePath) ?? panic(\"Cannot borrow thoughts reference from path\")\n    }\n\n    execute {\n        for i, id in ids {\n            self.collection.hide(id: id, hide: hide[i])\n        }\n\n    }\n}",
               "spec": {
                  "order": [
                     "ids",
                     "hide"
                  ],
                  "parameters": {
                     "hide": "[Bool]",
                     "ids": "[UInt64]"
                  }
               }
            },
            "increaseBidLeaseMarketAuctionSoft": {
               "code": "import FindLeaseMarketAuctionSoft from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FTRegistry from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\nimport FindLeaseMarket from 0x35717efbbce11c74\n\ntransaction(leaseName: String, amount: UFix64) {\n\n    let bidsReference: \u0026FindLeaseMarketAuctionSoft.MarketBidCollection\n\n    prepare(account: AuthAccount) {\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e())\n        self.bidsReference= account.borrow\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"Bid resource does not exist\")\n        // get Bidding Fungible Token Vault\n          let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e())\n        let item = FindLeaseMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, name: leaseName)\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n\n    }\n\n    execute {\n        self.bidsReference.increaseBid(name: leaseName, increaseBy: amount)\n    }\n\n}",
               "spec": {
                  "order": [
                     "leaseName",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "leaseName": "String"
                  }
               }
            },
            "increaseBidLeaseMarketDirectOfferSoft": {
               "code": "import FindLeaseMarketDirectOfferSoft from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\nimport FindLeaseMarket from 0x35717efbbce11c74\n\ntransaction(leaseName: String, amount: UFix64) {\n\n    let bidsReference: \u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection\n\n    prepare(account: AuthAccount) {\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e())\n        self.bidsReference= account.borrow\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"Bid resource does not exist\")\n        // get Bidding Fungible Token Vault\n          let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e())\n        let item = FindLeaseMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, name: leaseName)\n    }\n\n    execute {\n        self.bidsReference.increaseBid(name: leaseName, increaseBy: amount)\n    }\n}",
               "spec": {
                  "order": [
                     "leaseName",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "leaseName": "String"
                  }
               }
            },
            "increaseBidMarketAuctionEscrowed": {
               "code": "import FindMarketAuctionEscrow from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FTRegistry from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\n\ntransaction(marketplace:Address, id: UInt64, amount: UFix64) {\n\n    let walletReference : \u0026FungibleToken.Vault\n    let bidsReference: \u0026FindMarketAuctionEscrow.MarketBidCollection\n    let balanceBeforeBid: UFix64\n\n    prepare(account: AuthAccount) {\n\n        // Get the accepted vault type from BidInfo\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e())\n        self.bidsReference= account.borrow\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection\u003e(from: storagePath) ?? panic(\"This account does not have a bid collection\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e())\n        let item = FindMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: id)\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n        self.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n        self.balanceBeforeBid = self.walletReference.balance\n    }\n\n    pre {\n        self.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount) \n        self.bidsReference.increaseBid(id: id, vault: \u003c- vault)\n    }\n\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "increaseBidMarketAuctionSoft": {
               "code": "import FindMarketAuctionSoft from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FTRegistry from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\n\ntransaction(marketplace:Address, id: UInt64, amount: UFix64) {\n\n    let bidsReference: \u0026FindMarketAuctionSoft.MarketBidCollection\n\n\n    prepare(account: AuthAccount) {\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e())\n        self.bidsReference= account.borrow\u003c\u0026FindMarketAuctionSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"Bid resource does not exist\")\n        // get Bidding Fungible Token Vault\n          let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e())\n        let item = FindMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: id)\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n        if !ft.tag.contains(\"dapper\") {\n            let walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n        }\n    }\n\n    execute {\n        self.bidsReference.increaseBid(id: id, increaseBy: amount)\n    }\n\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "increaseBidMarketDirectOfferEscrowed": {
               "code": "import FindMarketDirectOfferEscrow from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FTRegistry from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\n\ntransaction(marketplace:Address, id: UInt64, amount: UFix64) {\n\n    let walletReference : \u0026FungibleToken.Vault\n    let bidsReference: \u0026FindMarketDirectOfferEscrow.MarketBidCollection\n    let balanceBeforeBid: UFix64\n\n    prepare(account: AuthAccount) {\n        let tenant=FindMarket.getTenantCapability(marketplace)!.borrow() ?? panic(\"Cannot borrow reference to tenant\")\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e())\n        self.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection\u003e(from: storagePath) ?? panic(\"This account does not have a bid collection\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e())\n        let item = FindMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: id)\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n        self.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n        self.balanceBeforeBid=self.walletReference.balance\n    }\n\n    pre {\n        self.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount) \n        self.bidsReference!.increaseBid(id: id, vault: \u003c- vault)\n    }\n\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "increaseBidMarketDirectOfferSoft": {
               "code": "import FindMarketDirectOfferSoft from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\n\ntransaction(marketplace: Address, id: UInt64, amount: UFix64) {\n\n    let bidsReference: \u0026FindMarketDirectOfferSoft.MarketBidCollection\n\n    prepare(account: AuthAccount) {\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n        self.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"Bid resource does not exist\")\n        // get Bidding Fungible Token Vault\n          let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n        let item = FindMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: id)\n    }\n\n    execute {\n        self.bidsReference.increaseBid(id: id, increaseBy: amount)\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "increaseNameBid": {
               "code": "import FIND from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FUSD from 0xe223d8a629e49c68\n\ntransaction(name: String, amount: UFix64) {\n\n    let vaultRef : \u0026FUSD.Vault?\n    let bids : \u0026FIND.BidCollection?\n\n    prepare(account: AuthAccount) {\n\n        \n        let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        self.vaultRef = account.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault)\n        self.bids = account.borrow\u003c\u0026FIND.BidCollection\u003e(from: FIND.BidStoragePath)\n    }\n\n    pre{\n        self.vaultRef != nil : \"Could not borrow reference to the fusdVault!\"\n        self.bids != nil : \"Could not borrow reference to bid collection\"\n    }\n\n    execute{\n        let vault \u003c- self.vaultRef!.withdraw(amount: amount) as! @FUSD.Vault\n        self.bids!.increaseBid(name: name, vault: \u003c- vault)\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "name": "String"
                  }
               }
            },
            "initDapperAccount": {
               "code": "import FungibleToken from 0x9a0766d93b6608b7\nimport DapperUtilityCoin from 0x82ec283f88a62e65\nimport FlowUtilityToken from 0x82ec283f88a62e65 \nimport TokenForwarding from 0x51ea0e37c27a1f1a\n\ntransaction(dapperAddress: Address) {\n    prepare(account: AuthAccount) {\n\n        let dapper=getAccount(dapperAddress)\n        //this is only for emulator\n        let ducReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver)\n        if !ducReceiver.check() {\n            // Create a new Forwarder resource for DUC and store it in the new account's storage\n            let ducForwarder \u003c- TokenForwarding.createNewForwarder(recipient: dapper.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver))\n            account.save(\u003c-ducForwarder, to: /storage/dapperUtilityCoinVault)\n            // Publish a Receiver capability for the new account, which is linked to the DUC Forwarder\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver,target: /storage/dapperUtilityCoinVault)\n        }\n\n        //this is only for emulator\n        let futReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowUtilityTokenReceiver)\n        if !futReceiver.check() {\n            // Create a new Forwarder resource for FUT and store it in the new account's storage\n            let futForwarder \u003c- TokenForwarding.createNewForwarder(recipient: dapper.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowUtilityTokenReceiver))\n            account.save(\u003c-futForwarder, to: /storage/flowUtilityTokenVault)\n            // Publish a Receiver capability for the new account, which is linked to the FUT Forwarder\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowUtilityTokenReceiver,target: /storage/flowUtilityTokenVault)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "dapperAddress"
                  ],
                  "parameters": {
                     "dapperAddress": "Address"
                  }
               }
            },
            "initMerchantAccount": {
               "code": "import TokenForwarding from 0x51ea0e37c27a1f1a\nimport FungibleToken from 0x9a0766d93b6608b7\nimport DapperUtilityCoin from 0x82ec283f88a62e65\nimport FlowUtilityToken from 0x82ec283f88a62e65\nimport FungibleTokenSwitchboard from 0x9a0766d93b6608b7\nimport FiatToken from 0xa983fecbed621163\nimport FUSD from 0xe223d8a629e49c68\nimport FlowToken from 0x7e60df042a9c0868\n\n/**\n This is a transaction to set up an merchant account\n\n It has to be a blocto account since dapper will not allow us to run this account on a merchan account\n\n The only input parameter to this is your merchant account at dapper\n\n // 1. run this transaction in a lilico/blocto account your \"credit account\"\n // 2. use the path = /public/fungibleTokenSwitchboardPublic on this account as royalty receiver, it will be able to handle all the common FT\n**/\n\ntransaction(dapperMerchantAccountAddress: Address) {\n\n    prepare(acct: AuthAccount) {\n        // Get a Receiver reference for the Dapper account that will be the recipient of the forwarded DUC and FUT\n        let dapper = getAccount(dapperMerchantAccountAddress)\n\n        //FUSD\n        let fusdReceiver = acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n        if !fusdReceiver.check() {\n            let fusd \u003c- FUSD.createEmptyVault()\n            acct.save(\u003c- fusd, to: /storage/fusdVault)\n            acct.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n            acct.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n        }\n\n        //USDC\n        let usdcCap = acct.getCapability\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e(FiatToken.VaultReceiverPubPath)\n        if !usdcCap.check() {\n            acct.save( \u003c-FiatToken.createEmptyVault(), to: FiatToken.VaultStoragePath)\n            acct.link\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e( FiatToken.VaultReceiverPubPath, target: FiatToken.VaultStoragePath)\n            acct.link\u003c\u0026FiatToken.Vault{FiatToken.ResourceId}\u003e( FiatToken.VaultUUIDPubPath, target: FiatToken.VaultStoragePath)\n            acct.link\u003c\u0026FiatToken.Vault{FungibleToken.Balance}\u003e( FiatToken.VaultBalancePubPath, target:FiatToken.VaultStoragePath)\n        }\n\n        //We have to first check if the SIGNER has forwarder created.\n        //If not then we create a forwarder with the capability to DAPPER's receiver\n        //Dapper utility token\n\n        let ducReceiver = acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver)\n        let dapperDUCReceiver = dapper.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver)\n        if !ducReceiver.check(){\n            let ducForwarder \u003c- TokenForwarding.createNewForwarder(recipient: dapperDUCReceiver)\n            acct.save(\u003c-ducForwarder, to: /storage/dapperUtilityCoinReceiver)\n            acct.link\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver, target: /storage/dapperUtilityCoinReceiver)\n        }\n\n        //We have to first check if the SIGNER has forwarder created.\n        //If not then we create a forwarder with the capability to DAPPER's receiver\n        //FlowUtility token\n\n        let futReceiver = acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowUtilityTokenReceiver)\n        let dapperFUTReceiver = dapper.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowUtilityTokenReceiver)\n        if !futReceiver.check(){\n            let futForwarder \u003c- TokenForwarding.createNewForwarder(recipient: dapperFUTReceiver)\n            acct.save(\u003c-futForwarder, to: /storage/flowUtilityTokenReceiver)\n            acct.link\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowUtilityTokenReceiver, target: /storage/flowUtilityTokenReceiver)\n        }\n\n        let switchboard \u003c- FungibleTokenSwitchboard.createSwitchboard()\n\n        //We add the direct forwarder to the merchant account to the switchboard so that the chain will be\n        //switchboard --\u003e merchant account forwarder --\u003e dapper\n        //the alternative would be \n        //switchboard --\u003e our forwarder --\u003e merchant account forwarder --\u003e dapper\n        switchboard.addNewVaultWrapper(capability: dapperDUCReceiver, type: Type\u003c@DapperUtilityCoin.Vault\u003e())\n        switchboard.addNewVaultWrapper(capability: dapperFUTReceiver, type: Type\u003c@FlowUtilityToken.Vault\u003e())\n        switchboard.addNewVault(capability: usdcCap)\n        switchboard.addNewVault(capability: fusdReceiver)\n        switchboard.addNewVault(capability: acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver))\n\n        acct.save(\u003c- switchboard, to: FungibleTokenSwitchboard.StoragePath)\n        acct.link\u003c\u0026FungibleTokenSwitchboard.Switchboard{FungibleToken.Receiver}\u003e( FungibleTokenSwitchboard.ReceiverPublicPath, target: FungibleTokenSwitchboard.StoragePath)\n        acct.link\u003c\u0026FungibleTokenSwitchboard.Switchboard{FungibleTokenSwitchboard.SwitchboardPublic, FungibleToken.Receiver}\u003e(\n            FungibleTokenSwitchboard.PublicPath,\n            target: FungibleTokenSwitchboard.StoragePath\n        )\n    }\n}",
               "spec": {
                  "order": [
                     "dapperMerchantAccountAddress"
                  ],
                  "parameters": {
                     "dapperMerchantAccountAddress": "Address"
                  }
               }
            },
            "initSwitchboard": {
               "code": "import FungibleToken from 0x9a0766d93b6608b7\nimport FlowToken from 0x7e60df042a9c0868\nimport FUSD from 0xe223d8a629e49c68\nimport FiatToken from 0xa983fecbed621163\nimport TokenForwarding from 0x51ea0e37c27a1f1a\nimport FungibleTokenSwitchboard from 0x9a0766d93b6608b7\nimport DapperUtilityCoin from 0x82ec283f88a62e65\nimport FlowUtilityToken from 0x82ec283f88a62e65\n\ntransaction(dapperAddress: Address) {\n    prepare(acct: AuthAccount) {\n\n        let dapper = getAccount(dapperAddress)\n\n        //FUSD\n        let fusdReceiver = acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n        if !fusdReceiver.check() {\n            let fusd \u003c- FUSD.createEmptyVault()\n            acct.save(\u003c- fusd, to: /storage/fusdVault)\n            acct.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n            acct.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n        }\n\n        //USDC\n        let usdcCap = acct.getCapability\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e(FiatToken.VaultReceiverPubPath)\n        if !usdcCap.check() {\n            acct.save( \u003c-FiatToken.createEmptyVault(), to: FiatToken.VaultStoragePath)\n            acct.link\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e( FiatToken.VaultReceiverPubPath, target: FiatToken.VaultStoragePath)\n            acct.link\u003c\u0026FiatToken.Vault{FiatToken.ResourceId}\u003e( FiatToken.VaultUUIDPubPath, target: FiatToken.VaultStoragePath)\n            acct.link\u003c\u0026FiatToken.Vault{FungibleToken.Balance}\u003e( FiatToken.VaultBalancePubPath, target:FiatToken.VaultStoragePath)\n        }\n\n\n        //Dapper utility token\n        let dapperDUCReceiver = dapper.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver)\n        let DUCReceiver = acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver)\n        if !DUCReceiver.check(){\n            let ducForwarder \u003c- TokenForwarding.createNewForwarder(recipient: dapperDUCReceiver)\n            acct.save(\u003c-ducForwarder, to: /storage/dapperUtilityCoinReceiver)\n            acct.link\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver, target: /storage/dapperUtilityCoinReceiver)\n        }\n\n        //FlowUtility token\n        let dapperFUTReceiver = dapper.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowUtilityTokenReceiver)\n        let FUTReceiver = acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowUtilityTokenReceiver)\n        if !FUTReceiver.check(){\n            let futForwarder \u003c- TokenForwarding.createNewForwarder(recipient: dapperFUTReceiver)\n            acct.save(\u003c-futForwarder, to: /storage/flowUtilityTokenReceiver)\n            acct.link\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowUtilityTokenReceiver, target: /storage/flowUtilityTokenReceiver)\n        }\n\n        let switchboardRef = acct.borrow\u003c\u0026FungibleTokenSwitchboard.Switchboard\u003e(from: FungibleTokenSwitchboard.StoragePath)\n        if switchboardRef == nil{\n            let sb \u003c- FungibleTokenSwitchboard.createSwitchboard()\n            acct.save(\u003c- sb, to: FungibleTokenSwitchboard.StoragePath)\n            acct.link\u003c\u0026FungibleTokenSwitchboard.Switchboard{FungibleToken.Receiver}\u003e( FungibleTokenSwitchboard.ReceiverPublicPath, target: FungibleTokenSwitchboard.StoragePath)\n            acct.link\u003c\u0026FungibleTokenSwitchboard.Switchboard{FungibleTokenSwitchboard.SwitchboardPublic, FungibleToken.Receiver}\u003e(\n                FungibleTokenSwitchboard.PublicPath,\n                target: FungibleTokenSwitchboard.StoragePath\n            )\n        }\n        let switchboard = acct.borrow\u003c\u0026FungibleTokenSwitchboard.Switchboard\u003e(from: FungibleTokenSwitchboard.StoragePath)!\n        let types = switchboard.getVaultTypes()\n        if !types.contains(Type\u003c@DapperUtilityCoin.Vault\u003e()) {\n            switchboard.addNewVaultWrapper(capability: dapperDUCReceiver, type: Type\u003c@DapperUtilityCoin.Vault\u003e())\n        }\n        if !types.contains(Type\u003c@FlowUtilityToken.Vault\u003e()) {\n            switchboard.addNewVaultWrapper(capability: dapperFUTReceiver, type: Type\u003c@FlowUtilityToken.Vault\u003e())\n        }\n        if !types.contains(usdcCap.borrow()!.getType()) {\n            switchboard.addNewVault(capability: usdcCap)\n        }\n        if !types.contains(fusdReceiver.borrow()!.getType()) {\n            switchboard.addNewVault(capability: fusdReceiver)\n        }\n        let flowTokenCap = acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver)\n        if !types.contains(flowTokenCap.borrow()!.getType()) {\n            switchboard.addNewVault(capability: flowTokenCap)\n        }\n\n    }\n}",
               "spec": {
                  "order": [
                     "dapperAddress"
                  ],
                  "parameters": {
                     "dapperAddress": "Address"
                  }
               }
            },
            "initWearables": {
               "code": "import Wearables from 0x1e0493ee604e7598\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\n\ntransaction() {\n    prepare(account: AuthAccount) {\n\n        let wearablesRef= account.borrow\u003c\u0026Wearables.Collection\u003e(from: Wearables.CollectionStoragePath)\n        if wearablesRef == nil {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Wearables.createEmptyCollection(), to: Wearables.CollectionStoragePath)\n            account.unlink(Wearables.CollectionPublicPath)\n            account.link\u003c\u0026Wearables.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                Wearables.CollectionPublicPath,\n                target: Wearables.CollectionStoragePath\n            )\n            account.unlink(Wearables.CollectionPrivatePath)\n            account.link\u003c\u0026Wearables.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                Wearables.CollectionPrivatePath,\n                target: Wearables.CollectionStoragePath\n            )\n            return\n        }\n\n        let wearablesCap= account.getCapability\u003c\u0026Wearables.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(Wearables.CollectionPublicPath)\n        if !wearablesCap.check() {\n            account.unlink(Wearables.CollectionPublicPath)\n            account.link\u003c\u0026Wearables.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                Wearables.CollectionPublicPath,\n                target: Wearables.CollectionStoragePath\n            )\n        }\n\n        let wearablesProviderCap= account.getCapability\u003c\u0026Wearables.Collection{NonFungibleToken.Provider,NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(Wearables.CollectionPrivatePath)\n        if !wearablesProviderCap.check() {\n            account.unlink(Wearables.CollectionPrivatePath)\n            account.link\u003c\u0026Wearables.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                Wearables.CollectionPrivatePath,\n                target: Wearables.CollectionStoragePath\n            )\n        }\n\n    }\n}",
               "spec": {
                  "order": [],
                  "parameters": {}
               }
            },
            "linkDUCVaultReceiver": {
               "code": "import TokenForwarding from 0x51ea0e37c27a1f1a\nimport FungibleToken from 0x9a0766d93b6608b7\n\n\ntransaction() {\n    prepare(account: AuthAccount) {\n        account.unlink(/public/dapperUtilityCoinReceiver)\n        account.link\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver,target: /storage/dapperUtilityCoinVault)\n    }\n}",
               "spec": {
                  "order": [],
                  "parameters": {}
               }
            },
            "listForSaleMultiple": {
               "code": "import FIND from 0x35717efbbce11c74\nimport FUSD from 0xe223d8a629e49c68\nimport FindMarket from 0x35717efbbce11c74\nimport FindMarketSale from 0x35717efbbce11c74\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FindViews from 0x35717efbbce11c74\nimport NFTCatalog from 0x324c34e1c517e4db\nimport FINDNFTCatalog from 0x35717efbbce11c74\nimport FTRegistry from 0x35717efbbce11c74\n\ntransaction(marketplace:Address, nftAliasOrIdentifiers: [String], ids: [AnyStruct], ftAliasOrIdentifiers: [String], directSellPrices:[UFix64], validUntil: UFix64?) {\n\n    let saleItems : \u0026FindMarketSale.SaleItemCollection?\n    let pointers : [FindViews.AuthNFTPointer]\n    let leaseNames : [String]\n    let vaultTypes : [Type]\n    let finLeases : \u0026FIND.LeaseCollection\n\n    prepare(account: AuthAccount) {\n\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n        let tenant = tenantCapability.borrow()!\n        self.vaultTypes= []\n        self.pointers= []\n        self.leaseNames= []\n        self.finLeases= account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath) ?? panic(\"Cannot borrow reference to find lease collection\")\n\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath)\n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n        self.saleItems= account.borrow\u003c\u0026FindMarketSale.SaleItemCollection\u003e(from: storagePath)!\n\n        var counter = 0\n\n        let nfts : {String : NFTCatalog.NFTCollectionData} = {}\n        let fts : {String : FTRegistry.FTInfo} = {}\n\n        while counter \u003c ids.length {\n            var ft : FTRegistry.FTInfo? = nil\n\n            if fts[ftAliasOrIdentifiers[counter]] != nil {\n                ft = fts[ftAliasOrIdentifiers[counter]]\n            } else {\n                ft = FTRegistry.getFTInfo(ftAliasOrIdentifiers[counter]) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftAliasOrIdentifiers[counter]))\n                fts[ftAliasOrIdentifiers[counter]] = ft\n            }\n\n            if let name = ids[counter] as? String {\n                if nftAliasOrIdentifiers[counter] != Type\u003c@FIND.Lease\u003e().identifier {\n                    panic(\"Lease does not match with identifiers\")\n                }\n                if ftAliasOrIdentifiers[counter] != Type\u003c@FUSD.Vault\u003e().identifier {\n                    panic(\"Listing of leases only supports FUSD at the moment\")\n                }\n                self.leaseNames.append(name)\n            }\n\n            if let id = ids[counter] as? UInt64 {\n                // Get supported NFT and FT Information from Registries from input alias\n                var nft : NFTCatalog.NFTCollectionData? = nil\n\n                if nfts[nftAliasOrIdentifiers[counter]] != nil {\n                    nft = nfts[nftAliasOrIdentifiers[counter]]\n                } else {\n                    let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftAliasOrIdentifiers[counter])?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftAliasOrIdentifiers[counter]))\n                    let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])!\n                    nft = collection.collectionData\n                    nfts[nftAliasOrIdentifiers[counter]] = nft\n                }\n\n                var providerCap=account.getCapability\u003c\u0026{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e(nft!.privatePath)\n\n                /* Ben : Question -\u003e Either client will have to provide the path here or agree that we set it up for the user */\n                if !providerCap.check() {\n                    let newCap = account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                            nft!.privatePath,\n                            target: nft!.storagePath\n                    )\n                    if newCap == nil {\n                        // If linking is not successful, we link it using finds custom link\n                        let pathIdentifier = nft!.privatePath.toString()\n                        let findPath = PrivatePath(identifier: pathIdentifier.slice(from: \"/private/\".length , upTo: pathIdentifier.length).concat(\"_FIND\"))!\n                        account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                            findPath,\n                            target: nft!.storagePath\n                        )\n                        providerCap = account.getCapability\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(findPath)\n                    }\n                }\n                // Get the salesItemRef from tenant\n                self.pointers.append(FindViews.AuthNFTPointer(cap: providerCap, id: id))\n            }\n\n            self.vaultTypes.append(ft!.type)\n            counter = counter + 1\n        }\n    }\n\n    execute{\n        var counter = 0\n        var nameCounter = 0\n        for identifier in nftAliasOrIdentifiers {\n            let vc = counter + nameCounter\n            if identifier == Type\u003c@FIND.Lease\u003e().identifier {\n                self.finLeases.listForSale(name: self.leaseNames[nameCounter],  directSellPrice:directSellPrices[vc])\n                nameCounter = nameCounter + 1\n                continue\n            }\n\n            self.saleItems!.listForSale(pointer: self.pointers[counter], vaultType: self.vaultTypes[vc], directSellPrice: directSellPrices[vc], validUntil: validUntil, extraField: {})\n            counter = counter + 1\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "nftAliasOrIdentifiers",
                     "ids",
                     "ftAliasOrIdentifiers",
                     "directSellPrices",
                     "validUntil"
                  ],
                  "parameters": {
                     "directSellPrices": "[UFix64]",
                     "ftAliasOrIdentifiers": "[String]",
                     "ids": "[AnyStruct]",
                     "marketplace": "Address",
                     "nftAliasOrIdentifiers": "[String]",
                     "validUntil": "UFix64?"
                  }
               }
            },
            "listLeaseForAuctionSoft": {
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FTRegistry from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\nimport FindLeaseMarketAuctionSoft from 0x35717efbbce11c74\nimport FindLeaseMarket from 0x35717efbbce11c74\n\ntransaction(leaseName: String, ftAliasOrIdentifier:String, price:UFix64, auctionReservePrice: UFix64, auctionDuration: UFix64, auctionExtensionOnLateBid: UFix64, minimumBidIncrement: UFix64, auctionValidUntil: UFix64?) {\n\n    let saleItems : \u0026FindLeaseMarketAuctionSoft.SaleItemCollection?\n    let pointer : FindLeaseMarket.AuthLeasePointer\n    let vaultType : Type\n\n    prepare(account: AuthAccount) {\n\n        // Get supported NFT and FT Information from Registries from input alias\n        let ft = FTRegistry.getFTInfo(ftAliasOrIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftAliasOrIdentifier))\n\n        let leaseMarketplace = FindMarket.getFindTenantAddress()\n        let leaseTenantCapability= FindMarket.getTenantCapability(leaseMarketplace)!\n        let leaseTenant = leaseTenantCapability.borrow()!\n\n        let leaseASSaleItemType= Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e()\n        let leaseASPublicPath=leaseTenant.getPublicPath(leaseASSaleItemType)\n        let leaseASStoragePath= leaseTenant.getStoragePath(leaseASSaleItemType)\n        let leaseASSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath)\n        if !leaseASSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseASStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath, target: leaseASStoragePath)\n        }\n\n        self.saleItems= account.borrow\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(from: leaseASStoragePath)\n        let ref = account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from: FIND.LeaseStoragePath)!\n        self.pointer= FindLeaseMarket.AuthLeasePointer(ref: ref, name: leaseName)\n        self.vaultType= ft.type\n\n    }\n\n    pre{\n        // Ben : panic on some unreasonable inputs in trxn\n        minimumBidIncrement \u003e 0.0 :\"Minimum bid increment should be larger than 0.\"\n        (auctionReservePrice - auctionReservePrice) % minimumBidIncrement == 0.0 : \"Acution ReservePrice should be in step of minimum bid increment.\"\n        auctionDuration \u003e 0.0 : \"Auction Duration should be greater than 0.\"\n        auctionExtensionOnLateBid \u003e 0.0 : \"Auction Duration should be greater than 0.\"\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        self.saleItems!.listForAuction(pointer: self.pointer, vaultType: self.vaultType, auctionStartPrice: price, auctionReservePrice: auctionReservePrice, auctionDuration: auctionDuration, auctionExtensionOnLateBid: auctionExtensionOnLateBid, minimumBidIncrement: minimumBidIncrement, auctionValidUntil: auctionValidUntil, saleItemExtraField: {})\n\n    }\n}",
               "spec": {
                  "order": [
                     "leaseName",
                     "ftAliasOrIdentifier",
                     "price",
                     "auctionReservePrice",
                     "auctionDuration",
                     "auctionExtensionOnLateBid",
                     "minimumBidIncrement",
                     "auctionValidUntil"
                  ],
                  "parameters": {
                     "auctionDuration": "UFix64",
                     "auctionExtensionOnLateBid": "UFix64",
                     "auctionReservePrice": "UFix64",
                     "auctionValidUntil": "UFix64?",
                     "ftAliasOrIdentifier": "String",
                     "leaseName": "String",
                     "minimumBidIncrement": "UFix64",
                     "price": "UFix64"
                  }
               }
            },
            "listLeaseForAuctionSoftDapper": {
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FTRegistry from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\nimport FindLeaseMarketAuctionSoft from 0x35717efbbce11c74\nimport FindLeaseMarket from 0x35717efbbce11c74\n\ntransaction(leaseName: String, ftAliasOrIdentifier: String, price:UFix64, auctionReservePrice: UFix64, auctionDuration: UFix64, auctionExtensionOnLateBid: UFix64, minimumBidIncrement: UFix64, auctionValidUntil: UFix64?) {\n\n    let saleItems : \u0026FindLeaseMarketAuctionSoft.SaleItemCollection?\n    let pointer : FindLeaseMarket.AuthLeasePointer\n    let vaultType : Type\n\n    prepare(account: AuthAccount) {\n\n        // Get supported NFT and FT Information from Registries from input alias\n        let ft = FTRegistry.getFTInfo(ftAliasOrIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftAliasOrIdentifier))\n\n        let leaseMarketplace = FindMarket.getFindTenantAddress()\n        let leaseTenantCapability= FindMarket.getTenantCapability(leaseMarketplace)!\n        let leaseTenant = leaseTenantCapability.borrow()!\n\n        let leaseASSaleItemType= Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e()\n        let leaseASPublicPath=leaseTenant.getPublicPath(leaseASSaleItemType)\n        let leaseASStoragePath= leaseTenant.getStoragePath(leaseASSaleItemType)\n        let leaseASSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath)\n        if !leaseASSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseASStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath, target: leaseASStoragePath)\n        }\n\n        self.saleItems= account.borrow\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(from: leaseASStoragePath)\n        let ref= account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from: FIND.LeaseStoragePath)!\n        self.pointer= FindLeaseMarket.AuthLeasePointer(ref: ref, name: leaseName)\n        self.vaultType= ft.type\n    }\n\n    pre{\n        // Ben : panic on some unreasonable inputs in trxn\n        minimumBidIncrement \u003e 0.0 :\"Minimum bid increment should be larger than 0.\"\n        (auctionReservePrice - auctionReservePrice) % minimumBidIncrement == 0.0 : \"Acution ReservePrice should be in step of minimum bid increment.\"\n        auctionDuration \u003e 0.0 : \"Auction Duration should be greater than 0.\"\n        auctionExtensionOnLateBid \u003e 0.0 : \"Auction Duration should be greater than 0.\"\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        self.saleItems!.listForAuction(pointer: self.pointer, vaultType: self.vaultType, auctionStartPrice: price, auctionReservePrice: auctionReservePrice, auctionDuration: auctionDuration, auctionExtensionOnLateBid: auctionExtensionOnLateBid, minimumBidIncrement: minimumBidIncrement, auctionValidUntil: auctionValidUntil, saleItemExtraField: {})\n\n    }\n}",
               "spec": {
                  "order": [
                     "leaseName",
                     "ftAliasOrIdentifier",
                     "price",
                     "auctionReservePrice",
                     "auctionDuration",
                     "auctionExtensionOnLateBid",
                     "minimumBidIncrement",
                     "auctionValidUntil"
                  ],
                  "parameters": {
                     "auctionDuration": "UFix64",
                     "auctionExtensionOnLateBid": "UFix64",
                     "auctionReservePrice": "UFix64",
                     "auctionValidUntil": "UFix64?",
                     "ftAliasOrIdentifier": "String",
                     "leaseName": "String",
                     "minimumBidIncrement": "UFix64",
                     "price": "UFix64"
                  }
               }
            },
            "listLeaseForSale": {
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\nimport FTRegistry from 0x35717efbbce11c74\nimport FindLeaseMarketSale from 0x35717efbbce11c74\nimport FindLeaseMarket from 0x35717efbbce11c74\n\ntransaction(leaseName: String, ftAliasOrIdentifier: String, directSellPrice:UFix64, validUntil: UFix64?) {\n\n    let saleItems : \u0026FindLeaseMarketSale.SaleItemCollection?\n    let pointer : FindLeaseMarket.AuthLeasePointer\n    let vaultType : Type\n\n    prepare(account: AuthAccount) {\n\n        // Get the salesItemRef from tenant\n        let leaseMarketplace = FindMarket.getFindTenantAddress()\n        let leaseTenantCapability= FindMarket.getTenantCapability(leaseMarketplace)!\n        let leaseTenant = leaseTenantCapability.borrow()!\n\n        let leaseSaleItemType= Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()\n        let leasePublicPath=leaseTenant.getPublicPath(leaseSaleItemType)\n        let leaseStoragePath= leaseTenant.getStoragePath(leaseSaleItemType)\n        let leaseSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath)\n        if !leaseSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketSale.SaleItemCollection\u003e(\u003c- FindLeaseMarketSale.createEmptySaleItemCollection(leaseTenantCapability), to: leaseStoragePath)\n            account.link\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath, target: leaseStoragePath)\n        }\n\n        self.saleItems= account.borrow\u003c\u0026FindLeaseMarketSale.SaleItemCollection\u003e(from: leaseStoragePath)!\n\n        // Get supported NFT and FT Information from Registries from input alias\n        let ft = FTRegistry.getFTInfo(ftAliasOrIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftAliasOrIdentifier))\n        self.vaultType= ft.type\n\n        let lease=account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from: FIND.LeaseStoragePath)!\n\n\n        self.pointer= FindLeaseMarket.AuthLeasePointer(ref:lease, name: leaseName)\n\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        self.saleItems!.listForSale(pointer: self.pointer, vaultType: self.vaultType, directSellPrice: directSellPrice, validUntil: validUntil, extraField: {})\n    }\n}",
               "spec": {
                  "order": [
                     "leaseName",
                     "ftAliasOrIdentifier",
                     "directSellPrice",
                     "validUntil"
                  ],
                  "parameters": {
                     "directSellPrice": "UFix64",
                     "ftAliasOrIdentifier": "String",
                     "leaseName": "String",
                     "validUntil": "UFix64?"
                  }
               }
            },
            "listLeaseForSaleDapper": {
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\nimport FTRegistry from 0x35717efbbce11c74\nimport FindLeaseMarketSale from 0x35717efbbce11c74\nimport FindLeaseMarket from 0x35717efbbce11c74\n\ntransaction(leaseName: String, ftAliasOrIdentifier: String, directSellPrice:UFix64, validUntil: UFix64?) {\n\n    let saleItems : \u0026FindLeaseMarketSale.SaleItemCollection?\n    let pointer : FindLeaseMarket.AuthLeasePointer\n    let vaultType : Type\n\n    prepare(account: AuthAccount) {\n\n        // Get the salesItemRef from tenant\n        let leaseMarketplace = FindMarket.getFindTenantAddress()\n        let leaseTenantCapability= FindMarket.getTenantCapability(leaseMarketplace)!\n        let leaseTenant = leaseTenantCapability.borrow()!\n\n        let leaseSaleItemType= Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()\n        let leasePublicPath=leaseTenant.getPublicPath(leaseSaleItemType)\n        let leaseStoragePath= leaseTenant.getStoragePath(leaseSaleItemType)\n        let leaseSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath)\n        if !leaseSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketSale.SaleItemCollection\u003e(\u003c- FindLeaseMarketSale.createEmptySaleItemCollection(leaseTenantCapability), to: leaseStoragePath)\n            account.link\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath, target: leaseStoragePath)\n        }\n\n        self.saleItems= account.borrow\u003c\u0026FindLeaseMarketSale.SaleItemCollection\u003e(from: leaseStoragePath)!\n\n        // Get supported NFT and FT Information from Registries from input alias\n        let ft = FTRegistry.getFTInfo(ftAliasOrIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftAliasOrIdentifier))\n        self.vaultType= ft.type\n\n        let ref=account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from: FIND.LeaseStoragePath)!\n\n        self.pointer= FindLeaseMarket.AuthLeasePointer(ref: ref, name: leaseName)\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        self.saleItems!.listForSale(pointer: self.pointer, vaultType: self.vaultType, directSellPrice: directSellPrice, validUntil: validUntil, extraField: {})\n\n    }\n\n}",
               "spec": {
                  "order": [
                     "leaseName",
                     "ftAliasOrIdentifier",
                     "directSellPrice",
                     "validUntil"
                  ],
                  "parameters": {
                     "directSellPrice": "UFix64",
                     "ftAliasOrIdentifier": "String",
                     "leaseName": "String",
                     "validUntil": "UFix64?"
                  }
               }
            },
            "listMultipleNFTForSale": {
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FindMarketSale from 0x35717efbbce11c74\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FindViews from 0x35717efbbce11c74\nimport NFTCatalog from 0x324c34e1c517e4db\nimport FINDNFTCatalog from 0x35717efbbce11c74\nimport FTRegistry from 0x35717efbbce11c74\n\ntransaction(marketplace:Address, nftAliasOrIdentifiers: [String], ids: [UInt64], ftAliasOrIdentifiers: [String], directSellPrices:[UFix64], validUntil: UFix64?) {\n    \n    let saleItems : \u0026FindMarketSale.SaleItemCollection?\n    let pointers : [FindViews.AuthNFTPointer]\n    let vaultTypes : [Type]\n\n    prepare(account: AuthAccount) {\n\n        if nftAliasOrIdentifiers.length != ids.length {\n            panic(\"The length of arrays passed in has to be the same\")\n        } else if nftAliasOrIdentifiers.length != ftAliasOrIdentifiers.length {\n            panic(\"The length of arrays passed in has to be the same\")\n        } else if nftAliasOrIdentifiers.length != directSellPrices.length {\n            panic(\"The length of arrays passed in has to be the same\")\n        }\n        \n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n        let tenant = tenantCapability.borrow()!\n        self.saleItems= account.borrow\u003c\u0026FindMarketSale.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketSale.SaleItemCollection\u003e()))\n        self.vaultTypes= []\n        self.pointers= []\n\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        var counter = 0\n\n        let nfts : {String : NFTCatalog.NFTCollectionData} = {}\n        let fts : {String : FTRegistry.FTInfo} = {}\n\n        while counter \u003c ids.length {\n            // Get supported NFT and FT Information from Registries from input alias\n            var nft : NFTCatalog.NFTCollectionData? = nil\n            var ft : FTRegistry.FTInfo? = nil\n\n            if nfts[nftAliasOrIdentifiers[counter]] != nil {\n                nft = nfts[nftAliasOrIdentifiers[counter]]\n            } else {\n                let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftAliasOrIdentifiers[counter])?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftAliasOrIdentifiers[counter])) \n                let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n                nft = collection.collectionData\n                nfts[nftAliasOrIdentifiers[counter]] = nft\n            }\n\n            if fts[ftAliasOrIdentifiers[counter]] != nil {\n                ft = fts[ftAliasOrIdentifiers[counter]]\n            } else {\n                ft = FTRegistry.getFTInfo(ftAliasOrIdentifiers[counter]) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftAliasOrIdentifiers[counter]))\n                fts[ftAliasOrIdentifiers[counter]] = ft \n            }\n\n            var providerCap=account.getCapability\u003c\u0026{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e(nft!.privatePath)\n\n            /* Ben : Question -\u003e Either client will have to provide the path here or agree that we set it up for the user */\n            if !providerCap.check() {\n                let newCap = account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                        nft!.privatePath,\n                        target: nft!.storagePath\n                )\n                if newCap == nil {\n                    // If linking is not successful, we link it using finds custom link \n                    let pathIdentifier = nft!.privatePath.toString()\n                    let findPath = PrivatePath(identifier: pathIdentifier.slice(from: \"/private/\".length , upTo: pathIdentifier.length).concat(\"_FIND\"))!\n                    account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                        findPath,\n                        target: nft!.storagePath\n                    )\n                    providerCap = account.getCapability\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(findPath)\n                }\n            }\n            // Get the salesItemRef from tenant\n            self.pointers.append(FindViews.AuthNFTPointer(cap: providerCap, id: ids[counter]))\n            self.vaultTypes.append(ft!.type)\n            counter = counter + 1\n        }\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        var counter = 0\n        while counter \u003c ids.length {\n            self.saleItems!.listForSale(pointer: self.pointers[counter], vaultType: self.vaultTypes[counter], directSellPrice: directSellPrices[counter], validUntil: validUntil, extraField: {})\n            counter = counter + 1\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "nftAliasOrIdentifiers",
                     "ids",
                     "ftAliasOrIdentifiers",
                     "directSellPrices",
                     "validUntil"
                  ],
                  "parameters": {
                     "directSellPrices": "[UFix64]",
                     "ftAliasOrIdentifiers": "[String]",
                     "ids": "[UInt64]",
                     "marketplace": "Address",
                     "nftAliasOrIdentifiers": "[String]",
                     "validUntil": "UFix64?"
                  }
               }
            },
            "listMultipleNFTForSaleDapper": {
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FindMarketSale from 0x35717efbbce11c74\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FindViews from 0x35717efbbce11c74\nimport NFTCatalog from 0x324c34e1c517e4db\nimport FINDNFTCatalog from 0x35717efbbce11c74\nimport FTRegistry from 0x35717efbbce11c74\n\ntransaction(marketplace:Address, nftAliasOrIdentifiers: [String], ids: [UInt64], ftAliasOrIdentifiers: [String], directSellPrices:[UFix64], validUntil: UFix64?) {\n    \n    let saleItems : \u0026FindMarketSale.SaleItemCollection?\n    let pointers : [FindViews.AuthNFTPointer]\n    let vaultTypes : [Type]\n    \n    prepare(account: AuthAccount) {\n\n        if nftAliasOrIdentifiers.length != ids.length {\n            panic(\"The length of arrays passed in has to be the same\")\n        } else if nftAliasOrIdentifiers.length != directSellPrices.length {\n            panic(\"The length of arrays passed in has to be the same\")\n        }\n\n\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n        let tenant = tenantCapability.borrow()!\n        self.saleItems= account.borrow\u003c\u0026FindMarketSale.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketSale.SaleItemCollection\u003e()))\n        self.pointers= []\n        self.vaultTypes= []\n\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        let nfts : {String : NFTCatalog.NFTCollectionData} = {}\n        let fts : {String : FTRegistry.FTInfo} = {}\n\n        var counter = 0\n        while counter \u003c ids.length {\n            // Get supported NFT and FT Information from Registries from input alias\n            var nft : NFTCatalog.NFTCollectionData? = nil\n\n            if nfts[nftAliasOrIdentifiers[counter]] != nil {\n                nft = nfts[nftAliasOrIdentifiers[counter]]\n            } else {\n                let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftAliasOrIdentifiers[counter])?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftAliasOrIdentifiers[counter])) \n                let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n                nft = collection.collectionData\n                nfts[nftAliasOrIdentifiers[counter]] = nft\n            }\n\n            if fts[ftAliasOrIdentifiers[counter]] != nil {\n                let ft = fts[ftAliasOrIdentifiers[counter]]!\n                self.vaultTypes.append(ft.type)\n            } else {\n                let ft = FTRegistry.getFTInfo(ftAliasOrIdentifiers[counter]) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftAliasOrIdentifiers[counter]))\n                fts[ftAliasOrIdentifiers[counter]] = ft \n                self.vaultTypes.append(ft.type)\n            }\n\n\n\n            var providerCap=account.getCapability\u003c\u0026{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e(nft!.privatePath)\n\n            /* Ben : Question -\u003e Either client will have to provide the path here or agree that we set it up for the user */\n            if !providerCap.check() {\n                let newCap = account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                        nft!.privatePath,\n                        target: nft!.storagePath\n                )\n                if newCap == nil {\n                    // If linking is not successful, we link it using finds custom link \n                    let pathIdentifier = nft!.privatePath.toString()\n                    let findPath = PrivatePath(identifier: pathIdentifier.slice(from: \"/private/\".length , upTo: pathIdentifier.length).concat(\"_FIND\"))!\n                    account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                        findPath,\n                        target: nft!.storagePath\n                    )\n                    providerCap = account.getCapability\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(findPath)\n                }\n            }\n            // Get the salesItemRef from tenant\n            self.pointers.append(FindViews.AuthNFTPointer(cap: providerCap, id: ids[counter]))\n            counter = counter + 1\n        }\n\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        var counter = 0\n        while counter \u003c ids.length {\n            self.saleItems!.listForSale(pointer: self.pointers[counter], vaultType: self.vaultTypes[counter], directSellPrice: directSellPrices[counter], validUntil: validUntil, extraField: {})\n            counter = counter + 1\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "nftAliasOrIdentifiers",
                     "ids",
                     "ftAliasOrIdentifiers",
                     "directSellPrices",
                     "validUntil"
                  ],
                  "parameters": {
                     "directSellPrices": "[UFix64]",
                     "ftAliasOrIdentifiers": "[String]",
                     "ids": "[UInt64]",
                     "marketplace": "Address",
                     "nftAliasOrIdentifiers": "[String]",
                     "validUntil": "UFix64?"
                  }
               }
            },
            "listNFTForAuctionEscrowed": {
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FindMarketAuctionEscrow from 0x35717efbbce11c74\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FindViews from 0x35717efbbce11c74\nimport FINDNFTCatalog from 0x35717efbbce11c74\nimport FTRegistry from 0x35717efbbce11c74\n\ntransaction(marketplace:Address, nftAliasOrIdentifier:String, id: UInt64, ftAliasOrIdentifier:String, price:UFix64, auctionReservePrice: UFix64, auctionDuration: UFix64, auctionExtensionOnLateBid: UFix64, minimumBidIncrement: UFix64, auctionStartTime: UFix64?, auctionValidUntil: UFix64?) {\n    \n    let saleItems : \u0026FindMarketAuctionEscrow.SaleItemCollection?\n    let vaultType : Type\n    let pointer : FindViews.AuthNFTPointer\n    \n    prepare(account: AuthAccount) {\n\n\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n        let tenant = tenantCapability.borrow()!\n        let path=FindMarket.getStoragePath(Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(), name: tenant.name)\n\n        /// auctions that escrow ft\n        let aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        let aeSalePublicPath=FindMarket.getPublicPath(aeSaleType, name: tenant.name)\n        let aeSaleStoragePath= FindMarket.getStoragePath(aeSaleType, name:tenant.name)\n        let aeSaleCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n        if !aeSaleCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n        }\n\n        // Get supported NFT and FT Information from Registries from input alias\n        let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftAliasOrIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftAliasOrIdentifier)) \n        let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n        let nft = collection.collectionData\n\n        let ft = FTRegistry.getFTInfo(ftAliasOrIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftAliasOrIdentifier))\n\n        var providerCap=account.getCapability\u003c\u0026{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e(nft.privatePath)\n        \n        /* Ben : Question -\u003e Either client will have to provide the path here or agree that we set it up for the user */\n        if !providerCap.check() {\n            let newCap = account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                    nft.privatePath,\n                    target: nft.storagePath\n            )\n            if newCap == nil {\n                // If linking is not successful, we link it using finds custom link \n                let pathIdentifier = nft.privatePath.toString()\n                let findPath = PrivatePath(identifier: pathIdentifier.slice(from: \"/private/\".length , upTo: pathIdentifier.length).concat(\"_FIND\"))!\n                account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                    findPath,\n                    target: nft.storagePath\n                )\n                providerCap = account.getCapability\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(findPath)\n            }\n        }\n\n        self.saleItems= account.borrow\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection\u003e(from: path)\n        self.pointer= FindViews.AuthNFTPointer(cap: providerCap, id: id)\n        self.vaultType= ft.type\n    }\n\n    pre{\n        // Ben : panic on some unreasonable inputs in trxn \n        minimumBidIncrement \u003e 0.0 : \"Minimum bid increment should be larger than 0.\"\n        (auctionReservePrice - auctionReservePrice) % minimumBidIncrement == 0.0 : \"Acution ReservePrice should be in step of minimum bid increment.\" \n        auctionDuration \u003e 0.0 : \"Auction Duration should be greater than 0.\"\n        auctionExtensionOnLateBid \u003e 0.0 : \"Auction Duration should be greater than 0.\"\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute {\n        self.saleItems!.listForAuction(pointer: self.pointer, vaultType: self.vaultType, auctionStartPrice: price, auctionReservePrice: auctionReservePrice, auctionDuration: auctionDuration, auctionExtensionOnLateBid: auctionExtensionOnLateBid, minimumBidIncrement: minimumBidIncrement, auctionStartTime: auctionStartTime, auctionValidUntil:auctionValidUntil, saleItemExtraField: {})\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "nftAliasOrIdentifier",
                     "id",
                     "ftAliasOrIdentifier",
                     "price",
                     "auctionReservePrice",
                     "auctionDuration",
                     "auctionExtensionOnLateBid",
                     "minimumBidIncrement",
                     "auctionStartTime",
                     "auctionValidUntil"
                  ],
                  "parameters": {
                     "auctionDuration": "UFix64",
                     "auctionExtensionOnLateBid": "UFix64",
                     "auctionReservePrice": "UFix64",
                     "auctionStartTime": "UFix64?",
                     "auctionValidUntil": "UFix64?",
                     "ftAliasOrIdentifier": "String",
                     "id": "UInt64",
                     "marketplace": "Address",
                     "minimumBidIncrement": "UFix64",
                     "nftAliasOrIdentifier": "String",
                     "price": "UFix64"
                  }
               }
            },
            "listNFTForAuctionSoft": {
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FindMarketAuctionSoft from 0x35717efbbce11c74\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FindViews from 0x35717efbbce11c74\nimport FTRegistry from 0x35717efbbce11c74\nimport FINDNFTCatalog from 0x35717efbbce11c74\n\ntransaction(marketplace:Address, nftAliasOrIdentifier:String, id: UInt64, ftAliasOrIdentifier:String, price:UFix64, auctionReservePrice: UFix64, auctionDuration: UFix64, auctionExtensionOnLateBid: UFix64, minimumBidIncrement: UFix64, auctionValidUntil: UFix64?) {\n    \n    let saleItems : \u0026FindMarketAuctionSoft.SaleItemCollection?\n    let pointer : FindViews.AuthNFTPointer\n    let vaultType : Type\n    \n    prepare(account: AuthAccount) {\n\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n        let tenant = tenantCapability.borrow()!\n\n         /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n        }\n\n        // Get supported NFT and FT Information from Registries from input alias\n        let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftAliasOrIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftAliasOrIdentifier)) \n        let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n        let nft = collection.collectionData\n\n        let ft = FTRegistry.getFTInfo(ftAliasOrIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftAliasOrIdentifier))\n\n        var providerCap = account.getCapability\u003c\u0026{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e(nft.privatePath)\n\n        /* Ben : Question -\u003e Either client will have to provide the path here or agree that we set it up for the user */\n        if !providerCap.check() {\n            let newCap = account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                    nft.privatePath,\n                    target: nft.storagePath\n            )\n            if newCap == nil {\n                // If linking is not successful, we link it using finds custom link \n                let pathIdentifier = nft.privatePath.toString()\n                let findPath = PrivatePath(identifier: pathIdentifier.slice(from: \"/private/\".length , upTo: pathIdentifier.length).concat(\"_FIND\"))!\n                account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                    findPath,\n                    target: nft.storagePath\n                )\n                providerCap = account.getCapability\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(findPath)\n            }\n        }\n        \n        self.saleItems= account.borrow\u003c\u0026FindMarketAuctionSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()))\n        self.pointer= FindViews.AuthNFTPointer(cap: providerCap, id: id)\n        self.vaultType= ft.type\n\n        \n\n    }\n\n    pre{\n        // Ben : panic on some unreasonable inputs in trxn \n        minimumBidIncrement \u003e 0.0 :\"Minimum bid increment should be larger than 0.\"\n        (auctionReservePrice - auctionReservePrice) % minimumBidIncrement == 0.0 : \"Acution ReservePrice should be in step of minimum bid increment.\" \n        auctionDuration \u003e 0.0 : \"Auction Duration should be greater than 0.\"\n        auctionExtensionOnLateBid \u003e 0.0 : \"Auction Duration should be greater than 0.\"\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        self.saleItems!.listForAuction(pointer: self.pointer, vaultType: self.vaultType, auctionStartPrice: price, auctionReservePrice: auctionReservePrice, auctionDuration: auctionDuration, auctionExtensionOnLateBid: auctionExtensionOnLateBid, minimumBidIncrement: minimumBidIncrement, auctionValidUntil: auctionValidUntil, saleItemExtraField: {})\n\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "nftAliasOrIdentifier",
                     "id",
                     "ftAliasOrIdentifier",
                     "price",
                     "auctionReservePrice",
                     "auctionDuration",
                     "auctionExtensionOnLateBid",
                     "minimumBidIncrement",
                     "auctionValidUntil"
                  ],
                  "parameters": {
                     "auctionDuration": "UFix64",
                     "auctionExtensionOnLateBid": "UFix64",
                     "auctionReservePrice": "UFix64",
                     "auctionValidUntil": "UFix64?",
                     "ftAliasOrIdentifier": "String",
                     "id": "UInt64",
                     "marketplace": "Address",
                     "minimumBidIncrement": "UFix64",
                     "nftAliasOrIdentifier": "String",
                     "price": "UFix64"
                  }
               }
            },
            "listNFTForAuctionSoftDapper": {
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FindMarketAuctionSoft from 0x35717efbbce11c74\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FindViews from 0x35717efbbce11c74\nimport FINDNFTCatalog from 0x35717efbbce11c74\nimport FTRegistry from 0x35717efbbce11c74\n\ntransaction(marketplace:Address, nftAliasOrIdentifier:String, id: UInt64, ftAliasOrIdentifier:String, price:UFix64, auctionReservePrice: UFix64, auctionDuration: UFix64, auctionExtensionOnLateBid: UFix64, minimumBidIncrement: UFix64, auctionValidUntil: UFix64?) {\n    \n    let saleItems : \u0026FindMarketAuctionSoft.SaleItemCollection?\n    let pointer : FindViews.AuthNFTPointer\n    let vaultType : Type\n    \n    prepare(account: AuthAccount) {\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n        let tenant = tenantCapability.borrow()!\n\n         /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n        }\n\n        // Get supported NFT and FT Information from Registries from input alias\n        let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftAliasOrIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftAliasOrIdentifier)) \n        let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n        let nft = collection.collectionData\n\n        let ft = FTRegistry.getFTInfo(ftAliasOrIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftAliasOrIdentifier))\n\n        var providerCap = account.getCapability\u003c\u0026{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e(nft.privatePath)\n\n        /* Ben : Question -\u003e Either client will have to provide the path here or agree that we set it up for the user */\n        if !providerCap.check() {\n            let newCap = account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                    nft.privatePath,\n                    target: nft.storagePath\n            )\n            if newCap == nil {\n                // If linking is not successful, we link it using finds custom link \n                let pathIdentifier = nft.privatePath.toString()\n                let findPath = PrivatePath(identifier: pathIdentifier.slice(from: \"/private/\".length , upTo: pathIdentifier.length).concat(\"_FIND\"))!\n                account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                    findPath,\n                    target: nft.storagePath\n                )\n                providerCap = account.getCapability\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(findPath)\n            }\n        }\n        \n\n        self.saleItems= account.borrow\u003c\u0026FindMarketAuctionSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()))\n        self.pointer= FindViews.AuthNFTPointer(cap: providerCap, id: id)    \n        self.vaultType= ft.type    \n    }\n\n    pre{\n        // Ben : panic on some unreasonable inputs in trxn \n        minimumBidIncrement \u003e 0.0 :\"Minimum bid increment should be larger than 0.\"\n        (auctionReservePrice - auctionReservePrice) % minimumBidIncrement == 0.0 : \"Acution ReservePrice should be in step of minimum bid increment.\" \n        auctionDuration \u003e 0.0 : \"Auction Duration should be greater than 0.\"\n        auctionExtensionOnLateBid \u003e 0.0 : \"Auction Duration should be greater than 0.\"\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        self.saleItems!.listForAuction(pointer: self.pointer, vaultType: self.vaultType, auctionStartPrice: price, auctionReservePrice: auctionReservePrice, auctionDuration: auctionDuration, auctionExtensionOnLateBid: auctionExtensionOnLateBid, minimumBidIncrement: minimumBidIncrement, auctionValidUntil: auctionValidUntil, saleItemExtraField: {})\n\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "nftAliasOrIdentifier",
                     "id",
                     "ftAliasOrIdentifier",
                     "price",
                     "auctionReservePrice",
                     "auctionDuration",
                     "auctionExtensionOnLateBid",
                     "minimumBidIncrement",
                     "auctionValidUntil"
                  ],
                  "parameters": {
                     "auctionDuration": "UFix64",
                     "auctionExtensionOnLateBid": "UFix64",
                     "auctionReservePrice": "UFix64",
                     "auctionValidUntil": "UFix64?",
                     "ftAliasOrIdentifier": "String",
                     "id": "UInt64",
                     "marketplace": "Address",
                     "minimumBidIncrement": "UFix64",
                     "nftAliasOrIdentifier": "String",
                     "price": "UFix64"
                  }
               }
            },
            "listNFTForSale": {
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FindMarketSale from 0x35717efbbce11c74\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FindViews from 0x35717efbbce11c74\nimport FINDNFTCatalog from 0x35717efbbce11c74\nimport FTRegistry from 0x35717efbbce11c74\n\ntransaction(marketplace:Address, nftAliasOrIdentifier: String, id: UInt64, ftAliasOrIdentifier: String, directSellPrice:UFix64, validUntil: UFix64?) {\n\n    let saleItems : \u0026FindMarketSale.SaleItemCollection?\n    let pointer : FindViews.AuthNFTPointer\n    let vaultType : Type\n\n    prepare(account: AuthAccount) {\n\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath)\n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n        // Get supported NFT and FT Information from Registries from input alias\n        let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier:nftAliasOrIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftAliasOrIdentifier))\n        let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])!\n        let nft = collection.collectionData\n\n        let ft = FTRegistry.getFTInfo(ftAliasOrIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftAliasOrIdentifier))\n\n        var providerCap=account.getCapability\u003c\u0026{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e(nft.privatePath)\n\n        /* Ben : Question -\u003e Either client will have to provide the path here or agree that we set it up for the user */\n        if !providerCap.check() {\n            let newCap = account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                nft.privatePath,\n                target: nft.storagePath\n            )\n            if newCap == nil {\n                // If linking is not successful, we link it using finds custom link\n                let pathIdentifier = nft.privatePath.toString()\n                let findPath = PrivatePath(identifier: pathIdentifier.slice(from: \"/private/\".length , upTo: pathIdentifier.length).concat(\"_FIND\"))!\n                account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                    findPath,\n                    target: nft.storagePath\n                )\n                providerCap = account.getCapability\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(findPath)\n            }\n        }\n        // Get the salesItemRef from tenant\n        self.saleItems= account.borrow\u003c\u0026FindMarketSale.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketSale.SaleItemCollection\u003e()))\n        self.pointer= FindViews.AuthNFTPointer(cap: providerCap, id: id)\n        self.vaultType= ft.type\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        self.saleItems!.listForSale(pointer: self.pointer, vaultType: self.vaultType, directSellPrice: directSellPrice, validUntil: validUntil, extraField: {})\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "nftAliasOrIdentifier",
                     "id",
                     "ftAliasOrIdentifier",
                     "directSellPrice",
                     "validUntil"
                  ],
                  "parameters": {
                     "directSellPrice": "UFix64",
                     "ftAliasOrIdentifier": "String",
                     "id": "UInt64",
                     "marketplace": "Address",
                     "nftAliasOrIdentifier": "String",
                     "validUntil": "UFix64?"
                  }
               }
            },
            "listNFTForSaleDapper": {
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FindMarketSale from 0x35717efbbce11c74\nimport FINDNFTCatalog from 0x35717efbbce11c74\nimport FTRegistry from 0x35717efbbce11c74\nimport FindViews from 0x35717efbbce11c74\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FlowUtilityToken from 0x82ec283f88a62e65\nimport TokenForwarding from 0x51ea0e37c27a1f1a\nimport FungibleToken from 0x9a0766d93b6608b7\n\ntransaction(marketplace:Address, nftAliasOrIdentifier: String, id: UInt64, ftAliasOrIdentifier: String, directSellPrice:UFix64, validUntil: UFix64?) {\n    \n    let saleItems : \u0026FindMarketSale.SaleItemCollection?\n    let pointer : FindViews.AuthNFTPointer\n    let vaultType : Type\n    \n    prepare(account: AuthAccount) {\n\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n\n        let tenant = tenantCapability.borrow()!\n\n        //TODO:how do we fix this on testnet/mainnet\n        let dapper=getAccount(FindViews.getDapperAddress())\n\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        // Get supported NFT and FT Information from Registries from input alias\n        let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftAliasOrIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftAliasOrIdentifier)) \n        let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n        let nft = collection.collectionData\n\n        let ft = FTRegistry.getFTInfo(ftAliasOrIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftAliasOrIdentifier))\n\n        let futReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowUtilityTokenReceiver)\n        if ft.type == Type\u003c@FlowUtilityToken.Vault\u003e() \u0026\u0026 !futReceiver.check() {\n            // Create a new Forwarder resource for FUT and store it in the new account's storage\n            let futForwarder \u003c- TokenForwarding.createNewForwarder(recipient: dapper.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowUtilityTokenReceiver))\n            account.save(\u003c-futForwarder, to: /storage/flowUtilityTokenVault)\n            // Publish a Receiver capability for the new account, which is linked to the FUT Forwarder\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowUtilityTokenReceiver,target: /storage/flowUtilityTokenVault)\n        }\n\n\n        let providerCap=account.getCapability\u003c\u0026{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e(nft.privatePath)\n\n        if !providerCap.check() {\n            account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                nft.privatePath,\n                target: nft.storagePath\n            )\n        }\n        // Get the salesItemRef from tenant\n        self.saleItems= account.borrow\u003c\u0026FindMarketSale.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketSale.SaleItemCollection\u003e()))\n        self.pointer= FindViews.AuthNFTPointer(cap: providerCap, id: id)\n        self.vaultType= ft.type\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        self.saleItems!.listForSale(pointer: self.pointer, vaultType: self.vaultType, directSellPrice: directSellPrice, validUntil: validUntil, extraField: {})\n\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "nftAliasOrIdentifier",
                     "id",
                     "ftAliasOrIdentifier",
                     "directSellPrice",
                     "validUntil"
                  ],
                  "parameters": {
                     "directSellPrice": "UFix64",
                     "ftAliasOrIdentifier": "String",
                     "id": "UInt64",
                     "marketplace": "Address",
                     "nftAliasOrIdentifier": "String",
                     "validUntil": "UFix64?"
                  }
               }
            },
            "listNameForAuction": {
               "code": "import FIND from 0x35717efbbce11c74\n\ntransaction(name: String, auctionStartPrice: UFix64, auctionReservePrice: UFix64, auctionDuration: UFix64, auctionExtensionOnLateBid: UFix64) {\n    \n    let finLeases : \u0026FIND.LeaseCollection?\n\n    prepare(acct: AuthAccount) {\n        self.finLeases= acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)\n    }\n\n    pre{\n        self.finLeases != nil : \"Cannot borrow reference to find lease collection\"\n    }\n\n    execute{\n        self.finLeases!.listForAuction(name: name, auctionStartPrice: auctionStartPrice, auctionReservePrice: auctionReservePrice, auctionDuration: auctionDuration,  auctionExtensionOnLateBid: auctionExtensionOnLateBid)\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "auctionStartPrice",
                     "auctionReservePrice",
                     "auctionDuration",
                     "auctionExtensionOnLateBid"
                  ],
                  "parameters": {
                     "auctionDuration": "UFix64",
                     "auctionExtensionOnLateBid": "UFix64",
                     "auctionReservePrice": "UFix64",
                     "auctionStartPrice": "UFix64",
                     "name": "String"
                  }
               }
            },
            "listNameForSale": {
               "code": "import FIND from 0x35717efbbce11c74\n\ntransaction(name: String, directSellPrice:UFix64) {\n\n    let finLeases : \u0026FIND.LeaseCollection?\n\n    prepare(acct: AuthAccount) {\n        self.finLeases= acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)\n    }\n\n    pre{\n        self.finLeases != nil : \"Cannot borrow reference to find lease collection\"\n    }\n\n    execute{\n        self.finLeases!.listForSale(name: name,  directSellPrice:directSellPrice)\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "directSellPrice"
                  ],
                  "parameters": {
                     "directSellPrice": "UFix64",
                     "name": "String"
                  }
               }
            },
            "moveNameTO": {
               "code": "import Profile from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\n\n\ntransaction(name: String, receiver:String) {\n\n\n    let receiverAddress:Address?\n    let sender : \u0026FIND.LeaseCollection\n\n    prepare(acct: AuthAccount) {\n        self.sender= acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath) ?? panic(\"You do not have a profile set up, initialize the user first\")\n        self.receiverAddress=FIND.resolve(receiver)\n    } \n\n    pre{\n        self.receiverAddress != nil : \"The input pass in is not a valid name or address. Input : \".concat(receiver)\n    }\n\n    execute {\n        let receiver=getAccount(self.receiverAddress!)\n        let receiverLease = receiver.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        let receiverProfile = receiver.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\n        if !receiverLease.check() || !receiverProfile.check() {\n            panic(\"Not a valid FIND user\")\n        }\n\n        self.sender.move(name:name, profile:receiverProfile, to: receiverLease)\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "receiver"
                  ],
                  "parameters": {
                     "name": "String",
                     "receiver": "String"
                  }
               }
            },
            "moveNameToDapper": {
               "code": "import Profile from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\n\n\ntransaction(name: String, receiver:String) {\n\n\n    let receiverAddress:Address?\n    let sender : \u0026FIND.LeaseCollection\n\n    prepare(acct: AuthAccount) {\n        self.sender= acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath) ?? panic(\"You do not have a profile set up, initialize the user first\")\n        self.receiverAddress=FIND.resolve(receiver)\n    } \n\n    pre{\n        self.receiverAddress != nil : \"The input pass in is not a valid name or address. Input : \".concat(receiver)\n    }\n\n    execute {\n        let receiver=getAccount(self.receiverAddress!)\n        let receiverLease = receiver.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        let receiverProfile = receiver.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\n        if !receiverLease.check() || !receiverProfile.check() {\n            panic(\"Not a valid FIND user\")\n        }\n\n        self.sender.move(name:name, profile:receiverProfile, to: receiverLease)\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "receiver"
                  ],
                  "parameters": {
                     "name": "String",
                     "receiver": "String"
                  }
               }
            },
            "openBl0xPack": {
               "code": "import Bl0x from 0xe8124d8428980aa6\nimport Bl0xPack from 0xe8124d8428980aa6\nimport FungibleToken from 0x9a0766d93b6608b7\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\n\n/// A transaction to open a pack with a given id\n/// @param packId: The id of the pack to open\ntransaction(packId:UInt64) {\n\n    let packs: \u0026Bl0xPack.Collection\n    var receiver: Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e\n\n    prepare(account: AuthAccount) {\n        self.packs=account.borrow\u003c\u0026Bl0xPack.Collection\u003e(from: Bl0xPack.CollectionStoragePath)!\n        self.receiver = account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(Bl0x.CollectionPublicPath)\n        if !self.receiver.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Bl0x.createEmptyCollection(), to: Bl0x.CollectionStoragePath)\n            account.link\u003c\u0026Bl0x.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                Bl0x.CollectionPublicPath,\n                target: Bl0x.CollectionStoragePath\n            )\n            account.link\u003c\u0026Bl0x.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                Bl0x.CollectionPrivatePath,\n                target: Bl0x.CollectionStoragePath\n            )\n\n            self.receiver = account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(Bl0x.CollectionPublicPath)\n        }\n\n    }\n\n    pre {\n        self.receiver.check() : \"The receiver collection for the packs is not set up properly\"\n    }\n    execute {\n        self.packs.open(packId: packId, receiverCap:self.receiver)\n    }\n\n    post {\n        !self.packs.getIDs().contains(packId) : \"The pack is still present in the users collection\"\n    }\n}",
               "spec": {
                  "order": [
                     "packId"
                  ],
                  "parameters": {
                     "packId": "UInt64"
                  }
               }
            },
            "openFindPack": {
               "code": "import FindPack from 0x35717efbbce11c74\nimport FINDNFTCatalog from 0x35717efbbce11c74\nimport NFTCatalog from 0x324c34e1c517e4db\nimport FungibleToken from 0x9a0766d93b6608b7\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\n\n/// A transaction to open a pack with a given id\n/// @param packId: The id of the pack to open\ntransaction(packId:UInt64) {\n\n    let packs: \u0026FindPack.Collection\n    let receiver: { Type : Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e}\n\n    prepare(account: AuthAccount) {\n        self.packs=account.borrow\u003c\u0026FindPack.Collection\u003e(from: FindPack.CollectionStoragePath)!\n\n        let packData = self.packs.borrowFindPack(id: packId) ?? panic(\"You do not own this pack. ID : \".concat(packId.toString()))\n        let packMetadata = packData.getMetadata()\n        let types = packMetadata.itemTypes\n\n        self.receiver = {}\n\n        // check the account setup for receiving nfts\n        for type in types {\n            let collection = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: type.identifier)\n            if collection == nil || collection!.length == 0 {\n                panic(\"Type : \".concat(type.identifier).concat(\" is not supported in NFTCatalog at the moment\"))\n            }\n            let collectionInfo = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collection!.keys[0])!.collectionData\n\n            let cap = account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(collectionInfo.publicPath)\n            if !cap.check() {\n                let newCollection \u003c- FindPack.createEmptyCollectionFromPackData(packData: packMetadata, type: type)\n                account.save(\u003c- newCollection, to: collectionInfo.storagePath)\n                account.link\u003c\u0026{NonFungibleToken.Receiver, NonFungibleToken.CollectionPublic, MetadataViews.ResolverCollection}\u003e(\n                    collectionInfo.publicPath, target: collectionInfo.storagePath)\n            }\n            self.receiver[type] = cap\n        }\n\n    }\n\n    execute {\n        self.packs.open(packId: packId, receiverCap:self.receiver)\n    }\n\n    post {\n        !self.packs.getIDs().contains(packId) : \"The pack is still present in the users collection\"\n    }\n}",
               "spec": {
                  "order": [
                     "packId"
                  ],
                  "parameters": {
                     "packId": "UInt64"
                  }
               }
            },
            "orderForge": {
               "code": "import FindForge from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\nimport MetadataViews from 0x631e88ae7f1d7c20\n\n\ntransaction(name: String, mintType:String, minterCut: UFix64, collectionDisplay: MetadataViews.NFTCollectionDisplay) {\n\n    let leases : \u0026FIND.LeaseCollection?\n\n    prepare(account: AuthAccount) {\n\n        self.leases= account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)\n\n    }\n\n    pre{\n        self.leases != nil : \"Could not borrow reference to the leases collection\"\n    }\n\n    execute {\n        let lease = self.leases!.borrow(name)\n        var mintCut : UFix64? = minterCut\n        if minterCut == 0.0 {\n            mintCut = nil\n        } \n        FindForge.orderForge(lease: lease, mintType: mintType, minterCut: mintCut, collectionDisplay: collectionDisplay)\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "mintType",
                     "minterCut",
                     "collectionDisplay"
                  ],
                  "parameters": {
                     "collectionDisplay": "MetadataViews.NFTCollectionDisplay",
                     "mintType": "String",
                     "minterCut": "UFix64",
                     "name": "String"
                  }
               }
            },
            "publishFindThought": {
               "code": "import MetadataViews from 0x631e88ae7f1d7c20\nimport FindThoughts from 0x35717efbbce11c74\nimport FINDNFTCatalog from 0x35717efbbce11c74\nimport FindViews from 0x35717efbbce11c74\nimport FindUtils from 0x35717efbbce11c74\n\ntransaction(header: String , body: String , tags: [String], mediaHash: String?, mediaType: String?, quoteNFTOwner: Address?, quoteNFTType: String?, quoteNFTId: UInt64?, quoteCreator: Address?, quoteId: UInt64?) {\n\n    let collection : \u0026FindThoughts.Collection\n\n    prepare(account: AuthAccount) {\n        let thoughtsCap= account.getCapability\u003c\u0026{FindThoughts.CollectionPublic}\u003e(FindThoughts.CollectionPublicPath)\n        if !thoughtsCap.check() {\n            account.save(\u003c- FindThoughts.createEmptyCollection(), to: FindThoughts.CollectionStoragePath)\n            account.link\u003c\u0026FindThoughts.Collection{FindThoughts.CollectionPublic , MetadataViews.ResolverCollection}\u003e(\n                FindThoughts.CollectionPublicPath,\n                target: FindThoughts.CollectionStoragePath\n            )\n        }\n        self.collection=account.borrow\u003c\u0026FindThoughts.Collection\u003e(from: FindThoughts.CollectionStoragePath) ?? panic(\"Cannot borrow thoughts reference from path\")\n    }\n\n    execute {\n\n        var media : MetadataViews.Media? = nil \n        if mediaHash != nil {\n            var file : {MetadataViews.File}? = nil  \n            if FindUtils.hasPrefix(mediaHash!, prefix: \"ipfs://\") {\n                file = MetadataViews.IPFSFile(cid: mediaHash!.slice(from: \"ipfs://\".length , upTo: mediaHash!.length), path: nil) \n            } else {\n                file = MetadataViews.HTTPFile(url: mediaHash!) \n            }\n            media = MetadataViews.Media(file: file!, mediaType: mediaType!)\n        }\n\n        var nftPointer : FindViews.ViewReadPointer? = nil \n        if quoteNFTOwner != nil {\n                let path = FINDNFTCatalog.getCollectionDataForType(nftTypeIdentifier: quoteNFTType!)?.publicPath ?? panic(\"This nft type is not supported by NFT Catalog. Type : \".concat(quoteNFTType!))\n                let cap = getAccount(quoteNFTOwner!).getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(path)\n                nftPointer = FindViews.ViewReadPointer(cap: cap, id: quoteNFTId!)\n        }\n\n        var quote : FindThoughts.ThoughtPointer? = nil \n        if quoteCreator != nil {\n            quote = FindThoughts.ThoughtPointer(creator: quoteCreator!, id: quoteId!)\n        }\n\n        self.collection.publish(header: header, body: body, tags: tags, media: media, nftPointer: nftPointer, quote: quote)\n    }\n}",
               "spec": {
                  "order": [
                     "header",
                     "body",
                     "tags",
                     "mediaHash",
                     "mediaType",
                     "quoteNFTOwner",
                     "quoteNFTType",
                     "quoteNFTId",
                     "quoteCreator",
                     "quoteId"
                  ],
                  "parameters": {
                     "body": "String",
                     "header": "String",
                     "mediaHash": "String?",
                     "mediaType": "String?",
                     "quoteCreator": "Address?",
                     "quoteId": "UInt64?",
                     "quoteNFTId": "UInt64?",
                     "quoteNFTOwner": "Address?",
                     "quoteNFTType": "String?",
                     "tags": "[String]"
                  }
               }
            },
            "reactToFindThoughts": {
               "code": "import MetadataViews from 0x631e88ae7f1d7c20\nimport FindThoughts from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\n\ntransaction(users: [String], ids: [UInt64] , reactions: [String], undoReactionUsers: [String], undoReactionIds: [UInt64]) {\n\n    let collection : \u0026FindThoughts.Collection\n\n    prepare(account: AuthAccount) {\n        let thoughtsCap= account.getCapability\u003c\u0026{FindThoughts.CollectionPublic}\u003e(FindThoughts.CollectionPublicPath)\n        if !thoughtsCap.check() {\n            account.save(\u003c- FindThoughts.createEmptyCollection(), to: FindThoughts.CollectionStoragePath)\n            account.link\u003c\u0026FindThoughts.Collection{FindThoughts.CollectionPublic , MetadataViews.ResolverCollection}\u003e(\n                FindThoughts.CollectionPublicPath,\n                target: FindThoughts.CollectionStoragePath\n            )\n        }\n        self.collection=account.borrow\u003c\u0026FindThoughts.Collection\u003e(from: FindThoughts.CollectionStoragePath) ?? panic(\"Cannot borrow thoughts reference from path\")\n    }\n\n    execute {\n        for i, user in users {\n            let address = FIND.resolve(user) ?? panic(\"Cannot resolve user : \".concat(user))\n            self.collection.react(user: address, id: ids[i], reaction: reactions[i])\n        }\n\n        for i, user in undoReactionUsers {\n            let address = FIND.resolve(user) ?? panic(\"Cannot resolve user : \".concat(user))\n            self.collection.react(user: address, id: undoReactionIds[i], reaction: nil)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "users",
                     "ids",
                     "reactions",
                     "undoReactionUsers",
                     "undoReactionIds"
                  ],
                  "parameters": {
                     "ids": "[UInt64]",
                     "reactions": "[String]",
                     "undoReactionIds": "[UInt64]",
                     "undoReactionUsers": "[String]",
                     "users": "[String]"
                  }
               }
            },
            "redeemAllLostAndFoundNFTs": {
               "code": "import FindLostAndFoundWrapper from 0x35717efbbce11c74\nimport LostAndFound from 0xbe4635353f55bbd4\nimport FINDNFTCatalog from 0x35717efbbce11c74\nimport NFTCatalog from 0x324c34e1c517e4db\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FIND from 0x35717efbbce11c74\n\n//IMPORT\n\ntransaction() {\n\n    let ids : {String : [UInt64]}\n    let nftInfos : {String : NFTCatalog.NFTCollectionData}\n    let receiverAddress : Address\n\n    prepare(account: AuthAccount){\n\n        //LINK\n\n\n        self.nftInfos = {}\n        self.ids = FindLostAndFoundWrapper.getTicketIDs(user: account.address, specificType: Type\u003c@NonFungibleToken.NFT\u003e())\n\n        for type in self.ids.keys{ \n            if self.nftInfos[type] == nil {\n                let collections = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: type) ?? panic(\"NFT type is not supported at the moment. Type : \".concat(type))\n                self.nftInfos[type] = FINDNFTCatalog.getCatalogEntry(collectionIdentifier: collections.keys[0])!.collectionData\n            }\n        }\n\n        self.receiverAddress = account.address\n    }\n\n    execute{\n        for type in self.ids.keys{ \n            let path = self.nftInfos[type]!.publicPath\n            for id in self.ids[type]! {\n                FindLostAndFoundWrapper.redeemNFT(type: CompositeType(type)!, ticketID: id, receiverAddress: self.receiverAddress, collectionPublicPath: path)\n            }\n        }\n    }\n}",
               "spec": {
                  "order": [],
                  "parameters": {}
               }
            },
            "redeemAllLostAndFoundNFTsOnBehalf": {
               "code": "import FindLostAndFoundWrapper from 0x35717efbbce11c74\nimport LostAndFound from 0xbe4635353f55bbd4\nimport FINDNFTCatalog from 0x35717efbbce11c74\nimport NFTCatalog from 0x324c34e1c517e4db\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FIND from 0x35717efbbce11c74\n\n//IMPORT\n\ntransaction(receiverAddress: Address) {\n\n    let ids : {String : [UInt64]}\n    let nftInfos : {String : NFTCatalog.NFTCollectionData}\n    let receiverAddress : Address\n\n    prepare(account: AuthAccount){\n        self.receiverAddress = receiverAddress\n\n        self.nftInfos = {}\n        self.ids = FindLostAndFoundWrapper.getTicketIDs(user: receiverAddress, specificType: Type\u003c@NonFungibleToken.NFT\u003e())\n\n        for type in self.ids.keys{ \n            if self.nftInfos[type] == nil {\n                let collections = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: type) ?? panic(\"NFT type is not supported at the moment. Type : \".concat(type))\n                self.nftInfos[type] = FINDNFTCatalog.getCatalogEntry(collectionIdentifier: collections.keys[0])!.collectionData\n            }\n        }\n\n    }\n\n    execute{\n        for type in self.ids.keys{ \n            let path = self.nftInfos[type]!.publicPath\n            for id in self.ids[type]! {\n                FindLostAndFoundWrapper.redeemNFT(type: CompositeType(type)!, ticketID: id, receiverAddress: self.receiverAddress, collectionPublicPath: path)\n            }\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "receiverAddress"
                  ],
                  "parameters": {
                     "receiverAddress": "Address"
                  }
               }
            },
            "redeemLostAndFoundNFTs": {
               "code": "import FindLostAndFoundWrapper from 0x35717efbbce11c74\nimport LostAndFound from 0xbe4635353f55bbd4\nimport FINDNFTCatalog from 0x35717efbbce11c74\nimport NFTCatalog from 0x324c34e1c517e4db\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FindViews from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\n\n//IMPORT\n\ntransaction(ids: {String : [UInt64]}) {\n\n    let nftInfos : {String : NFTCatalog.NFTCollectionData}\n    let receiverAddress : Address\n\n    prepare(account: AuthAccount){\n\n        //LINK\n        self.nftInfos = {}\n\n        for type in ids.keys{ \n            if self.nftInfos[type] == nil {\n                let collections = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: type) ?? panic(\"NFT type is not supported at the moment. Type : \".concat(type))\n                self.nftInfos[type] = FINDNFTCatalog.getCatalogEntry(collectionIdentifier: collections.keys[0])!.collectionData\n            }\n        }\n\n        self.receiverAddress = account.address\n    }\n\n    execute{\n        for type in ids.keys{ \n            let path = self.nftInfos[type]!.publicPath\n            for id in ids[type]! {\n                FindLostAndFoundWrapper.redeemNFT(type: CompositeType(type)!, ticketID: id, receiverAddress:self.receiverAddress, collectionPublicPath: path)\n            }\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "ids"
                  ],
                  "parameters": {
                     "ids": "{String: [UInt64]}"
                  }
               }
            },
            "redeemLostAndFoundNFTsOnBehalf": {
               "code": "import FindLostAndFoundWrapper from 0x35717efbbce11c74\nimport LostAndFound from 0xbe4635353f55bbd4\nimport FINDNFTCatalog from 0x35717efbbce11c74\nimport NFTCatalog from 0x324c34e1c517e4db\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FindViews from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\nimport Bl0xPack from 0xe8124d8428980aa6\n\n//IMPORT\n\ntransaction(receiverAddress: Address, ids: {String : [UInt64]}) {\n\n    let nftInfos : {String : NFTCatalog.NFTCollectionData}\n    let receiverAddress : Address\n\n    prepare(account: AuthAccount){\n\n        self.receiverAddress = receiverAddress\n\n        self.nftInfos = {}\n\n        for type in ids.keys{ \n            if self.nftInfos[type] == nil {\n                let collections = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: type) ?? panic(\"NFT type is not supported at the moment. Type : \".concat(type))\n                self.nftInfos[type] = FINDNFTCatalog.getCatalogEntry(collectionIdentifier: collections.keys[0])!.collectionData\n            }\n        }\n\n    }\n\n    execute{\n        for type in ids.keys{ \n            let path = self.nftInfos[type]!.publicPath\n            for id in ids[type]! {\n                FindLostAndFoundWrapper.redeemNFT(type: CompositeType(type)!, ticketID: id, receiverAddress:self.receiverAddress, collectionPublicPath: path)\n            }\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "receiverAddress",
                     "ids"
                  ],
                  "parameters": {
                     "ids": "{String: [UInt64]}",
                     "receiverAddress": "Address"
                  }
               }
            },
            "register": {
               "code": "import FUSD from 0xe223d8a629e49c68\nimport FIND from 0x35717efbbce11c74\n\ntransaction(name: String, amount: UFix64) {\n\n    let vaultRef : \u0026FUSD.Vault?\n    let leases : \u0026FIND.LeaseCollection?\n    let price : UFix64\n\n    prepare(account: AuthAccount) {\n\n        self.price=FIND.calculateCost(name)\n        log(\"The cost for registering this name is \".concat(self.price.toString()))\n        self.vaultRef = account.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault)\n        self.leases=account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from: FIND.LeaseStoragePath)\n    }\n\n    pre{\n        self.vaultRef != nil : \"Could not borrow reference to the fusdVault!\"\n        self.leases != nil : \"Could not borrow reference to find lease collection\"\n        self.price == amount : \"Calculated cost : \".concat(self.price.toString()).concat(\" does not match expected cost : \").concat(amount.toString())\n    }\n\n    execute{\n        let payVault \u003c- self.vaultRef!.withdraw(amount: self.price) as! @FUSD.Vault\n        self.leases!.register(name: name, vault: \u003c- payVault)\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "name": "String"
                  }
               }
            },
            "registerDapper": {
               "code": "import DapperUtilityCoin from 0x82ec283f88a62e65\nimport FIND from 0x35717efbbce11c74\n\ntransaction(merchAccount: Address, name: String, amount: UFix64) {\n\n    let finLeases : \u0026FIND.LeaseCollection\n    let mainDapperUtilityCoinVault: \u0026DapperUtilityCoin.Vault\n    let balanceBeforeTransfer: UFix64\n    let price : UFix64\n\n    prepare(dapper: AuthAccount, account: AuthAccount) {\n\n        self.price=FIND.calculateCost(name)\n        log(\"The cost for registering this name is \".concat(self.price.toString()))\n        self.mainDapperUtilityCoinVault = dapper.borrow\u003c\u0026DapperUtilityCoin.Vault\u003e(from: /storage/dapperUtilityCoinVault) ?? panic(\"Cannot borrow DapperUtilityCoin vault from account storage\".concat(dapper.address.toString()))\n        self.balanceBeforeTransfer = self.mainDapperUtilityCoinVault.balance\n        self.finLeases= account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath) ?? panic(\"Could not borrow reference to find lease collection\")\n    }\n\n    pre{\n        self.price == amount : \"Calculated cost : \".concat(self.price.toString()).concat(\" does not match expected cost : \").concat(amount.toString())\n    }\n\n    execute{\n        let payVault \u003c- self.mainDapperUtilityCoinVault.withdraw(amount: self.price) as! @DapperUtilityCoin.Vault\n        self.finLeases.registerDapper(merchAccount: merchAccount, name: name, vault: \u003c- payVault)\n    }\n\n    post {\n        self.mainDapperUtilityCoinVault.balance == self.balanceBeforeTransfer: \"DapperUtilityCoin leakage\"\n    }\n}",
               "spec": {
                  "order": [
                     "merchAccount",
                     "name",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "merchAccount": "Address",
                     "name": "String"
                  }
               }
            },
            "registerGift": {
               "code": "import FUSD from 0xe223d8a629e49c68\nimport Profile from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\n\ntransaction(name: String, amount: UFix64, recipient: String) {\n\n    let price : UFix64 \n    let vaultRef : \u0026FUSD.Vault? \n    let receiverLease : Capability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e\n    let receiverProfile : Capability\u003c\u0026{Profile.Public}\u003e\n    let leases : \u0026FIND.LeaseCollection?\n\n    prepare(acct: AuthAccount) {\n\n        let resolveAddress = FIND.resolve(recipient)\n        if resolveAddress == nil {panic(\"The input pass in is not a valid name or address. Input : \".concat(recipient))}\n        let address = resolveAddress!\n\n        self.price=FIND.calculateCost(name)\n        log(\"The cost for registering this name is \".concat(self.price.toString()))\n\n        self.vaultRef = acct.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault)\n\n        self.leases=acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from: FIND.LeaseStoragePath)\n\n        let receiver = getAccount(address)\n        self.receiverLease = receiver.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        self.receiverProfile = receiver.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\n    }\n\n    pre{\n        self.price == amount : \"Calculated cost : \".concat(self.price.toString()).concat(\" does not match expected cost\").concat(amount.toString())\n        self.vaultRef != nil : \"Cannot borrow reference to fusd Vault!\"\n        self.receiverLease.check() : \"Lease capability is invalid\"\n        self.receiverProfile.check() : \"Profile capability is invalid\"\n        self.leases != nil : \"Cannot borrow refernce to find lease collection\"\n    }\n\n    execute{\n        let payVault \u003c- self.vaultRef!.withdraw(amount: self.price) as! @FUSD.Vault\n        self.leases!.register(name: name, vault: \u003c- payVault)\n        self.leases!.move(name: name, profile: self.receiverProfile, to: self.receiverLease)\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "amount",
                     "recipient"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "name": "String",
                     "recipient": "String"
                  }
               }
            },
            "rejectNameDirectOffer": {
               "code": "import FIND from 0x35717efbbce11c74\n\ntransaction(names: [String]) {\n\n    let finLeases : \u0026FIND.LeaseCollection? \n\n    prepare(account: AuthAccount) {\n        self.finLeases= account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)\n    }\n\n    pre{\n        self.finLeases != nil : \"Cannot borrow reference to find lease collection\"\n    }\n\n    execute{\n        for name in names {\n            self.finLeases!.cancel(name)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "names"
                  ],
                  "parameters": {
                     "names": "[String]"
                  }
               }
            },
            "relistMarketListings": {
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FindMarketDirectOfferEscrow from 0x35717efbbce11c74\nimport FindMarketAuctionEscrow from 0x35717efbbce11c74\nimport FindMarketAuctionSoft from 0x35717efbbce11c74\nimport FindMarketDirectOfferSoft from 0x35717efbbce11c74\nimport FindMarketSale from 0x35717efbbce11c74\n\ntransaction(marketplace:Address, ids: {String : [UInt64]}) {\n    prepare(account: AuthAccount) {\n\n        let tenant=FindMarket.getTenant(marketplace)\n\n        var saleType = Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        if let ids = ids[FindMarket.getMarketOptionFromType(saleType)] {\n            let saleItems= account.borrow\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection\u003e(from: tenant.getStoragePath(saleType))!\n            for id in ids {\n                saleItems.relist(id)\n            }\n        }\n\n        saleType = Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        if let ids = ids[FindMarket.getMarketOptionFromType(saleType)] {\n            let saleItems= account.borrow\u003c\u0026FindMarketAuctionSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(saleType))!\n            for id in ids {\n                saleItems.relist(id)\n            }\n        }\n\n        saleType = Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        if let ids = ids[FindMarket.getMarketOptionFromType(saleType)] {\n            let saleItems= account.borrow\u003c\u0026FindMarketSale.SaleItemCollection\u003e(from: tenant.getStoragePath(saleType))!\n            for id in ids {\n                saleItems.relist(id)\n            }\n        }\n\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "ids"
                  ],
                  "parameters": {
                     "ids": "{String: [UInt64]}",
                     "marketplace": "Address"
                  }
               }
            },
            "removeCurratedCollection": {
               "code": "transaction(name: String) {\n    prepare(account: AuthAccount) {\n\n        let path=/storage/FindCuratedCollections\n        let publicPath=/public/FindCuratedCollections\n\n        var collections : {String: [String]} = {}\n        if account.borrow\u003c\u0026{String: [String]}\u003e(from:path) != nil {\n             collections=account.load\u003c{String: [String]}\u003e(from:path)!\n        }\n        collections.remove(key: name)\n        account.save(collections, to: path)\n        let link = account.getCapability\u003c\u0026{String: [String]}\u003e(publicPath)\n        if !link.check() {\n            account.link\u003c\u0026{String: [String]}\u003e( publicPath, target: path)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "removeMarketOption": {
               "code": "import FindMarket from 0x35717efbbce11c74\n\ntransaction(saleItemName: String){\n    \n    prepare(account: AuthAccount){\n        let path = FindMarket.TenantClientStoragePath\n        let tenantRef = account.borrow\u003c\u0026FindMarket.TenantClient\u003e(from: path) ?? panic(\"Cannot borrow Reference.\")\n\n        tenantRef.removeMarketOption(name: saleItemName)\n    }\n}",
               "spec": {
                  "order": [
                     "saleItemName"
                  ],
                  "parameters": {
                     "saleItemName": "String"
                  }
               }
            },
            "removeRelatedAccount": {
               "code": "import FindRelatedAccounts from 0x35717efbbce11c74\n\ntransaction(name: String, network: String, address: String) {\n\n    var relatedAccounts : \u0026FindRelatedAccounts.Accounts?\n\n    prepare(account: AuthAccount) {\n\n        self.relatedAccounts= account.borrow\u003c\u0026FindRelatedAccounts.Accounts\u003e(from:FindRelatedAccounts.storagePath)\n        if self.relatedAccounts == nil {\n            let relatedAccounts \u003c- FindRelatedAccounts.createEmptyAccounts()\n            account.save(\u003c- relatedAccounts, to: FindRelatedAccounts.storagePath)\n            account.link\u003c\u0026FindRelatedAccounts.Accounts{FindRelatedAccounts.Public}\u003e(FindRelatedAccounts.publicPath, target: FindRelatedAccounts.storagePath)\n            self.relatedAccounts = account.borrow\u003c\u0026FindRelatedAccounts.Accounts\u003e(from:FindRelatedAccounts.storagePath)\n        }\n\n        let cap = account.getCapability\u003c\u0026FindRelatedAccounts.Accounts{FindRelatedAccounts.Public}\u003e(FindRelatedAccounts.publicPath)\n        if !cap.check() {\n            account.unlink(FindRelatedAccounts.publicPath)\n            account.link\u003c\u0026FindRelatedAccounts.Accounts{FindRelatedAccounts.Public}\u003e(FindRelatedAccounts.publicPath, target: FindRelatedAccounts.storagePath)\n        }\n    }\n\n    execute {\n        self.relatedAccounts!.removeRelatedAccount(name:name, network:network, address: address)\n    }\n\n}",
               "spec": {
                  "order": [
                     "name",
                     "network",
                     "address"
                  ],
                  "parameters": {
                     "address": "String",
                     "name": "String",
                     "network": "String"
                  }
               }
            },
            "removeRelatedAccountDapper": {
               "code": "import FindRelatedAccounts from 0x35717efbbce11c74\n\ntransaction(name: String, network: String, address: String){\n\n    var relatedAccounts : \u0026FindRelatedAccounts.Accounts?\n\n    prepare(account: AuthAccount) {\n\n        self.relatedAccounts= account.borrow\u003c\u0026FindRelatedAccounts.Accounts\u003e(from:FindRelatedAccounts.storagePath)\n        if self.relatedAccounts == nil {\n            let relatedAccounts \u003c- FindRelatedAccounts.createEmptyAccounts()\n            account.save(\u003c- relatedAccounts, to: FindRelatedAccounts.storagePath)\n            account.link\u003c\u0026FindRelatedAccounts.Accounts{FindRelatedAccounts.Public}\u003e(FindRelatedAccounts.publicPath, target: FindRelatedAccounts.storagePath)\n            self.relatedAccounts= account.borrow\u003c\u0026FindRelatedAccounts.Accounts\u003e(from:FindRelatedAccounts.storagePath)\n        }\n\n        let cap = account.getCapability\u003c\u0026FindRelatedAccounts.Accounts{FindRelatedAccounts.Public}\u003e(FindRelatedAccounts.publicPath)\n        if !cap.check() {\n            account.unlink(FindRelatedAccounts.publicPath)\n            account.link\u003c\u0026FindRelatedAccounts.Accounts{FindRelatedAccounts.Public}\u003e(FindRelatedAccounts.publicPath, target: FindRelatedAccounts.storagePath)\n        }\n\n    }\n\n    execute{\n        self.relatedAccounts!.removeRelatedAccount(name: name, network: network, address: address)\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "network",
                     "address"
                  ],
                  "parameters": {
                     "address": "String",
                     "name": "String",
                     "network": "String"
                  }
               }
            },
            "removeTenantRule": {
               "code": "import FindMarket from 0x35717efbbce11c74\n\ntransaction(optionName: String, tenantRuleName: String){\n    prepare(account: AuthAccount){\n        let path = FindMarket.TenantClientStoragePath\n        let tenantRef = account.borrow\u003c\u0026FindMarket.TenantClient\u003e(from: path) ?? panic(\"Cannot borrow Reference.\")\n\n        tenantRef.removeTenantRule(optionName: optionName, tenantRuleName: tenantRuleName)\n    }\n}",
               "spec": {
                  "order": [
                     "optionName",
                     "tenantRuleName"
                  ],
                  "parameters": {
                     "optionName": "String",
                     "tenantRuleName": "String"
                  }
               }
            },
            "remove_find_market_1": {
               "code": "import FindMarketAdmin from 0x35717efbbce11c74\n\n//signed by admin to link tenantClient to a new tenant\ntransaction(tenant: Address) {\n    //versus account\n    prepare(account: AuthAccount) {\n        let adminClient=account.borrow\u003c\u0026FindMarketAdmin.AdminProxy\u003e(from: FindMarketAdmin.AdminProxyStoragePath)!\n\n        adminClient.removeFindMarketTenant(tenant: tenant)\n    }\n}",
               "spec": {
                  "order": [
                     "tenant"
                  ],
                  "parameters": {
                     "tenant": "Address"
                  }
               }
            },
            "remove_find_market_2": {
               "code": "import FindMarket from 0x35717efbbce11c74\n\n\n//Transaction that is signed by find to create a find market tenant for find\ntransaction() {\n    prepare(account: AuthAccount) {\n        //in finds case the\n        destroy account.load\u003c@FindMarket.TenantClient\u003e(from:FindMarket.TenantClientStoragePath)\n        account.unlink(FindMarket.TenantClientPublicPath)\n    }\n}",
               "spec": {
                  "order": [],
                  "parameters": {}
               }
            },
            "renewName": {
               "code": "import FUSD from 0xe223d8a629e49c68\nimport FIND from 0x35717efbbce11c74\n\ntransaction(name: String, amount: UFix64) {\n\n    let price : UFix64\n    let vaultRef : \u0026FUSD.Vault? \n    let finLeases : \u0026FIND.LeaseCollection? \n\n    prepare(acct: AuthAccount) {\n        self.price=FIND.calculateCost(name)\n        self.vaultRef = acct.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault)\n        self.finLeases= acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)\n    }\n\n    pre{\n        self.price == amount : \"expected renew cost : \".concat(self.price.toString()).concat(\" is not the same as calculated renew cost : \").concat(amount.toString())\n        self.vaultRef != nil : \"Could not borrow reference to the fusdVault!\"\n        self.finLeases != nil : \"Could not borrow reference to find lease collection\"\n    }\n\n    execute{\n        let payVault \u003c- self.vaultRef!.withdraw(amount: self.price) as! @FUSD.Vault\n        let finToken= self.finLeases!.borrow(name)\n        finToken.extendLease(\u003c- payVault)\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "name": "String"
                  }
               }
            },
            "renewNameDapper": {
               "code": "import DapperUtilityCoin from 0x82ec283f88a62e65\nimport FIND from 0x35717efbbce11c74\n\ntransaction(merchAccount: Address, name: String, amount: UFix64) {\n\n    let price : UFix64\n    let finLeases : \u0026FIND.LeaseCollection\n    let mainDapperUtilityCoinVault: \u0026DapperUtilityCoin.Vault\n    let balanceBeforeTransfer: UFix64\n\n    prepare(dapper: AuthAccount, acct: AuthAccount) {\n        self.price=FIND.calculateCost(name)\n        self.mainDapperUtilityCoinVault = dapper.borrow\u003c\u0026DapperUtilityCoin.Vault\u003e(from: /storage/dapperUtilityCoinVault) ?? panic(\"Cannot borrow DapperUtilityCoin vault from account storage\".concat(dapper.address.toString()))\n        self.balanceBeforeTransfer = self.mainDapperUtilityCoinVault.balance\n        self.finLeases= acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath) ?? panic(\"Could not borrow reference to find lease collection\")\n    }\n\n    pre{\n        self.price == amount : \"expected renew cost : \".concat(self.price.toString()).concat(\" is not the same as calculated renew cost : \").concat(amount.toString())\n    }\n\n    execute{\n        let payVault \u003c- self.mainDapperUtilityCoinVault.withdraw(amount: self.price) as! @DapperUtilityCoin.Vault\n        let finToken= self.finLeases.borrow(name)\n        finToken.extendLeaseDapper(merchAccount: merchAccount, vault: \u003c- payVault)\n    }\n\n    post {\n        self.mainDapperUtilityCoinVault.balance == self.balanceBeforeTransfer: \"DapperUtilityCoin leakage\"\n    }\n}",
               "spec": {
                  "order": [
                     "merchAccount",
                     "name",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "merchAccount": "Address",
                     "name": "String"
                  }
               }
            },
            "retractOfferLeaseMarketDirectOfferSoft": {
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FindLeaseMarketDirectOfferSoft from 0x35717efbbce11c74\n\ntransaction(leaseName: String) {\n    let bidsReference: \u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection?\n\n    prepare(account: AuthAccount) {\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e())\n        self.bidsReference= account.borrow\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(from: storagePath)\n    }\n\n    pre{\n        self.bidsReference != nil : \"Bid resource does not exist\"\n    }\n\n    execute {\n        self.bidsReference!.cancelBid(leaseName)\n    }\n}",
               "spec": {
                  "order": [
                     "leaseName"
                  ],
                  "parameters": {
                     "leaseName": "String"
                  }
               }
            },
            "retractOfferMarketDirectOfferEscrowed": {
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FindMarketDirectOfferEscrow from 0x35717efbbce11c74\n\ntransaction(marketplace:Address, id: UInt64) {\n    let bidsReference: \u0026FindMarketDirectOfferEscrow.MarketBidCollection? \n\n    prepare(account: AuthAccount) {\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e())\n        self.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection\u003e(from: storagePath) \n    }\n\n    pre{\n        self.bidsReference != nil : \"This account does not have a bid collection\"\n    }\n\n    execute {\n        self.bidsReference!.cancelBid(id)\n    }\n\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "retractOfferMarketDirectOfferSoft": {
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FindMarketDirectOfferSoft from 0x35717efbbce11c74\n\ntransaction(marketplace:Address, id: UInt64) {\n    let bidsReference: \u0026FindMarketDirectOfferSoft.MarketBidCollection?\n\n    prepare(account: AuthAccount) {\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n        self.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection\u003e(from: storagePath) \n    }\n\n    pre{\n        self.bidsReference != nil : \"Bid resource does not exist\"\n    }\n\n    execute {\n        self.bidsReference!.cancelBid(id)\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "sendCharity": {
               "code": "import NonFungibleToken from 0x631e88ae7f1d7c20\nimport CharityNFT from 0x35717efbbce11c74\n\n//mint an art and add it to a users collection\ntransaction(\n    id: UInt64,\n    recipient: Address\n) {\n    let receiverCap: Capability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e\n    let charityCollection: \u0026NonFungibleToken.Collection\n\n    prepare(account: AuthAccount) {\n        self.charityCollection =account.borrow\u003c\u0026NonFungibleToken.Collection\u003e(from: CharityNFT.CollectionStoragePath)!\n        self.receiverCap= getAccount(recipient).getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath)\n    }\n\n    pre{\n        self.receiverCap.check() : \"Receiver doesn't have receiving vault set up properly.\"\n    }\n\n    execute {\n        let nft \u003c- self.charityCollection.withdraw(withdrawID: id)\n        self.receiverCap.borrow()!.deposit(token: \u003c- nft)\n    }\n}",
               "spec": {
                  "order": [
                     "id",
                     "recipient"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "recipient": "Address"
                  }
               }
            },
            "sendDandy": {
               "code": "import FIND from 0x35717efbbce11c74\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport Dandy from 0x35717efbbce11c74\n\ntransaction(user: String, id: UInt64) {\n\n    let address : Address\n    let cap : Capability\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic}\u003e\n    let senderRef : \u0026Dandy.Collection\n\n    prepare(account: AuthAccount) {\n        self.address = FIND.resolve(user) ?? panic(\"Cannot find user with this name / address\")\n        self.cap = getAccount(self.address).getCapability\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n\n        self.senderRef = account.borrow\u003c\u0026Dandy.Collection\u003e(from: Dandy.CollectionStoragePath) ?? panic(\"Cannot borrow reference to sender Collection.\")\n    }\n\n    pre{\n        self.cap.check() : \"Cannot borrow reference to receiver Collection. Receiver account : \".concat(self.address.toString())\n        self.senderRef != nil : \"Cannot borrow reference to sender Collection.\"\n    }\n\n    execute{\n        self.cap.borrow()!.deposit(token: \u003c- self.senderRef!.withdraw(withdrawID: id))\n    }\n}",
               "spec": {
                  "order": [
                     "user",
                     "id"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "user": "String"
                  }
               }
            },
            "sendFT": {
               "code": "import FungibleToken from 0x9a0766d93b6608b7\nimport Sender from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\nimport FTRegistry from 0x35717efbbce11c74\n\n\ntransaction(name: String, amount: UFix64, ftAliasOrIdentifier: String, tag: String, message:String) {\n\n    var token : \u0026Sender.Token\n    let walletReference : \u0026FungibleToken.Vault? \n\n    prepare(account: AuthAccount) {\n\n        let ft = FTRegistry.getFTInfo(ftAliasOrIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftAliasOrIdentifier))\n        self.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath)\n\n        if account.borrow\u003c\u0026Sender.Token\u003e(from: Sender.storagePath) == nil {\n            account.save(\u003c- Sender.create(), to: Sender.storagePath)\n        }\n\n        self.token =account.borrow\u003c\u0026Sender.Token\u003e(from: Sender.storagePath)!\n    }\n\n    pre{\n        self.walletReference != nil : \"No suitable wallet linked for this account\"\n    }\n\n    execute{\n        let vault \u003c- self.walletReference!.withdraw(amount: amount)\n        FIND.depositWithTagAndMessage(to: name, message: message, tag: tag, vault: \u003c- vault, from: self.token)\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "amount",
                     "ftAliasOrIdentifier",
                     "tag",
                     "message"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "ftAliasOrIdentifier": "String",
                     "message": "String",
                     "name": "String",
                     "tag": "String"
                  }
               }
            },
            "sendFTWithTag": {
               "code": "import NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FlowToken from 0x7e60df042a9c0868\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FUSD from 0xe223d8a629e49c68\nimport Profile from 0x35717efbbce11c74\nimport Sender from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\nimport CharityNFT from 0x35717efbbce11c74\n\n\ntransaction(name: String, amount: UFix64, type: String, tag:String) {\n\n    prepare(account: AuthAccount) {\n\n        let stdCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath)\n        if !stdCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- CharityNFT.createEmptyCollection(), to: CharityNFT.CollectionStoragePath)\n            account.link\u003c\u0026{NonFungibleToken.CollectionPublic, MetadataViews.ResolverCollection}\u003e(CharityNFT.CollectionPublicPath, target: CharityNFT.CollectionStoragePath)\n        }\n\n        let charityCap = account.getCapability\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection)\n        if !charityCap.check() {\n            account.link\u003c\u0026{CharityNFT.CollectionPublic, MetadataViews.ResolverCollection}\u003e(/public/findCharityNFTCollection, target: CharityNFT.CollectionStoragePath)\n        }\n\n      let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n        if !fusdReceiver.check() {\n            let fusd \u003c- FUSD.createEmptyVault()\n            account.save(\u003c- fusd, to: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profileName = account.address.toString()\n\n            let profile \u003c-Profile.createUser(name:profileName, createdAt: \"find\")\n\n            let fusdWallet=Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), names: [\"fusd\", \"stablecoin\"])\n\n            profile.addWallet(fusdWallet)\n\n            let flowWallet=Profile.Wallet(\n                name:\"Flow\", \n                receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver),\n                balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance),\n                accept: Type\u003c@FlowToken.Vault\u003e(),\n                names: [\"flow\"]\n            )\n    \n            profile.addWallet(flowWallet)\n            profile.addCollection(Profile.ResourceCollection(\"FINDLeases\",leaseCollection, Type\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(), [\"find\", \"leases\"]))\n            profile.addCollection(Profile.ResourceCollection(\"FINDBids\", bidCollection, Type\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(), [\"find\", \"bids\"]))\n\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n        }\n\n        if account.borrow\u003c\u0026Sender.Token\u003e(from: Sender.storagePath) == nil {\n            account.save(\u003c- Sender.create(), to: Sender.storagePath)\n        }\n\n        let token =account.borrow\u003c\u0026Sender.Token\u003e(from: Sender.storagePath)!\n\n\n        if type == \"fusd\" {\n            let vaultRef = account.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault) ?? panic(\"Could not borrow reference to the fusdVault!\")\n            let vault \u003c- vaultRef.withdraw(amount: amount)\n            FIND.depositWithTagAndMessage(to: name, message: \"\", tag: tag, vault: \u003c- vault, from: token)\n            return \n        }\n\n        let vaultRef = account.borrow\u003c\u0026FlowToken.Vault\u003e(from: /storage/flowTokenVault) ?? panic(\"Could not borrow reference to the fusdVault!\")\n        let vault \u003c- vaultRef.withdraw(amount: amount)\n        FIND.depositWithTagAndMessage(to: name, message: \"\", tag: tag, vault: \u003c- vault, from: token)\n    }\n\n}",
               "spec": {
                  "order": [
                     "name",
                     "amount",
                     "type",
                     "tag"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "name": "String",
                     "tag": "String",
                     "type": "String"
                  }
               }
            },
            "sendFindPacks": {
               "code": "import FindPack from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport FindAirdropper from 0x35717efbbce11c74\nimport Admin from 0x35717efbbce11c74\n\ntransaction(packInfo: FindPack.AirdropInfo) {\n\n    prepare(account: AuthAccount) {\n\n        let pathIdentifier = \"FindPack_\".concat(packInfo.packTypeName).concat(\"_\").concat(packInfo.packTypeId.toString())\n\n        let pathCollection = FindPack.getPacksCollection(packTypeName: packInfo.packTypeName, packTypeId: packInfo.packTypeId)\n        let adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n\n        let ids = pathCollection.getIDs()\n        for i, user in packInfo.users {\n            let id = ids[i]\n\n            let address = FIND.resolve(user)\n            if address == nil {\n                panic(\"User cannot be resolved : \".concat(user))\n            }\n\n            let uAccount = getAccount(address!)\n            let userPacks=uAccount.getCapability\u003c\u0026FindPack.Collection{NonFungibleToken.Receiver}\u003e(FindPack.CollectionPublicPath).borrow() ?? panic(\"Could not find userPacks for \".concat(user))\n            let pointer = adminRef.getAuthPointer(pathIdentifier: pathIdentifier, id: id)\n            let ctx : {String : String } = {\"message\" : packInfo.message, \"tenant\" : \"find\"}\n            FindAirdropper.safeAirdrop(pointer: pointer, receiver: address!, path: FindPack.CollectionPublicPath, context: ctx , deepValidation: true)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "packInfo"
                  ],
                  "parameters": {
                     "packInfo": "FindPack.AirdropInfo"
                  }
               }
            },
            "sendNFTs": {
               "code": "import NonFungibleToken from 0x631e88ae7f1d7c20\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FlowStorageFees from 0x8c5303eaa26202d6\nimport FlowToken from 0x7e60df042a9c0868\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport NFTCatalog from 0x324c34e1c517e4db\nimport FINDNFTCatalog from 0x35717efbbce11c74\nimport FindViews from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\nimport FindAirdropper from 0x35717efbbce11c74\nimport FTRegistry from 0x35717efbbce11c74\nimport Profile from 0x35717efbbce11c74\nimport Sender from 0x35717efbbce11c74\n\ntransaction(nftIdentifiers: [String], allReceivers: [String] , ids:[UInt64], memos: [String], donationTypes: [String?], donationAmounts: [UFix64?], findDonationType: String?, findDonationAmount: UFix64?) {\n\n    let authPointers : [FindViews.AuthNFTPointer]\n    let paths : [PublicPath]\n    let flowVault : \u0026FungibleToken.Vault\n    let flowTokenRepayment : Capability\u003c\u0026FlowToken.Vault{FungibleToken.Receiver}\u003e\n    let defaultTokenAvailableBalance : UFix64\n\n    let royalties: [MetadataViews.Royalties?]\n    let totalRoyalties: [UFix64]\n    let vaultRefs: {String : \u0026FungibleToken.Vault}\n    var token : \u0026Sender.Token\n\n    prepare(account : AuthAccount) {\n\n        self.authPointers = []\n        self.paths = []\n        self.royalties = []\n        self.totalRoyalties = []\n        self.vaultRefs = {}\n\n\n        let contractData : {Type : NFTCatalog.NFTCatalogMetadata} = {}\n\n\n        for i , typeIdentifier in nftIdentifiers {\n            let type = CompositeType(typeIdentifier) ?? panic(\"Cannot refer to type with identifier : \".concat(typeIdentifier))\n\n            var data : NFTCatalog.NFTCatalogMetadata? = contractData[type]\n            if data == nil {\n                data = FINDNFTCatalog.getMetadataFromType(type) ?? panic(\"NFT Type is not supported by NFT Catalog. Type : \".concat(type.identifier))\n                contractData[type] = data\n            }\n\n            let path = data!.collectionData\n\n            var providerCap=account.getCapability\u003c\u0026{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e(path.privatePath)\n            if !providerCap.check() {\n                let newCap = account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                    path.privatePath,\n                    target: path.storagePath\n                )\n                if newCap == nil {\n                    // If linking is not successful, we link it using finds custom link\n                    let pathIdentifier = path.privatePath.toString()\n                    let findPath = PrivatePath(identifier: pathIdentifier.slice(from: \"/private/\".length , upTo: pathIdentifier.length).concat(\"_FIND\"))!\n                    account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                        findPath,\n                        target: path.storagePath\n                    )\n                    providerCap = account.getCapability\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(findPath)\n                }\n            }\n            let pointer = FindViews.AuthNFTPointer(cap: providerCap, id: ids[i])\n\n            if let dt = donationTypes[i] {\n                self.royalties.append(pointer.getRoyalty())\n                self.totalRoyalties.append(pointer.getTotalRoyaltiesCut())\n\n                // get the vault for donation\n                if self.vaultRefs[dt] == nil {\n                    let info = FTRegistry.getFTInfo(dt) ?? panic(\"This token type is not supported at the moment : \".concat(dt))\n                    let ftPath = info.vaultPath\n                    let ref = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ftPath) ?? panic(\"Cannot borrow vault reference for type : \".concat(dt))\n                    self.vaultRefs[dt] = ref\n                }\n\n            } else {\n                self.royalties.append(nil)\n                self.totalRoyalties.append(0.0)\n            }\n\n            self.authPointers.append(pointer)\n            self.paths.append(path.publicPath)\n        }\n\n        self.flowVault = account.borrow\u003c\u0026FlowToken.Vault\u003e(from: /storage/flowTokenVault) ?? panic(\"Cannot borrow reference to sender's flow vault\")\n        self.flowTokenRepayment = account.getCapability\u003c\u0026FlowToken.Vault{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver)\n        self.defaultTokenAvailableBalance = FlowStorageFees.defaultTokenAvailableBalance(account.address)\n\n        // get the vault for find donation\n        if let dt = findDonationType {\n            if self.vaultRefs[dt] == nil {\n                let info = FTRegistry.getFTInfo(dt) ?? panic(\"This token type is not supported at the moment : \".concat(dt))\n                let ftPath = info.vaultPath\n                let ref = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ftPath) ?? panic(\"Cannot borrow vault reference for type : \".concat(dt))\n                self.vaultRefs[dt] = ref\n            }\n        }\n\n        if account.borrow\u003c\u0026Sender.Token\u003e(from: Sender.storagePath) == nil {\n            account.save(\u003c- Sender.create(), to: Sender.storagePath)\n        }\n\n        self.token =account.borrow\u003c\u0026Sender.Token\u003e(from: Sender.storagePath)!\n\n    }\n\n    execute {\n        let addresses : {String : Address} = {}\n        let estimatedStorageFee = 0.0002 * UFix64(self.authPointers.length)\n        // we pass in the least amount as possible for storage fee here\n        let tempVault \u003c- self.flowVault.withdraw(amount: 0.0)\n        var vaultRef = \u0026tempVault as \u0026FungibleToken.Vault\n        if self.defaultTokenAvailableBalance \u003c= estimatedStorageFee {\n            vaultRef = self.flowVault as \u0026FungibleToken.Vault\n        } else {\n            tempVault.deposit(from: \u003c- self.flowVault.withdraw(amount: estimatedStorageFee))\n        }\n\n        let ctx : {String : String} = {\n            \"tenant\" : \"find\"\n        }\n\n        for i,  pointer in self.authPointers {\n            let receiver = allReceivers[i]\n            let id = ids[i]\n            ctx[\"message\"] = memos[i]\n            let path = self.paths[i]\n\n            var user = addresses[receiver]\n            if user == nil {\n                user = FIND.resolve(receiver) ?? panic(\"Cannot resolve user with name / address : \".concat(receiver))\n                addresses[receiver] = user\n            }\n\n            // airdrop thru airdropper\n            FindAirdropper.forcedAirdrop(pointer: pointer, receiver: user!, path: path, context: ctx, storagePayment: vaultRef, flowTokenRepayment: self.flowTokenRepayment, deepValidation: true)\n        }\n        self.flowVault.deposit(from: \u003c- tempVault)\n\n        // This is hard coded for spliting at the front end for now. So if there are no royalties, all goes to find\n        // AND This does not support different ft types for now.\n        var goesToFindFund = 0.0\n        for i , type in donationTypes {\n            if type == nil {\n                continue\n            }\n            let amount = donationAmounts[i]!\n            let royalties = self.royalties[i]!\n            let totalRoyalties = self.totalRoyalties[i]\n            let vaultRef = self.vaultRefs[type!]!\n            var noRoyalty = false\n            if totalRoyalties == 0.0 {\n                goesToFindFund = goesToFindFund + amount\n                continue\n            }\n\n            let balance = vaultRef.balance\n            var totalPaid = 0.0\n\n            for j, r in royalties.getRoyalties() {\n                var cap : Capability\u003c\u0026{FungibleToken.Receiver}\u003e = r.receiver\n                if !r.receiver.check(){\n                    // try to grab from profile\n                    if let ref = getAccount(r.receiver.address).getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath).borrow() {\n                        if ref.hasWallet(vaultRef.getType().identifier) {\n                            cap = getAccount(r.receiver.address).getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n                        } else if let ftInfo = FTRegistry.getFTInfo(vaultRef.getType().identifier) {\n                            cap = getAccount(r.receiver.address).getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(ftInfo.receiverPath)\n                        }\n                    }\n\n                }\n\n                if cap.check() {\n                    let individualAmount = r.cut / totalRoyalties * amount\n                    let vault \u003c- vaultRef.withdraw(amount: individualAmount)\n                    cap.borrow()!.deposit(from: \u003c- vault)\n\n                    totalPaid = totalPaid + individualAmount\n                }\n            }\n\n            assert(totalPaid \u003c= amount, message: \"Amount paid is greater than expected\" )\n\n        }\n\n        // for donating to find\n        if findDonationType != nil {\n            vaultRef = self.vaultRefs[findDonationType!]!\n            let vault \u003c- vaultRef.withdraw(amount: findDonationAmount! + goesToFindFund)\n            FIND.depositWithTagAndMessage(to: \"find\", message: \"donation to .find\", tag: \"donation\", vault: \u003c- vault, from: self.token)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "nftIdentifiers",
                     "allReceivers",
                     "ids",
                     "memos",
                     "donationTypes",
                     "donationAmounts",
                     "findDonationType",
                     "findDonationAmount"
                  ],
                  "parameters": {
                     "allReceivers": "[String]",
                     "donationAmounts": "[UFix64?]",
                     "donationTypes": "[String?]",
                     "findDonationAmount": "UFix64?",
                     "findDonationType": "String?",
                     "ids": "[UInt64]",
                     "memos": "[String]",
                     "nftIdentifiers": "[String]"
                  }
               }
            },
            "sendNFTsSafe": {
               "code": "import NonFungibleToken from 0x631e88ae7f1d7c20\nimport FungibleToken from 0x9a0766d93b6608b7\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport NFTCatalog from 0x324c34e1c517e4db\nimport FINDNFTCatalog from 0x35717efbbce11c74\nimport FindViews from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\nimport FindAirdropper from 0x35717efbbce11c74\nimport FTRegistry from 0x35717efbbce11c74\nimport Profile from 0x35717efbbce11c74\nimport Sender from 0x35717efbbce11c74\n\ntransaction(nftIdentifiers: [String], allReceivers: [String] , ids:[UInt64], memos: [String], donationTypes: [String?], donationAmounts: [UFix64?], findDonationType: String?, findDonationAmount: UFix64?) {\n\n    let authPointers : [FindViews.AuthNFTPointer]\n    let paths : [PublicPath]\n    let royalties: [MetadataViews.Royalties?]\n    let totalRoyalties: [UFix64]\n    let vaultRefs: {String : \u0026FungibleToken.Vault}\n    var token : \u0026Sender.Token\n\n    prepare(account : AuthAccount) {\n\n        self.authPointers = []\n        self.paths = []\n        self.royalties = []\n        self.totalRoyalties = []\n        self.vaultRefs = {}\n\n        let contractData : {Type : NFTCatalog.NFTCatalogMetadata} = {}\n\n\n        for i , typeIdentifier in nftIdentifiers {\n            let type = CompositeType(typeIdentifier) ?? panic(\"Cannot refer to type with identifier : \".concat(typeIdentifier))\n\n            var data : NFTCatalog.NFTCatalogMetadata? = contractData[type]\n            if data == nil {\n                data = FINDNFTCatalog.getMetadataFromType(type) ?? panic(\"NFT Type is not supported by NFT Catalog. Type : \".concat(type.identifier))\n                contractData[type] = data\n            }\n\n            let path = data!.collectionData\n\n            var providerCap=account.getCapability\u003c\u0026{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e(path.privatePath)\n            if !providerCap.check() {\n                let newCap = account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                    path.privatePath,\n                    target: path.storagePath\n                )\n                if newCap == nil {\n                    // If linking is not successful, we link it using finds custom link\n                    let pathIdentifier = path.privatePath.toString()\n                    let findPath = PrivatePath(identifier: pathIdentifier.slice(from: \"/private/\".length , upTo: pathIdentifier.length).concat(\"_FIND\"))!\n                    account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                        findPath,\n                        target: path.storagePath\n                    )\n                    providerCap = account.getCapability\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(findPath)\n                }\n            }\n            let pointer = FindViews.AuthNFTPointer(cap: providerCap, id: ids[i])\n\n            if let dt = donationTypes[i] {\n                self.royalties.append(pointer.getRoyalty())\n                self.totalRoyalties.append(pointer.getTotalRoyaltiesCut())\n\n                // get the vault for donation\n                if self.vaultRefs[dt] == nil {\n                    let info = FTRegistry.getFTInfo(dt) ?? panic(\"This token type is not supported at the moment : \".concat(dt))\n                    let ftPath = info.vaultPath\n                    let ref = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ftPath) ?? panic(\"Cannot borrow vault reference for type : \".concat(dt))\n                    self.vaultRefs[dt] = ref\n                }\n\n            } else {\n                self.royalties.append(nil)\n                self.totalRoyalties.append(0.0)\n            }\n\n\n            self.authPointers.append(pointer)\n            self.paths.append(path.publicPath)\n        }\n\n        // get the vault for find donation\n        if let dt = findDonationType {\n            if self.vaultRefs[dt] == nil {\n                let info = FTRegistry.getFTInfo(dt) ?? panic(\"This token type is not supported at the moment : \".concat(dt))\n                let ftPath = info.vaultPath\n                let ref = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ftPath) ?? panic(\"Cannot borrow vault reference for type : \".concat(dt))\n                self.vaultRefs[dt] = ref\n            }\n        }\n\n        if account.borrow\u003c\u0026Sender.Token\u003e(from: Sender.storagePath) == nil {\n            account.save(\u003c- Sender.create(), to: Sender.storagePath)\n        }\n\n        self.token =account.borrow\u003c\u0026Sender.Token\u003e(from: Sender.storagePath)!\n\n    }\n\n    execute {\n        let addresses : {String : Address} = {}\n\n        let ctx : {String : String} = {\n            \"tenant\" : \"find\"\n        }\n\n        for i,  pointer in self.authPointers {\n            let receiver = allReceivers[i]\n            let id = ids[i]\n            ctx[\"message\"] = memos[i]\n            let path = self.paths[i]\n\n            var user = addresses[receiver]\n            if user == nil {\n                user = FIND.resolve(receiver) ?? panic(\"Cannot resolve user with name / address : \".concat(receiver))\n                addresses[receiver] = user\n            }\n\n            // airdrop thru airdropper\n            FindAirdropper.safeAirdrop(pointer: pointer, receiver: user!, path: path, context: ctx, deepValidation: true)\n        }\n\n\n        // This is hard coded for spliting at the front end for now. So if there are no royalties, all goes to find\n        // AND This does not support different ft types for now.\n        var goesToFindFund = 0.0\n        for i , type in donationTypes {\n            if type == nil {\n                continue\n            }\n            let amount = donationAmounts[i]!\n            let royalties = self.royalties[i]!\n            let totalRoyalties = self.totalRoyalties[i]\n            let vaultRef = self.vaultRefs[type!]!\n            if totalRoyalties == 0.0 {\n                goesToFindFund = goesToFindFund + amount\n                continue\n            }\n\n            let balance = vaultRef.balance\n            var totalPaid = 0.0\n\n            for j, r in royalties.getRoyalties() {\n                var cap : Capability\u003c\u0026{FungibleToken.Receiver}\u003e = r.receiver\n                if !r.receiver.check(){\n                    // try to grab from profile\n                    if let ref = getAccount(r.receiver.address).getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath).borrow() {\n                        if ref.hasWallet(vaultRef.getType().identifier) {\n                            cap = getAccount(r.receiver.address).getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n                        } else if let ftInfo = FTRegistry.getFTInfo(vaultRef.getType().identifier) {\n                            cap = getAccount(r.receiver.address).getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(ftInfo.receiverPath)\n                        }\n                    }\n\n                }\n\n                if cap.check() {\n                    let individualAmount = r.cut / totalRoyalties * amount\n                    let vault \u003c- vaultRef.withdraw(amount: individualAmount)\n                    cap.borrow()!.deposit(from: \u003c- vault)\n\n                    totalPaid = totalPaid + individualAmount\n                }\n            }\n\n            assert(totalPaid \u003c= amount, message: \"Amount paid is greater than expected\" )\n\n        }\n\n\n        // for donating to find\n        if findDonationType != nil {\n            let vaultRef = self.vaultRefs[findDonationType!]!\n            let vault \u003c- vaultRef.withdraw(amount: findDonationAmount! + goesToFindFund)\n            FIND.depositWithTagAndMessage(to: \"find\", message: \"donation to .find\", tag: \"donation\", vault: \u003c- vault, from: self.token)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "nftIdentifiers",
                     "allReceivers",
                     "ids",
                     "memos",
                     "donationTypes",
                     "donationAmounts",
                     "findDonationType",
                     "findDonationAmount"
                  ],
                  "parameters": {
                     "allReceivers": "[String]",
                     "donationAmounts": "[UFix64?]",
                     "donationTypes": "[String?]",
                     "findDonationAmount": "UFix64?",
                     "findDonationType": "String?",
                     "ids": "[UInt64]",
                     "memos": "[String]",
                     "nftIdentifiers": "[String]"
                  }
               }
            },
            "sendNFTsSubsidize": {
               "code": "import NonFungibleToken from 0x631e88ae7f1d7c20\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FlowStorageFees from 0x8c5303eaa26202d6\nimport FlowToken from 0x7e60df042a9c0868\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport NFTCatalog from 0x324c34e1c517e4db\nimport FINDNFTCatalog from 0x35717efbbce11c74\nimport FindViews from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\nimport FindAirdropper from 0x35717efbbce11c74\nimport FTRegistry from 0x35717efbbce11c74\nimport Profile from 0x35717efbbce11c74\nimport Sender from 0x35717efbbce11c74\n\ntransaction(nftIdentifiers: [String], allReceivers: [String] , ids:[UInt64], memos: [String], donationTypes: [String?], donationAmounts: [UFix64?], findDonationType: String?, findDonationAmount: UFix64?) {\n\n    let authPointers : [FindViews.AuthNFTPointer]\n    let paths : [PublicPath]\n    let flowVault : \u0026FungibleToken.Vault\n    let flowTokenRepayment : Capability\u003c\u0026FlowToken.Vault{FungibleToken.Receiver}\u003e\n    let defaultTokenAvailableBalance : UFix64\n\n    let royalties: [MetadataViews.Royalties?]\n    let totalRoyalties: [UFix64]\n    let vaultRefs: {String : \u0026FungibleToken.Vault}\n    var token : \u0026Sender.Token\n\n    prepare(account : AuthAccount) {\n\n        self.authPointers = []\n        self.paths = []\n        self.royalties = []\n        self.totalRoyalties = []\n        self.vaultRefs = {}\n\n        let contractData : {Type : NFTCatalog.NFTCatalogMetadata} = {}\n\n\n        for i , typeIdentifier in nftIdentifiers {\n            let type = CompositeType(typeIdentifier) ?? panic(\"Cannot refer to type with identifier : \".concat(typeIdentifier))\n\n            var data : NFTCatalog.NFTCatalogMetadata? = contractData[type]\n            if data == nil {\n                data = FINDNFTCatalog.getMetadataFromType(type) ?? panic(\"NFT Type is not supported by NFT Catalog. Type : \".concat(type.identifier))\n                contractData[type] = data\n            }\n\n            let path = data!.collectionData\n\n            var providerCap=account.getCapability\u003c\u0026{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e(path.privatePath)\n            if !providerCap.check() {\n                let newCap = account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                    path.privatePath,\n                    target: path.storagePath\n                )\n                if newCap == nil {\n                    // If linking is not successful, we link it using finds custom link\n                    let pathIdentifier = path.privatePath.toString()\n                    let findPath = PrivatePath(identifier: pathIdentifier.slice(from: \"/private/\".length , upTo: pathIdentifier.length).concat(\"_FIND\"))!\n                    account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                        findPath,\n                        target: path.storagePath\n                    )\n                    providerCap = account.getCapability\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(findPath)\n                }\n            }\n            let pointer = FindViews.AuthNFTPointer(cap: providerCap, id: ids[i])\n\n            if let dt = donationTypes[i] {\n                self.royalties.append(pointer.getRoyalty())\n                self.totalRoyalties.append(pointer.getTotalRoyaltiesCut())\n\n                // get the vault for donation\n                if self.vaultRefs[dt] == nil {\n                    let info = FTRegistry.getFTInfo(dt) ?? panic(\"This token type is not supported at the moment : \".concat(dt))\n                    let ftPath = info.vaultPath\n                    let ref = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ftPath) ?? panic(\"Cannot borrow vault reference for type : \".concat(dt))\n                    self.vaultRefs[dt] = ref\n                }\n\n            } else {\n                self.royalties.append(nil)\n                self.totalRoyalties.append(0.0)\n            }\n\n\n            self.authPointers.append(pointer)\n            self.paths.append(path.publicPath)\n        }\n\n        self.flowVault = account.borrow\u003c\u0026FlowToken.Vault\u003e(from: /storage/flowTokenVault) ?? panic(\"Cannot borrow reference to sender's flow vault\")\n        self.flowTokenRepayment = account.getCapability\u003c\u0026FlowToken.Vault{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver)\n        self.defaultTokenAvailableBalance = FlowStorageFees.defaultTokenAvailableBalance(account.address)\n\n        // get the vault for find donation\n        if let dt = findDonationType {\n            if self.vaultRefs[dt] == nil {\n                let info = FTRegistry.getFTInfo(dt) ?? panic(\"This token type is not supported at the moment : \".concat(dt))\n                let ftPath = info.vaultPath\n                let ref = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ftPath) ?? panic(\"Cannot borrow vault reference for type : \".concat(dt))\n                self.vaultRefs[dt] = ref\n            }\n        }\n\n        if account.borrow\u003c\u0026Sender.Token\u003e(from: Sender.storagePath) == nil {\n            account.save(\u003c- Sender.create(), to: Sender.storagePath)\n        }\n\n        self.token =account.borrow\u003c\u0026Sender.Token\u003e(from: Sender.storagePath)!\n\n\n    }\n\n    execute {\n        let addresses : {String : Address} = {}\n        let estimatedStorageFee = 0.0002 * UFix64(self.authPointers.length)\n        // we pass in the least amount as possible for storage fee here\n        let tempVault \u003c- self.flowVault.withdraw(amount: 0.0)\n        var vaultRef = \u0026tempVault as \u0026FungibleToken.Vault\n        if self.defaultTokenAvailableBalance \u003c= estimatedStorageFee {\n            vaultRef = self.flowVault as \u0026FungibleToken.Vault\n        } else {\n            tempVault.deposit(from: \u003c- self.flowVault.withdraw(amount: estimatedStorageFee))\n        }\n\n        let ctx : {String : String} = {\n            \"tenant\" : \"find\"\n        }\n\n        for i,  pointer in self.authPointers {\n            let receiver = allReceivers[i]\n            let id = ids[i]\n            ctx[\"message\"] = memos[i]\n            let path = self.paths[i]\n\n            var user = addresses[receiver]\n            if user == nil {\n                user = FIND.resolve(receiver) ?? panic(\"Cannot resolve user with name / address : \".concat(receiver))\n                addresses[receiver] = user\n            }\n\n            // airdrop thru airdropper\n            FindAirdropper.subsidizedAirdrop(pointer: pointer, receiver: user!, path: path, context: ctx, storagePayment: vaultRef, flowTokenRepayment: self.flowTokenRepayment, deepValidation: true)\n        }\n        self.flowVault.deposit(from: \u003c- tempVault)\n\n        // This is hard coded for spliting at the front end for now. So if there are no royalties, all goes to find\n        // AND This does not support different ft types for now.\n        var goesToFindFund = 0.0\n        for i , type in donationTypes {\n            if type == nil {\n                continue\n            }\n            let amount = donationAmounts[i]!\n            let royalties = self.royalties[i]!\n            let totalRoyalties = self.totalRoyalties[i]\n            let vaultRef = self.vaultRefs[type!]!\n            if totalRoyalties == 0.0 {\n                goesToFindFund = goesToFindFund + amount\n                continue\n            }\n\n            let balance = vaultRef.balance\n            var totalPaid = 0.0\n\n            for j, r in royalties.getRoyalties() {\n                var cap : Capability\u003c\u0026{FungibleToken.Receiver}\u003e = r.receiver\n                if !r.receiver.check(){\n                    // try to grab from profile\n                    if let ref = getAccount(r.receiver.address).getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath).borrow() {\n                        if ref.hasWallet(vaultRef.getType().identifier) {\n                            cap = getAccount(r.receiver.address).getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n                        } else if let ftInfo = FTRegistry.getFTInfo(vaultRef.getType().identifier) {\n                            cap = getAccount(r.receiver.address).getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(ftInfo.receiverPath)\n                        }\n                    }\n\n                }\n\n                if cap.check() {\n                    let individualAmount = r.cut / totalRoyalties * amount\n                    let vault \u003c- vaultRef.withdraw(amount: individualAmount)\n                    cap.borrow()!.deposit(from: \u003c- vault)\n\n                    totalPaid = totalPaid + individualAmount\n                }\n            }\n\n            assert(totalPaid \u003c= amount, message: \"Amount paid is greater than expected\" )\n\n        }\n\n\n        // for donating to find\n        if findDonationType != nil {\n            vaultRef = self.vaultRefs[findDonationType!]!\n            let vault \u003c- vaultRef.withdraw(amount: findDonationAmount! + goesToFindFund)\n            FIND.depositWithTagAndMessage(to: \"find\", message: \"donation to .find\", tag: \"donation\", vault: \u003c- vault, from: self.token)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "nftIdentifiers",
                     "allReceivers",
                     "ids",
                     "memos",
                     "donationTypes",
                     "donationAmounts",
                     "findDonationType",
                     "findDonationAmount"
                  ],
                  "parameters": {
                     "allReceivers": "[String]",
                     "donationAmounts": "[UFix64?]",
                     "donationTypes": "[String?]",
                     "findDonationAmount": "UFix64?",
                     "findDonationType": "String?",
                     "ids": "[UInt64]",
                     "memos": "[String]",
                     "nftIdentifiers": "[String]"
                  }
               }
            },
            "sendWearables": {
               "code": "import NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FindViews from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\nimport FindAirdropper from 0x35717efbbce11c74\nimport Wearables from 0x1e0493ee604e7598\n\ntransaction(allReceivers: [String] , ids:[UInt64], memos: [String]) {\n\n    let authPointers : [FindViews.AuthNFTPointer]\n\n    prepare(account : AuthAccount) {\n\n        self.authPointers = []\n        let privatePath = Wearables.CollectionPrivatePath\n        let storagePath = Wearables.CollectionStoragePath\n\n        for id in ids {\n\n            var providerCap=account.getCapability\u003c\u0026{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e(privatePath)\n            if !providerCap.check() {\n                let newCap = account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                    privatePath,\n                    target: storagePath\n                )\n                if newCap == nil {\n                    // If linking is not successful, we link it using finds custom link\n                    let pathIdentifier = privatePath.toString()\n                    let findPath = PrivatePath(identifier: pathIdentifier.slice(from: \"/private/\".length , upTo: pathIdentifier.length).concat(\"_FIND\"))!\n                    account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                        findPath,\n                        target: storagePath\n                    )\n                    providerCap = account.getCapability\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(findPath)\n                }\n            }\n            let pointer = FindViews.AuthNFTPointer(cap: providerCap, id: id)\n\n            self.authPointers.append(pointer)\n        }\n\n    }\n\n    execute {\n        let addresses : {String : Address} = {}\n        let publicPath = Wearables.CollectionPublicPath\n\n        let ctx : {String : String} = {\n            \"tenant\" : \"find\"\n        }\n\n        for i,  pointer in self.authPointers {\n            let receiver = allReceivers[i]\n            let id = ids[i]\n            ctx[\"message\"] = memos[i]\n\n            var user = addresses[receiver]\n            if user == nil {\n                user = FIND.resolve(receiver) ?? panic(\"Cannot resolve user with name / address : \".concat(receiver))\n                addresses[receiver] = user\n            }\n\n            // airdrop thru airdropper\n            FindAirdropper.safeAirdrop(pointer: pointer, receiver: user!, path: publicPath, context: ctx, deepValidation: true)\n        }\n\n    }\n}",
               "spec": {
                  "order": [
                     "allReceivers",
                     "ids",
                     "memos"
                  ],
                  "parameters": {
                     "allReceivers": "[String]",
                     "ids": "[UInt64]",
                     "memos": "[String]"
                  }
               }
            },
            "setMainName": {
               "code": "import Profile from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\n\n\ntransaction(name: String) {\n\n    let leaseCollectionOwner : Capability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e\n    let profile : \u0026Profile.User\n\n    prepare(acct: AuthAccount) {\n        self.leaseCollectionOwner = acct.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        self.profile =acct.borrow\u003c\u0026Profile.User\u003e(from:Profile.storagePath)!\n    }\n\n    pre{\n        self.leaseCollectionOwner.check() : \"Not a find user\"\n        self.leaseCollectionOwner.borrow()!.getLease(name) != nil : \"You do not own this lease so you cannot set it as main name\"\n    }\n\n    execute{\n        self.profile.setFindName(name)\n    }\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "setMarketOptionFlowDandy": {
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FlowToken from 0x7e60df042a9c0868\nimport Dandy from 0x35717efbbce11c74\n\ntransaction(){\n    prepare(account: AuthAccount){\n        let path = FindMarket.TenantClientStoragePath\n        let tenantRef = account.borrow\u003c\u0026FindMarket.TenantClient\u003e(from: path) ?? panic(\"Cannot borrow Reference.\")\n\n        tenantRef.setMarketOption(name:\"FlowDandy\", cut: nil, rules:[\n            FindMarket.TenantRule(name:\"Flow\", types:[Type\u003c@FlowToken.Vault\u003e()], ruleType: \"ft\", allow: true),\n            FindMarket.TenantRule(name:\"Dandy\", types:[ Type\u003c@Dandy.NFT\u003e()], ruleType: \"nft\", allow: true)\n            ]\n        )\n    }\n}",
               "spec": {
                  "order": [],
                  "parameters": {}
               }
            },
            "setPrivateMode": {
               "code": "import Profile from 0x35717efbbce11c74\n\ntransaction(mode: Bool) {\n\n    let profile : \u0026Profile.User?\n\n    prepare(acct: AuthAccount) {\n        self.profile =acct.borrow\u003c\u0026Profile.User\u003e(from:Profile.storagePath)\n    }\n\n    pre{\n        self.profile != nil : \"Cannot borrow reference to profile\"\n    }\n\n    execute{\n        self.profile!.setPrivateMode(mode)\n        self.profile!.emitUpdatedEvent()\n    }\n}",
               "spec": {
                  "order": [
                     "mode"
                  ],
                  "parameters": {
                     "mode": "Bool"
                  }
               }
            },
            "setPrivateModeDapper": {
               "code": "import Profile from 0x35717efbbce11c74\n\ntransaction(mode: Bool) {\n\n    let profile : \u0026Profile.User?\n\n    prepare(acct: AuthAccount) {\n        self.profile =acct.borrow\u003c\u0026Profile.User\u003e(from:Profile.storagePath)\n    }\n\n    pre{\n        self.profile != nil : \"Cannot borrow reference to profile\"\n    }\n\n    execute{\n        self.profile!.setPrivateMode(mode)\n        self.profile!.emitUpdatedEvent()\n    }\n}",
               "spec": {
                  "order": [
                     "mode"
                  ],
                  "parameters": {
                     "mode": "Bool"
                  }
               }
            },
            "setProfile": {
               "code": "import Profile from 0x35717efbbce11c74\n\ntransaction(avatar: String) {\n\n    let profile : \u0026Profile.User?\n\n    prepare(acct: AuthAccount) {\n        self.profile =acct.borrow\u003c\u0026Profile.User\u003e(from:Profile.storagePath)\n    }\n\n    pre{\n        self.profile != nil : \"Cannot borrow reference to profile\"\n    }\n\n    execute{\n        self.profile!.setAvatar(avatar)\n        self.profile!.emitUpdatedEvent()\n    }\n}",
               "spec": {
                  "order": [
                     "avatar"
                  ],
                  "parameters": {
                     "avatar": "String"
                  }
               }
            },
            "setRelatedAccount": {
               "code": "import FindRelatedAccounts from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\n\ntransaction(name: String, target: String) {\n\n    var relatedAccounts : \u0026FindRelatedAccounts.Accounts?\n    let address : Address?\n\n    prepare(account: AuthAccount) {\n\n\n        self.address = FIND.resolve(target)\n\n        self.relatedAccounts= account.borrow\u003c\u0026FindRelatedAccounts.Accounts\u003e(from:FindRelatedAccounts.storagePath)\n        if self.relatedAccounts == nil {\n            let relatedAccounts \u003c- FindRelatedAccounts.createEmptyAccounts()\n            account.save(\u003c- relatedAccounts, to: FindRelatedAccounts.storagePath)\n            account.link\u003c\u0026FindRelatedAccounts.Accounts{FindRelatedAccounts.Public}\u003e(FindRelatedAccounts.publicPath, target: FindRelatedAccounts.storagePath)\n            self.relatedAccounts= account.borrow\u003c\u0026FindRelatedAccounts.Accounts\u003e(from:FindRelatedAccounts.storagePath)\n        }\n\n        let cap = account.getCapability\u003c\u0026FindRelatedAccounts.Accounts{FindRelatedAccounts.Public}\u003e(FindRelatedAccounts.publicPath)\n        if !cap.check() {\n            account.unlink(FindRelatedAccounts.publicPath)\n            account.link\u003c\u0026FindRelatedAccounts.Accounts{FindRelatedAccounts.Public}\u003e(FindRelatedAccounts.publicPath, target: FindRelatedAccounts.storagePath)\n        }\n    }\n\n    pre{\n        self.address != nil : \"The input pass in is not a valid name or address. Input : \".concat(target)\n    }\n\n    execute{\n        self.relatedAccounts!.addFlowAccount(name: name, address: self.address!)\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "target"
                  ],
                  "parameters": {
                     "name": "String",
                     "target": "String"
                  }
               }
            },
            "setRelatedAccountDapper": {
               "code": "import FindRelatedAccounts from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\n\ntransaction(name: String, target: String) {\n\n    var relatedAccounts : \u0026FindRelatedAccounts.Accounts?\n    let address : Address?\n\n    prepare(account: AuthAccount) {\n\n\n        self.address = FIND.resolve(target)\n\n        self.relatedAccounts= account.borrow\u003c\u0026FindRelatedAccounts.Accounts\u003e(from:FindRelatedAccounts.storagePath)\n        if self.relatedAccounts == nil {\n            let relatedAccounts \u003c- FindRelatedAccounts.createEmptyAccounts()\n            account.save(\u003c- relatedAccounts, to: FindRelatedAccounts.storagePath)\n            account.link\u003c\u0026FindRelatedAccounts.Accounts{FindRelatedAccounts.Public}\u003e(FindRelatedAccounts.publicPath, target: FindRelatedAccounts.storagePath)\n            self.relatedAccounts= account.borrow\u003c\u0026FindRelatedAccounts.Accounts\u003e(from:FindRelatedAccounts.storagePath)\n        }\n\n        let cap = account.getCapability\u003c\u0026FindRelatedAccounts.Accounts{FindRelatedAccounts.Public}\u003e(FindRelatedAccounts.publicPath)\n        if !cap.check() {\n            account.unlink(FindRelatedAccounts.publicPath)\n            account.link\u003c\u0026FindRelatedAccounts.Accounts{FindRelatedAccounts.Public}\u003e(FindRelatedAccounts.publicPath, target: FindRelatedAccounts.storagePath)\n        }\n    }\n\n    pre{\n        self.address != nil : \"The input pass in is not a valid name or address. Input : \".concat(target)\n    }\n\n    execute{\n        self.relatedAccounts!.addFlowAccount(name: name, address: self.address!)\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "target"
                  ],
                  "parameters": {
                     "name": "String",
                     "target": "String"
                  }
               }
            },
            "setSellDandyRules": {
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FlowToken from 0x7e60df042a9c0868\nimport FUSD from 0xe223d8a629e49c68\nimport Dandy from 0x35717efbbce11c74\n\ntransaction(){\n    prepare(account: AuthAccount){\n        let path = FindMarket.TenantClientStoragePath\n        let tenantRef = account.borrow\u003c\u0026FindMarket.TenantClient\u003e(from: path) ?? panic(\"Cannot borrow Reference.\")\n\n        tenantRef.setMarketOption(name:\"FUSDDandy\", cut: nil, rules:[\n            FindMarket.TenantRule(name:\"FUSD\", types:[Type\u003c@FUSD.Vault\u003e()], ruleType: \"ft\", allow: true),\n            FindMarket.TenantRule(name:\"Dandy\", types:[ Type\u003c@Dandy.NFT\u003e()], ruleType: \"nft\", allow: true)\n            ]\n        )\n\n        tenantRef.setMarketOption(name:\"FlowDandy\", cut: nil, rules:[\n            FindMarket.TenantRule(name:\"Flow\", types:[Type\u003c@FlowToken.Vault\u003e()], ruleType: \"ft\", allow: true),\n            FindMarket.TenantRule(name:\"Dandy\", types:[ Type\u003c@Dandy.NFT\u003e()], ruleType: \"nft\", allow: true)\n            ]\n        )\n\n    }\n}",
               "spec": {
                  "order": [],
                  "parameters": {}
               }
            },
            "setTenantRuleFUSD": {
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FUSD from 0xe223d8a629e49c68\n\ntransaction(optionName: String){\n    prepare(account: AuthAccount){\n        let path = FindMarket.TenantClientStoragePath\n        let tenantRef = account.borrow\u003c\u0026FindMarket.TenantClient\u003e(from: path) ?? panic(\"Cannot borrow Reference.\")\n\n        tenantRef.setTenantRule(optionName: optionName, tenantRule:\n            FindMarket.TenantRule(name:\"FUSD\", types:[Type\u003c@FUSD.Vault\u003e()], ruleType: \"ft\", allow: true)\n        )\n    }\n}",
               "spec": {
                  "order": [
                     "optionName"
                  ],
                  "parameters": {
                     "optionName": "String"
                  }
               }
            },
            "startNameAuction": {
               "code": "import FIND from 0x35717efbbce11c74\n\ntransaction(name: String) {\n\n    let finLeases : \u0026FIND.LeaseCollection?\n\n    prepare(account: AuthAccount) {\n        self.finLeases= account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)\n    }\n\n    pre{\n        self.finLeases != nil : \"Cannot borrow reference to find lease collection\"\n    }\n\n    execute{\n        self.finLeases!.startAuction(name)\n    }\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "storeCuratedCollections": {
               "code": "transaction(collections: {String :  [String]}) {\n    prepare(account: AuthAccount) {\n\n        let path=/storage/FindCuratedCollections\n        let publicPath=/public/FindCuratedCollections\n\n        if account.borrow\u003c\u0026{String: [String]}\u003e(from:path) != nil {\n             account.load\u003c{String: [String]}\u003e(from:path)\n        }\n        account.save(collections, to: path)\n\n        let link = account.getCapability\u003c\u0026{String: [String]}\u003e(publicPath)\n        if !link.check() {\n            account.link\u003c\u0026{String: [String]}\u003e( publicPath, target: path)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "collections"
                  ],
                  "parameters": {
                     "collections": "{String: [String]}"
                  }
               }
            },
            "tenantsetExtraCut": {
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FindMarketCutStruct from 0x35717efbbce11c74\n\ntransaction(ftTypes: [String], category: String, cuts: [FindMarketCutStruct.ThresholdCut]){\n    prepare(account: AuthAccount){\n\n        let types : [Type] = []\n        for t in ftTypes {\n            types.append(CompositeType(t)!)\n        }\n\n        let allCuts = FindMarketCutStruct.Cuts(cuts)\n\n        let clientRef = account.borrow\u003c\u0026FindMarket.TenantClient\u003e(from: FindMarket.TenantClientStoragePath) ?? panic(\"Cannot borrow Tenant Client Reference.\")\n        clientRef.setExtraCut(types: types, category: category, cuts: allCuts)\n    }\n}",
               "spec": {
                  "order": [
                     "ftTypes",
                     "category",
                     "cuts"
                  ],
                  "parameters": {
                     "category": "String",
                     "cuts": "[FindMarketCutStruct.ThresholdCut]",
                     "ftTypes": "[String]"
                  }
               }
            },
            "tenantsetLeaseOptionDapper": {
               "code": "import FindMarket from 0x35717efbbce11c74\nimport DapperUtilityCoin from 0x82ec283f88a62e65\nimport FlowUtilityToken from 0x82ec283f88a62e65\nimport FindLeaseMarketSale from 0x35717efbbce11c74\nimport FindLeaseMarketAuctionSoft from 0x35717efbbce11c74\nimport FindLeaseMarketDirectOfferSoft from 0x35717efbbce11c74\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FungibleTokenSwitchboard from 0x9a0766d93b6608b7\n\ntransaction(nftName: String, nftType: String, cut: UFix64){\n    prepare(account: AuthAccount){\n\n        let defaultRules : [FindMarket.TenantRule] = [\n            FindMarket.TenantRule(\n                name: \"Dapper\",\n                types:[Type\u003c@DapperUtilityCoin.Vault\u003e(), Type\u003c@FlowUtilityToken.Vault\u003e()],\n                ruleType: \"ft\",\n                allow:true\n            ),\n            FindMarket.TenantRule(\n                name: \"Soft\",\n                types:[Type\u003c@FindLeaseMarketSale.SaleItem\u003e(),\n                Type\u003c@FindLeaseMarketAuctionSoft.SaleItem\u003e(),\n                Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItem\u003e()\n                ],\n                ruleType: \"listing\",\n                allow:true\n            )\n        ]\n\n        defaultRules.append(\n            FindMarket.TenantRule(\n                name: nftName,\n                types:[CompositeType(nftType)!],\n                ruleType: \"nft\",\n                allow:true\n            )\n        )\n\n        var royalty : MetadataViews.Royalty? = nil\n        if cut != 0.0 {\n            royalty = MetadataViews.Royalty(\n                receiver: account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(FungibleTokenSwitchboard.ReceiverPublicPath),\n                cut: cut,\n                description: \"tenant\"\n            )\n        }\n\n        let saleItem = FindMarket.TenantSaleItem(\n            name: \"Dapper\".concat(nftName).concat(\"Soft\"),\n            cut: royalty,\n            rules: defaultRules,\n            status: \"active\"\n        )\n\n        let clientRef = account.borrow\u003c\u0026FindMarket.TenantClient\u003e(from: FindMarket.TenantClientStoragePath) ?? panic(\"Cannot borrow Tenant Client Reference.\")\n        clientRef.setMarketOption(saleItem: saleItem)\n    }\n}",
               "spec": {
                  "order": [
                     "nftName",
                     "nftType",
                     "cut"
                  ],
                  "parameters": {
                     "cut": "UFix64",
                     "nftName": "String",
                     "nftType": "String"
                  }
               }
            },
            "tenantsetMarketOption": {
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FlowToken from 0x7e60df042a9c0868\nimport FUSD from 0xe223d8a629e49c68\nimport FiatToken from 0xa983fecbed621163\nimport FindMarketSale from 0x35717efbbce11c74\nimport FindMarketAuctionEscrow from 0x35717efbbce11c74\nimport FindMarketDirectOfferEscrow from 0x35717efbbce11c74\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FungibleTokenSwitchboard from 0x9a0766d93b6608b7\n\ntransaction(nftName: String, nftType: String, cut: UFix64){\n    prepare(account: AuthAccount){\n\n        let defaultRules : [FindMarket.TenantRule] = [\n            FindMarket.TenantRule(\n                name: \"Flow\",\n                types:[\n                    Type\u003c@FlowToken.Vault\u003e()\n                    ],\n                ruleType: \"ft\",\n                allow:true\n            ),\n            FindMarket.TenantRule(\n                name: nftName,\n                types:[CompositeType(nftType)!],\n                ruleType: \"nft\",\n                allow:true\n            ),\n                FindMarket.TenantRule(\n                name: \"Escrow\",\n                types:[Type\u003c@FindMarketSale.SaleItem\u003e(), Type\u003c@FindMarketAuctionEscrow.SaleItem\u003e(), Type\u003c@FindMarketDirectOfferEscrow.SaleItem\u003e()],\n                ruleType: \"listing\",\n                allow:true\n            )\n        ]\n\n        var royalty : MetadataViews.Royalty? = nil\n        if cut != 0.0 {\n            royalty = MetadataViews.Royalty(\n                receiver: account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(FungibleTokenSwitchboard.ReceiverPublicPath),\n                cut: cut,\n                description: \"tenant\"\n            )\n        }\n\n        let saleItem = FindMarket.TenantSaleItem(\n            name: \"Flow\".concat(nftName).concat(\"Escrow\"),\n            cut: royalty,\n            rules: defaultRules,\n            status: \"active\"\n        )\n\n        let clientRef = account.borrow\u003c\u0026FindMarket.TenantClient\u003e(from: FindMarket.TenantClientStoragePath) ?? panic(\"Cannot borrow Tenant Client Reference.\")\n        clientRef.setMarketOption(saleItem: saleItem)\n    }\n}",
               "spec": {
                  "order": [
                     "nftName",
                     "nftType",
                     "cut"
                  ],
                  "parameters": {
                     "cut": "UFix64",
                     "nftName": "String",
                     "nftType": "String"
                  }
               }
            },
            "tenantsetMarketOptionDUC": {
               "code": "import FindMarket from 0x35717efbbce11c74\nimport DapperUtilityCoin from 0x82ec283f88a62e65\nimport FlowUtilityToken from 0x82ec283f88a62e65\nimport FindLeaseMarketSale from 0x35717efbbce11c74\nimport FindLeaseMarketAuctionSoft from 0x35717efbbce11c74\nimport FindLeaseMarketDirectOfferSoft from 0x35717efbbce11c74\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FungibleTokenSwitchboard from 0x9a0766d93b6608b7\n\ntransaction(nftName: String, nftType: String, cut: UFix64){\n    prepare(account: AuthAccount){\n\n        let defaultRules : [FindMarket.TenantRule] = [\n            FindMarket.TenantRule(\n                name: \"Dapper\",\n                types:[\n                    // Type\u003c@FlowUtilityToken.Vault\u003e(),\n                    Type\u003c@DapperUtilityCoin.Vault\u003e()\n                ],\n                ruleType: \"ft\",\n                allow:true\n            ),\n            FindMarket.TenantRule(\n                name: \"Soft\",\n                types:[\n                    Type\u003c@FindLeaseMarketSale.SaleItem\u003e(),\n                    Type\u003c@FindLeaseMarketAuctionSoft.SaleItem\u003e(),\n                    Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItem\u003e()\n                ],\n                ruleType: \"listing\",\n                allow:true\n            )\n        ]\n\n        defaultRules.append(\n            FindMarket.TenantRule(\n                name: nftName,\n                types:[CompositeType(nftType)!],\n                ruleType: \"nft\",\n                allow:true\n            )\n        )\n\n        var royalty : MetadataViews.Royalty? = nil\n        if cut != 0.0 {\n            royalty = MetadataViews.Royalty(\n                receiver: account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(FungibleTokenSwitchboard.ReceiverPublicPath),\n                cut: cut,\n                description: \"tenant\"\n            )\n        }\n\n        let saleItem = FindMarket.TenantSaleItem(\n            name: \"Dapper\".concat(nftName).concat(\"Soft\"),\n            cut: royalty,\n            rules: defaultRules,\n            status: \"active\"\n        )\n\n        let clientRef = account.borrow\u003c\u0026FindMarket.TenantClient\u003e(from: FindMarket.TenantClientStoragePath) ?? panic(\"Cannot borrow Tenant Client Reference.\")\n        clientRef.setMarketOption(saleItem: saleItem)\n    }\n}",
               "spec": {
                  "order": [
                     "nftName",
                     "nftType",
                     "cut"
                  ],
                  "parameters": {
                     "cut": "UFix64",
                     "nftName": "String",
                     "nftType": "String"
                  }
               }
            },
            "tenantsetMarketOptionDapper": {
               "code": "import FindMarket from 0x35717efbbce11c74\nimport DapperUtilityCoin from 0x82ec283f88a62e65\nimport FlowUtilityToken from 0x82ec283f88a62e65\nimport FindMarketSale from 0x35717efbbce11c74\nimport FindMarketAuctionSoft from 0x35717efbbce11c74\nimport FindMarketDirectOfferSoft from 0x35717efbbce11c74\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FungibleTokenSwitchboard from 0x9a0766d93b6608b7\n\ntransaction(nftName: String, nftType: String, cut: UFix64){\n    prepare(account: AuthAccount){\n\n        let defaultRules : [FindMarket.TenantRule] = [\n            FindMarket.TenantRule(\n                name: \"Dapper\",\n                types:[\n                    Type\u003c@FlowUtilityToken.Vault\u003e(),\n                    Type\u003c@DapperUtilityCoin.Vault\u003e()\n                ],\n                ruleType: \"ft\",\n                allow:true\n            ),\n            FindMarket.TenantRule(\n                name: \"Soft\",\n                types:[\n                    Type\u003c@FindMarketSale.SaleItem\u003e(),\n                    Type\u003c@FindMarketAuctionSoft.SaleItem\u003e(),\n                    Type\u003c@FindMarketDirectOfferSoft.SaleItem\u003e()\n                ],\n                ruleType: \"listing\",\n                allow:true\n            )\n        ]\n\n        defaultRules.append(\n            FindMarket.TenantRule(\n                name: nftName,\n                types:[CompositeType(nftType)!],\n                ruleType: \"nft\",\n                allow:true\n            )\n        )\n\n        var royalty : MetadataViews.Royalty? = nil\n        if cut != 0.0 {\n            royalty = MetadataViews.Royalty(\n                receiver: account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(FungibleTokenSwitchboard.ReceiverPublicPath),\n                cut: cut,\n                description: \"tenant\"\n            )\n        }\n\n        let saleItem = FindMarket.TenantSaleItem(\n            name: \"Dapper\".concat(nftName).concat(\"Soft\"),\n            cut: royalty,\n            rules: defaultRules,\n            status: \"active\"\n        )\n\n        let clientRef = account.borrow\u003c\u0026FindMarket.TenantClient\u003e(from: FindMarket.TenantClientStoragePath) ?? panic(\"Cannot borrow Tenant Client Reference.\")\n        clientRef.setMarketOption(saleItem: saleItem)\n    }\n}",
               "spec": {
                  "order": [
                     "nftName",
                     "nftType",
                     "cut"
                  ],
                  "parameters": {
                     "cut": "UFix64",
                     "nftName": "String",
                     "nftType": "String"
                  }
               }
            },
            "testInitFUSDVault": {
               "code": "import FungibleToken from 0x9a0766d93b6608b7\nimport FUSD from 0xe223d8a629e49c68\nimport FiatToken from 0xa983fecbed621163\n\n\ntransaction() {\n    prepare(account: AuthAccount) {\n        let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n        if !fusdReceiver.check() {\n            let fusd \u003c- FUSD.createEmptyVault()\n            account.save(\u003c- fusd, to: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n        }\n\n    }\n}",
               "spec": {
                  "order": [],
                  "parameters": {}
               }
            },
            "unfollow": {
               "code": "import FIND from 0x35717efbbce11c74\nimport Profile from 0x35717efbbce11c74\n\n// array of [User in string (find name or address)]\ntransaction(unfollows:[String]) {\n\n    let profile : \u0026Profile.User\n\n    prepare(account: AuthAccount) {\n\n        self.profile =account.borrow\u003c\u0026Profile.User\u003e(from:Profile.storagePath) ?? panic(\"Cannot borrow reference to profile\")\n\n    }\n\n    execute{\n        for key in unfollows {\n            let user = FIND.resolve(key) ?? panic(key.concat(\" cannot be resolved. It is either an invalid .find name or address\"))\n            self.profile.unfollow(user)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "unfollows"
                  ],
                  "parameters": {
                     "unfollows": "[String]"
                  }
               }
            },
            "unlinkDUCVaultReceiver": {
               "code": "import TokenForwarding from 0x51ea0e37c27a1f1a\n\n\ntransaction() {\n    prepare(account: AuthAccount) {\n        account.unlink(/public/dapperUtilityCoinReceiver)\n    }\n}",
               "spec": {
                  "order": [],
                  "parameters": {}
               }
            },
            "updateRelatedAccount": {
               "code": "import FindRelatedAccounts from 0x35717efbbce11c74\n\ntransaction(name: String, network: String, oldAddress:String, address: String) {\n\n    var relatedAccounts : \u0026FindRelatedAccounts.Accounts?\n\n    prepare(account: AuthAccount) {\n\n        self.relatedAccounts= account.borrow\u003c\u0026FindRelatedAccounts.Accounts\u003e(from:FindRelatedAccounts.storagePath)\n        if self.relatedAccounts == nil {\n            let relatedAccounts \u003c- FindRelatedAccounts.createEmptyAccounts()\n            account.save(\u003c- relatedAccounts, to: FindRelatedAccounts.storagePath)\n            account.link\u003c\u0026FindRelatedAccounts.Accounts{FindRelatedAccounts.Public}\u003e(FindRelatedAccounts.publicPath, target: FindRelatedAccounts.storagePath)\n            self.relatedAccounts = account.borrow\u003c\u0026FindRelatedAccounts.Accounts\u003e(from:FindRelatedAccounts.storagePath)\n        }\n\n        let cap = account.getCapability\u003c\u0026FindRelatedAccounts.Accounts{FindRelatedAccounts.Public}\u003e(FindRelatedAccounts.publicPath)\n        if !cap.check() {\n            account.unlink(FindRelatedAccounts.publicPath)\n            account.link\u003c\u0026FindRelatedAccounts.Accounts{FindRelatedAccounts.Public}\u003e(FindRelatedAccounts.publicPath, target: FindRelatedAccounts.storagePath)\n        }\n    }\n\n    execute {\n        self.relatedAccounts!.updateRelatedAccount(name:name, network:network, oldAddress: oldAddress, address: address)\n    }\n\n}",
               "spec": {
                  "order": [
                     "name",
                     "network",
                     "oldAddress",
                     "address"
                  ],
                  "parameters": {
                     "address": "String",
                     "name": "String",
                     "network": "String",
                     "oldAddress": "String"
                  }
               }
            },
            "updateRelatedFlowAccount": {
               "code": "import FindRelatedAccounts from 0x35717efbbce11c74\n\ntransaction(name: String, oldAddress: Address, address: Address) {\n\n    var relatedAccounts : \u0026FindRelatedAccounts.Accounts?\n\n    prepare(account: AuthAccount) {\n\n        self.relatedAccounts= account.borrow\u003c\u0026FindRelatedAccounts.Accounts\u003e(from:FindRelatedAccounts.storagePath)\n        if self.relatedAccounts == nil {\n            let relatedAccounts \u003c- FindRelatedAccounts.createEmptyAccounts()\n            account.save(\u003c- relatedAccounts, to: FindRelatedAccounts.storagePath)\n            account.link\u003c\u0026FindRelatedAccounts.Accounts{FindRelatedAccounts.Public}\u003e(FindRelatedAccounts.publicPath, target: FindRelatedAccounts.storagePath)\n            self.relatedAccounts = account.borrow\u003c\u0026FindRelatedAccounts.Accounts\u003e(from:FindRelatedAccounts.storagePath)\n        }\n\n        let cap = account.getCapability\u003c\u0026FindRelatedAccounts.Accounts{FindRelatedAccounts.Public}\u003e(FindRelatedAccounts.publicPath)\n        if !cap.check() {\n            account.unlink(FindRelatedAccounts.publicPath)\n            account.link\u003c\u0026FindRelatedAccounts.Accounts{FindRelatedAccounts.Public}\u003e(FindRelatedAccounts.publicPath, target: FindRelatedAccounts.storagePath)\n        }\n    }\n\n    execute {\n        self.relatedAccounts!.updateFlowAccount(name:name, oldAddress: oldAddress, address: address)\n    }\n\n}",
               "spec": {
                  "order": [
                     "name",
                     "oldAddress",
                     "address"
                  ],
                  "parameters": {
                     "address": "Address",
                     "name": "String",
                     "oldAddress": "Address"
                  }
               }
            }
         }
      }
   }
}
