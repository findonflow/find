{
  "transactions": {
    "bid": "import FIND from 0xFIND\nimport FungibleToken from 0xFungibleToken\nimport FUSD from 0xFUSD\n\ntransaction(name: String, amount: UFix64) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet vaultRef = account.borrow<&FUSD.Vault>(from: /storage/fusdVault) ?? panic(\"Could not borrow reference to the fusdVault!\")\n\t\t \n\t\tlet fusdReceiver = account.getCapability<&{FungibleToken.Receiver}>(/public/fusdReceiver)\n\n\t\tlet leaseCollection = account.getCapability<&FIND.LeaseCollection{FIND.LeaseCollectionPublic}>(FIND.LeasePublicPath)\n\t\tif !leaseCollection.check() {\n\t\t\taccount.unlink(FIND.LeasePublicPath)\n\t\t\tdestroy <- account.load<@AnyResource>(from:FIND.LeaseStoragePath)\n\t\t\taccount.save(<- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n\t\t\taccount.link<&FIND.LeaseCollection{FIND.LeaseCollectionPublic}>( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n\t\t}\n\n\t\tlet bidCollection = account.getCapability<&FIND.BidCollection{FIND.BidCollectionPublic}>(FIND.BidPublicPath)\n\t\tif !bidCollection.check() {\n\t\t\taccount.unlink(FIND.BidPublicPath)\n\t\t\tdestroy <- account.load<@AnyResource>(from:FIND.BidStoragePath)\n\t\t\taccount.save(<- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n\t\t\taccount.link<&FIND.BidCollection{FIND.BidCollectionPublic}>( FIND.BidPublicPath, target: FIND.BidStoragePath)\n\t\t}\n\n\t\tlet vault <- vaultRef.withdraw(amount: amount) as! @FUSD.Vault\n\t\tlet bids = account.borrow<&FIND.BidCollection>(from: FIND.BidStoragePath)!\n\t\tbids.bid(name: name, vault: <- vault)\n\n\t}\n}\n",
    "bidProfile": "import FIND from 0xFIND\nimport FungibleToken from 0xFungibleToken\nimport Profile from 0xProfile\nimport FUSD from 0xFUSD\n\ntransaction(name: String, amount: UFix64) {\n\tprepare(account: AuthAccount) {\n\n\n\t\t//Add exising FUSD or create a new one and add it\n\t\tlet fusdReceiver = account.getCapability<&{FungibleToken.Receiver}>(/public/fusdReceiver)\n\t\tif !fusdReceiver.check() {\n\t\t\tlet fusd <- FUSD.createEmptyVault()\n\t\t\taccount.save(<- fusd, to: /storage/fusdVault)\n\t\t\taccount.link<&FUSD.Vault{FungibleToken.Receiver}>( /public/fusdReceiver, target: /storage/fusdVault)\n\t\t\taccount.link<&FUSD.Vault{FungibleToken.Balance}>( /public/fusdBalance, target: /storage/fusdVault)\n\t\t}\n\n\t\tlet leaseCollection = account.getCapability<&FIND.LeaseCollection{FIND.LeaseCollectionPublic}>(FIND.LeasePublicPath)\n\t\tif !leaseCollection.check() {\n\t\t\taccount.unlink(FIND.LeasePublicPath)\n\t\t\tdestroy <- account.load<@AnyResource>(from:FIND.LeaseStoragePath)\n\n\t\t\taccount.save(<- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n\t\t\taccount.link<&FIND.LeaseCollection{FIND.LeaseCollectionPublic}>( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n\t\t}\n\n\t\tlet bidCollection = account.getCapability<&FIND.BidCollection{FIND.BidCollectionPublic}>(FIND.BidPublicPath)\n\t\tif !bidCollection.check() {\n\t\t\taccount.unlink(FIND.BidPublicPath)\n\t\t\tdestroy <- account.load<@AnyResource>(from:FIND.BidStoragePath)\n\n\t\t\taccount.save(<- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n\t\t\taccount.link<&FIND.BidCollection{FIND.BidCollectionPublic}>( FIND.BidPublicPath, target: FIND.BidStoragePath)\n\t\t}\n\n\t\tlet profileCap = account.getCapability<&{Profile.Public}>(Profile.publicPath)\n\t\tif !profileCap.check() {\n\t\t\taccount.unlink(Profile.publicPath)\n\t\t\tdestroy <- account.load<@AnyResource>(from:Profile.storagePath)\n\n\t\t\tlet profile <-Profile.createUser(name:name, description: \"\", allowStoringFollowers:true, tags:[\"find\"])\n\n\t\t\tlet fusdWallet=Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:account.getCapability<&{FungibleToken.Balance}>(/public/fusdBalance), accept: Type<@FUSD.Vault>(), names: [\"fusd\", \"stablecoin\"])\n\n\t\t\tprofile.addWallet(fusdWallet)\n\t\t\tprofile.addCollection(Profile.ResourceCollection(\"FINDLeases\",leaseCollection, Type<&FIND.LeaseCollection{FIND.LeaseCollectionPublic}>(), [\"find\", \"leases\"]))\n\t\t\tprofile.addCollection(Profile.ResourceCollection(\"FINDBids\", bidCollection, Type<&FIND.BidCollection{FIND.BidCollectionPublic}>(), [\"find\", \"bids\"]))\n\n\t\t\taccount.save(<-profile, to: Profile.storagePath)\n\t\t\taccount.link<&Profile.User{Profile.Public}>(Profile.publicPath, target: Profile.storagePath)\n\t\t}\n\n\t\tlet vaultRef = account.borrow<&FUSD.Vault>(from: /storage/fusdVault) ?? panic(\"Could not borrow reference to the fusdVault!\")\n\t\tlet vault <- vaultRef.withdraw(amount: amount) as! @FUSD.Vault\n\t\tlet bids = account.borrow<&FIND.BidCollection>(from: FIND.BidStoragePath)!\n\t\tbids.bid(name: name, vault: <- vault)\n\n\t}\n}\n",
    "buyAddon": "import FUSD from 0xFUSD\nimport FIND from 0xFIND\n\n\ntransaction(name: String, addon:String, amount:UFix64) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet leases= account.borrow<&FIND.LeaseCollection>(from:FIND.LeaseStoragePath)!\n\n\t\tlet vaultRef = account.borrow<&FUSD.Vault>(from: /storage/fusdVault) ?? panic(\"Could not borrow reference to the fusdVault!\")\n\t\tlet vault <- vaultRef.withdraw(amount: amount) as! @FUSD.Vault\n\t\tleases.buyAddon(name: name, addon: addon, vault: <- vault)\n\t}\n}\n",
    "cancelAuction": "import FIND from 0xFIND\n\ntransaction(name: String) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet finLeases= account.borrow<&FIND.LeaseCollection>(from:FIND.LeaseStoragePath)!\n\t\tfinLeases.cancel(name)\n\t\tfinLeases.delistAuction(name)\n\n\t}\n}\n",
    "cancelBid": "import FIND from 0xFIND\n\ntransaction(name: String) {\n\tprepare(account: AuthAccount) {\n\t\tlet bids = account.borrow<&FIND.BidCollection>(from: FIND.BidStoragePath)!\n\t\tbids.cancelBid(name)\n\t}\n}\n",
    "clock": "import Admin from 0xAdmin\n\ntransaction(clock: UFix64) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet adminClient=account.borrow<&Admin.AdminProxy>(from: Admin.AdminProxyStoragePath)!\n\t\tadminClient.advanceClock(clock)\n\n\t}\n}\n",
    "createProfile": "import FungibleToken from 0xFungibleToken\nimport FUSD from 0xFUSD\nimport FlowToken from 0xFlowToken\nimport FIND from 0xFIND\nimport Profile from 0xProfile\nimport Artifact from 0xArtifact\nimport Art from 0xArt\nimport TypedMetadata from 0xTypedMetadata\n\n\n//really not sure on how to input links here.)\ntransaction(name: String) {\n\tprepare(acct: AuthAccount) {\n\t\t//if we do not have a profile it might be stored under a different address so we will just remove it\n\t\tlet profileCap = acct.getCapability<&{Profile.Public}>(Profile.publicPath)\n\t\tif !profileCap.check() {\n\t\t\tacct.unlink(Profile.publicPath)\n\t\t\tdestroy <- acct.load<@AnyResource>(from:Profile.storagePath)\n\t\t}\n\n\t\t//TODO we already have a profile\n\t\tif profileCap.check() {\n\t\t\treturn \n\t\t}\n\n\t\tlet profile <-Profile.createUser(name:name, description: \"\", allowStoringFollowers:true, tags:[\"find\"])\n\n\t\t//Add exising FUSD or create a new one and add it\n\t\tlet fusdReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/fusdReceiver)\n\t\tif !fusdReceiver.check() {\n\t\t\tlet fusd <- FUSD.createEmptyVault()\n\t\t\tacct.save(<- fusd, to: /storage/fusdVault)\n\t\t\tacct.link<&FUSD.Vault{FungibleToken.Receiver}>( /public/fusdReceiver, target: /storage/fusdVault)\n\t\t\tacct.link<&FUSD.Vault{FungibleToken.Balance}>( /public/fusdBalance, target: /storage/fusdVault)\n\t\t}\n\n\t\tlet fusdWallet=Profile.Wallet(\n\t\t\tname:\"FUSD\", \n\t\t\treceiver:acct.getCapability<&{FungibleToken.Receiver}>(/public/fusdReceiver),\n\t\t\tbalance:acct.getCapability<&{FungibleToken.Balance}>(/public/fusdBalance),\n\t\t\taccept: Type<@FUSD.Vault>(),\n\t\t\tnames: [\"fusd\", \"stablecoin\"]\n\t\t)\n\n\t\tprofile.addWallet(fusdWallet)\n\n\n\t\t\tlet flowWallet=Profile.Wallet(\n\t\t\t\tname:\"Flow\", \n\t\t\t\treceiver:acct.getCapability<&{FungibleToken.Receiver}>(/public/flowTokenReceiver),\n\t\t\t\tbalance:acct.getCapability<&{FungibleToken.Balance}>(/public/flowTokenBalance),\n\t\t\t\taccept: Type<@FlowToken.Vault>(),\n\t\t\t\tnames: [\"flow\"]\n\t\t\t)\n\t\t\tprofile.addWallet(flowWallet)\n\t\tlet leaseCollection = acct.getCapability<&FIND.LeaseCollection{FIND.LeaseCollectionPublic}>(FIND.LeasePublicPath)\n\t\tif !leaseCollection.check() {\n\t\t\tacct.unlink(FIND.LeasePublicPath)\n\t\t\tdestroy <- acct.load<@AnyResource>(from:FIND.LeaseStoragePath)\n\t\t\tacct.save(<- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n\t\t\tacct.link<&FIND.LeaseCollection{FIND.LeaseCollectionPublic}>( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n\t\t}\n\t\tprofile.addCollection(Profile.ResourceCollection(\"FINDLeases\",leaseCollection, Type<&FIND.LeaseCollection{FIND.LeaseCollectionPublic}>(), [\"find\", \"leases\"]))\n\n\t\tlet bidCollection = acct.getCapability<&FIND.BidCollection{FIND.BidCollectionPublic}>(FIND.BidPublicPath)\n\t\tif !bidCollection.check() {\n\t\t\tacct.unlink(FIND.BidPublicPath)\n\t\t\tdestroy <- acct.load<@AnyResource>(from:FIND.BidStoragePath)\n\t\t\tacct.save(<- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n\t\t\tacct.link<&FIND.BidCollection{FIND.BidCollectionPublic}>( FIND.BidPublicPath, target: FIND.BidStoragePath)\n\t\t}\n\t\tprofile.addCollection(Profile.ResourceCollection( \"FINDBids\", bidCollection, Type<&FIND.BidCollection{FIND.BidCollectionPublic}>(), [\"find\", \"bids\"]))\n\n\t\tlet artifactCollection = acct.getCapability<&{TypedMetadata.ViewResolverCollection}>(Artifact.ArtifactPublicPath)\n\t\tif !artifactCollection.check() {\n\t\t\tacct.unlink(Artifact.ArtifactPublicPath)\n\t\t\tdestroy <- acct.load<@AnyResource>(from:Artifact.ArtifactStoragePath)\n\n\t\t\tacct.save(<- Artifact.createEmptyCollection(), to: Artifact.ArtifactStoragePath)\n\t\t\tacct.link<&{TypedMetadata.ViewResolverCollection}>( Artifact.ArtifactPublicPath, target: Artifact.ArtifactStoragePath)\n\t\t}\n\t\tprofile.addCollection(Profile.ResourceCollection(name: \"artifacts\", collection: artifactCollection, type: Type<&{TypedMetadata.ViewResolverCollection}>(), tags: [\"artifact\", \"nft\"]))\n\n    //Create versus art collection if it does not exist and add it\n    let artCollectionCap=acct.getCapability<&{TypedMetadata.ViewResolverCollection}>(/public/versusArtViewResolver)\n    if !artCollectionCap.check() {\n      acct.save(<- Art.createEmptyCollection(), to: Art.CollectionStoragePath)\n\t\t\t//NB! this is not how versus current links this, it is just for convenience for this demo\n\t\t\tacct.link<&{Art.CollectionPublic}>(Art.CollectionPublicPath, target: Art.CollectionStoragePath)\n      acct.link<&{TypedMetadata.ViewResolverCollection}>(/public/versusArtViewResolver, target: Art.CollectionStoragePath)\n    }\n    profile.addCollection(Profile.ResourceCollection( name: \"versus\", collection:artCollectionCap, type: Type<&{TypedMetadata.ViewResolverCollection}>(), tags: [\"versus\", \"nft\"]))\n\n\t\tacct.save(<-profile, to: Profile.storagePath)\n\t\tacct.link<&Profile.User{Profile.Public}>(Profile.publicPath, target: Profile.storagePath)\n\n\t}\n}\n",
    "delistSale": "import FIND from 0xFIND\n\ntransaction(name: String) {\n\tprepare(acct: AuthAccount) {\n\t\tlet finLeases= acct.borrow<&FIND.LeaseCollection>(from:FIND.LeaseStoragePath)!\n\t\tfinLeases.delistSale(name)\n\t}\n}\n",
    "editProfile": "import FungibleToken from 0xFungibleToken\nimport FUSD from 0xFUSD\nimport FlowToken from 0xFlowToken\nimport FIND from 0xFIND\nimport Profile from 0xProfile\nimport Artifact from 0xArtifact\nimport TypedMetadata from 0xTypedMetadata\n\n\ntransaction(name:String, description: String, avatar: String, tags:[String], allowStoringFollowers: Bool, links: [{String: String}]) {\n\tprepare(acct: AuthAccount) {\n\n\t\tlet profile =acct.borrow<&Profile.User>(from:Profile.storagePath)!\n\n\t\t//Add exising FUSD or create a new one and add it\n\t\tlet fusdReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/fusdReceiver)\n\t\tif !fusdReceiver.check() {\n\t\t\tlet fusd <- FUSD.createEmptyVault()\n\t\t\tacct.save(<- fusd, to: /storage/fusdVault)\n\t\t\tacct.link<&FUSD.Vault{FungibleToken.Receiver}>( /public/fusdReceiver, target: /storage/fusdVault)\n\t\t\tacct.link<&FUSD.Vault{FungibleToken.Balance}>( /public/fusdBalance, target: /storage/fusdVault)\n\t\t}\n\n\n\t\tvar hasFusdWallet=false\n\t\tvar hasFlowWallet=false\n\t\tlet wallets=profile.getWallets()\n\t\tfor wallet in wallets {\n\t\t\tif wallet.name==\"FUSD\" {\n\t\t\t\thasFusdWallet=true\n\t\t\t}\n\n\t\t\tif wallet.name ==\"Flow\" {\n\t\t\t\thasFlowWallet=true\n\t\t\t}\n\t\t}\n\n\t\tvar hasArtifacts=false\n\t\tlet collections=profile.getCollections()\n\t\tfor c in collections {\n\t\t\tif c.name==\"artifacts\" {\n\t\t\t\thasArtifacts=true\n\t\t\t}\n\t\t}\n\n\t\tif !hasArtifacts {\n\t\t\tacct.save(<- Artifact.createEmptyCollection(), to: Artifact.ArtifactStoragePath)\n\t\t\tacct.link<&{TypedMetadata.ViewResolverCollection}>( Artifact.ArtifactPublicPath, target: Artifact.ArtifactStoragePath)\n\t\t\tlet artifactCollection = acct.getCapability<&{TypedMetadata.ViewResolverCollection}>(Artifact.ArtifactPublicPath)\n\t\t\tprofile.addCollection(Profile.ResourceCollection(name: \"artifacts\", collection: artifactCollection, type: Type<&{TypedMetadata.ViewResolverCollection}>(), tags: [\"artifact\", \"nft\"]))\n\t\t}\n\n\n\t\tif !hasFlowWallet {\n\t\t\tlet flowWallet=Profile.Wallet(\n\t\t\t\tname:\"Flow\", \n\t\t\t\treceiver:acct.getCapability<&{FungibleToken.Receiver}>(/public/flowTokenReceiver),\n\t\t\t\tbalance:acct.getCapability<&{FungibleToken.Balance}>(/public/flowTokenBalance),\n\t\t\t\taccept: Type<@FlowToken.Vault>(),\n\t\t\t\tnames: [\"flow\"]\n\t\t\t)\n\t\t\tprofile.addWallet(flowWallet)\n\t\t}\n\n\t\tif !hasFusdWallet {\n\t\t\tlet fusdWallet=Profile.Wallet(\n\t\t\t\tname:\"FUSD\", \n\t\t\t\treceiver:acct.getCapability<&{FungibleToken.Receiver}>(/public/fusdReceiver),\n\t\t\t\tbalance:acct.getCapability<&{FungibleToken.Balance}>(/public/fusdBalance),\n\t\t\t\taccept: Type<@FUSD.Vault>(),\n\t\t\t\tnames: [\"fusd\", \"stablecoin\"]\n\t\t\t)\n\t\t\tprofile.addWallet(fusdWallet)\n\t\t}\n\n\t\tprofile.setName(name)\n\t\tprofile.setDescription(description)\n\t\tprofile.setAvatar(avatar)\n\n\t\tlet existingTags=profile.setTags(tags)\n\n\t\tlet oldLinks=profile.getLinks()\n\n\t\tfor link in links {\n\t\t\tif link[\"remove\"] == \"true\" {\n\t\t\t  profile.removeLink(link[\"title\"]!)\t\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tprofile.addLink(Profile.Link(title: link[\"title\"]!, type: link[\"type\"]!, url: link[\"url\"]!))\n\t\t}\n\t}\n}\n\n",
    "fulfill": "import FIND from 0xFIND\n\ntransaction(name: String) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet finLeases= account.borrow<&FIND.LeaseCollection>(from:FIND.LeaseStoragePath)!\n\t\tfinLeases.fulfill(name)\n\n\t}\n}\n",
    "fulfillAuction": "import FIND from 0xFIND\n\ntransaction(owner: Address, name: String) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet leaseCollection = getAccount(owner).getCapability<&FIND.LeaseCollection{FIND.LeaseCollectionPublic}>(FIND.LeasePublicPath)\n\t\tleaseCollection.borrow()!.fulfillAuction(name)\n\n\t}\n}\n",
    "fulfillAuctionBidder": "import FIND from 0xFIND\nimport FungibleToken from 0xFungibleToken\nimport FUSD from 0xFUSD\nimport Profile from 0xProfile\n\ntransaction(owner: Address, name: String) {\n\tprepare(acct: AuthAccount) {\n\n\n\t//Add exising FUSD or create a new one and add it\n\t\tlet fusdReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/fusdReceiver)\n\t\tif !fusdReceiver.check() {\n\t\t\tlet fusd <- FUSD.createEmptyVault()\n\t\t\tacct.save(<- fusd, to: /storage/fusdVault)\n\t\t\tacct.link<&FUSD.Vault{FungibleToken.Receiver}>( /public/fusdReceiver, target: /storage/fusdVault)\n\t\t\tacct.link<&FUSD.Vault{FungibleToken.Balance}>( /public/fusdBalance, target: /storage/fusdVault)\n\t\t}\n\n\t\tlet leaseCollection = acct.getCapability<&FIND.LeaseCollection{FIND.LeaseCollectionPublic}>(FIND.LeasePublicPath)\n\t\tif !leaseCollection.check() {\n\t\t\tacct.unlink(FIND.LeasePublicPath)\n\t\t\tdestroy <- acct.load<@AnyResource>(from:FIND.LeaseStoragePath)\n\n\t\t\tacct.save(<- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n\t\t\tacct.link<&FIND.LeaseCollection{FIND.LeaseCollectionPublic}>( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n\t\t}\n\n\t\tlet bidCollection = acct.getCapability<&FIND.BidCollection{FIND.BidCollectionPublic}>(FIND.BidPublicPath)\n\t\tif !bidCollection.check() {\n\t\t\tacct.unlink(FIND.BidPublicPath)\n\t\t\tdestroy <- acct.load<@AnyResource>(from:FIND.BidStoragePath)\n\n\t\t\tacct.save(<- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n\t\t\tacct.link<&FIND.BidCollection{FIND.BidCollectionPublic}>( FIND.BidPublicPath, target: FIND.BidStoragePath)\n\t\t}\n\n\t\tlet profileCap = acct.getCapability<&{Profile.Public}>(Profile.publicPath)\n\t\tif !profileCap.check() {\n\t\t\tacct.unlink(Profile.publicPath)\n\t\t\tdestroy <- acct.load<@AnyResource>(from:Profile.storagePath)\n\n\t\t\tlet profile <-Profile.createUser(name:name, description: \"\", allowStoringFollowers:true, tags:[\"find\"])\n\n\t\t\tlet fusdWallet=Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:acct.getCapability<&{FungibleToken.Balance}>(/public/fusdBalance), accept: Type<@FUSD.Vault>(), names: [\"fusd\", \"stablecoin\"])\n\n\t\t\tprofile.addWallet(fusdWallet)\n\t\t\tprofile.addCollection(Profile.ResourceCollection(\"FINDLeases\",leaseCollection, Type<&FIND.LeaseCollection{FIND.LeaseCollectionPublic}>(), [\"find\", \"leases\"]))\n\t\t\tprofile.addCollection(Profile.ResourceCollection(\"FINDBids\", bidCollection, Type<&FIND.BidCollection{FIND.BidCollectionPublic}>(), [\"find\", \"bids\"]))\n\n\t\t\tacct.save(<-profile, to: Profile.storagePath)\n\t\t\tacct.link<&Profile.User{Profile.Public}>(Profile.publicPath, target: Profile.storagePath)\n\t\t}\n\n\t\tlet leaseCollectionOwner = getAccount(owner).getCapability<&FIND.LeaseCollection{FIND.LeaseCollectionPublic}>(FIND.LeasePublicPath)\n\t\tleaseCollectionOwner.borrow()!.fulfillAuction(name)\n\n\t}\n}\n",
    "increaseBid": "import FIND from 0xFIND\nimport FungibleToken from 0xFungibleToken\nimport FUSD from 0xFUSD\n\ntransaction(name: String, amount: UFix64) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet vaultRef = account.borrow<&FUSD.Vault>(from: /storage/fusdVault) ?? panic(\"Could not borrow reference to the fusdVault!\")\n\t\t\n\t\tlet fusdReceiver = account.getCapability<&{FungibleToken.Receiver}>(/public/fusdReceiver)\n\n\t\tlet leaseCollection = account.getCapability<&FIND.LeaseCollection{FIND.LeaseCollectionPublic}>(FIND.LeasePublicPath)\n\t\tif !leaseCollection.check() {\n\t\t\taccount.save(<- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n\t\t\taccount.link<&FIND.LeaseCollection{FIND.LeaseCollectionPublic}>( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n\t\t}\n\n\t\tlet bidCollection = account.getCapability<&FIND.BidCollection{FIND.BidCollectionPublic}>(FIND.BidPublicPath)\n\t\tif !bidCollection.check() {\n\t\t\taccount.save(<- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n\t\t\taccount.link<&FIND.BidCollection{FIND.BidCollectionPublic}>( FIND.BidPublicPath, target: FIND.BidStoragePath)\n\t\t}\n\n\n\t\tlet vault <- vaultRef.withdraw(amount: amount) as! @FUSD.Vault\n\t\tlet bids = account.borrow<&FIND.BidCollection>(from: FIND.BidStoragePath)!\n\t\tbids.increaseBid(name: name, vault: <- vault)\n\n\t}\n}\n",
    "listForAuction": "import FIND from 0xFIND\n\ntransaction(name: String, auctionStartPrice: UFix64, auctionReservePrice: UFix64, auctionDuration: UFix64, auctionExtensionOnLateBid: UFix64) {\n\tprepare(acct: AuthAccount) {\n\t\tlet finLeases= acct.borrow<&FIND.LeaseCollection>(from:FIND.LeaseStoragePath)!\n\t\tfinLeases.listForAuction(name: name, auctionStartPrice: auctionStartPrice, auctionReservePrice: auctionReservePrice, auctionDuration: auctionDuration,  auctionExtensionOnLateBid: auctionExtensionOnLateBid)\n\n\t}\n}\n",
    "listForSale": "import FIND from 0xFIND\n\ntransaction(name: String, directSellPrice:UFix64) {\n\tprepare(acct: AuthAccount) {\n\t\tlet finLeases= acct.borrow<&FIND.LeaseCollection>(from:FIND.LeaseStoragePath)!\n\t\tfinLeases.listForSale(name: name,  directSellPrice:directSellPrice)\n\t}\n}\n",
    "mintArt": "\nimport FIND from 0xFIND\nimport Admin from 0xAdmin\nimport Art from 0xArt\nimport FungibleToken from 0xFungibleToken\n\n//mint an art and add it to a users collection\ntransaction(\n    artist: Address,\n    artistName: String, \n    artName: String, \n    description: String,\n\t  target:Address,\n    type: String,\n    artistCut: UFix64,\n    minterCut: UFix64\n\t\tcontent: String,\n\t) {\n\n    let artistCollection: Capability<&{Art.CollectionPublic}>\n    let client: &Admin.AdminProxy\n\t\tlet minterWallet: Capability<&{FungibleToken.Receiver}>\n\n    prepare(account: AuthAccount) {\n\t\t\t\tself.client=account.borrow<&Admin.AdminProxy>(from: Admin.AdminProxyStoragePath)!\n        self.artistCollection= getAccount(target).getCapability<&{Art.CollectionPublic}>(Art.CollectionPublicPath)\n\t\t\t\tself.minterWallet=account.getCapability<&{FungibleToken.Receiver}>(/public/flowTokenReceiver)\n    }\n\n    execute {\n\t\t\t    let artistWallet= getAccount(artist).getCapability<&{FungibleToken.Receiver}>(/public/flowTokenReceiver)\n  \n         let royalty = {\n           \"artist\" : Art.Royalty(wallet: artistWallet, cut: artistCut),\n           \"minter\" : Art.Royalty(wallet: self.minterWallet, cut: minterCut)\n         }\n\t\t\tlet art <-  self.client.createVersusArtWithContent(name: artName, artist: artistName, artistAddress: artist, description: description, url: content, type: type, royalty: royalty, edition: 1, maxEdition: 1)\n        self.artistCollection.borrow()!.deposit(token: <- art)\n    }\n}\n\n",
    "mintArtifact": "import NonFungibleToken from 0xNonFungibleToken\nimport FungibleToken from 0xFungibleToken\nimport FUSD from 0xFUSD\nimport FlowToken from 0xFlowToken\nimport TypedMetadata from 0xTypedMetadata\nimport Artifact from 0xArtifact\nimport FIND from 0xFIND\nimport Profile from 0xProfile\n\ntransaction(name: String) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet finLeases= account.borrow<&FIND.LeaseCollection>(from:FIND.LeaseStoragePath)!\n\n\t\tlet sharedContentCap =account.getCapability<&{TypedMetadata.ViewResolverCollection}>(/private/sharedContent)\n\t\tif !sharedContentCap.check() {\n\t\t\taccount.save<@NonFungibleToken.Collection>(<- Artifact.createEmptyCollection(), to: /storage/sharedContent)\n\t\t\taccount.link<&{TypedMetadata.ViewResolverCollection}>(/private/sharedContent, target: /storage/sharedContent)\n\t\t}\n\n\t\t//this will panic if you cannot borrow it\n\t\tfinLeases.borrow(name) \n\n\t\tlet sharedSchemas : [AnyStruct] = [\n\t\t\tTypedMetadata.Media(data:\"https://neomotorcycles.co.uk/assets/img/neo_motorcycle_side.webp\" , contentType: \"image/webp\", protocol: \"http\"),\n\t\t\tTypedMetadata.CreativeWork(artist:\"Neo Motorcycles\", name:\"Neo Bike \", description: \"Bringing the motorcycle world into the 21st century with cutting edge EV technology and advanced performance in a great classic British style, all here in the UK\", type:\"image\"),\n\t\t\tTypedMetadata.Royalties(royalty: {\"artist\" : TypedMetadata.createPercentageRoyalty(user: account.address , cut: 0.05)})\n\t\t]\n\n\t\tlet sharedNFT <- finLeases.mintArtifact(name: name, nftName: \"NeoBike\", schemas:sharedSchemas)\n\t\tlet sharedPointer= Artifact.Pointer(collection: sharedContentCap, id: sharedNFT.id, views: [Type<TypedMetadata.Media>(), Type<TypedMetadata.CreativeWork>(), Type<TypedMetadata.Royalties>()])\n\t\tsharedContentCap.borrow()!.deposit(token: <- sharedNFT)\n\t\n\t\tlet cap = account.getCapability<&{TypedMetadata.ViewResolverCollection}>(Artifact.ArtifactPublicPath)\n\n\t\tcap.borrow()!.deposit(token: <- finLeases.mintNFTWithSharedData(name: name, nftName: \"Neo Motorcycle 1 of 3\", schemas: [ TypedMetadata.Editioned(edition:1, maxEdition: 3)], sharedPointer: sharedPointer))\n\t\tcap.borrow()!.deposit(token: <- finLeases.mintNFTWithSharedData(name: name, nftName: \"Neo Motorcycle 2 of 3\", schemas: [ TypedMetadata.Editioned(edition:2, maxEdition: 3)], sharedPointer: sharedPointer))\n\t\tcap.borrow()!.deposit(token: <- finLeases.mintNFTWithSharedData(name: name, nftName: \"Neo Motorcycle 3 of 3\", schemas: [ TypedMetadata.Editioned(edition:3, maxEdition: 3)], sharedPointer: sharedPointer))\n\n\t}\n}\n",
    "mintFlow": "\nimport FungibleToken from 0xFungibleToken\nimport FlowToken from 0xFlowToken\n\ntransaction(recipient: Address, amount: UFix64) {\n    let tokenAdmin: &FlowToken.Administrator\n    let tokenReceiver: &{FungibleToken.Receiver}\n\n    prepare(signer: AuthAccount) {\n\n        self.tokenAdmin = signer\n            .borrow<&FlowToken.Administrator>(from: /storage/flowTokenAdmin)\n            ?? panic(\"Signer is not the token admin\")\n\n        self.tokenReceiver = getAccount(recipient)\n            .getCapability(/public/flowTokenReceiver)\n            .borrow<&{FungibleToken.Receiver}>()\n            ?? panic(\"Unable to borrow receiver reference\")\n    }\n\n    execute {\n        let minter <- self.tokenAdmin.createNewMinter(allowedAmount: amount)\n        let mintedVault <- minter.mintTokens(amount: amount)\n\n        self.tokenReceiver.deposit(from: <-mintedVault)\n\n        destroy minter\n    }\n}\n",
    "mintFusd": "\n\nimport FungibleToken from 0xFungibleToken\nimport FUSD from 0xFUSD\n\ntransaction(recipient: Address, amount: UFix64) {\n\tlet tokenAdmin: &FUSD.Administrator\n\tlet tokenReceiver: &{FungibleToken.Receiver}\n\n\tprepare(signer: AuthAccount) {\n\n\t\tself.tokenAdmin = signer\n\t\t.borrow<&FUSD.Administrator>(from: /storage/fusdAdmin)\n\t\t?? panic(\"Signer is not the token admin\")\n\n\t\tself.tokenReceiver = getAccount(recipient)\n\t\t.getCapability(/public/fusdReceiver)\n\t\t.borrow<&{FungibleToken.Receiver}>()\n\t\t?? panic(\"Unable to borrow receiver reference\")\n\t}\n\n\texecute {\n\n\n\n\t\tlet minter <- self.tokenAdmin.createNewMinter()\n\t\tlet mintedVault <- minter.mintTokens(amount: amount)\n\n\t\tself.tokenReceiver.deposit(from: <-mintedVault)\n\n\t\tdestroy minter\n\t}\n}\n",
    "register": "import FungibleToken from 0xFungibleToken\nimport FUSD from 0xFUSD\nimport FlowToken from 0xFlowToken\nimport Profile from 0xProfile\nimport FIND from 0xFIND\nimport Artifact from 0xArtifact\nimport TypedMetadata from 0xTypedMetadata\n\ntransaction(name: String, amount: UFix64) {\n\tprepare(acct: AuthAccount) {\n\n\t\t//Add exising FUSD or create a new one and add it\n\t\tlet fusdReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/fusdReceiver)\n\t\tif !fusdReceiver.check() {\n\t\t\tlet fusd <- FUSD.createEmptyVault()\n\t\t\tacct.save(<- fusd, to: /storage/fusdVault)\n\t\t\tacct.link<&FUSD.Vault{FungibleToken.Receiver}>( /public/fusdReceiver, target: /storage/fusdVault)\n\t\t\tacct.link<&FUSD.Vault{FungibleToken.Balance}>( /public/fusdBalance, target: /storage/fusdVault)\n\t\t}\n\n\t\tlet leaseCollection = acct.getCapability<&FIND.LeaseCollection{FIND.LeaseCollectionPublic}>(FIND.LeasePublicPath)\n\t\tif !leaseCollection.check() {\n\t\t\tacct.unlink(FIND.LeasePublicPath)\n\t\t\tdestroy <- acct.load<@AnyResource>(from:FIND.LeaseStoragePath)\n\n\t\t\tacct.save(<- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n\t\t\tacct.link<&FIND.LeaseCollection{FIND.LeaseCollectionPublic}>( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n\n\t\t}\n\n\t\tlet artifactCollection = acct.getCapability<&{TypedMetadata.ViewResolverCollection}>(Artifact.ArtifactPublicPath)\n\t\tif !artifactCollection.check() {\n\t\t\tacct.unlink(Artifact.ArtifactPublicPath)\n\t\t\tdestroy <- acct.load<@AnyResource>(from:Artifact.ArtifactStoragePath)\n\n\t\t\tacct.save(<- Artifact.createEmptyCollection(), to: Artifact.ArtifactStoragePath)\n\t\t\tacct.link<&{TypedMetadata.ViewResolverCollection}>( Artifact.ArtifactPublicPath, target: Artifact.ArtifactStoragePath)\n\t\t}\n\n\t\tlet bidCollection = acct.getCapability<&FIND.BidCollection{FIND.BidCollectionPublic}>(FIND.BidPublicPath)\n\t\tif !bidCollection.check() {\n\t\t\tacct.unlink(FIND.BidPublicPath)\n\t\t\tdestroy <- acct.load<@AnyResource>(from:FIND.BidStoragePath)\n\n\t\t\tacct.save(<- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n\t\t\tacct.link<&FIND.BidCollection{FIND.BidCollectionPublic}>( FIND.BidPublicPath, target: FIND.BidStoragePath)\n\t\t}\n\n\t\tlet profileCap = acct.getCapability<&{Profile.Public}>(Profile.publicPath)\n\t\tif !profileCap.check() {\n\t\t\tacct.unlink(Profile.publicPath)\n\t\t\tdestroy <- acct.load<@AnyResource>(from:Profile.storagePath)\n\n\t\t\tlet profile <-Profile.createUser(name:name, description: \"\", allowStoringFollowers:true, tags:[\"find\"])\n\n\t\t\tlet fusdWallet=Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:acct.getCapability<&{FungibleToken.Balance}>(/public/fusdBalance), accept: Type<@FUSD.Vault>(), names: [\"fusd\", \"stablecoin\"])\n\n\t\t\tlet flowWallet=Profile.Wallet(\n\t\t\t\tname:\"Flow\", \n\t\t\t\treceiver:acct.getCapability<&{FungibleToken.Receiver}>(/public/flowTokenReceiver),\n\t\t\t\tbalance:acct.getCapability<&{FungibleToken.Balance}>(/public/flowTokenBalance),\n\t\t\t\taccept: Type<@FlowToken.Vault>(),\n\t\t\t\tnames: [\"flow\"]\n\t\t\t)\n\t\n\t\t\tprofile.addWallet(flowWallet)\n\t\t\tprofile.addWallet(fusdWallet)\n\t\t\tprofile.addCollection(Profile.ResourceCollection(name: \"artifacts\", collection: artifactCollection, type: Type<&{TypedMetadata.ViewResolverCollection}>(), tags: [\"artifact\", \"nft\"]))\n\t\t\tprofile.addCollection(Profile.ResourceCollection(\"FINDLeases\",leaseCollection, Type<&FIND.LeaseCollection{FIND.LeaseCollectionPublic}>(), [\"find\", \"leases\"]))\n\t\t\tprofile.addCollection(Profile.ResourceCollection(\"FINDBids\", bidCollection, Type<&FIND.BidCollection{FIND.BidCollectionPublic}>(), [\"find\", \"bids\"]))\n\n\t\t\tacct.save(<-profile, to: Profile.storagePath)\n\t\t\tacct.link<&Profile.User{Profile.Public}>(Profile.publicPath, target: Profile.storagePath)\n\t\t}\n\n\t\tlet price=FIND.calculateCost(name)\n\t\tif price != amount {\n\t\t\tpanic(\"Calculated cost does not match expected cost\")\n\t\t}\n\t\tlog(\"The cost for registering this name is \".concat(price.toString()))\n\n\t\tlet vaultRef = acct.borrow<&FUSD.Vault>(from: /storage/fusdVault) ?? panic(\"Could not borrow reference to the fusdVault!\")\n\n\t\tlet payVault <- vaultRef.withdraw(amount: price) as! @FUSD.Vault\n\n\t\tlet leases=acct.borrow<&FIND.LeaseCollection>(from: FIND.LeaseStoragePath)!\n\t\tleases.register(name: name, vault: <- payVault)\n\n\n\t}\n}\n",
    "registerAdmin": "\n\nimport FUSD from 0xFUSD\nimport FIND from 0xFIND\nimport Admin from 0xAdmin\nimport Profile from 0xProfile\nimport FungibleToken from 0xFungibleToken\n\ntransaction(name: String, user: Address) {\n\n\tprepare(account: AuthAccount) {\n\n\t\tlet userAccount=getAccount(user)\n\t\tlet profileCap = userAccount.getCapability<&{Profile.Public}>(Profile.publicPath)\n\t\tlet leaseCollectionCap=userAccount.getCapability<&FIND.LeaseCollection{FIND.LeaseCollectionPublic}>(FIND.LeasePublicPath)\n\n\t\tlet wallet=account.getCapability<&{FungibleToken.Receiver}>(/public/fusdReceiver)\n\t\tlet adminClient=account.borrow<&Admin.AdminProxy>(from: Admin.AdminProxyStoragePath)!\n\n\t\tlet vaultRef = account.borrow<&FUSD.Vault>(from: /storage/fusdVault) ?? panic(\"Could not borrow reference to the fusdVault!\")\n\t\t//TODO calculate sum\n\t\tlet payVault <- vaultRef.withdraw(amount: 5.0) as! @FUSD.Vault\n\n\t\tadminClient.register(name: name, vault: <- payVault, profile: profileCap, leases: leaseCollectionCap)\n\t}\n}\n\n",
    "rejectDirectOffer": "import FIND from 0xFIND\n\ntransaction(name: String) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet finLeases= account.borrow<&FIND.LeaseCollection>(from:FIND.LeaseStoragePath)!\n\t\tfinLeases.cancel(name)\n\n\t}\n}\n",
    "removeProfile": "import Profile from 0xProfile\nimport FIND from 0xFIND\n\ntransaction() {\n\tprepare(acct: AuthAccount) {\n\t\t\tacct.unlink(Profile.publicPath)\n\t\t\tdestroy <- acct.load<@AnyResource>(from:Profile.storagePath)\n\n\t\t\tacct.unlink(FIND.BidPublicPath)\n\t\t\tdestroy <- acct.load<@AnyResource>(from:FIND.BidStoragePath)\n\n\t\t\tacct.unlink(FIND.LeasePublicPath)\n\t\t\tdestroy <- acct.load<@AnyResource>(from:FIND.LeaseStoragePath)\n\t}\n}\n",
    "renew": "import FungibleToken from 0xFungibleToken\nimport FUSD from 0xFUSD\nimport Profile from 0xProfile\nimport FIND from 0xFIND\n\ntransaction(name: String, amount: UFix64) {\n\tprepare(acct: AuthAccount) {\n\n\t\tlet profileCap = acct.getCapability<&{Profile.Public}>(Profile.publicPath)\n\n\t\tlet price=FIND.calculateCost(name)\n\t\tif amount != price {\n\t\t\tpanic(\"expected renew cost is not the same as calculated renew cost\")\n\t\t}\n\t\tlet vaultRef = acct.borrow<&FUSD.Vault>(from: /storage/fusdVault) ?? panic(\"Could not borrow reference to the fusdVault!\")\n\t\tlet payVault <- vaultRef.withdraw(amount: price) as! @FUSD.Vault\n\n\t\tlet finLeases= acct.borrow<&FIND.LeaseCollection>(from:FIND.LeaseStoragePath)!\n\t\tlet finToken= finLeases.borrow(name)\n\t\tfinToken.extendLease(<- payVault)\n\t}\n}\n",
    "send": "import FUSD from 0xFUSD\nimport FIND from 0xFIND\n\ntransaction(name: String, amount: UFix64) {\n\n    prepare(account: AuthAccount) {\n        let vaultRef = account.borrow<&FUSD.Vault>(from: /storage/fusdVault) ?? panic(\"Could not borrow reference to the fusdVault!\")\n\n        log(\"Sending \".concat(amount.toString()).concat( \" to profile with name \").concat(name))\n        FIND.deposit(to: name, from: <- vaultRef.withdraw(amount: amount))\n    }\n\n}\n \n",
    "setup_fin_1_create_client": "\nimport \"../contracts/Admin.cdc\"\n\n//set up the adminClient in the contract that will own the network\ntransaction() {\n\n\tprepare(account: AuthAccount) {\n\n\t\tif account.getCapability(Admin.AdminProxyPublicPath).check<&AnyResource>() {\n\t\t\taccount.unlink(Admin.AdminProxyPublicPath)\n\t\t\tdestroy <- account.load<@AnyResource>(from: Admin.AdminProxyStoragePath)\n\t\t}\n\t\taccount.save(<- Admin.createAdminProxyClient(), to:Admin.AdminProxyStoragePath)\n\t\taccount.link<&{Admin.AdminProxyClient}>(Admin.AdminProxyPublicPath, target: Admin.AdminProxyStoragePath)\n\n\t}\n}\n",
    "setup_fin_2_register_client": "import \"../contracts/Admin.cdc\"\n\n\n//link together the administrator to the client, signed by the owner of the contract\ntransaction(ownerAddress: Address) {\n\n    //versus account\n    prepare(account: AuthAccount) {\n\n        let owner= getAccount(ownerAddress)\n        let client= owner.getCapability<&{Admin.AdminProxyClient}>(Admin.AdminProxyPublicPath)\n                .borrow() ?? panic(\"Could not borrow admin client\")\n\n        let network=account.getCapability<&FIND.Network>(FIND.NetworkPrivatePath)\n        client.addCapability(network)\n\n    }\n}\n \n",
    "setup_fin_3_create_network": "\nimport Admin from 0xAdmin\nimport FUSD from 0xFUSD\nimport FIND from 0xFIND\nimport Artifact from 0xArtifact\nimport TypedMetadata from 0xTypedMetadata\nimport FungibleToken from 0xFungibleToken\n\ntransaction() {\n\n\tprepare(account: AuthAccount) {\n\t\tlet wallet=account.getCapability<&{FungibleToken.Receiver}>(/public/fusdReceiver)\n\t\tif !wallet.check() {\n\t\t\tlet fusd <- FUSD.createEmptyVault()\n\t\t\taccount.save(<- fusd, to: /storage/fusdVault)\n\t\t\taccount.link<&FUSD.Vault{FungibleToken.Receiver}>( /public/fusdReceiver, target: /storage/fusdVault)\n\t\t\taccount.link<&FUSD.Vault{FungibleToken.Balance}>( /public/fusdBalance, target: /storage/fusdVault)\n\t\t}\n\n\t\tlet adminClient=account.borrow<&Admin.AdminProxy>(from: Admin.AdminProxyStoragePath)!\n\t\tadminClient.setWallet(wallet)\n\t\tadminClient.setPublicEnabled(true)\n\n\t\t/*\n\t\t//this is just an example\n\t\taccount.save(<- Artifact.createNewMinterTypeConverter(), to: /storage/artifactExampleTypeConverter)\n\t\taccount.link<&{TypedMetadata.TypeConverter}>(/public/artifactExampleTypeConverter, target: /storage/artifactExampleTypeConverter)\n\t\tlet cap=account.getCapability<&{TypedMetadata.TypeConverter}>(/public/artifactExampleTypeConverter)\n\t\tlet typ=Type<Artifact.MinterPlatform>()\n\t\tadminClient.setArtifactTypeConverter(from:typ, converters: [cap])\n\t\t*/\n\t}\n}\n\n",
    "startAuction": "import FIND from 0xFIND\n\ntransaction(name: String) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet finLeases= account.borrow<&FIND.LeaseCollection>(from:FIND.LeaseStoragePath)!\n\t\tfinLeases.startAuction(name)\n\n\t}\n}\n",
    "transferFusd": "// This transaction withdraws FUSD from the signer's account and deposits it into a recipient account. \n// This transaction will fail if the recipient does not have an FUSD receiver. \n// No funds are transferred or lost if the transaction fails.\n//\n// Parameters:\n// - amount: The amount of FUSD to transfer (e.g. 10.0)\n// - to: The recipient account address.\n//\n// This transaction will fail if either the sender or recipient does not have\n// an FUSD vault stored in their account. To check if an account has a vault\n// or initialize a new vault, use check_fusd_vault_setup.cdc and setup_fusd_vault.cdc\n// respectively.\n\nimport FungibleToken from 0xFungibleToken\nimport FUSD from 0xFUSD\n\ntransaction(amount: UFix64, to: Address) {\n\n    // The Vaut resource that holds the tokens that are being transferred\n    let sentVault: @FungibleToken.Vault\n\n    prepare(signer: AuthAccount) {\n        // Get a reference to the signer's stored vault\n        let vaultRef = signer.borrow<&FUSD.Vault>(from: /storage/fusdVault)\n            ?? panic(\"Could not borrow reference to the owner's Vault!\")\n\n        // Withdraw tokens from the signer's stored vault\n        self.sentVault <- vaultRef.withdraw(amount: amount)\n    }\n\n    execute {\n        // Get the recipient's public account object\n        let recipient = getAccount(to)\n\n        // Get a reference to the recipient's Receiver\n        let receiverRef = recipient.getCapability(/public/fusdReceiver)!.borrow<&{FungibleToken.Receiver}>()\n            ?? panic(\"Could not borrow receiver reference to the recipient's Vault\")\n\n        // Deposit the withdrawn tokens in the recipient's receiver\n        receiverRef.deposit(from: <-self.sentVault)\n    }\n}\n"
  },
  "scripts": {
    "address_status": "import FIND from 0xFIND\nimport Profile from 0xProfile\n\npub struct FINDReport{\n\tpub let profile:Profile.UserProfile?\n\tpub let bids: [FIND.BidInfo]\n\tpub let leases: [FIND.LeaseInformation]\n\n\tinit(profile: Profile.UserProfile?, bids: [FIND.BidInfo], leases : [FIND.LeaseInformation]) {\n\t\tself.profile=profile\n\t\tself.bids=bids\n\t\tself.leases=leases\n\t}\n}\n\n//Check the status of a fin user\npub fun main(user: Address) : FINDReport{\n\n\tlet account=getAccount(user)\n\tlet bidCap = account.getCapability<&FIND.BidCollection{FIND.BidCollectionPublic}>(FIND.BidPublicPath)\n\n\tlet leaseCap = account.getCapability<&FIND.LeaseCollection{FIND.LeaseCollectionPublic}>(FIND.LeasePublicPath)\n\n\treturn FINDReport(\n\t\tprofile: account.getCapability<&{Profile.Public}>(Profile.publicPath).borrow()?.asProfile(),\n\t\tbids: bidCap.borrow()?.getBids() ?? [],\n\t\tleases: leaseCap.borrow()?.getLeaseInformation() ?? []\n\t)\n\n}\n",
    "find-collection": "import Profile from 0xProfile\nimport TypedMetadata from 0xTypedMetadata\n\npub fun main(address: Address) : [String] {\n\n\tlet account=getAccount(address)\n\n\tlet profileCap= getAccount(address).getCapability<&{Profile.Public}>(Profile.publicPath)\n\n\tif !profileCap.check() {\n\t\treturn [\"Unknown, no profile created\"]\n\t}\n\n\tlet collections= profileCap.borrow()!.getCollections()\n\n\tvar names:  [String] = []\n\tfor col in collections {\n\t\tif col.type == Type<&{TypedMetadata.ViewResolverCollection}>() {\n\t\t\tnames.append(col.name)\n\t\t}\n\t}\n\treturn names\n\n}\n\n",
    "find-full": "import TypedMetadata from 0xTypedMetadata\nimport Profile from 0xProfile\n\n\npub fun main(address: Address) : {String : { UInt64 : { String : AnyStruct }}} {\n\n\tlet results : {String : { UInt64 : { String : AnyStruct }}}={}\n\n\tlet collections= getAccount(address).getCapability(Profile.publicPath)\n\t.borrow<&{Profile.Public}>()!\n\t.getCollections()\n\n\tfor col in collections {\n\t\tif col.type ==Type<&{TypedMetadata.ViewResolverCollection}>() {\n\t\t\tlet name=col.name\n\t\t\tlet collection : { UInt64 : { String : AnyStruct }}={}\n\t\t\tlet vrc= col.collection.borrow<&{TypedMetadata.ViewResolverCollection}>()!\n\t\t\tfor id in vrc.getIDs() {\n\t\t\t\tlet views : { String : AnyStruct }={}\n\t\t\t\tlet nft=vrc.borrowViewResolver(id: id)\n\t\t\t\tfor view in nft.getViews() {\n\t\t\t\t\tlet resolved=nft.resolveView(view)\n\t\t\t\t\tviews[view.identifier] = resolved\n\t\t\t\t}\n\t\t\t\tcollection[id]=views\n\t\t\t}\n\t\t\tresults[name]=collection\n\t\t}\n\t}\n\treturn results\n}\n\n\n\n\n\n",
    "find-ids-profile": "import Profile from 0xProfile\nimport TypedMetadata from 0xTypedMetadata\n\npub fun main(address: Address, path: String) : [UInt64] {\n\n\tlet account=getAccount(address)\n\n\tlet collections= getAccount(address)\n\t.getCapability(Profile.publicPath)\n\t.borrow<&{Profile.Public}>()!\n\t.getCollections()\n\n\tfor col in collections {\n\t\tif col.name == path && col.type == Type<&{TypedMetadata.ViewResolverCollection}>() {\n\t\t\tlet cap = col.collection.borrow<&{TypedMetadata.ViewResolverCollection}>()! as &{TypedMetadata.ViewResolverCollection}\n\t\t\treturn cap.getIDs()\n\t\t}\n\t}\n\treturn []\n}\n\n",
    "find-ids": "import NonFungibleToken from 0xNonFungibleToken\nimport TypedMetadata from 0xTypedMetadata\n\npub fun main(address: Address, path: PublicPath) : [UInt64] {\n\n\tlet account=getAccount(address)\n\treturn account.getCapability(path).borrow<&{TypedMetadata.ViewResolverCollection}>()!.getIDs()\n\n}\n\n",
    "find-list": "/*\n- collection\n - type\n - dictionary id ->\n  - name\n  - imageurl\n  - hash\n\t*/\n\nimport TypedMetadata from 0xTypedMetadata\nimport Profile from 0xProfile\n\n\npub struct MetadataCollection{\n\tpub let type: String\n\tpub let items: [MetadataCollectionItem]\n\n\tinit(type:String, items: [MetadataCollectionItem]) {\n\t\tself.type=type\n\t\tself.items=items\n\t}\n}\n\npub struct MetadataCollectionItem {\n\tpub let id:UInt64\n\tpub let name: String\n\tpub let url: String\n\tpub let ipfsHash: String\n\n\n\tinit(id:UInt64, name:String, url:String, ipfsHash:String) {\n\t\tself.id=id\n\t\tself.name=name\n\t\tself.url=url\n\t\tself.ipfsHash=ipfsHash\n\t}\n\n}\n\n\npub fun main(address: Address) : {String : MetadataCollection} {\n\n\tlet results : {String :  MetadataCollection}={}\n\n\tlet collections= getAccount(address).getCapability(Profile.publicPath).borrow<&{Profile.Public}>()!.getCollections()\n\n\tfor col in collections {\n\t\tif col.type ==Type<&{TypedMetadata.ViewResolverCollection}>() {\n\t\t\tlet name=col.name\n\t\t\tlet collection : { UInt64 : { String : AnyStruct }}={}\n\t\t\tlet vrc= col.collection.borrow<&{TypedMetadata.ViewResolverCollection}>()!\n\n\t\t\tlet items: [MetadataCollectionItem]=[]\n\t\t\tfor id in vrc.getIDs() {\n\t\t\t\tlet nft=vrc.borrowViewResolver(id: id)\n\t\t\t\tvar name=\"\"\n\t\t\t\tvar ipfsHash=\"\"\n\t\t\t\tvar url=\"\"\n\t\t\t\tfor view in nft.getViews() {\n\n\t\t\t\t\tif view == Type<String>() {\n\t\t\t\t\t  name= nft.resolveView(view) as! String\n\t\t\t\t\t}\n\n\t\t\t\t\tif view == Type<TypedMetadata.Media>() {\n\t\t\t\t\t\tlet resolve= nft.resolveView(view) \n\n\t\t\t\t\t\tlet media= resolve as! TypedMetadata.Media\n\n\t\t\t\t\t\tif media.protocol==\"http\" {\n\t\t\t\t\t\t\turl=media.data\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif media.protocol==\"ipfs\" {\n\t\t\t\t\t\t\tipfsHash=media.data\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\titems.append(MetadataCollectionItem(id:id, name:name,  url:url, ipfsHash:ipfsHash))\n\t\t\t}\n\t\t\tresults[name]= MetadataCollection(type: vrc.getType().identifier, items: items)\n\t\t}\n\t}\n\treturn results\n}\n\n\n\n\n\n",
    "find-schemes": "\n\nimport Profile from 0xProfile\nimport TypedMetadata from 0xTypedMetadata\n\npub fun main(address: Address, path: String, id:UInt64) : [String] {\n\n\tlet account=getAccount(address)\n\n\tlet collections= getAccount(address)\n\t.getCapability(Profile.publicPath)\n\t.borrow<&{Profile.Public}>()!\n\t.getCollections()\n\n\tfor col in collections {\n\t\tif col.name == path && col.type == Type<&{TypedMetadata.ViewResolverCollection}>() {\n\t\t\tlet cap = col.collection.borrow<&{TypedMetadata.ViewResolverCollection}>()! as &{TypedMetadata.ViewResolverCollection}\n\t\t\tlet nft=cap.borrowViewResolver(id: id)\n\t\t\tlet views=nft.getViews()\n\t\t\tvar viewIdentifiers : [String] = []\n\t\t\tfor v in views {\n\t\t\t\tviewIdentifiers.append(v.identifier)\n\t\t\t}\n\t\t\treturn viewIdentifiers\n\t\t}\n\t}\n\treturn []\n}\n\n",
    "find": "import TypedMetadata from 0xTypedMetadata\nimport Profile from 0xProfile\n\n\npub fun main(address: Address, path: String, id: UInt64, identifier: String) : AnyStruct? {\n\n\tlet collections= getAccount(address).getCapability(Profile.publicPath)\n\t.borrow<&{Profile.Public}>()!\n\t.getCollections()\n\n\tfor col in collections {\n\t\tif col.name == path && col.type == Type<&{TypedMetadata.ViewResolverCollection}>() {\n\t\t\tlet cap = col.collection.borrow<&{TypedMetadata.ViewResolverCollection}>()! as &{TypedMetadata.ViewResolverCollection}\n\t\t\tlet nft=cap.borrowViewResolver(id: id)\n\t\t\tfor v in nft.getViews() {\n\t\t\t\tif v.identifier== identifier {\n\t\t\t\t\treturn nft.resolveView(v)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}\n\n",
    "name_status": "import FIND from 0xFIND\nimport Profile from 0xProfile\n\npub struct FINDNameReport{\n\tpub let profile:Profile.UserProfile?\n\tpub let lease: FIND.LeaseInformation?\n\tpub let status: String\n\tpub let cost: UFix64\n\n\tinit(status: String, profile: Profile.UserProfile?, lease : FIND.LeaseInformation?,  cost: UFix64) {\n\t\tself.status=status\n\t\tself.profile=profile\n\t\tself.lease=lease\n\t\tself.cost=cost\n\t}\n}\n\n//Check the status of a fin user\npub fun main(name: String) : FINDNameReport{\n\n\tlet status=FIND.status(name)\n\tlet cost=FIND.calculateCost(name)\n\tif let address=status.owner {\n\t\tlet account=getAccount(address)\n\t\tlet leaseCap = account.getCapability<&FIND.LeaseCollection{FIND.LeaseCollectionPublic}>(FIND.LeasePublicPath)\n\n\t\tlet profile= account.getCapability<&{Profile.Public}>(Profile.publicPath).borrow()\n\t\tvar lease:FIND.LeaseInformation?=nil\n\t\tif leaseCap.check() {\n\t\t\tlease=leaseCap.borrow()!.getLease(name)\n\t\t}\n\t\treturn FINDNameReport(\n\t\t\tstatus: lease?.status ?? \"taken\",\n\t\t\tprofile: profile?.asProfile(),\n\t\t\tlease: lease,\n\t\t\tcost:  cost\n\t\t)\n\n\t}\n\n\tvar statusValue= \"FREE\"\n\tif  status.status == FIND.LeaseStatus.TAKEN {\n\t\tstatusValue=\"NO_PROFILE\"\n\t}\n\treturn FINDNameReport(\n\t\tstatus: statusValue,\n\t\tprofile: nil, \n\t\tlease: nil,\n\t\tcost: cost\n\t)\n\n}\n",
    "status": "import FIND from 0xFIND\nimport Profile from 0xProfile\n\n//Check the status of a fin user\npub fun main(name: String) :  &{Profile.Public}? {\n    return FIND.lookup(name)\n}\n"
  },
  "vars": {
    "emulator": {
      "0xNonFungibleToken": "0xf8d6e0586b0a20c7",
      "0xFUSD": "0xf8d6e0586b0a20c7",
      "0xFungibleToken": "0xee82856bf20e2aa6",
      "0xFlowToken": "0x0ae53cb6e3f42a79",
      "0xArtifact": "0xf8d6e0586b0a20c7",
      "0xFIND": "0xf8d6e0586b0a20c7",
      "0xAdmin": "0xf8d6e0586b0a20c7",
      "0xArt": "0xf8d6e0586b0a20c7",
      "0xContent": "0xf8d6e0586b0a20c7",
      "0xTypedMetadata": "0xf8d6e0586b0a20c7",
      "0xClock": "0xf8d6e0586b0a20c7",
      "0xProfile": "0xf8d6e0586b0a20c7",
      "0xDebug": "0xf8d6e0586b0a20c7",
      "0xMarket": "0xf8d6e0586b0a20c7"
    },
    "testnet": {
      "0xNonFungibleToken": "0x631e88ae7f1d7c20",
      "0xFUSD": "0xe223d8a629e49c68",
      "0xFungibleToken": "0x9a0766d93b6608b7",
      "0xFlowToken": "0x7e60df042a9c0868",
      "0xArtifact": null,
      "0xFIND": "0xaa7481821839f36d",
      "0xAdmin": "0xaa7481821839f36d",
      "0xArt": null,
      "0xContent": null,
      "0xTypedMetadata": null,
      "0xClock": "0xaa7481821839f36d",
      "0xProfile": "0x99ca04281098b33d",
      "0xDebug": "0xaa7481821839f36d",
      "0xMarket": null
    },
    "mainnet": {
      "0xNonFungibleToken": null,
      "0xFUSD": "0x3c5959b568896393",
      "0xFungibleToken": null,
      "0xFlowToken": "0x1654653399040a61",
      "0xArtifact": null,
      "0xFIND": null,
      "0xAdmin": null,
      "0xArt": null,
      "0xContent": null,
      "0xTypedMetadata": null,
      "0xClock": null,
      "0xProfile": "0xd796ff17107bbff6",
      "0xDebug": null,
      "0xMarket": null
    }
  }
}
