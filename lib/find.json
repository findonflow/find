{
   "networks": {
      "emulator": {
         "scripts": {
            "getCheckRoyalty": {
               "code": "import MetadataViews from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\nimport NFTRegistry from 0xf8d6e0586b0a20c7\n\npub fun main(name: String, id: UInt64, nftAliasOrIdentifier: String, viewIdentifier: String) : AnyStruct? {\n\n    let address =FIND.lookupAddress(name)!\n\n    // Get collection public path from NFT Registry\n    let nftInfo = NFTRegistry.getNFTInfo(nftAliasOrIdentifier) ?? panic(\"This NFT is not supported by the Find Market yet\")\n    let collectionPublicPath = nftInfo.publicPath\n    let collection= getAccount(address).getCapability(collectionPublicPath).borrow\u003c\u0026{MetadataViews.ResolverCollection}\u003e()!\n\n    let nft=collection.borrowViewResolver(id: id)\n    for v in nft.getViews() {\n        if v.identifier== viewIdentifier {\n            return nft.resolveView(v)\n        }\n    }\n    return nil\n}",
               "spec": {
                  "order": [
                     "name",
                     "id",
                     "nftAliasOrIdentifier",
                     "viewIdentifier"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "name": "String",
                     "nftAliasOrIdentifier": "String",
                     "viewIdentifier": "String"
                  }
               }
            },
            "getCollectionIndex": {
               "code": "import MetadataViews from 0xf8d6e0586b0a20c7\nimport NFTRegistry from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\n\npub fun main(user: String) : {String : [UInt64]} {\n    if let address = FIND.resolve(user) {\n        var resultMap : {String : [UInt64]} = {}\n        let account = getAccount(address)\n        for nftInfo in NFTRegistry.getNFTInfoAll().values {\n            let publicPath = nftInfo.publicPath\n            let alias = nftInfo.alias\n            let resolverCollectionCap= account.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(publicPath)\n            if resolverCollectionCap.check() {\n                let collection = resolverCollectionCap.borrow()!\n                resultMap[alias] = collection.getIDs()\n            }\n        }\n\n        return resultMap\n    }\n    return {}\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "getCollections": {
               "code": "import MetadataViews from 0xf8d6e0586b0a20c7\nimport NFTRegistry from 0xf8d6e0586b0a20c7\nimport FindViews from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\n\npub struct MetadataCollections {\n\n    pub let items: {String : MetadataCollectionItem}\n    pub let collections: {String : [String]}\n    // supports new contracts that supports metadataViews \n    pub let curatedCollections: {String : [String]}\n\n    init(items: {String : MetadataCollectionItem}, collections: {String : [String]}, curatedCollections: {String: [String]}) {\n        self.items=items\n        self.collections=collections\n        self.curatedCollections=curatedCollections\n    }\n}\n\n\npub struct MetadataCollection{\n    pub let type: String\n    pub let items: [MetadataCollectionItem]\n\n    init(type:String, items: [MetadataCollectionItem]) {\n        self.type=type\n        self.items=items\n    }\n}\n\n// Collection Index.cdc Address : [{Path, ID}]\n/* \n    pub struct CollectionItemPointer {\n        pub let path \n        pub let id \n    }\n */\n// Need : A metadata collection index : -\u003e path, id, collection (Where do you want to group them)\n// A list of these for all the items (Like collections and cur)\n\n// Resolve Partial Collection.cdc Address, {path : [IDs]}\n// Address\n// [path1 , path1, path2]\n// [id1 , id2, id3]\n// Another list -\u003e take these path, id, collection and return the specific collection information (similar in collections)\n\npub struct MetadataCollectionItem {\n    pub let id:UInt64\n    pub let typeIdentifier: String\n    pub let uuid: UInt64 \n    pub let name: String\n    pub let image: String\n    pub let url: String\n    pub let contentType:String\n    pub let rarity:String\n    //Refine later \n    pub let metadata: {String : String}\n    pub let collection: String // \u003c- This will be Alias unless they want something else\n    pub let tag: {String : String}\n    pub let scalar: {String : UFix64}\n\n    init(id:UInt64, type: Type, uuid: UInt64, name:String, image:String, url:String, contentType: String, rarity: String, collection: String, tag: {String : String}, scalar: {String : UFix64}) {\n        self.id=id\n        self.typeIdentifier = type.identifier\n        self.uuid = uuid\n        self.name=name\n        self.url=url\n        self.image=image\n        self.contentType=contentType\n        self.rarity=rarity\n        self.metadata={}\n        self.collection=collection\n        self.tag=tag\n        self.scalar=scalar\n    }\n}\n\npub fun main(user: String) : MetadataCollections? {\n\n    let resolvingAddress = FIND.resolve(user)\n    if resolvingAddress == nil {\n        return nil\n    }\n    let address = resolvingAddress!\n    var resultMap : {String : MetadataCollectionItem} = {}\n    let account = getAccount(address)\n    let results : {String :  [String]}={}\n\n    for nftInfo in NFTRegistry.getNFTInfoAll().values {\n        let items: [String] = []\n        let resolverCollectionCap= account.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(nftInfo.publicPath)\n        if resolverCollectionCap.check() {\n            let collection = resolverCollectionCap.borrow()!\n            for id in collection.getIDs() {\n                let nft = collection.borrowViewResolver(id: id) \n                \n                if let display= FindViews.getDisplay(nft) {\n                    var externalUrl=nftInfo.externalFixedUrl\n\n                    if let externalUrlViw=FindViews.getExternalURL(nft) { \n                        externalUrl=externalUrlViw.url\n                    }\n\n                    var rarity=\"\"\n                    if let r = FindViews.getRarity(nft) {\n                        rarity=r.rarityName\n                    }\n\n                    var tag : {String : String}={}\n                    if let t= FindViews.getTags(nft) {\n                        tag=t.getTag()\n                    }            \n\n                    var scalar : {String : UFix64}={}\n                    if let s= FindViews.getScalar(nft) {\n                        scalar=s.getScalar()\n                    }                \n\n                    let item = MetadataCollectionItem(\n                        id: id,\n                        type: nft.getType() ,\n                        uuid: nft.uuid ,\n                        name: display.name,\n                        image: display.thumbnail.uri(),\n                        url: externalUrl,\n                        contentType: \"image\",\n                        rarity: rarity,\n                        collection: nftInfo.alias,\n                        tag: tag,\n                        scalar: scalar\n                    )\n                    let itemId = nftInfo.alias.concat(item.id.toString())\n                    items.append(itemId)\n                    resultMap.insert(key:itemId, item)\n                }\n            }\n            results[nftInfo.alias] = items\n        }\n    }\n\n    let publicPath=/public/FindCuratedCollections\n    let link = account.getCapability\u003c\u0026{String: [String]}\u003e(publicPath)\n    var curatedCollections : {String: [String]} = {}\n    if link.check() {\n        let curated = link.borrow()!\n        for curatedKey in curated.keys {\n            curatedCollections[curatedKey] = curated[curatedKey]!\n        }\n    }\n\n    return MetadataCollections(items: resultMap, collections:results, curatedCollections: curatedCollections)\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "getCuratedCollections": {
               "code": "pub fun main(address: Address) : \u0026{String: [String]}? {\n    let account=getAccount(address)\n    let publicPath=/public/FindCuratedCollections\n    let link = account.getCapability\u003c\u0026{String: [String]}\u003e(publicPath)\n    if link.check() {\n        return link.borrow()\n    }\n    return nil\n}",
               "spec": {
                  "order": [
                     "address"
                  ],
                  "parameters": {
                     "address": "Address"
                  }
               }
            },
            "getDandiesIDsFor": {
               "code": "import Dandy from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\n\npub fun main(user: String, minter: String) : [UInt64] {\n    let address = FIND.resolve(user)\n    if address == nil {\n        return []\n    }\n    let account = getAccount(address!)\n    let cap = account.getCapability\u003c\u0026Dandy.Collection{Dandy.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n    let ref = cap.borrow() ?? panic(\"Cannot borrow reference to Dandy Collection\")\n\n    return ref.getIDsFor(minter: minter)\n}",
               "spec": {
                  "order": [
                     "user",
                     "minter"
                  ],
                  "parameters": {
                     "minter": "String",
                     "user": "String"
                  }
               }
            },
            "getDandiesMinters": {
               "code": "import Dandy from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\n\npub fun main(user: String) : [String] {\n    let address = FIND.resolve(user)\n    if address == nil {\n        return []\n    }\n    let account = getAccount(address!)\n    let cap = account.getCapability\u003c\u0026Dandy.Collection{Dandy.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n    let ref = cap.borrow() ?? panic(\"Cannot borrow reference to Dandy Collection\")\n\n    return ref.getMinters()\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "getFTInfo": {
               "code": "import FTRegistry from 0xf8d6e0586b0a20c7\n\npub fun main(aliasOrIdentifier: String) : FTRegistry.FTInfo?{\n\n    return FTRegistry.getFTInfo(aliasOrIdentifier)\n\n}",
               "spec": {
                  "order": [
                     "aliasOrIdentifier"
                  ],
                  "parameters": {
                     "aliasOrIdentifier": "String"
                  }
               }
            },
            "getFTInfoAll": {
               "code": "import FTRegistry from 0xf8d6e0586b0a20c7\n\npub fun main() : {String: FTRegistry.FTInfo}{\n\n    return FTRegistry.getFTInfoAll()\n\n}",
               "spec": null
            },
            "getItem": {
               "code": "import MetadataViews from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\nimport NFTRegistry from 0xf8d6e0586b0a20c7\n\npub struct MetadataCollectionItem {\n    pub let id:UInt64\n    pub let uuid:UInt64\n    pub let name: String\n    pub let description: String?\n    pub let image: String\n    pub let url: String\n    pub let contentType:String\n    pub let rarity:String\n    pub let minter:String?\n    pub let type:Type\n\n\n    init(id:UInt64, uuid:UInt64, name:String, description:String?, image:String, url:String, contentType: String, rarity: String, minter:String?, type:Type) {\n        self.id=id\n        self.uuid=uuid\n        self.name=name\n        self.description=description\n        self.minter=minter\n        self.url=url\n        self.type=type\n        self.image=image\n        self.contentType=contentType\n        self.rarity=rarity\n    }\n}\n\n\npub fun main(user: String, aliasOrIdentifier: String, id:UInt64) : MetadataCollectionItem?{\n\n    let nftInfo = NFTRegistry.getNFTInfo(aliasOrIdentifier) \n    if nftInfo == nil {panic(\"This NFT is not registered in registry. input: \".concat(aliasOrIdentifier))}\n\n    let resolveAddress = FIND.resolve(user) \n    if resolveAddress == nil {return nil}\n    let address = resolveAddress!\n    let account=getAccount(address)\n    let resolverCollectionCap= account.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(nftInfo!.publicPath)\n    if !resolverCollectionCap.check() {\n        return nil\n    }\n\n    let collection = resolverCollectionCap.borrow()!\n    let nft = collection.borrowViewResolver(id: id)!\n\n    if let displayView = nft.resolveView(Type\u003cMetadataViews.Display\u003e()) {\n        let display = displayView as! MetadataViews.Display\n\n        var externalUrl=\"\"\n        if let externalUrlView = nft.resolveView(Type\u003cMetadataViews.ExternalURL\u003e()) {\n            let edvu= externalUrlView as! MetadataViews.ExternalURL\n            externalUrl=edvu.url\n        }\n        let item = MetadataCollectionItem(\n            id: id,\n            uuid: nft.uuid,\n            name: display.name,\n            description:display.description,\n            image: display.thumbnail.uri(),\n            url: externalUrl,\n            contentType: \"image\",\n            rarity: \"\",\n            minter: \"\",\n            type: nft.getType()\n        )\n        return item\n    }\n    return nil\n}",
               "spec": {
                  "order": [
                     "user",
                     "aliasOrIdentifier",
                     "id"
                  ],
                  "parameters": {
                     "aliasOrIdentifier": "String",
                     "id": "UInt64",
                     "user": "String"
                  }
               }
            },
            "getListings": {
               "code": "import FindMarket from 0xf8d6e0586b0a20c7 \nimport FIND from 0xf8d6e0586b0a20c7 \n\npub fun main(marketplace:Address, user: String) : {String : FindMarket.SaleItemCollectionReport} {\n    let resolveAddress = FIND.resolve(user)\n    if resolveAddress == nil { return {}}\n    let address = resolveAddress!\n        return FindMarket.getSaleItemReport(tenant:marketplace, address: address, getNFTInfo:false)\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "user"
                  ],
                  "parameters": {
                     "marketplace": "Address",
                     "user": "String"
                  }
               }
            },
            "getMarketBlockedNFT": {
               "code": "import FindMarket from 0xf8d6e0586b0a20c7 \n\npub fun main() : {String : [String] } {\n    let mapping : {String : [String] } = {}\n\n    let findAddress=FindMarket.getFindTenantAddress()\n    let tenantCap = FindMarket.getTenantCapability(findAddress)!\n    let tenantRef = tenantCap.borrow() ?? panic(\"This tenant is not set up.\")\n    let marketTypes = FindMarket.getSaleItemTypes()\n    for marketType in marketTypes {\n        let list : [String] = []\n        for type in tenantRef.getBlockedNFT(marketType: marketType) {\n            list.append(type.identifier)\n        }\n        mapping[FindMarket.getMarketOptionFromType(marketType)] = list\n    }\n\nreturn mapping\n}",
               "spec": null
            },
            "getNFTDetails": {
               "code": "import FindMarket from 0xf8d6e0586b0a20c7 \nimport FindViews from 0xf8d6e0586b0a20c7 \nimport FIND from 0xf8d6e0586b0a20c7 \nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport NFTStorefront from 0xf8d6e0586b0a20c7\nimport NFTRegistry from 0xf8d6e0586b0a20c7\nimport FTRegistry from 0xf8d6e0586b0a20c7\n\npub struct NFTDetailReport {\n    pub let findMarket: {String : FindMarket.SaleItemInformation}\n    pub let storefront: StorefrontListing?\n    pub let nftDetail: NFTDetail?\n    pub let allowedListingActions: {String : ListingTypeReport}\n\n    init(findMarket:{String : FindMarket.SaleItemInformation}, storefront: StorefrontListing?, nftDetail: NFTDetail?, allowedListingActions: {String : ListingTypeReport}) {\n        self.findMarket=findMarket\n        self.storefront=storefront\n        self.nftDetail=nftDetail\n        self.allowedListingActions=allowedListingActions\n    }\n}\n\npub struct ListingTypeReport {\n    pub let listingType: String \n    pub let ftAlias: [String] \n    pub let ftIdentifiers: [String] \n    pub let status: String \n\n    init(listingType: String, ftAlias: [String], ftIdentifiers: [String],  status: String ) {\n        self.listingType=listingType \n        self.ftAlias=ftAlias \n        self.ftIdentifiers=ftIdentifiers \n        self.status=status\n    }\n}\n\npub struct NFTDetail {\n    pub let id: UInt64 \n    pub let uuid: UInt64 \n    pub let name:String\n    pub let thumbnail:String\n    pub let type: String\n    pub var rarity:String?\n    pub var royalties: [Royalties]\n    pub var editionNumber: UInt64? \n    pub var totalInEdition: UInt64?\n    pub var scalars : {String: UFix64}\n    pub var tags : {String: String}\n    pub var media: [MetadataViews.Media]\n    pub var collectionName: String? \n    pub var collectionDescription: String? \n    pub var data: {String : AnyStruct?}\n    pub var views :[String]\n\n    init(_ pointer: FindViews.ViewReadPointer, views: {String : AnyStruct}){\n\n        let item = pointer.getViewResolver()\n\n        self.scalars={}\n        self.tags={}\n        self.media=[]\n        self.collectionName=nil\n        self.collectionDescription=nil\n\n        if let grouping=FindViews.getNFTCollectionDisplay(item) {\n            self.collectionName=grouping.name\n            self.collectionDescription=grouping.description\n        }\n\n        /* Rarity */\n        self.rarity=nil\n        if let r = FindViews.getRarity(item) {\n          self.rarity=r.rarityName\n        }\n\n\n        if let t= FindViews.getTags(item) {\n            self.tags=t.getTag()\n        }            \n\n        if let scalar=FindViews.getScalar(item){\n                self.scalars=scalar.getScalar()\n        }\n        /* Medias */\n        let mediaView=item.resolveView(Type\u003cFindViews.Medias\u003e())\n        if mediaView != nil {\n            let view = mediaView!\n            if view as? FindViews.Medias != nil {\n                let media = view as! FindViews.Medias\n                self.media=media.items\n            }\n        }\n    \n\n        let display = FindViews.getDisplay(item) ?? panic(\"Could not find display\")\n        self.name=display.name\n        self.thumbnail=display.thumbnail.uri()\n        self.type=item.getType().identifier\n        self.id=pointer.id\n        self.uuid=pointer.getUUID()\n\n        /* Edition */\n        self.editionNumber=nil\n        self.totalInEdition=nil\n            if let editions = FindViews.getEditions(item) {\n                for edition in editions.infoList {\n                    if edition.name == nil {\n                        self.editionNumber=edition.number\n                        self.totalInEdition=edition.max\n                    } else {\n                        self.scalars[\"edition_\".concat(edition.name!).concat(\"_number\")] = UFix64(edition.number)\n                        if edition.max != nil {\n                            self.scalars[\"edition_\".concat(edition.name!).concat(\"_max\")] = UFix64(edition.max!)\n                        }\n                    }\n                }\n            }\n\n        /* Royalties */\n        self.royalties=resolveRoyalties(pointer)\n        self.data=views\n\n        self.views=[]\n        for view in item.getViews() {\n            if ignoreViews().contains(view) {\n                continue\n            }\n            self.views.append(view.identifier)\n        }\n    }\n\n}\n\npub struct StoreFrontCut {\n\n    pub let amount:UFix64\n    pub let address: Address\n    pub let findName:String?\n\n    init(amount:UFix64, address:Address){\n        self.amount=amount\n        self.address=address\n        self.findName= FIND.reverseLookup(address)\n    }\n}\n\npub struct Royalties {\n\n    pub let royaltyName: String \n    pub let address: Address \n    pub let findName: String? \n    pub let cut: UFix64 \n\n    init(royaltyName: String , address: Address, findName: String?, cut: UFix64) {\n        self.royaltyName=royaltyName \n        self.address=address \n        self.findName=findName \n        self.cut=cut\n    }\n}\n\npub struct StorefrontListing {\n    pub let nftID:UInt64\n    pub let nftIdentifier: String\n    pub let saleCut: [StoreFrontCut]\n    pub let amount:UFix64\n    pub let ftTypeIdentifier:String\n    pub let storefront:UInt64\n    pub let listingID:UInt64\n\n    init(listingId:UInt64, details: NFTStorefront.ListingDetails) {\n\n        self.saleCut=[]\n        self.nftID=details.nftID\n        self.nftIdentifier=details.nftType.identifier\n        for cutDetails in details.saleCuts {\n            self.saleCut.append(StoreFrontCut(amount:cutDetails.amount, address:cutDetails.receiver.address))\n        }\n        self.amount=details.salePrice\n        self.ftTypeIdentifier=details.salePaymentVaultType.identifier\n        self.storefront=details.storefrontID\n        self.listingID=listingId\n    }\n}\n\npub fun main(user: String, nftAliasOrIdentifier:String, id: UInt64, views: [String]) : NFTDetailReport?{\n    let resolveAddress = FIND.resolve(user) \n    if resolveAddress == nil {\n        return nil\n    }\n    let address = resolveAddress!\n\n    let account = getAccount(address) \n    let publicPath = NFTRegistry.getNFTInfo(nftAliasOrIdentifier)?.publicPath ?? panic(\"This NFT is not supported by NFT Registry\")\n    let cap = account.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(publicPath)\n    let pointer = FindViews.ViewReadPointer(cap: cap, id: id)\n\n    let nftDetail = getNFTDetail(pointer:pointer, views: views)\n    if nftDetail == nil {\n        return nil\n    }\n\n\n    let findAddress=FindMarket.getFindTenantAddress()\n    let findMarket=FindMarket.getNFTListing(tenant:findAddress, address: address, id: nftDetail!.uuid, getNFTInfo:false)\n\n    var listings : StorefrontListing? = nil\n    let storefrontCap = account.getCapability\u003c\u0026NFTStorefront.Storefront{NFTStorefront.StorefrontPublic}\u003e(NFTStorefront.StorefrontPublicPath)\n\n    if storefrontCap.check() {\n        let storefrontRef=storefrontCap.borrow()!\n        for listingId in storefrontRef.getListingIDs() {\n            let listing = storefrontRef.borrowListing(listingResourceID: listingId)!\n            let nft=listing.borrowNFT()\n            if nft.id==id \u0026\u0026 !listing.getDetails().purchased {\n                listings = StorefrontListing(listingId: listingId, details: listing.getDetails())\n            }\n        }\n    }\n\n    let tenantCap = FindMarket.getTenantCapability(findAddress)!\n    let tenantRef = tenantCap.borrow() ?? panic(\"This tenant is not set up.\")\n\n    let marketTypes = FindMarket.getSaleItemTypes()\n    var report : {String : ListingTypeReport} = {}\n    for marketType in marketTypes {\n        if let allowedListing = tenantRef.getAllowedListings(nftType: pointer.getItemType(), marketType: marketType) {\n            report[FindMarket.getMarketOptionFromType(marketType)] = createListingTypeReport(allowedListing)\n        }\n    }\n\n    return NFTDetailReport(findMarket:findMarket, storefront: listings, nftDetail: nftDetail, allowedListingActions: report)\n\n}\n\npub fun getNFTDetail(pointer: FindViews.ViewReadPointer, views: [String]) : NFTDetail? {\n\n    if !pointer.valid() {\n        return nil\n    }\n\n    let viewTypes = pointer.getViews() \n    var nftViews: {String : AnyStruct} = {}\n    for viewType in viewTypes {\n        if views.contains(getType(viewType)) {\n            if let view = pointer.resolveView(viewType) {\n                nftViews[getType(viewType)] = view! \n            }\n        }\n    }\n    return NFTDetail(pointer, views: nftViews)\n\n\n}\n\n/* Helper Function */\npub fun getType(_ type: Type) : String {\n    let identifier = type.identifier\n    var dots = 0\n    var counter = 0 \n    while counter \u003c identifier.length {\n        if identifier[counter] == \".\" {\n            dots = dots + 1\n            if dots == 3 {\n                break\n            }\n        }\n        counter = counter + 1\n    }\n    if dots == 0 {\n        return identifier\n    }\n    if counter + 1 \u003e identifier.length {\n        panic(\"Identifier is \".concat(identifier))\n    }\n    return identifier.slice(from: counter + 1, upTo: identifier.length)\n}\n\npub fun resolveRoyalties(_ pointer: FindViews.ViewReadPointer) : [Royalties] {\n    let array : [Royalties] = []\n    for royalty in pointer.getRoyalty().getRoyalties() {\n        let address = royalty.receiver.address\n        array.append(Royalties(royaltyName: royalty.description, address: address, findName: FIND.reverseLookup(address), cut: royalty.cut))\n    }\n\n    return array\n}\n\npub fun createListingTypeReport(_ allowedListing: FindMarket.AllowedListing) : ListingTypeReport {\n    let listingType = allowedListing.listingType.identifier\n    var ftAlias : [String] = []\n    var ftIdentifier : [String] = []\n    for ft in allowedListing.ftTypes {\n        ftIdentifier.append(ft.identifier)\n        if let ftInfo = FTRegistry.getFTInfo(ft.identifier) {\n            ftAlias.append(ftInfo.alias)\n        }\n    }\n    return ListingTypeReport(listingType: listingType, ftAlias: ftAlias, ftIdentifiers: ftIdentifier,  status: allowedListing.status )\n}\n\npub fun ignoreViews() : [Type] {\n    return [\n        Type\u003cMetadataViews.NFTCollectionDisplay\u003e() , \n        Type\u003cFindViews.Rarity\u003e() ,\n        Type\u003cFindViews.Tag\u003e() , \n        Type\u003cFindViews.Scalar\u003e() ,\n        Type\u003cFindViews.Medias\u003e() ,\n        Type\u003cMetadataViews.Display\u003e() ,\n        Type\u003cMetadataViews.Edition\u003e() ,\n        Type\u003cMetadataViews.Editions\u003e() \n    ]\n}",
               "spec": {
                  "order": [
                     "user",
                     "nftAliasOrIdentifier",
                     "id",
                     "views"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "nftAliasOrIdentifier": "String",
                     "user": "String",
                     "views": "[String]"
                  }
               }
            },
            "getNFTInfo": {
               "code": "import NFTRegistry from 0xf8d6e0586b0a20c7\n\npub fun main(aliasOrIdentifier: String) : NFTRegistry.NFTInfo? {\n\n    return NFTRegistry.getNFTInfo(aliasOrIdentifier)\n\n}",
               "spec": {
                  "order": [
                     "aliasOrIdentifier"
                  ],
                  "parameters": {
                     "aliasOrIdentifier": "String"
                  }
               }
            },
            "getNFTInfoAll": {
               "code": "import NFTRegistry from 0xf8d6e0586b0a20c7\n\npub fun main() : {String: NFTRegistry.NFTInfo}{\n\n    return NFTRegistry.getNFTInfoAll()\n\n}",
               "spec": null
            },
            "getNFTView": {
               "code": "import MetadataViews from 0xf8d6e0586b0a20c7\nimport NFTRegistry from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\n\n//Fetch a single view from a nft on a given path\npub fun main(user: String, aliasOrIdentifier:String, id: UInt64, identifier: String) : AnyStruct? {\n\n    let nftInfo = NFTRegistry.getNFTInfo(aliasOrIdentifier) \n    if nftInfo == nil {panic(\"This NFT is not registered in registry. input: \".concat(aliasOrIdentifier))}\n    let resolveAddress = FIND.resolve(user) \n    if resolveAddress == nil {return []}\n    let address = resolveAddress!\n\n    let pp = nftInfo!.publicPath\n    let collection= getAccount(address).getCapability(pp).borrow\u003c\u0026{MetadataViews.ResolverCollection}\u003e()!\n\n    let nft=collection.borrowViewResolver(id: id)\n    for v in nft.getViews() {\n        if v.identifier== identifier {\n            return nft.resolveView(v)\n        }\n    }\n    return nil\n}",
               "spec": {
                  "order": [
                     "user",
                     "aliasOrIdentifier",
                     "id",
                     "identifier"
                  ],
                  "parameters": {
                     "aliasOrIdentifier": "String",
                     "id": "UInt64",
                     "identifier": "String",
                     "user": "String"
                  }
               }
            },
            "getNFTViews": {
               "code": "import MetadataViews from 0xf8d6e0586b0a20c7\nimport NFTRegistry from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\n\n//get all the views for an nft and address/path/id\npub fun main(user: String, aliasOrIdentifier:String, id: UInt64) : [String] {\n    let nftInfo = NFTRegistry.getNFTInfo(aliasOrIdentifier) \n    if nftInfo == nil {panic(\"This NFT is not registered in registry. input: \".concat(aliasOrIdentifier))}\n\n    let resolveAddress = FIND.resolve(user) \n    if resolveAddress == nil {return []}\n    let address = resolveAddress!\n    let pp = nftInfo!.publicPath\n    let collection= getAccount(address).getCapability(pp).borrow\u003c\u0026{MetadataViews.ResolverCollection}\u003e()!\n    let nft=collection.borrowViewResolver(id: id)\n    let views:[String]=[]\n    for v in nft.getViews() {\n        views.append(v.identifier)\n    }\n    return views\n}",
               "spec": {
                  "order": [
                     "user",
                     "aliasOrIdentifier",
                     "id"
                  ],
                  "parameters": {
                     "aliasOrIdentifier": "String",
                     "id": "UInt64",
                     "user": "String"
                  }
               }
            },
            "getName": {
               "code": "import FIND from 0xf8d6e0586b0a20c7\n\npub fun main(address: Address) : String?{\n    return FIND.reverseLookup(address)\n}",
               "spec": {
                  "order": [
                     "address"
                  ],
                  "parameters": {
                     "address": "Address"
                  }
               }
            },
            "getNameDetails": {
               "code": "import FIND from 0xf8d6e0586b0a20c7\nimport Profile from 0xf8d6e0586b0a20c7\nimport RelatedAccounts from 0xf8d6e0586b0a20c7\n\npub struct FINDReport {\n    pub let profile:Profile.UserReport?\n    pub let bids: [FIND.BidInfo]\n    pub let relatedAccounts: { String: Address}\n    pub let leases: [FIND.LeaseInformation]\n    pub let privateMode: Bool\n\n\n    init(profile: Profile.UserReport?, relatedAccounts: {String: Address}, bids: [FIND.BidInfo], leases : [FIND.LeaseInformation], privateMode: Bool ) {\n        self.profile=profile\n        self.bids=bids\n        self.leases=leases\n        self.relatedAccounts=relatedAccounts\n        self.privateMode=privateMode\n    }\n}\n\npub struct NameReport {\n    pub let status: String\n    pub let cost: UFix64 \n    pub let leaseStatus: FIND.LeaseInformation?\n    pub let userReport: FINDReport? \n\n    init(status: String, cost: UFix64, leaseStatus: FIND.LeaseInformation?, userReport: FINDReport? ) {\n        self.status=status \n        self.cost=cost \n        self.leaseStatus=leaseStatus\n        self.userReport=userReport\n    }\n}\n\npub fun main(user: String) : NameReport? {\n\n    var findReport: FINDReport? = nil\n    var nameLease: FIND.LeaseInformation? = nil\n    if let address=FIND.resolve(user) {\n        let account=getAccount(address)\n        let bidCap = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        let leaseCap = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        let profile=account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath).borrow()\n\n        findReport = FINDReport(\n            profile: profile?.asReport(),\n            relatedAccounts: RelatedAccounts.findRelatedFlowAccounts(address:address),\n            bids: bidCap.borrow()?.getBids() ?? [],\n            leases: leaseCap.borrow()?.getLeaseInformation() ?? [],\n            privateMode: profile?.isPrivateModeEnabled() ?? false\n        )\n        if FIND.validateFindName(user) \u0026\u0026 findReport != nil {\n            for lease in findReport!.leases {\n                if lease.name == user {\n                    nameLease = lease\n                    break\n                }\n            }\n        }\n        \n    }\n\n    var nameReport : NameReport? = nil \n    if FIND.validateFindName(user) {\n        let status = FIND.status(user)\n        let cost=FIND.calculateCost(user)\n        var s=\"TAKEN\"    \n        if status.status == FIND.LeaseStatus.FREE {\n            s=\"FREE\"\n        } else if status.status == FIND.LeaseStatus.LOCKED {\n            s=\"LOCKED\"\n        }\n        nameReport = NameReport(status: s, cost: cost, leaseStatus: nameLease, userReport: findReport)\n    }\n    \n\n    return nameReport\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "getNameStatus": {
               "code": "import FIND from 0xf8d6e0586b0a20c7\nimport Profile from 0xf8d6e0586b0a20c7\n\npub fun main(name: String) :  \u0026{Profile.Public}? {\n    return FIND.lookup(name)\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "getNames": {
               "code": "import FIND from 0xf8d6e0586b0a20c7\n\npub fun main(address: [Address]) : { Address:String}{\n\n    let items : {Address:String} = {}\n    for a in address {\n        if let name= FIND.reverseLookup(a) {\n            items[a]=name\n        }\n    }\n    return items\n}",
               "spec": {
                  "order": [
                     "address"
                  ],
                  "parameters": {
                     "address": "[Address]"
                  }
               }
            },
            "getNamesWithBids": {
               "code": "import FIND from 0xf8d6e0586b0a20c7\n\npub fun main(user: String) : [FIND.LeaseInformation] {\n\n    let resolveAddress = FIND.resolve(user) \n    if resolveAddress == nil {return []}\n    let address = resolveAddress!\n    let account=getAccount(address)\n    let leaseCap = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\n    let leases=leaseCap.borrow()?.getLeaseInformation() ?? []\n\n    var leasesWithBids :[FIND.LeaseInformation] =[]\n    for lease in leases {\n        if lease.latestBidBy != nil {\n            leasesWithBids.append(lease)\n        }\n    }\n\n    return leasesWithBids\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "getNamesWithoutBids": {
               "code": "import FIND from 0xf8d6e0586b0a20c7\n\n\npub fun main(user: String) : [String] {\n\n    let resolveAddress = FIND.resolve(user) \n    if resolveAddress == nil {return []}\n    let address = resolveAddress!\n    let account=getAccount(address)\n    let leaseCap = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\n    let leases=leaseCap.borrow()?.getLeaseInformation() ?? []\n\n    var leasesWithBids :[String] =[]\n    for lease in leases {\n        if lease.latestBidBy == nil {\n            leasesWithBids.append(lease.name)\n        }\n    }\n\n    return leasesWithBids\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "getProfile": {
               "code": "import Profile from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\n\npub fun main(user: String) :  Profile.UserReport? {\n    let resolveAddress = FIND.resolve(user) \n    if resolveAddress == nil {return nil}\n    let address = resolveAddress!\n\n    return getAccount(address)\n        .getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        .borrow()?.asReport()\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "getStatus": {
               "code": "import FIND from 0xf8d6e0586b0a20c7\nimport Profile from 0xf8d6e0586b0a20c7\nimport RelatedAccounts from 0xf8d6e0586b0a20c7\nimport FindMarket from 0xf8d6e0586b0a20c7\n\npub struct FINDReport{\n    pub let profile:Profile.UserReport?\n    pub let bids: [FIND.BidInfo]\n    pub let relatedAccounts: { String: Address}\n    pub let leases: [FIND.LeaseInformation]\n    pub let privateMode: Bool\n    pub let itemsForSale: {String : FindMarket.SaleItemCollectionReport}\n    pub let marketBids: {String : FindMarket.BidItemCollectionReport}\n\n\n    init(profile: Profile.UserReport?, relatedAccounts: {String: Address}, bids: [FIND.BidInfo], leases : [FIND.LeaseInformation], privateMode: Bool, itemsForSale: {String : FindMarket.SaleItemCollectionReport}, marketBids: {String : FindMarket.BidItemCollectionReport}) {\n        self.profile=profile\n        self.bids=bids\n        self.leases=leases\n        self.relatedAccounts=relatedAccounts\n        self.privateMode=privateMode\n        self.itemsForSale=itemsForSale\n        self.marketBids=marketBids\n    }\n}\n\npub struct NameReport {\n    pub let status: String \n    pub let cost: UFix64 \n\n    init(status: String, cost: UFix64) {\n        self.status=status \n        self.cost=cost\n    }\n}\n\npub struct Report {\n    pub let FINDReport: FINDReport?\n    pub let NameReport: NameReport?\n\n    init(FINDReport: FINDReport?, NameReport: NameReport?) {\n        self.FINDReport=FINDReport \n        self.NameReport=NameReport\n    }\n}\n\npub fun main(user: String) : Report? {\n\n    var findReport: FINDReport? = nil\n    if let address=FIND.resolve(user) {\n        let account=getAccount(address)\n        let bidCap = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        let leaseCap = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        let profile=account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath).borrow()\n\n        let find= FindMarket.getFindTenantAddress()\n        let items : {String : FindMarket.SaleItemCollectionReport} = FindMarket.getSaleItemReport(tenant:find, address: address, getNFTInfo:true)\n\n        let marketBids : {String : FindMarket.BidItemCollectionReport} = FindMarket.getBidsReport(tenant:find, address: address, getNFTInfo:true)\n\n        findReport = FINDReport(\n            profile: profile?.asReport(),\n            relatedAccounts: RelatedAccounts.findRelatedFlowAccounts(address:address),\n            bids: bidCap.borrow()?.getBids() ?? [],\n            leases: leaseCap.borrow()?.getLeaseInformation() ?? [],\n            privateMode: profile?.isPrivateModeEnabled() ?? false,\n            itemsForSale: items,\n            marketBids: marketBids\n        )\n    }\n\n    var nameReport : NameReport? = nil \n    if FIND.validateFindName(user) {\n        let status = FIND.status(user)\n        let cost=FIND.calculateCost(user)\n        var s=\"TAKEN\"    \n        if status.status == FIND.LeaseStatus.FREE {\n            s=\"FREE\"\n        } else if status.status == FIND.LeaseStatus.LOCKED {\n            s=\"LOCKED\"\n        }\n        nameReport = NameReport(status: s, cost: cost)\n    }\n    \n\n    return Report(FINDReport: findReport, NameReport: nameReport)\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "getTenantSaleItem": {
               "code": "import FindMarket from 0xf8d6e0586b0a20c7\n\npub fun main(tenant: Address) : TenantSaleItems {\n    let tenantCap = FindMarket.getTenantCapability(tenant) ?? panic(\"No tenant capability is set up for this address\")\n    let tenantRef = tenantCap.borrow() ?? panic(\"Cannot borrow tenant reference from this address\")\n    let saleItems = tenantRef.getSaleItems()\n    return TenantSaleItems(findSaleItems: saleItems[\"findSaleItems\"]! ,\n                           tenantSaleItems: saleItems[\"tenantSaleItems\"]! ,\n                           findCuts: saleItems[\"findCuts\"]! )\n\n}\n\npub struct TenantSaleItems {\n    pub let findSaleItems : {String : FindMarket.TenantSaleItem}\n    pub let tenantSaleItems : {String : FindMarket.TenantSaleItem}\n    pub let findCuts : {String : FindMarket.TenantSaleItem} \n\n    init(findSaleItems : {String : FindMarket.TenantSaleItem}, \n         tenantSaleItems : {String : FindMarket.TenantSaleItem},\n         findCuts : {String : FindMarket.TenantSaleItem}) {\n             self.findSaleItems = findSaleItems\n             self.tenantSaleItems = tenantSaleItems \n             self.findCuts = findCuts \n         }\n}",
               "spec": {
                  "order": [
                     "tenant"
                  ],
                  "parameters": {
                     "tenant": "Address"
                  }
               }
            },
            "hasCharity": {
               "code": "import CharityNFT from 0xf8d6e0586b0a20c7\n\npub fun main(user: Address) : Bool {\n    let account=getAccount(user)\n    let charityCap = account.getCapability\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection)\n    return charityCap.check()\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "Address"
                  }
               }
            },
            "isFindUser": {
               "code": "import Profile from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\n\npub fun main(user: Address) : Bool {\n\n    let account=getAccount(user)\n    let leaseCap=account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n    let profileCap=account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\n    return leaseCap.check() \u0026\u0026 profileCap.check()\n\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "Address"
                  }
               }
            },
            "mainnet_getBeam": {
               "code": "import Beam from 0x86b4a0010a71cfc3 \n\npub struct MetadataCollectionItem {\n    pub let id:UInt64\n    pub let name: String\n    pub let image: String\n    pub let url: String\n    pub let listPrice: UFix64?\n    pub let listToken: String?\n    pub let contentType:String\n    pub let rarity:String\n\n\n    init(id:UInt64, name:String, image:String, url:String, listPrice: UFix64?, listToken:String?, contentType: String, rarity: String) {\n        self.id=id\n        self.name=name\n        self.url=url\n        self.image=image\n        self.listToken=listToken\n        self.listPrice=listPrice\n        self.contentType=contentType\n        self.rarity=rarity\n    }\n}\n\npub fun main(address: Address) : [MetadataCollectionItem] {\n\n\n    let items: [MetadataCollectionItem] = []\n    let account=getAccount(address)\n    let beamCap = account.getCapability\u003c\u0026{Beam.BeamCollectionPublic}\u003e(Beam.CollectionPublicPath)\n    if beamCap.check() {\n        let collection = beamCap.borrow()!\n        for id in collection.getIDs() {\n            let nft = collection.borrowCollectible(id: id)!\n\n        let metadata = Beam.getCollectibleItemMetaData(collectibleItemID: nft.data.collectibleItemID)!\n          var mediaUrl: String? = metadata[\"mediaUrl\"]\n            if mediaUrl != nil \u0026\u0026  mediaUrl!.slice(from: 0, upTo: 7) != \"ipfs://\" {\n                mediaUrl = \"ipfs://\".concat(mediaUrl!)\n            }\n            let item = MetadataCollectionItem(\n                id: id,\n                name: metadata[\"title\"]!,\n                image: mediaUrl ?? \"\",\n                url: \"https://\".concat(metadata[\"domainUrl\"]!),\n                listPrice: nil,\n                listToken: nil,\n                contentType: metadata[\"mediaType\"]!,\n                rarity: \"\"\n            )\n\n            items.append(item)\n        }\n    }\n    return items\n\n}",
               "spec": {
                  "order": [
                     "address"
                  ],
                  "parameters": {
                     "address": "Address"
                  }
               }
            },
            "mainnet_getCharity": {
               "code": "import NonFungibleToken from 0xf8d6e0586b0a20c7\nimport CharityNFT from 0xf8d6e0586b0a20c7\n\npub fun main(address: Address) : [UInt64] {\n    \n    let account = getAccount(address)\n    let charityCap = account.getCapability\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection)\n\n    return charityCap.borrow()!.getIDs()\n}",
               "spec": {
                  "order": [
                     "address"
                  ],
                  "parameters": {
                     "address": "Address"
                  }
               }
            },
            "mainnet_getCollections2": {
               "code": "import NonFungibleToken from 0xf8d6e0586b0a20c7\nimport CharityNFT from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\n\n//mainnet\n\nimport Beam from 0x86b4a0010a71cfc3 \nimport Art from 0xd796ff17107bbff6\nimport Marketplace from 0xd796ff17107bbff6\nimport GooberXContract from 0x34f2bf4a80bb0f69\nimport Flovatar from 0x921ea449dffec68a\nimport FlovatarMarketplace from  0x921ea449dffec68a\nimport RareRooms_NFT from 0x329feb3ab062d289\nimport CNN_NFT from 0x329feb3ab062d289\nimport Canes_Vault_NFT from 0x329feb3ab062d289\nimport DGD_NFT from 0x329feb3ab062d289\nimport RaceDay_NFT from 0x329feb3ab062d289\nimport The_Next_Cartel_NFT from 0x329feb3ab062d289\nimport UFC_NFT from 0x329feb3ab062d289\nimport MotoGPCard from 0xa49cc0ee46c54bfb\nimport Gaia from 0x8b148183c28ff88f\nimport ChainmonstersRewards from 0x93615d25d14fa337\nimport Moments from 0xd4ad4740ee426334\nimport MatrixWorldFlowFestNFT from 0x2d2750f240198f91\nimport SturdyItems from 0x427ceada271aa0b1\nimport Evolution from 0xf4264ac8f3256818\nimport GeniaceNFT from 0xabda6627c70c7f52\nimport OneFootballCollectible from 0x6831760534292098\nimport CryptoPiggo from 0xd3df824bf81910a4\nimport GoatedGoatsVouchers from 0xdfc74d9d561374c0\nimport TraitPacksVouchers from 0xdfc74d9d561374c0\nimport HaikuNFT from 0xf61e40c19db2a9e2\nimport KlktnNFT from 0xabd6e80be7e9682c\nimport Mynft from 0xf6fcbef550d97aa5\nimport NeoAvatar from 0xb25138dbf45e5801\nimport NeoViews from 0xb25138dbf45e5801\nimport MetadataViews from 0x1d7e57aa55817448\n\n//Jambb\nimport Vouchers from 0x444f5ea22c6ea12c\n\n//xtingles\nimport Collectible from 0xf5b0eb433389ac3f\n\npub struct MetadataCollection {\n\n    pub let path:PublicPath\n    pub let type: Type\n    pub let typeIdentifier: String\n    pub let conformance: String \n    pub let domainUrl : String\n    pub let category: String\n    pub let legacyIdentifierPrefix:String\n    pub let transferable: Bool\n\n    init(path:PublicPath, type:Type, conformance:String, domainUrl:String, category:String, legacyIdentifierPrefix:String, transferable:Bool) {\n        self.path=path\n        self.type=type\n        self.typeIdentifier=type.identifier\n        self.conformance=conformance\n        self.domainUrl=domainUrl\n        self.category=category\n        self.legacyIdentifierPrefix=legacyIdentifierPrefix\n        self.transferable=transferable\n    }\n\n}\n\npub struct MetadataCollections {\n\n    pub let items: {UInt64 : MetadataCollectionItem}\n    pub let internalToUuidMap: {String : UInt64 }\n    pub let collections: {String : [UInt64]}\n\n    init() {\n        self.items= {}\n        self.internalToUuidMap= {}\n        self.collections={}\n    }\n\n\n    pub fun addCollection(items:[MetadataCollectionItem]) {\n\n\n        if items.length == 0 {\n            return\n        }\n\n        let collection=items[0].collection\n        let resultCollection = self.collections[collection.category] ?? []\n        for item in items {\n            self.items[item.uuid]=item\n            //we add a mapping from old legacy internal id to uuid\n            self.internalToUuidMap[collection.legacyIdentifierPrefix.concat(item.id.toString())]= item.uuid\n            resultCollection.append(item.uuid)\n        }\n        self.collections[collection.category]=resultCollection\n    }\n\n    //This uses a view from Neo until we agree on another for ExternalDomainViewUrl\n    pub fun addMetadataCollection(path: PublicPath, account:PublicAccount, category:String, legacyIdentifierPrefix: String, url:String, transferable:Bool)  {\n\n        // init(path:PublicPath, type:Type, conformance:String, domainUrl:String, items: {UInt64:MetadataCollectionItem}, category:String, legacyIdentifierPrefix:String) {\n\n        let resolverCollectionCap= account.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(path)\n        if !resolverCollectionCap.check() {\n            return \n        }\n\n        let collection = resolverCollectionCap.borrow()!\n\n        let mc= MetadataCollection(path: path, type: collection.getType() , conformance: \"MetadataViews.ResolverCollection\", domainUrl: url, category: category, legacyIdentifierPrefix: legacyIdentifierPrefix, transferable: transferable)\n\n\n        let items:[MetadataCollectionItem]=[]\n        for id in collection.getIDs() {\n            let nft = collection.borrowViewResolver(id: id)!\n\n            if let displayView = nft.resolveView(Type\u003cMetadataViews.Display\u003e()) {\n                let display = displayView as! MetadataViews.Display\n\n                var externalUrl=mc.domainUrl\n                if let externalUrlView = nft.resolveView(Type\u003cNeoViews.ExternalDomainViewUrl\u003e()) {\n                    let edvu= externalUrlView! as! NeoViews.ExternalDomainViewUrl\n                    externalUrl=edvu.url\n                }\n\n                //: add check for rarity and minter here\n\n                let item = MetadataCollectionItem(\n                    id: id,\n                    uuid: nft.uuid,\n                    name: display.name,\n                    description:display.description,\n                    image: display.thumbnail.uri(),\n                    url: externalUrl,\n                    contentType: \"image\",\n                    rarity: \"\",\n                    minter: \"\",\n                    type: nft.getType(),\n                    collection:mc\n                )\n                items.append(item)\n            }\n        }\n        self.addCollection(items: items)\n    }\n}\n\n\npub struct MetadataCollectionItem {\n    pub let id:UInt64\n    pub let uuid:UInt64\n    pub let name: String\n    pub let description: String?\n    pub let image: String\n    pub let url: String\n    pub let contentType:String\n    pub let rarity:String\n    pub let minter:String?\n    pub let type:Type\n    pub let collection:MetadataCollection\n\n\n    init(id:UInt64, uuid:UInt64, name:String, description:String?, image:String, url:String, contentType: String, rarity: String, minter:String?, type:Type, collection: MetadataCollection) {\n        self.id=id\n        self.uuid=uuid\n        self.name=name\n        self.description=description\n        self.minter=minter\n        self.url=url\n        self.type=type\n        self.image=image\n        self.collection=collection\n        self.contentType=contentType\n        self.rarity=rarity\n    }\n}\n\n// change bacak to address later\n//pub fun main(address: Address) : MetadataCollections? {\npub fun main(name: String) : MetadataCollections? {\n    let address=FIND.lookupAddress(name)!\n\n    let collection= MetadataCollections()\n    let account=getAccount(address)\n\n    let items:[MetadataCollectionItem]=[]\n\n    let versusArtCap=account.getCapability\u003c\u0026{Art.CollectionPublic}\u003e(Art.CollectionPublicPath)\n    let versusImageUrlPrefix = \"https://res.cloudinary.com/dxra4agvf/image/upload/c_fill,w_600/f_auto/maincache\"\n    if versusArtCap.check(){\n\n        let artCollection= versusArtCap.borrow()!\n\n        let mc= MetadataCollection(path: Art.CollectionPublicPath, type: artCollection.getType() , conformance: \"Art.CollectionPublic\", domainUrl: \"https://versus.auction\", category: \"Versus\", legacyIdentifierPrefix: \"Versus\", transferable: true)\n\n        for id in artCollection.getIDs() {\n            var art=artCollection.borrowArt(id: id)!\n            let item = MetadataCollectionItem(\n                id: id,\n                uuid: art.uuid,\n                name: art.metadata.name.concat(\" edition \").concat(art.metadata.edition.toString()).concat(\"/\").concat(art.metadata.maxEdition.toString()).concat(\" by \").concat(art.metadata.artist),  \n                description:art.metadata.description,\n                image: versusImageUrlPrefix.concat(art.cacheKey()), \n                url: \"https://www.versus.auction/piece/\".concat(address.toString()).concat(\"/\").concat(art.id.toString()).concat(\"/\"),\n                contentType: \"image\",\n                rarity: \"\",\n                minter: \"\",\n                type: art.getType(),\n                collection:mc\n            )\n            items.append(item)\n        }\n    }\n\n    let versusMarketplace = account.getCapability\u003c\u0026{Marketplace.SalePublic}\u003e(Marketplace.CollectionPublicPath)\n    if versusMarketplace.check() {\n\n        let versusMarket = versusMarketplace.borrow()!\n\n        let mc= MetadataCollection(path: Marketplace.CollectionPublicPath, type: versusMarketplace.borrow()!.getType() , conformance: \"Marketplace.SalePublic\", domainUrl: \"https://versus.auction\", category: \"Versus\", legacyIdentifierPrefix: \"Versus\", transferable:false)\n\n        let saleItems = versusMarket.listSaleItems()\n        for saleItem in saleItems {\n\n            let uuid = versusMarket.getUUIDforSaleItem(tokenID: saleItem.id)\n            let item = MetadataCollectionItem(\n                id: saleItem.id,\n                uuid: uuid,\n                name: saleItem.art.name.concat(\" edition \").concat(saleItem.art.edition.toString()).concat(\"/\").concat(saleItem.art.maxEdition.toString()).concat(\" by \").concat(saleItem.art.artist),\n                description:\"\",\n                image: versusImageUrlPrefix.concat(saleItem.cacheKey), \n                url: \"https://www.versus.auction/listing/\".concat(saleItem.id.toString()).concat(\"/\"),\n                contentType: \"image\",\n                rarity: \"\",\n                minter: \"\",\n                type: Type\u003c@Art.NFT\u003e(), \n                collection:mc\n            )\n            items.append(item)\n        }\n    }\n\n  let flovatarCap = account.getCapability\u003c\u0026{Flovatar.CollectionPublic}\u003e(Flovatar.CollectionPublicPath)  \n    if flovatarCap.check(){\n\n        let flovatars=flovatarCap.borrow()!\n         let mc= MetadataCollection(path: Flovatar.CollectionPublicPath, type: flovatars.getType() , conformance: \"Flovatar.CollectionPublic\", domainUrl: \"https://flovatar.com\", category: \"Flovatar\", legacyIdentifierPrefix: \"Flovatar\", transferable:true)\n        for id in flovatars.getIDs() {\n            let flovatar = flovatars.borrowFlovatar(id: id)!\n\n            let metadata=flovatar.getMetadata()\n            var name = flovatar.getName()\n            if name == \"\" {\n                name=\"Flovatar #\".concat(flovatar.id.toString())\n            }\n\n            var rarity=\"common\"\n            if metadata.legendaryCount \u003e 0 {\n                rarity=\"legendary\"\n            }else if metadata.epicCount \u003e 0 {\n                rarity=\"epic\"\n            }else if metadata.rareCount \u003e 0 {\n                rarity=\"rare\"\n            }\n\n\n            let item=MetadataCollectionItem(\n                id: flovatar.id, \n                uuid:flovatar.uuid,\n                name: name, \n                description: flovatar.description,\n                image: \"https://flovatar.com/api/image/\".concat(flovatar.id.toString()),\n                url: \"https://flovatar.com/flovatars/\".concat(flovatar.id.toString()).concat(\"/\"),\n                contentType: \"image\",\n                rarity: rarity,\n                minter: \"\",\n                type: flovatar.getType(),\n                collection:mc\n            )\n            items.append(item)\n        }\n    }\n\n\n    let flovatarMarketCap = account.getCapability\u003c\u0026{FlovatarMarketplace.SalePublic}\u003e(FlovatarMarketplace.CollectionPublicPath)  \n    if flovatarMarketCap.check(){\n\n        let saleCollection=flovatarMarketCap.borrow()!\n         let mc= MetadataCollection(path: FlovatarMarketplace.CollectionPublicPath, type: saleCollection.getType() , conformance: \"FlovatarMarketplace.SalePublic\", domainUrl: \"https://flovatar.com\", category: \"Flovatar\", legacyIdentifierPrefix: \"Flovatar\", transferable:false)\n        for id in saleCollection.getFlovatarIDs() {\n            let flovatar = saleCollection.getFlovatar(tokenId: id)!\n\n            let metadata=flovatar.getMetadata()\n            var name = flovatar.getName()\n            if name == \"\" {\n                name=\"Flovatar #\".concat(flovatar.id.toString())\n            }\n\n            var rarity=\"common\"\n            if metadata.legendaryCount \u003e 0 {\n                rarity=\"legendary\"\n            }else if metadata.epicCount \u003e 0 {\n                rarity=\"epic\"\n            }else if metadata.rareCount \u003e 0 {\n                rarity=\"rare\"\n            }\n\n\n            let item=MetadataCollectionItem(\n                id: flovatar.id, \n                uuid:flovatar.uuid,\n                name: name, \n                description: flovatar.description,\n                image: \"https://flovatar.com/api/image/\".concat(flovatar.id.toString()),\n                url: \"https://flovatar.com/flovatars/\".concat(flovatar.id.toString()).concat(\"/\"),\n                contentType: \"image\",\n                rarity: rarity,\n                minter: \"\",\n                type: flovatar.getType(),\n                collection:mc\n            )\n            items.append(item)\n        }\n    }\n\n\n    let goobersCap = account.getCapability\u003c\u0026GooberXContract.Collection{NonFungibleToken.CollectionPublic, GooberXContract.GooberCollectionPublic}\u003e(GooberXContract.CollectionPublicPath)\n    if goobersCap.check() {\n\n        let goobers = goobersCap.borrow()!\n\n        let mc= MetadataCollection(path: GooberXContract.CollectionPublicPath, type: goobers.getType() , conformance: \"NonFungibleToken.CollectionPublic, GooberXContract.GooberCollectionPublic\", domainUrl: \"https://partimansion.io/gooberz\", category: \"Gooberz\", legacyIdentifierPrefix: \"Gooberz\", transferable:true)\n        for id in goobers.getIDs() {\n            let goober= goobers.borrowGoober(id:id)!\n            let item=MetadataCollectionItem(\n                id: id,\n                uuid: goober.uuid,\n                name: \"Goober #\".concat(id.toString()),\n                description: \"\",\n                image: goober.data.uri,\n                url: \"https://partymansion.io/gooberz/\".concat(id.toString()),\n                contentType: \"image\",\n                rarity: \"\",\n                minter:\"\",\n                type: goober.getType(),\n                collection:mc\n            )\n            items.append(item)\n        }\n    }\n\n\n    let rareRoomCap = account.getCapability\u003c\u0026RareRooms_NFT.Collection{RareRooms_NFT.RareRooms_NFTCollectionPublic}\u003e(RareRooms_NFT.CollectionPublicPath)\n    if rareRoomCap.check() {\n\n        let rareRooms = rareRoomCap.borrow()!\n        let mc= MetadataCollection(path: RareRooms_NFT.CollectionPublicPath, type: rareRooms.getType() , conformance: \"RareRooms_NFT.RareRooms_NFTCollectionPublic\", domainUrl: \"https://rarerooms.io\", category: \"RareRooms\", legacyIdentifierPrefix: \"RareRooms\", transferable:true)\n        for id in rareRooms.getIDs() {\n            let nft = rareRooms.borrowRareRooms_NFT(id: id)!\n            let metadata = RareRooms_NFT.getSetMetadata(setId: nft.setId)!\n            let item = MetadataCollectionItem(\n                id: id,\n                uuid: nft.uuid,\n                name: metadata[\"name\"]!,\n                description: metadata[\"description\"] ?? \"\", \n                image: metadata[\"preview\"]!,\n                url: \"https://rarerooms.io/tokens/\".concat(id.toString()),\n                contentType: \"image\",\n                rarity: \"\",\n                minter: \"\",\n                type: nft.getType(),\n                collection:mc\n            )\n            items.append(item)\n        }\n    }\n    \n\n    let cnnCap = account.getCapability\u003c\u0026CNN_NFT.Collection{CNN_NFT.CNN_NFTCollectionPublic}\u003e(CNN_NFT.CollectionPublicPath)\n    if cnnCap.check() {\n\n        let cnns = cnnCap.borrow()!\n        let mc= MetadataCollection(path: CNN_NFT.CollectionPublicPath, type: cnns.getType() , conformance: \"CNN_NFT.CNN_NFTCollectionPublic\", domainUrl: \"https://vault.cnn.com\", category: \"CNN\", legacyIdentifierPrefix: \"CNN\", transferable:true)\n        for id in cnns.getIDs() {\n            let nft = cnns.borrowCNN_NFT(id: id)!\n            let metadata = CNN_NFT.getSetMetadata(setId: nft.setId)!\n            let item = MetadataCollectionItem(\n                id: id,\n                uuid: nft.uuid,\n                name: metadata[\"name\"]!,\n                description: metadata[\"description\"] ?? \"\", \n                image: metadata[\"preview\"]!,\n                url: \"https://vault.cnn.com\",\n                contentType: \"image\",\n                rarity: \"\",\n                minter: \"\",\n                type: nft.getType(),\n                collection:mc\n            )\n            items.append(item)\n        }\n    }\n\n    let canesVaultCap = account.getCapability\u003c\u0026Canes_Vault_NFT.Collection{Canes_Vault_NFT.Canes_Vault_NFTCollectionPublic}\u003e(Canes_Vault_NFT.CollectionPublicPath)\n    if canesVaultCap.check() {\n\n        let canesVaults = canesVaultCap.borrow()!\n        let mc= MetadataCollection(path: Canes_Vault_NFT.CollectionPublicPath, type: canesVaults.getType() , conformance: \"Canes_Vault_NFT.Canes_Vault_NFTCollectionPublic\", domainUrl: \"https://canesvault.com\", category: \"Canes_Vault\", legacyIdentifierPrefix: \"Canes_Vault_NFT\", transferable:true)\n        for id in canesVaults.getIDs() {\n            let nft = canesVaults.borrowCanes_Vault_NFT(id: id)!\n            let metadata = Canes_Vault_NFT.getSetMetadata(setId: nft.setId)!\n            let item = MetadataCollectionItem(\n                id: id,\n                uuid: nft.uuid,\n                name: metadata[\"name\"]!,\n                description: metadata[\"description\"] ?? \"\", \n                image: metadata[\"preview\"]!,\n                url: \"https://canesvault.com\",\n                contentType: \"image\",\n                rarity: \"\",\n                minter: \"\",\n                type: nft.getType(),\n                collection:mc\n            )\n            items.append(item)\n        }\n    }\n\n    let dgdCap = account.getCapability\u003c\u0026DGD_NFT.Collection{DGD_NFT.DGD_NFTCollectionPublic}\u003e(DGD_NFT.CollectionPublicPath)\n    if dgdCap.check() {\n\n        let dgds = dgdCap.borrow()!\n        let mc= MetadataCollection(path: DGD_NFT.CollectionPublicPath, type: dgds.getType() , conformance: \"DGD_NFT.DGD_NFTCollectionPublic\", domainUrl: \"https://theplayerslounge.io\", category: \"DGD\", legacyIdentifierPrefix: \"DGD\", transferable:true)\n        for id in dgds.getIDs() {\n            let nft = dgds.borrowDGD_NFT(id: id)!\n            let metadata = DGD_NFT.getSetMetadata(setId: nft.setId)!\n            let item = MetadataCollectionItem(\n                id: id,\n                uuid: nft.uuid,\n                name: metadata[\"name\"]!,\n                description: metadata[\"description\"] ?? \"\", \n                image: metadata[\"preview\"]!,\n                url: \"https://www.theplayerslounge.io\",\n                contentType: \"image\",\n                rarity: \"\",\n                minter: \"\",\n                type: nft.getType(),\n                collection:mc\n            )\n            items.append(item)\n        }\n    }\n    \n    let raceDayCap = account.getCapability\u003c\u0026RaceDay_NFT.Collection{RaceDay_NFT.RaceDay_NFTCollectionPublic}\u003e(RaceDay_NFT.CollectionPublicPath)\n    if raceDayCap.check() {\n\n        let raceDays = raceDayCap.borrow()!\n        let mc= MetadataCollection(path: RaceDay_NFT.CollectionPublicPath, type: raceDays.getType() , conformance: \"RaceDay_NFT.RaceDay_NFTCollectionPublic\", domainUrl: \"https://racedaynft.com\", category: \"RaceDay\", legacyIdentifierPrefix: \"RaceDay_NFT\", transferable:true)\n        for id in raceDays.getIDs() {\n            let nft = raceDays.borrowRaceDay_NFT(id: id)!\n            let metadata = RaceDay_NFT.getSetMetadata(setId: nft.setId)!\n            let item = MetadataCollectionItem(\n                id: id,\n                uuid: nft.uuid,\n                name: metadata[\"name\"]!,\n                description: metadata[\"description\"] ?? \"\", \n                image: metadata[\"preview\"]!,\n                url: \"https://www.racedaynft.com\",\n                contentType: \"image\",\n                rarity: \"\",\n                minter: \"\",\n                type: nft.getType(),\n                collection:mc\n            )\n            items.append(item)\n        }\n    }\n\n    let nextCartelCap = account.getCapability\u003c\u0026The_Next_Cartel_NFT.Collection{The_Next_Cartel_NFT.The_Next_Cartel_NFTCollectionPublic}\u003e(The_Next_Cartel_NFT.CollectionPublicPath)\n    if nextCartelCap.check() {\n\n        let nextCartels = nextCartelCap.borrow()!\n        let mc= MetadataCollection(path: The_Next_Cartel_NFT.CollectionPublicPath, type: nextCartels.getType() , conformance: \"The_Next_Cartel_NFT.The_Next_Cartel_NFTCollectionPublic\", domainUrl: \"https://thenextcartel.com\", category: \"The_Next_Cartel\", legacyIdentifierPrefix: \"The_Next_Cartel_NFT\", transferable:true)\n        for id in nextCartels.getIDs() {\n            let nft = nextCartels.borrowThe_Next_Cartel_NFT(id: id)!\n            let metadata = The_Next_Cartel_NFT.getSetMetadata(setId: nft.setId)!\n            let item = MetadataCollectionItem(\n                id: id,\n                uuid: nft.uuid,\n                name: metadata[\"name\"]!,\n                description: metadata[\"description\"] ?? \"\", \n                image: metadata[\"preview\"]!,\n                url: \"https://thenextcartel.com/\",\n                contentType: \"image\",\n                rarity: \"\",\n                minter: \"\",\n                type: nft.getType(),\n                collection:mc\n            )\n            items.append(item)\n        }\n    }\n\n    let utcCap = account.getCapability\u003c\u0026UFC_NFT.Collection{UFC_NFT.UFC_NFTCollectionPublic}\u003e(UFC_NFT.CollectionPublicPath)\n    if utcCap.check() {\n\n        let utcs = utcCap.borrow()!\n        let mc= MetadataCollection(path: UFC_NFT.CollectionPublicPath, type: utcs.getType() , conformance: \"UFC_NFT.UFC_NFTCollectionPublic\", domainUrl: \"https://ufcstrike.com\", category: \"UFC\", legacyIdentifierPrefix: \"UFC\", transferable:true)\n        for id in utcs.getIDs() {\n            let nft = utcs.borrowUFC_NFT(id: id)!\n            let metadata = UFC_NFT.getSetMetadata(setId: nft.setId)!\n            let item = MetadataCollectionItem(\n                id: id,\n                uuid: nft.uuid,\n                name: metadata[\"name\"]!,\n                description: metadata[\"description\"] ?? \"\", \n                image: metadata[\"image\"]!,\n                url: \"https://ufcstrike.com\",\n                contentType: \"video\",\n                rarity: \"\",\n                minter: \"\",\n                type: nft.getType(),\n                collection:mc\n            )\n            items.append(item)\n        }\n    }\n\n    let motoGPCollection = account.getCapability\u003c\u0026MotoGPCard.Collection{MotoGPCard.ICardCollectionPublic}\u003e(/public/motogpCardCollection)\n    if motoGPCollection.check() {\n        let motoGPNfts = motoGPCollection.borrow()!\n\n        let mc= MetadataCollection(path: /public/motogpCardCollection, type: motoGPNfts.getType() , conformance: \"MotoGPCard.ICardCollectionPublic\", domainUrl: \"https://motogp-ignition.com.com\", category: \"MotoGP\", legacyIdentifierPrefix: \"MotoGP\", transferable:true)\n        for id in motoGPNfts.getIDs() {\n            let nft = motoGPNfts.borrowCard(id: id)!\n            let metadata = nft.getCardMetadata()!\n            let item = MetadataCollectionItem(\n                id: id,\n                uuid: nft.uuid,\n                name: metadata.name,\n                description: metadata.description,\n                image: metadata.imageUrl,\n                url: \"https://motogp-ignition.com/nft/card/\".concat(id.toString()).concat(\"?owner=\").concat(address.toString()),\n                contentType: \"image\",\n                rarity: \"\",\n                minter: \"\",\n                type: nft.getType(),\n                collection:mc\n            )\n            items.append(item)\n        }\n    }\n\n    let gaiaCollection = account.getCapability\u003c\u0026{Gaia.CollectionPublic}\u003e(Gaia.CollectionPublicPath)\n    if gaiaCollection.check() {\n\n        let gaiaNfts = gaiaCollection.borrow()!\n\n        let mc= MetadataCollection(path: Gaia.CollectionPublicPath, type: gaiaNfts.getType() , conformance: \"Gaia.CollectionPublic\", domainUrl: \"http://ongaia.com\", category: \"Gaia\", legacyIdentifierPrefix: \"Gaia\", transferable:true)\n        for id in gaiaNfts.getIDs() {\n            let nft = gaiaNfts.borrowGaiaNFT(id: id)!\n            let metadata = Gaia.getTemplateMetaData(templateID: nft.data.templateID)!\n\n\n            var url=\"\"\n            let metadataId=metadata[\"id\"]\n            var name=metadata[\"title\"]!\n            if metadataId != nil {\n                url=\"http://ongaia.com/ballerz/\".concat(metadataId!)\n            }\n            //For ballerz we can do this...\n\n            if let seriesFullName=metadata[\"series\"] {\n                if seriesFullName==\"Shareef O\\u{2019}Neal - Basketball\" {\n                    //If the series is basketball with shareef we can do this\n                    url=\"http://ongaia.com/sharef/\".concat(id.toString())\n                    name=metadata[\"title\"]!.concat(\" #\").concat(nft.data.mintNumber.toString())\n                }else if seriesFullName==\"Bryson DeChambeau - Vegas, Baby!\" {\n                    //For golf there is yet another way\n                    url=\"http://ongaia.com/bryson/\".concat(nft.data.mintNumber.toString())\n                    name=metadata[\"title\"]!.concat(\" #\").concat(nft.data.mintNumber.toString())\n                }\n            }\n\n            let item = MetadataCollectionItem(\n                id: id,\n                uuid: nft.uuid,\n                name: name,\n                description: metadata[\"description\"] ?? \"\",\n                image: metadata[\"img\"]!,\n                url: url,\n                contentType: \"image\",\n                rarity: \"\",\n                minter: \"\",\n                type: nft.getType(),\n                collection:mc\n            )\n            items.append(item)\n        }\n    }\n\n    let jambbCap = account.getCapability\u003c\u0026Moments.Collection{Moments.CollectionPublic}\u003e(Moments.CollectionPublicPath)\n    if jambbCap.check() {\n\n        let nfts = jambbCap.borrow()!\n        let mc= MetadataCollection(path: Moments.CollectionPublicPath, type: nfts.getType() , conformance: \"Moments.CollectionPublic\", domainUrl: \"http://jambb.com\", category: \"Jambb\", legacyIdentifierPrefix: \"Jambb\", transferable:true)\n        for id in nfts.getIDs() {\n            let nft = nfts.borrowMoment(id: id)!\n            let metadata=nft.getMetadata()\n            let item  =MetadataCollectionItem(\n                id: id,\n                uuid: nft.uuid,\n                name: metadata.contentName,\n                description: metadata.contentDescription,\n                image: \"ipfs://\".concat(metadata.videoHash),\n        url: \"https://www.jambb.com/c/moment/\".concat(id.toString()),\n                contentType: \"video\",\n                rarity: \"\",\n                minter: \"\",\n                type: nft.getType(),\n                collection:mc\n            )\n            items.append(item)\n        }\n\n    }\n\n    let voucherCap = account.getCapability\u003c\u0026{Vouchers.CollectionPublic}\u003e(Vouchers.CollectionPublicPath)\n    if voucherCap.check() {\n\n        let jambb = voucherCap.borrow()!\n        let mc= MetadataCollection(path: Vouchers.CollectionPublicPath, type: jambb.getType() , conformance: \"Vouchers.CollectionPublic\", domainUrl: \"http://jambb.com\", category: \"Jambb\", legacyIdentifierPrefix: \"JambbVoucher\", transferable:false)\n        for id in jambb.getIDs() {\n            let nft = jambb.borrowVoucher(id: id)!\n            let metadata=nft.getMetadata()!\n\n            let url=\"https://jambb.com\"\n            let item = MetadataCollectionItem(\n                id: id,\n                uuid: nft.uuid,\n                name: metadata.name,\n                description: metadata.description,\n                image: \"ipfs://\".concat(metadata.mediaHash),\n                url: url,\n                contentType: metadata.mediaType,\n                rarity: \"\",\n                minter: \"\",\n                type:nft.getType(),\n                collection: mc\n            )\n            items.append(item)\n        }\n\n    }\n\n    \n    //:matrixworld\n\n  let sturdyCollectionCap = account.getCapability\u003c\u0026SturdyItems.Collection{SturdyItems.SturdyItemsCollectionPublic}\u003e(SturdyItems.CollectionPublicPath)\n    if sturdyCollectionCap.check() {\n        let sturdyNfts = sturdyCollectionCap.borrow()!\n\n        let mc= MetadataCollection(path: SturdyItems.CollectionPublicPath, type: sturdyNfts.getType() , conformance: \"SturdyItems.SturdyItemsCollectionPublic\", domainUrl: \"http://hoodlumsnft.com.com\", category: \"Hoodlums\", legacyIdentifierPrefix: \"Hoodlums\", transferable:true)\n        for id in sturdyNfts.getIDs() {\n            // the metadata is a JSON stored on IPFS at the address nft.tokenURI\n            let nft = sturdyNfts.borrowSturdyItem(id: id)!\n            // the only thing we can play with is the nft title which is for example:\n            //     - \"HOODLUM#10\"\n            //     - \"HOLIDAY MYSTERY BADGE 2021\"\n            //  - \"EXCALIBUR\"\n            let isHoodlum = nft.tokenTitle.slice(from: 0, upTo: 7) == \"HOODLUM\"\n            if isHoodlum {\n                // the hoodlum id is needed to retrieve the image but is not in the nft\n                let hoodlumId = nft.tokenTitle.slice(from: 8, upTo: nft.tokenTitle.length)\n                let item=MetadataCollectionItem(\n                    id: id,\n                    uuid:nft.uuid,\n                    name: nft.tokenTitle,\n                    description: \"\",\n                    image: \"https://hoodlumsnft.com/_next/image?url=%2Fthumbs%2FsomeHoodlum_\".concat(hoodlumId).concat(\".png\u0026w=1920\u0026q=75\"),\n                    url: \"https://hoodlumsnft.com/\",\n                    contentType:\"image\",\n                    rarity: \"\",\n                    minter:\"\",\n                    type: nft.getType(),\n                    collection: mc\n                )\n                items.append(item)\n            }\n        }\n    }\n\n  let charityCap = account.getCapability\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection)\n    if charityCap.check() {\n        let nfts = charityCap.borrow()!\n        let mc= MetadataCollection(path: /public/findCharityNFTCollection, type: nfts.getType() , conformance: \"CharityNFT.CollectionPublicPath\", domainUrl: \"https://find.xyz/neo-x-flowverse-community-charity-tree\", category: \"Find\", legacyIdentifierPrefix: \"Charity\", transferable:true)\n\n        for id in nfts.getIDs() {\n            let nft = nfts.borrowCharity(id: id)!\n            let metadata = nft.getMetadata()\n            let item=MetadataCollectionItem(\n                id: id,\n                uuid:nft.uuid,\n                name: metadata[\"name\"]!,\n                description: \"\",\n                image: metadata[\"thumbnail\"]!,\n                url: metadata[\"originUrl\"]!,\n                contentType:\"image\",\n                rarity: \"\",\n                minter: \"\",\n                type: nft.getType(),\n                collection:mc\n            )\n\n            items.append(item)\n        }\n    }\n\n  let evolutionCap=account.getCapability\u003c\u0026{Evolution.EvolutionCollectionPublic}\u003e(/public/f4264ac8f3256818_Evolution_Collection)\n    if evolutionCap.check() {\n        let evolution=evolutionCap.borrow()!\n        let nfts = evolution.getIDs()\n\n        let mc= MetadataCollection(path: /public/f4264ac8f3256818_Evolution_Collection, type: nfts.getType() , conformance: \"Evolution.EvolutionCollectionPublic\", domainUrl: \"https://evolution-collect.com\", category: \"Evolution\", legacyIdentifierPrefix: \"Evolution\", transferable:true)\n        for id in nfts{\n            // the metadata is a JSON stored on IPFS at the address nft.tokenURI\n            let nft = evolution.borrowCollectible(id: id)!\n            let metadata = Evolution.getItemMetadata(itemId: nft.data.itemId)!\n            let item=MetadataCollectionItem(\n                id: id,\n                uuid: nft.uuid,\n                name: metadata[\"Title\"]!.concat(\" #\").concat(nft.data.serialNumber.toString()),\n                description: metadata[\"Description\"] ?? \"\",\n                image: \"https://storage.viv3.com/0xf4264ac8f3256818/mv/\".concat(nft.data.itemId.toString()),\n                url: \"https://www.evolution-collect.com/\",\n                contentType:\"video\",\n                rarity: \"\",\n                minter:\"\",\n                type:nft.getType(),\n                collection:mc\n            )\n\n            items.append(item)\n        }\n    }\n\n    /* // fix\n  let geniaceCap = account.getCapability\u003c\u0026GeniaceNFT.Collection{NonFungibleToken.CollectionPublic, GeniaceNFT.GeniaceNFTCollectionPublic}\u003e(GeniaceNFT.CollectionPublicPath)\n    if geniaceCap.check() {\n        let geniace=geniaceCap.borrow()!\n\n        let mc= MetadataCollection(path: GeniaceNFT.CollectionPublic, type: geniace.getType() , conformance: \"NonFungibleToken.CollectionPublic, GeniaceNFT.GeniaceNFTCollectionPublic\", domainUrl: \"https://geniace.com\", category: \"Geniace\", legacyIdentifierPrefix: \"Geniace\", transferable:true)\n        let nfts = geniace.getIDs()\n        for id in nfts{\n            // the metadata is a JSON stored on IPFS at the address nft.tokenURI\n            let nft = geniace.borrowGeniaceNFT(id: id)!\n            let metadata = nft.metadata\n            var rarity=\"\"\n            if metadata.rarity == GeniaceNFT.Rarity.Collectible {\n                rarity=\"Collectible\"\n            }else if metadata.rarity == GeniaceNFT.Rarity.Rare {\n                rarity=\"Rare\"\n            }else if metadata.rarity == GeniaceNFT.Rarity.UltraRare {\n                rarity=\"UltraRare\"\n            }\n\n            let item=MetadataCollectionItem(\n                id: id,\n                uuid: nft.uuid,\n                name: metadata.name,\n                description:metadata.description,\n                image: metadata.imageUrl,\n                url: \"https://www.geniace.com/product/\".concat(id.toString()),\n                contentType: metadata.data[\"mimetype\"]!,\n                rarity: rarity,\n                minter: \"\",\n                type: nft.getType(),\n                collection:mc\n            )\n            items.append(item)\n        }\n    }\n\n// https://flow-view-source.com/mainnet/account/0x6831760534292098/contract/OneFootballCollectible\n    let oneFootballCollectibleCap = account.getCapability\u003c\u0026OneFootballCollectible.Collection{OneFootballCollectible.OneFootballCollectibleCollectionPublic}\u003e(OneFootballCollectible.CollectionPublicPath)\n    if oneFootballCollectibleCap.check() {\n        let nfts = oneFootballCollectibleCap.borrow()!\n\n        let mc= MetadataCollection(path: OneFootballCollectible.ColllectionPublicPath, type: nfts.getType() , conformance: \"OneFootballCollectible.OneFootballCollectibleCollectionPublic\", domainUrl: \"https://xmas.onefootball.com\", category: \"OneFootball\", legacyIdentifierPrefix: \"OneFootballCollectible\", transferable:true)\n        for id in nfts.getIDs() {\n            let nft = nfts.borrowOneFootballCollectible(id: id)!\n            let metadata = nft.getTemplate()!\n            let item=MetadataCollectionItem(\n                id: id,\n                uuid: nft.uuid,\n                name: metadata.name,\n                description:metadata.description,\n                image: \"ipfs://\".concat(metadata.media),\n                url: \"https://xmas.onefootball.com/\".concat(account.address.toString()),\n                contentType: \"video\",\n                rarity: \"\",\n                minter:\"\",\n                type: nft.getType(),\n                collection:mc\n            )\n            items.append(item)\n        }\n    }\n    */\n\n  let cryptoPiggoCap = account.getCapability\u003c\u0026{CryptoPiggo.CryptoPiggoCollectionPublic}\u003e(CryptoPiggo.CollectionPublicPath)\n    if cryptoPiggoCap.check() {\n        let nfts = cryptoPiggoCap.borrow()!\n\n        let mc= MetadataCollection(path: CryptoPiggo.CollectionPublicPath, type: nfts.getType() , conformance: \"CryptoPiggo.CryptoPiggoCollectionPublic\", domainUrl: \"https://rareworx.com/piggo\", category: \"CryptoPiggo\", legacyIdentifierPrefix: \"CryptoPiggo\", transferable:true)\n        for id in nfts.getIDs() {\n            let nft = nfts.borrowItem(id: id)!\n            let item=MetadataCollectionItem(\n                id: id,\n                uuid:nft.uuid,\n                name: \"CryptoPiggo #\".concat(id.toString()),\n                description: \"\",\n                image: \"https://s3.us-west-2.amazonaws.com/crypto-piggo.nft/piggo-\".concat(id.toString()).concat(\".png\"),\n                url: \"https://rareworx.com/piggo/details/\".concat(id.toString()),\n                contentType: \"image\",\n                rarity: \"\",\n                minter:\"\",\n                type: nft.getType(),\n                collection:mc\n            )\n            items.append(item)\n        }\n    }\n\n    //: xtingles\n\n    /*\n    : goats\n    let goatsCap = account.getCapability\u003c\u0026{GoatedGoatsVouchers.GoatsVoucherCollectionPublic}\u003e(GoatedGoatsVouchers.CollectionPublicPath)\n    if goatsCap.check() {\n        let goatsImageUrl= GoatedGoatsVouchers.getCollectionMetadata()[\"mediaURL\"]!\n        let nfts = goatsCap.borrow()!\n        let mc= MetadataCollection(path: GoatedGoatsVouchers.CollectionPublicPath, type: nfts.getType() , conformance: \"GoatedGoatsVouchers.GoatsVoucherCollectionPublic\", domainUrl: \"https://goatedgoats.com\", category: \"GoatedGoats\", legacyIdentifierPrefix: \"GoatedGoatsVouchers\", transferable:false)\n        for id in nfts.getIDs() {\n            let item=MetadataCollectionItem(\n                id: id,\n                uuid: nft.get\n                name: \"Goated Goat Base Goat Voucher #\".concat(id.toString()),\n                image: goatsImageUrl, \n                url: \"https://goatedgoats.com/\",\n                contentType: \"image\",\n                rarity: \"\"\n\n            )\n            items.append(item)\n        }\n    }\n  \n    let goatsTraitCap = account.getCapability\u003c\u0026{TraitPacksVouchers.PackVoucherCollectionPublic}\u003e(TraitPacksVouchers.CollectionPublicPath)\n    if goatsTraitCap.check() {\n        let goatsImageUrl= TraitPacksVouchers.getCollectionMetadata()[\"mediaURL\"]!\n        let collection = goatsTraitCap.borrow()!\n        for id in collection.getIDs() {\n            let item=MetadataCollectionItem(\n                id: id,\n                name: \"Goated Goat Trait Pack Voucher #\".concat(id.toString()),\n                image: goatsImageUrl, \n                url: \"https://goatedgoats.com/\",\n                listPrice: nil,\n                listToken: nil,\n                contentType: \"image\",\n                rarity: \"\"\n\n            )\n            let itemId=\"GoatedGoatsTraitVoucher\".concat(id.toString())\n            goats.append(itemId)\n            resultMap[itemId] = item\n        }\n    }\n    */\n\n\n    /* // fix\n  let bitkuCap = account.getCapability\u003c\u0026{HaikuNFT.HaikuCollectionPublic}\u003e(HaikuNFT.HaikuCollectionPublicPath)\n    if bitkuCap.check() {\n        let nfts = bitkuCap.borrow()!\n\n        let mc= MetadataCollection(path: HaikuNFT.CollectionPublicPath, type: nfts.getType() , conformance: \"HaikuNFT.HaikuCollectionPublic\", domainUrl: \"https://bitku.art\", category: \"Bitku\", legacyIdentifierPrefix: \"Bitku\", transferable:true)\n        for id in nfts.getIDs() {\n            let nft = nfts.borrowHaiku(id: id)!\n            let item = MetadataCollectionItem(\n                id: id,\n                uuid:nft.uuid,\n                name: \"Bitku #\".concat(id.toString()),\n                description:\"\",\n                image: nft.text,\n                url: \"https://bitku.art/#\".concat(address.toString()).concat(\"/\").concat(id.toString()),\n                contentType: \"text\",\n                rarity: \"\",\n                minter:\"\",\n                type:nft.getType(),\n                collection:mc\n            )\n\n            items.append(item)\n        }\n    }\n\n    */\n    let klktnCap = account.getCapability\u003c\u0026{KlktnNFT.KlktnNFTCollectionPublic}\u003e(KlktnNFT.CollectionPublicPath)\n    if klktnCap.check() {\n        let nfts = klktnCap.borrow()!\n\n        let mc= MetadataCollection(path: KlktnNFT.CollectionPublicPath, type: nfts.getType() , conformance: \"KlktnNFT.KlktnNFTCollectionPublic\", domainUrl: \"https://klktn.com\", category: \"KLKTN\", legacyIdentifierPrefix: \"KLKTN\", transferable:true)\n        for id in nfts.getIDs() {\n            let nft = nfts.borrowKlktnNFT(id: id)!\n\n            let metadata=nft.getNFTMetadata()\n            /*\n\n            Result: {\"uri\": \"ipfs://bafybeifsiousmtmcruuelgyiku3xa5hmw7ylsyqfdvpjsea7r4xa74bhym\", \"name\": \"Kevin Woo - What is KLKTN?\", \"mimeType\": \"video/mp4\", \"media\": \"https://ipfs.io/ipfs/bafybeifsiousmtmcruuelgyiku3xa5hmw7ylsyqfdvpjsea7r4xa74bhym/fb91ad34d61dde04f02ad240f0ca924902d8b4a3da25daaf0bb1ed769977848c.mp4\", \"description\": \"K-pop sensation Kevin Woo has partnered up with KLKTN to enhance his artist to fan interactions and experiences within his fandom. Join our chat to learn more: https://discord.gg/UJxb4erfUw\"}\n\n            */\n            let item = MetadataCollectionItem(\n                id: id,\n                uuid:nft.uuid,\n                name: metadata[\"name\"]!,\n                description: metadata[\"description\"]!,\n                image: metadata[\"media\"]!,\n                url: \"https://klktn.com/\",\n                contentType: \"video\", //metadata[\"mimeType\"]!,\n                rarity: \"\",\n                minter:\"\",\n                type:nft.getType(),\n                collection:mc\n            )\n            items.append(item)\n        }\n    }\n\n    let mynftCap = account.getCapability\u003c\u0026{Mynft.MynftCollectionPublic}\u003e(Mynft.CollectionPublicPath)\n    if mynftCap.check() {\n        let nfts = mynftCap.borrow()!\n\n        let mc= MetadataCollection(path: Mynft.CollectionPublicPath, type: nfts.getType() , conformance: \"Mynft.MynftCollectionPublic\", domainUrl: \"https://mynft.io\", category: \"mynft\", legacyIdentifierPrefix: \"mynft\", transferable:true)\n        for id in nfts.getIDs() {\n            let nft = nfts.borrowArt(id: id)!\n            let metadata=nft.metadata\n\n            var image= metadata.ipfsLink\n            if image == \"\" {\n                image=\"https://arweave.net/\".concat(metadata.arLink)\n            }\n            let item = MetadataCollectionItem(\n                id: id,\n                uuid:nft.uuid,\n                name: metadata.name,\n                description:metadata.description,\n                image: image,\n                url: \"http://mynft.io\",\n                contentType: metadata.type,\n                rarity: \"\",\n                minter:\"\",\n                type:nft.getType(),\n                collection:mc\n            )\n            items.append(item)\n        }\n    }\n\n    /*\n    : add when url fixed\n    let beamCap = account.getCapability\u003c\u0026{Beam.BeamCollectionPublic}\u003e(Beam.CollectionPublicPath)\n        if beamCap.check() {\n        let nfts = beamCap.borrow()!\n\n        let mc= MetadataCollection(path: Beam.CollectionPublicPath, type: nfts.getType() , conformance: \"Beam.BeamCollectionPublic\", domainUrl: \"https://https://frightclub.niftory.com\", category: \"FrightClub\", legacyIdentifierPrefix: \"FrightClub\", transferable:true)\n        for id in nfts.getIDs() {\n            let nft = nfts.borrowCollectible(id: id)!\n\n        let metadata = Beam.getCollectibleItemMetaData(collectibleItemID: nft.data.collectibleItemID)!\n          var mediaUrl: String? = metadata[\"mediaUrl\"]\n            if mediaUrl != nil \u0026\u0026  mediaUrl!.slice(from: 0, upTo: 7) != \"ipfs://\" {\n                mediaUrl = \"ipfs://\".concat(mediaUrl!)\n            }\n            let item = MetadataCollectionItem(\n                id: id,\n                uuid:nft.uuid,\n                name: metadata[\"title\"]!,\n                description: metadata[\"description\"] ?? \"\",\n                image: mediaUrl ?? \"\",\n                url: \"https://\".concat(metadata[\"domainUrl\"]!),\n                contentType: metadata[\"mediaType\"]!,\n                rarity: \"\",\n                minter:\"\",\n                type:nft.getType(),\n                collection:mc\n            )\n            items.append(item)\n        }\n    }\n    */\n\n    collection.addCollection(items: items)\n\n    //Adding a collection that supports the metadata standard is SOOO much easier\n    collection.addMetadataCollection(path: NeoAvatar.CollectionPublicPath, account: account, category: \"Neo\", legacyIdentifierPrefix: \"NeoAvatar\", url: \"https://neocollectibles.xyz\", transferable: true)\n\n    if collection.collections.length==0 {\n        return nil\n    }\n    return collection\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "mainnet_getCollections_old": {
               "code": "import NonFungibleToken from 0xf8d6e0586b0a20c7\nimport CharityNFT from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\n\n//mainnet\nimport Beam from 0x86b4a0010a71cfc3 \nimport Art from 0xd796ff17107bbff6\nimport Marketplace from 0xd796ff17107bbff6\nimport GooberXContract from 0x34f2bf4a80bb0f69\nimport Flovatar from 0x921ea449dffec68a\nimport FlovatarMarketplace from  0x921ea449dffec68a\nimport RareRooms_NFT from 0x329feb3ab062d289\nimport CNN_NFT from 0x329feb3ab062d289\nimport Canes_Vault_NFT from 0x329feb3ab062d289\nimport DGD_NFT from 0x329feb3ab062d289\nimport RaceDay_NFT from 0x329feb3ab062d289\nimport The_Next_Cartel_NFT from 0x329feb3ab062d289\nimport UFC_NFT from 0x329feb3ab062d289\nimport MotoGPCard from 0xa49cc0ee46c54bfb\nimport Gaia from 0x8b148183c28ff88f\nimport ChainmonstersRewards from 0x93615d25d14fa337\nimport Moments from 0xd4ad4740ee426334\nimport MatrixWorldFlowFestNFT from 0x2d2750f240198f91\nimport MatrixWorldAssetsNFT from 0xf20df769e658c257\n\nimport SturdyItems from 0x427ceada271aa0b1\nimport Evolution from 0xf4264ac8f3256818\nimport GeniaceNFT from 0xabda6627c70c7f52\nimport OneFootballCollectible from 0x6831760534292098\nimport CryptoPiggo from 0xd3df824bf81910a4\nimport GoatedGoatsVouchers from 0xdfc74d9d561374c0\nimport TraitPacksVouchers from 0xdfc74d9d561374c0\nimport GoatedGoats from 0x2068315349bdfce5\nimport GoatedGoatsTrait from 0x2068315349bdfce5\nimport GoatedGoatsTraitPack from 0x2068315349bdfce5\n\nimport HaikuNFT from 0xf61e40c19db2a9e2\nimport KlktnNFT from 0xabd6e80be7e9682c\nimport Mynft from 0xf6fcbef550d97aa5\nimport NeoAvatar from 0xb25138dbf45e5801\nimport NeoVoucher from 0xb25138dbf45e5801\nimport NeoMember from 0xb25138dbf45e5801\nimport NeoViews from 0xb25138dbf45e5801\nimport MetadataViews from 0x1d7e57aa55817448\nimport BarterYardPackNFT from 0xa95b021cf8a30d80\nimport BarterYardClubWerewolf from  0x28abb9f291cadaf2\n\n//Jambb\nimport Vouchers from 0x444f5ea22c6ea12c\n\n//xtingles\nimport Collectible from 0xf5b0eb433389ac3f\n\nimport StarlyCard from 0x5b82f21c0edf76e3\nimport StarlyMetadataViews from 0x5b82f21c0edf76e3\nimport Momentables from 0x9d21537544d9123d\nimport ZeedzINO from 0x62b3063fbe672fc8\nimport PartyMansionDrinksContract from 0x34f2bf4a80bb0f69\n\npub struct MetadataCollections {\n\n    pub let items: {String : MetadataCollectionItem}\n    pub let collections: {String : [String]}\n    pub let curatedCollections: {String : [String]}\n\n    init(items: {String : MetadataCollectionItem}, collections: {String : [String]}, curatedCollections: {String: [String]}) {\n        self.items=items\n        self.collections=collections\n        self.curatedCollections=curatedCollections\n    }\n}\n\n\npub struct MetadataCollection{\n    pub let type: String\n    pub let items: [MetadataCollectionItem]\n\n    init(type:String, items: [MetadataCollectionItem]) {\n        self.type=type\n        self.items=items\n    }\n}\n\n\npub struct MetadataCollectionItem {\n    pub let id:UInt64\n    pub let name: String\n    pub let image: String\n    pub let url: String\n    pub let listPrice: UFix64?\n    pub let listToken: String?\n    pub let contentType:String\n    pub let rarity:String\n\n\n    init(id:UInt64, name:String, image:String, url:String, listPrice: UFix64?, listToken:String?, contentType: String, rarity: String) {\n        self.id=id\n        self.name=name\n        self.url=url\n        self.image=image\n        self.listToken=listToken\n        self.listPrice=listPrice\n        self.contentType=contentType\n        self.rarity=rarity\n    }\n}\n\npub fun main(user: String) : MetadataCollections? {\n\n    let resolvingAddress = FIND.resolve(user)\n    if resolvingAddress == nil {\n        return nil\n    }\n    let address = resolvingAddress!\n    let resultMap : {String : MetadataCollectionItem} = {}\n    let account = getAccount(address)\n    let results : {String :  [String]}={}\n\n    let flovatarList= Flovatar.getFlovatars(address: address)\n    let flovatarMarketDetails = FlovatarMarketplace.getFlovatarSales(address: address)\n    if flovatarList.length \u003e 0 || flovatarMarketDetails.length \u003e 0 {\n        let items: [String] = []\n        for flovatar in flovatarList  {\n            var name = flovatar.name\n            if name == \"\" {\n                name=\"Flovatar #\".concat(flovatar.id.toString())\n            }\n\n            var rarity=\"common\"\n            if flovatar.metadata.legendaryCount \u003e 0 {\n                rarity=\"legendary\"\n            }else if flovatar.metadata.epicCount \u003e 0 {\n                rarity=\"epic\"\n            }else if flovatar.metadata.rareCount \u003e 0 {\n                rarity=\"rare\"\n            }\n\n\n            let item=MetadataCollectionItem(\n                id: flovatar.id, \n                name: name, \n                image: \"https://flovatar.com/api/image/\".concat(flovatar.id.toString()),\n                url: \"https://flovatar.com/flovatars/\".concat(flovatar.id.toString()).concat(\"/\"),\n                listPrice: nil,\n                listToken: nil,\n                contentType: \"image\",\n                rarity: rarity\n            )\n            let itemId=\"Flovatar\".concat(flovatar.id.toString())\n            items.append(itemId)\n            resultMap[itemId] = item\n        }\n\n        for flovatar in flovatarMarketDetails  {\n            var    name=\"Flovatar #\".concat(flovatar.id.toString())\n\n            var rarity=\"common\"\n            if flovatar.metadata.legendaryCount \u003e 0 {\n                rarity=\"legendary\"\n            }else if flovatar.metadata.epicCount \u003e 0 {\n                rarity=\"epic\"\n            }else if flovatar.metadata.rareCount \u003e 0 {\n                rarity=\"rare\"\n            }\n\n\n            let item=MetadataCollectionItem(\n                id: flovatar.id, \n                name: name, \n                image: \"https://flovatar.com/api/image/\".concat(flovatar.id.toString()),\n                url: \"https://flovatar.com/flovatars/\".concat(flovatar.id.toString()).concat(\"/\"),\n                listPrice: flovatar.price,\n                listToken: \"Flow\",\n                contentType: \"image\",\n                rarity: rarity\n            )\n\n            let itemId=\"Flovatar\".concat(flovatar.id.toString())\n            items.append(itemId)\n            resultMap[itemId] = item\n\n        }\n\n        if items.length != 0 {\n            results[\"Flovatar\"] = items\n        }\n    }\n\n    let versusMarketplace = account.getCapability\u003c\u0026{Marketplace.SalePublic}\u003e(Marketplace.CollectionPublicPath)\n    let versusImageUrlPrefix = \"https://res.cloudinary.com/dxra4agvf/image/upload/c_fill,w_600/f_auto/maincache\"\n    let artList = Art.getArt(address: address)\n    if artList.length \u003e 0 || versusMarketplace.check() {\n        let items: [String] = []\n        for art in artList {\n            let item=MetadataCollectionItem(\n                id: art.id, \n                name: art.metadata.name.concat(\" edition \").concat(art.metadata.edition.toString()).concat(\"/\").concat(art.metadata.maxEdition.toString()).concat(\" by \").concat(art.metadata.artist),  \n                image: versusImageUrlPrefix.concat(art.cacheKey), \n                url: \"https://www.versus.auction/piece/\".concat(address.toString()).concat(\"/\").concat(art.id.toString()).concat(\"/\"),\n                listPrice: nil,\n                listToken: nil,\n                contentType: \"image\",\n                rarity: \"\"\n            )\n            let itemId=\"Versus\".concat(art.id.toString())\n            items.append(itemId)\n            resultMap[itemId] = item\n\n        }\n        if versusMarketplace.check() {\n            let versusMarket = versusMarketplace.borrow()!.listSaleItems()\n            for saleItem in versusMarket {\n                let item=MetadataCollectionItem(\n                    id: saleItem.id, \n                    name: saleItem.art.name.concat(\" edition \").concat(saleItem.art.edition.toString()).concat(\"/\").concat(saleItem.art.maxEdition.toString()).concat(\" by \").concat(saleItem.art.artist),\n                    image: versusImageUrlPrefix.concat(saleItem.cacheKey), \n                    url: \"https://www.versus.auction/listing/\".concat(saleItem.id.toString()).concat(\"/\"),\n                    listPrice: saleItem.price,\n                    listToken: \"Flow\",\n                    contentType: \"image\",\n                    rarity: \"\"\n                )\n\n                let itemId=\"Versus\".concat(saleItem.id.toString())\n                items.append(itemId)\n                resultMap[itemId] = item\n            }\n        }\n        if items.length != 0 {\n            results[\"Versus\"]= items\n        }\n    }\n\n\n\n\n    let partyMansion: [String] = []\n    let goobersCap = account.getCapability\u003c\u0026GooberXContract.Collection{NonFungibleToken.CollectionPublic, GooberXContract.GooberCollectionPublic}\u003e(GooberXContract.CollectionPublicPath)\n    if goobersCap.check() {\n        let goobers = goobersCap.borrow()!.listUsersGoobers()\n        for id in goobers.keys {\n            let goober = goobers[id]!\n            let item=MetadataCollectionItem(\n                id: id,\n                name: \"Goober #\".concat(id.toString()),\n                image: goober.uri,\n                url: \"https://partymansion.io/gooberz/\".concat(id.toString()),\n                listPrice: nil,\n                listToken: nil,\n                contentType: \"image\",\n                rarity: \"\"\n            )\n            let itemId=\"Gooberz\".concat(id.toString())\n            partyMansion.append(itemId)\n            resultMap[itemId] = item\n        }\n    }\n\n\n    let partyMansionDrinksCap = account.getCapability\u003c\u0026{PartyMansionDrinksContract.DrinkCollectionPublic}\u003e(PartyMansionDrinksContract.CollectionPublicPath)\n    if partyMansionDrinksCap.check() {\n        let collection = partyMansionDrinksCap.borrow()!\n        for id in collection.getIDs() {\n            let nft = collection.borrowDrink(id: id)!\n            let item = MetadataCollectionItem(\n                id: id,\n                name: nft.data.description,\n                image: \"ipfs://\".concat(nft.imageCID()),\n                url: \"https://partymansion.io\",\n                listPrice: nil,\n                listToken: nil,\n                contentType: \"image\",\n                rarity: PartyMansionDrinksContract.rarityToString(rarity:nft.data.rarity)\n            )\n\n            let itemId=\"PartyMansionDrinks\".concat(id.toString())\n            partyMansion.append(itemId)\n            resultMap[itemId] = item\n        }\n    }\n\n    if partyMansion.length != 0 {\n        results[\"PartyMansion\"] = partyMansion\n    }\n\n    let rareRoomCap = account.getCapability\u003c\u0026RareRooms_NFT.Collection{RareRooms_NFT.RareRooms_NFTCollectionPublic}\u003e(RareRooms_NFT.CollectionPublicPath)\n    if rareRoomCap.check() {\n        let collection = rareRoomCap.borrow()!\n        let items: [String] = []\n        for id in collection.getIDs() {\n            let nft = collection.borrowRareRooms_NFT(id: id)!\n            let metadata = RareRooms_NFT.getSetMetadata(setId: nft.setId)!\n            let item = MetadataCollectionItem(\n                id: id,\n                name: metadata[\"name\"]!,\n                image: metadata[\"preview\"]!,\n                url: \"https://rarerooms.io/tokens/\".concat(id.toString()),\n                listPrice: nil,\n                listToken: nil,\n                contentType: \"image\",\n                rarity: \"\"\n            )\n\n            let itemId=\"RareRooms\".concat(id.toString())\n            items.append(itemId)\n            resultMap[itemId] = item\n        }\n\n        if items.length != 0 {\n            results[\"RareRooms\"] = items\n        }\n    }\n\n    let cnnCap = account.getCapability\u003c\u0026CNN_NFT.Collection{CNN_NFT.CNN_NFTCollectionPublic}\u003e(CNN_NFT.CollectionPublicPath)\n    if cnnCap.check() {\n        let collection = cnnCap.borrow()!\n        let items: [String] = []\n        for id in collection.getIDs() {\n            let nft = collection.borrowCNN_NFT(id: id)!\n            let metadata = CNN_NFT.getSetMetadata(setId: nft.setId)!\n\n            var image= metadata[\"preview\"]!\n            var contentType=\"image\"\n            /*\n            if metadata[\"image_file_type\"]! == \"mp4\" {\n                image=metadata[\"image\"]!\n                contentType=\"video\"\n            }\n            */\n            let item = MetadataCollectionItem(\n                id: id,\n                name: metadata[\"name\"]!,\n                image: image,\n                url: \"http://vault.cnn.com\",\n                listPrice: nil,\n                listToken: nil,\n                contentType: contentType,\n                rarity: \"\"\n            )\n\n            let itemId=\"CNN\".concat(id.toString())\n            items.append(itemId)\n            resultMap[itemId] = item\n        }\n\n        if items.length != 0 {\n            results[\"CNN\"] = items\n        }\n    }\n\n    let canesVaultCap = account.getCapability\u003c\u0026Canes_Vault_NFT.Collection{Canes_Vault_NFT.Canes_Vault_NFTCollectionPublic}\u003e(Canes_Vault_NFT.CollectionPublicPath)\n    if canesVaultCap.check() {\n        let collection = canesVaultCap.borrow()!\n        let items: [String] = []\n        for id in collection.getIDs() {\n            let nft = collection.borrowCanes_Vault_NFT(id: id)!\n            let metadata = Canes_Vault_NFT.getSetMetadata(setId: nft.setId)!\n            var image= metadata[\"preview\"]!\n            var contentType=\"image\"\n            /*\n            if metadata[\"image_file_type\"]! == \"mp4\" {\n                image=metadata[\"image\"]!\n                contentType=\"video\"\n            }\n            */\n\n            let item = MetadataCollectionItem(\n                id: id,\n                name: metadata[\"name\"]!,\n                image: image,\n                url: \"https://canesvault.com/\",\n                listPrice: nil,\n                listToken: nil,\n                contentType: contentType,\n                rarity: \"\"\n            )\n\n            let itemId=\"Canes_Vault_NFT\".concat(id.toString())\n            items.append(itemId)\n            resultMap[itemId] = item\n        }\n\n        if items.length != 0 {\n            results[\"Canes_Vault_NFT\"] = items\n        }\n    }\n\n    let dgdCap = account.getCapability\u003c\u0026DGD_NFT.Collection{DGD_NFT.DGD_NFTCollectionPublic}\u003e(DGD_NFT.CollectionPublicPath)\n    if dgdCap.check() {\n        let collection = dgdCap.borrow()!\n        let items: [String] = []\n        for id in collection.getIDs() {\n            let nft = collection.borrowDGD_NFT(id: id)!\n            let metadata = DGD_NFT.getSetMetadata(setId: nft.setId)!\n            var image= metadata[\"preview\"]!\n            var contentType=\"image\"\n            /*\n            if metadata[\"image_file_type\"]! == \"mp4\" {\n                image=metadata[\"image\"]!\n                contentType=\"video\"\n            }\n            */\n\n\n            let item = MetadataCollectionItem(\n                id: id,\n                name: metadata[\"name\"]!,\n                image: image,\n                url: \"https://www.theplayerslounge.io/\",\n                listPrice: nil,\n                listToken: nil,\n                contentType: contentType,\n                rarity: \"\"\n            )\n\n            let itemId=\"DGD_NFT\".concat(id.toString())\n            items.append(itemId)\n            resultMap[itemId] = item\n        }\n\n        if items.length != 0 {\n            results[\"DGD_NFT\"] = items\n        }\n    }\n\n    let raceDayCap = account.getCapability\u003c\u0026RaceDay_NFT.Collection{RaceDay_NFT.RaceDay_NFTCollectionPublic}\u003e(RaceDay_NFT.CollectionPublicPath)\n    if raceDayCap.check() {\n        let collection = raceDayCap.borrow()!\n        let items: [String] = []\n        for id in collection.getIDs() {\n            let nft = collection.borrowRaceDay_NFT(id: id)!\n            let metadata = RaceDay_NFT.getSetMetadata(setId: nft.setId)!\n            var image= metadata[\"preview\"]!\n            var contentType=\"image\"\n            /*\n            if metadata[\"image_file_type\"]! == \"mp4\" {\n                image=metadata[\"image\"]!\n                contentType=\"video\"\n            }\n            */\n\n\n            let item = MetadataCollectionItem(\n                id: id,\n                name: metadata[\"name\"]!,\n                image: image, \n                url: \"https://www.racedaynft.com\",\n                listPrice: nil,\n                listToken: nil,\n                contentType: contentType,\n                rarity: \"\"\n            )\n\n            let itemId=\"RaceDay_NFT\".concat(id.toString())\n            items.append(itemId)\n            resultMap[itemId] = item\n        }\n\n        if items.length != 0 {\n            results[\"RaceDay_NFT\"] = items\n        }\n    }\n\n    let nextCartelCap = account.getCapability\u003c\u0026The_Next_Cartel_NFT.Collection{The_Next_Cartel_NFT.The_Next_Cartel_NFTCollectionPublic}\u003e(The_Next_Cartel_NFT.CollectionPublicPath)\n    if nextCartelCap.check() {\n        let collection = nextCartelCap.borrow()!\n        let items: [String] = []\n        for id in collection.getIDs() {\n            let nft = collection.borrowThe_Next_Cartel_NFT(id: id)!\n            let metadata = The_Next_Cartel_NFT.getSetMetadata(setId: nft.setId)!\n            var image= metadata[\"preview\"]!\n            var contentType=\"image\"\n            let item = MetadataCollectionItem(\n                id: id,\n                name: metadata[\"name\"]!,\n                // we use \"preview\" and not \"image\" because of potential .glg and .mp4 file types\n                image: image,\n                url: \"https://thenextcartel.com/\",\n                listPrice: nil,\n                listToken: nil,\n                contentType: contentType,\n                rarity: \"\"\n            )\n\n            let itemId=\"The_Next_Cartel_NFT\".concat(id.toString())\n            items.append(itemId)\n            resultMap[itemId] = item\n        }\n\n        if items.length != 0 {\n            results[\"The_Next_Cartel_NFT\"] = items\n        }\n    }\n\n    let ufcCap = account.getCapability\u003c\u0026UFC_NFT.Collection{UFC_NFT.UFC_NFTCollectionPublic}\u003e(UFC_NFT.CollectionPublicPath)\n    if ufcCap.check() {\n        let collection = ufcCap.borrow()!\n        let items: [String] = []\n        for id in collection.getIDs() {\n            let nft = collection.borrowUFC_NFT(id: id)!\n            let metadata = UFC_NFT.getSetMetadata(setId: nft.setId)!\n            var image= metadata[\"image\"]!\n            var contentType=\"video\"\n            let item = MetadataCollectionItem(\n                id: id,\n                name: metadata[\"name\"]!,\n                image: image,\n                url: \"https://www.ufcstrike.com\",\n                listPrice: nil,\n                listToken: nil,\n                contentType: contentType,\n                rarity: \"\"\n            )\n\n            let itemId=\"UFC\".concat(id.toString())\n            items.append(itemId)\n            resultMap[itemId] = item\n        }\n\n        if items.length != 0 {\n            results[\"UFC\"] = items\n        }\n    }\n\n    let motoGPCollection = account.getCapability\u003c\u0026MotoGPCard.Collection{MotoGPCard.ICardCollectionPublic}\u003e(/public/motogpCardCollection)\n    if motoGPCollection.check() {\n        let motoGPNfts = motoGPCollection.borrow()!.getIDs()\n        let items: [String] = []\n        for id in motoGPNfts {\n            let nft = motoGPCollection.borrow()!.borrowCard(id: id)!\n            let metadata = nft.getCardMetadata()!\n            let item=MetadataCollectionItem(\n                id: id,\n                name: metadata.name,\n                image: metadata.imageUrl,\n                url: \"https://motogp-ignition.com/nft/card/\".concat(id.toString()).concat(\"?owner=\").concat(address.toString()),\n                listPrice: nil,\n                listToken: nil,\n                contentType: \"image\",\n                rarity: \"\"\n            )\n\n\n            let itemId=\"MotoGP\".concat(id.toString())\n            items.append(itemId)\n            resultMap[itemId] = item\n        }\n\n        if items.length != 0 {\n            results[\"MotoGP\"] = items\n        }\n    }\n\n    let gaiaCollection = account.getCapability\u003c\u0026{Gaia.CollectionPublic}\u003e(Gaia.CollectionPublicPath)\n    if gaiaCollection.check() {\n\n        let gaiaNfts = gaiaCollection.borrow()!.getIDs()\n        let items: [String] = []\n        for id in gaiaNfts {\n            let nft = gaiaCollection.borrow()!.borrowGaiaNFT(id: id)!\n            let metadata = Gaia.getTemplateMetaData(templateID: nft.data.templateID)!\n\n            //For ballerz we can do this...\n            var url=\"http://ongaia.com/ballerz/\".concat(metadata[\"id\"]!)\n            var name=metadata[\"title\"]!\n\n            if let seriesFullName=metadata[\"series\"] {\n\n                if seriesFullName==\"Shareef O\\u{2019}Neal - Basketball\" {\n                    //If the series is basketball with shareef we can do this\n                    url=\"http://ongaia.com/sharef/\".concat(id.toString())\n                    name=metadata[\"title\"]!.concat(\" #\").concat(nft.data.mintNumber.toString())\n                }else if seriesFullName==\"Bryson DeChambeau - Vegas, Baby!\" {\n                    //For golf there is yet another way\n                    url=\"http://ongaia.com/bryson/\".concat(nft.data.mintNumber.toString())\n                    name=metadata[\"title\"]!.concat(\" #\").concat(nft.data.mintNumber.toString())\n                }\n            }\n\n            let item= MetadataCollectionItem(\n                id: id,\n                name: name,\n                image: metadata[\"img\"]!,\n                url: url,\n                listPrice: nil,\n                listToken: nil,\n                contentType: \"image\",\n                rarity: \"\"\n            )\n\n            let itemId=\"Gaia\".concat(id.toString())\n            items.append(itemId)\n            resultMap[itemId] = item\n        }\n\n        if items.length != 0 {\n            results[\"Gaia\"] = items\n        }\n    }\n\n    /*\n    let chamonsterSeasonTable :  {UInt32: String} = {0 : \"kickstarter\", 1 : \"alpha\", 2 : \"genesis\", 4 : \"flowfest2021\" , 3: \"closedbeta\" }\n\n    let chainmonstersRewardsCollection = account.getCapability\u003c\u0026{ChainmonstersRewards.ChainmonstersRewardCollectionPublic}\u003e(/public/ChainmonstersRewardCollection)\n    if chainmonstersRewardsCollection.check() {\n        let nfts = chainmonstersRewardsCollection.borrow()!.getIDs()\n        let items: [MetadataCollectionItem] = []\n        for id in nfts {\n            let nft = chainmonstersRewardsCollection.borrow()!.borrowReward(id: id)!\n            let rewardID = nft.data.rewardID\n            // Other interesting metadata available are:\n            //         - serialNumber: nft.data.serialNumber\n            //         - totalMinted: ChainmonstersRewards.getNumRewardsMinted(rewardID: nft.data.rewardID)!\n            let season = ChainmonstersRewards.getRewardSeason(rewardID:nft.data.rewardID)!\n\n            var seasonName = chamonsterSeasonTable[season] ?? \"unknown\".concat(season.toString())\n\n            if season == 3 \u0026\u0026 rewardID \u003c 45 {\n                seasonName = \"flowfest2021\"\n            }\n            items.append(MetadataCollectionItem(\n                id: id,\n                name: ChainmonstersRewards.getRewardMetaData(rewardID: nft.data.rewardID)!,\n                image: \"https://chainmonsters.com/images/rewards/\".concat(seasonName).concat(\"/\").concat(rewardID.toString()).concat(\".png\"),\n                url: \"https://chainmonsters.com\",\n                listPrice: nil,\n                listToken: nil,\n                contentType: \"image\"\n            ))\n        }\n        if items.length != 0 {\n            results[\"ChainmonstersRewards\"] = MetadataCollection(type: Type\u003c@ChainmonstersRewards.Collection\u003e().identifier, items: items)\n        }\n    }\n    */\n\n    let jambb: [String] = []\n    let jambbCap = account.getCapability\u003c\u0026Moments.Collection{Moments.CollectionPublic}\u003e(Moments.CollectionPublicPath)\n    if jambbCap.check() {\n        let nfts = jambbCap.borrow()!.getIDs()\n        for id in nfts {\n            let nft = jambbCap.borrow()!.borrowMoment(id: id)!\n            let metadata=nft.getMetadata()\n            let item  =MetadataCollectionItem(\n                id: id,\n                name: metadata.contentName,\n                image: \"ipfs://\".concat(metadata.videoHash),\n                url: \"https://www.jambb.com/c/moment/\".concat(id.toString()),\n                listPrice: nil,\n                listToken: nil,\n                contentType: \"video\",\n                rarity: \"\"\n            )\n            let itemId=\"Jambb\".concat(id.toString())\n            jambb.append(itemId)\n            resultMap[itemId] = item\n        }\n    }\n\n    let voucherCap = account.getCapability\u003c\u0026{Vouchers.CollectionPublic}\u003e(Vouchers.CollectionPublicPath)\n    if voucherCap.check() {\n        let collection = voucherCap.borrow()!\n        for id in collection.getIDs() {\n            let nft = collection.borrowVoucher(id: id)!\n            let metadata=nft.getMetadata()!\n\n            let url=\"https://jambb.com\"\n            let item = MetadataCollectionItem(\n                id: id,\n                name: metadata.name,\n                image: \"ipfs://\".concat(metadata.mediaHash),\n                url: url,\n                listPrice: nil,\n                listToken: nil,\n                contentType: metadata.mediaType,\n                rarity: \"\"\n            )\n            let itemId=\"JambbVoucher\".concat(id.toString())\n            jambb.append(itemId)\n            resultMap[itemId] = item\n        }\n\n\n    }\n\n    if jambb.length != 0 {\n        results[\"Jambb\"] = jambb\n    }\n\n    let mw = MatrixWorldFlowFestNFT.getNft(address:address)\n    let mwItems: [String] = []\n    if mw.length \u003e 0 {\n        for nft in mw {\n            let metadata=nft.metadata\n            let item=MetadataCollectionItem(\n                id: nft.id,\n                name: metadata.name,\n                image: metadata.animationUrl,\n                url: \"https://matrixworld.org/\",\n                listPrice: nil,\n                listToken: nil,\n                contentType: \"image\",\n                rarity: \"\"\n            )\n            let itemId=\"MatrixWorldFlowFest\".concat(nft.id.toString())\n            mwItems.append(itemId)\n            resultMap[itemId] = item\n        }\n\n    }\n\n    let matrixworldAsset = account.getCapability\u003c\u0026{MatrixWorldAssetsNFT.Metadata, NonFungibleToken.CollectionPublic}\u003e(MatrixWorldAssetsNFT.collectionPublicPath)\n    if matrixworldAsset.check() {\n        let collection = matrixworldAsset.borrow()!\n        for id in collection.getIDs() {\n            let metadata = collection.getMetadata(id: id)!\n\n\n            /*\n            Result: {\"collection\": \"MW x Flow Holiday Giveaway\", \"description\": \"First Edition Matrix World Santa Hat. Only 50 pieces made.\", \"animation_url\": \"\", \"image\": \"https://d2yoccx42eml7e.cloudfront.net/airdrop/MWxFlowxHoliday/Santa_Hat.png\", \"name\": \"First Edition Santa Hat\", \"external_url\": \"https://matrixworld.org/home\", \"version\": \"assets-v0.1.1\", \"attributes\": \"\"}\n            */\n            let item = MetadataCollectionItem(\n                id: id,\n                name: metadata[\"name\"]!,\n                image: metadata[\"image\"]!,\n                url: metadata[\"external_url\"]!,\n                listPrice: nil,\n                listToken: nil,\n                contentType: \"image\",\n                rarity: \"\"\n            )\n            let itemId=\"MatrixWorldAsset\".concat(id.toString())\n            mwItems.append(itemId)\n            resultMap[itemId] = item\n        }\n    }\n\n    if mwItems.length != 0 {\n        results[\"MatrixWorld\"] = mwItems\n    }\n\n    let sturdyCollectionCap = account.getCapability\u003c\u0026SturdyItems.Collection{SturdyItems.SturdyItemsCollectionPublic}\u003e(SturdyItems.CollectionPublicPath)\n    if sturdyCollectionCap.check() {\n        let sturdyNfts = sturdyCollectionCap.borrow()!.getIDs()\n        let items: [String] = []\n        for id in sturdyNfts {\n            // the metadata is a JSON stored on IPFS at the address nft.tokenURI\n            let nft = sturdyCollectionCap.borrow()!.borrowSturdyItem(id: id)!\n            // the only thing we can play with is the nft title which is for example:\n            //     - \"HOODLUM#10\"\n            //     - \"HOLIDAY MYSTERY BADGE 2021\"\n            //  - \"EXCALIBUR\"\n            let isHoodlum = nft.tokenTitle.slice(from: 0, upTo: 7) == \"HOODLUM\"\n            if isHoodlum {\n                // the hoodlum id is needed to retrieve the image but is not in the nft\n                let hoodlumId = nft.tokenTitle.slice(from: 8, upTo: nft.tokenTitle.length)\n                let item=MetadataCollectionItem(\n                    id: id,\n                    name: nft.tokenTitle,\n                    image: \"https://hoodlumsnft.com/_next/image?url=%2Fthumbs%2FsomeHoodlum_\".concat(hoodlumId).concat(\".png\u0026w=1920\u0026q=75\"),\n                    url: \"https://hoodlumsnft.com/\",\n                    listPrice:nil,\n                    listToken:nil,\n                    contentType:\"image\",\n                    rarity: \"\"\n                )\n                let itemId=\"Hoodlums\".concat(id.toString())\n                items.append(itemId)\n                resultMap[itemId] = item\n            }\n        }\n        if items.length != 0 {\n            results[\"Hoodlums\"] = items\n        }\n    }\n\n    let charityCap = account.getCapability\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection)\n    if charityCap.check() {\n        let items: [String] = []\n        let collection = charityCap.borrow()!\n        for id in collection.getIDs() {\n            let nft = collection.borrowCharity(id: id)!\n            let metadata = nft.getMetadata()\n            let item=MetadataCollectionItem(\n                id: id,\n                name: metadata[\"name\"]!,\n                image: metadata[\"thumbnail\"]!,\n                url: metadata[\"originUrl\"]!,\n                listPrice: nil,\n                listToken: nil,\n                contentType:\"image\",\n                rarity: \"\"\n            )\n            let itemId=\"Charity\".concat(id.toString())\n            items.append(itemId)\n            resultMap[itemId] = item\n\n        }\n        if items.length != 0 {\n            results[\"Find\"] = items\n        }\n    }\n\n    let evolutionCap=account.getCapability\u003c\u0026{Evolution.EvolutionCollectionPublic}\u003e(/public/f4264ac8f3256818_Evolution_Collection)\n    if evolutionCap.check() {\n        let evolution=evolutionCap.borrow()!\n        let nfts = evolution.getIDs()\n        let items: [String] = []\n        for id in nfts{\n            // the metadata is a JSON stored on IPFS at the address nft.tokenURI\n            let nft = evolution.borrowCollectible(id: id)!\n            let metadata = Evolution.getItemMetadata(itemId: nft.data.itemId)!\n            let item=MetadataCollectionItem(\n                id: id,\n                name: metadata[\"Title\"]!.concat(\" #\").concat(nft.data.serialNumber.toString()),\n                image: \"https://storage.viv3.com/0xf4264ac8f3256818/mv/\".concat(nft.data.itemId.toString()),\n                url: \"https://www.evolution-collect.com/\",\n                listPrice: nil,\n                listToken: nil,\n                contentType:\"video\",\n                rarity: \"\"\n            )\n\n            let itemId=\"Evolution\".concat(id.toString())\n            items.append(itemId)\n            resultMap[itemId] = item\n        }\n\n        if items.length != 0 {\n            results[\"Evolution\"] = items\n        }\n    }\n\n\n    let geniaceCap = account.getCapability\u003c\u0026GeniaceNFT.Collection{NonFungibleToken.CollectionPublic, GeniaceNFT.GeniaceNFTCollectionPublic}\u003e(GeniaceNFT.CollectionPublicPath)\n    if geniaceCap.check() {\n        let geniace=geniaceCap.borrow()!\n        let nfts = geniace.getIDs()\n        let items: [String] = []\n        for id in nfts{\n            // the metadata is a JSON stored on IPFS at the address nft.tokenURI\n            let nft = geniace.borrowGeniaceNFT(id: id)!\n            let metadata = nft.metadata\n            var rarity=\"\"\n            if metadata.rarity == GeniaceNFT.Rarity.Collectible {\n                rarity=\"Collectible\"\n            }else if metadata.rarity == GeniaceNFT.Rarity.Rare {\n                rarity=\"Rare\"\n            }else if metadata.rarity == GeniaceNFT.Rarity.UltraRare {\n                rarity=\"UltraRare\"\n            }\n\n            let item=MetadataCollectionItem(\n                id: id,\n                name: metadata.name,\n                image: metadata.imageUrl,\n                url: \"https://www.geniace.com/product/\".concat(id.toString()),\n                listPrice: nil,\n                listToken: nil,\n                contentType: metadata.data[\"mimetype\"]!,\n                rarity: rarity,\n            )\n\n            let itemId=\"Geniace\".concat(id.toString())\n            items.append(itemId)\n            resultMap[itemId] = item\n        }\n\n        if items.length != 0 {\n            results[\"Geniace\"] = items\n        }\n    }\n\n    // https://flow-view-source.com/mainnet/account/0x6831760534292098/contract/OneFootballCollectible\n    let oneFootballCollectibleCap = account.getCapability\u003c\u0026OneFootballCollectible.Collection{OneFootballCollectible.OneFootballCollectibleCollectionPublic}\u003e(OneFootballCollectible.CollectionPublicPath)\n    if oneFootballCollectibleCap.check() {\n        let items: [String] = []\n        let collection = oneFootballCollectibleCap.borrow()!\n        for id in collection.getIDs() {\n            let nft = collection.borrowOneFootballCollectible(id: id)!\n            let metadata = nft.getTemplate()!\n            let item=MetadataCollectionItem(\n                id: id,\n                name: metadata.name,\n                image: \"ipfs://\".concat(metadata.media),\n                url: \"https://xmas.onefootball.com/\".concat(account.address.toString()),\n                listPrice: nil,\n                listToken: nil,\n                contentType: \"video\",\n                rarity: \"\"\n\n            )\n            let itemId=\"OneFootballCollectible\".concat(id.toString())\n            items.append(itemId)\n            resultMap[itemId] = item\n\n        }\n        if items.length != 0 {\n            results[\"OneFootballCollectible\"] = items\n        }\n    }\n\n\n    let cryptoPiggoCap = account.getCapability\u003c\u0026{CryptoPiggo.CryptoPiggoCollectionPublic}\u003e(CryptoPiggo.CollectionPublicPath)\n    if cryptoPiggoCap.check() {\n        let items: [String] = []\n        let collection = cryptoPiggoCap.borrow()!\n        for id in collection.getIDs() {\n            let nft = collection.borrowItem(id: id)!\n            let item=MetadataCollectionItem(\n                id: id,\n                name: \"CryptoPiggo #\".concat(id.toString()),\n                image: \"https://s3.us-west-2.amazonaws.com/crypto-piggo.nft/piggo-\".concat(id.toString()).concat(\".png\"),\n                url: \"https://rareworx.com/piggo/details/\".concat(id.toString()),\n                listPrice: nil,\n                listToken: nil,\n                contentType: \"image\",\n                rarity: \"\"\n\n            )\n            let itemId=\"CryptoPiggo\".concat(id.toString())\n            items.append(itemId)\n            resultMap[itemId] = item\n\n        }\n        if items.length != 0 {\n            results[\"CryptoPiggo\"] = items\n        }\n    }\n\n    let xtingles = Collectible.getCollectibleDatas(address:address) \n    if xtingles.length \u003e 0 {\n        let items: [String] = []\n        for nft in xtingles {\n\n            var image=nft.metadata.link\n\n            let prefix=\"https://\"\n            if image.slice(from:0, upTo:prefix.length) != prefix {\n                image=\"ipfs://\".concat(image)\n            }\n            let item=MetadataCollectionItem(\n                id: nft.id,\n                name: nft.metadata.name.concat(\" #\").concat(nft.metadata.edition.toString()),\n                image: image,\n                url: \"http://xtingles.com\",\n                listPrice: nil,\n                listToken: nil,\n                contentType: \"video\",\n                rarity: \"\"\n            )\n            let itemId=\"Xtingles\".concat(nft.id.toString())\n            items.append(itemId)\n            resultMap[itemId] = item\n\n\n        }\n        if items.length != 0 {\n            results[\"Xtingles\"] = items\n        }\n    }\n\n    let goatsCap = account.getCapability\u003c\u0026{GoatedGoatsVouchers.GoatsVoucherCollectionPublic}\u003e(GoatedGoatsVouchers.CollectionPublicPath)\n    var goats : [String]=[]\n    if goatsCap.check() {\n        let goatsImageUrl= GoatedGoatsVouchers.getCollectionMetadata()[\"mediaURL\"]!\n        let collection = goatsCap.borrow()!\n        for id in collection.getIDs() {\n            let item=MetadataCollectionItem(\n                id: id,\n                name: \"Goated Goat Base Goat Voucher #\".concat(id.toString()),\n                image: goatsImageUrl, \n                url: \"https://goatedgoats.com/\",\n                listPrice: nil,\n                listToken: nil,\n                contentType: \"image\",\n                rarity: \"\"\n\n            )\n            let itemId=\"GoatedGoatsVoucher\".concat(id.toString())\n            goats.append(itemId)\n            resultMap[itemId] = item\n        }\n    }\n\n\n    let goatsTraitCap = account.getCapability\u003c\u0026{TraitPacksVouchers.PackVoucherCollectionPublic}\u003e(TraitPacksVouchers.CollectionPublicPath)\n    if goatsTraitCap.check() {\n        let goatsImageUrl= TraitPacksVouchers.getCollectionMetadata()[\"mediaURL\"]!\n        let collection = goatsTraitCap.borrow()!\n        for id in collection.getIDs() {\n            let item=MetadataCollectionItem(\n                id: id,\n                name: \"Goated Goat Trait Pack Voucher #\".concat(id.toString()),\n                image: goatsImageUrl, \n                url: \"https://goatedgoats.com/\",\n                listPrice: nil,\n                listToken: nil,\n                contentType: \"image\",\n                rarity: \"\"\n\n            )\n            let itemId=\"GoatedGoatsTraitVoucher\".concat(id.toString())\n            goats.append(itemId)\n            resultMap[itemId] = item\n        }\n    }\n\n\n    let goatedGoats = getItemForMetadataStandard(path: GoatedGoats.CollectionPublicPath, account: account, externalFixedUrl: \"https://goatedgoats.com\")\n    for item in goatedGoats {\n        let itemId=\"GoatedGoats\".concat(item.id.toString())\n        goats.append(itemId)\n        resultMap[itemId] = item\n    }\n\n\n    let goatedGoatsTrait = getItemForMetadataStandard(path: GoatedGoatsTrait.CollectionPublicPath, account: account, externalFixedUrl: \"https://goatedgoats.com\")\n    for item in goatedGoatsTrait {\n        let itemId=\"GoatedGoatsTraits\".concat(item.id.toString())\n        goats.append(itemId)\n        resultMap[itemId] = item\n    }\n\n\n    let goatedGoatsTraitPack = getItemForMetadataStandard(path: GoatedGoatsTraitPack.CollectionPublicPath, account: account, externalFixedUrl: \"https://goatedgoats.com\")\n    for item in goatedGoatsTraitPack {\n        let itemId=\"GoatedGoatsTraitsPack\".concat(item.id.toString())\n        goats.append(itemId)\n        resultMap[itemId] = item\n    }\n\n    if goats.length != 0 {\n        results[\"GoatedGoats\"] = goats\n    }\n\n    let bitkuCap = account.getCapability\u003c\u0026{HaikuNFT.HaikuCollectionPublic}\u003e(HaikuNFT.HaikuCollectionPublicPath)\n    if bitkuCap.check() {\n        let collection = bitkuCap.borrow()!\n        let items: [String] = []\n        for id in collection.getIDs() {\n            let nft = collection.borrowHaiku(id: id)!\n            let item = MetadataCollectionItem(\n                id: id,\n                name: \"Bitku #\".concat(id.toString()),\n                image: nft.text,\n                url: \"https://bitku.art/#\".concat(address.toString()).concat(\"/\").concat(id.toString()),\n                listPrice: nil,\n                listToken: nil,\n                contentType: \"text\",\n                rarity: \"\"\n            )\n\n            let itemId=\"BitKu\".concat(id.toString())\n            items.append(itemId)\n            resultMap[itemId] = item\n        }\n\n        if items.length != 0 {\n            results[\"Bitku\"] = items\n        }\n    }\n    let klktnCap = account.getCapability\u003c\u0026{KlktnNFT.KlktnNFTCollectionPublic}\u003e(KlktnNFT.CollectionPublicPath)\n    if klktnCap.check() {\n        let items: [String] = []\n        let collection = klktnCap.borrow()!\n        for id in collection.getIDs() {\n            let nft = collection.borrowKlktnNFT(id: id)!\n\n            let metadata=nft.getNFTMetadata()\n            /*\n\n            Result: {\"uri\": \"ipfs://bafybeifsiousmtmcruuelgyiku3xa5hmw7ylsyqfdvpjsea7r4xa74bhym\", \"name\": \"Kevin Woo - What is KLKTN?\", \"mimeType\": \"video/mp4\", \"media\": \"https://ipfs.io/ipfs/bafybeifsiousmtmcruuelgyiku3xa5hmw7ylsyqfdvpjsea7r4xa74bhym/fb91ad34d61dde04f02ad240f0ca924902d8b4a3da25daaf0bb1ed769977848c.mp4\", \"description\": \"K-pop sensation Kevin Woo has partnered up with KLKTN to enhance his artist to fan interactions and experiences within his fandom. Join our chat to learn more: https://discord.gg/UJxb4erfUw\"}\n\n            */\n            let item = MetadataCollectionItem(\n                id: id,\n                name: metadata[\"name\"]!,\n                image: metadata[\"media\"]!,\n                url: \"https://klktn.com/\",\n                listPrice: nil,\n                listToken: nil,\n                contentType: \"video\", //metadata[\"mimeType\"]!,\n                rarity: \"\"\n            )\n            let itemId=\"KLKTN\".concat(id.toString())\n            items.append(itemId)\n            resultMap[itemId] = item\n        }\n\n        if items.length != 0 {\n            results[\"KLKTN\"] = items\n        }\n    }\n\n    let mynftCap = account.getCapability\u003c\u0026{Mynft.MynftCollectionPublic}\u003e(Mynft.CollectionPublicPath)\n    if mynftCap.check() {\n        let items: [String] = []\n        let collection = mynftCap.borrow()!\n        for id in collection.getIDs() {\n            let nft = collection.borrowArt(id: id)!\n            let metadata=nft.metadata\n\n            var image= metadata.ipfsLink\n            if image == \"\" {\n                image=\"https://arweave.net/\".concat(metadata.arLink)\n            }\n\n            let item = MetadataCollectionItem(\n                id: id,\n                name: metadata.name,\n                image: image,\n                url: \"http://mynft.io\",\n                listPrice: nil,\n                listToken: nil,\n                contentType: metadata.type,\n                rarity: \"\"\n            )\n            let itemId=\"mynft\".concat(id.toString())\n            items.append(itemId)\n            resultMap[itemId] = item\n        }\n\n\n        if items.length != 0 {\n            results[\"mynft\"] = items\n        }\n    }\n\n    let neoAvatars = getItemForMetadataStandard(path: NeoAvatar.CollectionPublicPath, account: account, externalFixedUrl: \"\")\n    let neoItems: [String] = []\n    for item in neoAvatars {\n        let itemId=\"NeoAvatar\".concat(item.id.toString())\n        neoItems.append(itemId)\n        resultMap[itemId] = item\n    }\n\n    let neoVouchers = getItemForMetadataStandard(path: NeoVoucher.CollectionPublicPath, account: account, externalFixedUrl: \"https://neocollectibles.xyz/member/\".concat(address.toString()))\n    for item in neoVouchers {\n        let itemId=\"NeoVoucher\".concat(item.id.toString())\n        neoItems.append(itemId)\n        resultMap[itemId] = item\n    }\n\n    let neoMembers = getItemForMetadataStandard(path: NeoMember.CollectionPublicPath, account: account, externalFixedUrl: \"https://neocollectibles.xyz/member/\".concat(address.toString()))\n    for item in neoMembers {\n        let itemId=\"NeoMembers\".concat(item.id.toString())\n        neoItems.append(itemId)\n        resultMap[itemId] = item\n    }\n\n    if neoItems.length != 0 {\n        results[\"Neo\"] = neoItems\n    }\n\n    let byc: [String] = []\n    let barterYardCap= account.getCapability\u003c\u0026{BarterYardPackNFT.BarterYardPackNFTCollectionPublic}\u003e(BarterYardPackNFT.CollectionPublicPath)\n    if barterYardCap.check() {\n        let collection = barterYardCap.borrow()!\n        for id in collection.getIDs() {\n            let nft = collection.borrowBarterYardPackNFT(id: id)!\n\n            if let displayView = nft.resolveView(Type\u003cMetadataViews.Display\u003e()) {\n                let display = displayView as! MetadataViews.Display\n                let item = MetadataCollectionItem(\n                    id: id,\n                    name: display.name,\n                    image: display.thumbnail.uri(),\n                    url: \"https://www.barteryard.club\",\n                    listPrice: nil,\n                    listToken: nil,\n                    contentType: \"image\",\n                    rarity: \"\"\n                )\n\n                let itemId=\"BarterYard\".concat(item.id.toString())\n                byc.append(itemId)\n                resultMap[itemId] = item\n            }\n        }\n    }\n    let werewolves = getItemForMetadataStandard(path: BarterYardClubWerewolf.CollectionPublicPath, account: account, externalFixedUrl: \"https://barteryard.club\")\n    for item in werewolves {\n        let itemId=\"BarterYardWerewolf\".concat(item.id.toString())\n        byc.append(itemId)\n        resultMap[itemId] = item\n    }\n\n    if byc.length != 0 {\n        results[\"Barter Yard Club\"] = byc\n    }\n\n\n    let momentablesCap = account.getCapability\u003c\u0026{Momentables.MomentablesCollectionPublic}\u003e(Momentables.CollectionPublicPath)\n    if momentablesCap.check() {\n        let items: [String] = []\n        let collection = momentablesCap.borrow()!\n\n        for id in collection.getIDs() {\n            let nft = collection.borrowMomentables(id: id)!\n            let traits=nft.getTraits()\n            let commonTrait=traits[\"common\"]!\n\n            let item = MetadataCollectionItem(\n                id: id,\n                name: nft.name,\n                image: \"ipfs://\".concat(nft.imageCID),\n                url: \"https://www.cryptopharaohs.world/\",\n                listPrice: nil,\n                listToken: nil,\n                contentType: \"image\",\n                rarity: commonTrait[\"type\"] ?? \"\",\n            )\n            let itemId=\"CryptoPharaohs\".concat(id.toString())\n            items.append(itemId)\n            resultMap[itemId] = item\n        }\n        if items.length != 0 {\n            results[\"CryptoPharaohs\"] = items\n        }\n    }\n\n\n    /*\n    let beamCap = account.getCapability\u003c\u0026{Beam.BeamCollectionPublic}\u003e(Beam.CollectionPublicPath)\n    if beamCap.check() {\n        let items: [String] = []\n        let collection = beamCap.borrow()!\n        for id in collection.getIDs() {\n            let nft = collection.borrowCollectible(id: id)!\n\n            let metadata = Beam.getCollectibleItemMetaData(collectibleItemID: nft.data.collectibleItemID)!\n            var mediaUrl: String? = metadata[\"mediaUrl\"]\n            if mediaUrl != nil \u0026\u0026  mediaUrl!.slice(from: 0, upTo: 7) != \"ipfs://\" {\n            mediaUrl = \"ipfs://\".concat(mediaUrl!)\n        }\n        let item = MetadataCollectionItem(\n            id: id,\n            name: metadata[\"title\"]!,\n            image: mediaUrl ?? \"\",\n            url: \"https://\".concat(metadata[\"domainUrl\"]!),\n            listPrice: nil,\n            listToken: nil,\n            contentType: metadata[\"mediaType\"]!,\n            rarity: \"\"\n        )\n        let itemId=\"FrightClub\".concat(id.toString())\n        items.append(itemId)\n        resultMap[itemId] = item\n    }\n    if items.length != 0 {\n        results[\"Fright Club\"] = items\n    }\n}*/\n\n\n/*\nlet resolverCollectionCap= account.getCapability\u003c\u0026{StarlyCard.StarlyCardCollectionPublic}\u003e(StarlyCard.CollectionPublicPath)\nif resolverCollectionCap.check() {\n    let items: [String] = []\n    let collection = resolverCollectionCap.borrow()!\n    for id in collection.getIDs() {\n        let nft = collection.borrowViewResolver(id: id)!\n\n        if let displayView = nft.resolveView(Type\u003cMetadataViews.Display\u003e()) {\n            let display = displayView as! MetadataViews.Display\n            if let starlyView = nft.resolveView(Type\u003cStarlyMetadataViews.CardEdition\u003e()) {\n                let cardEdition= starlyView as! StarlyMetadataViews.CardEdition\n\n                let item = MetadataCollectionItem(\n                    id: id,\n                    name: display.name,\n                    image: display.thumbnail.uri(),\n                    url:cardEdition.url,\n                    listPrice: nil,\n                    listToken: nil,\n                    contentType: cardEdition.card.mediaType,\n                    rarity: cardEdition.card.rarity\n                )\n                let itemId=\"Starly\".concat(id.toString())\n                items.append(itemId)\n                resultMap[itemId] = item\n            }\n        }\n    }\n    if items.length != 0 {\n        results[\"Starly\"] = items\n    }\n}\n*/\n\nlet zeedzCap = account.getCapability\u003c\u0026{ZeedzINO.ZeedzCollectionPublic}\u003e(ZeedzINO.CollectionPublicPath)\nif zeedzCap.check() {\n    let items: [String] = []\n    let collection = zeedzCap.borrow()!\n    for id in collection.getIDs() {\n        let nft = collection.borrowZeedle(id: id)!\n\n        let item = MetadataCollectionItem(\n            id: id,\n            name: nft.name,\n            image: \"ipfs://\".concat(nft.imageURI),\n            url: \"http://zeedz.io\",\n            listPrice: nil,\n            listToken: nil,\n            contentType: \"image\",\n            rarity: nft.rarity\n        )\n        let itemId=\"zeedz\".concat(id.toString())\n        items.append(itemId)\n        resultMap[itemId] = item\n    }\n\n\n    if items.length != 0 {\n        results[\"Zeedz\"] = items\n    }\n}\nif results.keys.length == 0 {\n    return nil\n}\n\nlet publicPath=/public/FindCuratedCollections\nlet link = account.getCapability\u003c\u0026{String: [String]}\u003e(publicPath)\nvar curatedCollections : {String: [String]} = {}\nif link.check() {\n    let curated = link.borrow()!\n    for curatedKey in curated.keys {\n        curatedCollections[curatedKey] = curated[curatedKey]!\n    }\n}\n\nreturn MetadataCollections(items: resultMap, collections:results, curatedCollections: curatedCollections)\n}\n\n//This uses a view from Neo until we agree on another for ExternalDomainViewUrl\npub fun getItemForMetadataStandard(path: PublicPath, account:PublicAccount, externalFixedUrl: String) : [MetadataCollectionItem] {\n    let items: [MetadataCollectionItem] = []\n    let resolverCollectionCap= account.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(path)\n    if resolverCollectionCap.check() {\n        let collection = resolverCollectionCap.borrow()!\n        for id in collection.getIDs() {\n            let nft = collection.borrowViewResolver(id: id)!\n\n            if let displayView = nft.resolveView(Type\u003cMetadataViews.Display\u003e()) {\n                let display = displayView as! MetadataViews.Display\n                var externalUrl=externalFixedUrl\n                if let externalUrlView = nft.resolveView(Type\u003cNeoViews.ExternalDomainViewUrl\u003e()) {\n                    let url= externalUrlView! as! NeoViews.ExternalDomainViewUrl\n                    externalUrl=url.url\n                }\n\n                let item = MetadataCollectionItem(\n                    id: id,\n                    name: display.name,\n                    image: display.thumbnail.uri(),\n                    url: externalUrl,\n                    listPrice: nil,\n                    listToken: nil,\n                    contentType: \"image\",\n                    rarity: \"\"\n                )\n\n                items.append(item)\n            }\n        }\n    }\n    return items\n\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "mainnet_getFlobits": {
               "code": "import FlovatarComponent from 0x921ea449dffec68a\nimport FlovatarMarketplace from  0x921ea449dffec68a\n\npub struct MetadataCollectionItem {\n    pub let id:UInt64\n    pub let name: String\n    pub let image: String\n    pub let url: String\n    pub let listPrice: UFix64?\n    pub let listToken: String?\n    pub let contentType:String\n    pub let rarity:String\n\n\n    init(id:UInt64, name:String, image:String, url:String, listPrice: UFix64?, listToken:String?, contentType: String, rarity: String) {\n        self.id=id\n        self.name=name\n        self.url=url\n        self.image=image\n        self.listToken=listToken\n        self.listPrice=listPrice\n        self.contentType=contentType\n        self.rarity=rarity\n    }\n}\n\npub fun main(addr: Address) : [MetadataCollectionItem] {\n\n    let flovatarComponents= FlovatarComponent.getComponents(address: addr)\n\n    let templateNumbers : {UInt64: UInt64} = {}\n    let templateData : {UInt64: FlovatarComponent.ComponentData} = {}\n    for flovatar in flovatarComponents {\n\n        let templateId= flovatar.templateId\n        var number:UInt64=1\n        if templateNumbers[templateId] == nil {\n            templateNumbers[templateId] = (1 as UInt64)\n            templateData[templateId]=flovatar\n        } else {\n            templateNumbers[templateId] = templateNumbers[templateId]! + 1\n        }\n    }\n\n\n    let flovatarMarketComponents=FlovatarMarketplace.getFlovatarComponentSales(address:addr)\n\n    for flovatar in flovatarMarketComponents {\n\n        let templateId= flovatar.metadata.templateId\n            var number:UInt64=1\n            if templateNumbers[templateId] == nil {\n                templateNumbers[templateId] = (1 as UInt64)\n                templateData[templateId]=FlovatarComponent.getComponent(address:addr, componentId: flovatar.id)!\n            } else {\n                templateNumbers[templateId] = templateNumbers[templateId]! + 1\n            }\n    }\n\n\n    let flovatarC : [MetadataCollectionItem] = []\n    for templateId in templateData.keys {\n        let template=templateData[templateId]!\n\n\n        var name=template.name\n\n        if templateId == 75 || templateId==74 || templateId == 73 {\n            name=name.concat(\" Booster\")\n        }\n\n        if templateNumbers[templateId]! \u003e 1 {\n            name=name.concat(\" x \").concat(templateNumbers[templateId]!.toString())\n        } \n\n        let item=MetadataCollectionItem(\n            id: template.id, \n            name: name, \n            image: \"https://flovatar.com/api/image/template/\".concat(templateId.toString()),\n            url: \"https://flovatar.com\",\n            listPrice: nil,\n            listToken: nil,\n            contentType: \"image\",\n            rarity: template.rarity\n        )\n\n        flovatarC.append(item)\n    }\n\n    return flovatarC\n\n}",
               "spec": {
                  "order": [
                     "addr"
                  ],
                  "parameters": {
                     "addr": "Address"
                  }
               }
            },
            "mainnet_getNeoAvatar": {
               "code": "import FIND from 0xf8d6e0586b0a20c7\n\nimport NeoAvatar from 0xb25138dbf45e5801\nimport NeoViews from 0xb25138dbf45e5801\nimport MetadataViews from 0x1d7e57aa55817448\n\npub struct MetadataCollectionItem {\n    pub let id:UInt64\n    pub let name: String\n    pub let image: String\n    pub let url: String\n    pub let listPrice: UFix64?\n    pub let listToken: String?\n    pub let contentType:String\n    pub let rarity:String\n\n\n    init(id:UInt64, name:String, image:String, url:String, listPrice: UFix64?, listToken:String?, contentType: String, rarity: String) {\n        self.id=id\n        self.name=name\n        self.url=url\n        self.image=image\n        self.listToken=listToken\n        self.listPrice=listPrice\n        self.contentType=contentType\n        self.rarity=rarity\n    }\n}\n\npub fun main(user: String) : [MetadataCollectionItem] {\n\n    let resolveAddress = FIND.resolve(user) \n    if resolveAddress == nil {return []}\n    let address = resolveAddress!\n    let account=getAccount(address)\n\n    return getItemForMetadataStandard(path: NeoAvatar.CollectionPublicPath, account:account)\n    /*\n    let items: [MetadataCollectionItem] = []\n    let account=getAccount(address)\n    let neoAvatarCap = account.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(NeoAvatar.CollectionPublicPath)\n    if neoAvatarCap.check() {\n        let collection = neoAvatarCap.borrow()!\n        for id in collection.getIDs() {\n            let nft = collection.borrowViewResolver(id: id)!\n\n            if let displayView = nft.resolveView(Type\u003cMetadataViews.Display\u003e()) {\n                let display = displayView as! MetadataViews.Display\n                if let externalUrlView = nft.resolveView(Type\u003cNeoViews.ExternalDomainViewUrl\u003e()) {\n                    let externalUrl= externalUrlView! as! NeoViews.ExternalDomainViewUrl\n                    let item = MetadataCollectionItem(\n                        id: id,\n                        name: display.name,\n                        image: display.thumbnail.uri(),\n                        url: externalUrl.url,\n                        listPrice: nil,\n                        listToken: nil,\n                        contentType: \"image\",\n                        rarity: \"\"\n                    )\n\n                    items.append(item)\n                }\n            }\n        }\n    }\n    return items\n    */\n\n}\n\npub fun getItemForMetadataStandard(path: PublicPath, account:PublicAccount) : [MetadataCollectionItem] {\n    let items: [MetadataCollectionItem] = []\n    let resolverCollectionCap= account.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(path)\n    if resolverCollectionCap.check() {\n        let collection = resolverCollectionCap.borrow()!\n        for id in collection.getIDs() {\n            let nft = collection.borrowViewResolver(id: id)!\n\n            if let displayView = nft.resolveView(Type\u003cMetadataViews.Display\u003e()) {\n                let display = displayView as! MetadataViews.Display\n                if let externalUrlView = nft.resolveView(Type\u003cNeoViews.ExternalDomainViewUrl\u003e()) {\n                    let externalUrl= externalUrlView! as! NeoViews.ExternalDomainViewUrl\n                    let item = MetadataCollectionItem(\n                        id: id,\n                        name: display.name,\n                        image: display.thumbnail.uri(),\n                        url: externalUrl.url,\n                        listPrice: nil,\n                        listToken: nil,\n                        contentType: \"image\",\n                        rarity: \"\"\n                    )\n\n                    items.append(item)\n                }\n            }\n        }\n    }\n    return items\n\n\n\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "mainnet_getRareroom": {
               "code": "import NonFungibleToken from 0xf8d6e0586b0a20c7\nimport CharityNFT from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\nimport RareRooms_NFT from 0x329feb3ab062d289\n\n\npub fun main(user: String) : {String:String} {\n\n    let resolveAddress = FIND.resolve(user) \n    if resolveAddress == nil {return {}}\n    let address = resolveAddress!\n    let account=getAccount(address)\n    let rareRoomCap = account.getCapability\u003c\u0026RareRooms_NFT.Collection{RareRooms_NFT.RareRooms_NFTCollectionPublic}\u003e(RareRooms_NFT.CollectionPublicPath)\n\n    if rareRoomCap.check() {\n        let collection = rareRoomCap.borrow()!\n        let items: [String] = []\n        for id in collection.getIDs() {\n            let nft = collection.borrowRareRooms_NFT(id: id)!\n            let metadata = RareRooms_NFT.getSetMetadata(setId: nft.setId)!\n            return metadata\n        }\n    }\n    return {}\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "mainnet_getStarly": {
               "code": "import FIND from 0xf8d6e0586b0a20c7\n\nimport StarlyCard from 0x5b82f21c0edf76e3\nimport StarlyMetadataViews from 0x5b82f21c0edf76e3\nimport MetadataViews from 0x1d7e57aa55817448\n\npub struct MetadataCollectionItem {\n    pub let id:UInt64\n    pub let name: String\n    pub let image: String\n    pub let url: String\n    pub let listPrice: UFix64?\n    pub let listToken: String?\n    pub let contentType:String\n    pub let rarity:String\n\n\n    init(id:UInt64, name:String, image:String, url:String, listPrice: UFix64?, listToken:String?, contentType: String, rarity: String) {\n        self.id=id\n        self.name=name\n        self.url=url\n        self.image=image\n        self.listToken=listToken\n        self.listPrice=listPrice\n        self.contentType=contentType\n        self.rarity=rarity\n    }\n}\n\npub fun main(user: String) : [MetadataCollectionItem] {\n\n    let resolveAddress = FIND.resolve(user) \n    if resolveAddress == nil {return []}\n    let address = resolveAddress!\n    let account=getAccount(address)\n    let items: [MetadataCollectionItem] = []\n    let resolverCollectionCap= account.getCapability\u003c\u0026{StarlyCard.StarlyCardCollectionPublic}\u003e(StarlyCard.CollectionPublicPath)\n    if resolverCollectionCap.check() {\n        let collection = resolverCollectionCap.borrow()!\n        for id in collection.getIDs() {\n            let nft = collection.borrowViewResolver(id: id)!\n\n            if let displayView = nft.resolveView(Type\u003cMetadataViews.Display\u003e()) {\n                let display = displayView as! MetadataViews.Display\n                if let starlyView = nft.resolveView(Type\u003cStarlyMetadataViews.CardEdition\u003e()) {\n                     let cardEdition= starlyView as! StarlyMetadataViews.CardEdition\n\n                    let item = MetadataCollectionItem(\n                        id: id,\n                        name: display.name,\n                        image: display.thumbnail.uri(),\n                        url:cardEdition.url,\n                        listPrice: nil,\n                        listToken: nil,\n                        contentType: \"image\",\n                        rarity: cardEdition.card.rarity\n                    )\n\n                    items.append(item)\n                }\n            }\n        }\n    }\n    return items\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "mainnet_getStoreFrontListings": {
               "code": "import FIND from 0xf8d6e0586b0a20c7\n\nimport NFTStorefront from 0x4eb8a10cb9f87357\nimport Marketplace from 0xd796ff17107bbff6\nimport Art from 0xd796ff17107bbff6\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport Flovatar from 0x921ea449dffec68a\nimport FlovatarMarketplace from  0x921ea449dffec68a\n\n// This script returns the details for a listing within a storefront\n\npub struct Listing {\n    pub let marketplace : String\n    pub let ftVault: Type\n    pub let price:UFix64\n    pub let nftType: Type\n    pub let nftId: UInt64\n\n    init(marketplace:String, ftVault:Type, price:UFix64, nftType:Type, nftId:UInt64) {\n        self.marketplace=marketplace\n        self.ftVault=ftVault\n        self.price=price\n        self.nftType=nftType\n        self.nftId=nftId\n    }\n}\n\npub fun main(user: String): {UInt64 :[Listing]} {\n\n    let resolveAddress = FIND.resolve(user) \n    if resolveAddress == nil {return {}}\n    let address = resolveAddress!\n    let account=getAccount(address)\n    let storefrontRef = account.getCapability\u003c\u0026NFTStorefront.Storefront{NFTStorefront.StorefrontPublic}\u003e(NFTStorefront.StorefrontPublicPath).borrow()!\n\n    let listings : {UInt64 : [Listing]} = {}\n\n    for id in storefrontRef.getListingIDs() {\n        let listing = storefrontRef.borrowListing(listingResourceID: id)!\n        let details=listing.getDetails()\n        if details.purchased==true {\n            continue\n        }\n        let uuid=listing.borrowNFT()!.uuid\n\n        let item = Listing( \n            marketplace:\"nftstorefront-\".concat(details.storefrontID.toString()),\n            ftVault: details.salePaymentVaultType, \n            price: details.salePrice,\n            nftType:details.nftType,\n            nftId: details.nftID,\n        )\n        let uuidListings= listings[uuid] ?? []\n        uuidListings.append(item)\n        listings[uuid]= uuidListings\n    }\n\n\n    let versusMarketplace = account.getCapability\u003c\u0026{Marketplace.SalePublic}\u003e(Marketplace.CollectionPublicPath)\n    if versusMarketplace.check() {\n\n        let versusMarket = versusMarketplace.borrow()!\n\n        let saleItems = versusMarket.listSaleItems()\n        for saleItem in saleItems {\n\n            let item = Listing( \n                marketplace:\"versus\",\n                ftVault: Type\u003c@FlowToken.Vault\u003e(),\n                price: saleItem.price,\n                nftType:Type\u003c@Art.NFT\u003e(),\n                nftId: saleItem.id\n            )\n\n            let uuid = versusMarket.getUUIDforSaleItem(tokenID: saleItem.id)\n            //let uuid = art.borrowNFT(id:saleItem.id)!.uuid\n            let uuidListings= listings[uuid] ?? []\n            uuidListings.append(item)\n            listings[uuid]= uuidListings\n\n        }\n    }\n\n\n\n    let flovatarCap = account.getCapability\u003c\u0026{FlovatarMarketplace.SalePublic}\u003e(FlovatarMarketplace.CollectionPublicPath)  \n    if flovatarCap.check(){\n        let saleCollection=flovatarCap.borrow()!\n        for id in saleCollection.getFlovatarIDs() {\n            let price = saleCollection.getFlovatarPrice(tokenId: id)!\n            let flovatar = saleCollection.getFlovatar(tokenId: id)!\n\n            let item = Listing( \n                marketplace:\"flovatar\",\n                ftVault: Type\u003c@FlowToken.Vault\u003e(),\n                price: price,\n                nftType:Type\u003c@Flovatar.NFT\u003e(),\n                nftId: id\n            )\n\n            let uuid =  flovatar.uuid\n            //let uuid = art.borrowNFT(id:saleItem.id)!.uuid\n            let uuidListings= listings[uuid] ?? []\n            uuidListings.append(item)\n            listings[uuid]= uuidListings\n        }\n    }\n    return listings\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "resolve": {
               "code": "import FIND from 0xf8d6e0586b0a20c7\n\npub fun main(input:String) : Address?{\n    return FIND.resolve(input)\n}",
               "spec": {
                  "order": [
                     "input"
                  ],
                  "parameters": {
                     "input": "String"
                  }
               }
            },
            "resolvePartialCollection": {
               "code": "import MetadataViews from 0xf8d6e0586b0a20c7\nimport NFTRegistry from 0xf8d6e0586b0a20c7\nimport FindViews from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\n\npub struct ViewCollectionPointer {\n    access(self) let cap: Capability\u003c\u0026{MetadataViews.ResolverCollection}\u003e\n    pub let nftInfo: NFTRegistry.NFTInfo\n\n    init(cap: Capability\u003c\u0026{MetadataViews.ResolverCollection}\u003e, aliasOrIdentifier: String) {\n        self.cap=cap\n        self.nftInfo=NFTRegistry.getNFTInfo(aliasOrIdentifier)!\n    }\n\n    pub fun resolveView(_ type: Type, id: UInt64) : AnyStruct? {\n        return self.getViewResolver(id).resolveView(type)\n    }\n\n    pub fun getUUID(_ id: UInt64) :UInt64{\n        return self.getViewResolver(id).uuid\n    }\n\n    pub fun getViews(_ id: UInt64) : [Type]{\n        return self.getViewResolver(id).getViews()\n    }\n\n    pub fun owner() : Address {\n        return self.cap.address\n    }\n\n    pub fun valid(_ id: UInt64) : Bool {\n        if !self.cap.borrow()!.getIDs().contains(id) {\n            return false\n        }\n        return true\n    }\n\n    pub fun getItemType(_ id: UInt64) : Type {\n        return self.getViewResolver(id).getType()\n    }\n\n    pub fun getViewResolver(_ id: UInt64) : \u0026AnyResource{MetadataViews.Resolver} {\n        return self.cap.borrow()!.borrowViewResolver(id: id)\n    }\n\n    pub fun resolveDisplayViews(_ id: UInt64) : MetadataViews.Display {\n        return self.resolveView(Type\u003cMetadataViews.Display\u003e(), id: id)! as! MetadataViews.Display\n    }\n\n    pub fun getName(_ id: UInt64) : String {\n        return self.resolveDisplayViews(id).name\n    }\n\n    pub fun getImage(_ id: UInt64) : String {\n        return self.resolveDisplayViews(id).thumbnail.uri()\n    }\n\n    pub fun getRarityView(_ id: UInt64) : FindViews.Rarity? {\n        return self.resolveView(Type\u003cFindViews.Rarity\u003e(), id:id) as? FindViews.Rarity\n    }\n\n    pub fun getRarity(_ id: UInt64) : String {\n        if let rarity = self.getRarityView(id) {\n            return rarity.rarityName\n        }\n        return \"\"\n    }\n\n    pub fun getExternalUrlView(_ id: UInt64) : MetadataViews.ExternalURL? {\n        return  self.resolveView(Type\u003cMetadataViews.ExternalURL\u003e(), id:id) as? MetadataViews.ExternalURL\n    }\n\n    pub fun getExternalUrl(_ id: UInt64) : String {\n        if let url = self.getExternalUrlView(id) {\n            return url.url\n        }\n        return self.nftInfo.externalFixedUrl\n    }\n\n}\n\npub fun createViewReadPointer(address:Address, aliasOrIdentifier:String) : ViewCollectionPointer {\n    let path= NFTRegistry.getNFTInfo(aliasOrIdentifier)!.publicPath\n    let cap= getAccount(address).getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(path)\n    let pointer= ViewCollectionPointer(cap: cap, aliasOrIdentifier: aliasOrIdentifier)\n    return pointer\n}\n\npub struct MetadataCollectionItem {\n    pub let id:UInt64\n    pub let typeIdentifier: String\n    pub let uuid: UInt64 \n    pub let name: String\n    pub let image: String\n    pub let url: String\n    pub let contentType:String\n    pub let rarity:String\n    //Refine later \n    pub let metadata: {String : String}\n    pub let collection: String \n\n    init(id:UInt64, type: Type, uuid: UInt64, name:String, image:String, url:String, contentType: String, rarity: String, collection: String) {\n        self.id=id\n        self.typeIdentifier = type.identifier\n        self.uuid = uuid\n        self.name=name\n        self.url=url\n        self.image=image\n        self.contentType=contentType\n        self.rarity=rarity\n        self.metadata={}\n        self.collection=collection\n    }\n}\n\npub fun main(user: String, aliasOrIdentifier: [String], ids:[UInt64]) : [MetadataCollectionItem] {\n\n    let resolveAddress = FIND.resolve(user) \n    if resolveAddress == nil {return []}\n    let address = resolveAddress!\n    var pointerMap: {String : ViewCollectionPointer} = {}\n\n    var resultMap : [MetadataCollectionItem] = []\n\n    assert(aliasOrIdentifier.length == ids.length, message: \"The length of alias passed in does not match with that of the IDs.\")\n    var i = 0\n    while i \u003c aliasOrIdentifier.length {\n        let alias = aliasOrIdentifier[i]\n        let id = ids[i]\n        if pointerMap[alias] == nil {\n            pointerMap[alias] = createViewReadPointer(address: address, aliasOrIdentifier: alias)\n        }\n        let pointer = pointerMap[alias]!\n        resultMap.append(MetadataCollectionItem(id: id, \n                                                type: pointer.getItemType(id), \n                                                uuid: pointer.getUUID(id), \n                                                name: pointer.getName(id), \n                                                image: pointer.getImage(id), \n                                                url: pointer.getExternalUrl(id), \n                                                contentType: \"image\", \n                                                rarity: pointer.getRarity(id), \n                                                collection: alias)\n        )\n        i = i + 1\n    }\n    return resultMap\n}",
               "spec": {
                  "order": [
                     "user",
                     "aliasOrIdentifier",
                     "ids"
                  ],
                  "parameters": {
                     "aliasOrIdentifier": "[String]",
                     "ids": "[UInt64]",
                     "user": "String"
                  }
               }
            }
         },
         "transactions": {
            "acceptDirectOfferSoft": {
               "code": "import FindMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FindViews from 0xf8d6e0586b0a20c7\nimport NFTRegistry from 0xf8d6e0586b0a20c7\nimport FindMarket from 0xf8d6e0586b0a20c7\n\ntransaction(marketplace:Address, id: UInt64) {\n\n\n    prepare(account: AuthAccount) {\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e())\n        let market = account.borrow\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection\u003e(from: storagePath)!\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e())\n        let item = FindMarket.assertOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: id)\n        let nftIdentifier = item.getItemType().identifier\n\n        //If this is nil, there must be something wrong with FIND setup\n        let nft = NFTRegistry.getNFTInfoByTypeIdentifier(nftIdentifier)!\n\n        let providerCap=account.getCapability\u003c\u0026{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e(nft.providerPath)\n        let pointer= FindViews.AuthNFTPointer(cap: providerCap, id: id)\n\n        market.acceptOffer(pointer)\n\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "addCuratedCollection": {
               "code": "transaction(name: String, items: [String]) {\n    prepare(account: AuthAccount) {\n\n        let path=/storage/FindCuratedCollections\n        let publicPath=/public/FindCuratedCollections\n\n        var collections : {String: [String]} = {}\n        if account.borrow\u003c\u0026{String: [String]}\u003e(from:path) != nil {\n             collections=account.load\u003c{String: [String]}\u003e(from:path)!\n        }\n        collections[name] = items\n        account.save(collections, to: path)\n        let link = account.getCapability\u003c\u0026{String: [String]}\u003e(publicPath)\n        if !link.check() {\n            account.link\u003c\u0026{String: [String]}\u003e( publicPath, target: path)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "items"
                  ],
                  "parameters": {
                     "items": "[String]",
                     "name": "String"
                  }
               }
            },
            "adminAddBl0xTestnet": {
               "code": "import Admin from 0xf8d6e0586b0a20c7\nimport Bl0x from 0xe8124d8428980aa6\nimport FindMarket from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\n\ntransaction(tenant: Address) {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n        \n    }\n    execute{\n\n        self.adminRef.setNFTInfo(\n            alias: \"Bl0x\", \n            type: Type\u003c@Bl0x.NFT\u003e(), \n            icon: \"https://global-uploads.webflow.com/60f008ba9757da0940af288e/626e4af22f80f09e2783df44_blox.jpg\", \n            providerPath: Bl0x.CollectionPrivatePath, \n            publicPath: Bl0x.CollectionPublicPath, \n            storagePath: Bl0x.CollectionStoragePath, \n            allowedFTTypes: nil, \n            address:0xe8124d8428980aa6, externalFixedUrl: \"bl0x-5ccsb92pb-findonflow.vercel.app\")\n\n        let rules = [\n            FindMarket.TenantRule(name:\"Flow\", types:[Type\u003c@FlowToken.Vault\u003e()], ruleType: \"ft\", allow: true),\n            FindMarket.TenantRule(name:\"Neo\", types:[Type\u003c@Bl0x.NFT\u003e()], ruleType: \"nft\", allow: true)\n        ]\n\n        let tenantSaleItem = FindMarket.TenantSaleItem(\n            name: \"FlowBl0x\", \n            cut: nil, \n            rules: rules, \n            status:\"active\"\n        )\n\n        self.adminRef.setMarketOption(tenant: tenant, saleItem: tenantSaleItem)\n        \n    }\n}",
               "spec": {
                  "order": [
                     "tenant"
                  ],
                  "parameters": {
                     "tenant": "Address"
                  }
               }
            },
            "adminMintCharity": {
               "code": "import NonFungibleToken from 0xf8d6e0586b0a20c7\nimport CharityNFT from 0xf8d6e0586b0a20c7\nimport Admin from 0xf8d6e0586b0a20c7\n\n//mint an art and add it to a users collection\ntransaction(\n    name: String,\n    image: String,\n    thumbnail: String,\n    originUrl: String,\n    description: String,\n    recipient: Address\n) {\n    let receiverCap: Capability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e\n    let client: \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount) {\n        self.client= account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath)!\n        self.receiverCap= getAccount(recipient).getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath)\n    }\n\n    execute {\n        let metadata = {\"name\" : name, \"image\" : image, \"thumbnail\": thumbnail, \"originUrl\": originUrl, \"description\":description}\n        self.client.mintCharity(metadata: metadata, recipient: self.receiverCap)\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "image",
                     "thumbnail",
                     "originUrl",
                     "description",
                     "recipient"
                  ],
                  "parameters": {
                     "description": "String",
                     "image": "String",
                     "name": "String",
                     "originUrl": "String",
                     "recipient": "Address",
                     "thumbnail": "String"
                  }
               }
            },
            "adminRegisterName": {
               "code": "import FIND from 0xf8d6e0586b0a20c7\nimport Admin from 0xf8d6e0586b0a20c7\nimport Profile from 0xf8d6e0586b0a20c7\n\ntransaction(names: [String], user: Address) {\n\n    prepare(account: AuthAccount) {\n\n        let userAccount=getAccount(user)\n        let profileCap = userAccount.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        let leaseCollectionCap=userAccount.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        let adminClient=account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath)!\n\n        for name in names {\n            adminClient.register(name: name,  profile: profileCap, leases: leaseCollectionCap)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "names",
                     "user"
                  ],
                  "parameters": {
                     "names": "[String]",
                     "user": "Address"
                  }
               }
            },
            "adminRemoveFTInfoByAlias": {
               "code": "import Admin from 0xf8d6e0586b0a20c7\n\ntransaction(alias: String) {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n        \n    }\n\n    execute{\n\n        self.adminRef.removeFTInfoByAlias(alias)\n\n    }\n}",
               "spec": {
                  "order": [
                     "alias"
                  ],
                  "parameters": {
                     "alias": "String"
                  }
               }
            },
            "adminRemoveFTInfoByTypeIdentifier": {
               "code": "import Admin from 0xf8d6e0586b0a20c7\n\ntransaction(typeIdentifier: String) {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n        \n    }\n\n    execute{\n\n        self.adminRef.removeFTInfoByTypeIdentifier(typeIdentifier) \n       \n    }\n}",
               "spec": {
                  "order": [
                     "typeIdentifier"
                  ],
                  "parameters": {
                     "typeIdentifier": "String"
                  }
               }
            },
            "adminRemoveNFTInfoByAlias": {
               "code": "import Admin from 0xf8d6e0586b0a20c7\n\ntransaction(alias: String) {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n        \n    }\n\n    execute{\n\n        self.adminRef.removeNFTInfoByAlias(alias)\n        \n    }\n}",
               "spec": {
                  "order": [
                     "alias"
                  ],
                  "parameters": {
                     "alias": "String"
                  }
               }
            },
            "adminRemoveNFTInfoByTypeIdentifier": {
               "code": "import Admin from 0xf8d6e0586b0a20c7\n\ntransaction(typeIdentifier: String) {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n        \n    }\n\n    execute{\n\n        self.adminRef.removeNFTInfoByTypeIdentifier(typeIdentifier) \n       \n    }\n}",
               "spec": {
                  "order": [
                     "typeIdentifier"
                  ],
                  "parameters": {
                     "typeIdentifier": "String"
                  }
               }
            },
            "adminSendFUSD": {
               "code": "import FungibleToken from 0xee82856bf20e2aa6\nimport FUSD from 0xf8d6e0586b0a20c7\n\ntransaction(receiver: Address, amount:UFix64) {\n    prepare(acct: AuthAccount) {\n        let receiver = getAccount(receiver).getCapability\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e(/public/fusdReceiver).borrow() ?? panic(\"Cannot borrow FUSD receiver\")\n\n        let sender = acct.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault)\n            ?? panic(\"Cannot borrow FUSD vault from authAcct storage\")\n\n        receiver.deposit(from: \u003c- sender.withdraw(amount:amount))\n    }\n}",
               "spec": {
                  "order": [
                     "receiver",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "receiver": "Address"
                  }
               }
            },
            "adminSetFTInfo_flow": {
               "code": "import Admin from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\n\ntransaction() {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n    }\n\n    execute{\n        let type: Type = Type\u003c@FlowToken.Vault\u003e()\n        self.adminRef.setFTInfo(alias: \"Flow\", type: type, tag:[\"utility coin\"] , icon: \"https://static.flowscan.org/mainnet/icons/A.1654653399040a61.FlowToken.png\", receiverPath: /public/flowTokenReceiver, balancePath: /public/flowTokenBalance, vaultPath: /storage/flowTokenVault)\n    }\n}",
               "spec": null
            },
            "adminSetFTInfo_fusd": {
               "code": "import Admin from 0xf8d6e0586b0a20c7\nimport FUSD from 0xf8d6e0586b0a20c7\n\ntransaction() {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n    }\n\n    execute{\n        let type: Type = Type\u003c@FUSD.Vault\u003e()\n        self.adminRef.setFTInfo(alias: \"FUSD\", type: type, tag:[\"stablecoin\"], icon: \"https://static.flowscan.org/mainnet/icons/A.3c5959b568896393.FUSD.png\", receiverPath: /public/fusdReceiver, balancePath: /public/fusdBalance, vaultPath: /storage/fusdVault)\n    }\n}",
               "spec": null
            },
            "adminSetFTInfo_usdc": {
               "code": "import Admin from 0xf8d6e0586b0a20c7\nimport FiatToken from 0xf8d6e0586b0a20c7\n\ntransaction() {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n    }\n\n    execute{\n        let type: Type = Type\u003c@FiatToken.Vault\u003e()\n        self.adminRef.setFTInfo(alias: \"USDC\", type: type, tag:[\"stablecoin\"] , icon: \"https://static.flowscan.org/mainnet/icons/A.b19436aae4d94622.FiatToken.png\", receiverPath: FiatToken.VaultReceiverPubPath, balancePath: FiatToken.VaultBalancePubPath, vaultPath: FiatToken.VaultStoragePath)\n    }\n}",
               "spec": null
            },
            "adminSetFindCut": {
               "code": "import Admin from 0xf8d6e0586b0a20c7\n\ntransaction(tenant: Address, cut: UFix64){\n    prepare(account: AuthAccount){\n        let adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n\n        adminRef.setFindCut(tenant: tenant, cut: cut, rules: nil, status: \"active\")\n    }\n}",
               "spec": {
                  "order": [
                     "tenant",
                     "cut"
                  ],
                  "parameters": {
                     "cut": "UFix64",
                     "tenant": "Address"
                  }
               }
            },
            "adminSetNFTInfo_Dandy": {
               "code": "import Admin from 0xf8d6e0586b0a20c7\nimport Dandy from 0xf8d6e0586b0a20c7\n\ntransaction() {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n        \n    }\n    execute{\n        let type: Type = Type\u003c@Dandy.NFT\u003e()\n        self.adminRef.setNFTInfo(alias: \"Dandy\", type: type, icon: nil, providerPath: Dandy.CollectionPrivatePath, publicPath: Dandy.CollectionPublicPath, storagePath: Dandy.CollectionStoragePath, allowedFTTypes: nil, address: 0xf8d6e0586b0a20c7, externalFixedUrl: \"find.xyz\")\n\n    }\n}",
               "spec": null
            },
            "adminSetNFTInfo_Neo": {
               "code": "import Admin from 0xf8d6e0586b0a20c7\nimport NeoVoucher from 0xd6b39e5b5b367aad\n\ntransaction() {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n        \n    }\n    execute{\n\n        self.adminRef.setNFTInfo(alias: \"NeoVoucher\", type: Type\u003c@NeoVoucher.NFT\u003e(), icon: \"https://test.neocollectibles.xyz/pages/images/neo-collectibles-logo.webp\", providerPath: /private/neoVoucherCollection, publicPath: NeoVoucher.CollectionPublicPath, storagePath: NeoVoucher.CollectionStoragePath, allowedFTTypes: nil, address: 0xd6b39e5b5b367aad, externalFixedUrl: \"test.neocollectibles.xyx\")\n\n    }\n}",
               "spec": null
            },
            "adminSetSellDandyForFUSD": {
               "code": "import FindMarket from 0xf8d6e0586b0a20c7\nimport Admin from 0xf8d6e0586b0a20c7\nimport FUSD from 0xf8d6e0586b0a20c7\nimport Dandy from 0xf8d6e0586b0a20c7\nimport FindMarketSale from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionSoft from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\n\n\ntransaction(tenant: Address, market: String){\n    prepare(account: AuthAccount){\n        let adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n\n        var marketType : [Type] = [Type\u003c@FindMarketSale.SaleItem\u003e()]\n        switch market {\n            case \"AuctionEscrow\" :\n                marketType = [Type\u003c@FindMarketAuctionEscrow.SaleItem\u003e()]\n\n            case \"AuctionSoft\" :\n                marketType = [Type\u003c@FindMarketAuctionSoft.SaleItem\u003e()]\n\n            case \"DirectOfferEscrow\" :\n                marketType = [Type\u003c@FindMarketDirectOfferEscrow.SaleItem\u003e()]\n\n            case \"DirectOfferSoft\" :\n                marketType = [Type\u003c@FindMarketDirectOfferSoft.SaleItem\u003e()]\n\n        }\n\n        let saleItem = FindMarket.TenantSaleItem(name:\"FlowDandy\".concat(market), cut: nil, rules:[\n            FindMarket.TenantRule(name:\"Flow\", types:[Type\u003c@FUSD.Vault\u003e()], ruleType: \"ft\", allow: true),\n            FindMarket.TenantRule(name:\"Dandy\", types:[Type\u003c@Dandy.NFT\u003e()], ruleType: \"nft\", allow: true),\n            FindMarket.TenantRule(name: market, types:marketType, ruleType: \"listing\", allow: true)\n            ], \n            status: \"active\"\n        )\n\n        adminRef.setMarketOption(tenant: tenant, saleItem: saleItem)\n    }\n}",
               "spec": {
                  "order": [
                     "tenant",
                     "market"
                  ],
                  "parameters": {
                     "market": "String",
                     "tenant": "Address"
                  }
               }
            },
            "adminSetSellDandyForFlow": {
               "code": "import FindMarket from 0xf8d6e0586b0a20c7\nimport Admin from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport Dandy from 0xf8d6e0586b0a20c7\nimport FindMarketSale from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionSoft from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\n\n\ntransaction(tenant: Address, market: String){\n    prepare(account: AuthAccount){\n        let adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n\n        var marketType : [Type] = [Type\u003c@FindMarketSale.SaleItem\u003e()]\n        switch market {\n            case \"AuctionEscrow\" :\n                marketType = [Type\u003c@FindMarketAuctionEscrow.SaleItem\u003e()]\n\n            case \"AuctionSoft\" :\n                marketType = [Type\u003c@FindMarketAuctionSoft.SaleItem\u003e()]\n\n            case \"DirectOfferEscrow\" :\n                marketType = [Type\u003c@FindMarketDirectOfferEscrow.SaleItem\u003e()]\n\n            case \"DirectOfferSoft\" :\n                marketType = [Type\u003c@FindMarketDirectOfferSoft.SaleItem\u003e()]\n\n        }\n\n        let saleItem = FindMarket.TenantSaleItem(name:\"FlowDandy\".concat(market), cut: nil, rules:[\n            FindMarket.TenantRule(name:\"Flow\", types:[Type\u003c@FlowToken.Vault\u003e()], ruleType: \"ft\", allow: true),\n            FindMarket.TenantRule(name:\"Dandy\", types:[Type\u003c@Dandy.NFT\u003e()], ruleType: \"nft\", allow: true),\n            FindMarket.TenantRule(name: market, types:marketType, ruleType: \"listing\", allow: true)\n            ], \n            status: \"active\"\n        )\n\n        adminRef.setMarketOption(tenant: tenant, saleItem: saleItem)\n    }\n}",
               "spec": {
                  "order": [
                     "tenant",
                     "market"
                  ],
                  "parameters": {
                     "market": "String",
                     "tenant": "Address"
                  }
               }
            },
            "adminSetSellDandyRules": {
               "code": "import FindMarket from 0xf8d6e0586b0a20c7\nimport Admin from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport FUSD from 0xf8d6e0586b0a20c7\nimport Dandy from 0xf8d6e0586b0a20c7\n\ntransaction(tenant: Address) {\n    prepare(account: AuthAccount){\n        let adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n\n        let fusdDandy = FindMarket.TenantSaleItem(name:\"FUSDDandy\", cut: nil, rules:[\n            FindMarket.TenantRule(name:\"FUSD\", types:[Type\u003c@FUSD.Vault\u003e()], ruleType: \"ft\", allow: true),\n            FindMarket.TenantRule(name:\"Dandy\", types:[ Type\u003c@Dandy.NFT\u003e()], ruleType: \"nft\", allow: true)\n            ], \n            status: \"active\"\n        )\n\n        let flowDandy = FindMarket.TenantSaleItem(name:\"FlowDandy\", cut: nil, rules:[\n            FindMarket.TenantRule(name:\"Flow\", types:[Type\u003c@FlowToken.Vault\u003e()], ruleType: \"ft\", allow: true),\n            FindMarket.TenantRule(name:\"Dandy\", types:[ Type\u003c@Dandy.NFT\u003e()], ruleType: \"nft\", allow: true)\n            ], \n            status: \"active\"\n        )\n\n        adminRef.setMarketOption(tenant: tenant, saleItem: fusdDandy)\n        adminRef.setMarketOption(tenant: tenant, saleItem: flowDandy)\n\n    }\n}",
               "spec": {
                  "order": [
                     "tenant"
                  ],
                  "parameters": {
                     "tenant": "Address"
                  }
               }
            },
            "adminTransferAllFusd": {
               "code": "// Mainnet\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FUSD from 0xf8d6e0586b0a20c7\n\n// Testnet\n// import FungibleToken from 0x9a0766d93b6608b7\n// import FUSD from 0xe223d8a629e49c68\n\ntransaction(recipient: Address) {\n\n  // The Vault resource that holds the tokens that are being transfered\n  let sentVault: @FungibleToken.Vault\n\n  prepare(signer: AuthAccount) {\n    // Get a reference to the signer's stored vault\n    let vaultRef = signer.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault)\n      ?? panic(\"Could not borrow reference to the owner's Vault!\")\n\n    // Withdraw tokens from the signer's stored vault\n    self.sentVault \u003c- vaultRef.withdraw(amount: vaultRef.balance)\n  }\n\n  execute {\n    // Get the recipient's public account object\n    let recipientAccount = getAccount(recipient)\n\n    // Get a reference to the recipient's Receiver\n    let receiverRef = recipientAccount.getCapability(/public/fusdReceiver)!\n      .borrow\u003c\u0026{FungibleToken.Receiver}\u003e()\n      ?? panic(\"Could not borrow receiver reference to the recipient's Vault\")\n\n    // Deposit the withdrawn tokens in the recipient's receiver\n    receiverRef.deposit(from: \u003c-self.sentVault)\n  }\n}",
               "spec": {
                  "order": [
                     "recipient"
                  ],
                  "parameters": {
                     "recipient": "Address"
                  }
               }
            },
            "alterMarketOption": {
               "code": "import FindMarket from 0xf8d6e0586b0a20c7\n\ntransaction(marketRule: String , action: String ){\n    prepare(account: AuthAccount){\n        let path = FindMarket.TenantClientStoragePath\n        let tenantRef = account.borrow\u003c\u0026FindMarket.TenantClient\u003e(from: path) ?? panic(\"Cannot borrow Reference.\")\n\n\n        switch action {\n            case \"enable\" :\n                tenantRef.enableMarketOption(marketRule)\n\n            case \"deprecate\" :\n                tenantRef.deprecateMarketOption(marketRule)\n\n            case \"stop\" :\n                tenantRef.stopMarketOption(marketRule)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "marketRule",
                     "action"
                  ],
                  "parameters": {
                     "action": "String",
                     "marketRule": "String"
                  }
               }
            },
            "bidMarketAuctionEscrowed": {
               "code": "import FindMarketAuctionEscrow from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FindViews from 0xf8d6e0586b0a20c7\nimport NFTRegistry from 0xf8d6e0586b0a20c7\nimport FTRegistry from 0xf8d6e0586b0a20c7\nimport FindMarket from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\n\ntransaction(marketplace:Address, user: String, id: UInt64, amount: UFix64) {\n\n    let saleItemsCap: Capability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic}\u003e \n    let targetCapability : Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e\n    let walletReference : \u0026FungibleToken.Vault\n    let bidsReference: \u0026FindMarketAuctionEscrow.MarketBidCollection?\n    let balanceBeforeBid: UFix64\n    let pointer: FindViews.ViewReadPointer\n\n    prepare(account: AuthAccount) {\n\n        let resolveAddress = FIND.resolve(user)\n        if resolveAddress == nil {panic(\"The address input is not a valid name nor address. Input : \".concat(user))}\n        let address = resolveAddress!\n\n        self.saleItemsCap= FindMarketAuctionEscrow.getSaleItemCapability(marketplace:marketplace, user:address) ?? panic(\"cannot find sale item cap\")\n\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e())\n        let item = FindMarket.assertOperationValid(tenant: marketplace, address: address, marketOption: marketOption, id: id)\n\n        let nft = NFTRegistry.getNFTInfoByTypeIdentifier(item.getItemType().identifier) ?? panic(\"This NFT is not supported by the Find Market yet \")\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet\")\n    \n        self.targetCapability= account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(nft.publicPath)\n        /* Check for nftCapability */\n        if !self.targetCapability.check() {\n            let cd = item.getNFTCollectionData()\n            // should use account.type here instead\n            if account.borrow\u003c\u0026AnyResource\u003e(from: cd.storagePath) != nil {\n                panic(\"This collection public link is not set up properly.\")\n            }\n            account.save(\u003c- cd.createEmptyCollection(), to: cd.storagePath)\n            account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.publicPath, target: cd.storagePath)\n            account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.providerPath, target: cd.storagePath)\n        }\n        \n        self.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e())!\n\n        self.bidsReference= account.borrow\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection\u003e(from: storagePath)\n        self.balanceBeforeBid=self.walletReference.balance\n        self.pointer= FindViews.createViewReadPointer(address: address, path:nft.publicPath, id: id)\n    }\n\n    pre {\n        self.bidsReference != nil : \"This account does not have a bid collection\"\n        self.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount) \n        self.bidsReference!.bid(item:self.pointer, vault: \u003c- vault, nftCap: self.targetCapability, bidExtraField: {})\n    }\n\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "user",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64",
                     "marketplace": "Address",
                     "user": "String"
                  }
               }
            },
            "bidMarketAuctionSoft": {
               "code": "import FindMarketAuctionSoft from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FindViews from 0xf8d6e0586b0a20c7\nimport FTRegistry from 0xf8d6e0586b0a20c7\nimport NFTRegistry from 0xf8d6e0586b0a20c7\nimport FindMarket from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\n\ntransaction(marketplace:Address, user: String, id: UInt64, amount: UFix64) {\n\n    let saleItemsCap: Capability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic}\u003e \n    let targetCapability : Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e\n    let walletReference : \u0026FungibleToken.Vault\n    let bidsReference: \u0026FindMarketAuctionSoft.MarketBidCollection?\n    let balanceBeforeBid: UFix64\n    let pointer: FindViews.ViewReadPointer\n    let ftVaultType: Type\n\n    prepare(account: AuthAccount) {\n\n        let resolveAddress = FIND.resolve(user)\n        if resolveAddress == nil {panic(\"The address input is not a valid name nor address. Input : \".concat(user))}\n        let address = resolveAddress!\n\n        self.saleItemsCap= FindMarketAuctionSoft.getSaleItemCapability(marketplace:marketplace, user:address) ?? panic(\"cannot find sale item cap\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e())\n\n        let item = FindMarket.assertOperationValid(tenant: marketplace, address: address, marketOption: marketOption, id: id)\n\n        let nft = NFTRegistry.getNFTInfoByTypeIdentifier(item.getItemType().identifier) ?? panic(\"This NFT is not supported by the Find Market yet \")\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet\")\n    \n        self.targetCapability= account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(nft.publicPath)\n        /* Check for nftCapability */\n        if !self.targetCapability.check() {\n            let cd = item.getNFTCollectionData()\n            // should use account.type here instead\n            if account.borrow\u003c\u0026AnyResource\u003e(from: cd.storagePath) != nil {\n                panic(\"This collection public link is not set up properly.\")\n            }\n            account.save(\u003c- cd.createEmptyCollection(), to: cd.storagePath)\n            account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.publicPath, target: cd.storagePath)\n            account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.providerPath, target: cd.storagePath)\n        }\n        \n        self.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No FUSD wallet linked for this account\")\n        self.ftVaultType = ft.type\n\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e())\n\n        self.bidsReference= account.borrow\u003c\u0026FindMarketAuctionSoft.MarketBidCollection\u003e(from: storagePath)\n        self.balanceBeforeBid=self.walletReference.balance\n        self.pointer= FindViews.createViewReadPointer(address: address, path:nft.publicPath, id: id)\n    }\n\n    pre {\n        self.bidsReference != nil : \"This account does not have a bid collection\"\n        self.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n    }\n\n    execute {\n        self.bidsReference!.bid(item:self.pointer, amount: amount, vaultType: self.ftVaultType, nftCap: self.targetCapability, bidExtraField: {})\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "user",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64",
                     "marketplace": "Address",
                     "user": "String"
                  }
               }
            },
            "bidMarketDirectOfferEscrowed": {
               "code": "import FindMarket from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferEscrow from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FindViews from 0xf8d6e0586b0a20c7\nimport FTRegistry from 0xf8d6e0586b0a20c7\nimport NFTRegistry from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\n\ntransaction(marketplace:Address, user: String, nftAliasOrIdentifier: String, id: UInt64, ftAliasOrIdentifier:String, amount: UFix64, validUntil: UFix64?) {\n\n    let targetCapability : Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e\n    let walletReference : \u0026FungibleToken.Vault\n    let bidsReference: \u0026FindMarketDirectOfferEscrow.MarketBidCollection?\n    let balanceBeforeBid: UFix64\n    let pointer: FindViews.ViewReadPointer\n\n    prepare(account: AuthAccount) {\n\n        let resolveAddress = FIND.resolve(user)\n        if resolveAddress == nil {panic(\"The address input is not a valid name nor address. Input : \".concat(user))}\n        let address = resolveAddress!\n\n        let nft = NFTRegistry.getNFTInfo(nftAliasOrIdentifier) ?? panic(\"This NFT is not supported by the Find Market yet\")\n        let ft = FTRegistry.getFTInfo(ftAliasOrIdentifier) ?? panic(\"This FT is not supported by the Find Market yet\")\n        \n        self.targetCapability= account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(nft.publicPath)\n        self.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e())!\n\n        self.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection\u003e(from: storagePath)\n        self.balanceBeforeBid=self.walletReference.balance\n        self.pointer= FindViews.createViewReadPointer(address: address, path:nft.publicPath, id: id)\n\n        /* Check for nftCapability */\n        if !self.targetCapability.check() {\n            let cd = self.pointer.getNFTCollectionData()\n            // should use account.type here instead\n            if account.borrow\u003c\u0026AnyResource\u003e(from: cd.storagePath) != nil {\n                panic(\"This collection public link is not set up properly.\")\n            }\n            account.save(\u003c- cd.createEmptyCollection(), to: cd.storagePath)\n            account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.publicPath, target: cd.storagePath)\n            account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.providerPath, target: cd.storagePath)\n        }\n    }\n\n    pre {\n        self.bidsReference != nil : \"This account does not have a bid collection\"\n        self.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount) \n        self.bidsReference!.bid(item:self.pointer, vault: \u003c- vault, nftCap: self.targetCapability, validUntil: validUntil, saleItemExtraField: {}, bidExtraField: {})\n    }\n\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "user",
                     "nftAliasOrIdentifier",
                     "id",
                     "ftAliasOrIdentifier",
                     "amount",
                     "validUntil"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "ftAliasOrIdentifier": "String",
                     "id": "UInt64",
                     "marketplace": "Address",
                     "nftAliasOrIdentifier": "String",
                     "user": "String",
                     "validUntil": "UFix64?"
                  }
               }
            },
            "bidMarketDirectOfferSoft": {
               "code": "import FindMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\nimport FindMarket from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FindViews from 0xf8d6e0586b0a20c7\nimport FTRegistry from 0xf8d6e0586b0a20c7\nimport NFTRegistry from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\n\ntransaction(marketplace:Address, user: String, nftAliasOrIdentifier: String, id: UInt64, ftAliasOrIdentifier:String, amount: UFix64, validUntil: UFix64?) {\n\n    let targetCapability : Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e\n    let walletReference : \u0026FungibleToken.Vault\n    let bidsReference: \u0026FindMarketDirectOfferSoft.MarketBidCollection?\n    let balanceBeforeBid: UFix64\n    let pointer: FindViews.ViewReadPointer\n    let ftVaultType: Type\n\n    prepare(account: AuthAccount) {\n        \n        let resolveAddress = FIND.resolve(user)\n        if resolveAddress == nil {panic(\"The address input is not a valid name nor address. Input : \".concat(user))}\n        let address = resolveAddress!\n\n        let nft = NFTRegistry.getNFTInfo(nftAliasOrIdentifier) ?? panic(\"This NFT is not supported by the Find Market yet\")\n        let ft = FTRegistry.getFTInfo(ftAliasOrIdentifier) ?? panic(\"This FT is not supported by the Find Market yet\")\n\n        self.ftVaultType = ft.type\n\n        self.targetCapability= account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(nft.publicPath)\n        self.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())!\n        self.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection\u003e(from: storagePath)\n        self.balanceBeforeBid=self.walletReference.balance\n        self.pointer= FindViews.createViewReadPointer(address: address, path:nft.publicPath, id: id)\n\n        /* Check for nftCapability */\n        if !self.targetCapability.check() {\n            let cd = self.pointer.getNFTCollectionData()\n            // should use account.type here instead\n            if account.borrow\u003c\u0026AnyResource\u003e(from: cd.storagePath) != nil {\n                panic(\"This collection public link is not set up properly.\")\n            }\n            account.save(\u003c- cd.createEmptyCollection(), to: cd.storagePath)\n            account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.publicPath, target: cd.storagePath)\n            account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.providerPath, target: cd.storagePath)\n        }\n    }\n\n    pre {\n        self.bidsReference != nil : \"This account does not have a bid collection\"\n        self.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n    }\n\n    execute {\n        self.bidsReference!.bid(item:self.pointer, amount: amount, vaultType: self.ftVaultType, nftCap: self.targetCapability, validUntil: validUntil, saleItemExtraField: {}, bidExtraField: {})\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "user",
                     "nftAliasOrIdentifier",
                     "id",
                     "ftAliasOrIdentifier",
                     "amount",
                     "validUntil"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "ftAliasOrIdentifier": "String",
                     "id": "UInt64",
                     "marketplace": "Address",
                     "nftAliasOrIdentifier": "String",
                     "user": "String",
                     "validUntil": "UFix64?"
                  }
               }
            },
            "bidName": {
               "code": "import FungibleToken from 0xee82856bf20e2aa6\nimport FUSD from 0xf8d6e0586b0a20c7\nimport FiatToken from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport Profile from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\nimport Dandy from 0xf8d6e0586b0a20c7\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FindMarketSale from 0xf8d6e0586b0a20c7\nimport FindMarket from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionSoft from 0xf8d6e0586b0a20c7\n\ntransaction(name: String, amount: UFix64) {\n    prepare(acct: AuthAccount) {\n\n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n        //SYNC with register\n        //Add exising FUSD or create a new one and add it\n        let fusdReceiver = acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n        if !fusdReceiver.check() {\n            let fusd \u003c- FUSD.createEmptyVault()\n            acct.save(\u003c- fusd, to: /storage/fusdVault)\n            acct.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n            acct.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n        }\n\n        let usdcCap = acct.getCapability\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e(FiatToken.VaultReceiverPubPath)\n        if !usdcCap.check() {\n                acct.save( \u003c-FiatToken.createEmptyVault(), to: FiatToken.VaultStoragePath)\n        acct.link\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e( FiatToken.VaultReceiverPubPath, target: FiatToken.VaultStoragePath)\n        acct.link\u003c\u0026FiatToken.Vault{FiatToken.ResourceId}\u003e( FiatToken.VaultUUIDPubPath, target: FiatToken.VaultStoragePath)\n                acct.link\u003c\u0026FiatToken.Vault{FungibleToken.Balance}\u003e( FiatToken.VaultBalancePubPath, target:FiatToken.VaultStoragePath)\n        }\n\n        let leaseCollection = acct.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            acct.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            acct.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = acct.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            acct.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            acct.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let dandyCap= acct.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            acct.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            acct.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            acct.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        var created=false\n        let profileCap = acct.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            acct.save(\u003c-profile, to: Profile.storagePath)\n            acct.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            acct.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=acct.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n        if !profile.hasWallet(\"Flow\") {\n            let flowWallet=Profile.Wallet( name:\"Flow\", receiver:acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:acct.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), names: [\"flow\"])\n    \n            profile.addWallet(flowWallet)\n        }\n        if !profile.hasWallet(\"FUSD\") {\n            profile.addWallet(Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:acct.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), names: [\"fusd\", \"stablecoin\"]))\n        }\n\n        if !profile.hasWallet(\"USDC\") {\n            profile.addWallet(Profile.Wallet( name:\"USDC\", receiver:usdcCap, balance:acct.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(FiatToken.VaultBalancePubPath), accept: Type\u003c@FiatToken.Vault\u003e(), names: [\"usdc\", \"stablecoin\"]))\n        }\n\n         //If find name not set and we have a profile set it.\n        if profile.getFindName() == \"\" {\n            profile.setFindName(name)\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else {\n            profile.emitUpdatedEvent()\n        }\n\n        let receiverCap=acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let tenantCapability= FindMarket.getTenantCapability(FindMarket.getFindTenantAddress())!\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= acct.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            acct.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            acct.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        let doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        let doeSalePublicPath=FindMarket.getPublicPath(doeSaleType, name: tenant.name)\n        let doeSaleStoragePath= FindMarket.getStoragePath(doeSaleType, name:tenant.name)\n        let doeSaleCap= acct.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n        if !doeSaleCap.check() {\n            acct.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n            acct.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n        }\n\n        let doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        let doeBidPublicPath=FindMarket.getPublicPath(doeBidType, name: tenant.name)\n        let doeBidStoragePath= FindMarket.getStoragePath(doeBidType, name:tenant.name)\n        let doeBidCap= acct.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n        if !doeBidCap.check() {\n            acct.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n            acct.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n        }\n\n        /// auctions that escrow ft\n        let aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        let aeSalePublicPath=FindMarket.getPublicPath(aeSaleType, name: tenant.name)\n        let aeSaleStoragePath= FindMarket.getStoragePath(aeSaleType, name:tenant.name)\n        let aeSaleCap= acct.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n        if !aeSaleCap.check() {\n            acct.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n            acct.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n        }\n\n        let dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\n        let dosSalePublicPath=FindMarket.getPublicPath(dosSaleType, name: tenant.name)\n        let dosSaleStoragePath= FindMarket.getStoragePath(dosSaleType, name:tenant.name)\n\n        let dosSaleCap= acct.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n        if !dosSaleCap.check() {\n            acct.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n            acct.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n        }\n\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= acct.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n        if !dosBidCap.check() {\n            acct.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            acct.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n        }\n\n        let aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\n        let aeBidPublicPath=FindMarket.getPublicPath(aeBidType, name: tenant.name)\n        let aeBidStoragePath= FindMarket.getStoragePath(aeBidType, name:tenant.name)\n        let aeBidCap= acct.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n        if !aeBidCap.check() {\n            acct.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n            acct.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n        }\n\n     /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= acct.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            acct.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            acct.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n        }\n\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= acct.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n        if !asBidCap.check() {\n            acct.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            acct.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n        }\n        //SYNC with register\n\n\n        let vaultRef = acct.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault) ?? panic(\"Could not borrow reference to the fusdVault!\")\n        let vault \u003c- vaultRef.withdraw(amount: amount) as! @FUSD.Vault\n        let bids = acct.borrow\u003c\u0026FIND.BidCollection\u003e(from: FIND.BidStoragePath)!\n        bids.bid(name: name, vault: \u003c- vault)\n\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "name": "String"
                  }
               }
            },
            "buyAddon": {
               "code": "import FUSD from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\n\n\ntransaction(name: String, addon:String, amount:UFix64) {\n    prepare(account: AuthAccount) {\n\n        let leases= account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n\n        let vaultRef = account.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault) ?? panic(\"Could not borrow reference to the fusdVault!\")\n        let vault \u003c- vaultRef.withdraw(amount: amount) as! @FUSD.Vault\n        leases.buyAddon(name: name, addon: addon, vault: \u003c- vault)\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "addon",
                     "amount"
                  ],
                  "parameters": {
                     "addon": "String",
                     "amount": "UFix64",
                     "name": "String"
                  }
               }
            },
            "buyNFTForSale": {
               "code": "import FindMarket from 0xf8d6e0586b0a20c7\nimport FindMarketSale from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport NFTRegistry from 0xf8d6e0586b0a20c7\nimport FTRegistry from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\n\ntransaction(marketplace:Address, user: String, id: UInt64, amount: UFix64) {\n\n    let targetCapability : Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e\n    let walletReference : \u0026FungibleToken.Vault\n\n    let saleItemsCap: Capability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic}\u003e \n\n    prepare(account: AuthAccount) {\n\n        let resolveAddress = FIND.resolve(user)\n        if resolveAddress == nil {\n            panic(\"The address input is not a valid name nor address. Input : \".concat(user))\n        }\n        let address = resolveAddress!\n        self.saleItemsCap= FindMarketSale.getSaleItemCapability(marketplace: marketplace, user:address) ?? panic(\"cannot find sale item cap\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketSale.SaleItemCollection\u003e())\n\n        let item= FindMarket.assertOperationValid(tenant: marketplace, address: address, marketOption: marketOption, id: id)\n\n        let nft = NFTRegistry.getNFTInfoByTypeIdentifier(item.getItemType().identifier) ?? panic(\"This NFT is not supported by the Find Market yet \")\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet\")\n    \n        self.targetCapability= account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(nft.publicPath)\n        /* Check for nftCapability */\n        if !self.targetCapability.check() {\n            let cd = item.getNFTCollectionData()\n            // should use account.type here instead\n            if account.borrow\u003c\u0026AnyResource\u003e(from: cd.storagePath) != nil {\n                panic(\"This collection public link is not set up properly.\")\n            }\n            account.save(\u003c- cd.createEmptyCollection(), to: cd.storagePath)\n            account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.publicPath, target: cd.storagePath)\n            account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.providerPath, target: cd.storagePath)\n        }\n\n        self.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n    }\n\n    pre {\n        self.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount) \n        self.saleItemsCap.borrow()!.buy(id:id, vault: \u003c- vault, nftCap: self.targetCapability)\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "user",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64",
                     "marketplace": "Address",
                     "user": "String"
                  }
               }
            },
            "cancelMarketAuctionEscrowed": {
               "code": "import FindMarket from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionEscrow from 0xf8d6e0586b0a20c7\n\ntransaction(marketplace:Address, ids: [UInt64]) {\n    prepare(account: AuthAccount) {\n\n        let tenant=FindMarket.getTenant(marketplace)\n        let saleItems= account.borrow\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()))!\n        for id in ids {\n            saleItems.cancel(id)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "ids"
                  ],
                  "parameters": {
                     "ids": "[UInt64]",
                     "marketplace": "Address"
                  }
               }
            },
            "cancelMarketAuctionSoft": {
               "code": "import FindMarket from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionSoft from 0xf8d6e0586b0a20c7\n\ntransaction(marketplace:Address, ids: [UInt64]) {\n    prepare(account: AuthAccount) {\n        let tenant=FindMarket.getTenant(marketplace)\n        let saleItems= account.borrow\u003c\u0026FindMarketAuctionSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()))!\n        for id in ids {\n            saleItems.cancel(id)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "ids"
                  ],
                  "parameters": {
                     "ids": "[UInt64]",
                     "marketplace": "Address"
                  }
               }
            },
            "cancelMarketDirectOfferEscrowed": {
               "code": "import FindMarket from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferEscrow from 0xf8d6e0586b0a20c7\n\ntransaction(marketplace:Address, ids: [UInt64]) {\n    prepare(account: AuthAccount) {\n\n        let tenant=FindMarket.getTenant(marketplace)\n        let saleItems= account.borrow\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()))!\n        for id in ids {\n            saleItems.cancel(id)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "ids"
                  ],
                  "parameters": {
                     "ids": "[UInt64]",
                     "marketplace": "Address"
                  }
               }
            },
            "cancelMarketDirectOfferSoft": {
               "code": "import FindMarket from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\n\ntransaction(marketplace:Address, ids: [UInt64]) {\n    prepare(account: AuthAccount) {\n\n        let tenant=FindMarket.getTenant(marketplace)\n        let saleItems= account.borrow\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()))!\n        for id in ids {\n            saleItems.cancel(id)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "ids"
                  ],
                  "parameters": {
                     "ids": "[UInt64]",
                     "marketplace": "Address"
                  }
               }
            },
            "cancelNameAuction": {
               "code": "import FIND from 0xf8d6e0586b0a20c7\n\ntransaction(names: [String]) {\n    prepare(account: AuthAccount) {\n\n        let finLeases= account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n        for name in names {\n            finLeases.cancel(name)\n            finLeases.delistAuction(name)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "names"
                  ],
                  "parameters": {
                     "names": "[String]"
                  }
               }
            },
            "cancelNameBid": {
               "code": "import FIND from 0xf8d6e0586b0a20c7\n\ntransaction(names: [String]) {\n    prepare(account: AuthAccount) {\n        let bids = account.borrow\u003c\u0026FIND.BidCollection\u003e(from: FIND.BidStoragePath)!\n        for name in names {\n            bids.cancelBid(name)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "names"
                  ],
                  "parameters": {
                     "names": "[String]"
                  }
               }
            },
            "createCharity": {
               "code": "import NonFungibleToken from 0xf8d6e0586b0a20c7\nimport CharityNFT from 0xf8d6e0586b0a20c7\n\n//This transaction will prepare the art collection\ntransaction() {\n    prepare(account: AuthAccount) {\n\n        let stdCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath)\n        if !stdCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- CharityNFT.createEmptyCollection(), to: CharityNFT.CollectionStoragePath)\n            account.link\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath, target: CharityNFT.CollectionStoragePath)\n        }\n\n        let charityCap = account.getCapability\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection)\n        if !charityCap.check() {\n            account.link\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection, target: CharityNFT.CollectionStoragePath)\n        }\n    }\n}",
               "spec": null
            },
            "createProfile": {
               "code": "import FungibleToken from 0xee82856bf20e2aa6\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport FUSD from 0xf8d6e0586b0a20c7\nimport FiatToken from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\nimport Profile from 0xf8d6e0586b0a20c7\nimport FindMarket from 0xf8d6e0586b0a20c7\nimport FindMarketSale from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionSoft from 0xf8d6e0586b0a20c7\nimport Dandy from 0xf8d6e0586b0a20c7\n\ntransaction(name: String) {\n    prepare(acct: AuthAccount) {\n        //if we do not have a profile it might be stored under a different address so we will just remove it\n        let profileCapFirst = acct.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if profileCapFirst.check() {\n            return \n        }\n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n        //SYNC with register\n        //Add exising FUSD or create a new one and add it\n        let fusdReceiver = acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n        if !fusdReceiver.check() {\n            let fusd \u003c- FUSD.createEmptyVault()\n            acct.save(\u003c- fusd, to: /storage/fusdVault)\n            acct.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n            acct.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n        }\n\n        let usdcCap = acct.getCapability\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e(FiatToken.VaultReceiverPubPath)\n        if !usdcCap.check() {\n                acct.save( \u003c-FiatToken.createEmptyVault(), to: FiatToken.VaultStoragePath)\n        acct.link\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e( FiatToken.VaultReceiverPubPath, target: FiatToken.VaultStoragePath)\n        acct.link\u003c\u0026FiatToken.Vault{FiatToken.ResourceId}\u003e( FiatToken.VaultUUIDPubPath, target: FiatToken.VaultStoragePath)\n                acct.link\u003c\u0026FiatToken.Vault{FungibleToken.Balance}\u003e( FiatToken.VaultBalancePubPath, target:FiatToken.VaultStoragePath)\n        }\n\n        let leaseCollection = acct.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            acct.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            acct.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = acct.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            acct.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            acct.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let dandyCap= acct.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            acct.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            acct.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            acct.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        var created=false\n        let profileCap = acct.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            acct.save(\u003c-profile, to: Profile.storagePath)\n            acct.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            acct.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=acct.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n        if !profile.hasWallet(\"Flow\") {\n            let flowWallet=Profile.Wallet( name:\"Flow\", receiver:acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:acct.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), names: [\"flow\"])\n    \n            profile.addWallet(flowWallet)\n        }\n        if !profile.hasWallet(\"FUSD\") {\n            profile.addWallet(Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:acct.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), names: [\"fusd\", \"stablecoin\"]))\n        }\n\n        if !profile.hasWallet(\"USDC\") {\n            profile.addWallet(Profile.Wallet( name:\"USDC\", receiver:usdcCap, balance:acct.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(FiatToken.VaultBalancePubPath), accept: Type\u003c@FiatToken.Vault\u003e(), names: [\"usdc\", \"stablecoin\"]))\n        }\n\n         //If find name not set and we have a profile set it.\n        if profile.getFindName() == \"\" {\n            profile.setFindName(name)\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else {\n            profile.emitUpdatedEvent()\n        }\n\n        let receiverCap=acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let tenantCapability= FindMarket.getTenantCapability(FindMarket.getFindTenantAddress())!\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= acct.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            acct.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            acct.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        let doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        let doeSalePublicPath=FindMarket.getPublicPath(doeSaleType, name: tenant.name)\n        let doeSaleStoragePath= FindMarket.getStoragePath(doeSaleType, name:tenant.name)\n        let doeSaleCap= acct.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n        if !doeSaleCap.check() {\n            acct.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n            acct.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n        }\n\n        let doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        let doeBidPublicPath=FindMarket.getPublicPath(doeBidType, name: tenant.name)\n        let doeBidStoragePath= FindMarket.getStoragePath(doeBidType, name:tenant.name)\n        let doeBidCap= acct.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n        if !doeBidCap.check() {\n            acct.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n            acct.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n        }\n\n        /// auctions that escrow ft\n        let aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        let aeSalePublicPath=FindMarket.getPublicPath(aeSaleType, name: tenant.name)\n        let aeSaleStoragePath= FindMarket.getStoragePath(aeSaleType, name:tenant.name)\n        let aeSaleCap= acct.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n        if !aeSaleCap.check() {\n            acct.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n            acct.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n        }\n\n        let dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\n        let dosSalePublicPath=FindMarket.getPublicPath(dosSaleType, name: tenant.name)\n        let dosSaleStoragePath= FindMarket.getStoragePath(dosSaleType, name:tenant.name)\n\n        let dosSaleCap= acct.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n        if !dosSaleCap.check() {\n            acct.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n            acct.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n        }\n\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= acct.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n        if !dosBidCap.check() {\n            acct.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            acct.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n        }\n\n        let aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\n        let aeBidPublicPath=FindMarket.getPublicPath(aeBidType, name: tenant.name)\n        let aeBidStoragePath= FindMarket.getStoragePath(aeBidType, name:tenant.name)\n        let aeBidCap= acct.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n        if !aeBidCap.check() {\n            acct.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n            acct.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n        }\n\n     /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= acct.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            acct.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            acct.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n        }\n\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= acct.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n        if !asBidCap.check() {\n            acct.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            acct.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n        }\n        //SYNC with register\n\n    }\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "delistAllNFTSale": {
               "code": "import FindMarketSale from 0xf8d6e0586b0a20c7\nimport FindMarket from 0xf8d6e0586b0a20c7\n\ntransaction(marketplace:Address) {\n    prepare(account: AuthAccount) {\n        // Get all the saleItems Id\n\n        let tenant = FindMarket.getTenant(marketplace)\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketSale.SaleItem\u003e())\n        let cap = FindMarket.getSaleItemCollectionCapability(tenantRef: tenant, marketOption: marketOption, address: account.address)\n        let ref = cap.borrow() ?? panic(\"Cannot borrow reference to the capability.\")\n\n        let listingType=Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let saleItems= account.borrow\u003c\u0026FindMarketSale.SaleItemCollection\u003e(from: tenant.getStoragePath(listingType))!\n        let ids = ref.getIds()\n        for id in ids {\n            saleItems.delist(id)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace"
                  ],
                  "parameters": {
                     "marketplace": "Address"
                  }
               }
            },
            "delistAllNameSale": {
               "code": "import FIND from 0xf8d6e0586b0a20c7\n\ntransaction() {\n    prepare(acct: AuthAccount) {\n        let finLeases= acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n        let leases = finLeases.getLeaseInformation()\n        for lease in leases {\n            if lease.salePrice != nil {\n                finLeases.delistSale(lease.name)\n            }\n        }\n    }\n}",
               "spec": null
            },
            "delistNFTSale": {
               "code": "import FindMarket from 0xf8d6e0586b0a20c7\nimport FindMarketSale from 0xf8d6e0586b0a20c7\n\ntransaction(marketplace:Address, ids: [UInt64]) {\n    prepare(account: AuthAccount) {\n\n        let tenant=FindMarket.getTenant(marketplace)\n        let saleItems= account.borrow\u003c\u0026FindMarketSale.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketSale.SaleItemCollection\u003e()))!\n        for id in ids {\n            saleItems.delist(id)\n        }\n\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "ids"
                  ],
                  "parameters": {
                     "ids": "[UInt64]",
                     "marketplace": "Address"
                  }
               }
            },
            "delistNameSale": {
               "code": "import FIND from 0xf8d6e0586b0a20c7\n\ntransaction(names: [String]) {\n    prepare(acct: AuthAccount) {\n        let finLeases= acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n        for name in names {\n            finLeases.delistSale(name)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "names"
                  ],
                  "parameters": {
                     "names": "[String]"
                  }
               }
            },
            "editProfile": {
               "code": "import FungibleToken from 0xee82856bf20e2aa6\nimport FUSD from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport FIND from 0xf8d6e0586b0a20c7\nimport Profile from 0xf8d6e0586b0a20c7\n\ntransaction(name:String, description: String, avatar: String, tags:[String], allowStoringFollowers: Bool, linkTitles : {String: String}, linkTypes: {String:String}, linkUrls : {String:String}, removeLinks : [String]) {\n    prepare(acct: AuthAccount) {\n\n        let profile =acct.borrow\u003c\u0026Profile.User\u003e(from:Profile.storagePath)!\n\n        //Add exising FUSD or create a new one and add it\n        let fusdReceiver = acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n        if !fusdReceiver.check() {\n            let fusd \u003c- FUSD.createEmptyVault()\n            acct.save(\u003c- fusd, to: /storage/fusdVault)\n            acct.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n            acct.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n        }\n\n\n        var hasFusdWallet=false\n        var hasFlowWallet=false\n        let wallets=profile.getWallets()\n        for wallet in wallets {\n            if wallet.name==\"FUSD\" {\n                hasFusdWallet=true\n            }\n\n            if wallet.name ==\"Flow\" {\n                hasFlowWallet=true\n            }\n        }\n\n        if !hasFlowWallet {\n            let flowWallet=Profile.Wallet(\n                name:\"Flow\", \n                receiver:acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver),\n                balance:acct.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance),\n                accept: Type\u003c@FlowToken.Vault\u003e(),\n                names: [\"flow\"]\n            )\n            profile.addWallet(flowWallet)\n        }\n\n        if !hasFusdWallet {\n            let fusdWallet=Profile.Wallet(\n                name:\"FUSD\", \n                receiver:acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver),\n                balance:acct.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance),\n                accept: Type\u003c@FUSD.Vault\u003e(),\n                names: [\"fusd\", \"stablecoin\"]\n            )\n            profile.addWallet(fusdWallet)\n        }\n\n        profile.setName(name)\n        profile.setDescription(description)\n        profile.setAvatar(avatar)\n        profile.setTags(tags)\n\n        for link in removeLinks {\n            profile.removeLink(link)\n        }\n\n        for titleName in linkTitles.keys {\n            let title=linkTitles[titleName]!\n            let url = linkUrls[titleName]!\n            let type = linkTypes[titleName]!\n\n            profile.addLinkWithName(name:titleName, link: Profile.Link(title: title, type: type, url: type))\n        }\n        profile.emitUpdatedEvent()\n\n        let leaseCollection = acct.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            acct.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            acct.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n\n        }\n\n        let bidCollection = acct.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            acct.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            acct.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "description",
                     "avatar",
                     "tags",
                     "allowStoringFollowers",
                     "linkTitles",
                     "linkTypes",
                     "linkUrls",
                     "removeLinks"
                  ],
                  "parameters": {
                     "allowStoringFollowers": "Bool",
                     "avatar": "String",
                     "description": "String",
                     "linkTitles": "{String: String}",
                     "linkTypes": "{String: String}",
                     "linkUrls": "{String: String}",
                     "name": "String",
                     "removeLinks": "[String]",
                     "tags": "[String]"
                  }
               }
            },
            "fulfillMarketAuctionEscrowed": {
               "code": "import FindMarketAuctionEscrow from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\n\ntransaction(marketplace:Address, owner: String, id: UInt64) {\n    prepare(account: AuthAccount) {\n        let resolveAddress = FIND.resolve(owner)\n        if resolveAddress == nil { \n            panic(\"The address input is not a valid name nor address. Input : \".concat(owner))\n        }\n        let address = resolveAddress!\n        FindMarketAuctionEscrow.getSaleItemCapability(marketplace:marketplace, user:address)!.borrow()!.fulfillAuction(id)\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "owner",
                     "id"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "marketplace": "Address",
                     "owner": "String"
                  }
               }
            },
            "fulfillMarketAuctionEscrowedFromBidder": {
               "code": "import FindMarketAuctionEscrow from 0xf8d6e0586b0a20c7\nimport FindMarket from 0xf8d6e0586b0a20c7\n\ntransaction(marketplace:Address, id: UInt64) {\n    prepare(account: AuthAccount) {\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e())!\n        let bidsReference= account.borrow\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection\u003e(from: storagePath)!\n\n        bidsReference.fulfillAuction(id)\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "fulfillMarketAuctionSoft": {
               "code": "import FindMarketAuctionSoft from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FTRegistry from 0xf8d6e0586b0a20c7\nimport FindMarket from 0xf8d6e0586b0a20c7\n\ntransaction(marketplace:Address, id: UInt64, amount:UFix64) {\n\n    let walletReference : \u0026FungibleToken.Vault\n    let bidsReference: \u0026FindMarketAuctionSoft.MarketBidCollection\n    let requiredAmount: UFix64\n\n    prepare(account: AuthAccount) {\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e())\n\n        self.bidsReference= account.borrow\u003c\u0026FindMarketAuctionSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"This account does not have a bid collection\")\n\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e())\n        let item = FindMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: id)\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet\")\n    \n        self.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n        self.requiredAmount = self.bidsReference.getBalance(id)\n    }\n\n    pre{\n        self.walletReference.balance \u003e self.requiredAmount : \"Your wallet does not have enough funds to pay for this item\"\n        self.requiredAmount == amount : \"Amount needed to fulfill is \".concat(self.requiredAmount.toString()).concat(\" you sent in \").concat(amount.toString())\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount) \n        self.bidsReference.fulfillAuction(id: id, vault: \u003c- vault)\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "fulfillMarketDirectOfferEscrowed": {
               "code": "import FindMarketDirectOfferEscrow from 0xf8d6e0586b0a20c7\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FindViews from 0xf8d6e0586b0a20c7\nimport NFTRegistry from 0xf8d6e0586b0a20c7\nimport FindMarket from 0xf8d6e0586b0a20c7\n\ntransaction(marketplace:Address, id: UInt64) {\n    prepare(account: AuthAccount) {\n\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e())\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e())\n\n        let item = FindMarket.assertOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: id)\n\n        let nft = NFTRegistry.getNFTInfoByTypeIdentifier(item.getItemType().identifier) ?? panic(\"This NFT is not supported by the Find Market yet \")\n    \n        let providerCap=account.getCapability\u003c\u0026{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e(nft.providerPath)\n\n        /* Ben : Question -\u003e Either client will have to provide the path here or agree that we set it up for the user */\n        if !providerCap.check() {\n                account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                    nft.providerPath,\n                    target: nft.storagePath\n            )\n        }\n\n        let pointer= FindViews.AuthNFTPointer(cap: providerCap, id: id)\n        let market = account.borrow\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection\u003e(from: storagePath)!\n        market.acceptDirectOffer(pointer)\n\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "fulfillMarketDirectOfferSoft": {
               "code": "import FindMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FTRegistry from 0xf8d6e0586b0a20c7\nimport FindMarket from 0xf8d6e0586b0a20c7\n\ntransaction(marketplace:Address, id: UInt64, amount:UFix64) {\n\n    let walletReference : \u0026FungibleToken.Vault\n    let bidsReference: \u0026FindMarketDirectOfferSoft.MarketBidCollection\n    let requiredAmount:UFix64\n\n    prepare(account: AuthAccount) {\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n        self.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"Cannot borrow direct offer soft bid collection\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n        let item = FindMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: id)\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet\")\n\n      self.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n\n        self.requiredAmount = self.bidsReference.getBalance(id)\n    }\n\n    pre {\n        self.walletReference.balance \u003e self.requiredAmount : \"Your wallet does not have enough funds to pay for this item\"\n        self.requiredAmount == amount : \"Amount needed to fulfill is \".concat(amount.toString())\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount) \n        self.bidsReference.fulfillDirectOffer(id: id, vault: \u003c- vault)\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "fulfillName": {
               "code": "import FIND from 0xf8d6e0586b0a20c7\n\ntransaction(name: String) {\n    prepare(account: AuthAccount) {\n\n        let finLeases= account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n        finLeases.fulfill(name)\n\n    }\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "fulfillNameAuction": {
               "code": "import FIND from 0xf8d6e0586b0a20c7\n\ntransaction(owner: Address, name: String) {\n    prepare(account: AuthAccount) {\n        let leaseCollection = getAccount(owner).getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        let leaseRef = leaseCollection.borrow() ?? panic(\"Cannot borrow reference to lease collection reference\")\n        leaseRef.fulfillAuction(name)\n\n    }\n}",
               "spec": {
                  "order": [
                     "owner",
                     "name"
                  ],
                  "parameters": {
                     "name": "String",
                     "owner": "Address"
                  }
               }
            },
            "fulfillNameAuctionBidder": {
               "code": "import FIND from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FUSD from 0xf8d6e0586b0a20c7\nimport Profile from 0xf8d6e0586b0a20c7\n\ntransaction(owner: Address, name: String) {\n    prepare(acct: AuthAccount) {\n\n\n    //Add exising FUSD or create a new one and add it\n        let fusdReceiver = acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n        if !fusdReceiver.check() {\n            let fusd \u003c- FUSD.createEmptyVault()\n            acct.save(\u003c- fusd, to: /storage/fusdVault)\n            acct.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n            acct.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n        }\n\n        let leaseCollection = acct.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            acct.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            acct.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = acct.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            acct.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            acct.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let profileCap = acct.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n\n            let fusdWallet=Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:acct.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), names: [\"fusd\", \"stablecoin\"])\n\n            profile.addWallet(fusdWallet)\n\n            acct.save(\u003c-profile, to: Profile.storagePath)\n            acct.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            acct.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n        }\n\n        let leaseCollectionOwner = getAccount(owner).getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        leaseCollectionOwner.borrow()!.fulfillAuction(name)\n\n    }\n}",
               "spec": {
                  "order": [
                     "owner",
                     "name"
                  ],
                  "parameters": {
                     "name": "String",
                     "owner": "Address"
                  }
               }
            },
            "increaseBidMarketAuctionEscrowed": {
               "code": "import FindMarketAuctionEscrow from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FTRegistry from 0xf8d6e0586b0a20c7\nimport FindMarket from 0xf8d6e0586b0a20c7\n\ntransaction(marketplace:Address, id: UInt64, amount: UFix64) {\n\n    let walletReference : \u0026FungibleToken.Vault\n    let bidsReference: \u0026FindMarketAuctionEscrow.MarketBidCollection\n    let balanceBeforeBid: UFix64\n\n    prepare(account: AuthAccount) {\n\n        // Get the accepted vault type from BidInfo\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e())\n        self.bidsReference= account.borrow\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection\u003e(from: storagePath) ?? panic(\"This account does not have a bid collection\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e())\n        let item = FindMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: id)\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet\")\n        self.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n        self.balanceBeforeBid = self.walletReference.balance\n    }\n\n    pre {\n        self.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount) \n        self.bidsReference.increaseBid(id: id, vault: \u003c- vault)\n    }\n\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "increaseBidMarketAuctionSoft": {
               "code": "import FindMarketAuctionSoft from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FTRegistry from 0xf8d6e0586b0a20c7\nimport FindMarket from 0xf8d6e0586b0a20c7\n\ntransaction(marketplace:Address, id: UInt64, amount: UFix64) {\n\n    let bidsReference: \u0026FindMarketAuctionSoft.MarketBidCollection\n    let walletReference : \u0026FungibleToken.Vault\n\n\n    prepare(account: AuthAccount) {\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e())\n        self.bidsReference= account.borrow\u003c\u0026FindMarketAuctionSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"Bid resource does not exist\")\n        // get Bidding Fungible Token Vault\n          let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e())\n        let item = FindMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: id)\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet\")\n\n        self.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n    }\n\n    execute {\n        self.bidsReference.increaseBid(id: id, increaseBy: amount)\n    }\n\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "increaseBidMarketDirectOfferEscrowed": {
               "code": "import FindMarketDirectOfferEscrow from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FTRegistry from 0xf8d6e0586b0a20c7\nimport FindMarket from 0xf8d6e0586b0a20c7\n\ntransaction(marketplace:Address, id: UInt64, amount: UFix64) {\n\n    let walletReference : \u0026FungibleToken.Vault\n    let bidsReference: \u0026FindMarketDirectOfferEscrow.MarketBidCollection\n    let balanceBeforeBid: UFix64\n\n    prepare(account: AuthAccount) {\n        let tenant=FindMarket.getTenantCapability(marketplace)!.borrow() ?? panic(\"Cannot borrow reference to tenant\")\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e())\n        self.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection\u003e(from: storagePath) ?? panic(\"This account does not have a bid collection\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e())\n        let item = FindMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: id)\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet\")\n        self.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n        self.balanceBeforeBid=self.walletReference.balance\n    }\n\n    pre {\n        self.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount) \n        self.bidsReference!.increaseBid(id: id, vault: \u003c- vault)\n    }\n\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "increaseBidMarketDirectOfferSoft": {
               "code": "import FindMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\nimport FindMarket from 0xf8d6e0586b0a20c7\n\ntransaction(marketplace: Address, id: UInt64, amount: UFix64) {\n\n    let bidsReference: \u0026FindMarketDirectOfferSoft.MarketBidCollection\n\n    prepare(account: AuthAccount) {\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n        self.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"Bid resource does not exist\")\n        // get Bidding Fungible Token Vault\n          let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n        let item = FindMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: id)\n    }\n\n    execute {\n        self.bidsReference.increaseBid(id: id, increaseBy: amount)\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "increaseNameBid": {
               "code": "import FIND from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FUSD from 0xf8d6e0586b0a20c7\n\ntransaction(name: String, amount: UFix64) {\n    prepare(account: AuthAccount) {\n\n        let vaultRef = account.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault) ?? panic(\"Could not borrow reference to the fusdVault!\")\n        \n        let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n\n        let vault \u003c- vaultRef.withdraw(amount: amount) as! @FUSD.Vault\n        let bids = account.borrow\u003c\u0026FIND.BidCollection\u003e(from: FIND.BidStoragePath)!\n        bids.increaseBid(name: name, vault: \u003c- vault)\n\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "name": "String"
                  }
               }
            },
            "listNFTForAuctionEscrowed": {
               "code": "import FindMarket from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionEscrow from 0xf8d6e0586b0a20c7\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FindViews from 0xf8d6e0586b0a20c7\nimport NFTRegistry from 0xf8d6e0586b0a20c7\nimport FTRegistry from 0xf8d6e0586b0a20c7\n\ntransaction(marketplace:Address, nftAliasOrIdentifier:String, id: UInt64, ftAliasOrIdentifier:String, price:UFix64, auctionReservePrice: UFix64, auctionDuration: UFix64, auctionExtensionOnLateBid: UFix64, minimumBidIncrement: UFix64, auctionValidUntil: UFix64?) {\n    prepare(account: AuthAccount) {\n        // get saleItemsRef from tenant\n        let tenant=FindMarket.getTenant(marketplace)\n\n        let path=FindMarket.getStoragePath(Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(), name: tenant.name)\n\n        let saleItems= account.borrow\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection\u003e(from: path)!\n\n        // Get supported NFT and FT Information from Registries from input alias\n        let nft = NFTRegistry.getNFTInfo(nftAliasOrIdentifier) ?? panic(\"This NFT is not supported by the Find Market yet\")\n        let ft = FTRegistry.getFTInfo(ftAliasOrIdentifier) ?? panic(\"This FT is not supported by the Find Market yet\")\n\n        let providerCap=account.getCapability\u003c\u0026{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e(nft.providerPath)\n        \n        /* Ben : Question -\u003e Either client will have to provide the path here or agree that we set it up for the user */\n        if !providerCap.check() {\n                account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                    nft.providerPath,\n                    target: nft.storagePath\n            )\n        }\n\n        let pointer= FindViews.AuthNFTPointer(cap: providerCap, id: id)\n        // Ben : panic on some unreasonable inputs in trxn \n        assert(minimumBidIncrement \u003e 0.0, message:\"Minimum bid increment should be larger than 0.\")\n        assert((auctionReservePrice - auctionReservePrice) % minimumBidIncrement == 0.0, message:\"Acution ReservePrice should be in step of minimum bid increment.\" )\n        assert(auctionDuration \u003e 0.0, message: \"Auction Duration should be greater than 0.\")\n        assert(auctionExtensionOnLateBid \u003e 0.0, message: \"Auction Duration should be greater than 0.\")\n        \n        saleItems.listForAuction(pointer: pointer, vaultType: ft.type, auctionStartPrice: price, auctionReservePrice: auctionReservePrice, auctionDuration: auctionDuration, auctionExtensionOnLateBid: auctionExtensionOnLateBid, minimumBidIncrement: minimumBidIncrement, auctionValidUntil:auctionValidUntil, saleItemExtraField: {})\n\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "nftAliasOrIdentifier",
                     "id",
                     "ftAliasOrIdentifier",
                     "price",
                     "auctionReservePrice",
                     "auctionDuration",
                     "auctionExtensionOnLateBid",
                     "minimumBidIncrement",
                     "auctionValidUntil"
                  ],
                  "parameters": {
                     "auctionDuration": "UFix64",
                     "auctionExtensionOnLateBid": "UFix64",
                     "auctionReservePrice": "UFix64",
                     "auctionValidUntil": "UFix64?",
                     "ftAliasOrIdentifier": "String",
                     "id": "UInt64",
                     "marketplace": "Address",
                     "minimumBidIncrement": "UFix64",
                     "nftAliasOrIdentifier": "String",
                     "price": "UFix64"
                  }
               }
            },
            "listNFTForAuctionSoft": {
               "code": "import FindMarket from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionSoft from 0xf8d6e0586b0a20c7\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FindViews from 0xf8d6e0586b0a20c7\nimport FTRegistry from 0xf8d6e0586b0a20c7\nimport NFTRegistry from 0xf8d6e0586b0a20c7\n\ntransaction(marketplace:Address, nftAliasOrIdentifier:String, id: UInt64, ftAliasOrIdentifier:String, price:UFix64, auctionReservePrice: UFix64, auctionDuration: UFix64, auctionExtensionOnLateBid: UFix64, minimumBidIncrement: UFix64, auctionValidUntil: UFix64?) {\n    prepare(account: AuthAccount) {\n\n        let tenant=FindMarket.getTenant(marketplace)\n        let saleItems= account.borrow\u003c\u0026FindMarketAuctionSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e())!)!\n\n        // Get supported NFT and FT Information from Registries from input alias\n        let nft = NFTRegistry.getNFTInfo(nftAliasOrIdentifier) ?? panic(\"This NFT is not supported by the Find Market yet\")\n        let ft = FTRegistry.getFTInfo(ftAliasOrIdentifier) ?? panic(\"This FT is not supported by the Find Market yet\")\n\n        let providerCap = account.getCapability\u003c\u0026{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e(nft.providerPath)\n\n        /* Ben : Question -\u003e Either client will have to provide the path here or agree that we set it up for the user */\n        if !providerCap.check() {\n                account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                    nft.providerPath,\n                    target: nft.storagePath\n            )\n        }\n        \n        let pointer= FindViews.AuthNFTPointer(cap: providerCap, id: id)\n        // Ben : panic on some unreasonable inputs in trxn \n        assert(minimumBidIncrement \u003e 0.0, message:\"Minimum bid increment should be larger than 0.\")\n        assert((auctionReservePrice - auctionReservePrice) % minimumBidIncrement == 0.0, message:\"Acution ReservePrice should be in step of minimum bid increment.\" )\n        assert(auctionDuration \u003e 0.0, message: \"Auction Duration should be greater than 0.\")\n        assert(auctionExtensionOnLateBid \u003e 0.0, message: \"Auction Duration should be greater than 0.\")\n        \n        saleItems.listForAuction(pointer: pointer, vaultType: ft.type, auctionStartPrice: price, auctionReservePrice: auctionReservePrice, auctionDuration: auctionDuration, auctionExtensionOnLateBid: auctionExtensionOnLateBid, minimumBidIncrement: minimumBidIncrement, auctionValidUntil: auctionValidUntil, saleItemExtraField: {})\n\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "nftAliasOrIdentifier",
                     "id",
                     "ftAliasOrIdentifier",
                     "price",
                     "auctionReservePrice",
                     "auctionDuration",
                     "auctionExtensionOnLateBid",
                     "minimumBidIncrement",
                     "auctionValidUntil"
                  ],
                  "parameters": {
                     "auctionDuration": "UFix64",
                     "auctionExtensionOnLateBid": "UFix64",
                     "auctionReservePrice": "UFix64",
                     "auctionValidUntil": "UFix64?",
                     "ftAliasOrIdentifier": "String",
                     "id": "UInt64",
                     "marketplace": "Address",
                     "minimumBidIncrement": "UFix64",
                     "nftAliasOrIdentifier": "String",
                     "price": "UFix64"
                  }
               }
            },
            "listNFTForSale": {
               "code": "import FindMarket from 0xf8d6e0586b0a20c7\nimport FindMarketSale from 0xf8d6e0586b0a20c7\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FindViews from 0xf8d6e0586b0a20c7\nimport NFTRegistry from 0xf8d6e0586b0a20c7\nimport FTRegistry from 0xf8d6e0586b0a20c7\n\ntransaction(marketplace:Address, nftAliasOrIdentifier: String, id: UInt64, ftAliasOrIdentifier: String, directSellPrice:UFix64, validUntil: UFix64?) {\n    prepare(account: AuthAccount) {\n        // Get the salesItemRef from tenant\n        let tenant=FindMarket.getTenant(marketplace)\n        let saleItems= account.borrow\u003c\u0026FindMarketSale.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketSale.SaleItemCollection\u003e()))!\n\n        // Get supported NFT and FT Information from Registries from input alias\n        let nft = NFTRegistry.getNFTInfo(nftAliasOrIdentifier) ?? panic(\"This NFT is not supported by the Find Market yet\")\n        let ft = FTRegistry.getFTInfo(ftAliasOrIdentifier) ?? panic(\"This FT is not supported by the Find Market yet\")\n\n        let providerCap=account.getCapability\u003c\u0026{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e(nft.providerPath)\n\n        /* Ben : Question -\u003e Either client will have to provide the path here or agree that we set it up for the user */\n        if !providerCap.check() {\n                account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                    nft.providerPath,\n                    target: nft.storagePath\n            )\n        }\n\n        let pointer= FindViews.AuthNFTPointer(cap: providerCap, id: id)\n        saleItems.listForSale(pointer: pointer, vaultType: ft.type, directSellPrice: directSellPrice, validUntil: validUntil, extraField: {})\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "nftAliasOrIdentifier",
                     "id",
                     "ftAliasOrIdentifier",
                     "directSellPrice",
                     "validUntil"
                  ],
                  "parameters": {
                     "directSellPrice": "UFix64",
                     "ftAliasOrIdentifier": "String",
                     "id": "UInt64",
                     "marketplace": "Address",
                     "nftAliasOrIdentifier": "String",
                     "validUntil": "UFix64?"
                  }
               }
            },
            "listNameForAuction": {
               "code": "import FIND from 0xf8d6e0586b0a20c7\n\ntransaction(name: String, auctionStartPrice: UFix64, auctionReservePrice: UFix64, auctionDuration: UFix64, auctionExtensionOnLateBid: UFix64) {\n    prepare(acct: AuthAccount) {\n        let finLeases= acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n        finLeases.listForAuction(name: name, auctionStartPrice: auctionStartPrice, auctionReservePrice: auctionReservePrice, auctionDuration: auctionDuration,  auctionExtensionOnLateBid: auctionExtensionOnLateBid)\n\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "auctionStartPrice",
                     "auctionReservePrice",
                     "auctionDuration",
                     "auctionExtensionOnLateBid"
                  ],
                  "parameters": {
                     "auctionDuration": "UFix64",
                     "auctionExtensionOnLateBid": "UFix64",
                     "auctionReservePrice": "UFix64",
                     "auctionStartPrice": "UFix64",
                     "name": "String"
                  }
               }
            },
            "listNameForSale": {
               "code": "import FIND from 0xf8d6e0586b0a20c7\n\ntransaction(name: String, directSellPrice:UFix64) {\n    prepare(acct: AuthAccount) {\n        let finLeases= acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n        finLeases.listForSale(name: name,  directSellPrice:directSellPrice)\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "directSellPrice"
                  ],
                  "parameters": {
                     "directSellPrice": "UFix64",
                     "name": "String"
                  }
               }
            },
            "moveNameTO": {
               "code": "import Profile from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\n\n\ntransaction(name: String, receiver:String) {\n\n\n    let receiverAddress:Address?\n    let sender : \u0026FIND.LeaseCollection\n\n    prepare(acct: AuthAccount) {\n        self.sender= acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n        self.receiverAddress=FIND.resolve(receiver)\n    } \n\n    pre{\n        self.receiverAddress != nil : \"The input pass in is not a valid name or address. Input : \".concat(receiver)\n    }\n\n    execute {\n        let receiver=getAccount(self.receiverAddress!)\n        let receiverLease = receiver.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        let receiverProfile = receiver.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\n        if !receiverLease.check() || !receiverProfile.check() {\n            panic(\"Not a valid FIND user\")\n        }\n\n        self.sender.move(name:name, profile:receiverProfile, to: receiverLease)\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "receiver"
                  ],
                  "parameters": {
                     "name": "String",
                     "receiver": "String"
                  }
               }
            },
            "register": {
               "code": "import FungibleToken from 0xee82856bf20e2aa6\nimport FUSD from 0xf8d6e0586b0a20c7\nimport FiatToken from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport Profile from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\nimport FindMarketSale from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionSoft from 0xf8d6e0586b0a20c7\nimport FindMarket from 0xf8d6e0586b0a20c7\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport Dandy from 0xf8d6e0586b0a20c7\n\ntransaction(name: String, amount: UFix64) {\n    prepare(acct: AuthAccount) {\n\n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n        //SYNC with register\n        //Add exising FUSD or create a new one and add it\n        let fusdReceiver = acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n        if !fusdReceiver.check() {\n            let fusd \u003c- FUSD.createEmptyVault()\n            acct.save(\u003c- fusd, to: /storage/fusdVault)\n            acct.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n            acct.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n        }\n\n        let usdcCap = acct.getCapability\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e(FiatToken.VaultReceiverPubPath)\n        if !usdcCap.check() {\n                acct.save( \u003c-FiatToken.createEmptyVault(), to: FiatToken.VaultStoragePath)\n        acct.link\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e( FiatToken.VaultReceiverPubPath, target: FiatToken.VaultStoragePath)\n        acct.link\u003c\u0026FiatToken.Vault{FiatToken.ResourceId}\u003e( FiatToken.VaultUUIDPubPath, target: FiatToken.VaultStoragePath)\n                acct.link\u003c\u0026FiatToken.Vault{FungibleToken.Balance}\u003e( FiatToken.VaultBalancePubPath, target:FiatToken.VaultStoragePath)\n        }\n\n        let leaseCollection = acct.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            acct.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            acct.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = acct.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            acct.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            acct.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let dandyCap= acct.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            acct.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            acct.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            acct.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n      let dandyCapPub= acct.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCapPub.check() {\n            acct.unlink(Dandy.CollectionPublicPath)\n            acct.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        let dandyCapPrivate= acct.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPrivatePath)\n        if !dandyCapPub.check() {\n            acct.unlink(Dandy.CollectionPrivatePath)\n            acct.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        var created=false\n        let profileCap = acct.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            acct.save(\u003c-profile, to: Profile.storagePath)\n            acct.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            acct.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=acct.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n        if !profile.hasWallet(\"Flow\") {\n            let flowWallet=Profile.Wallet( name:\"Flow\", receiver:acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:acct.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), names: [\"flow\"])\n    \n            profile.addWallet(flowWallet)\n        }\n        if !profile.hasWallet(\"FUSD\") {\n            profile.addWallet(Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:acct.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), names: [\"fusd\", \"stablecoin\"]))\n        }\n\n        if !profile.hasWallet(\"USDC\") {\n            profile.addWallet(Profile.Wallet( name:\"USDC\", receiver:usdcCap, balance:acct.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(FiatToken.VaultBalancePubPath), accept: Type\u003c@FiatToken.Vault\u003e(), names: [\"usdc\", \"stablecoin\"]))\n        }\n\n         //If find name not set and we have a profile set it.\n        if profile.getFindName() == \"\" {\n            profile.setFindName(name)\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else {\n            profile.emitUpdatedEvent()\n        }\n\n        let receiverCap=acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let tenantCapability= FindMarket.getTenantCapability(FindMarket.getFindTenantAddress())!\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= acct.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            acct.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            acct.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        let doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        let doeSalePublicPath=FindMarket.getPublicPath(doeSaleType, name: tenant.name)\n        let doeSaleStoragePath= FindMarket.getStoragePath(doeSaleType, name:tenant.name)\n        let doeSaleCap= acct.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n        if !doeSaleCap.check() {\n            acct.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n            acct.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n        }\n\n        let doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        let doeBidPublicPath=FindMarket.getPublicPath(doeBidType, name: tenant.name)\n        let doeBidStoragePath= FindMarket.getStoragePath(doeBidType, name:tenant.name)\n        let doeBidCap= acct.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n        if !doeBidCap.check() {\n            acct.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n            acct.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n        }\n\n        /// auctions that escrow ft\n        let aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        let aeSalePublicPath=FindMarket.getPublicPath(aeSaleType, name: tenant.name)\n        let aeSaleStoragePath= FindMarket.getStoragePath(aeSaleType, name:tenant.name)\n        let aeSaleCap= acct.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n        if !aeSaleCap.check() {\n            acct.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n            acct.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n        }\n\n        let dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\n        let dosSalePublicPath=FindMarket.getPublicPath(dosSaleType, name: tenant.name)\n        let dosSaleStoragePath= FindMarket.getStoragePath(dosSaleType, name:tenant.name)\n\n        let dosSaleCap= acct.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n        if !dosSaleCap.check() {\n            acct.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n            acct.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n        }\n\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= acct.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n        if !dosBidCap.check() {\n            acct.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            acct.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n        }\n\n        let aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\n        let aeBidPublicPath=FindMarket.getPublicPath(aeBidType, name: tenant.name)\n        let aeBidStoragePath= FindMarket.getStoragePath(aeBidType, name:tenant.name)\n        let aeBidCap= acct.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n        if !aeBidCap.check() {\n            acct.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n            acct.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n        }\n\n     /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= acct.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            acct.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            acct.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n        }\n\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= acct.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n        if !asBidCap.check() {\n            acct.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            acct.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n        }\n        //SYNC with register\n\n\n\n        let price=FIND.calculateCost(name)\n        if price != amount {\n            panic(\"Calculated cost does not match expected cost\")\n        }\n        log(\"The cost for registering this name is \".concat(price.toString()))\n\n        let vaultRef = acct.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault) ?? panic(\"Could not borrow reference to the fusdVault!\")\n\n        let payVault \u003c- vaultRef.withdraw(amount: price) as! @FUSD.Vault\n\n        let leases=acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from: FIND.LeaseStoragePath)!\n        leases.register(name: name, vault: \u003c- payVault)\n\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "name": "String"
                  }
               }
            },
            "registerGift": {
               "code": "import FUSD from 0xf8d6e0586b0a20c7\nimport Profile from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\n\ntransaction(name: String, amount: UFix64, recipient: String) {\n    prepare(acct: AuthAccount) {\n\n        let resolveAddress = FIND.resolve(recipient)\n        if resolveAddress == nil {panic(\"The input pass in is not a valid name or address. Input : \".concat(recipient))}\n        let address = resolveAddress!\n        let price=FIND.calculateCost(name)\n        if price != amount {\n            panic(\"Calculated cost does not match expected cost\")\n        }\n        log(\"The cost for registering this name is \".concat(price.toString()))\n\n        let vaultRef = acct.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault) ?? panic(\"Could not borrow reference to the fusdVault!\")\n        let payVault \u003c- vaultRef.withdraw(amount: price) as! @FUSD.Vault\n\n        let leases=acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from: FIND.LeaseStoragePath)!\n        leases.register(name: name, vault: \u003c- payVault)\n\n        let receiver = getAccount(address)\n        let receiverLease = receiver.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        let receiverProfile = receiver.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !receiverLease.check() {\n            panic(\"Receiver is not a find user\")\n        }\n        leases.move(name: name, profile: receiverProfile, to: receiverLease)\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "amount",
                     "recipient"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "name": "String",
                     "recipient": "String"
                  }
               }
            },
            "rejectNameDirectOffer": {
               "code": "import FIND from 0xf8d6e0586b0a20c7\n\ntransaction(names: [String]) {\n    prepare(account: AuthAccount) {\n\n        let finLeases= account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n        for name in names {\n            finLeases.cancel(name)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "names"
                  ],
                  "parameters": {
                     "names": "[String]"
                  }
               }
            },
            "removeCurratedCollection": {
               "code": "transaction(name: String) {\n    prepare(account: AuthAccount) {\n\n        let path=/storage/FindCuratedCollections\n        let publicPath=/public/FindCuratedCollections\n\n        var collections : {String: [String]} = {}\n        if account.borrow\u003c\u0026{String: [String]}\u003e(from:path) != nil {\n             collections=account.load\u003c{String: [String]}\u003e(from:path)!\n        }\n        collections.remove(key: name)\n        account.save(collections, to: path)\n        let link = account.getCapability\u003c\u0026{String: [String]}\u003e(publicPath)\n        if !link.check() {\n            account.link\u003c\u0026{String: [String]}\u003e( publicPath, target: path)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "removeMarketOption": {
               "code": "import FindMarket from 0xf8d6e0586b0a20c7\n\n\n\n\ntransaction(saleItemName: String){\n    prepare(account: AuthAccount){\n        let path = FindMarket.TenantClientStoragePath\n        let tenantRef = account.borrow\u003c\u0026FindMarket.TenantClient\u003e(from: path) ?? panic(\"Cannot borrow Reference.\")\n\n        tenantRef.removeMarketOption(name: saleItemName)\n    }\n}",
               "spec": {
                  "order": [
                     "saleItemName"
                  ],
                  "parameters": {
                     "saleItemName": "String"
                  }
               }
            },
            "removeRelatedAccount": {
               "code": "import RelatedAccounts from 0xf8d6e0586b0a20c7\n\n\ntransaction(name: String){\n    prepare(account: AuthAccount) {\n\n        let cap = account.getCapability\u003c\u0026RelatedAccounts.Accounts{RelatedAccounts.Public}\u003e(RelatedAccounts.publicPath)\n        if !cap.check() {\n            let relatedAccounts \u003c- RelatedAccounts.createEmptyAccounts()\n            account.save(\u003c- relatedAccounts, to: RelatedAccounts.storagePath)\n            account.link\u003c\u0026RelatedAccounts.Accounts{RelatedAccounts.Public}\u003e(RelatedAccounts.publicPath, target: RelatedAccounts.storagePath)\n        }\n\n        let relatedAccounts =account.borrow\u003c\u0026RelatedAccounts.Accounts\u003e(from:RelatedAccounts.storagePath)!\n        relatedAccounts.deleteAccount(name: name)\n    }\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "removeTenantRule": {
               "code": "import FindMarket from 0xf8d6e0586b0a20c7\n\ntransaction(optionName: String, tenantRuleName: String){\n    prepare(account: AuthAccount){\n        let path = FindMarket.TenantClientStoragePath\n        let tenantRef = account.borrow\u003c\u0026FindMarket.TenantClient\u003e(from: path) ?? panic(\"Cannot borrow Reference.\")\n\n        tenantRef.removeTenantRule(optionName: optionName, tenantRuleName: tenantRuleName)\n    }\n}",
               "spec": {
                  "order": [
                     "optionName",
                     "tenantRuleName"
                  ],
                  "parameters": {
                     "optionName": "String",
                     "tenantRuleName": "String"
                  }
               }
            },
            "renewName": {
               "code": "import FUSD from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\n\ntransaction(name: String, amount: UFix64) {\n    prepare(acct: AuthAccount) {\n\n        let price=FIND.calculateCost(name)\n        if amount != price {\n            panic(\"expected renew cost is not the same as calculated renew cost\")\n        }\n        let vaultRef = acct.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault) ?? panic(\"Could not borrow reference to the fusdVault!\")\n        let payVault \u003c- vaultRef.withdraw(amount: price) as! @FUSD.Vault\n\n        let finLeases= acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n        let finToken= finLeases.borrow(name)\n        finToken.extendLease(\u003c- payVault)\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "name": "String"
                  }
               }
            },
            "retractOfferMarketDirectOfferEscrowed": {
               "code": "import FindMarket from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferEscrow from 0xf8d6e0586b0a20c7\n\ntransaction(marketplace:Address, id: UInt64) {\n    let bidsReference: \u0026FindMarketDirectOfferEscrow.MarketBidCollection\n\n    prepare(account: AuthAccount) {\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e())\n        self.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection\u003e(from: storagePath) ?? panic(\"This account does not have a bid collection\")\n    }\n\n    execute {\n        self.bidsReference.cancelBid(id)\n    }\n\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "retractOfferMarketDirectOfferSoft": {
               "code": "import FindMarket from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\n\ntransaction(marketplace:Address, id: UInt64) {\n    let bidsReference: \u0026FindMarketDirectOfferSoft.MarketBidCollection\n\n    prepare(account: AuthAccount) {\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n        self.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"Bid resource does not exist\")\n    }\n\n    execute {\n        self.bidsReference.cancelBid(id)\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "sendCharity": {
               "code": "import NonFungibleToken from 0xf8d6e0586b0a20c7\nimport CharityNFT from 0xf8d6e0586b0a20c7\n\n//mint an art and add it to a users collection\ntransaction(\n    id: UInt64,\n    recipient: Address\n) {\n    let receiverCap: Capability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e\n    let charityCollection: \u0026NonFungibleToken.Collection\n\n    prepare(account: AuthAccount) {\n        self.charityCollection =account.borrow\u003c\u0026NonFungibleToken.Collection\u003e(from: CharityNFT.CollectionStoragePath)!\n        self.receiverCap= getAccount(recipient).getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath)\n    }\n\n    execute {\n        let nft \u003c- self.charityCollection.withdraw(withdrawID: id)\n        self.receiverCap.borrow()!.deposit(token: \u003c- nft)\n    }\n}",
               "spec": {
                  "order": [
                     "id",
                     "recipient"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "recipient": "Address"
                  }
               }
            },
            "sendDandy": {
               "code": "import FIND from 0xf8d6e0586b0a20c7\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport Dandy from 0xf8d6e0586b0a20c7\n\ntransaction(user: String, id: UInt64) {\n    prepare(account: AuthAccount) {\n        let address = FIND.resolve(user) ?? panic(\"Cannot find user with this name / address\")\n        let cap = getAccount(address).getCapability\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        let ref = cap.borrow() ?? panic(\"Cannot borrow reference to receiver Collection.\")\n\n        let senderRef = account.borrow\u003c\u0026Dandy.Collection\u003e(from: Dandy.CollectionStoragePath) ?? panic(\"Cannot borrow reference to sender Collection.\")\n        ref.deposit(token: \u003c- senderRef.withdraw(withdrawID: id))\n    }\n}",
               "spec": {
                  "order": [
                     "user",
                     "id"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "user": "String"
                  }
               }
            },
            "sendFT": {
               "code": "import FungibleToken from 0xee82856bf20e2aa6\nimport Sender from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\nimport FTRegistry from 0xf8d6e0586b0a20c7\n\n\ntransaction(name: String, amount: UFix64, ftAliasOrIdentifier: String, tag: String, message:String) {\n\n    prepare(account: AuthAccount) {\n\n        let ft = FTRegistry.getFTInfo(ftAliasOrIdentifier) ?? panic(\"This FT is not supported by the Find Market yet\")\n        let walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n\n        if account.borrow\u003c\u0026Sender.Token\u003e(from: Sender.storagePath) == nil {\n            account.save(\u003c- Sender.create(), to: Sender.storagePath)\n        }\n\n        let token =account.borrow\u003c\u0026Sender.Token\u003e(from: Sender.storagePath)!\n        let vault \u003c- walletReference.withdraw(amount: amount)\n        FIND.depositWithTagAndMessage(to: name, message: message, tag: tag, vault: \u003c- vault, from: token)\n    }\n\n}",
               "spec": {
                  "order": [
                     "name",
                     "amount",
                     "ftAliasOrIdentifier",
                     "tag",
                     "message"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "ftAliasOrIdentifier": "String",
                     "message": "String",
                     "name": "String",
                     "tag": "String"
                  }
               }
            },
            "setMainName": {
               "code": "import Profile from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\n\n\ntransaction(name: String) {\n    prepare(acct: AuthAccount) {\n\n        let leaseCollectionOwner = acct.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\n        if !leaseCollectionOwner.check() {\n            panic(\"Not a find user\")\n        }\n\n        if leaseCollectionOwner.borrow()!.getLease(name) == nil {\n            panic(\"You do not own this lease so you cannot set it as main name\")\n        }\n\n        let profile =acct.borrow\u003c\u0026Profile.User\u003e(from:Profile.storagePath)!\n        profile.setFindName(name)\n    }\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "setMarketOptionFlowDandy": {
               "code": "import FindMarket from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport Dandy from 0xf8d6e0586b0a20c7\n\ntransaction(){\n    prepare(account: AuthAccount){\n        let path = FindMarket.TenantClientStoragePath\n        let tenantRef = account.borrow\u003c\u0026FindMarket.TenantClient\u003e(from: path) ?? panic(\"Cannot borrow Reference.\")\n\n        tenantRef.setMarketOption(name:\"FlowDandy\", cut: nil, rules:[\n            FindMarket.TenantRule(name:\"Flow\", types:[Type\u003c@FlowToken.Vault\u003e()], ruleType: \"ft\", allow: true),\n            FindMarket.TenantRule(name:\"Dandy\", types:[ Type\u003c@Dandy.NFT\u003e()],\n                        ruleType: \"nft\", allow: true)\n            ]\n        )\n    }\n}",
               "spec": null
            },
            "setPrivateMode": {
               "code": "import Profile from 0xf8d6e0586b0a20c7\n\ntransaction(mode: Bool) {\n    prepare(acct: AuthAccount) {\n        let profile =acct.borrow\u003c\u0026Profile.User\u003e(from:Profile.storagePath)!\n        profile.setPrivateMode(mode)\n        profile.emitUpdatedEvent()\n    }\n}",
               "spec": {
                  "order": [
                     "mode"
                  ],
                  "parameters": {
                     "mode": "Bool"
                  }
               }
            },
            "setProfile": {
               "code": "import Profile from 0xf8d6e0586b0a20c7\n\ntransaction(avatar: String) {\n    prepare(acct: AuthAccount) {\n        let profile =acct.borrow\u003c\u0026Profile.User\u003e(from:Profile.storagePath)!\n        profile.setAvatar(avatar)\n\n        profile.emitUpdatedEvent()\n    }\n}",
               "spec": {
                  "order": [
                     "avatar"
                  ],
                  "parameters": {
                     "avatar": "String"
                  }
               }
            },
            "setRelatedAccount": {
               "code": "import RelatedAccounts from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\n\ntransaction(name: String, target: String) {\n    prepare(account: AuthAccount) {\n\n        let resolveAddress = FIND.resolve(target)\n        if resolveAddress == nil {panic(\"The input pass in is not a valid name or address. Input : \".concat(target))}\n        let address = resolveAddress!\n        let cap = account.getCapability\u003c\u0026RelatedAccounts.Accounts{RelatedAccounts.Public}\u003e(RelatedAccounts.publicPath)\n        if !cap.check() {\n            let relatedAccounts \u003c- RelatedAccounts.createEmptyAccounts()\n            account.save(\u003c- relatedAccounts, to: RelatedAccounts.storagePath)\n            account.link\u003c\u0026RelatedAccounts.Accounts{RelatedAccounts.Public}\u003e(RelatedAccounts.publicPath, target: RelatedAccounts.storagePath)\n        }\n\n        let relatedAccounts =account.borrow\u003c\u0026RelatedAccounts.Accounts\u003e(from:RelatedAccounts.storagePath)!\n        relatedAccounts.setFlowAccount(name: name, address: address)\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "target"
                  ],
                  "parameters": {
                     "name": "String",
                     "target": "String"
                  }
               }
            },
            "setSellDandyRules": {
               "code": "import FindMarket from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport FUSD from 0xf8d6e0586b0a20c7\nimport Dandy from 0xf8d6e0586b0a20c7\n\ntransaction(){\n    prepare(account: AuthAccount){\n        let path = FindMarket.TenantClientStoragePath\n        let tenantRef = account.borrow\u003c\u0026FindMarket.TenantClient\u003e(from: path) ?? panic(\"Cannot borrow Reference.\")\n\n        tenantRef.setMarketOption(name:\"FUSDDandy\", cut: nil, rules:[\n            FindMarket.TenantRule(name:\"FUSD\", types:[Type\u003c@FUSD.Vault\u003e()], ruleType: \"ft\", allow: true),\n            FindMarket.TenantRule(name:\"Dandy\", types:[ Type\u003c@Dandy.NFT\u003e()], ruleType: \"nft\", allow: true)\n            ]\n        )\n\n        tenantRef.setMarketOption(name:\"FlowDandy\", cut: nil, rules:[\n            FindMarket.TenantRule(name:\"Flow\", types:[Type\u003c@FlowToken.Vault\u003e()], ruleType: \"ft\", allow: true),\n            FindMarket.TenantRule(name:\"Dandy\", types:[ Type\u003c@Dandy.NFT\u003e()], ruleType: \"nft\", allow: true)\n            ]\n        )\n\n    }\n}",
               "spec": null
            },
            "setTenantRuleFUSD": {
               "code": "import FindMarket from 0xf8d6e0586b0a20c7\nimport FUSD from 0xf8d6e0586b0a20c7\n\ntransaction(optionName: String){\n    prepare(account: AuthAccount){\n        let path = FindMarket.TenantClientStoragePath\n        let tenantRef = account.borrow\u003c\u0026FindMarket.TenantClient\u003e(from: path) ?? panic(\"Cannot borrow Reference.\")\n\n        tenantRef.setTenantRule(optionName: optionName, tenantRule:\n            FindMarket.TenantRule(name:\"FUSD\", types:[Type\u003c@FUSD.Vault\u003e()], ruleType: \"ft\", allow: true)\n        )\n    }\n}",
               "spec": {
                  "order": [
                     "optionName"
                  ],
                  "parameters": {
                     "optionName": "String"
                  }
               }
            },
            "startNameAuction": {
               "code": "import FIND from 0xf8d6e0586b0a20c7\n\ntransaction(name: String) {\n    prepare(account: AuthAccount) {\n\n        let finLeases= account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n        finLeases.startAuction(name)\n\n    }\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "storeCuratedCollections": {
               "code": "transaction(collections: {String :  [String]}) {\n    prepare(account: AuthAccount) {\n\n        let path=/storage/FindCuratedCollections\n        let publicPath=/public/FindCuratedCollections\n\n        if account.borrow\u003c\u0026{String: [String]}\u003e(from:path) != nil {\n             account.load\u003c{String: [String]}\u003e(from:path)\n        }\n        account.save(collections, to: path)\n\n        let link = account.getCapability\u003c\u0026{String: [String]}\u003e(publicPath)\n        if !link.check() {\n            account.link\u003c\u0026{String: [String]}\u003e( publicPath, target: path)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "collections"
                  ],
                  "parameters": {
                     "collections": "{String: [String]}"
                  }
               }
            },
            "testAlterMarketOption": {
               "code": "import FindMarket from 0xf8d6e0586b0a20c7\n\ntransaction(market: String , action: String ){\n    prepare(account: AuthAccount){\n        let path = FindMarket.TenantClientStoragePath\n        let tenantRef = account.borrow\u003c\u0026FindMarket.TenantClient\u003e(from: path) ?? panic(\"Cannot borrow Reference.\")\n\n\n        switch action {\n            case \"enable\" :\n                tenantRef.enableMarketOption(\"FlowDandy\".concat(market))\n\n            case \"deprecate\" :\n                tenantRef.deprecateMarketOption(\"FlowDandy\".concat(market))\n\n            case \"stop\" :\n                tenantRef.stopMarketOption(\"FlowDandy\".concat(market))\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "market",
                     "action"
                  ],
                  "parameters": {
                     "action": "String",
                     "market": "String"
                  }
               }
            },
            "testBlockItem": {
               "code": "import Admin from 0xf8d6e0586b0a20c7\nimport FindMarket from 0xf8d6e0586b0a20c7\nimport Dandy from 0xf8d6e0586b0a20c7\n\ntransaction(tenant: Address){\n    prepare(account: AuthAccount){\n        let adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n        let rules = [\n            FindMarket.TenantRule(name:\"nft\", types:[Type\u003c@Dandy.NFT\u003e()], ruleType:\"nft\", allow:false) \n        ]\n        let item = FindMarket.TenantSaleItem(name:\"Block Dandy\", cut:nil, rules:rules, status:\"active\")\n        adminRef.addFindBlockItem(tenant: tenant, item: item)\n    }\n}",
               "spec": {
                  "order": [
                     "tenant"
                  ],
                  "parameters": {
                     "tenant": "Address"
                  }
               }
            },
            "testBlockItemByListingType": {
               "code": "import Admin from 0xf8d6e0586b0a20c7\nimport FindMarket from 0xf8d6e0586b0a20c7\nimport Dandy from 0xf8d6e0586b0a20c7\n\ntransaction(tenant: Address){\n    prepare(account: AuthAccount){\n        let adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n        let rules = [\n            FindMarket.TenantRule(name:\"nft\", types:[Type\u003c@Dandy.NFT\u003e()], ruleType:\"nft\", allow:false) ,\n            FindMarket.TenantRule(name:\"listing\", types:FindMarket.getSaleItemTypes(), ruleType:\"listing\", allow:false) \n        ]\n        let item = FindMarket.TenantSaleItem(name:\"Block Dandy\", cut:nil, rules:rules, status:\"active\")\n        adminRef.addFindBlockItem(tenant: tenant, item: item)\n    }\n}",
               "spec": {
                  "order": [
                     "tenant"
                  ],
                  "parameters": {
                     "tenant": "Address"
                  }
               }
            },
            "testClock": {
               "code": "import Admin from 0xf8d6e0586b0a20c7\n\ntransaction(clock: UFix64) {\n    prepare(account: AuthAccount) {\n\n        let adminClient=account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath)!\n        adminClient.advanceClock(clock)\n\n    }\n}",
               "spec": {
                  "order": [
                     "clock"
                  ],
                  "parameters": {
                     "clock": "UFix64"
                  }
               }
            },
            "testDestroyDandies": {
               "code": "import Dandy from 0xf8d6e0586b0a20c7\n\n\ntransaction(ids: [UInt64]) {\n    prepare(account: AuthAccount) {\n\n        let dandyRef= account.borrow\u003c\u0026Dandy.Collection\u003e(from: Dandy.CollectionStoragePath) ?? panic(\"Cannot borrow reference to Dandy Collection\")\n        for id in ids {\n            destroy dandyRef.withdraw(withdrawID: id)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "ids"
                  ],
                  "parameters": {
                     "ids": "[UInt64]"
                  }
               }
            },
            "testDestroyDandyCollection": {
               "code": "import Dandy from 0xf8d6e0586b0a20c7\n\n\ntransaction() {\n    prepare(account: AuthAccount) {\n        destroy account.load\u003c@Dandy.Collection\u003e(from: Dandy.CollectionStoragePath)\n    }\n}",
               "spec": null
            },
            "testDestroyFUSDVault": {
               "code": "import FUSD from 0xf8d6e0586b0a20c7\n\n\ntransaction() {\n    prepare(account: AuthAccount) {\n        destroy account.load\u003c@FUSD.Vault\u003e(from: /storage/fusdVault) ?? panic(\"Cannot load flow token vault\")\n    }\n}",
               "spec": null
            },
            "testListStorefront": {
               "code": "import FungibleToken from 0xee82856bf20e2aa6\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport Dandy from 0xf8d6e0586b0a20c7\nimport NFTStorefront from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\n\n\n\n//this has to be called after we have listed it somewhere else because of cap\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64) {\n    let flowReceiver: Capability\u003c\u0026FlowToken.Vault{FungibleToken.Receiver}\u003e\n    let exampleNFTProvider: Capability\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e\n    let storefront: \u0026NFTStorefront.Storefront\n\n    prepare(acct: AuthAccount) {\n\n             // If the account doesn't already have a Storefront\n        if acct.borrow\u003c\u0026NFTStorefront.Storefront\u003e(from: NFTStorefront.StorefrontStoragePath) == nil {\n\n            // Create a new empty .Storefront\n            let storefront \u003c- NFTStorefront.createStorefront() as @NFTStorefront.Storefront\n            \n            // save it to the account\n            acct.save(\u003c-storefront, to: NFTStorefront.StorefrontStoragePath)\n\n            // create a public capability for the .Storefront\n            acct.link\u003c\u0026NFTStorefront.Storefront{NFTStorefront.StorefrontPublic}\u003e(NFTStorefront.StorefrontPublicPath, target: NFTStorefront.StorefrontStoragePath)\n        }\n\n        // We need a provider capability, but one is not provided by default so we create one if needed.\n        let exampleNFTCollectionProviderPrivatePath = /private/exampleNFTCollectionProviderForNFTStorefront\n\n        self.flowReceiver = acct.getCapability\u003c\u0026FlowToken.Vault{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver)\n        assert(self.flowReceiver.borrow() != nil, message: \"Missing or mis-typed FlowToken receiver\")\n        self.exampleNFTProvider = acct.getCapability\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPrivatePath)\n        assert(self.exampleNFTProvider.borrow() != nil, message: \"Missing or mis-typed ExampleNFT.Collection provider\")\n\n        self.storefront = acct.borrow\u003c\u0026NFTStorefront.Storefront\u003e(from: NFTStorefront.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n    }\n\n    execute {\n        let saleCut = NFTStorefront.SaleCut(\n            receiver: self.flowReceiver,\n            amount: saleItemPrice\n        )\n        self.storefront.createListing(\n            nftProviderCapability: self.exampleNFTProvider,\n            nftType: Type\u003c@Dandy.NFT\u003e(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type\u003c@FlowToken.Vault\u003e(),\n            saleCuts: [saleCut]\n        )\n    }\n}",
               "spec": {
                  "order": [
                     "saleItemID",
                     "saleItemPrice"
                  ],
                  "parameters": {
                     "saleItemID": "UInt64",
                     "saleItemPrice": "UFix64"
                  }
               }
            },
            "testMintDandyTO": {
               "code": "import FIND from 0xf8d6e0586b0a20c7\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport Dandy from 0xf8d6e0586b0a20c7\nimport Profile from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FindViews from 0xf8d6e0586b0a20c7\n\ntransaction(name: String, maxEdition:UInt64, artist:String, nftName:String, nftDescription:String, nftUrl:String, rarity: String, rarityNum:UFix64, to: Address) {\n    prepare(account: AuthAccount) {\n\n        let dancyReceiver =getAccount(to)\n        let dandyCap= dancyReceiver.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            panic(\"need dandy receicer\")\n        }\n\n        let finLeases= account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n\n        let creativeWork=\n        FindViews.CreativeWork(artist: artist, name: nftName, description: nftDescription, type:\"image\")\n\n        let httpFile=MetadataViews.HTTPFile(url:nftUrl)\n        let media=MetadataViews.Media(file: httpFile, mediaType: \"image/thumbnail\")\n\n        let rarity = FindViews.Rarity(rarity: rarityNum, rarityName:rarity, parts: {})\n\n        let receiver=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let minterRoyalty=MetadataViews.Royalties(cutInfos:[MetadataViews.Royalty(receiver: receiver, cut: 0.05, description: \"artist\")])\n\n        let tag=FindViews.Tag({\"NeoMotorCycleTag\":\"Tag1\"})\n        let scalar=FindViews.Scalar({\"Speed\" : 100.0})\n\n        let collection=dandyCap.borrow()!\n        var i:UInt64=1\n\n        while i \u003c= maxEdition {\n            let editioned= MetadataViews.Edition(name: \"nft\", number:i, max:maxEdition)\n            let description=creativeWork.description.concat( \" edition \").concat(i.toString()).concat( \" of \").concat(maxEdition.toString())\n            let schemas: [AnyStruct] = [ MetadataViews.Editions([editioned]), creativeWork, minterRoyalty, rarity, tag, scalar, FindViews.Medias([media])]\n            let token \u003c- finLeases.mintDandy(minter: name, \n              nftName: \"Neo Motorcycle \".concat(i.toString()).concat(\" of \").concat(maxEdition.toString()), \n                description: creativeWork.description,\n                thumbnail: media,\n                schemas: schemas, \n                externalUrlPrefix: \"https://find.xyz/collection/\".concat(name).concat(\"/dandy\"),\n                collectionDescription: \"Neo Collectibles FIND\",\n                collectionExternalURL: \"https://neomotorcycles.co.uk/index.html\",\n                collectionSquareImage: \"https://neomotorcycles.co.uk/assets/img/neo_motorcycle_side.webp\",\n                collectionBannerImage: \"https://neomotorcycles.co.uk/assets/img/neo-logo-web-dark.png?h=5a4d226197291f5f6370e79a1ee656a1\",\n            )\n\n            collection.deposit(token: \u003c- token)\n            i=i+1\n        }\n        i = 1\n\n        while i \u003c= maxEdition {\n            let editioned= MetadataViews.Edition(name: \"nft\", number:i, max:maxEdition)\n            let artCreativeWork=FindViews.CreativeWork(artist: artist, name: \"xtingle \", description: \"xtingle_NFT\", type:\"video/mp4\")\n            let description=artCreativeWork.description.concat( \" edition \").concat(i.toString()).concat( \" of \").concat(maxEdition.toString())\n            let artHttpFile=MetadataViews.HTTPFile(url:\"https://nft.blocto.app/xtingles/xBloctopus.mp4\")\n            let thumbnailFile=MetadataViews.HTTPFile(url:\"https://nft.blocto.app/xtingles/preview-xBloctopus.png\")\n            let artMedia=MetadataViews.Media(file: artHttpFile, mediaType: \"video\")\n            let thumbnailMedia=MetadataViews.Media(file: thumbnailFile, mediaType: \"image/thumbnail\")\n            let artTag=FindViews.Tag({\"xtingle Tag\":\"Tag1\"})\n            let artScalar=FindViews.Scalar({\"video length\" : 27.0})\n\n            let schemas: [AnyStruct] = [ MetadataViews.Editions([editioned]), artCreativeWork, artMedia, minterRoyalty, rarity, artTag, artScalar, FindViews.Medias([artMedia, thumbnailMedia])]\n            let token \u003c- finLeases.mintDandy(minter: name, \n              nftName: \"xtingle \".concat(i.toString()).concat(\" of \").concat(maxEdition.toString()), \n                description: artCreativeWork.description,\n                thumbnail: thumbnailMedia,\n                schemas: schemas, \n                externalUrlPrefix: \"https://nft.blocto.app/xtingles/\",\n                collectionDescription: \"xtingle FIND\",\n                collectionExternalURL: \"https://xtingles.com/\",\n                collectionSquareImage: \"https://xtingles-strapi-prod.s3.us-east-2.amazonaws.com/copy_of_upcoming_drops_db41fbf287.png\",\n                collectionBannerImage: \"https://xtingles.com/images/main-metaverse.png\",\n            )\n\n            collection.deposit(token: \u003c- token)\n            i=i+1\n        }\n        i = 1\n\n        while i \u003c= maxEdition {\n            let editioned= MetadataViews.Edition(name: \"nft\", number:i, max:maxEdition)\n            let artCreativeWork=FindViews.CreativeWork(artist: artist, name: \"flovatar \", description: \"flovatar_NFT\", type:\"image\")\n            let description=artCreativeWork.description.concat( \" edition \").concat(i.toString()).concat( \" of \").concat(maxEdition.toString())\n            let artHttpFile=MetadataViews.HTTPFile(url:\"https://flovatar.com/flovatars/1225/0x92ba5cba77fc1e87\")\n            let artMedia=MetadataViews.Media(file: artHttpFile, mediaType: \"image\")\n            let artTag=FindViews.Tag({\"flovatar Tag\":\"Tag1\"})\n            let artScalar=FindViews.Scalar({\"rarity score\" : 2.2})\n\n            let schemas: [AnyStruct] = [ MetadataViews.Editions([editioned]), artCreativeWork, artMedia, minterRoyalty, rarity, artTag, artScalar, FindViews.Medias([artMedia])]\n            let token \u003c- finLeases.mintDandy(minter: name, \n              nftName: \"flovatar \".concat(i.toString()).concat(\" of \").concat(maxEdition.toString()), \n                description: artCreativeWork.description,\n                thumbnail: artMedia,\n                schemas: schemas, \n                externalUrlPrefix: \"https://flovatar.com/flovatars/\",\n                collectionDescription: \"flovatar FIND\",\n                collectionExternalURL: \"https://flovatar.com/\",\n                collectionSquareImage: \"https://miro.medium.com/max/1080/1*nD3N5BvxvH-wgLW1KPizoA.png\",\n                collectionBannerImage: \"https://miro.medium.com/max/1400/1*WjFBUweGaThcTR-UOZ6TnA.gif\",\n            )\n\n            collection.deposit(token: \u003c- token)\n            i=i+1\n        }\n        i = 1\n\n        while i \u003c= maxEdition {\n            let editioned= MetadataViews.Edition(name: \"nft\", number:i, max:maxEdition)\n            let artCreativeWork=FindViews.CreativeWork(artist: artist, name: \"ufcstrike \", description: \"ufcstrike_NFT\", type:\"video/ipfs\")\n            let description=artCreativeWork.description.concat( \" edition \").concat(i.toString()).concat( \" of \").concat(maxEdition.toString())\n            let artHttpFile=MetadataViews.IPFSFile(cid:\"QmdDJUobzSaFfg8PwZZcCB3cPwbZ8pthRf1x6XiR9xwS3U\", path:nil)\n            let thumbnailHttpFile=MetadataViews.IPFSFile(cid:\"QmeDLGnYNyunkTjd23yx36sHviWyR9L2shHshjwe1qBCqR\", path:nil)\n            let artMedia=MetadataViews.Media(file: artHttpFile, mediaType: \"image/ipfs\")\n            let thumbnailMedia=MetadataViews.Media(file: thumbnailHttpFile, mediaType: \"image/thumbnail\")\n\n            let artTag=FindViews.Tag({\"ufcstrike Tag\":\"Tag1\"})\n            let artScalar=FindViews.Scalar({\"rank\" : 295.0})\n\n            let schemas: [AnyStruct] = [ MetadataViews.Editions([editioned]), artCreativeWork, artMedia, minterRoyalty, rarity, artTag, artScalar, FindViews.Medias([artMedia, thumbnailMedia])]\n            let token \u003c- finLeases.mintDandy(minter: name, \n              nftName: \"ufcstrike \".concat(i.toString()).concat(\" of \").concat(maxEdition.toString()), \n                description: artCreativeWork.description,\n                thumbnail: thumbnailMedia,\n                schemas: schemas, \n                externalUrlPrefix: \"https://giglabs.mypinata.cloud/ipfs/\",\n                collectionDescription: \"ufc strike FIND\",\n                collectionExternalURL: \"https://ufcstrike.com/\",\n                collectionSquareImage: \"https://assets.website-files.com/62605ca984796169418ca5dc/628e9bba372af61fcf967e03_round-one-standard-p-1080.png\",\n                collectionBannerImage: \"https://s3.us-east-2.amazonaws.com/giglabs.assets.ufc/4f166ac23e10bb510319e82fe9ed2c7d\",\n            )\n\n            collection.deposit(token: \u003c- token)\n            i=i+1\n        }\n\n    \n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "maxEdition",
                     "artist",
                     "nftName",
                     "nftDescription",
                     "nftUrl",
                     "rarity",
                     "rarityNum",
                     "to"
                  ],
                  "parameters": {
                     "artist": "String",
                     "maxEdition": "UInt64",
                     "name": "String",
                     "nftDescription": "String",
                     "nftName": "String",
                     "nftUrl": "String",
                     "rarity": "String",
                     "rarityNum": "UFix64",
                     "to": "Address"
                  }
               }
            },
            "testMintFlow": {
               "code": "import FungibleToken from 0xee82856bf20e2aa6\nimport FlowToken from 0x0ae53cb6e3f42a79\n\ntransaction(recipient: Address, amount: UFix64) {\n    let tokenAdmin: \u0026FlowToken.Administrator\n    let tokenReceiver: \u0026{FungibleToken.Receiver}\n\n    prepare(signer: AuthAccount) {\n\n        self.tokenAdmin = signer\n            .borrow\u003c\u0026FlowToken.Administrator\u003e(from: /storage/flowTokenAdmin)\n            ?? panic(\"Signer is not the token admin\")\n\n        self.tokenReceiver = getAccount(recipient)\n            .getCapability(/public/flowTokenReceiver)\n            .borrow\u003c\u0026{FungibleToken.Receiver}\u003e()\n            ?? panic(\"Unable to borrow receiver reference\")\n    }\n\n    execute {\n        let minter \u003c- self.tokenAdmin.createNewMinter(allowedAmount: amount)\n        let mintedVault \u003c- minter.mintTokens(amount: amount)\n\n        self.tokenReceiver.deposit(from: \u003c-mintedVault)\n\n        destroy minter\n    }\n}",
               "spec": {
                  "order": [
                     "recipient",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "recipient": "Address"
                  }
               }
            },
            "testMintFusd": {
               "code": "import FungibleToken from 0xee82856bf20e2aa6\nimport FUSD from 0xf8d6e0586b0a20c7\n\ntransaction(recipient: Address, amount: UFix64) {\n    let tokenAdmin: \u0026FUSD.Administrator\n    let tokenReceiver: \u0026{FungibleToken.Receiver}\n\n    prepare(signer: AuthAccount) {\n\n        self.tokenAdmin = signer\n        .borrow\u003c\u0026FUSD.Administrator\u003e(from: /storage/fusdAdmin)\n        ?? panic(\"Signer is not the token admin\")\n\n        self.tokenReceiver = getAccount(recipient)\n        .getCapability(/public/fusdReceiver)\n        .borrow\u003c\u0026{FungibleToken.Receiver}\u003e()\n        ?? panic(\"Unable to borrow receiver reference\")\n    }\n\n    execute {\n\n\n\n        let minter \u003c- self.tokenAdmin.createNewMinter()\n        let mintedVault \u003c- minter.mintTokens(amount: amount)\n\n        self.tokenReceiver.deposit(from: \u003c-mintedVault)\n\n        destroy minter\n    }\n}",
               "spec": {
                  "order": [
                     "recipient",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "recipient": "Address"
                  }
               }
            },
            "testMintUsdc": {
               "code": "import FungibleToken from 0xee82856bf20e2aa6\nimport FiatToken from 0xf8d6e0586b0a20c7\n\ntransaction(recipient: Address, amount: UFix64) {\n    let tokenAdmin: \u0026FiatToken.Administrator\n    let tokenReceiver: \u0026{FungibleToken.Receiver}\n\n    prepare(signer: AuthAccount) {\n\n        self.tokenAdmin = signer.borrow\u003c\u0026FiatToken.Administrator\u003e(from: FiatToken.AdminStoragePath)\n        ?? panic(\"Signer is not the token admin\")\n\n        self.tokenReceiver = getAccount(recipient)\n        .getCapability(FiatToken.VaultReceiverPubPath)\n        .borrow\u003c\u0026{FungibleToken.Receiver}\u003e()\n        ?? panic(\"Unable to borrow receiver reference\")\n    }\n\n    execute {\n        let minter \u003c- self.tokenAdmin.createNewMinter()\n        let mintedVault \u003c- minter.mintTokens(amount: amount)\n\n        self.tokenReceiver.deposit(from: \u003c-mintedVault)\n\n        destroy minter\n    }\n}",
               "spec": {
                  "order": [
                     "recipient",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "recipient": "Address"
                  }
               }
            },
            "testSetResidualAddress": {
               "code": "import Admin from 0xf8d6e0586b0a20c7\n\ntransaction(address: Address) {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n        \n    }\n\n    execute{\n        self.adminRef.setResidualAddress(address)\n    }\n}",
               "spec": {
                  "order": [
                     "address"
                  ],
                  "parameters": {
                     "address": "Address"
                  }
               }
            },
            "testSetSellNeoTestnetRules": {
               "code": "import FindMarket from 0xf8d6e0586b0a20c7\nimport Admin from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport NeoVoucher from 0xd6b39e5b5b367aad\n\n\ntransaction(tenant: Address){\n    prepare(account: AuthAccount){\n        let adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n\n        let saleItem = FindMarket.TenantSaleItem(name:\"FlowNeo\", cut: nil, rules:[\n            FindMarket.TenantRule(name:\"Flow\", types:[Type\u003c@FlowToken.Vault\u003e()], ruleType: \"ft\", allow: true),\n            FindMarket.TenantRule(name:\"Neo\", types:[ Type\u003c@NeoVoucher.NFT\u003e()], ruleType: \"nft\", allow: true)\n            ], \n            status: \"active\"\n        )\n\n        adminRef.setMarketOption(tenant: tenant, saleItem: saleItem)\n    }\n}",
               "spec": {
                  "order": [
                     "tenant"
                  ],
                  "parameters": {
                     "tenant": "Address"
                  }
               }
            }
         }
      },
      "mainnet": {
         "scripts": {
            "getCheckRoyalty": {
               "code": "import MetadataViews from 0x1d7e57aa55817448\nimport FIND from 0x097bafa4e0b48eef\nimport NFTRegistry from 0x097bafa4e0b48eef\n\npub fun main(name: String, id: UInt64, nftAliasOrIdentifier: String, viewIdentifier: String) : AnyStruct? {\n\n    let address =FIND.lookupAddress(name)!\n\n    // Get collection public path from NFT Registry\n    let nftInfo = NFTRegistry.getNFTInfo(nftAliasOrIdentifier) ?? panic(\"This NFT is not supported by the Find Market yet\")\n    let collectionPublicPath = nftInfo.publicPath\n    let collection= getAccount(address).getCapability(collectionPublicPath).borrow\u003c\u0026{MetadataViews.ResolverCollection}\u003e()!\n\n    let nft=collection.borrowViewResolver(id: id)\n    for v in nft.getViews() {\n        if v.identifier== viewIdentifier {\n            return nft.resolveView(v)\n        }\n    }\n    return nil\n}",
               "spec": {
                  "order": [
                     "name",
                     "id",
                     "nftAliasOrIdentifier",
                     "viewIdentifier"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "name": "String",
                     "nftAliasOrIdentifier": "String",
                     "viewIdentifier": "String"
                  }
               }
            },
            "getCollectionIndex": {
               "code": "import MetadataViews from 0x1d7e57aa55817448\nimport NFTRegistry from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\n\npub fun main(user: String) : {String : [UInt64]} {\n    if let address = FIND.resolve(user) {\n        var resultMap : {String : [UInt64]} = {}\n        let account = getAccount(address)\n        for nftInfo in NFTRegistry.getNFTInfoAll().values {\n            let publicPath = nftInfo.publicPath\n            let alias = nftInfo.alias\n            let resolverCollectionCap= account.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(publicPath)\n            if resolverCollectionCap.check() {\n                let collection = resolverCollectionCap.borrow()!\n                resultMap[alias] = collection.getIDs()\n            }\n        }\n\n        return resultMap\n    }\n    return {}\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "getCollections": {
               "code": "import MetadataViews from 0x1d7e57aa55817448\nimport NFTRegistry from 0x097bafa4e0b48eef\nimport FindViews from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\n\npub struct MetadataCollections {\n\n    pub let items: {String : MetadataCollectionItem}\n    pub let collections: {String : [String]}\n    // supports new contracts that supports metadataViews \n    pub let curatedCollections: {String : [String]}\n\n    init(items: {String : MetadataCollectionItem}, collections: {String : [String]}, curatedCollections: {String: [String]}) {\n        self.items=items\n        self.collections=collections\n        self.curatedCollections=curatedCollections\n    }\n}\n\n\npub struct MetadataCollection{\n    pub let type: String\n    pub let items: [MetadataCollectionItem]\n\n    init(type:String, items: [MetadataCollectionItem]) {\n        self.type=type\n        self.items=items\n    }\n}\n\n// Collection Index.cdc Address : [{Path, ID}]\n/* \n    pub struct CollectionItemPointer {\n        pub let path \n        pub let id \n    }\n */\n// Need : A metadata collection index : -\u003e path, id, collection (Where do you want to group them)\n// A list of these for all the items (Like collections and cur)\n\n// Resolve Partial Collection.cdc Address, {path : [IDs]}\n// Address\n// [path1 , path1, path2]\n// [id1 , id2, id3]\n// Another list -\u003e take these path, id, collection and return the specific collection information (similar in collections)\n\npub struct MetadataCollectionItem {\n    pub let id:UInt64\n    pub let typeIdentifier: String\n    pub let uuid: UInt64 \n    pub let name: String\n    pub let image: String\n    pub let url: String\n    pub let contentType:String\n    pub let rarity:String\n    //Refine later \n    pub let metadata: {String : String}\n    pub let collection: String // \u003c- This will be Alias unless they want something else\n    pub let tag: {String : String}\n    pub let scalar: {String : UFix64}\n\n    init(id:UInt64, type: Type, uuid: UInt64, name:String, image:String, url:String, contentType: String, rarity: String, collection: String, tag: {String : String}, scalar: {String : UFix64}) {\n        self.id=id\n        self.typeIdentifier = type.identifier\n        self.uuid = uuid\n        self.name=name\n        self.url=url\n        self.image=image\n        self.contentType=contentType\n        self.rarity=rarity\n        self.metadata={}\n        self.collection=collection\n        self.tag=tag\n        self.scalar=scalar\n    }\n}\n\npub fun main(user: String) : MetadataCollections? {\n\n    let resolvingAddress = FIND.resolve(user)\n    if resolvingAddress == nil {\n        return nil\n    }\n    let address = resolvingAddress!\n    var resultMap : {String : MetadataCollectionItem} = {}\n    let account = getAccount(address)\n    let results : {String :  [String]}={}\n\n    for nftInfo in NFTRegistry.getNFTInfoAll().values {\n        let items: [String] = []\n        let resolverCollectionCap= account.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(nftInfo.publicPath)\n        if resolverCollectionCap.check() {\n            let collection = resolverCollectionCap.borrow()!\n            for id in collection.getIDs() {\n                let nft = collection.borrowViewResolver(id: id) \n                \n                if let display= FindViews.getDisplay(nft) {\n                    var externalUrl=nftInfo.externalFixedUrl\n\n                    if let externalUrlViw=FindViews.getExternalURL(nft) { \n                        externalUrl=externalUrlViw.url\n                    }\n\n                    var rarity=\"\"\n                    if let r = FindViews.getRarity(nft) {\n                        rarity=r.rarityName\n                    }\n\n                    var tag : {String : String}={}\n                    if let t= FindViews.getTags(nft) {\n                        tag=t.getTag()\n                    }            \n\n                    var scalar : {String : UFix64}={}\n                    if let s= FindViews.getScalar(nft) {\n                        scalar=s.getScalar()\n                    }                \n\n                    let item = MetadataCollectionItem(\n                        id: id,\n                        type: nft.getType() ,\n                        uuid: nft.uuid ,\n                        name: display.name,\n                        image: display.thumbnail.uri(),\n                        url: externalUrl,\n                        contentType: \"image\",\n                        rarity: rarity,\n                        collection: nftInfo.alias,\n                        tag: tag,\n                        scalar: scalar\n                    )\n                    let itemId = nftInfo.alias.concat(item.id.toString())\n                    items.append(itemId)\n                    resultMap.insert(key:itemId, item)\n                }\n            }\n            results[nftInfo.alias] = items\n        }\n    }\n\n    let publicPath=/public/FindCuratedCollections\n    let link = account.getCapability\u003c\u0026{String: [String]}\u003e(publicPath)\n    var curatedCollections : {String: [String]} = {}\n    if link.check() {\n        let curated = link.borrow()!\n        for curatedKey in curated.keys {\n            curatedCollections[curatedKey] = curated[curatedKey]!\n        }\n    }\n\n    return MetadataCollections(items: resultMap, collections:results, curatedCollections: curatedCollections)\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "getCuratedCollections": {
               "code": "pub fun main(address: Address) : \u0026{String: [String]}? {\n    let account=getAccount(address)\n    let publicPath=/public/FindCuratedCollections\n    let link = account.getCapability\u003c\u0026{String: [String]}\u003e(publicPath)\n    if link.check() {\n        return link.borrow()\n    }\n    return nil\n}",
               "spec": {
                  "order": [
                     "address"
                  ],
                  "parameters": {
                     "address": "Address"
                  }
               }
            },
            "getDandiesIDsFor": {
               "code": "import Dandy from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\n\npub fun main(user: String, minter: String) : [UInt64] {\n    let address = FIND.resolve(user)\n    if address == nil {\n        return []\n    }\n    let account = getAccount(address!)\n    let cap = account.getCapability\u003c\u0026Dandy.Collection{Dandy.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n    let ref = cap.borrow() ?? panic(\"Cannot borrow reference to Dandy Collection\")\n\n    return ref.getIDsFor(minter: minter)\n}",
               "spec": {
                  "order": [
                     "user",
                     "minter"
                  ],
                  "parameters": {
                     "minter": "String",
                     "user": "String"
                  }
               }
            },
            "getDandiesMinters": {
               "code": "import Dandy from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\n\npub fun main(user: String) : [String] {\n    let address = FIND.resolve(user)\n    if address == nil {\n        return []\n    }\n    let account = getAccount(address!)\n    let cap = account.getCapability\u003c\u0026Dandy.Collection{Dandy.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n    let ref = cap.borrow() ?? panic(\"Cannot borrow reference to Dandy Collection\")\n\n    return ref.getMinters()\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "getFTInfo": {
               "code": "import FTRegistry from 0x097bafa4e0b48eef\n\npub fun main(aliasOrIdentifier: String) : FTRegistry.FTInfo?{\n\n    return FTRegistry.getFTInfo(aliasOrIdentifier)\n\n}",
               "spec": {
                  "order": [
                     "aliasOrIdentifier"
                  ],
                  "parameters": {
                     "aliasOrIdentifier": "String"
                  }
               }
            },
            "getFTInfoAll": {
               "code": "import FTRegistry from 0x097bafa4e0b48eef\n\npub fun main() : {String: FTRegistry.FTInfo}{\n\n    return FTRegistry.getFTInfoAll()\n\n}",
               "spec": null
            },
            "getItem": {
               "code": "import MetadataViews from 0x1d7e57aa55817448\nimport FIND from 0x097bafa4e0b48eef\nimport NFTRegistry from 0x097bafa4e0b48eef\n\npub struct MetadataCollectionItem {\n    pub let id:UInt64\n    pub let uuid:UInt64\n    pub let name: String\n    pub let description: String?\n    pub let image: String\n    pub let url: String\n    pub let contentType:String\n    pub let rarity:String\n    pub let minter:String?\n    pub let type:Type\n\n\n    init(id:UInt64, uuid:UInt64, name:String, description:String?, image:String, url:String, contentType: String, rarity: String, minter:String?, type:Type) {\n        self.id=id\n        self.uuid=uuid\n        self.name=name\n        self.description=description\n        self.minter=minter\n        self.url=url\n        self.type=type\n        self.image=image\n        self.contentType=contentType\n        self.rarity=rarity\n    }\n}\n\n\npub fun main(user: String, aliasOrIdentifier: String, id:UInt64) : MetadataCollectionItem?{\n\n    let nftInfo = NFTRegistry.getNFTInfo(aliasOrIdentifier) \n    if nftInfo == nil {panic(\"This NFT is not registered in registry. input: \".concat(aliasOrIdentifier))}\n\n    let resolveAddress = FIND.resolve(user) \n    if resolveAddress == nil {return nil}\n    let address = resolveAddress!\n    let account=getAccount(address)\n    let resolverCollectionCap= account.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(nftInfo!.publicPath)\n    if !resolverCollectionCap.check() {\n        return nil\n    }\n\n    let collection = resolverCollectionCap.borrow()!\n    let nft = collection.borrowViewResolver(id: id)!\n\n    if let displayView = nft.resolveView(Type\u003cMetadataViews.Display\u003e()) {\n        let display = displayView as! MetadataViews.Display\n\n        var externalUrl=\"\"\n        if let externalUrlView = nft.resolveView(Type\u003cMetadataViews.ExternalURL\u003e()) {\n            let edvu= externalUrlView as! MetadataViews.ExternalURL\n            externalUrl=edvu.url\n        }\n        let item = MetadataCollectionItem(\n            id: id,\n            uuid: nft.uuid,\n            name: display.name,\n            description:display.description,\n            image: display.thumbnail.uri(),\n            url: externalUrl,\n            contentType: \"image\",\n            rarity: \"\",\n            minter: \"\",\n            type: nft.getType()\n        )\n        return item\n    }\n    return nil\n}",
               "spec": {
                  "order": [
                     "user",
                     "aliasOrIdentifier",
                     "id"
                  ],
                  "parameters": {
                     "aliasOrIdentifier": "String",
                     "id": "UInt64",
                     "user": "String"
                  }
               }
            },
            "getListings": {
               "code": "import FindMarket from 0x097bafa4e0b48eef \nimport FIND from 0x097bafa4e0b48eef \n\npub fun main(marketplace:Address, user: String) : {String : FindMarket.SaleItemCollectionReport} {\n    let resolveAddress = FIND.resolve(user)\n    if resolveAddress == nil { return {}}\n    let address = resolveAddress!\n        return FindMarket.getSaleItemReport(tenant:marketplace, address: address, getNFTInfo:false)\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "user"
                  ],
                  "parameters": {
                     "marketplace": "Address",
                     "user": "String"
                  }
               }
            },
            "getMarketBlockedNFT": {
               "code": "import FindMarket from 0x097bafa4e0b48eef \n\npub fun main() : {String : [String] } {\n    let mapping : {String : [String] } = {}\n\n    let findAddress=FindMarket.getFindTenantAddress()\n    let tenantCap = FindMarket.getTenantCapability(findAddress)!\n    let tenantRef = tenantCap.borrow() ?? panic(\"This tenant is not set up.\")\n    let marketTypes = FindMarket.getSaleItemTypes()\n    for marketType in marketTypes {\n        let list : [String] = []\n        for type in tenantRef.getBlockedNFT(marketType: marketType) {\n            list.append(type.identifier)\n        }\n        mapping[FindMarket.getMarketOptionFromType(marketType)] = list\n    }\n\nreturn mapping\n}",
               "spec": null
            },
            "getNFTDetails": {
               "code": "import FindMarket from 0x097bafa4e0b48eef \nimport FindViews from 0x097bafa4e0b48eef \nimport FIND from 0x097bafa4e0b48eef \nimport MetadataViews from 0x1d7e57aa55817448\nimport NFTStorefront from 0x4eb8a10cb9f87357\nimport NFTRegistry from 0x097bafa4e0b48eef\nimport FTRegistry from 0x097bafa4e0b48eef\n\npub struct NFTDetailReport {\n    pub let findMarket: {String : FindMarket.SaleItemInformation}\n    pub let storefront: StorefrontListing?\n    pub let nftDetail: NFTDetail?\n    pub let allowedListingActions: {String : ListingTypeReport}\n\n    init(findMarket:{String : FindMarket.SaleItemInformation}, storefront: StorefrontListing?, nftDetail: NFTDetail?, allowedListingActions: {String : ListingTypeReport}) {\n        self.findMarket=findMarket\n        self.storefront=storefront\n        self.nftDetail=nftDetail\n        self.allowedListingActions=allowedListingActions\n    }\n}\n\npub struct ListingTypeReport {\n    pub let listingType: String \n    pub let ftAlias: [String] \n    pub let ftIdentifiers: [String] \n    pub let status: String \n\n    init(listingType: String, ftAlias: [String], ftIdentifiers: [String],  status: String ) {\n        self.listingType=listingType \n        self.ftAlias=ftAlias \n        self.ftIdentifiers=ftIdentifiers \n        self.status=status\n    }\n}\n\npub struct NFTDetail {\n    pub let id: UInt64 \n    pub let uuid: UInt64 \n    pub let name:String\n    pub let thumbnail:String\n    pub let type: String\n    pub var rarity:String?\n    pub var royalties: [Royalties]\n    pub var editionNumber: UInt64? \n    pub var totalInEdition: UInt64?\n    pub var scalars : {String: UFix64}\n    pub var tags : {String: String}\n    pub var media: [MetadataViews.Media]\n    pub var collectionName: String? \n    pub var collectionDescription: String? \n    pub var data: {String : AnyStruct?}\n    pub var views :[String]\n\n    init(_ pointer: FindViews.ViewReadPointer, views: {String : AnyStruct}){\n\n        let item = pointer.getViewResolver()\n\n        self.scalars={}\n        self.tags={}\n        self.media=[]\n        self.collectionName=nil\n        self.collectionDescription=nil\n\n        if let grouping=FindViews.getNFTCollectionDisplay(item) {\n            self.collectionName=grouping.name\n            self.collectionDescription=grouping.description\n        }\n\n        /* Rarity */\n        self.rarity=nil\n        if let r = FindViews.getRarity(item) {\n          self.rarity=r.rarityName\n        }\n\n\n        if let t= FindViews.getTags(item) {\n            self.tags=t.getTag()\n        }            \n\n        if let scalar=FindViews.getScalar(item){\n                self.scalars=scalar.getScalar()\n        }\n        /* Medias */\n        let mediaView=item.resolveView(Type\u003cFindViews.Medias\u003e())\n        if mediaView != nil {\n            let view = mediaView!\n            if view as? FindViews.Medias != nil {\n                let media = view as! FindViews.Medias\n                self.media=media.items\n            }\n        }\n    \n\n        let display = FindViews.getDisplay(item) ?? panic(\"Could not find display\")\n        self.name=display.name\n        self.thumbnail=display.thumbnail.uri()\n        self.type=item.getType().identifier\n        self.id=pointer.id\n        self.uuid=pointer.getUUID()\n\n        /* Edition */\n        self.editionNumber=nil\n        self.totalInEdition=nil\n            if let editions = FindViews.getEditions(item) {\n                for edition in editions.infoList {\n                    if edition.name == nil {\n                        self.editionNumber=edition.number\n                        self.totalInEdition=edition.max\n                    } else {\n                        self.scalars[\"edition_\".concat(edition.name!).concat(\"_number\")] = UFix64(edition.number)\n                        if edition.max != nil {\n                            self.scalars[\"edition_\".concat(edition.name!).concat(\"_max\")] = UFix64(edition.max!)\n                        }\n                    }\n                }\n            }\n\n        /* Royalties */\n        self.royalties=resolveRoyalties(pointer)\n        self.data=views\n\n        self.views=[]\n        for view in item.getViews() {\n            if ignoreViews().contains(view) {\n                continue\n            }\n            self.views.append(view.identifier)\n        }\n    }\n\n}\n\npub struct StoreFrontCut {\n\n    pub let amount:UFix64\n    pub let address: Address\n    pub let findName:String?\n\n    init(amount:UFix64, address:Address){\n        self.amount=amount\n        self.address=address\n        self.findName= FIND.reverseLookup(address)\n    }\n}\n\npub struct Royalties {\n\n    pub let royaltyName: String \n    pub let address: Address \n    pub let findName: String? \n    pub let cut: UFix64 \n\n    init(royaltyName: String , address: Address, findName: String?, cut: UFix64) {\n        self.royaltyName=royaltyName \n        self.address=address \n        self.findName=findName \n        self.cut=cut\n    }\n}\n\npub struct StorefrontListing {\n    pub let nftID:UInt64\n    pub let nftIdentifier: String\n    pub let saleCut: [StoreFrontCut]\n    pub let amount:UFix64\n    pub let ftTypeIdentifier:String\n    pub let storefront:UInt64\n    pub let listingID:UInt64\n\n    init(listingId:UInt64, details: NFTStorefront.ListingDetails) {\n\n        self.saleCut=[]\n        self.nftID=details.nftID\n        self.nftIdentifier=details.nftType.identifier\n        for cutDetails in details.saleCuts {\n            self.saleCut.append(StoreFrontCut(amount:cutDetails.amount, address:cutDetails.receiver.address))\n        }\n        self.amount=details.salePrice\n        self.ftTypeIdentifier=details.salePaymentVaultType.identifier\n        self.storefront=details.storefrontID\n        self.listingID=listingId\n    }\n}\n\npub fun main(user: String, nftAliasOrIdentifier:String, id: UInt64, views: [String]) : NFTDetailReport?{\n    let resolveAddress = FIND.resolve(user) \n    if resolveAddress == nil {\n        return nil\n    }\n    let address = resolveAddress!\n\n    let account = getAccount(address) \n    let publicPath = NFTRegistry.getNFTInfo(nftAliasOrIdentifier)?.publicPath ?? panic(\"This NFT is not supported by NFT Registry\")\n    let cap = account.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(publicPath)\n    let pointer = FindViews.ViewReadPointer(cap: cap, id: id)\n\n    let nftDetail = getNFTDetail(pointer:pointer, views: views)\n    if nftDetail == nil {\n        return nil\n    }\n\n\n    let findAddress=FindMarket.getFindTenantAddress()\n    let findMarket=FindMarket.getNFTListing(tenant:findAddress, address: address, id: nftDetail!.uuid, getNFTInfo:false)\n\n    var listings : StorefrontListing? = nil\n    let storefrontCap = account.getCapability\u003c\u0026NFTStorefront.Storefront{NFTStorefront.StorefrontPublic}\u003e(NFTStorefront.StorefrontPublicPath)\n\n    if storefrontCap.check() {\n        let storefrontRef=storefrontCap.borrow()!\n        for listingId in storefrontRef.getListingIDs() {\n            let listing = storefrontRef.borrowListing(listingResourceID: listingId)!\n            let nft=listing.borrowNFT()\n            if nft.id==id \u0026\u0026 !listing.getDetails().purchased {\n                listings = StorefrontListing(listingId: listingId, details: listing.getDetails())\n            }\n        }\n    }\n\n    let tenantCap = FindMarket.getTenantCapability(findAddress)!\n    let tenantRef = tenantCap.borrow() ?? panic(\"This tenant is not set up.\")\n\n    let marketTypes = FindMarket.getSaleItemTypes()\n    var report : {String : ListingTypeReport} = {}\n    for marketType in marketTypes {\n        if let allowedListing = tenantRef.getAllowedListings(nftType: pointer.getItemType(), marketType: marketType) {\n            report[FindMarket.getMarketOptionFromType(marketType)] = createListingTypeReport(allowedListing)\n        }\n    }\n\n    return NFTDetailReport(findMarket:findMarket, storefront: listings, nftDetail: nftDetail, allowedListingActions: report)\n\n}\n\npub fun getNFTDetail(pointer: FindViews.ViewReadPointer, views: [String]) : NFTDetail? {\n\n    if !pointer.valid() {\n        return nil\n    }\n\n    let viewTypes = pointer.getViews() \n    var nftViews: {String : AnyStruct} = {}\n    for viewType in viewTypes {\n        if views.contains(getType(viewType)) {\n            if let view = pointer.resolveView(viewType) {\n                nftViews[getType(viewType)] = view! \n            }\n        }\n    }\n    return NFTDetail(pointer, views: nftViews)\n\n\n}\n\n/* Helper Function */\npub fun getType(_ type: Type) : String {\n    let identifier = type.identifier\n    var dots = 0\n    var counter = 0 \n    while counter \u003c identifier.length {\n        if identifier[counter] == \".\" {\n            dots = dots + 1\n            if dots == 3 {\n                break\n            }\n        }\n        counter = counter + 1\n    }\n    if dots == 0 {\n        return identifier\n    }\n    if counter + 1 \u003e identifier.length {\n        panic(\"Identifier is \".concat(identifier))\n    }\n    return identifier.slice(from: counter + 1, upTo: identifier.length)\n}\n\npub fun resolveRoyalties(_ pointer: FindViews.ViewReadPointer) : [Royalties] {\n    let array : [Royalties] = []\n    for royalty in pointer.getRoyalty().getRoyalties() {\n        let address = royalty.receiver.address\n        array.append(Royalties(royaltyName: royalty.description, address: address, findName: FIND.reverseLookup(address), cut: royalty.cut))\n    }\n\n    return array\n}\n\npub fun createListingTypeReport(_ allowedListing: FindMarket.AllowedListing) : ListingTypeReport {\n    let listingType = allowedListing.listingType.identifier\n    var ftAlias : [String] = []\n    var ftIdentifier : [String] = []\n    for ft in allowedListing.ftTypes {\n        ftIdentifier.append(ft.identifier)\n        if let ftInfo = FTRegistry.getFTInfo(ft.identifier) {\n            ftAlias.append(ftInfo.alias)\n        }\n    }\n    return ListingTypeReport(listingType: listingType, ftAlias: ftAlias, ftIdentifiers: ftIdentifier,  status: allowedListing.status )\n}\n\npub fun ignoreViews() : [Type] {\n    return [\n        Type\u003cMetadataViews.NFTCollectionDisplay\u003e() , \n        Type\u003cFindViews.Rarity\u003e() ,\n        Type\u003cFindViews.Tag\u003e() , \n        Type\u003cFindViews.Scalar\u003e() ,\n        Type\u003cFindViews.Medias\u003e() ,\n        Type\u003cMetadataViews.Display\u003e() ,\n        Type\u003cMetadataViews.Edition\u003e() ,\n        Type\u003cMetadataViews.Editions\u003e() \n    ]\n}",
               "spec": {
                  "order": [
                     "user",
                     "nftAliasOrIdentifier",
                     "id",
                     "views"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "nftAliasOrIdentifier": "String",
                     "user": "String",
                     "views": "[String]"
                  }
               }
            },
            "getNFTInfo": {
               "code": "import NFTRegistry from 0x097bafa4e0b48eef\n\npub fun main(aliasOrIdentifier: String) : NFTRegistry.NFTInfo? {\n\n    return NFTRegistry.getNFTInfo(aliasOrIdentifier)\n\n}",
               "spec": {
                  "order": [
                     "aliasOrIdentifier"
                  ],
                  "parameters": {
                     "aliasOrIdentifier": "String"
                  }
               }
            },
            "getNFTInfoAll": {
               "code": "import NFTRegistry from 0x097bafa4e0b48eef\n\npub fun main() : {String: NFTRegistry.NFTInfo}{\n\n    return NFTRegistry.getNFTInfoAll()\n\n}",
               "spec": null
            },
            "getNFTView": {
               "code": "import MetadataViews from 0x1d7e57aa55817448\nimport NFTRegistry from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\n\n//Fetch a single view from a nft on a given path\npub fun main(user: String, aliasOrIdentifier:String, id: UInt64, identifier: String) : AnyStruct? {\n\n    let nftInfo = NFTRegistry.getNFTInfo(aliasOrIdentifier) \n    if nftInfo == nil {panic(\"This NFT is not registered in registry. input: \".concat(aliasOrIdentifier))}\n    let resolveAddress = FIND.resolve(user) \n    if resolveAddress == nil {return []}\n    let address = resolveAddress!\n\n    let pp = nftInfo!.publicPath\n    let collection= getAccount(address).getCapability(pp).borrow\u003c\u0026{MetadataViews.ResolverCollection}\u003e()!\n\n    let nft=collection.borrowViewResolver(id: id)\n    for v in nft.getViews() {\n        if v.identifier== identifier {\n            return nft.resolveView(v)\n        }\n    }\n    return nil\n}",
               "spec": {
                  "order": [
                     "user",
                     "aliasOrIdentifier",
                     "id",
                     "identifier"
                  ],
                  "parameters": {
                     "aliasOrIdentifier": "String",
                     "id": "UInt64",
                     "identifier": "String",
                     "user": "String"
                  }
               }
            },
            "getNFTViews": {
               "code": "import MetadataViews from 0x1d7e57aa55817448\nimport NFTRegistry from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\n\n//get all the views for an nft and address/path/id\npub fun main(user: String, aliasOrIdentifier:String, id: UInt64) : [String] {\n    let nftInfo = NFTRegistry.getNFTInfo(aliasOrIdentifier) \n    if nftInfo == nil {panic(\"This NFT is not registered in registry. input: \".concat(aliasOrIdentifier))}\n\n    let resolveAddress = FIND.resolve(user) \n    if resolveAddress == nil {return []}\n    let address = resolveAddress!\n    let pp = nftInfo!.publicPath\n    let collection= getAccount(address).getCapability(pp).borrow\u003c\u0026{MetadataViews.ResolverCollection}\u003e()!\n    let nft=collection.borrowViewResolver(id: id)\n    let views:[String]=[]\n    for v in nft.getViews() {\n        views.append(v.identifier)\n    }\n    return views\n}",
               "spec": {
                  "order": [
                     "user",
                     "aliasOrIdentifier",
                     "id"
                  ],
                  "parameters": {
                     "aliasOrIdentifier": "String",
                     "id": "UInt64",
                     "user": "String"
                  }
               }
            },
            "getName": {
               "code": "import FIND from 0x097bafa4e0b48eef\n\npub fun main(address: Address) : String?{\n    return FIND.reverseLookup(address)\n}",
               "spec": {
                  "order": [
                     "address"
                  ],
                  "parameters": {
                     "address": "Address"
                  }
               }
            },
            "getNameDetails": {
               "code": "import FIND from 0x097bafa4e0b48eef\nimport Profile from 0x097bafa4e0b48eef\nimport RelatedAccounts from 0x097bafa4e0b48eef\n\npub struct FINDReport {\n    pub let profile:Profile.UserReport?\n    pub let bids: [FIND.BidInfo]\n    pub let relatedAccounts: { String: Address}\n    pub let leases: [FIND.LeaseInformation]\n    pub let privateMode: Bool\n\n\n    init(profile: Profile.UserReport?, relatedAccounts: {String: Address}, bids: [FIND.BidInfo], leases : [FIND.LeaseInformation], privateMode: Bool ) {\n        self.profile=profile\n        self.bids=bids\n        self.leases=leases\n        self.relatedAccounts=relatedAccounts\n        self.privateMode=privateMode\n    }\n}\n\npub struct NameReport {\n    pub let status: String\n    pub let cost: UFix64 \n    pub let leaseStatus: FIND.LeaseInformation?\n    pub let userReport: FINDReport? \n\n    init(status: String, cost: UFix64, leaseStatus: FIND.LeaseInformation?, userReport: FINDReport? ) {\n        self.status=status \n        self.cost=cost \n        self.leaseStatus=leaseStatus\n        self.userReport=userReport\n    }\n}\n\npub fun main(user: String) : NameReport? {\n\n    var findReport: FINDReport? = nil\n    var nameLease: FIND.LeaseInformation? = nil\n    if let address=FIND.resolve(user) {\n        let account=getAccount(address)\n        let bidCap = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        let leaseCap = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        let profile=account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath).borrow()\n\n        findReport = FINDReport(\n            profile: profile?.asReport(),\n            relatedAccounts: RelatedAccounts.findRelatedFlowAccounts(address:address),\n            bids: bidCap.borrow()?.getBids() ?? [],\n            leases: leaseCap.borrow()?.getLeaseInformation() ?? [],\n            privateMode: profile?.isPrivateModeEnabled() ?? false\n        )\n        if FIND.validateFindName(user) \u0026\u0026 findReport != nil {\n            for lease in findReport!.leases {\n                if lease.name == user {\n                    nameLease = lease\n                    break\n                }\n            }\n        }\n        \n    }\n\n    var nameReport : NameReport? = nil \n    if FIND.validateFindName(user) {\n        let status = FIND.status(user)\n        let cost=FIND.calculateCost(user)\n        var s=\"TAKEN\"    \n        if status.status == FIND.LeaseStatus.FREE {\n            s=\"FREE\"\n        } else if status.status == FIND.LeaseStatus.LOCKED {\n            s=\"LOCKED\"\n        }\n        nameReport = NameReport(status: s, cost: cost, leaseStatus: nameLease, userReport: findReport)\n    }\n    \n\n    return nameReport\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "getNameStatus": {
               "code": "import FIND from 0x097bafa4e0b48eef\nimport Profile from 0x097bafa4e0b48eef\n\npub fun main(name: String) :  \u0026{Profile.Public}? {\n    return FIND.lookup(name)\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "getNames": {
               "code": "import FIND from 0x097bafa4e0b48eef\n\npub fun main(address: [Address]) : { Address:String}{\n\n    let items : {Address:String} = {}\n    for a in address {\n        if let name= FIND.reverseLookup(a) {\n            items[a]=name\n        }\n    }\n    return items\n}",
               "spec": {
                  "order": [
                     "address"
                  ],
                  "parameters": {
                     "address": "[Address]"
                  }
               }
            },
            "getNamesWithBids": {
               "code": "import FIND from 0x097bafa4e0b48eef\n\npub fun main(user: String) : [FIND.LeaseInformation] {\n\n    let resolveAddress = FIND.resolve(user) \n    if resolveAddress == nil {return []}\n    let address = resolveAddress!\n    let account=getAccount(address)\n    let leaseCap = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\n    let leases=leaseCap.borrow()?.getLeaseInformation() ?? []\n\n    var leasesWithBids :[FIND.LeaseInformation] =[]\n    for lease in leases {\n        if lease.latestBidBy != nil {\n            leasesWithBids.append(lease)\n        }\n    }\n\n    return leasesWithBids\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "getNamesWithoutBids": {
               "code": "import FIND from 0x097bafa4e0b48eef\n\n\npub fun main(user: String) : [String] {\n\n    let resolveAddress = FIND.resolve(user) \n    if resolveAddress == nil {return []}\n    let address = resolveAddress!\n    let account=getAccount(address)\n    let leaseCap = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\n    let leases=leaseCap.borrow()?.getLeaseInformation() ?? []\n\n    var leasesWithBids :[String] =[]\n    for lease in leases {\n        if lease.latestBidBy == nil {\n            leasesWithBids.append(lease.name)\n        }\n    }\n\n    return leasesWithBids\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "getProfile": {
               "code": "import Profile from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\n\npub fun main(user: String) :  Profile.UserReport? {\n    let resolveAddress = FIND.resolve(user) \n    if resolveAddress == nil {return nil}\n    let address = resolveAddress!\n\n    return getAccount(address)\n        .getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        .borrow()?.asReport()\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "getStatus": {
               "code": "import FIND from 0x097bafa4e0b48eef\nimport Profile from 0x097bafa4e0b48eef\nimport RelatedAccounts from 0x097bafa4e0b48eef\nimport FindMarket from 0x097bafa4e0b48eef\n\npub struct FINDReport{\n    pub let profile:Profile.UserReport?\n    pub let bids: [FIND.BidInfo]\n    pub let relatedAccounts: { String: Address}\n    pub let leases: [FIND.LeaseInformation]\n    pub let privateMode: Bool\n    pub let itemsForSale: {String : FindMarket.SaleItemCollectionReport}\n    pub let marketBids: {String : FindMarket.BidItemCollectionReport}\n\n\n    init(profile: Profile.UserReport?, relatedAccounts: {String: Address}, bids: [FIND.BidInfo], leases : [FIND.LeaseInformation], privateMode: Bool, itemsForSale: {String : FindMarket.SaleItemCollectionReport}, marketBids: {String : FindMarket.BidItemCollectionReport}) {\n        self.profile=profile\n        self.bids=bids\n        self.leases=leases\n        self.relatedAccounts=relatedAccounts\n        self.privateMode=privateMode\n        self.itemsForSale=itemsForSale\n        self.marketBids=marketBids\n    }\n}\n\npub struct NameReport {\n    pub let status: String \n    pub let cost: UFix64 \n\n    init(status: String, cost: UFix64) {\n        self.status=status \n        self.cost=cost\n    }\n}\n\npub struct Report {\n    pub let FINDReport: FINDReport?\n    pub let NameReport: NameReport?\n\n    init(FINDReport: FINDReport?, NameReport: NameReport?) {\n        self.FINDReport=FINDReport \n        self.NameReport=NameReport\n    }\n}\n\npub fun main(user: String) : Report? {\n\n    var findReport: FINDReport? = nil\n    if let address=FIND.resolve(user) {\n        let account=getAccount(address)\n        let bidCap = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        let leaseCap = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        let profile=account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath).borrow()\n\n        let find= FindMarket.getFindTenantAddress()\n        let items : {String : FindMarket.SaleItemCollectionReport} = FindMarket.getSaleItemReport(tenant:find, address: address, getNFTInfo:true)\n\n        let marketBids : {String : FindMarket.BidItemCollectionReport} = FindMarket.getBidsReport(tenant:find, address: address, getNFTInfo:true)\n\n        findReport = FINDReport(\n            profile: profile?.asReport(),\n            relatedAccounts: RelatedAccounts.findRelatedFlowAccounts(address:address),\n            bids: bidCap.borrow()?.getBids() ?? [],\n            leases: leaseCap.borrow()?.getLeaseInformation() ?? [],\n            privateMode: profile?.isPrivateModeEnabled() ?? false,\n            itemsForSale: items,\n            marketBids: marketBids\n        )\n    }\n\n    var nameReport : NameReport? = nil \n    if FIND.validateFindName(user) {\n        let status = FIND.status(user)\n        let cost=FIND.calculateCost(user)\n        var s=\"TAKEN\"    \n        if status.status == FIND.LeaseStatus.FREE {\n            s=\"FREE\"\n        } else if status.status == FIND.LeaseStatus.LOCKED {\n            s=\"LOCKED\"\n        }\n        nameReport = NameReport(status: s, cost: cost)\n    }\n    \n\n    return Report(FINDReport: findReport, NameReport: nameReport)\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "getTenantSaleItem": {
               "code": "import FindMarket from 0x097bafa4e0b48eef\n\npub fun main(tenant: Address) : TenantSaleItems {\n    let tenantCap = FindMarket.getTenantCapability(tenant) ?? panic(\"No tenant capability is set up for this address\")\n    let tenantRef = tenantCap.borrow() ?? panic(\"Cannot borrow tenant reference from this address\")\n    let saleItems = tenantRef.getSaleItems()\n    return TenantSaleItems(findSaleItems: saleItems[\"findSaleItems\"]! ,\n                           tenantSaleItems: saleItems[\"tenantSaleItems\"]! ,\n                           findCuts: saleItems[\"findCuts\"]! )\n\n}\n\npub struct TenantSaleItems {\n    pub let findSaleItems : {String : FindMarket.TenantSaleItem}\n    pub let tenantSaleItems : {String : FindMarket.TenantSaleItem}\n    pub let findCuts : {String : FindMarket.TenantSaleItem} \n\n    init(findSaleItems : {String : FindMarket.TenantSaleItem}, \n         tenantSaleItems : {String : FindMarket.TenantSaleItem},\n         findCuts : {String : FindMarket.TenantSaleItem}) {\n             self.findSaleItems = findSaleItems\n             self.tenantSaleItems = tenantSaleItems \n             self.findCuts = findCuts \n         }\n}",
               "spec": {
                  "order": [
                     "tenant"
                  ],
                  "parameters": {
                     "tenant": "Address"
                  }
               }
            },
            "hasCharity": {
               "code": "import CharityNFT from 0x097bafa4e0b48eef\n\npub fun main(user: Address) : Bool {\n    let account=getAccount(user)\n    let charityCap = account.getCapability\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection)\n    return charityCap.check()\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "Address"
                  }
               }
            },
            "isFindUser": {
               "code": "import Profile from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\n\npub fun main(user: Address) : Bool {\n\n    let account=getAccount(user)\n    let leaseCap=account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n    let profileCap=account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\n    return leaseCap.check() \u0026\u0026 profileCap.check()\n\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "Address"
                  }
               }
            },
            "mainnet_getBeam": {
               "code": "import Beam from 0x86b4a0010a71cfc3 \n\npub struct MetadataCollectionItem {\n    pub let id:UInt64\n    pub let name: String\n    pub let image: String\n    pub let url: String\n    pub let listPrice: UFix64?\n    pub let listToken: String?\n    pub let contentType:String\n    pub let rarity:String\n\n\n    init(id:UInt64, name:String, image:String, url:String, listPrice: UFix64?, listToken:String?, contentType: String, rarity: String) {\n        self.id=id\n        self.name=name\n        self.url=url\n        self.image=image\n        self.listToken=listToken\n        self.listPrice=listPrice\n        self.contentType=contentType\n        self.rarity=rarity\n    }\n}\n\npub fun main(address: Address) : [MetadataCollectionItem] {\n\n\n    let items: [MetadataCollectionItem] = []\n    let account=getAccount(address)\n    let beamCap = account.getCapability\u003c\u0026{Beam.BeamCollectionPublic}\u003e(Beam.CollectionPublicPath)\n    if beamCap.check() {\n        let collection = beamCap.borrow()!\n        for id in collection.getIDs() {\n            let nft = collection.borrowCollectible(id: id)!\n\n        let metadata = Beam.getCollectibleItemMetaData(collectibleItemID: nft.data.collectibleItemID)!\n          var mediaUrl: String? = metadata[\"mediaUrl\"]\n            if mediaUrl != nil \u0026\u0026  mediaUrl!.slice(from: 0, upTo: 7) != \"ipfs://\" {\n                mediaUrl = \"ipfs://\".concat(mediaUrl!)\n            }\n            let item = MetadataCollectionItem(\n                id: id,\n                name: metadata[\"title\"]!,\n                image: mediaUrl ?? \"\",\n                url: \"https://\".concat(metadata[\"domainUrl\"]!),\n                listPrice: nil,\n                listToken: nil,\n                contentType: metadata[\"mediaType\"]!,\n                rarity: \"\"\n            )\n\n            items.append(item)\n        }\n    }\n    return items\n\n}",
               "spec": {
                  "order": [
                     "address"
                  ],
                  "parameters": {
                     "address": "Address"
                  }
               }
            },
            "mainnet_getCharity": {
               "code": "import NonFungibleToken from 0x1d7e57aa55817448\nimport CharityNFT from 0x097bafa4e0b48eef\n\npub fun main(address: Address) : [UInt64] {\n    \n    let account = getAccount(address)\n    let charityCap = account.getCapability\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection)\n\n    return charityCap.borrow()!.getIDs()\n}",
               "spec": {
                  "order": [
                     "address"
                  ],
                  "parameters": {
                     "address": "Address"
                  }
               }
            },
            "mainnet_getCollections2": {
               "code": "import NonFungibleToken from 0x1d7e57aa55817448\nimport CharityNFT from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\n\n//mainnet\n\nimport Beam from 0x86b4a0010a71cfc3 \nimport Art from 0xd796ff17107bbff6\nimport Marketplace from 0xd796ff17107bbff6\nimport GooberXContract from 0x34f2bf4a80bb0f69\nimport Flovatar from 0x921ea449dffec68a\nimport FlovatarMarketplace from  0x921ea449dffec68a\nimport RareRooms_NFT from 0x329feb3ab062d289\nimport CNN_NFT from 0x329feb3ab062d289\nimport Canes_Vault_NFT from 0x329feb3ab062d289\nimport DGD_NFT from 0x329feb3ab062d289\nimport RaceDay_NFT from 0x329feb3ab062d289\nimport The_Next_Cartel_NFT from 0x329feb3ab062d289\nimport UFC_NFT from 0x329feb3ab062d289\nimport MotoGPCard from 0xa49cc0ee46c54bfb\nimport Gaia from 0x8b148183c28ff88f\nimport ChainmonstersRewards from 0x93615d25d14fa337\nimport Moments from 0xd4ad4740ee426334\nimport MatrixWorldFlowFestNFT from 0x2d2750f240198f91\nimport SturdyItems from 0x427ceada271aa0b1\nimport Evolution from 0xf4264ac8f3256818\nimport GeniaceNFT from 0xabda6627c70c7f52\nimport OneFootballCollectible from 0x6831760534292098\nimport CryptoPiggo from 0xd3df824bf81910a4\nimport GoatedGoatsVouchers from 0xdfc74d9d561374c0\nimport TraitPacksVouchers from 0xdfc74d9d561374c0\nimport HaikuNFT from 0xf61e40c19db2a9e2\nimport KlktnNFT from 0xabd6e80be7e9682c\nimport Mynft from 0xf6fcbef550d97aa5\nimport NeoAvatar from 0xb25138dbf45e5801\nimport NeoViews from 0xb25138dbf45e5801\nimport MetadataViews from 0x1d7e57aa55817448\n\n//Jambb\nimport Vouchers from 0x444f5ea22c6ea12c\n\n//xtingles\nimport Collectible from 0xf5b0eb433389ac3f\n\npub struct MetadataCollection {\n\n    pub let path:PublicPath\n    pub let type: Type\n    pub let typeIdentifier: String\n    pub let conformance: String \n    pub let domainUrl : String\n    pub let category: String\n    pub let legacyIdentifierPrefix:String\n    pub let transferable: Bool\n\n    init(path:PublicPath, type:Type, conformance:String, domainUrl:String, category:String, legacyIdentifierPrefix:String, transferable:Bool) {\n        self.path=path\n        self.type=type\n        self.typeIdentifier=type.identifier\n        self.conformance=conformance\n        self.domainUrl=domainUrl\n        self.category=category\n        self.legacyIdentifierPrefix=legacyIdentifierPrefix\n        self.transferable=transferable\n    }\n\n}\n\npub struct MetadataCollections {\n\n    pub let items: {UInt64 : MetadataCollectionItem}\n    pub let internalToUuidMap: {String : UInt64 }\n    pub let collections: {String : [UInt64]}\n\n    init() {\n        self.items= {}\n        self.internalToUuidMap= {}\n        self.collections={}\n    }\n\n\n    pub fun addCollection(items:[MetadataCollectionItem]) {\n\n\n        if items.length == 0 {\n            return\n        }\n\n        let collection=items[0].collection\n        let resultCollection = self.collections[collection.category] ?? []\n        for item in items {\n            self.items[item.uuid]=item\n            //we add a mapping from old legacy internal id to uuid\n            self.internalToUuidMap[collection.legacyIdentifierPrefix.concat(item.id.toString())]= item.uuid\n            resultCollection.append(item.uuid)\n        }\n        self.collections[collection.category]=resultCollection\n    }\n\n    //This uses a view from Neo until we agree on another for ExternalDomainViewUrl\n    pub fun addMetadataCollection(path: PublicPath, account:PublicAccount, category:String, legacyIdentifierPrefix: String, url:String, transferable:Bool)  {\n\n        // init(path:PublicPath, type:Type, conformance:String, domainUrl:String, items: {UInt64:MetadataCollectionItem}, category:String, legacyIdentifierPrefix:String) {\n\n        let resolverCollectionCap= account.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(path)\n        if !resolverCollectionCap.check() {\n            return \n        }\n\n        let collection = resolverCollectionCap.borrow()!\n\n        let mc= MetadataCollection(path: path, type: collection.getType() , conformance: \"MetadataViews.ResolverCollection\", domainUrl: url, category: category, legacyIdentifierPrefix: legacyIdentifierPrefix, transferable: transferable)\n\n\n        let items:[MetadataCollectionItem]=[]\n        for id in collection.getIDs() {\n            let nft = collection.borrowViewResolver(id: id)!\n\n            if let displayView = nft.resolveView(Type\u003cMetadataViews.Display\u003e()) {\n                let display = displayView as! MetadataViews.Display\n\n                var externalUrl=mc.domainUrl\n                if let externalUrlView = nft.resolveView(Type\u003cNeoViews.ExternalDomainViewUrl\u003e()) {\n                    let edvu= externalUrlView! as! NeoViews.ExternalDomainViewUrl\n                    externalUrl=edvu.url\n                }\n\n                //: add check for rarity and minter here\n\n                let item = MetadataCollectionItem(\n                    id: id,\n                    uuid: nft.uuid,\n                    name: display.name,\n                    description:display.description,\n                    image: display.thumbnail.uri(),\n                    url: externalUrl,\n                    contentType: \"image\",\n                    rarity: \"\",\n                    minter: \"\",\n                    type: nft.getType(),\n                    collection:mc\n                )\n                items.append(item)\n            }\n        }\n        self.addCollection(items: items)\n    }\n}\n\n\npub struct MetadataCollectionItem {\n    pub let id:UInt64\n    pub let uuid:UInt64\n    pub let name: String\n    pub let description: String?\n    pub let image: String\n    pub let url: String\n    pub let contentType:String\n    pub let rarity:String\n    pub let minter:String?\n    pub let type:Type\n    pub let collection:MetadataCollection\n\n\n    init(id:UInt64, uuid:UInt64, name:String, description:String?, image:String, url:String, contentType: String, rarity: String, minter:String?, type:Type, collection: MetadataCollection) {\n        self.id=id\n        self.uuid=uuid\n        self.name=name\n        self.description=description\n        self.minter=minter\n        self.url=url\n        self.type=type\n        self.image=image\n        self.collection=collection\n        self.contentType=contentType\n        self.rarity=rarity\n    }\n}\n\n// change bacak to address later\n//pub fun main(address: Address) : MetadataCollections? {\npub fun main(name: String) : MetadataCollections? {\n    let address=FIND.lookupAddress(name)!\n\n    let collection= MetadataCollections()\n    let account=getAccount(address)\n\n    let items:[MetadataCollectionItem]=[]\n\n    let versusArtCap=account.getCapability\u003c\u0026{Art.CollectionPublic}\u003e(Art.CollectionPublicPath)\n    let versusImageUrlPrefix = \"https://res.cloudinary.com/dxra4agvf/image/upload/c_fill,w_600/f_auto/maincache\"\n    if versusArtCap.check(){\n\n        let artCollection= versusArtCap.borrow()!\n\n        let mc= MetadataCollection(path: Art.CollectionPublicPath, type: artCollection.getType() , conformance: \"Art.CollectionPublic\", domainUrl: \"https://versus.auction\", category: \"Versus\", legacyIdentifierPrefix: \"Versus\", transferable: true)\n\n        for id in artCollection.getIDs() {\n            var art=artCollection.borrowArt(id: id)!\n            let item = MetadataCollectionItem(\n                id: id,\n                uuid: art.uuid,\n                name: art.metadata.name.concat(\" edition \").concat(art.metadata.edition.toString()).concat(\"/\").concat(art.metadata.maxEdition.toString()).concat(\" by \").concat(art.metadata.artist),  \n                description:art.metadata.description,\n                image: versusImageUrlPrefix.concat(art.cacheKey()), \n                url: \"https://www.versus.auction/piece/\".concat(address.toString()).concat(\"/\").concat(art.id.toString()).concat(\"/\"),\n                contentType: \"image\",\n                rarity: \"\",\n                minter: \"\",\n                type: art.getType(),\n                collection:mc\n            )\n            items.append(item)\n        }\n    }\n\n    let versusMarketplace = account.getCapability\u003c\u0026{Marketplace.SalePublic}\u003e(Marketplace.CollectionPublicPath)\n    if versusMarketplace.check() {\n\n        let versusMarket = versusMarketplace.borrow()!\n\n        let mc= MetadataCollection(path: Marketplace.CollectionPublicPath, type: versusMarketplace.borrow()!.getType() , conformance: \"Marketplace.SalePublic\", domainUrl: \"https://versus.auction\", category: \"Versus\", legacyIdentifierPrefix: \"Versus\", transferable:false)\n\n        let saleItems = versusMarket.listSaleItems()\n        for saleItem in saleItems {\n\n            let uuid = versusMarket.getUUIDforSaleItem(tokenID: saleItem.id)\n            let item = MetadataCollectionItem(\n                id: saleItem.id,\n                uuid: uuid,\n                name: saleItem.art.name.concat(\" edition \").concat(saleItem.art.edition.toString()).concat(\"/\").concat(saleItem.art.maxEdition.toString()).concat(\" by \").concat(saleItem.art.artist),\n                description:\"\",\n                image: versusImageUrlPrefix.concat(saleItem.cacheKey), \n                url: \"https://www.versus.auction/listing/\".concat(saleItem.id.toString()).concat(\"/\"),\n                contentType: \"image\",\n                rarity: \"\",\n                minter: \"\",\n                type: Type\u003c@Art.NFT\u003e(), \n                collection:mc\n            )\n            items.append(item)\n        }\n    }\n\n  let flovatarCap = account.getCapability\u003c\u0026{Flovatar.CollectionPublic}\u003e(Flovatar.CollectionPublicPath)  \n    if flovatarCap.check(){\n\n        let flovatars=flovatarCap.borrow()!\n         let mc= MetadataCollection(path: Flovatar.CollectionPublicPath, type: flovatars.getType() , conformance: \"Flovatar.CollectionPublic\", domainUrl: \"https://flovatar.com\", category: \"Flovatar\", legacyIdentifierPrefix: \"Flovatar\", transferable:true)\n        for id in flovatars.getIDs() {\n            let flovatar = flovatars.borrowFlovatar(id: id)!\n\n            let metadata=flovatar.getMetadata()\n            var name = flovatar.getName()\n            if name == \"\" {\n                name=\"Flovatar #\".concat(flovatar.id.toString())\n            }\n\n            var rarity=\"common\"\n            if metadata.legendaryCount \u003e 0 {\n                rarity=\"legendary\"\n            }else if metadata.epicCount \u003e 0 {\n                rarity=\"epic\"\n            }else if metadata.rareCount \u003e 0 {\n                rarity=\"rare\"\n            }\n\n\n            let item=MetadataCollectionItem(\n                id: flovatar.id, \n                uuid:flovatar.uuid,\n                name: name, \n                description: flovatar.description,\n                image: \"https://flovatar.com/api/image/\".concat(flovatar.id.toString()),\n                url: \"https://flovatar.com/flovatars/\".concat(flovatar.id.toString()).concat(\"/\"),\n                contentType: \"image\",\n                rarity: rarity,\n                minter: \"\",\n                type: flovatar.getType(),\n                collection:mc\n            )\n            items.append(item)\n        }\n    }\n\n\n    let flovatarMarketCap = account.getCapability\u003c\u0026{FlovatarMarketplace.SalePublic}\u003e(FlovatarMarketplace.CollectionPublicPath)  \n    if flovatarMarketCap.check(){\n\n        let saleCollection=flovatarMarketCap.borrow()!\n         let mc= MetadataCollection(path: FlovatarMarketplace.CollectionPublicPath, type: saleCollection.getType() , conformance: \"FlovatarMarketplace.SalePublic\", domainUrl: \"https://flovatar.com\", category: \"Flovatar\", legacyIdentifierPrefix: \"Flovatar\", transferable:false)\n        for id in saleCollection.getFlovatarIDs() {\n            let flovatar = saleCollection.getFlovatar(tokenId: id)!\n\n            let metadata=flovatar.getMetadata()\n            var name = flovatar.getName()\n            if name == \"\" {\n                name=\"Flovatar #\".concat(flovatar.id.toString())\n            }\n\n            var rarity=\"common\"\n            if metadata.legendaryCount \u003e 0 {\n                rarity=\"legendary\"\n            }else if metadata.epicCount \u003e 0 {\n                rarity=\"epic\"\n            }else if metadata.rareCount \u003e 0 {\n                rarity=\"rare\"\n            }\n\n\n            let item=MetadataCollectionItem(\n                id: flovatar.id, \n                uuid:flovatar.uuid,\n                name: name, \n                description: flovatar.description,\n                image: \"https://flovatar.com/api/image/\".concat(flovatar.id.toString()),\n                url: \"https://flovatar.com/flovatars/\".concat(flovatar.id.toString()).concat(\"/\"),\n                contentType: \"image\",\n                rarity: rarity,\n                minter: \"\",\n                type: flovatar.getType(),\n                collection:mc\n            )\n            items.append(item)\n        }\n    }\n\n\n    let goobersCap = account.getCapability\u003c\u0026GooberXContract.Collection{NonFungibleToken.CollectionPublic, GooberXContract.GooberCollectionPublic}\u003e(GooberXContract.CollectionPublicPath)\n    if goobersCap.check() {\n\n        let goobers = goobersCap.borrow()!\n\n        let mc= MetadataCollection(path: GooberXContract.CollectionPublicPath, type: goobers.getType() , conformance: \"NonFungibleToken.CollectionPublic, GooberXContract.GooberCollectionPublic\", domainUrl: \"https://partimansion.io/gooberz\", category: \"Gooberz\", legacyIdentifierPrefix: \"Gooberz\", transferable:true)\n        for id in goobers.getIDs() {\n            let goober= goobers.borrowGoober(id:id)!\n            let item=MetadataCollectionItem(\n                id: id,\n                uuid: goober.uuid,\n                name: \"Goober #\".concat(id.toString()),\n                description: \"\",\n                image: goober.data.uri,\n                url: \"https://partymansion.io/gooberz/\".concat(id.toString()),\n                contentType: \"image\",\n                rarity: \"\",\n                minter:\"\",\n                type: goober.getType(),\n                collection:mc\n            )\n            items.append(item)\n        }\n    }\n\n\n    let rareRoomCap = account.getCapability\u003c\u0026RareRooms_NFT.Collection{RareRooms_NFT.RareRooms_NFTCollectionPublic}\u003e(RareRooms_NFT.CollectionPublicPath)\n    if rareRoomCap.check() {\n\n        let rareRooms = rareRoomCap.borrow()!\n        let mc= MetadataCollection(path: RareRooms_NFT.CollectionPublicPath, type: rareRooms.getType() , conformance: \"RareRooms_NFT.RareRooms_NFTCollectionPublic\", domainUrl: \"https://rarerooms.io\", category: \"RareRooms\", legacyIdentifierPrefix: \"RareRooms\", transferable:true)\n        for id in rareRooms.getIDs() {\n            let nft = rareRooms.borrowRareRooms_NFT(id: id)!\n            let metadata = RareRooms_NFT.getSetMetadata(setId: nft.setId)!\n            let item = MetadataCollectionItem(\n                id: id,\n                uuid: nft.uuid,\n                name: metadata[\"name\"]!,\n                description: metadata[\"description\"] ?? \"\", \n                image: metadata[\"preview\"]!,\n                url: \"https://rarerooms.io/tokens/\".concat(id.toString()),\n                contentType: \"image\",\n                rarity: \"\",\n                minter: \"\",\n                type: nft.getType(),\n                collection:mc\n            )\n            items.append(item)\n        }\n    }\n    \n\n    let cnnCap = account.getCapability\u003c\u0026CNN_NFT.Collection{CNN_NFT.CNN_NFTCollectionPublic}\u003e(CNN_NFT.CollectionPublicPath)\n    if cnnCap.check() {\n\n        let cnns = cnnCap.borrow()!\n        let mc= MetadataCollection(path: CNN_NFT.CollectionPublicPath, type: cnns.getType() , conformance: \"CNN_NFT.CNN_NFTCollectionPublic\", domainUrl: \"https://vault.cnn.com\", category: \"CNN\", legacyIdentifierPrefix: \"CNN\", transferable:true)\n        for id in cnns.getIDs() {\n            let nft = cnns.borrowCNN_NFT(id: id)!\n            let metadata = CNN_NFT.getSetMetadata(setId: nft.setId)!\n            let item = MetadataCollectionItem(\n                id: id,\n                uuid: nft.uuid,\n                name: metadata[\"name\"]!,\n                description: metadata[\"description\"] ?? \"\", \n                image: metadata[\"preview\"]!,\n                url: \"https://vault.cnn.com\",\n                contentType: \"image\",\n                rarity: \"\",\n                minter: \"\",\n                type: nft.getType(),\n                collection:mc\n            )\n            items.append(item)\n        }\n    }\n\n    let canesVaultCap = account.getCapability\u003c\u0026Canes_Vault_NFT.Collection{Canes_Vault_NFT.Canes_Vault_NFTCollectionPublic}\u003e(Canes_Vault_NFT.CollectionPublicPath)\n    if canesVaultCap.check() {\n\n        let canesVaults = canesVaultCap.borrow()!\n        let mc= MetadataCollection(path: Canes_Vault_NFT.CollectionPublicPath, type: canesVaults.getType() , conformance: \"Canes_Vault_NFT.Canes_Vault_NFTCollectionPublic\", domainUrl: \"https://canesvault.com\", category: \"Canes_Vault\", legacyIdentifierPrefix: \"Canes_Vault_NFT\", transferable:true)\n        for id in canesVaults.getIDs() {\n            let nft = canesVaults.borrowCanes_Vault_NFT(id: id)!\n            let metadata = Canes_Vault_NFT.getSetMetadata(setId: nft.setId)!\n            let item = MetadataCollectionItem(\n                id: id,\n                uuid: nft.uuid,\n                name: metadata[\"name\"]!,\n                description: metadata[\"description\"] ?? \"\", \n                image: metadata[\"preview\"]!,\n                url: \"https://canesvault.com\",\n                contentType: \"image\",\n                rarity: \"\",\n                minter: \"\",\n                type: nft.getType(),\n                collection:mc\n            )\n            items.append(item)\n        }\n    }\n\n    let dgdCap = account.getCapability\u003c\u0026DGD_NFT.Collection{DGD_NFT.DGD_NFTCollectionPublic}\u003e(DGD_NFT.CollectionPublicPath)\n    if dgdCap.check() {\n\n        let dgds = dgdCap.borrow()!\n        let mc= MetadataCollection(path: DGD_NFT.CollectionPublicPath, type: dgds.getType() , conformance: \"DGD_NFT.DGD_NFTCollectionPublic\", domainUrl: \"https://theplayerslounge.io\", category: \"DGD\", legacyIdentifierPrefix: \"DGD\", transferable:true)\n        for id in dgds.getIDs() {\n            let nft = dgds.borrowDGD_NFT(id: id)!\n            let metadata = DGD_NFT.getSetMetadata(setId: nft.setId)!\n            let item = MetadataCollectionItem(\n                id: id,\n                uuid: nft.uuid,\n                name: metadata[\"name\"]!,\n                description: metadata[\"description\"] ?? \"\", \n                image: metadata[\"preview\"]!,\n                url: \"https://www.theplayerslounge.io\",\n                contentType: \"image\",\n                rarity: \"\",\n                minter: \"\",\n                type: nft.getType(),\n                collection:mc\n            )\n            items.append(item)\n        }\n    }\n    \n    let raceDayCap = account.getCapability\u003c\u0026RaceDay_NFT.Collection{RaceDay_NFT.RaceDay_NFTCollectionPublic}\u003e(RaceDay_NFT.CollectionPublicPath)\n    if raceDayCap.check() {\n\n        let raceDays = raceDayCap.borrow()!\n        let mc= MetadataCollection(path: RaceDay_NFT.CollectionPublicPath, type: raceDays.getType() , conformance: \"RaceDay_NFT.RaceDay_NFTCollectionPublic\", domainUrl: \"https://racedaynft.com\", category: \"RaceDay\", legacyIdentifierPrefix: \"RaceDay_NFT\", transferable:true)\n        for id in raceDays.getIDs() {\n            let nft = raceDays.borrowRaceDay_NFT(id: id)!\n            let metadata = RaceDay_NFT.getSetMetadata(setId: nft.setId)!\n            let item = MetadataCollectionItem(\n                id: id,\n                uuid: nft.uuid,\n                name: metadata[\"name\"]!,\n                description: metadata[\"description\"] ?? \"\", \n                image: metadata[\"preview\"]!,\n                url: \"https://www.racedaynft.com\",\n                contentType: \"image\",\n                rarity: \"\",\n                minter: \"\",\n                type: nft.getType(),\n                collection:mc\n            )\n            items.append(item)\n        }\n    }\n\n    let nextCartelCap = account.getCapability\u003c\u0026The_Next_Cartel_NFT.Collection{The_Next_Cartel_NFT.The_Next_Cartel_NFTCollectionPublic}\u003e(The_Next_Cartel_NFT.CollectionPublicPath)\n    if nextCartelCap.check() {\n\n        let nextCartels = nextCartelCap.borrow()!\n        let mc= MetadataCollection(path: The_Next_Cartel_NFT.CollectionPublicPath, type: nextCartels.getType() , conformance: \"The_Next_Cartel_NFT.The_Next_Cartel_NFTCollectionPublic\", domainUrl: \"https://thenextcartel.com\", category: \"The_Next_Cartel\", legacyIdentifierPrefix: \"The_Next_Cartel_NFT\", transferable:true)\n        for id in nextCartels.getIDs() {\n            let nft = nextCartels.borrowThe_Next_Cartel_NFT(id: id)!\n            let metadata = The_Next_Cartel_NFT.getSetMetadata(setId: nft.setId)!\n            let item = MetadataCollectionItem(\n                id: id,\n                uuid: nft.uuid,\n                name: metadata[\"name\"]!,\n                description: metadata[\"description\"] ?? \"\", \n                image: metadata[\"preview\"]!,\n                url: \"https://thenextcartel.com/\",\n                contentType: \"image\",\n                rarity: \"\",\n                minter: \"\",\n                type: nft.getType(),\n                collection:mc\n            )\n            items.append(item)\n        }\n    }\n\n    let utcCap = account.getCapability\u003c\u0026UFC_NFT.Collection{UFC_NFT.UFC_NFTCollectionPublic}\u003e(UFC_NFT.CollectionPublicPath)\n    if utcCap.check() {\n\n        let utcs = utcCap.borrow()!\n        let mc= MetadataCollection(path: UFC_NFT.CollectionPublicPath, type: utcs.getType() , conformance: \"UFC_NFT.UFC_NFTCollectionPublic\", domainUrl: \"https://ufcstrike.com\", category: \"UFC\", legacyIdentifierPrefix: \"UFC\", transferable:true)\n        for id in utcs.getIDs() {\n            let nft = utcs.borrowUFC_NFT(id: id)!\n            let metadata = UFC_NFT.getSetMetadata(setId: nft.setId)!\n            let item = MetadataCollectionItem(\n                id: id,\n                uuid: nft.uuid,\n                name: metadata[\"name\"]!,\n                description: metadata[\"description\"] ?? \"\", \n                image: metadata[\"image\"]!,\n                url: \"https://ufcstrike.com\",\n                contentType: \"video\",\n                rarity: \"\",\n                minter: \"\",\n                type: nft.getType(),\n                collection:mc\n            )\n            items.append(item)\n        }\n    }\n\n    let motoGPCollection = account.getCapability\u003c\u0026MotoGPCard.Collection{MotoGPCard.ICardCollectionPublic}\u003e(/public/motogpCardCollection)\n    if motoGPCollection.check() {\n        let motoGPNfts = motoGPCollection.borrow()!\n\n        let mc= MetadataCollection(path: /public/motogpCardCollection, type: motoGPNfts.getType() , conformance: \"MotoGPCard.ICardCollectionPublic\", domainUrl: \"https://motogp-ignition.com.com\", category: \"MotoGP\", legacyIdentifierPrefix: \"MotoGP\", transferable:true)\n        for id in motoGPNfts.getIDs() {\n            let nft = motoGPNfts.borrowCard(id: id)!\n            let metadata = nft.getCardMetadata()!\n            let item = MetadataCollectionItem(\n                id: id,\n                uuid: nft.uuid,\n                name: metadata.name,\n                description: metadata.description,\n                image: metadata.imageUrl,\n                url: \"https://motogp-ignition.com/nft/card/\".concat(id.toString()).concat(\"?owner=\").concat(address.toString()),\n                contentType: \"image\",\n                rarity: \"\",\n                minter: \"\",\n                type: nft.getType(),\n                collection:mc\n            )\n            items.append(item)\n        }\n    }\n\n    let gaiaCollection = account.getCapability\u003c\u0026{Gaia.CollectionPublic}\u003e(Gaia.CollectionPublicPath)\n    if gaiaCollection.check() {\n\n        let gaiaNfts = gaiaCollection.borrow()!\n\n        let mc= MetadataCollection(path: Gaia.CollectionPublicPath, type: gaiaNfts.getType() , conformance: \"Gaia.CollectionPublic\", domainUrl: \"http://ongaia.com\", category: \"Gaia\", legacyIdentifierPrefix: \"Gaia\", transferable:true)\n        for id in gaiaNfts.getIDs() {\n            let nft = gaiaNfts.borrowGaiaNFT(id: id)!\n            let metadata = Gaia.getTemplateMetaData(templateID: nft.data.templateID)!\n\n\n            var url=\"\"\n            let metadataId=metadata[\"id\"]\n            var name=metadata[\"title\"]!\n            if metadataId != nil {\n                url=\"http://ongaia.com/ballerz/\".concat(metadataId!)\n            }\n            //For ballerz we can do this...\n\n            if let seriesFullName=metadata[\"series\"] {\n                if seriesFullName==\"Shareef O\\u{2019}Neal - Basketball\" {\n                    //If the series is basketball with shareef we can do this\n                    url=\"http://ongaia.com/sharef/\".concat(id.toString())\n                    name=metadata[\"title\"]!.concat(\" #\").concat(nft.data.mintNumber.toString())\n                }else if seriesFullName==\"Bryson DeChambeau - Vegas, Baby!\" {\n                    //For golf there is yet another way\n                    url=\"http://ongaia.com/bryson/\".concat(nft.data.mintNumber.toString())\n                    name=metadata[\"title\"]!.concat(\" #\").concat(nft.data.mintNumber.toString())\n                }\n            }\n\n            let item = MetadataCollectionItem(\n                id: id,\n                uuid: nft.uuid,\n                name: name,\n                description: metadata[\"description\"] ?? \"\",\n                image: metadata[\"img\"]!,\n                url: url,\n                contentType: \"image\",\n                rarity: \"\",\n                minter: \"\",\n                type: nft.getType(),\n                collection:mc\n            )\n            items.append(item)\n        }\n    }\n\n    let jambbCap = account.getCapability\u003c\u0026Moments.Collection{Moments.CollectionPublic}\u003e(Moments.CollectionPublicPath)\n    if jambbCap.check() {\n\n        let nfts = jambbCap.borrow()!\n        let mc= MetadataCollection(path: Moments.CollectionPublicPath, type: nfts.getType() , conformance: \"Moments.CollectionPublic\", domainUrl: \"http://jambb.com\", category: \"Jambb\", legacyIdentifierPrefix: \"Jambb\", transferable:true)\n        for id in nfts.getIDs() {\n            let nft = nfts.borrowMoment(id: id)!\n            let metadata=nft.getMetadata()\n            let item  =MetadataCollectionItem(\n                id: id,\n                uuid: nft.uuid,\n                name: metadata.contentName,\n                description: metadata.contentDescription,\n                image: \"ipfs://\".concat(metadata.videoHash),\n        url: \"https://www.jambb.com/c/moment/\".concat(id.toString()),\n                contentType: \"video\",\n                rarity: \"\",\n                minter: \"\",\n                type: nft.getType(),\n                collection:mc\n            )\n            items.append(item)\n        }\n\n    }\n\n    let voucherCap = account.getCapability\u003c\u0026{Vouchers.CollectionPublic}\u003e(Vouchers.CollectionPublicPath)\n    if voucherCap.check() {\n\n        let jambb = voucherCap.borrow()!\n        let mc= MetadataCollection(path: Vouchers.CollectionPublicPath, type: jambb.getType() , conformance: \"Vouchers.CollectionPublic\", domainUrl: \"http://jambb.com\", category: \"Jambb\", legacyIdentifierPrefix: \"JambbVoucher\", transferable:false)\n        for id in jambb.getIDs() {\n            let nft = jambb.borrowVoucher(id: id)!\n            let metadata=nft.getMetadata()!\n\n            let url=\"https://jambb.com\"\n            let item = MetadataCollectionItem(\n                id: id,\n                uuid: nft.uuid,\n                name: metadata.name,\n                description: metadata.description,\n                image: \"ipfs://\".concat(metadata.mediaHash),\n                url: url,\n                contentType: metadata.mediaType,\n                rarity: \"\",\n                minter: \"\",\n                type:nft.getType(),\n                collection: mc\n            )\n            items.append(item)\n        }\n\n    }\n\n    \n    //:matrixworld\n\n  let sturdyCollectionCap = account.getCapability\u003c\u0026SturdyItems.Collection{SturdyItems.SturdyItemsCollectionPublic}\u003e(SturdyItems.CollectionPublicPath)\n    if sturdyCollectionCap.check() {\n        let sturdyNfts = sturdyCollectionCap.borrow()!\n\n        let mc= MetadataCollection(path: SturdyItems.CollectionPublicPath, type: sturdyNfts.getType() , conformance: \"SturdyItems.SturdyItemsCollectionPublic\", domainUrl: \"http://hoodlumsnft.com.com\", category: \"Hoodlums\", legacyIdentifierPrefix: \"Hoodlums\", transferable:true)\n        for id in sturdyNfts.getIDs() {\n            // the metadata is a JSON stored on IPFS at the address nft.tokenURI\n            let nft = sturdyNfts.borrowSturdyItem(id: id)!\n            // the only thing we can play with is the nft title which is for example:\n            //     - \"HOODLUM#10\"\n            //     - \"HOLIDAY MYSTERY BADGE 2021\"\n            //  - \"EXCALIBUR\"\n            let isHoodlum = nft.tokenTitle.slice(from: 0, upTo: 7) == \"HOODLUM\"\n            if isHoodlum {\n                // the hoodlum id is needed to retrieve the image but is not in the nft\n                let hoodlumId = nft.tokenTitle.slice(from: 8, upTo: nft.tokenTitle.length)\n                let item=MetadataCollectionItem(\n                    id: id,\n                    uuid:nft.uuid,\n                    name: nft.tokenTitle,\n                    description: \"\",\n                    image: \"https://hoodlumsnft.com/_next/image?url=%2Fthumbs%2FsomeHoodlum_\".concat(hoodlumId).concat(\".png\u0026w=1920\u0026q=75\"),\n                    url: \"https://hoodlumsnft.com/\",\n                    contentType:\"image\",\n                    rarity: \"\",\n                    minter:\"\",\n                    type: nft.getType(),\n                    collection: mc\n                )\n                items.append(item)\n            }\n        }\n    }\n\n  let charityCap = account.getCapability\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection)\n    if charityCap.check() {\n        let nfts = charityCap.borrow()!\n        let mc= MetadataCollection(path: /public/findCharityNFTCollection, type: nfts.getType() , conformance: \"CharityNFT.CollectionPublicPath\", domainUrl: \"https://find.xyz/neo-x-flowverse-community-charity-tree\", category: \"Find\", legacyIdentifierPrefix: \"Charity\", transferable:true)\n\n        for id in nfts.getIDs() {\n            let nft = nfts.borrowCharity(id: id)!\n            let metadata = nft.getMetadata()\n            let item=MetadataCollectionItem(\n                id: id,\n                uuid:nft.uuid,\n                name: metadata[\"name\"]!,\n                description: \"\",\n                image: metadata[\"thumbnail\"]!,\n                url: metadata[\"originUrl\"]!,\n                contentType:\"image\",\n                rarity: \"\",\n                minter: \"\",\n                type: nft.getType(),\n                collection:mc\n            )\n\n            items.append(item)\n        }\n    }\n\n  let evolutionCap=account.getCapability\u003c\u0026{Evolution.EvolutionCollectionPublic}\u003e(/public/f4264ac8f3256818_Evolution_Collection)\n    if evolutionCap.check() {\n        let evolution=evolutionCap.borrow()!\n        let nfts = evolution.getIDs()\n\n        let mc= MetadataCollection(path: /public/f4264ac8f3256818_Evolution_Collection, type: nfts.getType() , conformance: \"Evolution.EvolutionCollectionPublic\", domainUrl: \"https://evolution-collect.com\", category: \"Evolution\", legacyIdentifierPrefix: \"Evolution\", transferable:true)\n        for id in nfts{\n            // the metadata is a JSON stored on IPFS at the address nft.tokenURI\n            let nft = evolution.borrowCollectible(id: id)!\n            let metadata = Evolution.getItemMetadata(itemId: nft.data.itemId)!\n            let item=MetadataCollectionItem(\n                id: id,\n                uuid: nft.uuid,\n                name: metadata[\"Title\"]!.concat(\" #\").concat(nft.data.serialNumber.toString()),\n                description: metadata[\"Description\"] ?? \"\",\n                image: \"https://storage.viv3.com/0xf4264ac8f3256818/mv/\".concat(nft.data.itemId.toString()),\n                url: \"https://www.evolution-collect.com/\",\n                contentType:\"video\",\n                rarity: \"\",\n                minter:\"\",\n                type:nft.getType(),\n                collection:mc\n            )\n\n            items.append(item)\n        }\n    }\n\n    /* // fix\n  let geniaceCap = account.getCapability\u003c\u0026GeniaceNFT.Collection{NonFungibleToken.CollectionPublic, GeniaceNFT.GeniaceNFTCollectionPublic}\u003e(GeniaceNFT.CollectionPublicPath)\n    if geniaceCap.check() {\n        let geniace=geniaceCap.borrow()!\n\n        let mc= MetadataCollection(path: GeniaceNFT.CollectionPublic, type: geniace.getType() , conformance: \"NonFungibleToken.CollectionPublic, GeniaceNFT.GeniaceNFTCollectionPublic\", domainUrl: \"https://geniace.com\", category: \"Geniace\", legacyIdentifierPrefix: \"Geniace\", transferable:true)\n        let nfts = geniace.getIDs()\n        for id in nfts{\n            // the metadata is a JSON stored on IPFS at the address nft.tokenURI\n            let nft = geniace.borrowGeniaceNFT(id: id)!\n            let metadata = nft.metadata\n            var rarity=\"\"\n            if metadata.rarity == GeniaceNFT.Rarity.Collectible {\n                rarity=\"Collectible\"\n            }else if metadata.rarity == GeniaceNFT.Rarity.Rare {\n                rarity=\"Rare\"\n            }else if metadata.rarity == GeniaceNFT.Rarity.UltraRare {\n                rarity=\"UltraRare\"\n            }\n\n            let item=MetadataCollectionItem(\n                id: id,\n                uuid: nft.uuid,\n                name: metadata.name,\n                description:metadata.description,\n                image: metadata.imageUrl,\n                url: \"https://www.geniace.com/product/\".concat(id.toString()),\n                contentType: metadata.data[\"mimetype\"]!,\n                rarity: rarity,\n                minter: \"\",\n                type: nft.getType(),\n                collection:mc\n            )\n            items.append(item)\n        }\n    }\n\n// https://flow-view-source.com/mainnet/account/0x6831760534292098/contract/OneFootballCollectible\n    let oneFootballCollectibleCap = account.getCapability\u003c\u0026OneFootballCollectible.Collection{OneFootballCollectible.OneFootballCollectibleCollectionPublic}\u003e(OneFootballCollectible.CollectionPublicPath)\n    if oneFootballCollectibleCap.check() {\n        let nfts = oneFootballCollectibleCap.borrow()!\n\n        let mc= MetadataCollection(path: OneFootballCollectible.ColllectionPublicPath, type: nfts.getType() , conformance: \"OneFootballCollectible.OneFootballCollectibleCollectionPublic\", domainUrl: \"https://xmas.onefootball.com\", category: \"OneFootball\", legacyIdentifierPrefix: \"OneFootballCollectible\", transferable:true)\n        for id in nfts.getIDs() {\n            let nft = nfts.borrowOneFootballCollectible(id: id)!\n            let metadata = nft.getTemplate()!\n            let item=MetadataCollectionItem(\n                id: id,\n                uuid: nft.uuid,\n                name: metadata.name,\n                description:metadata.description,\n                image: \"ipfs://\".concat(metadata.media),\n                url: \"https://xmas.onefootball.com/\".concat(account.address.toString()),\n                contentType: \"video\",\n                rarity: \"\",\n                minter:\"\",\n                type: nft.getType(),\n                collection:mc\n            )\n            items.append(item)\n        }\n    }\n    */\n\n  let cryptoPiggoCap = account.getCapability\u003c\u0026{CryptoPiggo.CryptoPiggoCollectionPublic}\u003e(CryptoPiggo.CollectionPublicPath)\n    if cryptoPiggoCap.check() {\n        let nfts = cryptoPiggoCap.borrow()!\n\n        let mc= MetadataCollection(path: CryptoPiggo.CollectionPublicPath, type: nfts.getType() , conformance: \"CryptoPiggo.CryptoPiggoCollectionPublic\", domainUrl: \"https://rareworx.com/piggo\", category: \"CryptoPiggo\", legacyIdentifierPrefix: \"CryptoPiggo\", transferable:true)\n        for id in nfts.getIDs() {\n            let nft = nfts.borrowItem(id: id)!\n            let item=MetadataCollectionItem(\n                id: id,\n                uuid:nft.uuid,\n                name: \"CryptoPiggo #\".concat(id.toString()),\n                description: \"\",\n                image: \"https://s3.us-west-2.amazonaws.com/crypto-piggo.nft/piggo-\".concat(id.toString()).concat(\".png\"),\n                url: \"https://rareworx.com/piggo/details/\".concat(id.toString()),\n                contentType: \"image\",\n                rarity: \"\",\n                minter:\"\",\n                type: nft.getType(),\n                collection:mc\n            )\n            items.append(item)\n        }\n    }\n\n    //: xtingles\n\n    /*\n    : goats\n    let goatsCap = account.getCapability\u003c\u0026{GoatedGoatsVouchers.GoatsVoucherCollectionPublic}\u003e(GoatedGoatsVouchers.CollectionPublicPath)\n    if goatsCap.check() {\n        let goatsImageUrl= GoatedGoatsVouchers.getCollectionMetadata()[\"mediaURL\"]!\n        let nfts = goatsCap.borrow()!\n        let mc= MetadataCollection(path: GoatedGoatsVouchers.CollectionPublicPath, type: nfts.getType() , conformance: \"GoatedGoatsVouchers.GoatsVoucherCollectionPublic\", domainUrl: \"https://goatedgoats.com\", category: \"GoatedGoats\", legacyIdentifierPrefix: \"GoatedGoatsVouchers\", transferable:false)\n        for id in nfts.getIDs() {\n            let item=MetadataCollectionItem(\n                id: id,\n                uuid: nft.get\n                name: \"Goated Goat Base Goat Voucher #\".concat(id.toString()),\n                image: goatsImageUrl, \n                url: \"https://goatedgoats.com/\",\n                contentType: \"image\",\n                rarity: \"\"\n\n            )\n            items.append(item)\n        }\n    }\n  \n    let goatsTraitCap = account.getCapability\u003c\u0026{TraitPacksVouchers.PackVoucherCollectionPublic}\u003e(TraitPacksVouchers.CollectionPublicPath)\n    if goatsTraitCap.check() {\n        let goatsImageUrl= TraitPacksVouchers.getCollectionMetadata()[\"mediaURL\"]!\n        let collection = goatsTraitCap.borrow()!\n        for id in collection.getIDs() {\n            let item=MetadataCollectionItem(\n                id: id,\n                name: \"Goated Goat Trait Pack Voucher #\".concat(id.toString()),\n                image: goatsImageUrl, \n                url: \"https://goatedgoats.com/\",\n                listPrice: nil,\n                listToken: nil,\n                contentType: \"image\",\n                rarity: \"\"\n\n            )\n            let itemId=\"GoatedGoatsTraitVoucher\".concat(id.toString())\n            goats.append(itemId)\n            resultMap[itemId] = item\n        }\n    }\n    */\n\n\n    /* // fix\n  let bitkuCap = account.getCapability\u003c\u0026{HaikuNFT.HaikuCollectionPublic}\u003e(HaikuNFT.HaikuCollectionPublicPath)\n    if bitkuCap.check() {\n        let nfts = bitkuCap.borrow()!\n\n        let mc= MetadataCollection(path: HaikuNFT.CollectionPublicPath, type: nfts.getType() , conformance: \"HaikuNFT.HaikuCollectionPublic\", domainUrl: \"https://bitku.art\", category: \"Bitku\", legacyIdentifierPrefix: \"Bitku\", transferable:true)\n        for id in nfts.getIDs() {\n            let nft = nfts.borrowHaiku(id: id)!\n            let item = MetadataCollectionItem(\n                id: id,\n                uuid:nft.uuid,\n                name: \"Bitku #\".concat(id.toString()),\n                description:\"\",\n                image: nft.text,\n                url: \"https://bitku.art/#\".concat(address.toString()).concat(\"/\").concat(id.toString()),\n                contentType: \"text\",\n                rarity: \"\",\n                minter:\"\",\n                type:nft.getType(),\n                collection:mc\n            )\n\n            items.append(item)\n        }\n    }\n\n    */\n    let klktnCap = account.getCapability\u003c\u0026{KlktnNFT.KlktnNFTCollectionPublic}\u003e(KlktnNFT.CollectionPublicPath)\n    if klktnCap.check() {\n        let nfts = klktnCap.borrow()!\n\n        let mc= MetadataCollection(path: KlktnNFT.CollectionPublicPath, type: nfts.getType() , conformance: \"KlktnNFT.KlktnNFTCollectionPublic\", domainUrl: \"https://klktn.com\", category: \"KLKTN\", legacyIdentifierPrefix: \"KLKTN\", transferable:true)\n        for id in nfts.getIDs() {\n            let nft = nfts.borrowKlktnNFT(id: id)!\n\n            let metadata=nft.getNFTMetadata()\n            /*\n\n            Result: {\"uri\": \"ipfs://bafybeifsiousmtmcruuelgyiku3xa5hmw7ylsyqfdvpjsea7r4xa74bhym\", \"name\": \"Kevin Woo - What is KLKTN?\", \"mimeType\": \"video/mp4\", \"media\": \"https://ipfs.io/ipfs/bafybeifsiousmtmcruuelgyiku3xa5hmw7ylsyqfdvpjsea7r4xa74bhym/fb91ad34d61dde04f02ad240f0ca924902d8b4a3da25daaf0bb1ed769977848c.mp4\", \"description\": \"K-pop sensation Kevin Woo has partnered up with KLKTN to enhance his artist to fan interactions and experiences within his fandom. Join our chat to learn more: https://discord.gg/UJxb4erfUw\"}\n\n            */\n            let item = MetadataCollectionItem(\n                id: id,\n                uuid:nft.uuid,\n                name: metadata[\"name\"]!,\n                description: metadata[\"description\"]!,\n                image: metadata[\"media\"]!,\n                url: \"https://klktn.com/\",\n                contentType: \"video\", //metadata[\"mimeType\"]!,\n                rarity: \"\",\n                minter:\"\",\n                type:nft.getType(),\n                collection:mc\n            )\n            items.append(item)\n        }\n    }\n\n    let mynftCap = account.getCapability\u003c\u0026{Mynft.MynftCollectionPublic}\u003e(Mynft.CollectionPublicPath)\n    if mynftCap.check() {\n        let nfts = mynftCap.borrow()!\n\n        let mc= MetadataCollection(path: Mynft.CollectionPublicPath, type: nfts.getType() , conformance: \"Mynft.MynftCollectionPublic\", domainUrl: \"https://mynft.io\", category: \"mynft\", legacyIdentifierPrefix: \"mynft\", transferable:true)\n        for id in nfts.getIDs() {\n            let nft = nfts.borrowArt(id: id)!\n            let metadata=nft.metadata\n\n            var image= metadata.ipfsLink\n            if image == \"\" {\n                image=\"https://arweave.net/\".concat(metadata.arLink)\n            }\n            let item = MetadataCollectionItem(\n                id: id,\n                uuid:nft.uuid,\n                name: metadata.name,\n                description:metadata.description,\n                image: image,\n                url: \"http://mynft.io\",\n                contentType: metadata.type,\n                rarity: \"\",\n                minter:\"\",\n                type:nft.getType(),\n                collection:mc\n            )\n            items.append(item)\n        }\n    }\n\n    /*\n    : add when url fixed\n    let beamCap = account.getCapability\u003c\u0026{Beam.BeamCollectionPublic}\u003e(Beam.CollectionPublicPath)\n        if beamCap.check() {\n        let nfts = beamCap.borrow()!\n\n        let mc= MetadataCollection(path: Beam.CollectionPublicPath, type: nfts.getType() , conformance: \"Beam.BeamCollectionPublic\", domainUrl: \"https://https://frightclub.niftory.com\", category: \"FrightClub\", legacyIdentifierPrefix: \"FrightClub\", transferable:true)\n        for id in nfts.getIDs() {\n            let nft = nfts.borrowCollectible(id: id)!\n\n        let metadata = Beam.getCollectibleItemMetaData(collectibleItemID: nft.data.collectibleItemID)!\n          var mediaUrl: String? = metadata[\"mediaUrl\"]\n            if mediaUrl != nil \u0026\u0026  mediaUrl!.slice(from: 0, upTo: 7) != \"ipfs://\" {\n                mediaUrl = \"ipfs://\".concat(mediaUrl!)\n            }\n            let item = MetadataCollectionItem(\n                id: id,\n                uuid:nft.uuid,\n                name: metadata[\"title\"]!,\n                description: metadata[\"description\"] ?? \"\",\n                image: mediaUrl ?? \"\",\n                url: \"https://\".concat(metadata[\"domainUrl\"]!),\n                contentType: metadata[\"mediaType\"]!,\n                rarity: \"\",\n                minter:\"\",\n                type:nft.getType(),\n                collection:mc\n            )\n            items.append(item)\n        }\n    }\n    */\n\n    collection.addCollection(items: items)\n\n    //Adding a collection that supports the metadata standard is SOOO much easier\n    collection.addMetadataCollection(path: NeoAvatar.CollectionPublicPath, account: account, category: \"Neo\", legacyIdentifierPrefix: \"NeoAvatar\", url: \"https://neocollectibles.xyz\", transferable: true)\n\n    if collection.collections.length==0 {\n        return nil\n    }\n    return collection\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "mainnet_getCollections_old": {
               "code": "import NonFungibleToken from 0x1d7e57aa55817448\nimport CharityNFT from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\n\n//mainnet\nimport Beam from 0x86b4a0010a71cfc3 \nimport Art from 0xd796ff17107bbff6\nimport Marketplace from 0xd796ff17107bbff6\nimport GooberXContract from 0x34f2bf4a80bb0f69\nimport Flovatar from 0x921ea449dffec68a\nimport FlovatarMarketplace from  0x921ea449dffec68a\nimport RareRooms_NFT from 0x329feb3ab062d289\nimport CNN_NFT from 0x329feb3ab062d289\nimport Canes_Vault_NFT from 0x329feb3ab062d289\nimport DGD_NFT from 0x329feb3ab062d289\nimport RaceDay_NFT from 0x329feb3ab062d289\nimport The_Next_Cartel_NFT from 0x329feb3ab062d289\nimport UFC_NFT from 0x329feb3ab062d289\nimport MotoGPCard from 0xa49cc0ee46c54bfb\nimport Gaia from 0x8b148183c28ff88f\nimport ChainmonstersRewards from 0x93615d25d14fa337\nimport Moments from 0xd4ad4740ee426334\nimport MatrixWorldFlowFestNFT from 0x2d2750f240198f91\nimport MatrixWorldAssetsNFT from 0xf20df769e658c257\n\nimport SturdyItems from 0x427ceada271aa0b1\nimport Evolution from 0xf4264ac8f3256818\nimport GeniaceNFT from 0xabda6627c70c7f52\nimport OneFootballCollectible from 0x6831760534292098\nimport CryptoPiggo from 0xd3df824bf81910a4\nimport GoatedGoatsVouchers from 0xdfc74d9d561374c0\nimport TraitPacksVouchers from 0xdfc74d9d561374c0\nimport GoatedGoats from 0x2068315349bdfce5\nimport GoatedGoatsTrait from 0x2068315349bdfce5\nimport GoatedGoatsTraitPack from 0x2068315349bdfce5\n\nimport HaikuNFT from 0xf61e40c19db2a9e2\nimport KlktnNFT from 0xabd6e80be7e9682c\nimport Mynft from 0xf6fcbef550d97aa5\nimport NeoAvatar from 0xb25138dbf45e5801\nimport NeoVoucher from 0xb25138dbf45e5801\nimport NeoMember from 0xb25138dbf45e5801\nimport NeoViews from 0xb25138dbf45e5801\nimport MetadataViews from 0x1d7e57aa55817448\nimport BarterYardPackNFT from 0xa95b021cf8a30d80\nimport BarterYardClubWerewolf from  0x28abb9f291cadaf2\n\n//Jambb\nimport Vouchers from 0x444f5ea22c6ea12c\n\n//xtingles\nimport Collectible from 0xf5b0eb433389ac3f\n\nimport StarlyCard from 0x5b82f21c0edf76e3\nimport StarlyMetadataViews from 0x5b82f21c0edf76e3\nimport Momentables from 0x9d21537544d9123d\nimport ZeedzINO from 0x62b3063fbe672fc8\nimport PartyMansionDrinksContract from 0x34f2bf4a80bb0f69\n\npub struct MetadataCollections {\n\n    pub let items: {String : MetadataCollectionItem}\n    pub let collections: {String : [String]}\n    pub let curatedCollections: {String : [String]}\n\n    init(items: {String : MetadataCollectionItem}, collections: {String : [String]}, curatedCollections: {String: [String]}) {\n        self.items=items\n        self.collections=collections\n        self.curatedCollections=curatedCollections\n    }\n}\n\n\npub struct MetadataCollection{\n    pub let type: String\n    pub let items: [MetadataCollectionItem]\n\n    init(type:String, items: [MetadataCollectionItem]) {\n        self.type=type\n        self.items=items\n    }\n}\n\n\npub struct MetadataCollectionItem {\n    pub let id:UInt64\n    pub let name: String\n    pub let image: String\n    pub let url: String\n    pub let listPrice: UFix64?\n    pub let listToken: String?\n    pub let contentType:String\n    pub let rarity:String\n\n\n    init(id:UInt64, name:String, image:String, url:String, listPrice: UFix64?, listToken:String?, contentType: String, rarity: String) {\n        self.id=id\n        self.name=name\n        self.url=url\n        self.image=image\n        self.listToken=listToken\n        self.listPrice=listPrice\n        self.contentType=contentType\n        self.rarity=rarity\n    }\n}\n\npub fun main(user: String) : MetadataCollections? {\n\n    let resolvingAddress = FIND.resolve(user)\n    if resolvingAddress == nil {\n        return nil\n    }\n    let address = resolvingAddress!\n    let resultMap : {String : MetadataCollectionItem} = {}\n    let account = getAccount(address)\n    let results : {String :  [String]}={}\n\n    let flovatarList= Flovatar.getFlovatars(address: address)\n    let flovatarMarketDetails = FlovatarMarketplace.getFlovatarSales(address: address)\n    if flovatarList.length \u003e 0 || flovatarMarketDetails.length \u003e 0 {\n        let items: [String] = []\n        for flovatar in flovatarList  {\n            var name = flovatar.name\n            if name == \"\" {\n                name=\"Flovatar #\".concat(flovatar.id.toString())\n            }\n\n            var rarity=\"common\"\n            if flovatar.metadata.legendaryCount \u003e 0 {\n                rarity=\"legendary\"\n            }else if flovatar.metadata.epicCount \u003e 0 {\n                rarity=\"epic\"\n            }else if flovatar.metadata.rareCount \u003e 0 {\n                rarity=\"rare\"\n            }\n\n\n            let item=MetadataCollectionItem(\n                id: flovatar.id, \n                name: name, \n                image: \"https://flovatar.com/api/image/\".concat(flovatar.id.toString()),\n                url: \"https://flovatar.com/flovatars/\".concat(flovatar.id.toString()).concat(\"/\"),\n                listPrice: nil,\n                listToken: nil,\n                contentType: \"image\",\n                rarity: rarity\n            )\n            let itemId=\"Flovatar\".concat(flovatar.id.toString())\n            items.append(itemId)\n            resultMap[itemId] = item\n        }\n\n        for flovatar in flovatarMarketDetails  {\n            var    name=\"Flovatar #\".concat(flovatar.id.toString())\n\n            var rarity=\"common\"\n            if flovatar.metadata.legendaryCount \u003e 0 {\n                rarity=\"legendary\"\n            }else if flovatar.metadata.epicCount \u003e 0 {\n                rarity=\"epic\"\n            }else if flovatar.metadata.rareCount \u003e 0 {\n                rarity=\"rare\"\n            }\n\n\n            let item=MetadataCollectionItem(\n                id: flovatar.id, \n                name: name, \n                image: \"https://flovatar.com/api/image/\".concat(flovatar.id.toString()),\n                url: \"https://flovatar.com/flovatars/\".concat(flovatar.id.toString()).concat(\"/\"),\n                listPrice: flovatar.price,\n                listToken: \"Flow\",\n                contentType: \"image\",\n                rarity: rarity\n            )\n\n            let itemId=\"Flovatar\".concat(flovatar.id.toString())\n            items.append(itemId)\n            resultMap[itemId] = item\n\n        }\n\n        if items.length != 0 {\n            results[\"Flovatar\"] = items\n        }\n    }\n\n    let versusMarketplace = account.getCapability\u003c\u0026{Marketplace.SalePublic}\u003e(Marketplace.CollectionPublicPath)\n    let versusImageUrlPrefix = \"https://res.cloudinary.com/dxra4agvf/image/upload/c_fill,w_600/f_auto/maincache\"\n    let artList = Art.getArt(address: address)\n    if artList.length \u003e 0 || versusMarketplace.check() {\n        let items: [String] = []\n        for art in artList {\n            let item=MetadataCollectionItem(\n                id: art.id, \n                name: art.metadata.name.concat(\" edition \").concat(art.metadata.edition.toString()).concat(\"/\").concat(art.metadata.maxEdition.toString()).concat(\" by \").concat(art.metadata.artist),  \n                image: versusImageUrlPrefix.concat(art.cacheKey), \n                url: \"https://www.versus.auction/piece/\".concat(address.toString()).concat(\"/\").concat(art.id.toString()).concat(\"/\"),\n                listPrice: nil,\n                listToken: nil,\n                contentType: \"image\",\n                rarity: \"\"\n            )\n            let itemId=\"Versus\".concat(art.id.toString())\n            items.append(itemId)\n            resultMap[itemId] = item\n\n        }\n        if versusMarketplace.check() {\n            let versusMarket = versusMarketplace.borrow()!.listSaleItems()\n            for saleItem in versusMarket {\n                let item=MetadataCollectionItem(\n                    id: saleItem.id, \n                    name: saleItem.art.name.concat(\" edition \").concat(saleItem.art.edition.toString()).concat(\"/\").concat(saleItem.art.maxEdition.toString()).concat(\" by \").concat(saleItem.art.artist),\n                    image: versusImageUrlPrefix.concat(saleItem.cacheKey), \n                    url: \"https://www.versus.auction/listing/\".concat(saleItem.id.toString()).concat(\"/\"),\n                    listPrice: saleItem.price,\n                    listToken: \"Flow\",\n                    contentType: \"image\",\n                    rarity: \"\"\n                )\n\n                let itemId=\"Versus\".concat(saleItem.id.toString())\n                items.append(itemId)\n                resultMap[itemId] = item\n            }\n        }\n        if items.length != 0 {\n            results[\"Versus\"]= items\n        }\n    }\n\n\n\n\n    let partyMansion: [String] = []\n    let goobersCap = account.getCapability\u003c\u0026GooberXContract.Collection{NonFungibleToken.CollectionPublic, GooberXContract.GooberCollectionPublic}\u003e(GooberXContract.CollectionPublicPath)\n    if goobersCap.check() {\n        let goobers = goobersCap.borrow()!.listUsersGoobers()\n        for id in goobers.keys {\n            let goober = goobers[id]!\n            let item=MetadataCollectionItem(\n                id: id,\n                name: \"Goober #\".concat(id.toString()),\n                image: goober.uri,\n                url: \"https://partymansion.io/gooberz/\".concat(id.toString()),\n                listPrice: nil,\n                listToken: nil,\n                contentType: \"image\",\n                rarity: \"\"\n            )\n            let itemId=\"Gooberz\".concat(id.toString())\n            partyMansion.append(itemId)\n            resultMap[itemId] = item\n        }\n    }\n\n\n    let partyMansionDrinksCap = account.getCapability\u003c\u0026{PartyMansionDrinksContract.DrinkCollectionPublic}\u003e(PartyMansionDrinksContract.CollectionPublicPath)\n    if partyMansionDrinksCap.check() {\n        let collection = partyMansionDrinksCap.borrow()!\n        for id in collection.getIDs() {\n            let nft = collection.borrowDrink(id: id)!\n            let item = MetadataCollectionItem(\n                id: id,\n                name: nft.data.description,\n                image: \"ipfs://\".concat(nft.imageCID()),\n                url: \"https://partymansion.io\",\n                listPrice: nil,\n                listToken: nil,\n                contentType: \"image\",\n                rarity: PartyMansionDrinksContract.rarityToString(rarity:nft.data.rarity)\n            )\n\n            let itemId=\"PartyMansionDrinks\".concat(id.toString())\n            partyMansion.append(itemId)\n            resultMap[itemId] = item\n        }\n    }\n\n    if partyMansion.length != 0 {\n        results[\"PartyMansion\"] = partyMansion\n    }\n\n    let rareRoomCap = account.getCapability\u003c\u0026RareRooms_NFT.Collection{RareRooms_NFT.RareRooms_NFTCollectionPublic}\u003e(RareRooms_NFT.CollectionPublicPath)\n    if rareRoomCap.check() {\n        let collection = rareRoomCap.borrow()!\n        let items: [String] = []\n        for id in collection.getIDs() {\n            let nft = collection.borrowRareRooms_NFT(id: id)!\n            let metadata = RareRooms_NFT.getSetMetadata(setId: nft.setId)!\n            let item = MetadataCollectionItem(\n                id: id,\n                name: metadata[\"name\"]!,\n                image: metadata[\"preview\"]!,\n                url: \"https://rarerooms.io/tokens/\".concat(id.toString()),\n                listPrice: nil,\n                listToken: nil,\n                contentType: \"image\",\n                rarity: \"\"\n            )\n\n            let itemId=\"RareRooms\".concat(id.toString())\n            items.append(itemId)\n            resultMap[itemId] = item\n        }\n\n        if items.length != 0 {\n            results[\"RareRooms\"] = items\n        }\n    }\n\n    let cnnCap = account.getCapability\u003c\u0026CNN_NFT.Collection{CNN_NFT.CNN_NFTCollectionPublic}\u003e(CNN_NFT.CollectionPublicPath)\n    if cnnCap.check() {\n        let collection = cnnCap.borrow()!\n        let items: [String] = []\n        for id in collection.getIDs() {\n            let nft = collection.borrowCNN_NFT(id: id)!\n            let metadata = CNN_NFT.getSetMetadata(setId: nft.setId)!\n\n            var image= metadata[\"preview\"]!\n            var contentType=\"image\"\n            /*\n            if metadata[\"image_file_type\"]! == \"mp4\" {\n                image=metadata[\"image\"]!\n                contentType=\"video\"\n            }\n            */\n            let item = MetadataCollectionItem(\n                id: id,\n                name: metadata[\"name\"]!,\n                image: image,\n                url: \"http://vault.cnn.com\",\n                listPrice: nil,\n                listToken: nil,\n                contentType: contentType,\n                rarity: \"\"\n            )\n\n            let itemId=\"CNN\".concat(id.toString())\n            items.append(itemId)\n            resultMap[itemId] = item\n        }\n\n        if items.length != 0 {\n            results[\"CNN\"] = items\n        }\n    }\n\n    let canesVaultCap = account.getCapability\u003c\u0026Canes_Vault_NFT.Collection{Canes_Vault_NFT.Canes_Vault_NFTCollectionPublic}\u003e(Canes_Vault_NFT.CollectionPublicPath)\n    if canesVaultCap.check() {\n        let collection = canesVaultCap.borrow()!\n        let items: [String] = []\n        for id in collection.getIDs() {\n            let nft = collection.borrowCanes_Vault_NFT(id: id)!\n            let metadata = Canes_Vault_NFT.getSetMetadata(setId: nft.setId)!\n            var image= metadata[\"preview\"]!\n            var contentType=\"image\"\n            /*\n            if metadata[\"image_file_type\"]! == \"mp4\" {\n                image=metadata[\"image\"]!\n                contentType=\"video\"\n            }\n            */\n\n            let item = MetadataCollectionItem(\n                id: id,\n                name: metadata[\"name\"]!,\n                image: image,\n                url: \"https://canesvault.com/\",\n                listPrice: nil,\n                listToken: nil,\n                contentType: contentType,\n                rarity: \"\"\n            )\n\n            let itemId=\"Canes_Vault_NFT\".concat(id.toString())\n            items.append(itemId)\n            resultMap[itemId] = item\n        }\n\n        if items.length != 0 {\n            results[\"Canes_Vault_NFT\"] = items\n        }\n    }\n\n    let dgdCap = account.getCapability\u003c\u0026DGD_NFT.Collection{DGD_NFT.DGD_NFTCollectionPublic}\u003e(DGD_NFT.CollectionPublicPath)\n    if dgdCap.check() {\n        let collection = dgdCap.borrow()!\n        let items: [String] = []\n        for id in collection.getIDs() {\n            let nft = collection.borrowDGD_NFT(id: id)!\n            let metadata = DGD_NFT.getSetMetadata(setId: nft.setId)!\n            var image= metadata[\"preview\"]!\n            var contentType=\"image\"\n            /*\n            if metadata[\"image_file_type\"]! == \"mp4\" {\n                image=metadata[\"image\"]!\n                contentType=\"video\"\n            }\n            */\n\n\n            let item = MetadataCollectionItem(\n                id: id,\n                name: metadata[\"name\"]!,\n                image: image,\n                url: \"https://www.theplayerslounge.io/\",\n                listPrice: nil,\n                listToken: nil,\n                contentType: contentType,\n                rarity: \"\"\n            )\n\n            let itemId=\"DGD_NFT\".concat(id.toString())\n            items.append(itemId)\n            resultMap[itemId] = item\n        }\n\n        if items.length != 0 {\n            results[\"DGD_NFT\"] = items\n        }\n    }\n\n    let raceDayCap = account.getCapability\u003c\u0026RaceDay_NFT.Collection{RaceDay_NFT.RaceDay_NFTCollectionPublic}\u003e(RaceDay_NFT.CollectionPublicPath)\n    if raceDayCap.check() {\n        let collection = raceDayCap.borrow()!\n        let items: [String] = []\n        for id in collection.getIDs() {\n            let nft = collection.borrowRaceDay_NFT(id: id)!\n            let metadata = RaceDay_NFT.getSetMetadata(setId: nft.setId)!\n            var image= metadata[\"preview\"]!\n            var contentType=\"image\"\n            /*\n            if metadata[\"image_file_type\"]! == \"mp4\" {\n                image=metadata[\"image\"]!\n                contentType=\"video\"\n            }\n            */\n\n\n            let item = MetadataCollectionItem(\n                id: id,\n                name: metadata[\"name\"]!,\n                image: image, \n                url: \"https://www.racedaynft.com\",\n                listPrice: nil,\n                listToken: nil,\n                contentType: contentType,\n                rarity: \"\"\n            )\n\n            let itemId=\"RaceDay_NFT\".concat(id.toString())\n            items.append(itemId)\n            resultMap[itemId] = item\n        }\n\n        if items.length != 0 {\n            results[\"RaceDay_NFT\"] = items\n        }\n    }\n\n    let nextCartelCap = account.getCapability\u003c\u0026The_Next_Cartel_NFT.Collection{The_Next_Cartel_NFT.The_Next_Cartel_NFTCollectionPublic}\u003e(The_Next_Cartel_NFT.CollectionPublicPath)\n    if nextCartelCap.check() {\n        let collection = nextCartelCap.borrow()!\n        let items: [String] = []\n        for id in collection.getIDs() {\n            let nft = collection.borrowThe_Next_Cartel_NFT(id: id)!\n            let metadata = The_Next_Cartel_NFT.getSetMetadata(setId: nft.setId)!\n            var image= metadata[\"preview\"]!\n            var contentType=\"image\"\n            let item = MetadataCollectionItem(\n                id: id,\n                name: metadata[\"name\"]!,\n                // we use \"preview\" and not \"image\" because of potential .glg and .mp4 file types\n                image: image,\n                url: \"https://thenextcartel.com/\",\n                listPrice: nil,\n                listToken: nil,\n                contentType: contentType,\n                rarity: \"\"\n            )\n\n            let itemId=\"The_Next_Cartel_NFT\".concat(id.toString())\n            items.append(itemId)\n            resultMap[itemId] = item\n        }\n\n        if items.length != 0 {\n            results[\"The_Next_Cartel_NFT\"] = items\n        }\n    }\n\n    let ufcCap = account.getCapability\u003c\u0026UFC_NFT.Collection{UFC_NFT.UFC_NFTCollectionPublic}\u003e(UFC_NFT.CollectionPublicPath)\n    if ufcCap.check() {\n        let collection = ufcCap.borrow()!\n        let items: [String] = []\n        for id in collection.getIDs() {\n            let nft = collection.borrowUFC_NFT(id: id)!\n            let metadata = UFC_NFT.getSetMetadata(setId: nft.setId)!\n            var image= metadata[\"image\"]!\n            var contentType=\"video\"\n            let item = MetadataCollectionItem(\n                id: id,\n                name: metadata[\"name\"]!,\n                image: image,\n                url: \"https://www.ufcstrike.com\",\n                listPrice: nil,\n                listToken: nil,\n                contentType: contentType,\n                rarity: \"\"\n            )\n\n            let itemId=\"UFC\".concat(id.toString())\n            items.append(itemId)\n            resultMap[itemId] = item\n        }\n\n        if items.length != 0 {\n            results[\"UFC\"] = items\n        }\n    }\n\n    let motoGPCollection = account.getCapability\u003c\u0026MotoGPCard.Collection{MotoGPCard.ICardCollectionPublic}\u003e(/public/motogpCardCollection)\n    if motoGPCollection.check() {\n        let motoGPNfts = motoGPCollection.borrow()!.getIDs()\n        let items: [String] = []\n        for id in motoGPNfts {\n            let nft = motoGPCollection.borrow()!.borrowCard(id: id)!\n            let metadata = nft.getCardMetadata()!\n            let item=MetadataCollectionItem(\n                id: id,\n                name: metadata.name,\n                image: metadata.imageUrl,\n                url: \"https://motogp-ignition.com/nft/card/\".concat(id.toString()).concat(\"?owner=\").concat(address.toString()),\n                listPrice: nil,\n                listToken: nil,\n                contentType: \"image\",\n                rarity: \"\"\n            )\n\n\n            let itemId=\"MotoGP\".concat(id.toString())\n            items.append(itemId)\n            resultMap[itemId] = item\n        }\n\n        if items.length != 0 {\n            results[\"MotoGP\"] = items\n        }\n    }\n\n    let gaiaCollection = account.getCapability\u003c\u0026{Gaia.CollectionPublic}\u003e(Gaia.CollectionPublicPath)\n    if gaiaCollection.check() {\n\n        let gaiaNfts = gaiaCollection.borrow()!.getIDs()\n        let items: [String] = []\n        for id in gaiaNfts {\n            let nft = gaiaCollection.borrow()!.borrowGaiaNFT(id: id)!\n            let metadata = Gaia.getTemplateMetaData(templateID: nft.data.templateID)!\n\n            //For ballerz we can do this...\n            var url=\"http://ongaia.com/ballerz/\".concat(metadata[\"id\"]!)\n            var name=metadata[\"title\"]!\n\n            if let seriesFullName=metadata[\"series\"] {\n\n                if seriesFullName==\"Shareef O\\u{2019}Neal - Basketball\" {\n                    //If the series is basketball with shareef we can do this\n                    url=\"http://ongaia.com/sharef/\".concat(id.toString())\n                    name=metadata[\"title\"]!.concat(\" #\").concat(nft.data.mintNumber.toString())\n                }else if seriesFullName==\"Bryson DeChambeau - Vegas, Baby!\" {\n                    //For golf there is yet another way\n                    url=\"http://ongaia.com/bryson/\".concat(nft.data.mintNumber.toString())\n                    name=metadata[\"title\"]!.concat(\" #\").concat(nft.data.mintNumber.toString())\n                }\n            }\n\n            let item= MetadataCollectionItem(\n                id: id,\n                name: name,\n                image: metadata[\"img\"]!,\n                url: url,\n                listPrice: nil,\n                listToken: nil,\n                contentType: \"image\",\n                rarity: \"\"\n            )\n\n            let itemId=\"Gaia\".concat(id.toString())\n            items.append(itemId)\n            resultMap[itemId] = item\n        }\n\n        if items.length != 0 {\n            results[\"Gaia\"] = items\n        }\n    }\n\n    /*\n    let chamonsterSeasonTable :  {UInt32: String} = {0 : \"kickstarter\", 1 : \"alpha\", 2 : \"genesis\", 4 : \"flowfest2021\" , 3: \"closedbeta\" }\n\n    let chainmonstersRewardsCollection = account.getCapability\u003c\u0026{ChainmonstersRewards.ChainmonstersRewardCollectionPublic}\u003e(/public/ChainmonstersRewardCollection)\n    if chainmonstersRewardsCollection.check() {\n        let nfts = chainmonstersRewardsCollection.borrow()!.getIDs()\n        let items: [MetadataCollectionItem] = []\n        for id in nfts {\n            let nft = chainmonstersRewardsCollection.borrow()!.borrowReward(id: id)!\n            let rewardID = nft.data.rewardID\n            // Other interesting metadata available are:\n            //         - serialNumber: nft.data.serialNumber\n            //         - totalMinted: ChainmonstersRewards.getNumRewardsMinted(rewardID: nft.data.rewardID)!\n            let season = ChainmonstersRewards.getRewardSeason(rewardID:nft.data.rewardID)!\n\n            var seasonName = chamonsterSeasonTable[season] ?? \"unknown\".concat(season.toString())\n\n            if season == 3 \u0026\u0026 rewardID \u003c 45 {\n                seasonName = \"flowfest2021\"\n            }\n            items.append(MetadataCollectionItem(\n                id: id,\n                name: ChainmonstersRewards.getRewardMetaData(rewardID: nft.data.rewardID)!,\n                image: \"https://chainmonsters.com/images/rewards/\".concat(seasonName).concat(\"/\").concat(rewardID.toString()).concat(\".png\"),\n                url: \"https://chainmonsters.com\",\n                listPrice: nil,\n                listToken: nil,\n                contentType: \"image\"\n            ))\n        }\n        if items.length != 0 {\n            results[\"ChainmonstersRewards\"] = MetadataCollection(type: Type\u003c@ChainmonstersRewards.Collection\u003e().identifier, items: items)\n        }\n    }\n    */\n\n    let jambb: [String] = []\n    let jambbCap = account.getCapability\u003c\u0026Moments.Collection{Moments.CollectionPublic}\u003e(Moments.CollectionPublicPath)\n    if jambbCap.check() {\n        let nfts = jambbCap.borrow()!.getIDs()\n        for id in nfts {\n            let nft = jambbCap.borrow()!.borrowMoment(id: id)!\n            let metadata=nft.getMetadata()\n            let item  =MetadataCollectionItem(\n                id: id,\n                name: metadata.contentName,\n                image: \"ipfs://\".concat(metadata.videoHash),\n                url: \"https://www.jambb.com/c/moment/\".concat(id.toString()),\n                listPrice: nil,\n                listToken: nil,\n                contentType: \"video\",\n                rarity: \"\"\n            )\n            let itemId=\"Jambb\".concat(id.toString())\n            jambb.append(itemId)\n            resultMap[itemId] = item\n        }\n    }\n\n    let voucherCap = account.getCapability\u003c\u0026{Vouchers.CollectionPublic}\u003e(Vouchers.CollectionPublicPath)\n    if voucherCap.check() {\n        let collection = voucherCap.borrow()!\n        for id in collection.getIDs() {\n            let nft = collection.borrowVoucher(id: id)!\n            let metadata=nft.getMetadata()!\n\n            let url=\"https://jambb.com\"\n            let item = MetadataCollectionItem(\n                id: id,\n                name: metadata.name,\n                image: \"ipfs://\".concat(metadata.mediaHash),\n                url: url,\n                listPrice: nil,\n                listToken: nil,\n                contentType: metadata.mediaType,\n                rarity: \"\"\n            )\n            let itemId=\"JambbVoucher\".concat(id.toString())\n            jambb.append(itemId)\n            resultMap[itemId] = item\n        }\n\n\n    }\n\n    if jambb.length != 0 {\n        results[\"Jambb\"] = jambb\n    }\n\n    let mw = MatrixWorldFlowFestNFT.getNft(address:address)\n    let mwItems: [String] = []\n    if mw.length \u003e 0 {\n        for nft in mw {\n            let metadata=nft.metadata\n            let item=MetadataCollectionItem(\n                id: nft.id,\n                name: metadata.name,\n                image: metadata.animationUrl,\n                url: \"https://matrixworld.org/\",\n                listPrice: nil,\n                listToken: nil,\n                contentType: \"image\",\n                rarity: \"\"\n            )\n            let itemId=\"MatrixWorldFlowFest\".concat(nft.id.toString())\n            mwItems.append(itemId)\n            resultMap[itemId] = item\n        }\n\n    }\n\n    let matrixworldAsset = account.getCapability\u003c\u0026{MatrixWorldAssetsNFT.Metadata, NonFungibleToken.CollectionPublic}\u003e(MatrixWorldAssetsNFT.collectionPublicPath)\n    if matrixworldAsset.check() {\n        let collection = matrixworldAsset.borrow()!\n        for id in collection.getIDs() {\n            let metadata = collection.getMetadata(id: id)!\n\n\n            /*\n            Result: {\"collection\": \"MW x Flow Holiday Giveaway\", \"description\": \"First Edition Matrix World Santa Hat. Only 50 pieces made.\", \"animation_url\": \"\", \"image\": \"https://d2yoccx42eml7e.cloudfront.net/airdrop/MWxFlowxHoliday/Santa_Hat.png\", \"name\": \"First Edition Santa Hat\", \"external_url\": \"https://matrixworld.org/home\", \"version\": \"assets-v0.1.1\", \"attributes\": \"\"}\n            */\n            let item = MetadataCollectionItem(\n                id: id,\n                name: metadata[\"name\"]!,\n                image: metadata[\"image\"]!,\n                url: metadata[\"external_url\"]!,\n                listPrice: nil,\n                listToken: nil,\n                contentType: \"image\",\n                rarity: \"\"\n            )\n            let itemId=\"MatrixWorldAsset\".concat(id.toString())\n            mwItems.append(itemId)\n            resultMap[itemId] = item\n        }\n    }\n\n    if mwItems.length != 0 {\n        results[\"MatrixWorld\"] = mwItems\n    }\n\n    let sturdyCollectionCap = account.getCapability\u003c\u0026SturdyItems.Collection{SturdyItems.SturdyItemsCollectionPublic}\u003e(SturdyItems.CollectionPublicPath)\n    if sturdyCollectionCap.check() {\n        let sturdyNfts = sturdyCollectionCap.borrow()!.getIDs()\n        let items: [String] = []\n        for id in sturdyNfts {\n            // the metadata is a JSON stored on IPFS at the address nft.tokenURI\n            let nft = sturdyCollectionCap.borrow()!.borrowSturdyItem(id: id)!\n            // the only thing we can play with is the nft title which is for example:\n            //     - \"HOODLUM#10\"\n            //     - \"HOLIDAY MYSTERY BADGE 2021\"\n            //  - \"EXCALIBUR\"\n            let isHoodlum = nft.tokenTitle.slice(from: 0, upTo: 7) == \"HOODLUM\"\n            if isHoodlum {\n                // the hoodlum id is needed to retrieve the image but is not in the nft\n                let hoodlumId = nft.tokenTitle.slice(from: 8, upTo: nft.tokenTitle.length)\n                let item=MetadataCollectionItem(\n                    id: id,\n                    name: nft.tokenTitle,\n                    image: \"https://hoodlumsnft.com/_next/image?url=%2Fthumbs%2FsomeHoodlum_\".concat(hoodlumId).concat(\".png\u0026w=1920\u0026q=75\"),\n                    url: \"https://hoodlumsnft.com/\",\n                    listPrice:nil,\n                    listToken:nil,\n                    contentType:\"image\",\n                    rarity: \"\"\n                )\n                let itemId=\"Hoodlums\".concat(id.toString())\n                items.append(itemId)\n                resultMap[itemId] = item\n            }\n        }\n        if items.length != 0 {\n            results[\"Hoodlums\"] = items\n        }\n    }\n\n    let charityCap = account.getCapability\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection)\n    if charityCap.check() {\n        let items: [String] = []\n        let collection = charityCap.borrow()!\n        for id in collection.getIDs() {\n            let nft = collection.borrowCharity(id: id)!\n            let metadata = nft.getMetadata()\n            let item=MetadataCollectionItem(\n                id: id,\n                name: metadata[\"name\"]!,\n                image: metadata[\"thumbnail\"]!,\n                url: metadata[\"originUrl\"]!,\n                listPrice: nil,\n                listToken: nil,\n                contentType:\"image\",\n                rarity: \"\"\n            )\n            let itemId=\"Charity\".concat(id.toString())\n            items.append(itemId)\n            resultMap[itemId] = item\n\n        }\n        if items.length != 0 {\n            results[\"Find\"] = items\n        }\n    }\n\n    let evolutionCap=account.getCapability\u003c\u0026{Evolution.EvolutionCollectionPublic}\u003e(/public/f4264ac8f3256818_Evolution_Collection)\n    if evolutionCap.check() {\n        let evolution=evolutionCap.borrow()!\n        let nfts = evolution.getIDs()\n        let items: [String] = []\n        for id in nfts{\n            // the metadata is a JSON stored on IPFS at the address nft.tokenURI\n            let nft = evolution.borrowCollectible(id: id)!\n            let metadata = Evolution.getItemMetadata(itemId: nft.data.itemId)!\n            let item=MetadataCollectionItem(\n                id: id,\n                name: metadata[\"Title\"]!.concat(\" #\").concat(nft.data.serialNumber.toString()),\n                image: \"https://storage.viv3.com/0xf4264ac8f3256818/mv/\".concat(nft.data.itemId.toString()),\n                url: \"https://www.evolution-collect.com/\",\n                listPrice: nil,\n                listToken: nil,\n                contentType:\"video\",\n                rarity: \"\"\n            )\n\n            let itemId=\"Evolution\".concat(id.toString())\n            items.append(itemId)\n            resultMap[itemId] = item\n        }\n\n        if items.length != 0 {\n            results[\"Evolution\"] = items\n        }\n    }\n\n\n    let geniaceCap = account.getCapability\u003c\u0026GeniaceNFT.Collection{NonFungibleToken.CollectionPublic, GeniaceNFT.GeniaceNFTCollectionPublic}\u003e(GeniaceNFT.CollectionPublicPath)\n    if geniaceCap.check() {\n        let geniace=geniaceCap.borrow()!\n        let nfts = geniace.getIDs()\n        let items: [String] = []\n        for id in nfts{\n            // the metadata is a JSON stored on IPFS at the address nft.tokenURI\n            let nft = geniace.borrowGeniaceNFT(id: id)!\n            let metadata = nft.metadata\n            var rarity=\"\"\n            if metadata.rarity == GeniaceNFT.Rarity.Collectible {\n                rarity=\"Collectible\"\n            }else if metadata.rarity == GeniaceNFT.Rarity.Rare {\n                rarity=\"Rare\"\n            }else if metadata.rarity == GeniaceNFT.Rarity.UltraRare {\n                rarity=\"UltraRare\"\n            }\n\n            let item=MetadataCollectionItem(\n                id: id,\n                name: metadata.name,\n                image: metadata.imageUrl,\n                url: \"https://www.geniace.com/product/\".concat(id.toString()),\n                listPrice: nil,\n                listToken: nil,\n                contentType: metadata.data[\"mimetype\"]!,\n                rarity: rarity,\n            )\n\n            let itemId=\"Geniace\".concat(id.toString())\n            items.append(itemId)\n            resultMap[itemId] = item\n        }\n\n        if items.length != 0 {\n            results[\"Geniace\"] = items\n        }\n    }\n\n    // https://flow-view-source.com/mainnet/account/0x6831760534292098/contract/OneFootballCollectible\n    let oneFootballCollectibleCap = account.getCapability\u003c\u0026OneFootballCollectible.Collection{OneFootballCollectible.OneFootballCollectibleCollectionPublic}\u003e(OneFootballCollectible.CollectionPublicPath)\n    if oneFootballCollectibleCap.check() {\n        let items: [String] = []\n        let collection = oneFootballCollectibleCap.borrow()!\n        for id in collection.getIDs() {\n            let nft = collection.borrowOneFootballCollectible(id: id)!\n            let metadata = nft.getTemplate()!\n            let item=MetadataCollectionItem(\n                id: id,\n                name: metadata.name,\n                image: \"ipfs://\".concat(metadata.media),\n                url: \"https://xmas.onefootball.com/\".concat(account.address.toString()),\n                listPrice: nil,\n                listToken: nil,\n                contentType: \"video\",\n                rarity: \"\"\n\n            )\n            let itemId=\"OneFootballCollectible\".concat(id.toString())\n            items.append(itemId)\n            resultMap[itemId] = item\n\n        }\n        if items.length != 0 {\n            results[\"OneFootballCollectible\"] = items\n        }\n    }\n\n\n    let cryptoPiggoCap = account.getCapability\u003c\u0026{CryptoPiggo.CryptoPiggoCollectionPublic}\u003e(CryptoPiggo.CollectionPublicPath)\n    if cryptoPiggoCap.check() {\n        let items: [String] = []\n        let collection = cryptoPiggoCap.borrow()!\n        for id in collection.getIDs() {\n            let nft = collection.borrowItem(id: id)!\n            let item=MetadataCollectionItem(\n                id: id,\n                name: \"CryptoPiggo #\".concat(id.toString()),\n                image: \"https://s3.us-west-2.amazonaws.com/crypto-piggo.nft/piggo-\".concat(id.toString()).concat(\".png\"),\n                url: \"https://rareworx.com/piggo/details/\".concat(id.toString()),\n                listPrice: nil,\n                listToken: nil,\n                contentType: \"image\",\n                rarity: \"\"\n\n            )\n            let itemId=\"CryptoPiggo\".concat(id.toString())\n            items.append(itemId)\n            resultMap[itemId] = item\n\n        }\n        if items.length != 0 {\n            results[\"CryptoPiggo\"] = items\n        }\n    }\n\n    let xtingles = Collectible.getCollectibleDatas(address:address) \n    if xtingles.length \u003e 0 {\n        let items: [String] = []\n        for nft in xtingles {\n\n            var image=nft.metadata.link\n\n            let prefix=\"https://\"\n            if image.slice(from:0, upTo:prefix.length) != prefix {\n                image=\"ipfs://\".concat(image)\n            }\n            let item=MetadataCollectionItem(\n                id: nft.id,\n                name: nft.metadata.name.concat(\" #\").concat(nft.metadata.edition.toString()),\n                image: image,\n                url: \"http://xtingles.com\",\n                listPrice: nil,\n                listToken: nil,\n                contentType: \"video\",\n                rarity: \"\"\n            )\n            let itemId=\"Xtingles\".concat(nft.id.toString())\n            items.append(itemId)\n            resultMap[itemId] = item\n\n\n        }\n        if items.length != 0 {\n            results[\"Xtingles\"] = items\n        }\n    }\n\n    let goatsCap = account.getCapability\u003c\u0026{GoatedGoatsVouchers.GoatsVoucherCollectionPublic}\u003e(GoatedGoatsVouchers.CollectionPublicPath)\n    var goats : [String]=[]\n    if goatsCap.check() {\n        let goatsImageUrl= GoatedGoatsVouchers.getCollectionMetadata()[\"mediaURL\"]!\n        let collection = goatsCap.borrow()!\n        for id in collection.getIDs() {\n            let item=MetadataCollectionItem(\n                id: id,\n                name: \"Goated Goat Base Goat Voucher #\".concat(id.toString()),\n                image: goatsImageUrl, \n                url: \"https://goatedgoats.com/\",\n                listPrice: nil,\n                listToken: nil,\n                contentType: \"image\",\n                rarity: \"\"\n\n            )\n            let itemId=\"GoatedGoatsVoucher\".concat(id.toString())\n            goats.append(itemId)\n            resultMap[itemId] = item\n        }\n    }\n\n\n    let goatsTraitCap = account.getCapability\u003c\u0026{TraitPacksVouchers.PackVoucherCollectionPublic}\u003e(TraitPacksVouchers.CollectionPublicPath)\n    if goatsTraitCap.check() {\n        let goatsImageUrl= TraitPacksVouchers.getCollectionMetadata()[\"mediaURL\"]!\n        let collection = goatsTraitCap.borrow()!\n        for id in collection.getIDs() {\n            let item=MetadataCollectionItem(\n                id: id,\n                name: \"Goated Goat Trait Pack Voucher #\".concat(id.toString()),\n                image: goatsImageUrl, \n                url: \"https://goatedgoats.com/\",\n                listPrice: nil,\n                listToken: nil,\n                contentType: \"image\",\n                rarity: \"\"\n\n            )\n            let itemId=\"GoatedGoatsTraitVoucher\".concat(id.toString())\n            goats.append(itemId)\n            resultMap[itemId] = item\n        }\n    }\n\n\n    let goatedGoats = getItemForMetadataStandard(path: GoatedGoats.CollectionPublicPath, account: account, externalFixedUrl: \"https://goatedgoats.com\")\n    for item in goatedGoats {\n        let itemId=\"GoatedGoats\".concat(item.id.toString())\n        goats.append(itemId)\n        resultMap[itemId] = item\n    }\n\n\n    let goatedGoatsTrait = getItemForMetadataStandard(path: GoatedGoatsTrait.CollectionPublicPath, account: account, externalFixedUrl: \"https://goatedgoats.com\")\n    for item in goatedGoatsTrait {\n        let itemId=\"GoatedGoatsTraits\".concat(item.id.toString())\n        goats.append(itemId)\n        resultMap[itemId] = item\n    }\n\n\n    let goatedGoatsTraitPack = getItemForMetadataStandard(path: GoatedGoatsTraitPack.CollectionPublicPath, account: account, externalFixedUrl: \"https://goatedgoats.com\")\n    for item in goatedGoatsTraitPack {\n        let itemId=\"GoatedGoatsTraitsPack\".concat(item.id.toString())\n        goats.append(itemId)\n        resultMap[itemId] = item\n    }\n\n    if goats.length != 0 {\n        results[\"GoatedGoats\"] = goats\n    }\n\n    let bitkuCap = account.getCapability\u003c\u0026{HaikuNFT.HaikuCollectionPublic}\u003e(HaikuNFT.HaikuCollectionPublicPath)\n    if bitkuCap.check() {\n        let collection = bitkuCap.borrow()!\n        let items: [String] = []\n        for id in collection.getIDs() {\n            let nft = collection.borrowHaiku(id: id)!\n            let item = MetadataCollectionItem(\n                id: id,\n                name: \"Bitku #\".concat(id.toString()),\n                image: nft.text,\n                url: \"https://bitku.art/#\".concat(address.toString()).concat(\"/\").concat(id.toString()),\n                listPrice: nil,\n                listToken: nil,\n                contentType: \"text\",\n                rarity: \"\"\n            )\n\n            let itemId=\"BitKu\".concat(id.toString())\n            items.append(itemId)\n            resultMap[itemId] = item\n        }\n\n        if items.length != 0 {\n            results[\"Bitku\"] = items\n        }\n    }\n    let klktnCap = account.getCapability\u003c\u0026{KlktnNFT.KlktnNFTCollectionPublic}\u003e(KlktnNFT.CollectionPublicPath)\n    if klktnCap.check() {\n        let items: [String] = []\n        let collection = klktnCap.borrow()!\n        for id in collection.getIDs() {\n            let nft = collection.borrowKlktnNFT(id: id)!\n\n            let metadata=nft.getNFTMetadata()\n            /*\n\n            Result: {\"uri\": \"ipfs://bafybeifsiousmtmcruuelgyiku3xa5hmw7ylsyqfdvpjsea7r4xa74bhym\", \"name\": \"Kevin Woo - What is KLKTN?\", \"mimeType\": \"video/mp4\", \"media\": \"https://ipfs.io/ipfs/bafybeifsiousmtmcruuelgyiku3xa5hmw7ylsyqfdvpjsea7r4xa74bhym/fb91ad34d61dde04f02ad240f0ca924902d8b4a3da25daaf0bb1ed769977848c.mp4\", \"description\": \"K-pop sensation Kevin Woo has partnered up with KLKTN to enhance his artist to fan interactions and experiences within his fandom. Join our chat to learn more: https://discord.gg/UJxb4erfUw\"}\n\n            */\n            let item = MetadataCollectionItem(\n                id: id,\n                name: metadata[\"name\"]!,\n                image: metadata[\"media\"]!,\n                url: \"https://klktn.com/\",\n                listPrice: nil,\n                listToken: nil,\n                contentType: \"video\", //metadata[\"mimeType\"]!,\n                rarity: \"\"\n            )\n            let itemId=\"KLKTN\".concat(id.toString())\n            items.append(itemId)\n            resultMap[itemId] = item\n        }\n\n        if items.length != 0 {\n            results[\"KLKTN\"] = items\n        }\n    }\n\n    let mynftCap = account.getCapability\u003c\u0026{Mynft.MynftCollectionPublic}\u003e(Mynft.CollectionPublicPath)\n    if mynftCap.check() {\n        let items: [String] = []\n        let collection = mynftCap.borrow()!\n        for id in collection.getIDs() {\n            let nft = collection.borrowArt(id: id)!\n            let metadata=nft.metadata\n\n            var image= metadata.ipfsLink\n            if image == \"\" {\n                image=\"https://arweave.net/\".concat(metadata.arLink)\n            }\n\n            let item = MetadataCollectionItem(\n                id: id,\n                name: metadata.name,\n                image: image,\n                url: \"http://mynft.io\",\n                listPrice: nil,\n                listToken: nil,\n                contentType: metadata.type,\n                rarity: \"\"\n            )\n            let itemId=\"mynft\".concat(id.toString())\n            items.append(itemId)\n            resultMap[itemId] = item\n        }\n\n\n        if items.length != 0 {\n            results[\"mynft\"] = items\n        }\n    }\n\n    let neoAvatars = getItemForMetadataStandard(path: NeoAvatar.CollectionPublicPath, account: account, externalFixedUrl: \"\")\n    let neoItems: [String] = []\n    for item in neoAvatars {\n        let itemId=\"NeoAvatar\".concat(item.id.toString())\n        neoItems.append(itemId)\n        resultMap[itemId] = item\n    }\n\n    let neoVouchers = getItemForMetadataStandard(path: NeoVoucher.CollectionPublicPath, account: account, externalFixedUrl: \"https://neocollectibles.xyz/member/\".concat(address.toString()))\n    for item in neoVouchers {\n        let itemId=\"NeoVoucher\".concat(item.id.toString())\n        neoItems.append(itemId)\n        resultMap[itemId] = item\n    }\n\n    let neoMembers = getItemForMetadataStandard(path: NeoMember.CollectionPublicPath, account: account, externalFixedUrl: \"https://neocollectibles.xyz/member/\".concat(address.toString()))\n    for item in neoMembers {\n        let itemId=\"NeoMembers\".concat(item.id.toString())\n        neoItems.append(itemId)\n        resultMap[itemId] = item\n    }\n\n    if neoItems.length != 0 {\n        results[\"Neo\"] = neoItems\n    }\n\n    let byc: [String] = []\n    let barterYardCap= account.getCapability\u003c\u0026{BarterYardPackNFT.BarterYardPackNFTCollectionPublic}\u003e(BarterYardPackNFT.CollectionPublicPath)\n    if barterYardCap.check() {\n        let collection = barterYardCap.borrow()!\n        for id in collection.getIDs() {\n            let nft = collection.borrowBarterYardPackNFT(id: id)!\n\n            if let displayView = nft.resolveView(Type\u003cMetadataViews.Display\u003e()) {\n                let display = displayView as! MetadataViews.Display\n                let item = MetadataCollectionItem(\n                    id: id,\n                    name: display.name,\n                    image: display.thumbnail.uri(),\n                    url: \"https://www.barteryard.club\",\n                    listPrice: nil,\n                    listToken: nil,\n                    contentType: \"image\",\n                    rarity: \"\"\n                )\n\n                let itemId=\"BarterYard\".concat(item.id.toString())\n                byc.append(itemId)\n                resultMap[itemId] = item\n            }\n        }\n    }\n    let werewolves = getItemForMetadataStandard(path: BarterYardClubWerewolf.CollectionPublicPath, account: account, externalFixedUrl: \"https://barteryard.club\")\n    for item in werewolves {\n        let itemId=\"BarterYardWerewolf\".concat(item.id.toString())\n        byc.append(itemId)\n        resultMap[itemId] = item\n    }\n\n    if byc.length != 0 {\n        results[\"Barter Yard Club\"] = byc\n    }\n\n\n    let momentablesCap = account.getCapability\u003c\u0026{Momentables.MomentablesCollectionPublic}\u003e(Momentables.CollectionPublicPath)\n    if momentablesCap.check() {\n        let items: [String] = []\n        let collection = momentablesCap.borrow()!\n\n        for id in collection.getIDs() {\n            let nft = collection.borrowMomentables(id: id)!\n            let traits=nft.getTraits()\n            let commonTrait=traits[\"common\"]!\n\n            let item = MetadataCollectionItem(\n                id: id,\n                name: nft.name,\n                image: \"ipfs://\".concat(nft.imageCID),\n                url: \"https://www.cryptopharaohs.world/\",\n                listPrice: nil,\n                listToken: nil,\n                contentType: \"image\",\n                rarity: commonTrait[\"type\"] ?? \"\",\n            )\n            let itemId=\"CryptoPharaohs\".concat(id.toString())\n            items.append(itemId)\n            resultMap[itemId] = item\n        }\n        if items.length != 0 {\n            results[\"CryptoPharaohs\"] = items\n        }\n    }\n\n\n    /*\n    let beamCap = account.getCapability\u003c\u0026{Beam.BeamCollectionPublic}\u003e(Beam.CollectionPublicPath)\n    if beamCap.check() {\n        let items: [String] = []\n        let collection = beamCap.borrow()!\n        for id in collection.getIDs() {\n            let nft = collection.borrowCollectible(id: id)!\n\n            let metadata = Beam.getCollectibleItemMetaData(collectibleItemID: nft.data.collectibleItemID)!\n            var mediaUrl: String? = metadata[\"mediaUrl\"]\n            if mediaUrl != nil \u0026\u0026  mediaUrl!.slice(from: 0, upTo: 7) != \"ipfs://\" {\n            mediaUrl = \"ipfs://\".concat(mediaUrl!)\n        }\n        let item = MetadataCollectionItem(\n            id: id,\n            name: metadata[\"title\"]!,\n            image: mediaUrl ?? \"\",\n            url: \"https://\".concat(metadata[\"domainUrl\"]!),\n            listPrice: nil,\n            listToken: nil,\n            contentType: metadata[\"mediaType\"]!,\n            rarity: \"\"\n        )\n        let itemId=\"FrightClub\".concat(id.toString())\n        items.append(itemId)\n        resultMap[itemId] = item\n    }\n    if items.length != 0 {\n        results[\"Fright Club\"] = items\n    }\n}*/\n\n\n/*\nlet resolverCollectionCap= account.getCapability\u003c\u0026{StarlyCard.StarlyCardCollectionPublic}\u003e(StarlyCard.CollectionPublicPath)\nif resolverCollectionCap.check() {\n    let items: [String] = []\n    let collection = resolverCollectionCap.borrow()!\n    for id in collection.getIDs() {\n        let nft = collection.borrowViewResolver(id: id)!\n\n        if let displayView = nft.resolveView(Type\u003cMetadataViews.Display\u003e()) {\n            let display = displayView as! MetadataViews.Display\n            if let starlyView = nft.resolveView(Type\u003cStarlyMetadataViews.CardEdition\u003e()) {\n                let cardEdition= starlyView as! StarlyMetadataViews.CardEdition\n\n                let item = MetadataCollectionItem(\n                    id: id,\n                    name: display.name,\n                    image: display.thumbnail.uri(),\n                    url:cardEdition.url,\n                    listPrice: nil,\n                    listToken: nil,\n                    contentType: cardEdition.card.mediaType,\n                    rarity: cardEdition.card.rarity\n                )\n                let itemId=\"Starly\".concat(id.toString())\n                items.append(itemId)\n                resultMap[itemId] = item\n            }\n        }\n    }\n    if items.length != 0 {\n        results[\"Starly\"] = items\n    }\n}\n*/\n\nlet zeedzCap = account.getCapability\u003c\u0026{ZeedzINO.ZeedzCollectionPublic}\u003e(ZeedzINO.CollectionPublicPath)\nif zeedzCap.check() {\n    let items: [String] = []\n    let collection = zeedzCap.borrow()!\n    for id in collection.getIDs() {\n        let nft = collection.borrowZeedle(id: id)!\n\n        let item = MetadataCollectionItem(\n            id: id,\n            name: nft.name,\n            image: \"ipfs://\".concat(nft.imageURI),\n            url: \"http://zeedz.io\",\n            listPrice: nil,\n            listToken: nil,\n            contentType: \"image\",\n            rarity: nft.rarity\n        )\n        let itemId=\"zeedz\".concat(id.toString())\n        items.append(itemId)\n        resultMap[itemId] = item\n    }\n\n\n    if items.length != 0 {\n        results[\"Zeedz\"] = items\n    }\n}\nif results.keys.length == 0 {\n    return nil\n}\n\nlet publicPath=/public/FindCuratedCollections\nlet link = account.getCapability\u003c\u0026{String: [String]}\u003e(publicPath)\nvar curatedCollections : {String: [String]} = {}\nif link.check() {\n    let curated = link.borrow()!\n    for curatedKey in curated.keys {\n        curatedCollections[curatedKey] = curated[curatedKey]!\n    }\n}\n\nreturn MetadataCollections(items: resultMap, collections:results, curatedCollections: curatedCollections)\n}\n\n//This uses a view from Neo until we agree on another for ExternalDomainViewUrl\npub fun getItemForMetadataStandard(path: PublicPath, account:PublicAccount, externalFixedUrl: String) : [MetadataCollectionItem] {\n    let items: [MetadataCollectionItem] = []\n    let resolverCollectionCap= account.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(path)\n    if resolverCollectionCap.check() {\n        let collection = resolverCollectionCap.borrow()!\n        for id in collection.getIDs() {\n            let nft = collection.borrowViewResolver(id: id)!\n\n            if let displayView = nft.resolveView(Type\u003cMetadataViews.Display\u003e()) {\n                let display = displayView as! MetadataViews.Display\n                var externalUrl=externalFixedUrl\n                if let externalUrlView = nft.resolveView(Type\u003cNeoViews.ExternalDomainViewUrl\u003e()) {\n                    let url= externalUrlView! as! NeoViews.ExternalDomainViewUrl\n                    externalUrl=url.url\n                }\n\n                let item = MetadataCollectionItem(\n                    id: id,\n                    name: display.name,\n                    image: display.thumbnail.uri(),\n                    url: externalUrl,\n                    listPrice: nil,\n                    listToken: nil,\n                    contentType: \"image\",\n                    rarity: \"\"\n                )\n\n                items.append(item)\n            }\n        }\n    }\n    return items\n\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "mainnet_getFlobits": {
               "code": "import FlovatarComponent from 0x921ea449dffec68a\nimport FlovatarMarketplace from  0x921ea449dffec68a\n\npub struct MetadataCollectionItem {\n    pub let id:UInt64\n    pub let name: String\n    pub let image: String\n    pub let url: String\n    pub let listPrice: UFix64?\n    pub let listToken: String?\n    pub let contentType:String\n    pub let rarity:String\n\n\n    init(id:UInt64, name:String, image:String, url:String, listPrice: UFix64?, listToken:String?, contentType: String, rarity: String) {\n        self.id=id\n        self.name=name\n        self.url=url\n        self.image=image\n        self.listToken=listToken\n        self.listPrice=listPrice\n        self.contentType=contentType\n        self.rarity=rarity\n    }\n}\n\npub fun main(addr: Address) : [MetadataCollectionItem] {\n\n    let flovatarComponents= FlovatarComponent.getComponents(address: addr)\n\n    let templateNumbers : {UInt64: UInt64} = {}\n    let templateData : {UInt64: FlovatarComponent.ComponentData} = {}\n    for flovatar in flovatarComponents {\n\n        let templateId= flovatar.templateId\n        var number:UInt64=1\n        if templateNumbers[templateId] == nil {\n            templateNumbers[templateId] = (1 as UInt64)\n            templateData[templateId]=flovatar\n        } else {\n            templateNumbers[templateId] = templateNumbers[templateId]! + 1\n        }\n    }\n\n\n    let flovatarMarketComponents=FlovatarMarketplace.getFlovatarComponentSales(address:addr)\n\n    for flovatar in flovatarMarketComponents {\n\n        let templateId= flovatar.metadata.templateId\n            var number:UInt64=1\n            if templateNumbers[templateId] == nil {\n                templateNumbers[templateId] = (1 as UInt64)\n                templateData[templateId]=FlovatarComponent.getComponent(address:addr, componentId: flovatar.id)!\n            } else {\n                templateNumbers[templateId] = templateNumbers[templateId]! + 1\n            }\n    }\n\n\n    let flovatarC : [MetadataCollectionItem] = []\n    for templateId in templateData.keys {\n        let template=templateData[templateId]!\n\n\n        var name=template.name\n\n        if templateId == 75 || templateId==74 || templateId == 73 {\n            name=name.concat(\" Booster\")\n        }\n\n        if templateNumbers[templateId]! \u003e 1 {\n            name=name.concat(\" x \").concat(templateNumbers[templateId]!.toString())\n        } \n\n        let item=MetadataCollectionItem(\n            id: template.id, \n            name: name, \n            image: \"https://flovatar.com/api/image/template/\".concat(templateId.toString()),\n            url: \"https://flovatar.com\",\n            listPrice: nil,\n            listToken: nil,\n            contentType: \"image\",\n            rarity: template.rarity\n        )\n\n        flovatarC.append(item)\n    }\n\n    return flovatarC\n\n}",
               "spec": {
                  "order": [
                     "addr"
                  ],
                  "parameters": {
                     "addr": "Address"
                  }
               }
            },
            "mainnet_getNeoAvatar": {
               "code": "import FIND from 0x097bafa4e0b48eef\n\nimport NeoAvatar from 0xb25138dbf45e5801\nimport NeoViews from 0xb25138dbf45e5801\nimport MetadataViews from 0x1d7e57aa55817448\n\npub struct MetadataCollectionItem {\n    pub let id:UInt64\n    pub let name: String\n    pub let image: String\n    pub let url: String\n    pub let listPrice: UFix64?\n    pub let listToken: String?\n    pub let contentType:String\n    pub let rarity:String\n\n\n    init(id:UInt64, name:String, image:String, url:String, listPrice: UFix64?, listToken:String?, contentType: String, rarity: String) {\n        self.id=id\n        self.name=name\n        self.url=url\n        self.image=image\n        self.listToken=listToken\n        self.listPrice=listPrice\n        self.contentType=contentType\n        self.rarity=rarity\n    }\n}\n\npub fun main(user: String) : [MetadataCollectionItem] {\n\n    let resolveAddress = FIND.resolve(user) \n    if resolveAddress == nil {return []}\n    let address = resolveAddress!\n    let account=getAccount(address)\n\n    return getItemForMetadataStandard(path: NeoAvatar.CollectionPublicPath, account:account)\n    /*\n    let items: [MetadataCollectionItem] = []\n    let account=getAccount(address)\n    let neoAvatarCap = account.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(NeoAvatar.CollectionPublicPath)\n    if neoAvatarCap.check() {\n        let collection = neoAvatarCap.borrow()!\n        for id in collection.getIDs() {\n            let nft = collection.borrowViewResolver(id: id)!\n\n            if let displayView = nft.resolveView(Type\u003cMetadataViews.Display\u003e()) {\n                let display = displayView as! MetadataViews.Display\n                if let externalUrlView = nft.resolveView(Type\u003cNeoViews.ExternalDomainViewUrl\u003e()) {\n                    let externalUrl= externalUrlView! as! NeoViews.ExternalDomainViewUrl\n                    let item = MetadataCollectionItem(\n                        id: id,\n                        name: display.name,\n                        image: display.thumbnail.uri(),\n                        url: externalUrl.url,\n                        listPrice: nil,\n                        listToken: nil,\n                        contentType: \"image\",\n                        rarity: \"\"\n                    )\n\n                    items.append(item)\n                }\n            }\n        }\n    }\n    return items\n    */\n\n}\n\npub fun getItemForMetadataStandard(path: PublicPath, account:PublicAccount) : [MetadataCollectionItem] {\n    let items: [MetadataCollectionItem] = []\n    let resolverCollectionCap= account.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(path)\n    if resolverCollectionCap.check() {\n        let collection = resolverCollectionCap.borrow()!\n        for id in collection.getIDs() {\n            let nft = collection.borrowViewResolver(id: id)!\n\n            if let displayView = nft.resolveView(Type\u003cMetadataViews.Display\u003e()) {\n                let display = displayView as! MetadataViews.Display\n                if let externalUrlView = nft.resolveView(Type\u003cNeoViews.ExternalDomainViewUrl\u003e()) {\n                    let externalUrl= externalUrlView! as! NeoViews.ExternalDomainViewUrl\n                    let item = MetadataCollectionItem(\n                        id: id,\n                        name: display.name,\n                        image: display.thumbnail.uri(),\n                        url: externalUrl.url,\n                        listPrice: nil,\n                        listToken: nil,\n                        contentType: \"image\",\n                        rarity: \"\"\n                    )\n\n                    items.append(item)\n                }\n            }\n        }\n    }\n    return items\n\n\n\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "mainnet_getRareroom": {
               "code": "import NonFungibleToken from 0x1d7e57aa55817448\nimport CharityNFT from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\nimport RareRooms_NFT from 0x329feb3ab062d289\n\n\npub fun main(user: String) : {String:String} {\n\n    let resolveAddress = FIND.resolve(user) \n    if resolveAddress == nil {return {}}\n    let address = resolveAddress!\n    let account=getAccount(address)\n    let rareRoomCap = account.getCapability\u003c\u0026RareRooms_NFT.Collection{RareRooms_NFT.RareRooms_NFTCollectionPublic}\u003e(RareRooms_NFT.CollectionPublicPath)\n\n    if rareRoomCap.check() {\n        let collection = rareRoomCap.borrow()!\n        let items: [String] = []\n        for id in collection.getIDs() {\n            let nft = collection.borrowRareRooms_NFT(id: id)!\n            let metadata = RareRooms_NFT.getSetMetadata(setId: nft.setId)!\n            return metadata\n        }\n    }\n    return {}\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "mainnet_getStarly": {
               "code": "import FIND from 0x097bafa4e0b48eef\n\nimport StarlyCard from 0x5b82f21c0edf76e3\nimport StarlyMetadataViews from 0x5b82f21c0edf76e3\nimport MetadataViews from 0x1d7e57aa55817448\n\npub struct MetadataCollectionItem {\n    pub let id:UInt64\n    pub let name: String\n    pub let image: String\n    pub let url: String\n    pub let listPrice: UFix64?\n    pub let listToken: String?\n    pub let contentType:String\n    pub let rarity:String\n\n\n    init(id:UInt64, name:String, image:String, url:String, listPrice: UFix64?, listToken:String?, contentType: String, rarity: String) {\n        self.id=id\n        self.name=name\n        self.url=url\n        self.image=image\n        self.listToken=listToken\n        self.listPrice=listPrice\n        self.contentType=contentType\n        self.rarity=rarity\n    }\n}\n\npub fun main(user: String) : [MetadataCollectionItem] {\n\n    let resolveAddress = FIND.resolve(user) \n    if resolveAddress == nil {return []}\n    let address = resolveAddress!\n    let account=getAccount(address)\n    let items: [MetadataCollectionItem] = []\n    let resolverCollectionCap= account.getCapability\u003c\u0026{StarlyCard.StarlyCardCollectionPublic}\u003e(StarlyCard.CollectionPublicPath)\n    if resolverCollectionCap.check() {\n        let collection = resolverCollectionCap.borrow()!\n        for id in collection.getIDs() {\n            let nft = collection.borrowViewResolver(id: id)!\n\n            if let displayView = nft.resolveView(Type\u003cMetadataViews.Display\u003e()) {\n                let display = displayView as! MetadataViews.Display\n                if let starlyView = nft.resolveView(Type\u003cStarlyMetadataViews.CardEdition\u003e()) {\n                     let cardEdition= starlyView as! StarlyMetadataViews.CardEdition\n\n                    let item = MetadataCollectionItem(\n                        id: id,\n                        name: display.name,\n                        image: display.thumbnail.uri(),\n                        url:cardEdition.url,\n                        listPrice: nil,\n                        listToken: nil,\n                        contentType: \"image\",\n                        rarity: cardEdition.card.rarity\n                    )\n\n                    items.append(item)\n                }\n            }\n        }\n    }\n    return items\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "mainnet_getStoreFrontListings": {
               "code": "import FIND from 0x097bafa4e0b48eef\n\nimport NFTStorefront from 0x4eb8a10cb9f87357\nimport Marketplace from 0xd796ff17107bbff6\nimport Art from 0xd796ff17107bbff6\nimport FlowToken from 0x1654653399040a61\nimport Flovatar from 0x921ea449dffec68a\nimport FlovatarMarketplace from  0x921ea449dffec68a\n\n// This script returns the details for a listing within a storefront\n\npub struct Listing {\n    pub let marketplace : String\n    pub let ftVault: Type\n    pub let price:UFix64\n    pub let nftType: Type\n    pub let nftId: UInt64\n\n    init(marketplace:String, ftVault:Type, price:UFix64, nftType:Type, nftId:UInt64) {\n        self.marketplace=marketplace\n        self.ftVault=ftVault\n        self.price=price\n        self.nftType=nftType\n        self.nftId=nftId\n    }\n}\n\npub fun main(user: String): {UInt64 :[Listing]} {\n\n    let resolveAddress = FIND.resolve(user) \n    if resolveAddress == nil {return {}}\n    let address = resolveAddress!\n    let account=getAccount(address)\n    let storefrontRef = account.getCapability\u003c\u0026NFTStorefront.Storefront{NFTStorefront.StorefrontPublic}\u003e(NFTStorefront.StorefrontPublicPath).borrow()!\n\n    let listings : {UInt64 : [Listing]} = {}\n\n    for id in storefrontRef.getListingIDs() {\n        let listing = storefrontRef.borrowListing(listingResourceID: id)!\n        let details=listing.getDetails()\n        if details.purchased==true {\n            continue\n        }\n        let uuid=listing.borrowNFT()!.uuid\n\n        let item = Listing( \n            marketplace:\"nftstorefront-\".concat(details.storefrontID.toString()),\n            ftVault: details.salePaymentVaultType, \n            price: details.salePrice,\n            nftType:details.nftType,\n            nftId: details.nftID,\n        )\n        let uuidListings= listings[uuid] ?? []\n        uuidListings.append(item)\n        listings[uuid]= uuidListings\n    }\n\n\n    let versusMarketplace = account.getCapability\u003c\u0026{Marketplace.SalePublic}\u003e(Marketplace.CollectionPublicPath)\n    if versusMarketplace.check() {\n\n        let versusMarket = versusMarketplace.borrow()!\n\n        let saleItems = versusMarket.listSaleItems()\n        for saleItem in saleItems {\n\n            let item = Listing( \n                marketplace:\"versus\",\n                ftVault: Type\u003c@FlowToken.Vault\u003e(),\n                price: saleItem.price,\n                nftType:Type\u003c@Art.NFT\u003e(),\n                nftId: saleItem.id\n            )\n\n            let uuid = versusMarket.getUUIDforSaleItem(tokenID: saleItem.id)\n            //let uuid = art.borrowNFT(id:saleItem.id)!.uuid\n            let uuidListings= listings[uuid] ?? []\n            uuidListings.append(item)\n            listings[uuid]= uuidListings\n\n        }\n    }\n\n\n\n    let flovatarCap = account.getCapability\u003c\u0026{FlovatarMarketplace.SalePublic}\u003e(FlovatarMarketplace.CollectionPublicPath)  \n    if flovatarCap.check(){\n        let saleCollection=flovatarCap.borrow()!\n        for id in saleCollection.getFlovatarIDs() {\n            let price = saleCollection.getFlovatarPrice(tokenId: id)!\n            let flovatar = saleCollection.getFlovatar(tokenId: id)!\n\n            let item = Listing( \n                marketplace:\"flovatar\",\n                ftVault: Type\u003c@FlowToken.Vault\u003e(),\n                price: price,\n                nftType:Type\u003c@Flovatar.NFT\u003e(),\n                nftId: id\n            )\n\n            let uuid =  flovatar.uuid\n            //let uuid = art.borrowNFT(id:saleItem.id)!.uuid\n            let uuidListings= listings[uuid] ?? []\n            uuidListings.append(item)\n            listings[uuid]= uuidListings\n        }\n    }\n    return listings\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "resolve": {
               "code": "import FIND from 0x097bafa4e0b48eef\n\npub fun main(input:String) : Address?{\n    return FIND.resolve(input)\n}",
               "spec": {
                  "order": [
                     "input"
                  ],
                  "parameters": {
                     "input": "String"
                  }
               }
            },
            "resolvePartialCollection": {
               "code": "import MetadataViews from 0x1d7e57aa55817448\nimport NFTRegistry from 0x097bafa4e0b48eef\nimport FindViews from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\n\npub struct ViewCollectionPointer {\n    access(self) let cap: Capability\u003c\u0026{MetadataViews.ResolverCollection}\u003e\n    pub let nftInfo: NFTRegistry.NFTInfo\n\n    init(cap: Capability\u003c\u0026{MetadataViews.ResolverCollection}\u003e, aliasOrIdentifier: String) {\n        self.cap=cap\n        self.nftInfo=NFTRegistry.getNFTInfo(aliasOrIdentifier)!\n    }\n\n    pub fun resolveView(_ type: Type, id: UInt64) : AnyStruct? {\n        return self.getViewResolver(id).resolveView(type)\n    }\n\n    pub fun getUUID(_ id: UInt64) :UInt64{\n        return self.getViewResolver(id).uuid\n    }\n\n    pub fun getViews(_ id: UInt64) : [Type]{\n        return self.getViewResolver(id).getViews()\n    }\n\n    pub fun owner() : Address {\n        return self.cap.address\n    }\n\n    pub fun valid(_ id: UInt64) : Bool {\n        if !self.cap.borrow()!.getIDs().contains(id) {\n            return false\n        }\n        return true\n    }\n\n    pub fun getItemType(_ id: UInt64) : Type {\n        return self.getViewResolver(id).getType()\n    }\n\n    pub fun getViewResolver(_ id: UInt64) : \u0026AnyResource{MetadataViews.Resolver} {\n        return self.cap.borrow()!.borrowViewResolver(id: id)\n    }\n\n    pub fun resolveDisplayViews(_ id: UInt64) : MetadataViews.Display {\n        return self.resolveView(Type\u003cMetadataViews.Display\u003e(), id: id)! as! MetadataViews.Display\n    }\n\n    pub fun getName(_ id: UInt64) : String {\n        return self.resolveDisplayViews(id).name\n    }\n\n    pub fun getImage(_ id: UInt64) : String {\n        return self.resolveDisplayViews(id).thumbnail.uri()\n    }\n\n    pub fun getRarityView(_ id: UInt64) : FindViews.Rarity? {\n        return self.resolveView(Type\u003cFindViews.Rarity\u003e(), id:id) as? FindViews.Rarity\n    }\n\n    pub fun getRarity(_ id: UInt64) : String {\n        if let rarity = self.getRarityView(id) {\n            return rarity.rarityName\n        }\n        return \"\"\n    }\n\n    pub fun getExternalUrlView(_ id: UInt64) : MetadataViews.ExternalURL? {\n        return  self.resolveView(Type\u003cMetadataViews.ExternalURL\u003e(), id:id) as? MetadataViews.ExternalURL\n    }\n\n    pub fun getExternalUrl(_ id: UInt64) : String {\n        if let url = self.getExternalUrlView(id) {\n            return url.url\n        }\n        return self.nftInfo.externalFixedUrl\n    }\n\n}\n\npub fun createViewReadPointer(address:Address, aliasOrIdentifier:String) : ViewCollectionPointer {\n    let path= NFTRegistry.getNFTInfo(aliasOrIdentifier)!.publicPath\n    let cap= getAccount(address).getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(path)\n    let pointer= ViewCollectionPointer(cap: cap, aliasOrIdentifier: aliasOrIdentifier)\n    return pointer\n}\n\npub struct MetadataCollectionItem {\n    pub let id:UInt64\n    pub let typeIdentifier: String\n    pub let uuid: UInt64 \n    pub let name: String\n    pub let image: String\n    pub let url: String\n    pub let contentType:String\n    pub let rarity:String\n    //Refine later \n    pub let metadata: {String : String}\n    pub let collection: String \n\n    init(id:UInt64, type: Type, uuid: UInt64, name:String, image:String, url:String, contentType: String, rarity: String, collection: String) {\n        self.id=id\n        self.typeIdentifier = type.identifier\n        self.uuid = uuid\n        self.name=name\n        self.url=url\n        self.image=image\n        self.contentType=contentType\n        self.rarity=rarity\n        self.metadata={}\n        self.collection=collection\n    }\n}\n\npub fun main(user: String, aliasOrIdentifier: [String], ids:[UInt64]) : [MetadataCollectionItem] {\n\n    let resolveAddress = FIND.resolve(user) \n    if resolveAddress == nil {return []}\n    let address = resolveAddress!\n    var pointerMap: {String : ViewCollectionPointer} = {}\n\n    var resultMap : [MetadataCollectionItem] = []\n\n    assert(aliasOrIdentifier.length == ids.length, message: \"The length of alias passed in does not match with that of the IDs.\")\n    var i = 0\n    while i \u003c aliasOrIdentifier.length {\n        let alias = aliasOrIdentifier[i]\n        let id = ids[i]\n        if pointerMap[alias] == nil {\n            pointerMap[alias] = createViewReadPointer(address: address, aliasOrIdentifier: alias)\n        }\n        let pointer = pointerMap[alias]!\n        resultMap.append(MetadataCollectionItem(id: id, \n                                                type: pointer.getItemType(id), \n                                                uuid: pointer.getUUID(id), \n                                                name: pointer.getName(id), \n                                                image: pointer.getImage(id), \n                                                url: pointer.getExternalUrl(id), \n                                                contentType: \"image\", \n                                                rarity: pointer.getRarity(id), \n                                                collection: alias)\n        )\n        i = i + 1\n    }\n    return resultMap\n}",
               "spec": {
                  "order": [
                     "user",
                     "aliasOrIdentifier",
                     "ids"
                  ],
                  "parameters": {
                     "aliasOrIdentifier": "[String]",
                     "ids": "[UInt64]",
                     "user": "String"
                  }
               }
            }
         },
         "transactions": {
            "acceptDirectOfferSoft": {
               "code": "import FindMarketDirectOfferSoft from 0x097bafa4e0b48eef\nimport NonFungibleToken from 0x1d7e57aa55817448\nimport MetadataViews from 0x1d7e57aa55817448\nimport FindViews from 0x097bafa4e0b48eef\nimport NFTRegistry from 0x097bafa4e0b48eef\nimport FindMarket from 0x097bafa4e0b48eef\n\ntransaction(marketplace:Address, id: UInt64) {\n\n\n    prepare(account: AuthAccount) {\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e())\n        let market = account.borrow\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection\u003e(from: storagePath)!\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e())\n        let item = FindMarket.assertOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: id)\n        let nftIdentifier = item.getItemType().identifier\n\n        //If this is nil, there must be something wrong with FIND setup\n        let nft = NFTRegistry.getNFTInfoByTypeIdentifier(nftIdentifier)!\n\n        let providerCap=account.getCapability\u003c\u0026{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e(nft.providerPath)\n        let pointer= FindViews.AuthNFTPointer(cap: providerCap, id: id)\n\n        market.acceptOffer(pointer)\n\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "addCuratedCollection": {
               "code": "transaction(name: String, items: [String]) {\n    prepare(account: AuthAccount) {\n\n        let path=/storage/FindCuratedCollections\n        let publicPath=/public/FindCuratedCollections\n\n        var collections : {String: [String]} = {}\n        if account.borrow\u003c\u0026{String: [String]}\u003e(from:path) != nil {\n             collections=account.load\u003c{String: [String]}\u003e(from:path)!\n        }\n        collections[name] = items\n        account.save(collections, to: path)\n        let link = account.getCapability\u003c\u0026{String: [String]}\u003e(publicPath)\n        if !link.check() {\n            account.link\u003c\u0026{String: [String]}\u003e( publicPath, target: path)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "items"
                  ],
                  "parameters": {
                     "items": "[String]",
                     "name": "String"
                  }
               }
            },
            "adminAddBl0xTestnet": {
               "code": "import Admin from 0x097bafa4e0b48eef\nimport Bl0x from 0xe8124d8428980aa6\nimport FindMarket from 0x097bafa4e0b48eef\nimport FlowToken from 0x1654653399040a61\n\ntransaction(tenant: Address) {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n        \n    }\n    execute{\n\n        self.adminRef.setNFTInfo(\n            alias: \"Bl0x\", \n            type: Type\u003c@Bl0x.NFT\u003e(), \n            icon: \"https://global-uploads.webflow.com/60f008ba9757da0940af288e/626e4af22f80f09e2783df44_blox.jpg\", \n            providerPath: Bl0x.CollectionPrivatePath, \n            publicPath: Bl0x.CollectionPublicPath, \n            storagePath: Bl0x.CollectionStoragePath, \n            allowedFTTypes: nil, \n            address:0xe8124d8428980aa6, externalFixedUrl: \"bl0x-5ccsb92pb-findonflow.vercel.app\")\n\n        let rules = [\n            FindMarket.TenantRule(name:\"Flow\", types:[Type\u003c@FlowToken.Vault\u003e()], ruleType: \"ft\", allow: true),\n            FindMarket.TenantRule(name:\"Neo\", types:[Type\u003c@Bl0x.NFT\u003e()], ruleType: \"nft\", allow: true)\n        ]\n\n        let tenantSaleItem = FindMarket.TenantSaleItem(\n            name: \"FlowBl0x\", \n            cut: nil, \n            rules: rules, \n            status:\"active\"\n        )\n\n        self.adminRef.setMarketOption(tenant: tenant, saleItem: tenantSaleItem)\n        \n    }\n}",
               "spec": {
                  "order": [
                     "tenant"
                  ],
                  "parameters": {
                     "tenant": "Address"
                  }
               }
            },
            "adminMintCharity": {
               "code": "import NonFungibleToken from 0x1d7e57aa55817448\nimport CharityNFT from 0x097bafa4e0b48eef\nimport Admin from 0x097bafa4e0b48eef\n\n//mint an art and add it to a users collection\ntransaction(\n    name: String,\n    image: String,\n    thumbnail: String,\n    originUrl: String,\n    description: String,\n    recipient: Address\n) {\n    let receiverCap: Capability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e\n    let client: \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount) {\n        self.client= account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath)!\n        self.receiverCap= getAccount(recipient).getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath)\n    }\n\n    execute {\n        let metadata = {\"name\" : name, \"image\" : image, \"thumbnail\": thumbnail, \"originUrl\": originUrl, \"description\":description}\n        self.client.mintCharity(metadata: metadata, recipient: self.receiverCap)\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "image",
                     "thumbnail",
                     "originUrl",
                     "description",
                     "recipient"
                  ],
                  "parameters": {
                     "description": "String",
                     "image": "String",
                     "name": "String",
                     "originUrl": "String",
                     "recipient": "Address",
                     "thumbnail": "String"
                  }
               }
            },
            "adminRegisterName": {
               "code": "import FIND from 0x097bafa4e0b48eef\nimport Admin from 0x097bafa4e0b48eef\nimport Profile from 0x097bafa4e0b48eef\n\ntransaction(names: [String], user: Address) {\n\n    prepare(account: AuthAccount) {\n\n        let userAccount=getAccount(user)\n        let profileCap = userAccount.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        let leaseCollectionCap=userAccount.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        let adminClient=account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath)!\n\n        for name in names {\n            adminClient.register(name: name,  profile: profileCap, leases: leaseCollectionCap)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "names",
                     "user"
                  ],
                  "parameters": {
                     "names": "[String]",
                     "user": "Address"
                  }
               }
            },
            "adminRemoveFTInfoByAlias": {
               "code": "import Admin from 0x097bafa4e0b48eef\n\ntransaction(alias: String) {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n        \n    }\n\n    execute{\n\n        self.adminRef.removeFTInfoByAlias(alias)\n\n    }\n}",
               "spec": {
                  "order": [
                     "alias"
                  ],
                  "parameters": {
                     "alias": "String"
                  }
               }
            },
            "adminRemoveFTInfoByTypeIdentifier": {
               "code": "import Admin from 0x097bafa4e0b48eef\n\ntransaction(typeIdentifier: String) {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n        \n    }\n\n    execute{\n\n        self.adminRef.removeFTInfoByTypeIdentifier(typeIdentifier) \n       \n    }\n}",
               "spec": {
                  "order": [
                     "typeIdentifier"
                  ],
                  "parameters": {
                     "typeIdentifier": "String"
                  }
               }
            },
            "adminRemoveNFTInfoByAlias": {
               "code": "import Admin from 0x097bafa4e0b48eef\n\ntransaction(alias: String) {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n        \n    }\n\n    execute{\n\n        self.adminRef.removeNFTInfoByAlias(alias)\n        \n    }\n}",
               "spec": {
                  "order": [
                     "alias"
                  ],
                  "parameters": {
                     "alias": "String"
                  }
               }
            },
            "adminRemoveNFTInfoByTypeIdentifier": {
               "code": "import Admin from 0x097bafa4e0b48eef\n\ntransaction(typeIdentifier: String) {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n        \n    }\n\n    execute{\n\n        self.adminRef.removeNFTInfoByTypeIdentifier(typeIdentifier) \n       \n    }\n}",
               "spec": {
                  "order": [
                     "typeIdentifier"
                  ],
                  "parameters": {
                     "typeIdentifier": "String"
                  }
               }
            },
            "adminSendFUSD": {
               "code": "import FungibleToken from 0xf233dcee88fe0abe\nimport FUSD from 0x3c5959b568896393\n\ntransaction(receiver: Address, amount:UFix64) {\n    prepare(acct: AuthAccount) {\n        let receiver = getAccount(receiver).getCapability\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e(/public/fusdReceiver).borrow() ?? panic(\"Cannot borrow FUSD receiver\")\n\n        let sender = acct.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault)\n            ?? panic(\"Cannot borrow FUSD vault from authAcct storage\")\n\n        receiver.deposit(from: \u003c- sender.withdraw(amount:amount))\n    }\n}",
               "spec": {
                  "order": [
                     "receiver",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "receiver": "Address"
                  }
               }
            },
            "adminSetFTInfo_flow": {
               "code": "import Admin from 0x097bafa4e0b48eef\nimport FlowToken from 0x1654653399040a61\n\ntransaction() {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n    }\n\n    execute{\n        let type: Type = Type\u003c@FlowToken.Vault\u003e()\n        self.adminRef.setFTInfo(alias: \"Flow\", type: type, tag:[\"utility coin\"] , icon: \"https://static.flowscan.org/mainnet/icons/A.1654653399040a61.FlowToken.png\", receiverPath: /public/flowTokenReceiver, balancePath: /public/flowTokenBalance, vaultPath: /storage/flowTokenVault)\n    }\n}",
               "spec": null
            },
            "adminSetFTInfo_fusd": {
               "code": "import Admin from 0x097bafa4e0b48eef\nimport FUSD from 0x3c5959b568896393\n\ntransaction() {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n    }\n\n    execute{\n        let type: Type = Type\u003c@FUSD.Vault\u003e()\n        self.adminRef.setFTInfo(alias: \"FUSD\", type: type, tag:[\"stablecoin\"], icon: \"https://static.flowscan.org/mainnet/icons/A.3c5959b568896393.FUSD.png\", receiverPath: /public/fusdReceiver, balancePath: /public/fusdBalance, vaultPath: /storage/fusdVault)\n    }\n}",
               "spec": null
            },
            "adminSetFTInfo_usdc": {
               "code": "import Admin from 0x097bafa4e0b48eef\nimport FiatToken from 0xb19436aae4d94622\n\ntransaction() {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n    }\n\n    execute{\n        let type: Type = Type\u003c@FiatToken.Vault\u003e()\n        self.adminRef.setFTInfo(alias: \"USDC\", type: type, tag:[\"stablecoin\"] , icon: \"https://static.flowscan.org/mainnet/icons/A.b19436aae4d94622.FiatToken.png\", receiverPath: FiatToken.VaultReceiverPubPath, balancePath: FiatToken.VaultBalancePubPath, vaultPath: FiatToken.VaultStoragePath)\n    }\n}",
               "spec": null
            },
            "adminSetFindCut": {
               "code": "import Admin from 0x097bafa4e0b48eef\n\ntransaction(tenant: Address, cut: UFix64){\n    prepare(account: AuthAccount){\n        let adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n\n        adminRef.setFindCut(tenant: tenant, cut: cut, rules: nil, status: \"active\")\n    }\n}",
               "spec": {
                  "order": [
                     "tenant",
                     "cut"
                  ],
                  "parameters": {
                     "cut": "UFix64",
                     "tenant": "Address"
                  }
               }
            },
            "adminSetNFTInfo_Dandy": {
               "code": "import Admin from 0x097bafa4e0b48eef\nimport Dandy from 0x097bafa4e0b48eef\n\ntransaction() {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n        \n    }\n    execute{\n        let type: Type = Type\u003c@Dandy.NFT\u003e()\n        self.adminRef.setNFTInfo(alias: \"Dandy\", type: type, icon: nil, providerPath: Dandy.CollectionPrivatePath, publicPath: Dandy.CollectionPublicPath, storagePath: Dandy.CollectionStoragePath, allowedFTTypes: nil, address: 0xf8d6e0586b0a20c7, externalFixedUrl: \"find.xyz\")\n\n    }\n}",
               "spec": null
            },
            "adminSetNFTInfo_Neo": {
               "code": "import Admin from 0x097bafa4e0b48eef\nimport NeoVoucher from 0xd6b39e5b5b367aad\n\ntransaction() {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n        \n    }\n    execute{\n\n        self.adminRef.setNFTInfo(alias: \"NeoVoucher\", type: Type\u003c@NeoVoucher.NFT\u003e(), icon: \"https://test.neocollectibles.xyz/pages/images/neo-collectibles-logo.webp\", providerPath: /private/neoVoucherCollection, publicPath: NeoVoucher.CollectionPublicPath, storagePath: NeoVoucher.CollectionStoragePath, allowedFTTypes: nil, address: 0xd6b39e5b5b367aad, externalFixedUrl: \"test.neocollectibles.xyx\")\n\n    }\n}",
               "spec": null
            },
            "adminSetSellDandyForFUSD": {
               "code": "import FindMarket from 0x097bafa4e0b48eef\nimport Admin from 0x097bafa4e0b48eef\nimport FUSD from 0x3c5959b568896393\nimport Dandy from 0x097bafa4e0b48eef\nimport FindMarketSale from 0x097bafa4e0b48eef\nimport FindMarketAuctionEscrow from 0x097bafa4e0b48eef\nimport FindMarketAuctionSoft from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferEscrow from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferSoft from 0x097bafa4e0b48eef\n\n\ntransaction(tenant: Address, market: String){\n    prepare(account: AuthAccount){\n        let adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n\n        var marketType : [Type] = [Type\u003c@FindMarketSale.SaleItem\u003e()]\n        switch market {\n            case \"AuctionEscrow\" :\n                marketType = [Type\u003c@FindMarketAuctionEscrow.SaleItem\u003e()]\n\n            case \"AuctionSoft\" :\n                marketType = [Type\u003c@FindMarketAuctionSoft.SaleItem\u003e()]\n\n            case \"DirectOfferEscrow\" :\n                marketType = [Type\u003c@FindMarketDirectOfferEscrow.SaleItem\u003e()]\n\n            case \"DirectOfferSoft\" :\n                marketType = [Type\u003c@FindMarketDirectOfferSoft.SaleItem\u003e()]\n\n        }\n\n        let saleItem = FindMarket.TenantSaleItem(name:\"FlowDandy\".concat(market), cut: nil, rules:[\n            FindMarket.TenantRule(name:\"Flow\", types:[Type\u003c@FUSD.Vault\u003e()], ruleType: \"ft\", allow: true),\n            FindMarket.TenantRule(name:\"Dandy\", types:[Type\u003c@Dandy.NFT\u003e()], ruleType: \"nft\", allow: true),\n            FindMarket.TenantRule(name: market, types:marketType, ruleType: \"listing\", allow: true)\n            ], \n            status: \"active\"\n        )\n\n        adminRef.setMarketOption(tenant: tenant, saleItem: saleItem)\n    }\n}",
               "spec": {
                  "order": [
                     "tenant",
                     "market"
                  ],
                  "parameters": {
                     "market": "String",
                     "tenant": "Address"
                  }
               }
            },
            "adminSetSellDandyForFlow": {
               "code": "import FindMarket from 0x097bafa4e0b48eef\nimport Admin from 0x097bafa4e0b48eef\nimport FlowToken from 0x1654653399040a61\nimport Dandy from 0x097bafa4e0b48eef\nimport FindMarketSale from 0x097bafa4e0b48eef\nimport FindMarketAuctionEscrow from 0x097bafa4e0b48eef\nimport FindMarketAuctionSoft from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferEscrow from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferSoft from 0x097bafa4e0b48eef\n\n\ntransaction(tenant: Address, market: String){\n    prepare(account: AuthAccount){\n        let adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n\n        var marketType : [Type] = [Type\u003c@FindMarketSale.SaleItem\u003e()]\n        switch market {\n            case \"AuctionEscrow\" :\n                marketType = [Type\u003c@FindMarketAuctionEscrow.SaleItem\u003e()]\n\n            case \"AuctionSoft\" :\n                marketType = [Type\u003c@FindMarketAuctionSoft.SaleItem\u003e()]\n\n            case \"DirectOfferEscrow\" :\n                marketType = [Type\u003c@FindMarketDirectOfferEscrow.SaleItem\u003e()]\n\n            case \"DirectOfferSoft\" :\n                marketType = [Type\u003c@FindMarketDirectOfferSoft.SaleItem\u003e()]\n\n        }\n\n        let saleItem = FindMarket.TenantSaleItem(name:\"FlowDandy\".concat(market), cut: nil, rules:[\n            FindMarket.TenantRule(name:\"Flow\", types:[Type\u003c@FlowToken.Vault\u003e()], ruleType: \"ft\", allow: true),\n            FindMarket.TenantRule(name:\"Dandy\", types:[Type\u003c@Dandy.NFT\u003e()], ruleType: \"nft\", allow: true),\n            FindMarket.TenantRule(name: market, types:marketType, ruleType: \"listing\", allow: true)\n            ], \n            status: \"active\"\n        )\n\n        adminRef.setMarketOption(tenant: tenant, saleItem: saleItem)\n    }\n}",
               "spec": {
                  "order": [
                     "tenant",
                     "market"
                  ],
                  "parameters": {
                     "market": "String",
                     "tenant": "Address"
                  }
               }
            },
            "adminSetSellDandyRules": {
               "code": "import FindMarket from 0x097bafa4e0b48eef\nimport Admin from 0x097bafa4e0b48eef\nimport FlowToken from 0x1654653399040a61\nimport FUSD from 0x3c5959b568896393\nimport Dandy from 0x097bafa4e0b48eef\n\ntransaction(tenant: Address) {\n    prepare(account: AuthAccount){\n        let adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n\n        let fusdDandy = FindMarket.TenantSaleItem(name:\"FUSDDandy\", cut: nil, rules:[\n            FindMarket.TenantRule(name:\"FUSD\", types:[Type\u003c@FUSD.Vault\u003e()], ruleType: \"ft\", allow: true),\n            FindMarket.TenantRule(name:\"Dandy\", types:[ Type\u003c@Dandy.NFT\u003e()], ruleType: \"nft\", allow: true)\n            ], \n            status: \"active\"\n        )\n\n        let flowDandy = FindMarket.TenantSaleItem(name:\"FlowDandy\", cut: nil, rules:[\n            FindMarket.TenantRule(name:\"Flow\", types:[Type\u003c@FlowToken.Vault\u003e()], ruleType: \"ft\", allow: true),\n            FindMarket.TenantRule(name:\"Dandy\", types:[ Type\u003c@Dandy.NFT\u003e()], ruleType: \"nft\", allow: true)\n            ], \n            status: \"active\"\n        )\n\n        adminRef.setMarketOption(tenant: tenant, saleItem: fusdDandy)\n        adminRef.setMarketOption(tenant: tenant, saleItem: flowDandy)\n\n    }\n}",
               "spec": {
                  "order": [
                     "tenant"
                  ],
                  "parameters": {
                     "tenant": "Address"
                  }
               }
            },
            "adminTransferAllFusd": {
               "code": "// Mainnet\nimport FungibleToken from 0xf233dcee88fe0abe\nimport FUSD from 0x3c5959b568896393\n\n// Testnet\n// import FungibleToken from 0x9a0766d93b6608b7\n// import FUSD from 0xe223d8a629e49c68\n\ntransaction(recipient: Address) {\n\n  // The Vault resource that holds the tokens that are being transfered\n  let sentVault: @FungibleToken.Vault\n\n  prepare(signer: AuthAccount) {\n    // Get a reference to the signer's stored vault\n    let vaultRef = signer.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault)\n      ?? panic(\"Could not borrow reference to the owner's Vault!\")\n\n    // Withdraw tokens from the signer's stored vault\n    self.sentVault \u003c- vaultRef.withdraw(amount: vaultRef.balance)\n  }\n\n  execute {\n    // Get the recipient's public account object\n    let recipientAccount = getAccount(recipient)\n\n    // Get a reference to the recipient's Receiver\n    let receiverRef = recipientAccount.getCapability(/public/fusdReceiver)!\n      .borrow\u003c\u0026{FungibleToken.Receiver}\u003e()\n      ?? panic(\"Could not borrow receiver reference to the recipient's Vault\")\n\n    // Deposit the withdrawn tokens in the recipient's receiver\n    receiverRef.deposit(from: \u003c-self.sentVault)\n  }\n}",
               "spec": {
                  "order": [
                     "recipient"
                  ],
                  "parameters": {
                     "recipient": "Address"
                  }
               }
            },
            "alterMarketOption": {
               "code": "import FindMarket from 0x097bafa4e0b48eef\n\ntransaction(marketRule: String , action: String ){\n    prepare(account: AuthAccount){\n        let path = FindMarket.TenantClientStoragePath\n        let tenantRef = account.borrow\u003c\u0026FindMarket.TenantClient\u003e(from: path) ?? panic(\"Cannot borrow Reference.\")\n\n\n        switch action {\n            case \"enable\" :\n                tenantRef.enableMarketOption(marketRule)\n\n            case \"deprecate\" :\n                tenantRef.deprecateMarketOption(marketRule)\n\n            case \"stop\" :\n                tenantRef.stopMarketOption(marketRule)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "marketRule",
                     "action"
                  ],
                  "parameters": {
                     "action": "String",
                     "marketRule": "String"
                  }
               }
            },
            "bidMarketAuctionEscrowed": {
               "code": "import FindMarketAuctionEscrow from 0x097bafa4e0b48eef\nimport FungibleToken from 0xf233dcee88fe0abe\nimport NonFungibleToken from 0x1d7e57aa55817448\nimport MetadataViews from 0x1d7e57aa55817448\nimport FindViews from 0x097bafa4e0b48eef\nimport NFTRegistry from 0x097bafa4e0b48eef\nimport FTRegistry from 0x097bafa4e0b48eef\nimport FindMarket from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\n\ntransaction(marketplace:Address, user: String, id: UInt64, amount: UFix64) {\n\n    let saleItemsCap: Capability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic}\u003e \n    let targetCapability : Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e\n    let walletReference : \u0026FungibleToken.Vault\n    let bidsReference: \u0026FindMarketAuctionEscrow.MarketBidCollection?\n    let balanceBeforeBid: UFix64\n    let pointer: FindViews.ViewReadPointer\n\n    prepare(account: AuthAccount) {\n\n        let resolveAddress = FIND.resolve(user)\n        if resolveAddress == nil {panic(\"The address input is not a valid name nor address. Input : \".concat(user))}\n        let address = resolveAddress!\n\n        self.saleItemsCap= FindMarketAuctionEscrow.getSaleItemCapability(marketplace:marketplace, user:address) ?? panic(\"cannot find sale item cap\")\n\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e())\n        let item = FindMarket.assertOperationValid(tenant: marketplace, address: address, marketOption: marketOption, id: id)\n\n        let nft = NFTRegistry.getNFTInfoByTypeIdentifier(item.getItemType().identifier) ?? panic(\"This NFT is not supported by the Find Market yet \")\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet\")\n    \n        self.targetCapability= account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(nft.publicPath)\n        /* Check for nftCapability */\n        if !self.targetCapability.check() {\n            let cd = item.getNFTCollectionData()\n            // should use account.type here instead\n            if account.borrow\u003c\u0026AnyResource\u003e(from: cd.storagePath) != nil {\n                panic(\"This collection public link is not set up properly.\")\n            }\n            account.save(\u003c- cd.createEmptyCollection(), to: cd.storagePath)\n            account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.publicPath, target: cd.storagePath)\n            account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.providerPath, target: cd.storagePath)\n        }\n        \n        self.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e())!\n\n        self.bidsReference= account.borrow\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection\u003e(from: storagePath)\n        self.balanceBeforeBid=self.walletReference.balance\n        self.pointer= FindViews.createViewReadPointer(address: address, path:nft.publicPath, id: id)\n    }\n\n    pre {\n        self.bidsReference != nil : \"This account does not have a bid collection\"\n        self.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount) \n        self.bidsReference!.bid(item:self.pointer, vault: \u003c- vault, nftCap: self.targetCapability, bidExtraField: {})\n    }\n\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "user",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64",
                     "marketplace": "Address",
                     "user": "String"
                  }
               }
            },
            "bidMarketAuctionSoft": {
               "code": "import FindMarketAuctionSoft from 0x097bafa4e0b48eef\nimport FungibleToken from 0xf233dcee88fe0abe\nimport NonFungibleToken from 0x1d7e57aa55817448\nimport MetadataViews from 0x1d7e57aa55817448\nimport FindViews from 0x097bafa4e0b48eef\nimport FTRegistry from 0x097bafa4e0b48eef\nimport NFTRegistry from 0x097bafa4e0b48eef\nimport FindMarket from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\n\ntransaction(marketplace:Address, user: String, id: UInt64, amount: UFix64) {\n\n    let saleItemsCap: Capability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic}\u003e \n    let targetCapability : Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e\n    let walletReference : \u0026FungibleToken.Vault\n    let bidsReference: \u0026FindMarketAuctionSoft.MarketBidCollection?\n    let balanceBeforeBid: UFix64\n    let pointer: FindViews.ViewReadPointer\n    let ftVaultType: Type\n\n    prepare(account: AuthAccount) {\n\n        let resolveAddress = FIND.resolve(user)\n        if resolveAddress == nil {panic(\"The address input is not a valid name nor address. Input : \".concat(user))}\n        let address = resolveAddress!\n\n        self.saleItemsCap= FindMarketAuctionSoft.getSaleItemCapability(marketplace:marketplace, user:address) ?? panic(\"cannot find sale item cap\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e())\n\n        let item = FindMarket.assertOperationValid(tenant: marketplace, address: address, marketOption: marketOption, id: id)\n\n        let nft = NFTRegistry.getNFTInfoByTypeIdentifier(item.getItemType().identifier) ?? panic(\"This NFT is not supported by the Find Market yet \")\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet\")\n    \n        self.targetCapability= account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(nft.publicPath)\n        /* Check for nftCapability */\n        if !self.targetCapability.check() {\n            let cd = item.getNFTCollectionData()\n            // should use account.type here instead\n            if account.borrow\u003c\u0026AnyResource\u003e(from: cd.storagePath) != nil {\n                panic(\"This collection public link is not set up properly.\")\n            }\n            account.save(\u003c- cd.createEmptyCollection(), to: cd.storagePath)\n            account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.publicPath, target: cd.storagePath)\n            account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.providerPath, target: cd.storagePath)\n        }\n        \n        self.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No FUSD wallet linked for this account\")\n        self.ftVaultType = ft.type\n\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e())\n\n        self.bidsReference= account.borrow\u003c\u0026FindMarketAuctionSoft.MarketBidCollection\u003e(from: storagePath)\n        self.balanceBeforeBid=self.walletReference.balance\n        self.pointer= FindViews.createViewReadPointer(address: address, path:nft.publicPath, id: id)\n    }\n\n    pre {\n        self.bidsReference != nil : \"This account does not have a bid collection\"\n        self.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n    }\n\n    execute {\n        self.bidsReference!.bid(item:self.pointer, amount: amount, vaultType: self.ftVaultType, nftCap: self.targetCapability, bidExtraField: {})\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "user",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64",
                     "marketplace": "Address",
                     "user": "String"
                  }
               }
            },
            "bidMarketDirectOfferEscrowed": {
               "code": "import FindMarket from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferEscrow from 0x097bafa4e0b48eef\nimport FungibleToken from 0xf233dcee88fe0abe\nimport NonFungibleToken from 0x1d7e57aa55817448\nimport MetadataViews from 0x1d7e57aa55817448\nimport FindViews from 0x097bafa4e0b48eef\nimport FTRegistry from 0x097bafa4e0b48eef\nimport NFTRegistry from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\n\ntransaction(marketplace:Address, user: String, nftAliasOrIdentifier: String, id: UInt64, ftAliasOrIdentifier:String, amount: UFix64, validUntil: UFix64?) {\n\n    let targetCapability : Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e\n    let walletReference : \u0026FungibleToken.Vault\n    let bidsReference: \u0026FindMarketDirectOfferEscrow.MarketBidCollection?\n    let balanceBeforeBid: UFix64\n    let pointer: FindViews.ViewReadPointer\n\n    prepare(account: AuthAccount) {\n\n        let resolveAddress = FIND.resolve(user)\n        if resolveAddress == nil {panic(\"The address input is not a valid name nor address. Input : \".concat(user))}\n        let address = resolveAddress!\n\n        let nft = NFTRegistry.getNFTInfo(nftAliasOrIdentifier) ?? panic(\"This NFT is not supported by the Find Market yet\")\n        let ft = FTRegistry.getFTInfo(ftAliasOrIdentifier) ?? panic(\"This FT is not supported by the Find Market yet\")\n        \n        self.targetCapability= account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(nft.publicPath)\n        self.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e())!\n\n        self.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection\u003e(from: storagePath)\n        self.balanceBeforeBid=self.walletReference.balance\n        self.pointer= FindViews.createViewReadPointer(address: address, path:nft.publicPath, id: id)\n\n        /* Check for nftCapability */\n        if !self.targetCapability.check() {\n            let cd = self.pointer.getNFTCollectionData()\n            // should use account.type here instead\n            if account.borrow\u003c\u0026AnyResource\u003e(from: cd.storagePath) != nil {\n                panic(\"This collection public link is not set up properly.\")\n            }\n            account.save(\u003c- cd.createEmptyCollection(), to: cd.storagePath)\n            account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.publicPath, target: cd.storagePath)\n            account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.providerPath, target: cd.storagePath)\n        }\n    }\n\n    pre {\n        self.bidsReference != nil : \"This account does not have a bid collection\"\n        self.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount) \n        self.bidsReference!.bid(item:self.pointer, vault: \u003c- vault, nftCap: self.targetCapability, validUntil: validUntil, saleItemExtraField: {}, bidExtraField: {})\n    }\n\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "user",
                     "nftAliasOrIdentifier",
                     "id",
                     "ftAliasOrIdentifier",
                     "amount",
                     "validUntil"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "ftAliasOrIdentifier": "String",
                     "id": "UInt64",
                     "marketplace": "Address",
                     "nftAliasOrIdentifier": "String",
                     "user": "String",
                     "validUntil": "UFix64?"
                  }
               }
            },
            "bidMarketDirectOfferSoft": {
               "code": "import FindMarketDirectOfferSoft from 0x097bafa4e0b48eef\nimport FindMarket from 0x097bafa4e0b48eef\nimport FungibleToken from 0xf233dcee88fe0abe\nimport NonFungibleToken from 0x1d7e57aa55817448\nimport MetadataViews from 0x1d7e57aa55817448\nimport FindViews from 0x097bafa4e0b48eef\nimport FTRegistry from 0x097bafa4e0b48eef\nimport NFTRegistry from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\n\ntransaction(marketplace:Address, user: String, nftAliasOrIdentifier: String, id: UInt64, ftAliasOrIdentifier:String, amount: UFix64, validUntil: UFix64?) {\n\n    let targetCapability : Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e\n    let walletReference : \u0026FungibleToken.Vault\n    let bidsReference: \u0026FindMarketDirectOfferSoft.MarketBidCollection?\n    let balanceBeforeBid: UFix64\n    let pointer: FindViews.ViewReadPointer\n    let ftVaultType: Type\n\n    prepare(account: AuthAccount) {\n        \n        let resolveAddress = FIND.resolve(user)\n        if resolveAddress == nil {panic(\"The address input is not a valid name nor address. Input : \".concat(user))}\n        let address = resolveAddress!\n\n        let nft = NFTRegistry.getNFTInfo(nftAliasOrIdentifier) ?? panic(\"This NFT is not supported by the Find Market yet\")\n        let ft = FTRegistry.getFTInfo(ftAliasOrIdentifier) ?? panic(\"This FT is not supported by the Find Market yet\")\n\n        self.ftVaultType = ft.type\n\n        self.targetCapability= account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(nft.publicPath)\n        self.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())!\n        self.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection\u003e(from: storagePath)\n        self.balanceBeforeBid=self.walletReference.balance\n        self.pointer= FindViews.createViewReadPointer(address: address, path:nft.publicPath, id: id)\n\n        /* Check for nftCapability */\n        if !self.targetCapability.check() {\n            let cd = self.pointer.getNFTCollectionData()\n            // should use account.type here instead\n            if account.borrow\u003c\u0026AnyResource\u003e(from: cd.storagePath) != nil {\n                panic(\"This collection public link is not set up properly.\")\n            }\n            account.save(\u003c- cd.createEmptyCollection(), to: cd.storagePath)\n            account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.publicPath, target: cd.storagePath)\n            account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.providerPath, target: cd.storagePath)\n        }\n    }\n\n    pre {\n        self.bidsReference != nil : \"This account does not have a bid collection\"\n        self.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n    }\n\n    execute {\n        self.bidsReference!.bid(item:self.pointer, amount: amount, vaultType: self.ftVaultType, nftCap: self.targetCapability, validUntil: validUntil, saleItemExtraField: {}, bidExtraField: {})\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "user",
                     "nftAliasOrIdentifier",
                     "id",
                     "ftAliasOrIdentifier",
                     "amount",
                     "validUntil"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "ftAliasOrIdentifier": "String",
                     "id": "UInt64",
                     "marketplace": "Address",
                     "nftAliasOrIdentifier": "String",
                     "user": "String",
                     "validUntil": "UFix64?"
                  }
               }
            },
            "bidName": {
               "code": "import FungibleToken from 0xf233dcee88fe0abe\nimport FUSD from 0x3c5959b568896393\nimport FiatToken from 0xb19436aae4d94622\nimport FlowToken from 0x1654653399040a61\nimport Profile from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\nimport Dandy from 0x097bafa4e0b48eef\nimport NonFungibleToken from 0x1d7e57aa55817448\nimport MetadataViews from 0x1d7e57aa55817448\nimport FindMarketSale from 0x097bafa4e0b48eef\nimport FindMarket from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferEscrow from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferSoft from 0x097bafa4e0b48eef\nimport FindMarketAuctionEscrow from 0x097bafa4e0b48eef\nimport FindMarketAuctionSoft from 0x097bafa4e0b48eef\n\ntransaction(name: String, amount: UFix64) {\n    prepare(acct: AuthAccount) {\n\n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n        //SYNC with register\n        //Add exising FUSD or create a new one and add it\n        let fusdReceiver = acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n        if !fusdReceiver.check() {\n            let fusd \u003c- FUSD.createEmptyVault()\n            acct.save(\u003c- fusd, to: /storage/fusdVault)\n            acct.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n            acct.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n        }\n\n        let usdcCap = acct.getCapability\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e(FiatToken.VaultReceiverPubPath)\n        if !usdcCap.check() {\n                acct.save( \u003c-FiatToken.createEmptyVault(), to: FiatToken.VaultStoragePath)\n        acct.link\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e( FiatToken.VaultReceiverPubPath, target: FiatToken.VaultStoragePath)\n        acct.link\u003c\u0026FiatToken.Vault{FiatToken.ResourceId}\u003e( FiatToken.VaultUUIDPubPath, target: FiatToken.VaultStoragePath)\n                acct.link\u003c\u0026FiatToken.Vault{FungibleToken.Balance}\u003e( FiatToken.VaultBalancePubPath, target:FiatToken.VaultStoragePath)\n        }\n\n        let leaseCollection = acct.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            acct.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            acct.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = acct.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            acct.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            acct.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let dandyCap= acct.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            acct.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            acct.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            acct.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        var created=false\n        let profileCap = acct.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            acct.save(\u003c-profile, to: Profile.storagePath)\n            acct.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            acct.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=acct.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n        if !profile.hasWallet(\"Flow\") {\n            let flowWallet=Profile.Wallet( name:\"Flow\", receiver:acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:acct.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), names: [\"flow\"])\n    \n            profile.addWallet(flowWallet)\n        }\n        if !profile.hasWallet(\"FUSD\") {\n            profile.addWallet(Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:acct.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), names: [\"fusd\", \"stablecoin\"]))\n        }\n\n        if !profile.hasWallet(\"USDC\") {\n            profile.addWallet(Profile.Wallet( name:\"USDC\", receiver:usdcCap, balance:acct.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(FiatToken.VaultBalancePubPath), accept: Type\u003c@FiatToken.Vault\u003e(), names: [\"usdc\", \"stablecoin\"]))\n        }\n\n         //If find name not set and we have a profile set it.\n        if profile.getFindName() == \"\" {\n            profile.setFindName(name)\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else {\n            profile.emitUpdatedEvent()\n        }\n\n        let receiverCap=acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let tenantCapability= FindMarket.getTenantCapability(FindMarket.getFindTenantAddress())!\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= acct.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            acct.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            acct.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        let doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        let doeSalePublicPath=FindMarket.getPublicPath(doeSaleType, name: tenant.name)\n        let doeSaleStoragePath= FindMarket.getStoragePath(doeSaleType, name:tenant.name)\n        let doeSaleCap= acct.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n        if !doeSaleCap.check() {\n            acct.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n            acct.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n        }\n\n        let doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        let doeBidPublicPath=FindMarket.getPublicPath(doeBidType, name: tenant.name)\n        let doeBidStoragePath= FindMarket.getStoragePath(doeBidType, name:tenant.name)\n        let doeBidCap= acct.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n        if !doeBidCap.check() {\n            acct.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n            acct.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n        }\n\n        /// auctions that escrow ft\n        let aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        let aeSalePublicPath=FindMarket.getPublicPath(aeSaleType, name: tenant.name)\n        let aeSaleStoragePath= FindMarket.getStoragePath(aeSaleType, name:tenant.name)\n        let aeSaleCap= acct.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n        if !aeSaleCap.check() {\n            acct.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n            acct.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n        }\n\n        let dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\n        let dosSalePublicPath=FindMarket.getPublicPath(dosSaleType, name: tenant.name)\n        let dosSaleStoragePath= FindMarket.getStoragePath(dosSaleType, name:tenant.name)\n\n        let dosSaleCap= acct.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n        if !dosSaleCap.check() {\n            acct.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n            acct.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n        }\n\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= acct.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n        if !dosBidCap.check() {\n            acct.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            acct.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n        }\n\n        let aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\n        let aeBidPublicPath=FindMarket.getPublicPath(aeBidType, name: tenant.name)\n        let aeBidStoragePath= FindMarket.getStoragePath(aeBidType, name:tenant.name)\n        let aeBidCap= acct.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n        if !aeBidCap.check() {\n            acct.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n            acct.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n        }\n\n     /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= acct.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            acct.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            acct.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n        }\n\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= acct.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n        if !asBidCap.check() {\n            acct.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            acct.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n        }\n        //SYNC with register\n\n\n        let vaultRef = acct.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault) ?? panic(\"Could not borrow reference to the fusdVault!\")\n        let vault \u003c- vaultRef.withdraw(amount: amount) as! @FUSD.Vault\n        let bids = acct.borrow\u003c\u0026FIND.BidCollection\u003e(from: FIND.BidStoragePath)!\n        bids.bid(name: name, vault: \u003c- vault)\n\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "name": "String"
                  }
               }
            },
            "buyAddon": {
               "code": "import FUSD from 0x3c5959b568896393\nimport FIND from 0x097bafa4e0b48eef\n\n\ntransaction(name: String, addon:String, amount:UFix64) {\n    prepare(account: AuthAccount) {\n\n        let leases= account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n\n        let vaultRef = account.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault) ?? panic(\"Could not borrow reference to the fusdVault!\")\n        let vault \u003c- vaultRef.withdraw(amount: amount) as! @FUSD.Vault\n        leases.buyAddon(name: name, addon: addon, vault: \u003c- vault)\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "addon",
                     "amount"
                  ],
                  "parameters": {
                     "addon": "String",
                     "amount": "UFix64",
                     "name": "String"
                  }
               }
            },
            "buyNFTForSale": {
               "code": "import FindMarket from 0x097bafa4e0b48eef\nimport FindMarketSale from 0x097bafa4e0b48eef\nimport FungibleToken from 0xf233dcee88fe0abe\nimport NonFungibleToken from 0x1d7e57aa55817448\nimport MetadataViews from 0x1d7e57aa55817448\nimport NFTRegistry from 0x097bafa4e0b48eef\nimport FTRegistry from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\n\ntransaction(marketplace:Address, user: String, id: UInt64, amount: UFix64) {\n\n    let targetCapability : Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e\n    let walletReference : \u0026FungibleToken.Vault\n\n    let saleItemsCap: Capability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic}\u003e \n\n    prepare(account: AuthAccount) {\n\n        let resolveAddress = FIND.resolve(user)\n        if resolveAddress == nil {\n            panic(\"The address input is not a valid name nor address. Input : \".concat(user))\n        }\n        let address = resolveAddress!\n        self.saleItemsCap= FindMarketSale.getSaleItemCapability(marketplace: marketplace, user:address) ?? panic(\"cannot find sale item cap\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketSale.SaleItemCollection\u003e())\n\n        let item= FindMarket.assertOperationValid(tenant: marketplace, address: address, marketOption: marketOption, id: id)\n\n        let nft = NFTRegistry.getNFTInfoByTypeIdentifier(item.getItemType().identifier) ?? panic(\"This NFT is not supported by the Find Market yet \")\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet\")\n    \n        self.targetCapability= account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(nft.publicPath)\n        /* Check for nftCapability */\n        if !self.targetCapability.check() {\n            let cd = item.getNFTCollectionData()\n            // should use account.type here instead\n            if account.borrow\u003c\u0026AnyResource\u003e(from: cd.storagePath) != nil {\n                panic(\"This collection public link is not set up properly.\")\n            }\n            account.save(\u003c- cd.createEmptyCollection(), to: cd.storagePath)\n            account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.publicPath, target: cd.storagePath)\n            account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.providerPath, target: cd.storagePath)\n        }\n\n        self.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n    }\n\n    pre {\n        self.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount) \n        self.saleItemsCap.borrow()!.buy(id:id, vault: \u003c- vault, nftCap: self.targetCapability)\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "user",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64",
                     "marketplace": "Address",
                     "user": "String"
                  }
               }
            },
            "cancelMarketAuctionEscrowed": {
               "code": "import FindMarket from 0x097bafa4e0b48eef\nimport FindMarketAuctionEscrow from 0x097bafa4e0b48eef\n\ntransaction(marketplace:Address, ids: [UInt64]) {\n    prepare(account: AuthAccount) {\n\n        let tenant=FindMarket.getTenant(marketplace)\n        let saleItems= account.borrow\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()))!\n        for id in ids {\n            saleItems.cancel(id)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "ids"
                  ],
                  "parameters": {
                     "ids": "[UInt64]",
                     "marketplace": "Address"
                  }
               }
            },
            "cancelMarketAuctionSoft": {
               "code": "import FindMarket from 0x097bafa4e0b48eef\nimport FindMarketAuctionSoft from 0x097bafa4e0b48eef\n\ntransaction(marketplace:Address, ids: [UInt64]) {\n    prepare(account: AuthAccount) {\n        let tenant=FindMarket.getTenant(marketplace)\n        let saleItems= account.borrow\u003c\u0026FindMarketAuctionSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()))!\n        for id in ids {\n            saleItems.cancel(id)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "ids"
                  ],
                  "parameters": {
                     "ids": "[UInt64]",
                     "marketplace": "Address"
                  }
               }
            },
            "cancelMarketDirectOfferEscrowed": {
               "code": "import FindMarket from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferEscrow from 0x097bafa4e0b48eef\n\ntransaction(marketplace:Address, ids: [UInt64]) {\n    prepare(account: AuthAccount) {\n\n        let tenant=FindMarket.getTenant(marketplace)\n        let saleItems= account.borrow\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()))!\n        for id in ids {\n            saleItems.cancel(id)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "ids"
                  ],
                  "parameters": {
                     "ids": "[UInt64]",
                     "marketplace": "Address"
                  }
               }
            },
            "cancelMarketDirectOfferSoft": {
               "code": "import FindMarket from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferSoft from 0x097bafa4e0b48eef\n\ntransaction(marketplace:Address, ids: [UInt64]) {\n    prepare(account: AuthAccount) {\n\n        let tenant=FindMarket.getTenant(marketplace)\n        let saleItems= account.borrow\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()))!\n        for id in ids {\n            saleItems.cancel(id)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "ids"
                  ],
                  "parameters": {
                     "ids": "[UInt64]",
                     "marketplace": "Address"
                  }
               }
            },
            "cancelNameAuction": {
               "code": "import FIND from 0x097bafa4e0b48eef\n\ntransaction(names: [String]) {\n    prepare(account: AuthAccount) {\n\n        let finLeases= account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n        for name in names {\n            finLeases.cancel(name)\n            finLeases.delistAuction(name)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "names"
                  ],
                  "parameters": {
                     "names": "[String]"
                  }
               }
            },
            "cancelNameBid": {
               "code": "import FIND from 0x097bafa4e0b48eef\n\ntransaction(names: [String]) {\n    prepare(account: AuthAccount) {\n        let bids = account.borrow\u003c\u0026FIND.BidCollection\u003e(from: FIND.BidStoragePath)!\n        for name in names {\n            bids.cancelBid(name)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "names"
                  ],
                  "parameters": {
                     "names": "[String]"
                  }
               }
            },
            "createCharity": {
               "code": "import NonFungibleToken from 0x1d7e57aa55817448\nimport CharityNFT from 0x097bafa4e0b48eef\n\n//This transaction will prepare the art collection\ntransaction() {\n    prepare(account: AuthAccount) {\n\n        let stdCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath)\n        if !stdCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- CharityNFT.createEmptyCollection(), to: CharityNFT.CollectionStoragePath)\n            account.link\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath, target: CharityNFT.CollectionStoragePath)\n        }\n\n        let charityCap = account.getCapability\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection)\n        if !charityCap.check() {\n            account.link\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection, target: CharityNFT.CollectionStoragePath)\n        }\n    }\n}",
               "spec": null
            },
            "createProfile": {
               "code": "import FungibleToken from 0xf233dcee88fe0abe\nimport NonFungibleToken from 0x1d7e57aa55817448\nimport FUSD from 0x3c5959b568896393\nimport FiatToken from 0xb19436aae4d94622\nimport FlowToken from 0x1654653399040a61\nimport MetadataViews from 0x1d7e57aa55817448\nimport FIND from 0x097bafa4e0b48eef\nimport Profile from 0x097bafa4e0b48eef\nimport FindMarket from 0x097bafa4e0b48eef\nimport FindMarketSale from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferEscrow from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferSoft from 0x097bafa4e0b48eef\nimport FindMarketAuctionEscrow from 0x097bafa4e0b48eef\nimport FindMarketAuctionSoft from 0x097bafa4e0b48eef\nimport Dandy from 0x097bafa4e0b48eef\n\ntransaction(name: String) {\n    prepare(acct: AuthAccount) {\n        //if we do not have a profile it might be stored under a different address so we will just remove it\n        let profileCapFirst = acct.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if profileCapFirst.check() {\n            return \n        }\n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n        //SYNC with register\n        //Add exising FUSD or create a new one and add it\n        let fusdReceiver = acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n        if !fusdReceiver.check() {\n            let fusd \u003c- FUSD.createEmptyVault()\n            acct.save(\u003c- fusd, to: /storage/fusdVault)\n            acct.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n            acct.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n        }\n\n        let usdcCap = acct.getCapability\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e(FiatToken.VaultReceiverPubPath)\n        if !usdcCap.check() {\n                acct.save( \u003c-FiatToken.createEmptyVault(), to: FiatToken.VaultStoragePath)\n        acct.link\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e( FiatToken.VaultReceiverPubPath, target: FiatToken.VaultStoragePath)\n        acct.link\u003c\u0026FiatToken.Vault{FiatToken.ResourceId}\u003e( FiatToken.VaultUUIDPubPath, target: FiatToken.VaultStoragePath)\n                acct.link\u003c\u0026FiatToken.Vault{FungibleToken.Balance}\u003e( FiatToken.VaultBalancePubPath, target:FiatToken.VaultStoragePath)\n        }\n\n        let leaseCollection = acct.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            acct.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            acct.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = acct.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            acct.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            acct.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let dandyCap= acct.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            acct.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            acct.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            acct.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        var created=false\n        let profileCap = acct.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            acct.save(\u003c-profile, to: Profile.storagePath)\n            acct.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            acct.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=acct.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n        if !profile.hasWallet(\"Flow\") {\n            let flowWallet=Profile.Wallet( name:\"Flow\", receiver:acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:acct.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), names: [\"flow\"])\n    \n            profile.addWallet(flowWallet)\n        }\n        if !profile.hasWallet(\"FUSD\") {\n            profile.addWallet(Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:acct.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), names: [\"fusd\", \"stablecoin\"]))\n        }\n\n        if !profile.hasWallet(\"USDC\") {\n            profile.addWallet(Profile.Wallet( name:\"USDC\", receiver:usdcCap, balance:acct.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(FiatToken.VaultBalancePubPath), accept: Type\u003c@FiatToken.Vault\u003e(), names: [\"usdc\", \"stablecoin\"]))\n        }\n\n         //If find name not set and we have a profile set it.\n        if profile.getFindName() == \"\" {\n            profile.setFindName(name)\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else {\n            profile.emitUpdatedEvent()\n        }\n\n        let receiverCap=acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let tenantCapability= FindMarket.getTenantCapability(FindMarket.getFindTenantAddress())!\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= acct.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            acct.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            acct.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        let doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        let doeSalePublicPath=FindMarket.getPublicPath(doeSaleType, name: tenant.name)\n        let doeSaleStoragePath= FindMarket.getStoragePath(doeSaleType, name:tenant.name)\n        let doeSaleCap= acct.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n        if !doeSaleCap.check() {\n            acct.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n            acct.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n        }\n\n        let doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        let doeBidPublicPath=FindMarket.getPublicPath(doeBidType, name: tenant.name)\n        let doeBidStoragePath= FindMarket.getStoragePath(doeBidType, name:tenant.name)\n        let doeBidCap= acct.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n        if !doeBidCap.check() {\n            acct.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n            acct.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n        }\n\n        /// auctions that escrow ft\n        let aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        let aeSalePublicPath=FindMarket.getPublicPath(aeSaleType, name: tenant.name)\n        let aeSaleStoragePath= FindMarket.getStoragePath(aeSaleType, name:tenant.name)\n        let aeSaleCap= acct.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n        if !aeSaleCap.check() {\n            acct.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n            acct.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n        }\n\n        let dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\n        let dosSalePublicPath=FindMarket.getPublicPath(dosSaleType, name: tenant.name)\n        let dosSaleStoragePath= FindMarket.getStoragePath(dosSaleType, name:tenant.name)\n\n        let dosSaleCap= acct.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n        if !dosSaleCap.check() {\n            acct.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n            acct.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n        }\n\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= acct.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n        if !dosBidCap.check() {\n            acct.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            acct.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n        }\n\n        let aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\n        let aeBidPublicPath=FindMarket.getPublicPath(aeBidType, name: tenant.name)\n        let aeBidStoragePath= FindMarket.getStoragePath(aeBidType, name:tenant.name)\n        let aeBidCap= acct.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n        if !aeBidCap.check() {\n            acct.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n            acct.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n        }\n\n     /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= acct.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            acct.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            acct.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n        }\n\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= acct.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n        if !asBidCap.check() {\n            acct.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            acct.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n        }\n        //SYNC with register\n\n    }\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "delistAllNFTSale": {
               "code": "import FindMarketSale from 0x097bafa4e0b48eef\nimport FindMarket from 0x097bafa4e0b48eef\n\ntransaction(marketplace:Address) {\n    prepare(account: AuthAccount) {\n        // Get all the saleItems Id\n\n        let tenant = FindMarket.getTenant(marketplace)\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketSale.SaleItem\u003e())\n        let cap = FindMarket.getSaleItemCollectionCapability(tenantRef: tenant, marketOption: marketOption, address: account.address)\n        let ref = cap.borrow() ?? panic(\"Cannot borrow reference to the capability.\")\n\n        let listingType=Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let saleItems= account.borrow\u003c\u0026FindMarketSale.SaleItemCollection\u003e(from: tenant.getStoragePath(listingType))!\n        let ids = ref.getIds()\n        for id in ids {\n            saleItems.delist(id)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace"
                  ],
                  "parameters": {
                     "marketplace": "Address"
                  }
               }
            },
            "delistAllNameSale": {
               "code": "import FIND from 0x097bafa4e0b48eef\n\ntransaction() {\n    prepare(acct: AuthAccount) {\n        let finLeases= acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n        let leases = finLeases.getLeaseInformation()\n        for lease in leases {\n            if lease.salePrice != nil {\n                finLeases.delistSale(lease.name)\n            }\n        }\n    }\n}",
               "spec": null
            },
            "delistNFTSale": {
               "code": "import FindMarket from 0x097bafa4e0b48eef\nimport FindMarketSale from 0x097bafa4e0b48eef\n\ntransaction(marketplace:Address, ids: [UInt64]) {\n    prepare(account: AuthAccount) {\n\n        let tenant=FindMarket.getTenant(marketplace)\n        let saleItems= account.borrow\u003c\u0026FindMarketSale.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketSale.SaleItemCollection\u003e()))!\n        for id in ids {\n            saleItems.delist(id)\n        }\n\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "ids"
                  ],
                  "parameters": {
                     "ids": "[UInt64]",
                     "marketplace": "Address"
                  }
               }
            },
            "delistNameSale": {
               "code": "import FIND from 0x097bafa4e0b48eef\n\ntransaction(names: [String]) {\n    prepare(acct: AuthAccount) {\n        let finLeases= acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n        for name in names {\n            finLeases.delistSale(name)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "names"
                  ],
                  "parameters": {
                     "names": "[String]"
                  }
               }
            },
            "editProfile": {
               "code": "import FungibleToken from 0xf233dcee88fe0abe\nimport FUSD from 0x3c5959b568896393\nimport FlowToken from 0x1654653399040a61\nimport FIND from 0x097bafa4e0b48eef\nimport Profile from 0x097bafa4e0b48eef\n\ntransaction(name:String, description: String, avatar: String, tags:[String], allowStoringFollowers: Bool, linkTitles : {String: String}, linkTypes: {String:String}, linkUrls : {String:String}, removeLinks : [String]) {\n    prepare(acct: AuthAccount) {\n\n        let profile =acct.borrow\u003c\u0026Profile.User\u003e(from:Profile.storagePath)!\n\n        //Add exising FUSD or create a new one and add it\n        let fusdReceiver = acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n        if !fusdReceiver.check() {\n            let fusd \u003c- FUSD.createEmptyVault()\n            acct.save(\u003c- fusd, to: /storage/fusdVault)\n            acct.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n            acct.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n        }\n\n\n        var hasFusdWallet=false\n        var hasFlowWallet=false\n        let wallets=profile.getWallets()\n        for wallet in wallets {\n            if wallet.name==\"FUSD\" {\n                hasFusdWallet=true\n            }\n\n            if wallet.name ==\"Flow\" {\n                hasFlowWallet=true\n            }\n        }\n\n        if !hasFlowWallet {\n            let flowWallet=Profile.Wallet(\n                name:\"Flow\", \n                receiver:acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver),\n                balance:acct.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance),\n                accept: Type\u003c@FlowToken.Vault\u003e(),\n                names: [\"flow\"]\n            )\n            profile.addWallet(flowWallet)\n        }\n\n        if !hasFusdWallet {\n            let fusdWallet=Profile.Wallet(\n                name:\"FUSD\", \n                receiver:acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver),\n                balance:acct.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance),\n                accept: Type\u003c@FUSD.Vault\u003e(),\n                names: [\"fusd\", \"stablecoin\"]\n            )\n            profile.addWallet(fusdWallet)\n        }\n\n        profile.setName(name)\n        profile.setDescription(description)\n        profile.setAvatar(avatar)\n        profile.setTags(tags)\n\n        for link in removeLinks {\n            profile.removeLink(link)\n        }\n\n        for titleName in linkTitles.keys {\n            let title=linkTitles[titleName]!\n            let url = linkUrls[titleName]!\n            let type = linkTypes[titleName]!\n\n            profile.addLinkWithName(name:titleName, link: Profile.Link(title: title, type: type, url: type))\n        }\n        profile.emitUpdatedEvent()\n\n        let leaseCollection = acct.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            acct.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            acct.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n\n        }\n\n        let bidCollection = acct.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            acct.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            acct.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "description",
                     "avatar",
                     "tags",
                     "allowStoringFollowers",
                     "linkTitles",
                     "linkTypes",
                     "linkUrls",
                     "removeLinks"
                  ],
                  "parameters": {
                     "allowStoringFollowers": "Bool",
                     "avatar": "String",
                     "description": "String",
                     "linkTitles": "{String: String}",
                     "linkTypes": "{String: String}",
                     "linkUrls": "{String: String}",
                     "name": "String",
                     "removeLinks": "[String]",
                     "tags": "[String]"
                  }
               }
            },
            "fulfillMarketAuctionEscrowed": {
               "code": "import FindMarketAuctionEscrow from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\n\ntransaction(marketplace:Address, owner: String, id: UInt64) {\n    prepare(account: AuthAccount) {\n        let resolveAddress = FIND.resolve(owner)\n        if resolveAddress == nil { \n            panic(\"The address input is not a valid name nor address. Input : \".concat(owner))\n        }\n        let address = resolveAddress!\n        FindMarketAuctionEscrow.getSaleItemCapability(marketplace:marketplace, user:address)!.borrow()!.fulfillAuction(id)\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "owner",
                     "id"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "marketplace": "Address",
                     "owner": "String"
                  }
               }
            },
            "fulfillMarketAuctionEscrowedFromBidder": {
               "code": "import FindMarketAuctionEscrow from 0x097bafa4e0b48eef\nimport FindMarket from 0x097bafa4e0b48eef\n\ntransaction(marketplace:Address, id: UInt64) {\n    prepare(account: AuthAccount) {\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e())!\n        let bidsReference= account.borrow\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection\u003e(from: storagePath)!\n\n        bidsReference.fulfillAuction(id)\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "fulfillMarketAuctionSoft": {
               "code": "import FindMarketAuctionSoft from 0x097bafa4e0b48eef\nimport FungibleToken from 0xf233dcee88fe0abe\nimport FTRegistry from 0x097bafa4e0b48eef\nimport FindMarket from 0x097bafa4e0b48eef\n\ntransaction(marketplace:Address, id: UInt64, amount:UFix64) {\n\n    let walletReference : \u0026FungibleToken.Vault\n    let bidsReference: \u0026FindMarketAuctionSoft.MarketBidCollection\n    let requiredAmount: UFix64\n\n    prepare(account: AuthAccount) {\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e())\n\n        self.bidsReference= account.borrow\u003c\u0026FindMarketAuctionSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"This account does not have a bid collection\")\n\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e())\n        let item = FindMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: id)\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet\")\n    \n        self.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n        self.requiredAmount = self.bidsReference.getBalance(id)\n    }\n\n    pre{\n        self.walletReference.balance \u003e self.requiredAmount : \"Your wallet does not have enough funds to pay for this item\"\n        self.requiredAmount == amount : \"Amount needed to fulfill is \".concat(self.requiredAmount.toString()).concat(\" you sent in \").concat(amount.toString())\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount) \n        self.bidsReference.fulfillAuction(id: id, vault: \u003c- vault)\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "fulfillMarketDirectOfferEscrowed": {
               "code": "import FindMarketDirectOfferEscrow from 0x097bafa4e0b48eef\nimport NonFungibleToken from 0x1d7e57aa55817448\nimport MetadataViews from 0x1d7e57aa55817448\nimport FindViews from 0x097bafa4e0b48eef\nimport NFTRegistry from 0x097bafa4e0b48eef\nimport FindMarket from 0x097bafa4e0b48eef\n\ntransaction(marketplace:Address, id: UInt64) {\n    prepare(account: AuthAccount) {\n\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e())\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e())\n\n        let item = FindMarket.assertOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: id)\n\n        let nft = NFTRegistry.getNFTInfoByTypeIdentifier(item.getItemType().identifier) ?? panic(\"This NFT is not supported by the Find Market yet \")\n    \n        let providerCap=account.getCapability\u003c\u0026{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e(nft.providerPath)\n\n        /* Ben : Question -\u003e Either client will have to provide the path here or agree that we set it up for the user */\n        if !providerCap.check() {\n                account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                    nft.providerPath,\n                    target: nft.storagePath\n            )\n        }\n\n        let pointer= FindViews.AuthNFTPointer(cap: providerCap, id: id)\n        let market = account.borrow\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection\u003e(from: storagePath)!\n        market.acceptDirectOffer(pointer)\n\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "fulfillMarketDirectOfferSoft": {
               "code": "import FindMarketDirectOfferSoft from 0x097bafa4e0b48eef\nimport FungibleToken from 0xf233dcee88fe0abe\nimport FTRegistry from 0x097bafa4e0b48eef\nimport FindMarket from 0x097bafa4e0b48eef\n\ntransaction(marketplace:Address, id: UInt64, amount:UFix64) {\n\n    let walletReference : \u0026FungibleToken.Vault\n    let bidsReference: \u0026FindMarketDirectOfferSoft.MarketBidCollection\n    let requiredAmount:UFix64\n\n    prepare(account: AuthAccount) {\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n        self.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"Cannot borrow direct offer soft bid collection\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n        let item = FindMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: id)\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet\")\n\n      self.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n\n        self.requiredAmount = self.bidsReference.getBalance(id)\n    }\n\n    pre {\n        self.walletReference.balance \u003e self.requiredAmount : \"Your wallet does not have enough funds to pay for this item\"\n        self.requiredAmount == amount : \"Amount needed to fulfill is \".concat(amount.toString())\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount) \n        self.bidsReference.fulfillDirectOffer(id: id, vault: \u003c- vault)\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "fulfillName": {
               "code": "import FIND from 0x097bafa4e0b48eef\n\ntransaction(name: String) {\n    prepare(account: AuthAccount) {\n\n        let finLeases= account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n        finLeases.fulfill(name)\n\n    }\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "fulfillNameAuction": {
               "code": "import FIND from 0x097bafa4e0b48eef\n\ntransaction(owner: Address, name: String) {\n    prepare(account: AuthAccount) {\n        let leaseCollection = getAccount(owner).getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        let leaseRef = leaseCollection.borrow() ?? panic(\"Cannot borrow reference to lease collection reference\")\n        leaseRef.fulfillAuction(name)\n\n    }\n}",
               "spec": {
                  "order": [
                     "owner",
                     "name"
                  ],
                  "parameters": {
                     "name": "String",
                     "owner": "Address"
                  }
               }
            },
            "fulfillNameAuctionBidder": {
               "code": "import FIND from 0x097bafa4e0b48eef\nimport FungibleToken from 0xf233dcee88fe0abe\nimport FUSD from 0x3c5959b568896393\nimport Profile from 0x097bafa4e0b48eef\n\ntransaction(owner: Address, name: String) {\n    prepare(acct: AuthAccount) {\n\n\n    //Add exising FUSD or create a new one and add it\n        let fusdReceiver = acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n        if !fusdReceiver.check() {\n            let fusd \u003c- FUSD.createEmptyVault()\n            acct.save(\u003c- fusd, to: /storage/fusdVault)\n            acct.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n            acct.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n        }\n\n        let leaseCollection = acct.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            acct.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            acct.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = acct.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            acct.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            acct.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let profileCap = acct.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n\n            let fusdWallet=Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:acct.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), names: [\"fusd\", \"stablecoin\"])\n\n            profile.addWallet(fusdWallet)\n\n            acct.save(\u003c-profile, to: Profile.storagePath)\n            acct.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            acct.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n        }\n\n        let leaseCollectionOwner = getAccount(owner).getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        leaseCollectionOwner.borrow()!.fulfillAuction(name)\n\n    }\n}",
               "spec": {
                  "order": [
                     "owner",
                     "name"
                  ],
                  "parameters": {
                     "name": "String",
                     "owner": "Address"
                  }
               }
            },
            "increaseBidMarketAuctionEscrowed": {
               "code": "import FindMarketAuctionEscrow from 0x097bafa4e0b48eef\nimport FungibleToken from 0xf233dcee88fe0abe\nimport FTRegistry from 0x097bafa4e0b48eef\nimport FindMarket from 0x097bafa4e0b48eef\n\ntransaction(marketplace:Address, id: UInt64, amount: UFix64) {\n\n    let walletReference : \u0026FungibleToken.Vault\n    let bidsReference: \u0026FindMarketAuctionEscrow.MarketBidCollection\n    let balanceBeforeBid: UFix64\n\n    prepare(account: AuthAccount) {\n\n        // Get the accepted vault type from BidInfo\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e())\n        self.bidsReference= account.borrow\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection\u003e(from: storagePath) ?? panic(\"This account does not have a bid collection\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e())\n        let item = FindMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: id)\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet\")\n        self.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n        self.balanceBeforeBid = self.walletReference.balance\n    }\n\n    pre {\n        self.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount) \n        self.bidsReference.increaseBid(id: id, vault: \u003c- vault)\n    }\n\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "increaseBidMarketAuctionSoft": {
               "code": "import FindMarketAuctionSoft from 0x097bafa4e0b48eef\nimport FungibleToken from 0xf233dcee88fe0abe\nimport FTRegistry from 0x097bafa4e0b48eef\nimport FindMarket from 0x097bafa4e0b48eef\n\ntransaction(marketplace:Address, id: UInt64, amount: UFix64) {\n\n    let bidsReference: \u0026FindMarketAuctionSoft.MarketBidCollection\n    let walletReference : \u0026FungibleToken.Vault\n\n\n    prepare(account: AuthAccount) {\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e())\n        self.bidsReference= account.borrow\u003c\u0026FindMarketAuctionSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"Bid resource does not exist\")\n        // get Bidding Fungible Token Vault\n          let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e())\n        let item = FindMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: id)\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet\")\n\n        self.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n    }\n\n    execute {\n        self.bidsReference.increaseBid(id: id, increaseBy: amount)\n    }\n\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "increaseBidMarketDirectOfferEscrowed": {
               "code": "import FindMarketDirectOfferEscrow from 0x097bafa4e0b48eef\nimport FungibleToken from 0xf233dcee88fe0abe\nimport FTRegistry from 0x097bafa4e0b48eef\nimport FindMarket from 0x097bafa4e0b48eef\n\ntransaction(marketplace:Address, id: UInt64, amount: UFix64) {\n\n    let walletReference : \u0026FungibleToken.Vault\n    let bidsReference: \u0026FindMarketDirectOfferEscrow.MarketBidCollection\n    let balanceBeforeBid: UFix64\n\n    prepare(account: AuthAccount) {\n        let tenant=FindMarket.getTenantCapability(marketplace)!.borrow() ?? panic(\"Cannot borrow reference to tenant\")\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e())\n        self.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection\u003e(from: storagePath) ?? panic(\"This account does not have a bid collection\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e())\n        let item = FindMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: id)\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet\")\n        self.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n        self.balanceBeforeBid=self.walletReference.balance\n    }\n\n    pre {\n        self.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount) \n        self.bidsReference!.increaseBid(id: id, vault: \u003c- vault)\n    }\n\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "increaseBidMarketDirectOfferSoft": {
               "code": "import FindMarketDirectOfferSoft from 0x097bafa4e0b48eef\nimport FindMarket from 0x097bafa4e0b48eef\n\ntransaction(marketplace: Address, id: UInt64, amount: UFix64) {\n\n    let bidsReference: \u0026FindMarketDirectOfferSoft.MarketBidCollection\n\n    prepare(account: AuthAccount) {\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n        self.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"Bid resource does not exist\")\n        // get Bidding Fungible Token Vault\n          let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n        let item = FindMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: id)\n    }\n\n    execute {\n        self.bidsReference.increaseBid(id: id, increaseBy: amount)\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "increaseNameBid": {
               "code": "import FIND from 0x097bafa4e0b48eef\nimport FungibleToken from 0xf233dcee88fe0abe\nimport FUSD from 0x3c5959b568896393\n\ntransaction(name: String, amount: UFix64) {\n    prepare(account: AuthAccount) {\n\n        let vaultRef = account.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault) ?? panic(\"Could not borrow reference to the fusdVault!\")\n        \n        let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n\n        let vault \u003c- vaultRef.withdraw(amount: amount) as! @FUSD.Vault\n        let bids = account.borrow\u003c\u0026FIND.BidCollection\u003e(from: FIND.BidStoragePath)!\n        bids.increaseBid(name: name, vault: \u003c- vault)\n\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "name": "String"
                  }
               }
            },
            "listNFTForAuctionEscrowed": {
               "code": "import FindMarket from 0x097bafa4e0b48eef\nimport FindMarketAuctionEscrow from 0x097bafa4e0b48eef\nimport NonFungibleToken from 0x1d7e57aa55817448\nimport MetadataViews from 0x1d7e57aa55817448\nimport FindViews from 0x097bafa4e0b48eef\nimport NFTRegistry from 0x097bafa4e0b48eef\nimport FTRegistry from 0x097bafa4e0b48eef\n\ntransaction(marketplace:Address, nftAliasOrIdentifier:String, id: UInt64, ftAliasOrIdentifier:String, price:UFix64, auctionReservePrice: UFix64, auctionDuration: UFix64, auctionExtensionOnLateBid: UFix64, minimumBidIncrement: UFix64, auctionValidUntil: UFix64?) {\n    prepare(account: AuthAccount) {\n        // get saleItemsRef from tenant\n        let tenant=FindMarket.getTenant(marketplace)\n\n        let path=FindMarket.getStoragePath(Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(), name: tenant.name)\n\n        let saleItems= account.borrow\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection\u003e(from: path)!\n\n        // Get supported NFT and FT Information from Registries from input alias\n        let nft = NFTRegistry.getNFTInfo(nftAliasOrIdentifier) ?? panic(\"This NFT is not supported by the Find Market yet\")\n        let ft = FTRegistry.getFTInfo(ftAliasOrIdentifier) ?? panic(\"This FT is not supported by the Find Market yet\")\n\n        let providerCap=account.getCapability\u003c\u0026{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e(nft.providerPath)\n        \n        /* Ben : Question -\u003e Either client will have to provide the path here or agree that we set it up for the user */\n        if !providerCap.check() {\n                account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                    nft.providerPath,\n                    target: nft.storagePath\n            )\n        }\n\n        let pointer= FindViews.AuthNFTPointer(cap: providerCap, id: id)\n        // Ben : panic on some unreasonable inputs in trxn \n        assert(minimumBidIncrement \u003e 0.0, message:\"Minimum bid increment should be larger than 0.\")\n        assert((auctionReservePrice - auctionReservePrice) % minimumBidIncrement == 0.0, message:\"Acution ReservePrice should be in step of minimum bid increment.\" )\n        assert(auctionDuration \u003e 0.0, message: \"Auction Duration should be greater than 0.\")\n        assert(auctionExtensionOnLateBid \u003e 0.0, message: \"Auction Duration should be greater than 0.\")\n        \n        saleItems.listForAuction(pointer: pointer, vaultType: ft.type, auctionStartPrice: price, auctionReservePrice: auctionReservePrice, auctionDuration: auctionDuration, auctionExtensionOnLateBid: auctionExtensionOnLateBid, minimumBidIncrement: minimumBidIncrement, auctionValidUntil:auctionValidUntil, saleItemExtraField: {})\n\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "nftAliasOrIdentifier",
                     "id",
                     "ftAliasOrIdentifier",
                     "price",
                     "auctionReservePrice",
                     "auctionDuration",
                     "auctionExtensionOnLateBid",
                     "minimumBidIncrement",
                     "auctionValidUntil"
                  ],
                  "parameters": {
                     "auctionDuration": "UFix64",
                     "auctionExtensionOnLateBid": "UFix64",
                     "auctionReservePrice": "UFix64",
                     "auctionValidUntil": "UFix64?",
                     "ftAliasOrIdentifier": "String",
                     "id": "UInt64",
                     "marketplace": "Address",
                     "minimumBidIncrement": "UFix64",
                     "nftAliasOrIdentifier": "String",
                     "price": "UFix64"
                  }
               }
            },
            "listNFTForAuctionSoft": {
               "code": "import FindMarket from 0x097bafa4e0b48eef\nimport FindMarketAuctionSoft from 0x097bafa4e0b48eef\nimport NonFungibleToken from 0x1d7e57aa55817448\nimport MetadataViews from 0x1d7e57aa55817448\nimport FindViews from 0x097bafa4e0b48eef\nimport FTRegistry from 0x097bafa4e0b48eef\nimport NFTRegistry from 0x097bafa4e0b48eef\n\ntransaction(marketplace:Address, nftAliasOrIdentifier:String, id: UInt64, ftAliasOrIdentifier:String, price:UFix64, auctionReservePrice: UFix64, auctionDuration: UFix64, auctionExtensionOnLateBid: UFix64, minimumBidIncrement: UFix64, auctionValidUntil: UFix64?) {\n    prepare(account: AuthAccount) {\n\n        let tenant=FindMarket.getTenant(marketplace)\n        let saleItems= account.borrow\u003c\u0026FindMarketAuctionSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e())!)!\n\n        // Get supported NFT and FT Information from Registries from input alias\n        let nft = NFTRegistry.getNFTInfo(nftAliasOrIdentifier) ?? panic(\"This NFT is not supported by the Find Market yet\")\n        let ft = FTRegistry.getFTInfo(ftAliasOrIdentifier) ?? panic(\"This FT is not supported by the Find Market yet\")\n\n        let providerCap = account.getCapability\u003c\u0026{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e(nft.providerPath)\n\n        /* Ben : Question -\u003e Either client will have to provide the path here or agree that we set it up for the user */\n        if !providerCap.check() {\n                account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                    nft.providerPath,\n                    target: nft.storagePath\n            )\n        }\n        \n        let pointer= FindViews.AuthNFTPointer(cap: providerCap, id: id)\n        // Ben : panic on some unreasonable inputs in trxn \n        assert(minimumBidIncrement \u003e 0.0, message:\"Minimum bid increment should be larger than 0.\")\n        assert((auctionReservePrice - auctionReservePrice) % minimumBidIncrement == 0.0, message:\"Acution ReservePrice should be in step of minimum bid increment.\" )\n        assert(auctionDuration \u003e 0.0, message: \"Auction Duration should be greater than 0.\")\n        assert(auctionExtensionOnLateBid \u003e 0.0, message: \"Auction Duration should be greater than 0.\")\n        \n        saleItems.listForAuction(pointer: pointer, vaultType: ft.type, auctionStartPrice: price, auctionReservePrice: auctionReservePrice, auctionDuration: auctionDuration, auctionExtensionOnLateBid: auctionExtensionOnLateBid, minimumBidIncrement: minimumBidIncrement, auctionValidUntil: auctionValidUntil, saleItemExtraField: {})\n\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "nftAliasOrIdentifier",
                     "id",
                     "ftAliasOrIdentifier",
                     "price",
                     "auctionReservePrice",
                     "auctionDuration",
                     "auctionExtensionOnLateBid",
                     "minimumBidIncrement",
                     "auctionValidUntil"
                  ],
                  "parameters": {
                     "auctionDuration": "UFix64",
                     "auctionExtensionOnLateBid": "UFix64",
                     "auctionReservePrice": "UFix64",
                     "auctionValidUntil": "UFix64?",
                     "ftAliasOrIdentifier": "String",
                     "id": "UInt64",
                     "marketplace": "Address",
                     "minimumBidIncrement": "UFix64",
                     "nftAliasOrIdentifier": "String",
                     "price": "UFix64"
                  }
               }
            },
            "listNFTForSale": {
               "code": "import FindMarket from 0x097bafa4e0b48eef\nimport FindMarketSale from 0x097bafa4e0b48eef\nimport NonFungibleToken from 0x1d7e57aa55817448\nimport MetadataViews from 0x1d7e57aa55817448\nimport FindViews from 0x097bafa4e0b48eef\nimport NFTRegistry from 0x097bafa4e0b48eef\nimport FTRegistry from 0x097bafa4e0b48eef\n\ntransaction(marketplace:Address, nftAliasOrIdentifier: String, id: UInt64, ftAliasOrIdentifier: String, directSellPrice:UFix64, validUntil: UFix64?) {\n    prepare(account: AuthAccount) {\n        // Get the salesItemRef from tenant\n        let tenant=FindMarket.getTenant(marketplace)\n        let saleItems= account.borrow\u003c\u0026FindMarketSale.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketSale.SaleItemCollection\u003e()))!\n\n        // Get supported NFT and FT Information from Registries from input alias\n        let nft = NFTRegistry.getNFTInfo(nftAliasOrIdentifier) ?? panic(\"This NFT is not supported by the Find Market yet\")\n        let ft = FTRegistry.getFTInfo(ftAliasOrIdentifier) ?? panic(\"This FT is not supported by the Find Market yet\")\n\n        let providerCap=account.getCapability\u003c\u0026{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e(nft.providerPath)\n\n        /* Ben : Question -\u003e Either client will have to provide the path here or agree that we set it up for the user */\n        if !providerCap.check() {\n                account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                    nft.providerPath,\n                    target: nft.storagePath\n            )\n        }\n\n        let pointer= FindViews.AuthNFTPointer(cap: providerCap, id: id)\n        saleItems.listForSale(pointer: pointer, vaultType: ft.type, directSellPrice: directSellPrice, validUntil: validUntil, extraField: {})\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "nftAliasOrIdentifier",
                     "id",
                     "ftAliasOrIdentifier",
                     "directSellPrice",
                     "validUntil"
                  ],
                  "parameters": {
                     "directSellPrice": "UFix64",
                     "ftAliasOrIdentifier": "String",
                     "id": "UInt64",
                     "marketplace": "Address",
                     "nftAliasOrIdentifier": "String",
                     "validUntil": "UFix64?"
                  }
               }
            },
            "listNameForAuction": {
               "code": "import FIND from 0x097bafa4e0b48eef\n\ntransaction(name: String, auctionStartPrice: UFix64, auctionReservePrice: UFix64, auctionDuration: UFix64, auctionExtensionOnLateBid: UFix64) {\n    prepare(acct: AuthAccount) {\n        let finLeases= acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n        finLeases.listForAuction(name: name, auctionStartPrice: auctionStartPrice, auctionReservePrice: auctionReservePrice, auctionDuration: auctionDuration,  auctionExtensionOnLateBid: auctionExtensionOnLateBid)\n\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "auctionStartPrice",
                     "auctionReservePrice",
                     "auctionDuration",
                     "auctionExtensionOnLateBid"
                  ],
                  "parameters": {
                     "auctionDuration": "UFix64",
                     "auctionExtensionOnLateBid": "UFix64",
                     "auctionReservePrice": "UFix64",
                     "auctionStartPrice": "UFix64",
                     "name": "String"
                  }
               }
            },
            "listNameForSale": {
               "code": "import FIND from 0x097bafa4e0b48eef\n\ntransaction(name: String, directSellPrice:UFix64) {\n    prepare(acct: AuthAccount) {\n        let finLeases= acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n        finLeases.listForSale(name: name,  directSellPrice:directSellPrice)\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "directSellPrice"
                  ],
                  "parameters": {
                     "directSellPrice": "UFix64",
                     "name": "String"
                  }
               }
            },
            "moveNameTO": {
               "code": "import Profile from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\n\n\ntransaction(name: String, receiver:String) {\n\n\n    let receiverAddress:Address?\n    let sender : \u0026FIND.LeaseCollection\n\n    prepare(acct: AuthAccount) {\n        self.sender= acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n        self.receiverAddress=FIND.resolve(receiver)\n    } \n\n    pre{\n        self.receiverAddress != nil : \"The input pass in is not a valid name or address. Input : \".concat(receiver)\n    }\n\n    execute {\n        let receiver=getAccount(self.receiverAddress!)\n        let receiverLease = receiver.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        let receiverProfile = receiver.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\n        if !receiverLease.check() || !receiverProfile.check() {\n            panic(\"Not a valid FIND user\")\n        }\n\n        self.sender.move(name:name, profile:receiverProfile, to: receiverLease)\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "receiver"
                  ],
                  "parameters": {
                     "name": "String",
                     "receiver": "String"
                  }
               }
            },
            "register": {
               "code": "import FungibleToken from 0xf233dcee88fe0abe\nimport FUSD from 0x3c5959b568896393\nimport FiatToken from 0xb19436aae4d94622\nimport FlowToken from 0x1654653399040a61\nimport Profile from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\nimport FindMarketSale from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferEscrow from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferSoft from 0x097bafa4e0b48eef\nimport FindMarketAuctionEscrow from 0x097bafa4e0b48eef\nimport FindMarketAuctionSoft from 0x097bafa4e0b48eef\nimport FindMarket from 0x097bafa4e0b48eef\nimport NonFungibleToken from 0x1d7e57aa55817448\nimport MetadataViews from 0x1d7e57aa55817448\nimport Dandy from 0x097bafa4e0b48eef\n\ntransaction(name: String, amount: UFix64) {\n    prepare(acct: AuthAccount) {\n\n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n        //SYNC with register\n        //Add exising FUSD or create a new one and add it\n        let fusdReceiver = acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n        if !fusdReceiver.check() {\n            let fusd \u003c- FUSD.createEmptyVault()\n            acct.save(\u003c- fusd, to: /storage/fusdVault)\n            acct.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n            acct.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n        }\n\n        let usdcCap = acct.getCapability\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e(FiatToken.VaultReceiverPubPath)\n        if !usdcCap.check() {\n                acct.save( \u003c-FiatToken.createEmptyVault(), to: FiatToken.VaultStoragePath)\n        acct.link\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e( FiatToken.VaultReceiverPubPath, target: FiatToken.VaultStoragePath)\n        acct.link\u003c\u0026FiatToken.Vault{FiatToken.ResourceId}\u003e( FiatToken.VaultUUIDPubPath, target: FiatToken.VaultStoragePath)\n                acct.link\u003c\u0026FiatToken.Vault{FungibleToken.Balance}\u003e( FiatToken.VaultBalancePubPath, target:FiatToken.VaultStoragePath)\n        }\n\n        let leaseCollection = acct.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            acct.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            acct.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = acct.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            acct.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            acct.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let dandyCap= acct.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            acct.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            acct.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            acct.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n      let dandyCapPub= acct.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCapPub.check() {\n            acct.unlink(Dandy.CollectionPublicPath)\n            acct.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        let dandyCapPrivate= acct.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPrivatePath)\n        if !dandyCapPub.check() {\n            acct.unlink(Dandy.CollectionPrivatePath)\n            acct.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        var created=false\n        let profileCap = acct.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            acct.save(\u003c-profile, to: Profile.storagePath)\n            acct.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            acct.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=acct.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n        if !profile.hasWallet(\"Flow\") {\n            let flowWallet=Profile.Wallet( name:\"Flow\", receiver:acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:acct.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), names: [\"flow\"])\n    \n            profile.addWallet(flowWallet)\n        }\n        if !profile.hasWallet(\"FUSD\") {\n            profile.addWallet(Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:acct.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), names: [\"fusd\", \"stablecoin\"]))\n        }\n\n        if !profile.hasWallet(\"USDC\") {\n            profile.addWallet(Profile.Wallet( name:\"USDC\", receiver:usdcCap, balance:acct.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(FiatToken.VaultBalancePubPath), accept: Type\u003c@FiatToken.Vault\u003e(), names: [\"usdc\", \"stablecoin\"]))\n        }\n\n         //If find name not set and we have a profile set it.\n        if profile.getFindName() == \"\" {\n            profile.setFindName(name)\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else {\n            profile.emitUpdatedEvent()\n        }\n\n        let receiverCap=acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let tenantCapability= FindMarket.getTenantCapability(FindMarket.getFindTenantAddress())!\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= acct.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            acct.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            acct.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        let doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        let doeSalePublicPath=FindMarket.getPublicPath(doeSaleType, name: tenant.name)\n        let doeSaleStoragePath= FindMarket.getStoragePath(doeSaleType, name:tenant.name)\n        let doeSaleCap= acct.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n        if !doeSaleCap.check() {\n            acct.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n            acct.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n        }\n\n        let doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        let doeBidPublicPath=FindMarket.getPublicPath(doeBidType, name: tenant.name)\n        let doeBidStoragePath= FindMarket.getStoragePath(doeBidType, name:tenant.name)\n        let doeBidCap= acct.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n        if !doeBidCap.check() {\n            acct.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n            acct.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n        }\n\n        /// auctions that escrow ft\n        let aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        let aeSalePublicPath=FindMarket.getPublicPath(aeSaleType, name: tenant.name)\n        let aeSaleStoragePath= FindMarket.getStoragePath(aeSaleType, name:tenant.name)\n        let aeSaleCap= acct.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n        if !aeSaleCap.check() {\n            acct.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n            acct.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n        }\n\n        let dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\n        let dosSalePublicPath=FindMarket.getPublicPath(dosSaleType, name: tenant.name)\n        let dosSaleStoragePath= FindMarket.getStoragePath(dosSaleType, name:tenant.name)\n\n        let dosSaleCap= acct.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n        if !dosSaleCap.check() {\n            acct.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n            acct.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n        }\n\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= acct.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n        if !dosBidCap.check() {\n            acct.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            acct.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n        }\n\n        let aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\n        let aeBidPublicPath=FindMarket.getPublicPath(aeBidType, name: tenant.name)\n        let aeBidStoragePath= FindMarket.getStoragePath(aeBidType, name:tenant.name)\n        let aeBidCap= acct.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n        if !aeBidCap.check() {\n            acct.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n            acct.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n        }\n\n     /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= acct.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            acct.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            acct.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n        }\n\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= acct.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n        if !asBidCap.check() {\n            acct.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            acct.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n        }\n        //SYNC with register\n\n\n\n        let price=FIND.calculateCost(name)\n        if price != amount {\n            panic(\"Calculated cost does not match expected cost\")\n        }\n        log(\"The cost for registering this name is \".concat(price.toString()))\n\n        let vaultRef = acct.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault) ?? panic(\"Could not borrow reference to the fusdVault!\")\n\n        let payVault \u003c- vaultRef.withdraw(amount: price) as! @FUSD.Vault\n\n        let leases=acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from: FIND.LeaseStoragePath)!\n        leases.register(name: name, vault: \u003c- payVault)\n\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "name": "String"
                  }
               }
            },
            "registerGift": {
               "code": "import FUSD from 0x3c5959b568896393\nimport Profile from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\n\ntransaction(name: String, amount: UFix64, recipient: String) {\n    prepare(acct: AuthAccount) {\n\n        let resolveAddress = FIND.resolve(recipient)\n        if resolveAddress == nil {panic(\"The input pass in is not a valid name or address. Input : \".concat(recipient))}\n        let address = resolveAddress!\n        let price=FIND.calculateCost(name)\n        if price != amount {\n            panic(\"Calculated cost does not match expected cost\")\n        }\n        log(\"The cost for registering this name is \".concat(price.toString()))\n\n        let vaultRef = acct.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault) ?? panic(\"Could not borrow reference to the fusdVault!\")\n        let payVault \u003c- vaultRef.withdraw(amount: price) as! @FUSD.Vault\n\n        let leases=acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from: FIND.LeaseStoragePath)!\n        leases.register(name: name, vault: \u003c- payVault)\n\n        let receiver = getAccount(address)\n        let receiverLease = receiver.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        let receiverProfile = receiver.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !receiverLease.check() {\n            panic(\"Receiver is not a find user\")\n        }\n        leases.move(name: name, profile: receiverProfile, to: receiverLease)\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "amount",
                     "recipient"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "name": "String",
                     "recipient": "String"
                  }
               }
            },
            "rejectNameDirectOffer": {
               "code": "import FIND from 0x097bafa4e0b48eef\n\ntransaction(names: [String]) {\n    prepare(account: AuthAccount) {\n\n        let finLeases= account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n        for name in names {\n            finLeases.cancel(name)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "names"
                  ],
                  "parameters": {
                     "names": "[String]"
                  }
               }
            },
            "removeCurratedCollection": {
               "code": "transaction(name: String) {\n    prepare(account: AuthAccount) {\n\n        let path=/storage/FindCuratedCollections\n        let publicPath=/public/FindCuratedCollections\n\n        var collections : {String: [String]} = {}\n        if account.borrow\u003c\u0026{String: [String]}\u003e(from:path) != nil {\n             collections=account.load\u003c{String: [String]}\u003e(from:path)!\n        }\n        collections.remove(key: name)\n        account.save(collections, to: path)\n        let link = account.getCapability\u003c\u0026{String: [String]}\u003e(publicPath)\n        if !link.check() {\n            account.link\u003c\u0026{String: [String]}\u003e( publicPath, target: path)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "removeMarketOption": {
               "code": "import FindMarket from 0x097bafa4e0b48eef\n\n\n\n\ntransaction(saleItemName: String){\n    prepare(account: AuthAccount){\n        let path = FindMarket.TenantClientStoragePath\n        let tenantRef = account.borrow\u003c\u0026FindMarket.TenantClient\u003e(from: path) ?? panic(\"Cannot borrow Reference.\")\n\n        tenantRef.removeMarketOption(name: saleItemName)\n    }\n}",
               "spec": {
                  "order": [
                     "saleItemName"
                  ],
                  "parameters": {
                     "saleItemName": "String"
                  }
               }
            },
            "removeRelatedAccount": {
               "code": "import RelatedAccounts from 0x097bafa4e0b48eef\n\n\ntransaction(name: String){\n    prepare(account: AuthAccount) {\n\n        let cap = account.getCapability\u003c\u0026RelatedAccounts.Accounts{RelatedAccounts.Public}\u003e(RelatedAccounts.publicPath)\n        if !cap.check() {\n            let relatedAccounts \u003c- RelatedAccounts.createEmptyAccounts()\n            account.save(\u003c- relatedAccounts, to: RelatedAccounts.storagePath)\n            account.link\u003c\u0026RelatedAccounts.Accounts{RelatedAccounts.Public}\u003e(RelatedAccounts.publicPath, target: RelatedAccounts.storagePath)\n        }\n\n        let relatedAccounts =account.borrow\u003c\u0026RelatedAccounts.Accounts\u003e(from:RelatedAccounts.storagePath)!\n        relatedAccounts.deleteAccount(name: name)\n    }\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "removeTenantRule": {
               "code": "import FindMarket from 0x097bafa4e0b48eef\n\ntransaction(optionName: String, tenantRuleName: String){\n    prepare(account: AuthAccount){\n        let path = FindMarket.TenantClientStoragePath\n        let tenantRef = account.borrow\u003c\u0026FindMarket.TenantClient\u003e(from: path) ?? panic(\"Cannot borrow Reference.\")\n\n        tenantRef.removeTenantRule(optionName: optionName, tenantRuleName: tenantRuleName)\n    }\n}",
               "spec": {
                  "order": [
                     "optionName",
                     "tenantRuleName"
                  ],
                  "parameters": {
                     "optionName": "String",
                     "tenantRuleName": "String"
                  }
               }
            },
            "renewName": {
               "code": "import FUSD from 0x3c5959b568896393\nimport FIND from 0x097bafa4e0b48eef\n\ntransaction(name: String, amount: UFix64) {\n    prepare(acct: AuthAccount) {\n\n        let price=FIND.calculateCost(name)\n        if amount != price {\n            panic(\"expected renew cost is not the same as calculated renew cost\")\n        }\n        let vaultRef = acct.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault) ?? panic(\"Could not borrow reference to the fusdVault!\")\n        let payVault \u003c- vaultRef.withdraw(amount: price) as! @FUSD.Vault\n\n        let finLeases= acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n        let finToken= finLeases.borrow(name)\n        finToken.extendLease(\u003c- payVault)\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "name": "String"
                  }
               }
            },
            "retractOfferMarketDirectOfferEscrowed": {
               "code": "import FindMarket from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferEscrow from 0x097bafa4e0b48eef\n\ntransaction(marketplace:Address, id: UInt64) {\n    let bidsReference: \u0026FindMarketDirectOfferEscrow.MarketBidCollection\n\n    prepare(account: AuthAccount) {\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e())\n        self.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection\u003e(from: storagePath) ?? panic(\"This account does not have a bid collection\")\n    }\n\n    execute {\n        self.bidsReference.cancelBid(id)\n    }\n\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "retractOfferMarketDirectOfferSoft": {
               "code": "import FindMarket from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferSoft from 0x097bafa4e0b48eef\n\ntransaction(marketplace:Address, id: UInt64) {\n    let bidsReference: \u0026FindMarketDirectOfferSoft.MarketBidCollection\n\n    prepare(account: AuthAccount) {\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n        self.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"Bid resource does not exist\")\n    }\n\n    execute {\n        self.bidsReference.cancelBid(id)\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "sendCharity": {
               "code": "import NonFungibleToken from 0x1d7e57aa55817448\nimport CharityNFT from 0x097bafa4e0b48eef\n\n//mint an art and add it to a users collection\ntransaction(\n    id: UInt64,\n    recipient: Address\n) {\n    let receiverCap: Capability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e\n    let charityCollection: \u0026NonFungibleToken.Collection\n\n    prepare(account: AuthAccount) {\n        self.charityCollection =account.borrow\u003c\u0026NonFungibleToken.Collection\u003e(from: CharityNFT.CollectionStoragePath)!\n        self.receiverCap= getAccount(recipient).getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath)\n    }\n\n    execute {\n        let nft \u003c- self.charityCollection.withdraw(withdrawID: id)\n        self.receiverCap.borrow()!.deposit(token: \u003c- nft)\n    }\n}",
               "spec": {
                  "order": [
                     "id",
                     "recipient"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "recipient": "Address"
                  }
               }
            },
            "sendDandy": {
               "code": "import FIND from 0x097bafa4e0b48eef\nimport NonFungibleToken from 0x1d7e57aa55817448\nimport Dandy from 0x097bafa4e0b48eef\n\ntransaction(user: String, id: UInt64) {\n    prepare(account: AuthAccount) {\n        let address = FIND.resolve(user) ?? panic(\"Cannot find user with this name / address\")\n        let cap = getAccount(address).getCapability\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        let ref = cap.borrow() ?? panic(\"Cannot borrow reference to receiver Collection.\")\n\n        let senderRef = account.borrow\u003c\u0026Dandy.Collection\u003e(from: Dandy.CollectionStoragePath) ?? panic(\"Cannot borrow reference to sender Collection.\")\n        ref.deposit(token: \u003c- senderRef.withdraw(withdrawID: id))\n    }\n}",
               "spec": {
                  "order": [
                     "user",
                     "id"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "user": "String"
                  }
               }
            },
            "sendFT": {
               "code": "import FungibleToken from 0xf233dcee88fe0abe\nimport Sender from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\nimport FTRegistry from 0x097bafa4e0b48eef\n\n\ntransaction(name: String, amount: UFix64, ftAliasOrIdentifier: String, tag: String, message:String) {\n\n    prepare(account: AuthAccount) {\n\n        let ft = FTRegistry.getFTInfo(ftAliasOrIdentifier) ?? panic(\"This FT is not supported by the Find Market yet\")\n        let walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n\n        if account.borrow\u003c\u0026Sender.Token\u003e(from: Sender.storagePath) == nil {\n            account.save(\u003c- Sender.create(), to: Sender.storagePath)\n        }\n\n        let token =account.borrow\u003c\u0026Sender.Token\u003e(from: Sender.storagePath)!\n        let vault \u003c- walletReference.withdraw(amount: amount)\n        FIND.depositWithTagAndMessage(to: name, message: message, tag: tag, vault: \u003c- vault, from: token)\n    }\n\n}",
               "spec": {
                  "order": [
                     "name",
                     "amount",
                     "ftAliasOrIdentifier",
                     "tag",
                     "message"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "ftAliasOrIdentifier": "String",
                     "message": "String",
                     "name": "String",
                     "tag": "String"
                  }
               }
            },
            "setMainName": {
               "code": "import Profile from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\n\n\ntransaction(name: String) {\n    prepare(acct: AuthAccount) {\n\n        let leaseCollectionOwner = acct.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\n        if !leaseCollectionOwner.check() {\n            panic(\"Not a find user\")\n        }\n\n        if leaseCollectionOwner.borrow()!.getLease(name) == nil {\n            panic(\"You do not own this lease so you cannot set it as main name\")\n        }\n\n        let profile =acct.borrow\u003c\u0026Profile.User\u003e(from:Profile.storagePath)!\n        profile.setFindName(name)\n    }\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "setMarketOptionFlowDandy": {
               "code": "import FindMarket from 0x097bafa4e0b48eef\nimport FlowToken from 0x1654653399040a61\nimport Dandy from 0x097bafa4e0b48eef\n\ntransaction(){\n    prepare(account: AuthAccount){\n        let path = FindMarket.TenantClientStoragePath\n        let tenantRef = account.borrow\u003c\u0026FindMarket.TenantClient\u003e(from: path) ?? panic(\"Cannot borrow Reference.\")\n\n        tenantRef.setMarketOption(name:\"FlowDandy\", cut: nil, rules:[\n            FindMarket.TenantRule(name:\"Flow\", types:[Type\u003c@FlowToken.Vault\u003e()], ruleType: \"ft\", allow: true),\n            FindMarket.TenantRule(name:\"Dandy\", types:[ Type\u003c@Dandy.NFT\u003e()],\n                        ruleType: \"nft\", allow: true)\n            ]\n        )\n    }\n}",
               "spec": null
            },
            "setPrivateMode": {
               "code": "import Profile from 0x097bafa4e0b48eef\n\ntransaction(mode: Bool) {\n    prepare(acct: AuthAccount) {\n        let profile =acct.borrow\u003c\u0026Profile.User\u003e(from:Profile.storagePath)!\n        profile.setPrivateMode(mode)\n        profile.emitUpdatedEvent()\n    }\n}",
               "spec": {
                  "order": [
                     "mode"
                  ],
                  "parameters": {
                     "mode": "Bool"
                  }
               }
            },
            "setProfile": {
               "code": "import Profile from 0x097bafa4e0b48eef\n\ntransaction(avatar: String) {\n    prepare(acct: AuthAccount) {\n        let profile =acct.borrow\u003c\u0026Profile.User\u003e(from:Profile.storagePath)!\n        profile.setAvatar(avatar)\n\n        profile.emitUpdatedEvent()\n    }\n}",
               "spec": {
                  "order": [
                     "avatar"
                  ],
                  "parameters": {
                     "avatar": "String"
                  }
               }
            },
            "setRelatedAccount": {
               "code": "import RelatedAccounts from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\n\ntransaction(name: String, target: String) {\n    prepare(account: AuthAccount) {\n\n        let resolveAddress = FIND.resolve(target)\n        if resolveAddress == nil {panic(\"The input pass in is not a valid name or address. Input : \".concat(target))}\n        let address = resolveAddress!\n        let cap = account.getCapability\u003c\u0026RelatedAccounts.Accounts{RelatedAccounts.Public}\u003e(RelatedAccounts.publicPath)\n        if !cap.check() {\n            let relatedAccounts \u003c- RelatedAccounts.createEmptyAccounts()\n            account.save(\u003c- relatedAccounts, to: RelatedAccounts.storagePath)\n            account.link\u003c\u0026RelatedAccounts.Accounts{RelatedAccounts.Public}\u003e(RelatedAccounts.publicPath, target: RelatedAccounts.storagePath)\n        }\n\n        let relatedAccounts =account.borrow\u003c\u0026RelatedAccounts.Accounts\u003e(from:RelatedAccounts.storagePath)!\n        relatedAccounts.setFlowAccount(name: name, address: address)\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "target"
                  ],
                  "parameters": {
                     "name": "String",
                     "target": "String"
                  }
               }
            },
            "setSellDandyRules": {
               "code": "import FindMarket from 0x097bafa4e0b48eef\nimport FlowToken from 0x1654653399040a61\nimport FUSD from 0x3c5959b568896393\nimport Dandy from 0x097bafa4e0b48eef\n\ntransaction(){\n    prepare(account: AuthAccount){\n        let path = FindMarket.TenantClientStoragePath\n        let tenantRef = account.borrow\u003c\u0026FindMarket.TenantClient\u003e(from: path) ?? panic(\"Cannot borrow Reference.\")\n\n        tenantRef.setMarketOption(name:\"FUSDDandy\", cut: nil, rules:[\n            FindMarket.TenantRule(name:\"FUSD\", types:[Type\u003c@FUSD.Vault\u003e()], ruleType: \"ft\", allow: true),\n            FindMarket.TenantRule(name:\"Dandy\", types:[ Type\u003c@Dandy.NFT\u003e()], ruleType: \"nft\", allow: true)\n            ]\n        )\n\n        tenantRef.setMarketOption(name:\"FlowDandy\", cut: nil, rules:[\n            FindMarket.TenantRule(name:\"Flow\", types:[Type\u003c@FlowToken.Vault\u003e()], ruleType: \"ft\", allow: true),\n            FindMarket.TenantRule(name:\"Dandy\", types:[ Type\u003c@Dandy.NFT\u003e()], ruleType: \"nft\", allow: true)\n            ]\n        )\n\n    }\n}",
               "spec": null
            },
            "setTenantRuleFUSD": {
               "code": "import FindMarket from 0x097bafa4e0b48eef\nimport FUSD from 0x3c5959b568896393\n\ntransaction(optionName: String){\n    prepare(account: AuthAccount){\n        let path = FindMarket.TenantClientStoragePath\n        let tenantRef = account.borrow\u003c\u0026FindMarket.TenantClient\u003e(from: path) ?? panic(\"Cannot borrow Reference.\")\n\n        tenantRef.setTenantRule(optionName: optionName, tenantRule:\n            FindMarket.TenantRule(name:\"FUSD\", types:[Type\u003c@FUSD.Vault\u003e()], ruleType: \"ft\", allow: true)\n        )\n    }\n}",
               "spec": {
                  "order": [
                     "optionName"
                  ],
                  "parameters": {
                     "optionName": "String"
                  }
               }
            },
            "startNameAuction": {
               "code": "import FIND from 0x097bafa4e0b48eef\n\ntransaction(name: String) {\n    prepare(account: AuthAccount) {\n\n        let finLeases= account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n        finLeases.startAuction(name)\n\n    }\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "storeCuratedCollections": {
               "code": "transaction(collections: {String :  [String]}) {\n    prepare(account: AuthAccount) {\n\n        let path=/storage/FindCuratedCollections\n        let publicPath=/public/FindCuratedCollections\n\n        if account.borrow\u003c\u0026{String: [String]}\u003e(from:path) != nil {\n             account.load\u003c{String: [String]}\u003e(from:path)\n        }\n        account.save(collections, to: path)\n\n        let link = account.getCapability\u003c\u0026{String: [String]}\u003e(publicPath)\n        if !link.check() {\n            account.link\u003c\u0026{String: [String]}\u003e( publicPath, target: path)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "collections"
                  ],
                  "parameters": {
                     "collections": "{String: [String]}"
                  }
               }
            },
            "testAlterMarketOption": {
               "code": "import FindMarket from 0x097bafa4e0b48eef\n\ntransaction(market: String , action: String ){\n    prepare(account: AuthAccount){\n        let path = FindMarket.TenantClientStoragePath\n        let tenantRef = account.borrow\u003c\u0026FindMarket.TenantClient\u003e(from: path) ?? panic(\"Cannot borrow Reference.\")\n\n\n        switch action {\n            case \"enable\" :\n                tenantRef.enableMarketOption(\"FlowDandy\".concat(market))\n\n            case \"deprecate\" :\n                tenantRef.deprecateMarketOption(\"FlowDandy\".concat(market))\n\n            case \"stop\" :\n                tenantRef.stopMarketOption(\"FlowDandy\".concat(market))\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "market",
                     "action"
                  ],
                  "parameters": {
                     "action": "String",
                     "market": "String"
                  }
               }
            },
            "testBlockItem": {
               "code": "import Admin from 0x097bafa4e0b48eef\nimport FindMarket from 0x097bafa4e0b48eef\nimport Dandy from 0x097bafa4e0b48eef\n\ntransaction(tenant: Address){\n    prepare(account: AuthAccount){\n        let adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n        let rules = [\n            FindMarket.TenantRule(name:\"nft\", types:[Type\u003c@Dandy.NFT\u003e()], ruleType:\"nft\", allow:false) \n        ]\n        let item = FindMarket.TenantSaleItem(name:\"Block Dandy\", cut:nil, rules:rules, status:\"active\")\n        adminRef.addFindBlockItem(tenant: tenant, item: item)\n    }\n}",
               "spec": {
                  "order": [
                     "tenant"
                  ],
                  "parameters": {
                     "tenant": "Address"
                  }
               }
            },
            "testBlockItemByListingType": {
               "code": "import Admin from 0x097bafa4e0b48eef\nimport FindMarket from 0x097bafa4e0b48eef\nimport Dandy from 0x097bafa4e0b48eef\n\ntransaction(tenant: Address){\n    prepare(account: AuthAccount){\n        let adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n        let rules = [\n            FindMarket.TenantRule(name:\"nft\", types:[Type\u003c@Dandy.NFT\u003e()], ruleType:\"nft\", allow:false) ,\n            FindMarket.TenantRule(name:\"listing\", types:FindMarket.getSaleItemTypes(), ruleType:\"listing\", allow:false) \n        ]\n        let item = FindMarket.TenantSaleItem(name:\"Block Dandy\", cut:nil, rules:rules, status:\"active\")\n        adminRef.addFindBlockItem(tenant: tenant, item: item)\n    }\n}",
               "spec": {
                  "order": [
                     "tenant"
                  ],
                  "parameters": {
                     "tenant": "Address"
                  }
               }
            },
            "testClock": {
               "code": "import Admin from 0x097bafa4e0b48eef\n\ntransaction(clock: UFix64) {\n    prepare(account: AuthAccount) {\n\n        let adminClient=account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath)!\n        adminClient.advanceClock(clock)\n\n    }\n}",
               "spec": {
                  "order": [
                     "clock"
                  ],
                  "parameters": {
                     "clock": "UFix64"
                  }
               }
            },
            "testDestroyDandies": {
               "code": "import Dandy from 0x097bafa4e0b48eef\n\n\ntransaction(ids: [UInt64]) {\n    prepare(account: AuthAccount) {\n\n        let dandyRef= account.borrow\u003c\u0026Dandy.Collection\u003e(from: Dandy.CollectionStoragePath) ?? panic(\"Cannot borrow reference to Dandy Collection\")\n        for id in ids {\n            destroy dandyRef.withdraw(withdrawID: id)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "ids"
                  ],
                  "parameters": {
                     "ids": "[UInt64]"
                  }
               }
            },
            "testDestroyDandyCollection": {
               "code": "import Dandy from 0x097bafa4e0b48eef\n\n\ntransaction() {\n    prepare(account: AuthAccount) {\n        destroy account.load\u003c@Dandy.Collection\u003e(from: Dandy.CollectionStoragePath)\n    }\n}",
               "spec": null
            },
            "testDestroyFUSDVault": {
               "code": "import FUSD from 0x3c5959b568896393\n\n\ntransaction() {\n    prepare(account: AuthAccount) {\n        destroy account.load\u003c@FUSD.Vault\u003e(from: /storage/fusdVault) ?? panic(\"Cannot load flow token vault\")\n    }\n}",
               "spec": null
            },
            "testListStorefront": {
               "code": "import FungibleToken from 0xf233dcee88fe0abe\nimport NonFungibleToken from 0x1d7e57aa55817448\nimport FlowToken from 0x1654653399040a61\nimport Dandy from 0x097bafa4e0b48eef\nimport NFTStorefront from 0x4eb8a10cb9f87357\nimport MetadataViews from 0x1d7e57aa55817448\n\n\n\n//this has to be called after we have listed it somewhere else because of cap\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64) {\n    let flowReceiver: Capability\u003c\u0026FlowToken.Vault{FungibleToken.Receiver}\u003e\n    let exampleNFTProvider: Capability\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e\n    let storefront: \u0026NFTStorefront.Storefront\n\n    prepare(acct: AuthAccount) {\n\n             // If the account doesn't already have a Storefront\n        if acct.borrow\u003c\u0026NFTStorefront.Storefront\u003e(from: NFTStorefront.StorefrontStoragePath) == nil {\n\n            // Create a new empty .Storefront\n            let storefront \u003c- NFTStorefront.createStorefront() as @NFTStorefront.Storefront\n            \n            // save it to the account\n            acct.save(\u003c-storefront, to: NFTStorefront.StorefrontStoragePath)\n\n            // create a public capability for the .Storefront\n            acct.link\u003c\u0026NFTStorefront.Storefront{NFTStorefront.StorefrontPublic}\u003e(NFTStorefront.StorefrontPublicPath, target: NFTStorefront.StorefrontStoragePath)\n        }\n\n        // We need a provider capability, but one is not provided by default so we create one if needed.\n        let exampleNFTCollectionProviderPrivatePath = /private/exampleNFTCollectionProviderForNFTStorefront\n\n        self.flowReceiver = acct.getCapability\u003c\u0026FlowToken.Vault{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver)\n        assert(self.flowReceiver.borrow() != nil, message: \"Missing or mis-typed FlowToken receiver\")\n        self.exampleNFTProvider = acct.getCapability\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPrivatePath)\n        assert(self.exampleNFTProvider.borrow() != nil, message: \"Missing or mis-typed ExampleNFT.Collection provider\")\n\n        self.storefront = acct.borrow\u003c\u0026NFTStorefront.Storefront\u003e(from: NFTStorefront.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n    }\n\n    execute {\n        let saleCut = NFTStorefront.SaleCut(\n            receiver: self.flowReceiver,\n            amount: saleItemPrice\n        )\n        self.storefront.createListing(\n            nftProviderCapability: self.exampleNFTProvider,\n            nftType: Type\u003c@Dandy.NFT\u003e(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type\u003c@FlowToken.Vault\u003e(),\n            saleCuts: [saleCut]\n        )\n    }\n}",
               "spec": {
                  "order": [
                     "saleItemID",
                     "saleItemPrice"
                  ],
                  "parameters": {
                     "saleItemID": "UInt64",
                     "saleItemPrice": "UFix64"
                  }
               }
            },
            "testMintDandyTO": {
               "code": "import FIND from 0x097bafa4e0b48eef\nimport NonFungibleToken from 0x1d7e57aa55817448\nimport FungibleToken from 0xf233dcee88fe0abe\nimport Dandy from 0x097bafa4e0b48eef\nimport Profile from 0x097bafa4e0b48eef\nimport MetadataViews from 0x1d7e57aa55817448\nimport FindViews from 0x097bafa4e0b48eef\n\ntransaction(name: String, maxEdition:UInt64, artist:String, nftName:String, nftDescription:String, nftUrl:String, rarity: String, rarityNum:UFix64, to: Address) {\n    prepare(account: AuthAccount) {\n\n        let dancyReceiver =getAccount(to)\n        let dandyCap= dancyReceiver.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            panic(\"need dandy receicer\")\n        }\n\n        let finLeases= account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n\n        let creativeWork=\n        FindViews.CreativeWork(artist: artist, name: nftName, description: nftDescription, type:\"image\")\n\n        let httpFile=MetadataViews.HTTPFile(url:nftUrl)\n        let media=MetadataViews.Media(file: httpFile, mediaType: \"image/thumbnail\")\n\n        let rarity = FindViews.Rarity(rarity: rarityNum, rarityName:rarity, parts: {})\n\n        let receiver=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let minterRoyalty=MetadataViews.Royalties(cutInfos:[MetadataViews.Royalty(receiver: receiver, cut: 0.05, description: \"artist\")])\n\n        let tag=FindViews.Tag({\"NeoMotorCycleTag\":\"Tag1\"})\n        let scalar=FindViews.Scalar({\"Speed\" : 100.0})\n\n        let collection=dandyCap.borrow()!\n        var i:UInt64=1\n\n        while i \u003c= maxEdition {\n            let editioned= MetadataViews.Edition(name: \"nft\", number:i, max:maxEdition)\n            let description=creativeWork.description.concat( \" edition \").concat(i.toString()).concat( \" of \").concat(maxEdition.toString())\n            let schemas: [AnyStruct] = [ MetadataViews.Editions([editioned]), creativeWork, minterRoyalty, rarity, tag, scalar, FindViews.Medias([media])]\n            let token \u003c- finLeases.mintDandy(minter: name, \n              nftName: \"Neo Motorcycle \".concat(i.toString()).concat(\" of \").concat(maxEdition.toString()), \n                description: creativeWork.description,\n                thumbnail: media,\n                schemas: schemas, \n                externalUrlPrefix: \"https://find.xyz/collection/\".concat(name).concat(\"/dandy\"),\n                collectionDescription: \"Neo Collectibles FIND\",\n                collectionExternalURL: \"https://neomotorcycles.co.uk/index.html\",\n                collectionSquareImage: \"https://neomotorcycles.co.uk/assets/img/neo_motorcycle_side.webp\",\n                collectionBannerImage: \"https://neomotorcycles.co.uk/assets/img/neo-logo-web-dark.png?h=5a4d226197291f5f6370e79a1ee656a1\",\n            )\n\n            collection.deposit(token: \u003c- token)\n            i=i+1\n        }\n        i = 1\n\n        while i \u003c= maxEdition {\n            let editioned= MetadataViews.Edition(name: \"nft\", number:i, max:maxEdition)\n            let artCreativeWork=FindViews.CreativeWork(artist: artist, name: \"xtingle \", description: \"xtingle_NFT\", type:\"video/mp4\")\n            let description=artCreativeWork.description.concat( \" edition \").concat(i.toString()).concat( \" of \").concat(maxEdition.toString())\n            let artHttpFile=MetadataViews.HTTPFile(url:\"https://nft.blocto.app/xtingles/xBloctopus.mp4\")\n            let thumbnailFile=MetadataViews.HTTPFile(url:\"https://nft.blocto.app/xtingles/preview-xBloctopus.png\")\n            let artMedia=MetadataViews.Media(file: artHttpFile, mediaType: \"video\")\n            let thumbnailMedia=MetadataViews.Media(file: thumbnailFile, mediaType: \"image/thumbnail\")\n            let artTag=FindViews.Tag({\"xtingle Tag\":\"Tag1\"})\n            let artScalar=FindViews.Scalar({\"video length\" : 27.0})\n\n            let schemas: [AnyStruct] = [ MetadataViews.Editions([editioned]), artCreativeWork, artMedia, minterRoyalty, rarity, artTag, artScalar, FindViews.Medias([artMedia, thumbnailMedia])]\n            let token \u003c- finLeases.mintDandy(minter: name, \n              nftName: \"xtingle \".concat(i.toString()).concat(\" of \").concat(maxEdition.toString()), \n                description: artCreativeWork.description,\n                thumbnail: thumbnailMedia,\n                schemas: schemas, \n                externalUrlPrefix: \"https://nft.blocto.app/xtingles/\",\n                collectionDescription: \"xtingle FIND\",\n                collectionExternalURL: \"https://xtingles.com/\",\n                collectionSquareImage: \"https://xtingles-strapi-prod.s3.us-east-2.amazonaws.com/copy_of_upcoming_drops_db41fbf287.png\",\n                collectionBannerImage: \"https://xtingles.com/images/main-metaverse.png\",\n            )\n\n            collection.deposit(token: \u003c- token)\n            i=i+1\n        }\n        i = 1\n\n        while i \u003c= maxEdition {\n            let editioned= MetadataViews.Edition(name: \"nft\", number:i, max:maxEdition)\n            let artCreativeWork=FindViews.CreativeWork(artist: artist, name: \"flovatar \", description: \"flovatar_NFT\", type:\"image\")\n            let description=artCreativeWork.description.concat( \" edition \").concat(i.toString()).concat( \" of \").concat(maxEdition.toString())\n            let artHttpFile=MetadataViews.HTTPFile(url:\"https://flovatar.com/flovatars/1225/0x92ba5cba77fc1e87\")\n            let artMedia=MetadataViews.Media(file: artHttpFile, mediaType: \"image\")\n            let artTag=FindViews.Tag({\"flovatar Tag\":\"Tag1\"})\n            let artScalar=FindViews.Scalar({\"rarity score\" : 2.2})\n\n            let schemas: [AnyStruct] = [ MetadataViews.Editions([editioned]), artCreativeWork, artMedia, minterRoyalty, rarity, artTag, artScalar, FindViews.Medias([artMedia])]\n            let token \u003c- finLeases.mintDandy(minter: name, \n              nftName: \"flovatar \".concat(i.toString()).concat(\" of \").concat(maxEdition.toString()), \n                description: artCreativeWork.description,\n                thumbnail: artMedia,\n                schemas: schemas, \n                externalUrlPrefix: \"https://flovatar.com/flovatars/\",\n                collectionDescription: \"flovatar FIND\",\n                collectionExternalURL: \"https://flovatar.com/\",\n                collectionSquareImage: \"https://miro.medium.com/max/1080/1*nD3N5BvxvH-wgLW1KPizoA.png\",\n                collectionBannerImage: \"https://miro.medium.com/max/1400/1*WjFBUweGaThcTR-UOZ6TnA.gif\",\n            )\n\n            collection.deposit(token: \u003c- token)\n            i=i+1\n        }\n        i = 1\n\n        while i \u003c= maxEdition {\n            let editioned= MetadataViews.Edition(name: \"nft\", number:i, max:maxEdition)\n            let artCreativeWork=FindViews.CreativeWork(artist: artist, name: \"ufcstrike \", description: \"ufcstrike_NFT\", type:\"video/ipfs\")\n            let description=artCreativeWork.description.concat( \" edition \").concat(i.toString()).concat( \" of \").concat(maxEdition.toString())\n            let artHttpFile=MetadataViews.IPFSFile(cid:\"QmdDJUobzSaFfg8PwZZcCB3cPwbZ8pthRf1x6XiR9xwS3U\", path:nil)\n            let thumbnailHttpFile=MetadataViews.IPFSFile(cid:\"QmeDLGnYNyunkTjd23yx36sHviWyR9L2shHshjwe1qBCqR\", path:nil)\n            let artMedia=MetadataViews.Media(file: artHttpFile, mediaType: \"image/ipfs\")\n            let thumbnailMedia=MetadataViews.Media(file: thumbnailHttpFile, mediaType: \"image/thumbnail\")\n\n            let artTag=FindViews.Tag({\"ufcstrike Tag\":\"Tag1\"})\n            let artScalar=FindViews.Scalar({\"rank\" : 295.0})\n\n            let schemas: [AnyStruct] = [ MetadataViews.Editions([editioned]), artCreativeWork, artMedia, minterRoyalty, rarity, artTag, artScalar, FindViews.Medias([artMedia, thumbnailMedia])]\n            let token \u003c- finLeases.mintDandy(minter: name, \n              nftName: \"ufcstrike \".concat(i.toString()).concat(\" of \").concat(maxEdition.toString()), \n                description: artCreativeWork.description,\n                thumbnail: thumbnailMedia,\n                schemas: schemas, \n                externalUrlPrefix: \"https://giglabs.mypinata.cloud/ipfs/\",\n                collectionDescription: \"ufc strike FIND\",\n                collectionExternalURL: \"https://ufcstrike.com/\",\n                collectionSquareImage: \"https://assets.website-files.com/62605ca984796169418ca5dc/628e9bba372af61fcf967e03_round-one-standard-p-1080.png\",\n                collectionBannerImage: \"https://s3.us-east-2.amazonaws.com/giglabs.assets.ufc/4f166ac23e10bb510319e82fe9ed2c7d\",\n            )\n\n            collection.deposit(token: \u003c- token)\n            i=i+1\n        }\n\n    \n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "maxEdition",
                     "artist",
                     "nftName",
                     "nftDescription",
                     "nftUrl",
                     "rarity",
                     "rarityNum",
                     "to"
                  ],
                  "parameters": {
                     "artist": "String",
                     "maxEdition": "UInt64",
                     "name": "String",
                     "nftDescription": "String",
                     "nftName": "String",
                     "nftUrl": "String",
                     "rarity": "String",
                     "rarityNum": "UFix64",
                     "to": "Address"
                  }
               }
            },
            "testMintFlow": {
               "code": "import FungibleToken from 0xf233dcee88fe0abe\nimport FlowToken from 0x1654653399040a61\n\ntransaction(recipient: Address, amount: UFix64) {\n    let tokenAdmin: \u0026FlowToken.Administrator\n    let tokenReceiver: \u0026{FungibleToken.Receiver}\n\n    prepare(signer: AuthAccount) {\n\n        self.tokenAdmin = signer\n            .borrow\u003c\u0026FlowToken.Administrator\u003e(from: /storage/flowTokenAdmin)\n            ?? panic(\"Signer is not the token admin\")\n\n        self.tokenReceiver = getAccount(recipient)\n            .getCapability(/public/flowTokenReceiver)\n            .borrow\u003c\u0026{FungibleToken.Receiver}\u003e()\n            ?? panic(\"Unable to borrow receiver reference\")\n    }\n\n    execute {\n        let minter \u003c- self.tokenAdmin.createNewMinter(allowedAmount: amount)\n        let mintedVault \u003c- minter.mintTokens(amount: amount)\n\n        self.tokenReceiver.deposit(from: \u003c-mintedVault)\n\n        destroy minter\n    }\n}",
               "spec": {
                  "order": [
                     "recipient",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "recipient": "Address"
                  }
               }
            },
            "testMintFusd": {
               "code": "import FungibleToken from 0xf233dcee88fe0abe\nimport FUSD from 0x3c5959b568896393\n\ntransaction(recipient: Address, amount: UFix64) {\n    let tokenAdmin: \u0026FUSD.Administrator\n    let tokenReceiver: \u0026{FungibleToken.Receiver}\n\n    prepare(signer: AuthAccount) {\n\n        self.tokenAdmin = signer\n        .borrow\u003c\u0026FUSD.Administrator\u003e(from: /storage/fusdAdmin)\n        ?? panic(\"Signer is not the token admin\")\n\n        self.tokenReceiver = getAccount(recipient)\n        .getCapability(/public/fusdReceiver)\n        .borrow\u003c\u0026{FungibleToken.Receiver}\u003e()\n        ?? panic(\"Unable to borrow receiver reference\")\n    }\n\n    execute {\n\n\n\n        let minter \u003c- self.tokenAdmin.createNewMinter()\n        let mintedVault \u003c- minter.mintTokens(amount: amount)\n\n        self.tokenReceiver.deposit(from: \u003c-mintedVault)\n\n        destroy minter\n    }\n}",
               "spec": {
                  "order": [
                     "recipient",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "recipient": "Address"
                  }
               }
            },
            "testMintUsdc": {
               "code": "import FungibleToken from 0xf233dcee88fe0abe\nimport FiatToken from 0xb19436aae4d94622\n\ntransaction(recipient: Address, amount: UFix64) {\n    let tokenAdmin: \u0026FiatToken.Administrator\n    let tokenReceiver: \u0026{FungibleToken.Receiver}\n\n    prepare(signer: AuthAccount) {\n\n        self.tokenAdmin = signer.borrow\u003c\u0026FiatToken.Administrator\u003e(from: FiatToken.AdminStoragePath)\n        ?? panic(\"Signer is not the token admin\")\n\n        self.tokenReceiver = getAccount(recipient)\n        .getCapability(FiatToken.VaultReceiverPubPath)\n        .borrow\u003c\u0026{FungibleToken.Receiver}\u003e()\n        ?? panic(\"Unable to borrow receiver reference\")\n    }\n\n    execute {\n        let minter \u003c- self.tokenAdmin.createNewMinter()\n        let mintedVault \u003c- minter.mintTokens(amount: amount)\n\n        self.tokenReceiver.deposit(from: \u003c-mintedVault)\n\n        destroy minter\n    }\n}",
               "spec": {
                  "order": [
                     "recipient",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "recipient": "Address"
                  }
               }
            },
            "testSetResidualAddress": {
               "code": "import Admin from 0x097bafa4e0b48eef\n\ntransaction(address: Address) {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n        \n    }\n\n    execute{\n        self.adminRef.setResidualAddress(address)\n    }\n}",
               "spec": {
                  "order": [
                     "address"
                  ],
                  "parameters": {
                     "address": "Address"
                  }
               }
            },
            "testSetSellNeoTestnetRules": {
               "code": "import FindMarket from 0x097bafa4e0b48eef\nimport Admin from 0x097bafa4e0b48eef\nimport FlowToken from 0x1654653399040a61\nimport NeoVoucher from 0xd6b39e5b5b367aad\n\n\ntransaction(tenant: Address){\n    prepare(account: AuthAccount){\n        let adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n\n        let saleItem = FindMarket.TenantSaleItem(name:\"FlowNeo\", cut: nil, rules:[\n            FindMarket.TenantRule(name:\"Flow\", types:[Type\u003c@FlowToken.Vault\u003e()], ruleType: \"ft\", allow: true),\n            FindMarket.TenantRule(name:\"Neo\", types:[ Type\u003c@NeoVoucher.NFT\u003e()], ruleType: \"nft\", allow: true)\n            ], \n            status: \"active\"\n        )\n\n        adminRef.setMarketOption(tenant: tenant, saleItem: saleItem)\n    }\n}",
               "spec": {
                  "order": [
                     "tenant"
                  ],
                  "parameters": {
                     "tenant": "Address"
                  }
               }
            }
         }
      },
      "testnet": {
         "scripts": {
            "getCheckRoyalty": {
               "code": "import MetadataViews from 0x631e88ae7f1d7c20\nimport FIND from 0x39937dba71a38820\nimport NFTRegistry from 0x39937dba71a38820\n\npub fun main(name: String, id: UInt64, nftAliasOrIdentifier: String, viewIdentifier: String) : AnyStruct? {\n\n    let address =FIND.lookupAddress(name)!\n\n    // Get collection public path from NFT Registry\n    let nftInfo = NFTRegistry.getNFTInfo(nftAliasOrIdentifier) ?? panic(\"This NFT is not supported by the Find Market yet\")\n    let collectionPublicPath = nftInfo.publicPath\n    let collection= getAccount(address).getCapability(collectionPublicPath).borrow\u003c\u0026{MetadataViews.ResolverCollection}\u003e()!\n\n    let nft=collection.borrowViewResolver(id: id)\n    for v in nft.getViews() {\n        if v.identifier== viewIdentifier {\n            return nft.resolveView(v)\n        }\n    }\n    return nil\n}",
               "spec": {
                  "order": [
                     "name",
                     "id",
                     "nftAliasOrIdentifier",
                     "viewIdentifier"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "name": "String",
                     "nftAliasOrIdentifier": "String",
                     "viewIdentifier": "String"
                  }
               }
            },
            "getCollectionIndex": {
               "code": "import MetadataViews from 0x631e88ae7f1d7c20\nimport NFTRegistry from 0x39937dba71a38820\nimport FIND from 0x39937dba71a38820\n\npub fun main(user: String) : {String : [UInt64]} {\n    if let address = FIND.resolve(user) {\n        var resultMap : {String : [UInt64]} = {}\n        let account = getAccount(address)\n        for nftInfo in NFTRegistry.getNFTInfoAll().values {\n            let publicPath = nftInfo.publicPath\n            let alias = nftInfo.alias\n            let resolverCollectionCap= account.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(publicPath)\n            if resolverCollectionCap.check() {\n                let collection = resolverCollectionCap.borrow()!\n                resultMap[alias] = collection.getIDs()\n            }\n        }\n\n        return resultMap\n    }\n    return {}\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "getCollections": {
               "code": "import MetadataViews from 0x631e88ae7f1d7c20\nimport NFTRegistry from 0x39937dba71a38820\nimport FindViews from 0x39937dba71a38820\nimport FIND from 0x39937dba71a38820\n\npub struct MetadataCollections {\n\n    pub let items: {String : MetadataCollectionItem}\n    pub let collections: {String : [String]}\n    // supports new contracts that supports metadataViews \n    pub let curatedCollections: {String : [String]}\n\n    init(items: {String : MetadataCollectionItem}, collections: {String : [String]}, curatedCollections: {String: [String]}) {\n        self.items=items\n        self.collections=collections\n        self.curatedCollections=curatedCollections\n    }\n}\n\n\npub struct MetadataCollection{\n    pub let type: String\n    pub let items: [MetadataCollectionItem]\n\n    init(type:String, items: [MetadataCollectionItem]) {\n        self.type=type\n        self.items=items\n    }\n}\n\n// Collection Index.cdc Address : [{Path, ID}]\n/* \n    pub struct CollectionItemPointer {\n        pub let path \n        pub let id \n    }\n */\n// Need : A metadata collection index : -\u003e path, id, collection (Where do you want to group them)\n// A list of these for all the items (Like collections and cur)\n\n// Resolve Partial Collection.cdc Address, {path : [IDs]}\n// Address\n// [path1 , path1, path2]\n// [id1 , id2, id3]\n// Another list -\u003e take these path, id, collection and return the specific collection information (similar in collections)\n\npub struct MetadataCollectionItem {\n    pub let id:UInt64\n    pub let typeIdentifier: String\n    pub let uuid: UInt64 \n    pub let name: String\n    pub let image: String\n    pub let url: String\n    pub let contentType:String\n    pub let rarity:String\n    //Refine later \n    pub let metadata: {String : String}\n    pub let collection: String // \u003c- This will be Alias unless they want something else\n    pub let tag: {String : String}\n    pub let scalar: {String : UFix64}\n\n    init(id:UInt64, type: Type, uuid: UInt64, name:String, image:String, url:String, contentType: String, rarity: String, collection: String, tag: {String : String}, scalar: {String : UFix64}) {\n        self.id=id\n        self.typeIdentifier = type.identifier\n        self.uuid = uuid\n        self.name=name\n        self.url=url\n        self.image=image\n        self.contentType=contentType\n        self.rarity=rarity\n        self.metadata={}\n        self.collection=collection\n        self.tag=tag\n        self.scalar=scalar\n    }\n}\n\npub fun main(user: String) : MetadataCollections? {\n\n    let resolvingAddress = FIND.resolve(user)\n    if resolvingAddress == nil {\n        return nil\n    }\n    let address = resolvingAddress!\n    var resultMap : {String : MetadataCollectionItem} = {}\n    let account = getAccount(address)\n    let results : {String :  [String]}={}\n\n    for nftInfo in NFTRegistry.getNFTInfoAll().values {\n        let items: [String] = []\n        let resolverCollectionCap= account.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(nftInfo.publicPath)\n        if resolverCollectionCap.check() {\n            let collection = resolverCollectionCap.borrow()!\n            for id in collection.getIDs() {\n                let nft = collection.borrowViewResolver(id: id) \n                \n                if let display= FindViews.getDisplay(nft) {\n                    var externalUrl=nftInfo.externalFixedUrl\n\n                    if let externalUrlViw=FindViews.getExternalURL(nft) { \n                        externalUrl=externalUrlViw.url\n                    }\n\n                    var rarity=\"\"\n                    if let r = FindViews.getRarity(nft) {\n                        rarity=r.rarityName\n                    }\n\n                    var tag : {String : String}={}\n                    if let t= FindViews.getTags(nft) {\n                        tag=t.getTag()\n                    }            \n\n                    var scalar : {String : UFix64}={}\n                    if let s= FindViews.getScalar(nft) {\n                        scalar=s.getScalar()\n                    }                \n\n                    let item = MetadataCollectionItem(\n                        id: id,\n                        type: nft.getType() ,\n                        uuid: nft.uuid ,\n                        name: display.name,\n                        image: display.thumbnail.uri(),\n                        url: externalUrl,\n                        contentType: \"image\",\n                        rarity: rarity,\n                        collection: nftInfo.alias,\n                        tag: tag,\n                        scalar: scalar\n                    )\n                    let itemId = nftInfo.alias.concat(item.id.toString())\n                    items.append(itemId)\n                    resultMap.insert(key:itemId, item)\n                }\n            }\n            results[nftInfo.alias] = items\n        }\n    }\n\n    let publicPath=/public/FindCuratedCollections\n    let link = account.getCapability\u003c\u0026{String: [String]}\u003e(publicPath)\n    var curatedCollections : {String: [String]} = {}\n    if link.check() {\n        let curated = link.borrow()!\n        for curatedKey in curated.keys {\n            curatedCollections[curatedKey] = curated[curatedKey]!\n        }\n    }\n\n    return MetadataCollections(items: resultMap, collections:results, curatedCollections: curatedCollections)\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "getCuratedCollections": {
               "code": "pub fun main(address: Address) : \u0026{String: [String]}? {\n    let account=getAccount(address)\n    let publicPath=/public/FindCuratedCollections\n    let link = account.getCapability\u003c\u0026{String: [String]}\u003e(publicPath)\n    if link.check() {\n        return link.borrow()\n    }\n    return nil\n}",
               "spec": {
                  "order": [
                     "address"
                  ],
                  "parameters": {
                     "address": "Address"
                  }
               }
            },
            "getDandiesIDsFor": {
               "code": "import Dandy from 0x39937dba71a38820\nimport FIND from 0x39937dba71a38820\n\npub fun main(user: String, minter: String) : [UInt64] {\n    let address = FIND.resolve(user)\n    if address == nil {\n        return []\n    }\n    let account = getAccount(address!)\n    let cap = account.getCapability\u003c\u0026Dandy.Collection{Dandy.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n    let ref = cap.borrow() ?? panic(\"Cannot borrow reference to Dandy Collection\")\n\n    return ref.getIDsFor(minter: minter)\n}",
               "spec": {
                  "order": [
                     "user",
                     "minter"
                  ],
                  "parameters": {
                     "minter": "String",
                     "user": "String"
                  }
               }
            },
            "getDandiesMinters": {
               "code": "import Dandy from 0x39937dba71a38820\nimport FIND from 0x39937dba71a38820\n\npub fun main(user: String) : [String] {\n    let address = FIND.resolve(user)\n    if address == nil {\n        return []\n    }\n    let account = getAccount(address!)\n    let cap = account.getCapability\u003c\u0026Dandy.Collection{Dandy.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n    let ref = cap.borrow() ?? panic(\"Cannot borrow reference to Dandy Collection\")\n\n    return ref.getMinters()\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "getFTInfo": {
               "code": "import FTRegistry from 0x39937dba71a38820\n\npub fun main(aliasOrIdentifier: String) : FTRegistry.FTInfo?{\n\n    return FTRegistry.getFTInfo(aliasOrIdentifier)\n\n}",
               "spec": {
                  "order": [
                     "aliasOrIdentifier"
                  ],
                  "parameters": {
                     "aliasOrIdentifier": "String"
                  }
               }
            },
            "getFTInfoAll": {
               "code": "import FTRegistry from 0x39937dba71a38820\n\npub fun main() : {String: FTRegistry.FTInfo}{\n\n    return FTRegistry.getFTInfoAll()\n\n}",
               "spec": null
            },
            "getItem": {
               "code": "import MetadataViews from 0x631e88ae7f1d7c20\nimport FIND from 0x39937dba71a38820\nimport NFTRegistry from 0x39937dba71a38820\n\npub struct MetadataCollectionItem {\n    pub let id:UInt64\n    pub let uuid:UInt64\n    pub let name: String\n    pub let description: String?\n    pub let image: String\n    pub let url: String\n    pub let contentType:String\n    pub let rarity:String\n    pub let minter:String?\n    pub let type:Type\n\n\n    init(id:UInt64, uuid:UInt64, name:String, description:String?, image:String, url:String, contentType: String, rarity: String, minter:String?, type:Type) {\n        self.id=id\n        self.uuid=uuid\n        self.name=name\n        self.description=description\n        self.minter=minter\n        self.url=url\n        self.type=type\n        self.image=image\n        self.contentType=contentType\n        self.rarity=rarity\n    }\n}\n\n\npub fun main(user: String, aliasOrIdentifier: String, id:UInt64) : MetadataCollectionItem?{\n\n    let nftInfo = NFTRegistry.getNFTInfo(aliasOrIdentifier) \n    if nftInfo == nil {panic(\"This NFT is not registered in registry. input: \".concat(aliasOrIdentifier))}\n\n    let resolveAddress = FIND.resolve(user) \n    if resolveAddress == nil {return nil}\n    let address = resolveAddress!\n    let account=getAccount(address)\n    let resolverCollectionCap= account.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(nftInfo!.publicPath)\n    if !resolverCollectionCap.check() {\n        return nil\n    }\n\n    let collection = resolverCollectionCap.borrow()!\n    let nft = collection.borrowViewResolver(id: id)!\n\n    if let displayView = nft.resolveView(Type\u003cMetadataViews.Display\u003e()) {\n        let display = displayView as! MetadataViews.Display\n\n        var externalUrl=\"\"\n        if let externalUrlView = nft.resolveView(Type\u003cMetadataViews.ExternalURL\u003e()) {\n            let edvu= externalUrlView as! MetadataViews.ExternalURL\n            externalUrl=edvu.url\n        }\n        let item = MetadataCollectionItem(\n            id: id,\n            uuid: nft.uuid,\n            name: display.name,\n            description:display.description,\n            image: display.thumbnail.uri(),\n            url: externalUrl,\n            contentType: \"image\",\n            rarity: \"\",\n            minter: \"\",\n            type: nft.getType()\n        )\n        return item\n    }\n    return nil\n}",
               "spec": {
                  "order": [
                     "user",
                     "aliasOrIdentifier",
                     "id"
                  ],
                  "parameters": {
                     "aliasOrIdentifier": "String",
                     "id": "UInt64",
                     "user": "String"
                  }
               }
            },
            "getListings": {
               "code": "import FindMarket from 0x39937dba71a38820 \nimport FIND from 0x39937dba71a38820 \n\npub fun main(marketplace:Address, user: String) : {String : FindMarket.SaleItemCollectionReport} {\n    let resolveAddress = FIND.resolve(user)\n    if resolveAddress == nil { return {}}\n    let address = resolveAddress!\n        return FindMarket.getSaleItemReport(tenant:marketplace, address: address, getNFTInfo:false)\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "user"
                  ],
                  "parameters": {
                     "marketplace": "Address",
                     "user": "String"
                  }
               }
            },
            "getMarketBlockedNFT": {
               "code": "import FindMarket from 0x39937dba71a38820 \n\npub fun main() : {String : [String] } {\n    let mapping : {String : [String] } = {}\n\n    let findAddress=FindMarket.getFindTenantAddress()\n    let tenantCap = FindMarket.getTenantCapability(findAddress)!\n    let tenantRef = tenantCap.borrow() ?? panic(\"This tenant is not set up.\")\n    let marketTypes = FindMarket.getSaleItemTypes()\n    for marketType in marketTypes {\n        let list : [String] = []\n        for type in tenantRef.getBlockedNFT(marketType: marketType) {\n            list.append(type.identifier)\n        }\n        mapping[FindMarket.getMarketOptionFromType(marketType)] = list\n    }\n\nreturn mapping\n}",
               "spec": null
            },
            "getNFTDetails": {
               "code": "import FindMarket from 0x39937dba71a38820 \nimport FindViews from 0x39937dba71a38820 \nimport FIND from 0x39937dba71a38820 \nimport MetadataViews from 0x631e88ae7f1d7c20\nimport NFTStorefront from 0x94b06cfca1d8a476\nimport NFTRegistry from 0x39937dba71a38820\nimport FTRegistry from 0x39937dba71a38820\n\npub struct NFTDetailReport {\n    pub let findMarket: {String : FindMarket.SaleItemInformation}\n    pub let storefront: StorefrontListing?\n    pub let nftDetail: NFTDetail?\n    pub let allowedListingActions: {String : ListingTypeReport}\n\n    init(findMarket:{String : FindMarket.SaleItemInformation}, storefront: StorefrontListing?, nftDetail: NFTDetail?, allowedListingActions: {String : ListingTypeReport}) {\n        self.findMarket=findMarket\n        self.storefront=storefront\n        self.nftDetail=nftDetail\n        self.allowedListingActions=allowedListingActions\n    }\n}\n\npub struct ListingTypeReport {\n    pub let listingType: String \n    pub let ftAlias: [String] \n    pub let ftIdentifiers: [String] \n    pub let status: String \n\n    init(listingType: String, ftAlias: [String], ftIdentifiers: [String],  status: String ) {\n        self.listingType=listingType \n        self.ftAlias=ftAlias \n        self.ftIdentifiers=ftIdentifiers \n        self.status=status\n    }\n}\n\npub struct NFTDetail {\n    pub let id: UInt64 \n    pub let uuid: UInt64 \n    pub let name:String\n    pub let thumbnail:String\n    pub let type: String\n    pub var rarity:String?\n    pub var royalties: [Royalties]\n    pub var editionNumber: UInt64? \n    pub var totalInEdition: UInt64?\n    pub var scalars : {String: UFix64}\n    pub var tags : {String: String}\n    pub var media: [MetadataViews.Media]\n    pub var collectionName: String? \n    pub var collectionDescription: String? \n    pub var data: {String : AnyStruct?}\n    pub var views :[String]\n\n    init(_ pointer: FindViews.ViewReadPointer, views: {String : AnyStruct}){\n\n        let item = pointer.getViewResolver()\n\n        self.scalars={}\n        self.tags={}\n        self.media=[]\n        self.collectionName=nil\n        self.collectionDescription=nil\n\n        if let grouping=FindViews.getNFTCollectionDisplay(item) {\n            self.collectionName=grouping.name\n            self.collectionDescription=grouping.description\n        }\n\n        /* Rarity */\n        self.rarity=nil\n        if let r = FindViews.getRarity(item) {\n          self.rarity=r.rarityName\n        }\n\n\n        if let t= FindViews.getTags(item) {\n            self.tags=t.getTag()\n        }            \n\n        if let scalar=FindViews.getScalar(item){\n                self.scalars=scalar.getScalar()\n        }\n        /* Medias */\n        let mediaView=item.resolveView(Type\u003cFindViews.Medias\u003e())\n        if mediaView != nil {\n            let view = mediaView!\n            if view as? FindViews.Medias != nil {\n                let media = view as! FindViews.Medias\n                self.media=media.items\n            }\n        }\n    \n\n        let display = FindViews.getDisplay(item) ?? panic(\"Could not find display\")\n        self.name=display.name\n        self.thumbnail=display.thumbnail.uri()\n        self.type=item.getType().identifier\n        self.id=pointer.id\n        self.uuid=pointer.getUUID()\n\n        /* Edition */\n        self.editionNumber=nil\n        self.totalInEdition=nil\n            if let editions = FindViews.getEditions(item) {\n                for edition in editions.infoList {\n                    if edition.name == nil {\n                        self.editionNumber=edition.number\n                        self.totalInEdition=edition.max\n                    } else {\n                        self.scalars[\"edition_\".concat(edition.name!).concat(\"_number\")] = UFix64(edition.number)\n                        if edition.max != nil {\n                            self.scalars[\"edition_\".concat(edition.name!).concat(\"_max\")] = UFix64(edition.max!)\n                        }\n                    }\n                }\n            }\n\n        /* Royalties */\n        self.royalties=resolveRoyalties(pointer)\n        self.data=views\n\n        self.views=[]\n        for view in item.getViews() {\n            if ignoreViews().contains(view) {\n                continue\n            }\n            self.views.append(view.identifier)\n        }\n    }\n\n}\n\npub struct StoreFrontCut {\n\n    pub let amount:UFix64\n    pub let address: Address\n    pub let findName:String?\n\n    init(amount:UFix64, address:Address){\n        self.amount=amount\n        self.address=address\n        self.findName= FIND.reverseLookup(address)\n    }\n}\n\npub struct Royalties {\n\n    pub let royaltyName: String \n    pub let address: Address \n    pub let findName: String? \n    pub let cut: UFix64 \n\n    init(royaltyName: String , address: Address, findName: String?, cut: UFix64) {\n        self.royaltyName=royaltyName \n        self.address=address \n        self.findName=findName \n        self.cut=cut\n    }\n}\n\npub struct StorefrontListing {\n    pub let nftID:UInt64\n    pub let nftIdentifier: String\n    pub let saleCut: [StoreFrontCut]\n    pub let amount:UFix64\n    pub let ftTypeIdentifier:String\n    pub let storefront:UInt64\n    pub let listingID:UInt64\n\n    init(listingId:UInt64, details: NFTStorefront.ListingDetails) {\n\n        self.saleCut=[]\n        self.nftID=details.nftID\n        self.nftIdentifier=details.nftType.identifier\n        for cutDetails in details.saleCuts {\n            self.saleCut.append(StoreFrontCut(amount:cutDetails.amount, address:cutDetails.receiver.address))\n        }\n        self.amount=details.salePrice\n        self.ftTypeIdentifier=details.salePaymentVaultType.identifier\n        self.storefront=details.storefrontID\n        self.listingID=listingId\n    }\n}\n\npub fun main(user: String, nftAliasOrIdentifier:String, id: UInt64, views: [String]) : NFTDetailReport?{\n    let resolveAddress = FIND.resolve(user) \n    if resolveAddress == nil {\n        return nil\n    }\n    let address = resolveAddress!\n\n    let account = getAccount(address) \n    let publicPath = NFTRegistry.getNFTInfo(nftAliasOrIdentifier)?.publicPath ?? panic(\"This NFT is not supported by NFT Registry\")\n    let cap = account.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(publicPath)\n    let pointer = FindViews.ViewReadPointer(cap: cap, id: id)\n\n    let nftDetail = getNFTDetail(pointer:pointer, views: views)\n    if nftDetail == nil {\n        return nil\n    }\n\n\n    let findAddress=FindMarket.getFindTenantAddress()\n    let findMarket=FindMarket.getNFTListing(tenant:findAddress, address: address, id: nftDetail!.uuid, getNFTInfo:false)\n\n    var listings : StorefrontListing? = nil\n    let storefrontCap = account.getCapability\u003c\u0026NFTStorefront.Storefront{NFTStorefront.StorefrontPublic}\u003e(NFTStorefront.StorefrontPublicPath)\n\n    if storefrontCap.check() {\n        let storefrontRef=storefrontCap.borrow()!\n        for listingId in storefrontRef.getListingIDs() {\n            let listing = storefrontRef.borrowListing(listingResourceID: listingId)!\n            let nft=listing.borrowNFT()\n            if nft.id==id \u0026\u0026 !listing.getDetails().purchased {\n                listings = StorefrontListing(listingId: listingId, details: listing.getDetails())\n            }\n        }\n    }\n\n    let tenantCap = FindMarket.getTenantCapability(findAddress)!\n    let tenantRef = tenantCap.borrow() ?? panic(\"This tenant is not set up.\")\n\n    let marketTypes = FindMarket.getSaleItemTypes()\n    var report : {String : ListingTypeReport} = {}\n    for marketType in marketTypes {\n        if let allowedListing = tenantRef.getAllowedListings(nftType: pointer.getItemType(), marketType: marketType) {\n            report[FindMarket.getMarketOptionFromType(marketType)] = createListingTypeReport(allowedListing)\n        }\n    }\n\n    return NFTDetailReport(findMarket:findMarket, storefront: listings, nftDetail: nftDetail, allowedListingActions: report)\n\n}\n\npub fun getNFTDetail(pointer: FindViews.ViewReadPointer, views: [String]) : NFTDetail? {\n\n    if !pointer.valid() {\n        return nil\n    }\n\n    let viewTypes = pointer.getViews() \n    var nftViews: {String : AnyStruct} = {}\n    for viewType in viewTypes {\n        if views.contains(getType(viewType)) {\n            if let view = pointer.resolveView(viewType) {\n                nftViews[getType(viewType)] = view! \n            }\n        }\n    }\n    return NFTDetail(pointer, views: nftViews)\n\n\n}\n\n/* Helper Function */\npub fun getType(_ type: Type) : String {\n    let identifier = type.identifier\n    var dots = 0\n    var counter = 0 \n    while counter \u003c identifier.length {\n        if identifier[counter] == \".\" {\n            dots = dots + 1\n            if dots == 3 {\n                break\n            }\n        }\n        counter = counter + 1\n    }\n    if dots == 0 {\n        return identifier\n    }\n    if counter + 1 \u003e identifier.length {\n        panic(\"Identifier is \".concat(identifier))\n    }\n    return identifier.slice(from: counter + 1, upTo: identifier.length)\n}\n\npub fun resolveRoyalties(_ pointer: FindViews.ViewReadPointer) : [Royalties] {\n    let array : [Royalties] = []\n    for royalty in pointer.getRoyalty().getRoyalties() {\n        let address = royalty.receiver.address\n        array.append(Royalties(royaltyName: royalty.description, address: address, findName: FIND.reverseLookup(address), cut: royalty.cut))\n    }\n\n    return array\n}\n\npub fun createListingTypeReport(_ allowedListing: FindMarket.AllowedListing) : ListingTypeReport {\n    let listingType = allowedListing.listingType.identifier\n    var ftAlias : [String] = []\n    var ftIdentifier : [String] = []\n    for ft in allowedListing.ftTypes {\n        ftIdentifier.append(ft.identifier)\n        if let ftInfo = FTRegistry.getFTInfo(ft.identifier) {\n            ftAlias.append(ftInfo.alias)\n        }\n    }\n    return ListingTypeReport(listingType: listingType, ftAlias: ftAlias, ftIdentifiers: ftIdentifier,  status: allowedListing.status )\n}\n\npub fun ignoreViews() : [Type] {\n    return [\n        Type\u003cMetadataViews.NFTCollectionDisplay\u003e() , \n        Type\u003cFindViews.Rarity\u003e() ,\n        Type\u003cFindViews.Tag\u003e() , \n        Type\u003cFindViews.Scalar\u003e() ,\n        Type\u003cFindViews.Medias\u003e() ,\n        Type\u003cMetadataViews.Display\u003e() ,\n        Type\u003cMetadataViews.Edition\u003e() ,\n        Type\u003cMetadataViews.Editions\u003e() \n    ]\n}",
               "spec": {
                  "order": [
                     "user",
                     "nftAliasOrIdentifier",
                     "id",
                     "views"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "nftAliasOrIdentifier": "String",
                     "user": "String",
                     "views": "[String]"
                  }
               }
            },
            "getNFTInfo": {
               "code": "import NFTRegistry from 0x39937dba71a38820\n\npub fun main(aliasOrIdentifier: String) : NFTRegistry.NFTInfo? {\n\n    return NFTRegistry.getNFTInfo(aliasOrIdentifier)\n\n}",
               "spec": {
                  "order": [
                     "aliasOrIdentifier"
                  ],
                  "parameters": {
                     "aliasOrIdentifier": "String"
                  }
               }
            },
            "getNFTInfoAll": {
               "code": "import NFTRegistry from 0x39937dba71a38820\n\npub fun main() : {String: NFTRegistry.NFTInfo}{\n\n    return NFTRegistry.getNFTInfoAll()\n\n}",
               "spec": null
            },
            "getNFTView": {
               "code": "import MetadataViews from 0x631e88ae7f1d7c20\nimport NFTRegistry from 0x39937dba71a38820\nimport FIND from 0x39937dba71a38820\n\n//Fetch a single view from a nft on a given path\npub fun main(user: String, aliasOrIdentifier:String, id: UInt64, identifier: String) : AnyStruct? {\n\n    let nftInfo = NFTRegistry.getNFTInfo(aliasOrIdentifier) \n    if nftInfo == nil {panic(\"This NFT is not registered in registry. input: \".concat(aliasOrIdentifier))}\n    let resolveAddress = FIND.resolve(user) \n    if resolveAddress == nil {return []}\n    let address = resolveAddress!\n\n    let pp = nftInfo!.publicPath\n    let collection= getAccount(address).getCapability(pp).borrow\u003c\u0026{MetadataViews.ResolverCollection}\u003e()!\n\n    let nft=collection.borrowViewResolver(id: id)\n    for v in nft.getViews() {\n        if v.identifier== identifier {\n            return nft.resolveView(v)\n        }\n    }\n    return nil\n}",
               "spec": {
                  "order": [
                     "user",
                     "aliasOrIdentifier",
                     "id",
                     "identifier"
                  ],
                  "parameters": {
                     "aliasOrIdentifier": "String",
                     "id": "UInt64",
                     "identifier": "String",
                     "user": "String"
                  }
               }
            },
            "getNFTViews": {
               "code": "import MetadataViews from 0x631e88ae7f1d7c20\nimport NFTRegistry from 0x39937dba71a38820\nimport FIND from 0x39937dba71a38820\n\n//get all the views for an nft and address/path/id\npub fun main(user: String, aliasOrIdentifier:String, id: UInt64) : [String] {\n    let nftInfo = NFTRegistry.getNFTInfo(aliasOrIdentifier) \n    if nftInfo == nil {panic(\"This NFT is not registered in registry. input: \".concat(aliasOrIdentifier))}\n\n    let resolveAddress = FIND.resolve(user) \n    if resolveAddress == nil {return []}\n    let address = resolveAddress!\n    let pp = nftInfo!.publicPath\n    let collection= getAccount(address).getCapability(pp).borrow\u003c\u0026{MetadataViews.ResolverCollection}\u003e()!\n    let nft=collection.borrowViewResolver(id: id)\n    let views:[String]=[]\n    for v in nft.getViews() {\n        views.append(v.identifier)\n    }\n    return views\n}",
               "spec": {
                  "order": [
                     "user",
                     "aliasOrIdentifier",
                     "id"
                  ],
                  "parameters": {
                     "aliasOrIdentifier": "String",
                     "id": "UInt64",
                     "user": "String"
                  }
               }
            },
            "getName": {
               "code": "import FIND from 0x39937dba71a38820\n\npub fun main(address: Address) : String?{\n    return FIND.reverseLookup(address)\n}",
               "spec": {
                  "order": [
                     "address"
                  ],
                  "parameters": {
                     "address": "Address"
                  }
               }
            },
            "getNameDetails": {
               "code": "import FIND from 0x39937dba71a38820\nimport Profile from 0x39937dba71a38820\nimport RelatedAccounts from 0x39937dba71a38820\n\npub struct FINDReport {\n    pub let profile:Profile.UserReport?\n    pub let bids: [FIND.BidInfo]\n    pub let relatedAccounts: { String: Address}\n    pub let leases: [FIND.LeaseInformation]\n    pub let privateMode: Bool\n\n\n    init(profile: Profile.UserReport?, relatedAccounts: {String: Address}, bids: [FIND.BidInfo], leases : [FIND.LeaseInformation], privateMode: Bool ) {\n        self.profile=profile\n        self.bids=bids\n        self.leases=leases\n        self.relatedAccounts=relatedAccounts\n        self.privateMode=privateMode\n    }\n}\n\npub struct NameReport {\n    pub let status: String\n    pub let cost: UFix64 \n    pub let leaseStatus: FIND.LeaseInformation?\n    pub let userReport: FINDReport? \n\n    init(status: String, cost: UFix64, leaseStatus: FIND.LeaseInformation?, userReport: FINDReport? ) {\n        self.status=status \n        self.cost=cost \n        self.leaseStatus=leaseStatus\n        self.userReport=userReport\n    }\n}\n\npub fun main(user: String) : NameReport? {\n\n    var findReport: FINDReport? = nil\n    var nameLease: FIND.LeaseInformation? = nil\n    if let address=FIND.resolve(user) {\n        let account=getAccount(address)\n        let bidCap = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        let leaseCap = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        let profile=account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath).borrow()\n\n        findReport = FINDReport(\n            profile: profile?.asReport(),\n            relatedAccounts: RelatedAccounts.findRelatedFlowAccounts(address:address),\n            bids: bidCap.borrow()?.getBids() ?? [],\n            leases: leaseCap.borrow()?.getLeaseInformation() ?? [],\n            privateMode: profile?.isPrivateModeEnabled() ?? false\n        )\n        if FIND.validateFindName(user) \u0026\u0026 findReport != nil {\n            for lease in findReport!.leases {\n                if lease.name == user {\n                    nameLease = lease\n                    break\n                }\n            }\n        }\n        \n    }\n\n    var nameReport : NameReport? = nil \n    if FIND.validateFindName(user) {\n        let status = FIND.status(user)\n        let cost=FIND.calculateCost(user)\n        var s=\"TAKEN\"    \n        if status.status == FIND.LeaseStatus.FREE {\n            s=\"FREE\"\n        } else if status.status == FIND.LeaseStatus.LOCKED {\n            s=\"LOCKED\"\n        }\n        nameReport = NameReport(status: s, cost: cost, leaseStatus: nameLease, userReport: findReport)\n    }\n    \n\n    return nameReport\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "getNameStatus": {
               "code": "import FIND from 0x39937dba71a38820\nimport Profile from 0x39937dba71a38820\n\npub fun main(name: String) :  \u0026{Profile.Public}? {\n    return FIND.lookup(name)\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "getNames": {
               "code": "import FIND from 0x39937dba71a38820\n\npub fun main(address: [Address]) : { Address:String}{\n\n    let items : {Address:String} = {}\n    for a in address {\n        if let name= FIND.reverseLookup(a) {\n            items[a]=name\n        }\n    }\n    return items\n}",
               "spec": {
                  "order": [
                     "address"
                  ],
                  "parameters": {
                     "address": "[Address]"
                  }
               }
            },
            "getNamesWithBids": {
               "code": "import FIND from 0x39937dba71a38820\n\npub fun main(user: String) : [FIND.LeaseInformation] {\n\n    let resolveAddress = FIND.resolve(user) \n    if resolveAddress == nil {return []}\n    let address = resolveAddress!\n    let account=getAccount(address)\n    let leaseCap = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\n    let leases=leaseCap.borrow()?.getLeaseInformation() ?? []\n\n    var leasesWithBids :[FIND.LeaseInformation] =[]\n    for lease in leases {\n        if lease.latestBidBy != nil {\n            leasesWithBids.append(lease)\n        }\n    }\n\n    return leasesWithBids\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "getNamesWithoutBids": {
               "code": "import FIND from 0x39937dba71a38820\n\n\npub fun main(user: String) : [String] {\n\n    let resolveAddress = FIND.resolve(user) \n    if resolveAddress == nil {return []}\n    let address = resolveAddress!\n    let account=getAccount(address)\n    let leaseCap = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\n    let leases=leaseCap.borrow()?.getLeaseInformation() ?? []\n\n    var leasesWithBids :[String] =[]\n    for lease in leases {\n        if lease.latestBidBy == nil {\n            leasesWithBids.append(lease.name)\n        }\n    }\n\n    return leasesWithBids\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "getProfile": {
               "code": "import Profile from 0x39937dba71a38820\nimport FIND from 0x39937dba71a38820\n\npub fun main(user: String) :  Profile.UserReport? {\n    let resolveAddress = FIND.resolve(user) \n    if resolveAddress == nil {return nil}\n    let address = resolveAddress!\n\n    return getAccount(address)\n        .getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        .borrow()?.asReport()\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "getStatus": {
               "code": "import FIND from 0x39937dba71a38820\nimport Profile from 0x39937dba71a38820\nimport RelatedAccounts from 0x39937dba71a38820\nimport FindMarket from 0x39937dba71a38820\n\npub struct FINDReport{\n    pub let profile:Profile.UserReport?\n    pub let bids: [FIND.BidInfo]\n    pub let relatedAccounts: { String: Address}\n    pub let leases: [FIND.LeaseInformation]\n    pub let privateMode: Bool\n    pub let itemsForSale: {String : FindMarket.SaleItemCollectionReport}\n    pub let marketBids: {String : FindMarket.BidItemCollectionReport}\n\n\n    init(profile: Profile.UserReport?, relatedAccounts: {String: Address}, bids: [FIND.BidInfo], leases : [FIND.LeaseInformation], privateMode: Bool, itemsForSale: {String : FindMarket.SaleItemCollectionReport}, marketBids: {String : FindMarket.BidItemCollectionReport}) {\n        self.profile=profile\n        self.bids=bids\n        self.leases=leases\n        self.relatedAccounts=relatedAccounts\n        self.privateMode=privateMode\n        self.itemsForSale=itemsForSale\n        self.marketBids=marketBids\n    }\n}\n\npub struct NameReport {\n    pub let status: String \n    pub let cost: UFix64 \n\n    init(status: String, cost: UFix64) {\n        self.status=status \n        self.cost=cost\n    }\n}\n\npub struct Report {\n    pub let FINDReport: FINDReport?\n    pub let NameReport: NameReport?\n\n    init(FINDReport: FINDReport?, NameReport: NameReport?) {\n        self.FINDReport=FINDReport \n        self.NameReport=NameReport\n    }\n}\n\npub fun main(user: String) : Report? {\n\n    var findReport: FINDReport? = nil\n    if let address=FIND.resolve(user) {\n        let account=getAccount(address)\n        let bidCap = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        let leaseCap = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        let profile=account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath).borrow()\n\n        let find= FindMarket.getFindTenantAddress()\n        let items : {String : FindMarket.SaleItemCollectionReport} = FindMarket.getSaleItemReport(tenant:find, address: address, getNFTInfo:true)\n\n        let marketBids : {String : FindMarket.BidItemCollectionReport} = FindMarket.getBidsReport(tenant:find, address: address, getNFTInfo:true)\n\n        findReport = FINDReport(\n            profile: profile?.asReport(),\n            relatedAccounts: RelatedAccounts.findRelatedFlowAccounts(address:address),\n            bids: bidCap.borrow()?.getBids() ?? [],\n            leases: leaseCap.borrow()?.getLeaseInformation() ?? [],\n            privateMode: profile?.isPrivateModeEnabled() ?? false,\n            itemsForSale: items,\n            marketBids: marketBids\n        )\n    }\n\n    var nameReport : NameReport? = nil \n    if FIND.validateFindName(user) {\n        let status = FIND.status(user)\n        let cost=FIND.calculateCost(user)\n        var s=\"TAKEN\"    \n        if status.status == FIND.LeaseStatus.FREE {\n            s=\"FREE\"\n        } else if status.status == FIND.LeaseStatus.LOCKED {\n            s=\"LOCKED\"\n        }\n        nameReport = NameReport(status: s, cost: cost)\n    }\n    \n\n    return Report(FINDReport: findReport, NameReport: nameReport)\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "getTenantSaleItem": {
               "code": "import FindMarket from 0x39937dba71a38820\n\npub fun main(tenant: Address) : TenantSaleItems {\n    let tenantCap = FindMarket.getTenantCapability(tenant) ?? panic(\"No tenant capability is set up for this address\")\n    let tenantRef = tenantCap.borrow() ?? panic(\"Cannot borrow tenant reference from this address\")\n    let saleItems = tenantRef.getSaleItems()\n    return TenantSaleItems(findSaleItems: saleItems[\"findSaleItems\"]! ,\n                           tenantSaleItems: saleItems[\"tenantSaleItems\"]! ,\n                           findCuts: saleItems[\"findCuts\"]! )\n\n}\n\npub struct TenantSaleItems {\n    pub let findSaleItems : {String : FindMarket.TenantSaleItem}\n    pub let tenantSaleItems : {String : FindMarket.TenantSaleItem}\n    pub let findCuts : {String : FindMarket.TenantSaleItem} \n\n    init(findSaleItems : {String : FindMarket.TenantSaleItem}, \n         tenantSaleItems : {String : FindMarket.TenantSaleItem},\n         findCuts : {String : FindMarket.TenantSaleItem}) {\n             self.findSaleItems = findSaleItems\n             self.tenantSaleItems = tenantSaleItems \n             self.findCuts = findCuts \n         }\n}",
               "spec": {
                  "order": [
                     "tenant"
                  ],
                  "parameters": {
                     "tenant": "Address"
                  }
               }
            },
            "hasCharity": {
               "code": "import CharityNFT from 0x39937dba71a38820\n\npub fun main(user: Address) : Bool {\n    let account=getAccount(user)\n    let charityCap = account.getCapability\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection)\n    return charityCap.check()\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "Address"
                  }
               }
            },
            "isFindUser": {
               "code": "import Profile from 0x39937dba71a38820\nimport FIND from 0x39937dba71a38820\n\npub fun main(user: Address) : Bool {\n\n    let account=getAccount(user)\n    let leaseCap=account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n    let profileCap=account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\n    return leaseCap.check() \u0026\u0026 profileCap.check()\n\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "Address"
                  }
               }
            },
            "mainnet_getBeam": {
               "code": "import Beam from 0x86b4a0010a71cfc3 \n\npub struct MetadataCollectionItem {\n    pub let id:UInt64\n    pub let name: String\n    pub let image: String\n    pub let url: String\n    pub let listPrice: UFix64?\n    pub let listToken: String?\n    pub let contentType:String\n    pub let rarity:String\n\n\n    init(id:UInt64, name:String, image:String, url:String, listPrice: UFix64?, listToken:String?, contentType: String, rarity: String) {\n        self.id=id\n        self.name=name\n        self.url=url\n        self.image=image\n        self.listToken=listToken\n        self.listPrice=listPrice\n        self.contentType=contentType\n        self.rarity=rarity\n    }\n}\n\npub fun main(address: Address) : [MetadataCollectionItem] {\n\n\n    let items: [MetadataCollectionItem] = []\n    let account=getAccount(address)\n    let beamCap = account.getCapability\u003c\u0026{Beam.BeamCollectionPublic}\u003e(Beam.CollectionPublicPath)\n    if beamCap.check() {\n        let collection = beamCap.borrow()!\n        for id in collection.getIDs() {\n            let nft = collection.borrowCollectible(id: id)!\n\n        let metadata = Beam.getCollectibleItemMetaData(collectibleItemID: nft.data.collectibleItemID)!\n          var mediaUrl: String? = metadata[\"mediaUrl\"]\n            if mediaUrl != nil \u0026\u0026  mediaUrl!.slice(from: 0, upTo: 7) != \"ipfs://\" {\n                mediaUrl = \"ipfs://\".concat(mediaUrl!)\n            }\n            let item = MetadataCollectionItem(\n                id: id,\n                name: metadata[\"title\"]!,\n                image: mediaUrl ?? \"\",\n                url: \"https://\".concat(metadata[\"domainUrl\"]!),\n                listPrice: nil,\n                listToken: nil,\n                contentType: metadata[\"mediaType\"]!,\n                rarity: \"\"\n            )\n\n            items.append(item)\n        }\n    }\n    return items\n\n}",
               "spec": {
                  "order": [
                     "address"
                  ],
                  "parameters": {
                     "address": "Address"
                  }
               }
            },
            "mainnet_getCharity": {
               "code": "import NonFungibleToken from 0x631e88ae7f1d7c20\nimport CharityNFT from 0x39937dba71a38820\n\npub fun main(address: Address) : [UInt64] {\n    \n    let account = getAccount(address)\n    let charityCap = account.getCapability\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection)\n\n    return charityCap.borrow()!.getIDs()\n}",
               "spec": {
                  "order": [
                     "address"
                  ],
                  "parameters": {
                     "address": "Address"
                  }
               }
            },
            "mainnet_getCollections2": {
               "code": "import NonFungibleToken from 0x631e88ae7f1d7c20\nimport CharityNFT from 0x39937dba71a38820\nimport FIND from 0x39937dba71a38820\n\n//mainnet\n\nimport Beam from 0x86b4a0010a71cfc3 \nimport Art from 0xd796ff17107bbff6\nimport Marketplace from 0xd796ff17107bbff6\nimport GooberXContract from 0x34f2bf4a80bb0f69\nimport Flovatar from 0x921ea449dffec68a\nimport FlovatarMarketplace from  0x921ea449dffec68a\nimport RareRooms_NFT from 0x329feb3ab062d289\nimport CNN_NFT from 0x329feb3ab062d289\nimport Canes_Vault_NFT from 0x329feb3ab062d289\nimport DGD_NFT from 0x329feb3ab062d289\nimport RaceDay_NFT from 0x329feb3ab062d289\nimport The_Next_Cartel_NFT from 0x329feb3ab062d289\nimport UFC_NFT from 0x329feb3ab062d289\nimport MotoGPCard from 0xa49cc0ee46c54bfb\nimport Gaia from 0x8b148183c28ff88f\nimport ChainmonstersRewards from 0x93615d25d14fa337\nimport Moments from 0xd4ad4740ee426334\nimport MatrixWorldFlowFestNFT from 0x2d2750f240198f91\nimport SturdyItems from 0x427ceada271aa0b1\nimport Evolution from 0xf4264ac8f3256818\nimport GeniaceNFT from 0xabda6627c70c7f52\nimport OneFootballCollectible from 0x6831760534292098\nimport CryptoPiggo from 0xd3df824bf81910a4\nimport GoatedGoatsVouchers from 0xdfc74d9d561374c0\nimport TraitPacksVouchers from 0xdfc74d9d561374c0\nimport HaikuNFT from 0xf61e40c19db2a9e2\nimport KlktnNFT from 0xabd6e80be7e9682c\nimport Mynft from 0xf6fcbef550d97aa5\nimport NeoAvatar from 0xb25138dbf45e5801\nimport NeoViews from 0xb25138dbf45e5801\nimport MetadataViews from 0x1d7e57aa55817448\n\n//Jambb\nimport Vouchers from 0x444f5ea22c6ea12c\n\n//xtingles\nimport Collectible from 0xf5b0eb433389ac3f\n\npub struct MetadataCollection {\n\n    pub let path:PublicPath\n    pub let type: Type\n    pub let typeIdentifier: String\n    pub let conformance: String \n    pub let domainUrl : String\n    pub let category: String\n    pub let legacyIdentifierPrefix:String\n    pub let transferable: Bool\n\n    init(path:PublicPath, type:Type, conformance:String, domainUrl:String, category:String, legacyIdentifierPrefix:String, transferable:Bool) {\n        self.path=path\n        self.type=type\n        self.typeIdentifier=type.identifier\n        self.conformance=conformance\n        self.domainUrl=domainUrl\n        self.category=category\n        self.legacyIdentifierPrefix=legacyIdentifierPrefix\n        self.transferable=transferable\n    }\n\n}\n\npub struct MetadataCollections {\n\n    pub let items: {UInt64 : MetadataCollectionItem}\n    pub let internalToUuidMap: {String : UInt64 }\n    pub let collections: {String : [UInt64]}\n\n    init() {\n        self.items= {}\n        self.internalToUuidMap= {}\n        self.collections={}\n    }\n\n\n    pub fun addCollection(items:[MetadataCollectionItem]) {\n\n\n        if items.length == 0 {\n            return\n        }\n\n        let collection=items[0].collection\n        let resultCollection = self.collections[collection.category] ?? []\n        for item in items {\n            self.items[item.uuid]=item\n            //we add a mapping from old legacy internal id to uuid\n            self.internalToUuidMap[collection.legacyIdentifierPrefix.concat(item.id.toString())]= item.uuid\n            resultCollection.append(item.uuid)\n        }\n        self.collections[collection.category]=resultCollection\n    }\n\n    //This uses a view from Neo until we agree on another for ExternalDomainViewUrl\n    pub fun addMetadataCollection(path: PublicPath, account:PublicAccount, category:String, legacyIdentifierPrefix: String, url:String, transferable:Bool)  {\n\n        // init(path:PublicPath, type:Type, conformance:String, domainUrl:String, items: {UInt64:MetadataCollectionItem}, category:String, legacyIdentifierPrefix:String) {\n\n        let resolverCollectionCap= account.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(path)\n        if !resolverCollectionCap.check() {\n            return \n        }\n\n        let collection = resolverCollectionCap.borrow()!\n\n        let mc= MetadataCollection(path: path, type: collection.getType() , conformance: \"MetadataViews.ResolverCollection\", domainUrl: url, category: category, legacyIdentifierPrefix: legacyIdentifierPrefix, transferable: transferable)\n\n\n        let items:[MetadataCollectionItem]=[]\n        for id in collection.getIDs() {\n            let nft = collection.borrowViewResolver(id: id)!\n\n            if let displayView = nft.resolveView(Type\u003cMetadataViews.Display\u003e()) {\n                let display = displayView as! MetadataViews.Display\n\n                var externalUrl=mc.domainUrl\n                if let externalUrlView = nft.resolveView(Type\u003cNeoViews.ExternalDomainViewUrl\u003e()) {\n                    let edvu= externalUrlView! as! NeoViews.ExternalDomainViewUrl\n                    externalUrl=edvu.url\n                }\n\n                //: add check for rarity and minter here\n\n                let item = MetadataCollectionItem(\n                    id: id,\n                    uuid: nft.uuid,\n                    name: display.name,\n                    description:display.description,\n                    image: display.thumbnail.uri(),\n                    url: externalUrl,\n                    contentType: \"image\",\n                    rarity: \"\",\n                    minter: \"\",\n                    type: nft.getType(),\n                    collection:mc\n                )\n                items.append(item)\n            }\n        }\n        self.addCollection(items: items)\n    }\n}\n\n\npub struct MetadataCollectionItem {\n    pub let id:UInt64\n    pub let uuid:UInt64\n    pub let name: String\n    pub let description: String?\n    pub let image: String\n    pub let url: String\n    pub let contentType:String\n    pub let rarity:String\n    pub let minter:String?\n    pub let type:Type\n    pub let collection:MetadataCollection\n\n\n    init(id:UInt64, uuid:UInt64, name:String, description:String?, image:String, url:String, contentType: String, rarity: String, minter:String?, type:Type, collection: MetadataCollection) {\n        self.id=id\n        self.uuid=uuid\n        self.name=name\n        self.description=description\n        self.minter=minter\n        self.url=url\n        self.type=type\n        self.image=image\n        self.collection=collection\n        self.contentType=contentType\n        self.rarity=rarity\n    }\n}\n\n// change bacak to address later\n//pub fun main(address: Address) : MetadataCollections? {\npub fun main(name: String) : MetadataCollections? {\n    let address=FIND.lookupAddress(name)!\n\n    let collection= MetadataCollections()\n    let account=getAccount(address)\n\n    let items:[MetadataCollectionItem]=[]\n\n    let versusArtCap=account.getCapability\u003c\u0026{Art.CollectionPublic}\u003e(Art.CollectionPublicPath)\n    let versusImageUrlPrefix = \"https://res.cloudinary.com/dxra4agvf/image/upload/c_fill,w_600/f_auto/maincache\"\n    if versusArtCap.check(){\n\n        let artCollection= versusArtCap.borrow()!\n\n        let mc= MetadataCollection(path: Art.CollectionPublicPath, type: artCollection.getType() , conformance: \"Art.CollectionPublic\", domainUrl: \"https://versus.auction\", category: \"Versus\", legacyIdentifierPrefix: \"Versus\", transferable: true)\n\n        for id in artCollection.getIDs() {\n            var art=artCollection.borrowArt(id: id)!\n            let item = MetadataCollectionItem(\n                id: id,\n                uuid: art.uuid,\n                name: art.metadata.name.concat(\" edition \").concat(art.metadata.edition.toString()).concat(\"/\").concat(art.metadata.maxEdition.toString()).concat(\" by \").concat(art.metadata.artist),  \n                description:art.metadata.description,\n                image: versusImageUrlPrefix.concat(art.cacheKey()), \n                url: \"https://www.versus.auction/piece/\".concat(address.toString()).concat(\"/\").concat(art.id.toString()).concat(\"/\"),\n                contentType: \"image\",\n                rarity: \"\",\n                minter: \"\",\n                type: art.getType(),\n                collection:mc\n            )\n            items.append(item)\n        }\n    }\n\n    let versusMarketplace = account.getCapability\u003c\u0026{Marketplace.SalePublic}\u003e(Marketplace.CollectionPublicPath)\n    if versusMarketplace.check() {\n\n        let versusMarket = versusMarketplace.borrow()!\n\n        let mc= MetadataCollection(path: Marketplace.CollectionPublicPath, type: versusMarketplace.borrow()!.getType() , conformance: \"Marketplace.SalePublic\", domainUrl: \"https://versus.auction\", category: \"Versus\", legacyIdentifierPrefix: \"Versus\", transferable:false)\n\n        let saleItems = versusMarket.listSaleItems()\n        for saleItem in saleItems {\n\n            let uuid = versusMarket.getUUIDforSaleItem(tokenID: saleItem.id)\n            let item = MetadataCollectionItem(\n                id: saleItem.id,\n                uuid: uuid,\n                name: saleItem.art.name.concat(\" edition \").concat(saleItem.art.edition.toString()).concat(\"/\").concat(saleItem.art.maxEdition.toString()).concat(\" by \").concat(saleItem.art.artist),\n                description:\"\",\n                image: versusImageUrlPrefix.concat(saleItem.cacheKey), \n                url: \"https://www.versus.auction/listing/\".concat(saleItem.id.toString()).concat(\"/\"),\n                contentType: \"image\",\n                rarity: \"\",\n                minter: \"\",\n                type: Type\u003c@Art.NFT\u003e(), \n                collection:mc\n            )\n            items.append(item)\n        }\n    }\n\n  let flovatarCap = account.getCapability\u003c\u0026{Flovatar.CollectionPublic}\u003e(Flovatar.CollectionPublicPath)  \n    if flovatarCap.check(){\n\n        let flovatars=flovatarCap.borrow()!\n         let mc= MetadataCollection(path: Flovatar.CollectionPublicPath, type: flovatars.getType() , conformance: \"Flovatar.CollectionPublic\", domainUrl: \"https://flovatar.com\", category: \"Flovatar\", legacyIdentifierPrefix: \"Flovatar\", transferable:true)\n        for id in flovatars.getIDs() {\n            let flovatar = flovatars.borrowFlovatar(id: id)!\n\n            let metadata=flovatar.getMetadata()\n            var name = flovatar.getName()\n            if name == \"\" {\n                name=\"Flovatar #\".concat(flovatar.id.toString())\n            }\n\n            var rarity=\"common\"\n            if metadata.legendaryCount \u003e 0 {\n                rarity=\"legendary\"\n            }else if metadata.epicCount \u003e 0 {\n                rarity=\"epic\"\n            }else if metadata.rareCount \u003e 0 {\n                rarity=\"rare\"\n            }\n\n\n            let item=MetadataCollectionItem(\n                id: flovatar.id, \n                uuid:flovatar.uuid,\n                name: name, \n                description: flovatar.description,\n                image: \"https://flovatar.com/api/image/\".concat(flovatar.id.toString()),\n                url: \"https://flovatar.com/flovatars/\".concat(flovatar.id.toString()).concat(\"/\"),\n                contentType: \"image\",\n                rarity: rarity,\n                minter: \"\",\n                type: flovatar.getType(),\n                collection:mc\n            )\n            items.append(item)\n        }\n    }\n\n\n    let flovatarMarketCap = account.getCapability\u003c\u0026{FlovatarMarketplace.SalePublic}\u003e(FlovatarMarketplace.CollectionPublicPath)  \n    if flovatarMarketCap.check(){\n\n        let saleCollection=flovatarMarketCap.borrow()!\n         let mc= MetadataCollection(path: FlovatarMarketplace.CollectionPublicPath, type: saleCollection.getType() , conformance: \"FlovatarMarketplace.SalePublic\", domainUrl: \"https://flovatar.com\", category: \"Flovatar\", legacyIdentifierPrefix: \"Flovatar\", transferable:false)\n        for id in saleCollection.getFlovatarIDs() {\n            let flovatar = saleCollection.getFlovatar(tokenId: id)!\n\n            let metadata=flovatar.getMetadata()\n            var name = flovatar.getName()\n            if name == \"\" {\n                name=\"Flovatar #\".concat(flovatar.id.toString())\n            }\n\n            var rarity=\"common\"\n            if metadata.legendaryCount \u003e 0 {\n                rarity=\"legendary\"\n            }else if metadata.epicCount \u003e 0 {\n                rarity=\"epic\"\n            }else if metadata.rareCount \u003e 0 {\n                rarity=\"rare\"\n            }\n\n\n            let item=MetadataCollectionItem(\n                id: flovatar.id, \n                uuid:flovatar.uuid,\n                name: name, \n                description: flovatar.description,\n                image: \"https://flovatar.com/api/image/\".concat(flovatar.id.toString()),\n                url: \"https://flovatar.com/flovatars/\".concat(flovatar.id.toString()).concat(\"/\"),\n                contentType: \"image\",\n                rarity: rarity,\n                minter: \"\",\n                type: flovatar.getType(),\n                collection:mc\n            )\n            items.append(item)\n        }\n    }\n\n\n    let goobersCap = account.getCapability\u003c\u0026GooberXContract.Collection{NonFungibleToken.CollectionPublic, GooberXContract.GooberCollectionPublic}\u003e(GooberXContract.CollectionPublicPath)\n    if goobersCap.check() {\n\n        let goobers = goobersCap.borrow()!\n\n        let mc= MetadataCollection(path: GooberXContract.CollectionPublicPath, type: goobers.getType() , conformance: \"NonFungibleToken.CollectionPublic, GooberXContract.GooberCollectionPublic\", domainUrl: \"https://partimansion.io/gooberz\", category: \"Gooberz\", legacyIdentifierPrefix: \"Gooberz\", transferable:true)\n        for id in goobers.getIDs() {\n            let goober= goobers.borrowGoober(id:id)!\n            let item=MetadataCollectionItem(\n                id: id,\n                uuid: goober.uuid,\n                name: \"Goober #\".concat(id.toString()),\n                description: \"\",\n                image: goober.data.uri,\n                url: \"https://partymansion.io/gooberz/\".concat(id.toString()),\n                contentType: \"image\",\n                rarity: \"\",\n                minter:\"\",\n                type: goober.getType(),\n                collection:mc\n            )\n            items.append(item)\n        }\n    }\n\n\n    let rareRoomCap = account.getCapability\u003c\u0026RareRooms_NFT.Collection{RareRooms_NFT.RareRooms_NFTCollectionPublic}\u003e(RareRooms_NFT.CollectionPublicPath)\n    if rareRoomCap.check() {\n\n        let rareRooms = rareRoomCap.borrow()!\n        let mc= MetadataCollection(path: RareRooms_NFT.CollectionPublicPath, type: rareRooms.getType() , conformance: \"RareRooms_NFT.RareRooms_NFTCollectionPublic\", domainUrl: \"https://rarerooms.io\", category: \"RareRooms\", legacyIdentifierPrefix: \"RareRooms\", transferable:true)\n        for id in rareRooms.getIDs() {\n            let nft = rareRooms.borrowRareRooms_NFT(id: id)!\n            let metadata = RareRooms_NFT.getSetMetadata(setId: nft.setId)!\n            let item = MetadataCollectionItem(\n                id: id,\n                uuid: nft.uuid,\n                name: metadata[\"name\"]!,\n                description: metadata[\"description\"] ?? \"\", \n                image: metadata[\"preview\"]!,\n                url: \"https://rarerooms.io/tokens/\".concat(id.toString()),\n                contentType: \"image\",\n                rarity: \"\",\n                minter: \"\",\n                type: nft.getType(),\n                collection:mc\n            )\n            items.append(item)\n        }\n    }\n    \n\n    let cnnCap = account.getCapability\u003c\u0026CNN_NFT.Collection{CNN_NFT.CNN_NFTCollectionPublic}\u003e(CNN_NFT.CollectionPublicPath)\n    if cnnCap.check() {\n\n        let cnns = cnnCap.borrow()!\n        let mc= MetadataCollection(path: CNN_NFT.CollectionPublicPath, type: cnns.getType() , conformance: \"CNN_NFT.CNN_NFTCollectionPublic\", domainUrl: \"https://vault.cnn.com\", category: \"CNN\", legacyIdentifierPrefix: \"CNN\", transferable:true)\n        for id in cnns.getIDs() {\n            let nft = cnns.borrowCNN_NFT(id: id)!\n            let metadata = CNN_NFT.getSetMetadata(setId: nft.setId)!\n            let item = MetadataCollectionItem(\n                id: id,\n                uuid: nft.uuid,\n                name: metadata[\"name\"]!,\n                description: metadata[\"description\"] ?? \"\", \n                image: metadata[\"preview\"]!,\n                url: \"https://vault.cnn.com\",\n                contentType: \"image\",\n                rarity: \"\",\n                minter: \"\",\n                type: nft.getType(),\n                collection:mc\n            )\n            items.append(item)\n        }\n    }\n\n    let canesVaultCap = account.getCapability\u003c\u0026Canes_Vault_NFT.Collection{Canes_Vault_NFT.Canes_Vault_NFTCollectionPublic}\u003e(Canes_Vault_NFT.CollectionPublicPath)\n    if canesVaultCap.check() {\n\n        let canesVaults = canesVaultCap.borrow()!\n        let mc= MetadataCollection(path: Canes_Vault_NFT.CollectionPublicPath, type: canesVaults.getType() , conformance: \"Canes_Vault_NFT.Canes_Vault_NFTCollectionPublic\", domainUrl: \"https://canesvault.com\", category: \"Canes_Vault\", legacyIdentifierPrefix: \"Canes_Vault_NFT\", transferable:true)\n        for id in canesVaults.getIDs() {\n            let nft = canesVaults.borrowCanes_Vault_NFT(id: id)!\n            let metadata = Canes_Vault_NFT.getSetMetadata(setId: nft.setId)!\n            let item = MetadataCollectionItem(\n                id: id,\n                uuid: nft.uuid,\n                name: metadata[\"name\"]!,\n                description: metadata[\"description\"] ?? \"\", \n                image: metadata[\"preview\"]!,\n                url: \"https://canesvault.com\",\n                contentType: \"image\",\n                rarity: \"\",\n                minter: \"\",\n                type: nft.getType(),\n                collection:mc\n            )\n            items.append(item)\n        }\n    }\n\n    let dgdCap = account.getCapability\u003c\u0026DGD_NFT.Collection{DGD_NFT.DGD_NFTCollectionPublic}\u003e(DGD_NFT.CollectionPublicPath)\n    if dgdCap.check() {\n\n        let dgds = dgdCap.borrow()!\n        let mc= MetadataCollection(path: DGD_NFT.CollectionPublicPath, type: dgds.getType() , conformance: \"DGD_NFT.DGD_NFTCollectionPublic\", domainUrl: \"https://theplayerslounge.io\", category: \"DGD\", legacyIdentifierPrefix: \"DGD\", transferable:true)\n        for id in dgds.getIDs() {\n            let nft = dgds.borrowDGD_NFT(id: id)!\n            let metadata = DGD_NFT.getSetMetadata(setId: nft.setId)!\n            let item = MetadataCollectionItem(\n                id: id,\n                uuid: nft.uuid,\n                name: metadata[\"name\"]!,\n                description: metadata[\"description\"] ?? \"\", \n                image: metadata[\"preview\"]!,\n                url: \"https://www.theplayerslounge.io\",\n                contentType: \"image\",\n                rarity: \"\",\n                minter: \"\",\n                type: nft.getType(),\n                collection:mc\n            )\n            items.append(item)\n        }\n    }\n    \n    let raceDayCap = account.getCapability\u003c\u0026RaceDay_NFT.Collection{RaceDay_NFT.RaceDay_NFTCollectionPublic}\u003e(RaceDay_NFT.CollectionPublicPath)\n    if raceDayCap.check() {\n\n        let raceDays = raceDayCap.borrow()!\n        let mc= MetadataCollection(path: RaceDay_NFT.CollectionPublicPath, type: raceDays.getType() , conformance: \"RaceDay_NFT.RaceDay_NFTCollectionPublic\", domainUrl: \"https://racedaynft.com\", category: \"RaceDay\", legacyIdentifierPrefix: \"RaceDay_NFT\", transferable:true)\n        for id in raceDays.getIDs() {\n            let nft = raceDays.borrowRaceDay_NFT(id: id)!\n            let metadata = RaceDay_NFT.getSetMetadata(setId: nft.setId)!\n            let item = MetadataCollectionItem(\n                id: id,\n                uuid: nft.uuid,\n                name: metadata[\"name\"]!,\n                description: metadata[\"description\"] ?? \"\", \n                image: metadata[\"preview\"]!,\n                url: \"https://www.racedaynft.com\",\n                contentType: \"image\",\n                rarity: \"\",\n                minter: \"\",\n                type: nft.getType(),\n                collection:mc\n            )\n            items.append(item)\n        }\n    }\n\n    let nextCartelCap = account.getCapability\u003c\u0026The_Next_Cartel_NFT.Collection{The_Next_Cartel_NFT.The_Next_Cartel_NFTCollectionPublic}\u003e(The_Next_Cartel_NFT.CollectionPublicPath)\n    if nextCartelCap.check() {\n\n        let nextCartels = nextCartelCap.borrow()!\n        let mc= MetadataCollection(path: The_Next_Cartel_NFT.CollectionPublicPath, type: nextCartels.getType() , conformance: \"The_Next_Cartel_NFT.The_Next_Cartel_NFTCollectionPublic\", domainUrl: \"https://thenextcartel.com\", category: \"The_Next_Cartel\", legacyIdentifierPrefix: \"The_Next_Cartel_NFT\", transferable:true)\n        for id in nextCartels.getIDs() {\n            let nft = nextCartels.borrowThe_Next_Cartel_NFT(id: id)!\n            let metadata = The_Next_Cartel_NFT.getSetMetadata(setId: nft.setId)!\n            let item = MetadataCollectionItem(\n                id: id,\n                uuid: nft.uuid,\n                name: metadata[\"name\"]!,\n                description: metadata[\"description\"] ?? \"\", \n                image: metadata[\"preview\"]!,\n                url: \"https://thenextcartel.com/\",\n                contentType: \"image\",\n                rarity: \"\",\n                minter: \"\",\n                type: nft.getType(),\n                collection:mc\n            )\n            items.append(item)\n        }\n    }\n\n    let utcCap = account.getCapability\u003c\u0026UFC_NFT.Collection{UFC_NFT.UFC_NFTCollectionPublic}\u003e(UFC_NFT.CollectionPublicPath)\n    if utcCap.check() {\n\n        let utcs = utcCap.borrow()!\n        let mc= MetadataCollection(path: UFC_NFT.CollectionPublicPath, type: utcs.getType() , conformance: \"UFC_NFT.UFC_NFTCollectionPublic\", domainUrl: \"https://ufcstrike.com\", category: \"UFC\", legacyIdentifierPrefix: \"UFC\", transferable:true)\n        for id in utcs.getIDs() {\n            let nft = utcs.borrowUFC_NFT(id: id)!\n            let metadata = UFC_NFT.getSetMetadata(setId: nft.setId)!\n            let item = MetadataCollectionItem(\n                id: id,\n                uuid: nft.uuid,\n                name: metadata[\"name\"]!,\n                description: metadata[\"description\"] ?? \"\", \n                image: metadata[\"image\"]!,\n                url: \"https://ufcstrike.com\",\n                contentType: \"video\",\n                rarity: \"\",\n                minter: \"\",\n                type: nft.getType(),\n                collection:mc\n            )\n            items.append(item)\n        }\n    }\n\n    let motoGPCollection = account.getCapability\u003c\u0026MotoGPCard.Collection{MotoGPCard.ICardCollectionPublic}\u003e(/public/motogpCardCollection)\n    if motoGPCollection.check() {\n        let motoGPNfts = motoGPCollection.borrow()!\n\n        let mc= MetadataCollection(path: /public/motogpCardCollection, type: motoGPNfts.getType() , conformance: \"MotoGPCard.ICardCollectionPublic\", domainUrl: \"https://motogp-ignition.com.com\", category: \"MotoGP\", legacyIdentifierPrefix: \"MotoGP\", transferable:true)\n        for id in motoGPNfts.getIDs() {\n            let nft = motoGPNfts.borrowCard(id: id)!\n            let metadata = nft.getCardMetadata()!\n            let item = MetadataCollectionItem(\n                id: id,\n                uuid: nft.uuid,\n                name: metadata.name,\n                description: metadata.description,\n                image: metadata.imageUrl,\n                url: \"https://motogp-ignition.com/nft/card/\".concat(id.toString()).concat(\"?owner=\").concat(address.toString()),\n                contentType: \"image\",\n                rarity: \"\",\n                minter: \"\",\n                type: nft.getType(),\n                collection:mc\n            )\n            items.append(item)\n        }\n    }\n\n    let gaiaCollection = account.getCapability\u003c\u0026{Gaia.CollectionPublic}\u003e(Gaia.CollectionPublicPath)\n    if gaiaCollection.check() {\n\n        let gaiaNfts = gaiaCollection.borrow()!\n\n        let mc= MetadataCollection(path: Gaia.CollectionPublicPath, type: gaiaNfts.getType() , conformance: \"Gaia.CollectionPublic\", domainUrl: \"http://ongaia.com\", category: \"Gaia\", legacyIdentifierPrefix: \"Gaia\", transferable:true)\n        for id in gaiaNfts.getIDs() {\n            let nft = gaiaNfts.borrowGaiaNFT(id: id)!\n            let metadata = Gaia.getTemplateMetaData(templateID: nft.data.templateID)!\n\n\n            var url=\"\"\n            let metadataId=metadata[\"id\"]\n            var name=metadata[\"title\"]!\n            if metadataId != nil {\n                url=\"http://ongaia.com/ballerz/\".concat(metadataId!)\n            }\n            //For ballerz we can do this...\n\n            if let seriesFullName=metadata[\"series\"] {\n                if seriesFullName==\"Shareef O\\u{2019}Neal - Basketball\" {\n                    //If the series is basketball with shareef we can do this\n                    url=\"http://ongaia.com/sharef/\".concat(id.toString())\n                    name=metadata[\"title\"]!.concat(\" #\").concat(nft.data.mintNumber.toString())\n                }else if seriesFullName==\"Bryson DeChambeau - Vegas, Baby!\" {\n                    //For golf there is yet another way\n                    url=\"http://ongaia.com/bryson/\".concat(nft.data.mintNumber.toString())\n                    name=metadata[\"title\"]!.concat(\" #\").concat(nft.data.mintNumber.toString())\n                }\n            }\n\n            let item = MetadataCollectionItem(\n                id: id,\n                uuid: nft.uuid,\n                name: name,\n                description: metadata[\"description\"] ?? \"\",\n                image: metadata[\"img\"]!,\n                url: url,\n                contentType: \"image\",\n                rarity: \"\",\n                minter: \"\",\n                type: nft.getType(),\n                collection:mc\n            )\n            items.append(item)\n        }\n    }\n\n    let jambbCap = account.getCapability\u003c\u0026Moments.Collection{Moments.CollectionPublic}\u003e(Moments.CollectionPublicPath)\n    if jambbCap.check() {\n\n        let nfts = jambbCap.borrow()!\n        let mc= MetadataCollection(path: Moments.CollectionPublicPath, type: nfts.getType() , conformance: \"Moments.CollectionPublic\", domainUrl: \"http://jambb.com\", category: \"Jambb\", legacyIdentifierPrefix: \"Jambb\", transferable:true)\n        for id in nfts.getIDs() {\n            let nft = nfts.borrowMoment(id: id)!\n            let metadata=nft.getMetadata()\n            let item  =MetadataCollectionItem(\n                id: id,\n                uuid: nft.uuid,\n                name: metadata.contentName,\n                description: metadata.contentDescription,\n                image: \"ipfs://\".concat(metadata.videoHash),\n        url: \"https://www.jambb.com/c/moment/\".concat(id.toString()),\n                contentType: \"video\",\n                rarity: \"\",\n                minter: \"\",\n                type: nft.getType(),\n                collection:mc\n            )\n            items.append(item)\n        }\n\n    }\n\n    let voucherCap = account.getCapability\u003c\u0026{Vouchers.CollectionPublic}\u003e(Vouchers.CollectionPublicPath)\n    if voucherCap.check() {\n\n        let jambb = voucherCap.borrow()!\n        let mc= MetadataCollection(path: Vouchers.CollectionPublicPath, type: jambb.getType() , conformance: \"Vouchers.CollectionPublic\", domainUrl: \"http://jambb.com\", category: \"Jambb\", legacyIdentifierPrefix: \"JambbVoucher\", transferable:false)\n        for id in jambb.getIDs() {\n            let nft = jambb.borrowVoucher(id: id)!\n            let metadata=nft.getMetadata()!\n\n            let url=\"https://jambb.com\"\n            let item = MetadataCollectionItem(\n                id: id,\n                uuid: nft.uuid,\n                name: metadata.name,\n                description: metadata.description,\n                image: \"ipfs://\".concat(metadata.mediaHash),\n                url: url,\n                contentType: metadata.mediaType,\n                rarity: \"\",\n                minter: \"\",\n                type:nft.getType(),\n                collection: mc\n            )\n            items.append(item)\n        }\n\n    }\n\n    \n    //:matrixworld\n\n  let sturdyCollectionCap = account.getCapability\u003c\u0026SturdyItems.Collection{SturdyItems.SturdyItemsCollectionPublic}\u003e(SturdyItems.CollectionPublicPath)\n    if sturdyCollectionCap.check() {\n        let sturdyNfts = sturdyCollectionCap.borrow()!\n\n        let mc= MetadataCollection(path: SturdyItems.CollectionPublicPath, type: sturdyNfts.getType() , conformance: \"SturdyItems.SturdyItemsCollectionPublic\", domainUrl: \"http://hoodlumsnft.com.com\", category: \"Hoodlums\", legacyIdentifierPrefix: \"Hoodlums\", transferable:true)\n        for id in sturdyNfts.getIDs() {\n            // the metadata is a JSON stored on IPFS at the address nft.tokenURI\n            let nft = sturdyNfts.borrowSturdyItem(id: id)!\n            // the only thing we can play with is the nft title which is for example:\n            //     - \"HOODLUM#10\"\n            //     - \"HOLIDAY MYSTERY BADGE 2021\"\n            //  - \"EXCALIBUR\"\n            let isHoodlum = nft.tokenTitle.slice(from: 0, upTo: 7) == \"HOODLUM\"\n            if isHoodlum {\n                // the hoodlum id is needed to retrieve the image but is not in the nft\n                let hoodlumId = nft.tokenTitle.slice(from: 8, upTo: nft.tokenTitle.length)\n                let item=MetadataCollectionItem(\n                    id: id,\n                    uuid:nft.uuid,\n                    name: nft.tokenTitle,\n                    description: \"\",\n                    image: \"https://hoodlumsnft.com/_next/image?url=%2Fthumbs%2FsomeHoodlum_\".concat(hoodlumId).concat(\".png\u0026w=1920\u0026q=75\"),\n                    url: \"https://hoodlumsnft.com/\",\n                    contentType:\"image\",\n                    rarity: \"\",\n                    minter:\"\",\n                    type: nft.getType(),\n                    collection: mc\n                )\n                items.append(item)\n            }\n        }\n    }\n\n  let charityCap = account.getCapability\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection)\n    if charityCap.check() {\n        let nfts = charityCap.borrow()!\n        let mc= MetadataCollection(path: /public/findCharityNFTCollection, type: nfts.getType() , conformance: \"CharityNFT.CollectionPublicPath\", domainUrl: \"https://find.xyz/neo-x-flowverse-community-charity-tree\", category: \"Find\", legacyIdentifierPrefix: \"Charity\", transferable:true)\n\n        for id in nfts.getIDs() {\n            let nft = nfts.borrowCharity(id: id)!\n            let metadata = nft.getMetadata()\n            let item=MetadataCollectionItem(\n                id: id,\n                uuid:nft.uuid,\n                name: metadata[\"name\"]!,\n                description: \"\",\n                image: metadata[\"thumbnail\"]!,\n                url: metadata[\"originUrl\"]!,\n                contentType:\"image\",\n                rarity: \"\",\n                minter: \"\",\n                type: nft.getType(),\n                collection:mc\n            )\n\n            items.append(item)\n        }\n    }\n\n  let evolutionCap=account.getCapability\u003c\u0026{Evolution.EvolutionCollectionPublic}\u003e(/public/f4264ac8f3256818_Evolution_Collection)\n    if evolutionCap.check() {\n        let evolution=evolutionCap.borrow()!\n        let nfts = evolution.getIDs()\n\n        let mc= MetadataCollection(path: /public/f4264ac8f3256818_Evolution_Collection, type: nfts.getType() , conformance: \"Evolution.EvolutionCollectionPublic\", domainUrl: \"https://evolution-collect.com\", category: \"Evolution\", legacyIdentifierPrefix: \"Evolution\", transferable:true)\n        for id in nfts{\n            // the metadata is a JSON stored on IPFS at the address nft.tokenURI\n            let nft = evolution.borrowCollectible(id: id)!\n            let metadata = Evolution.getItemMetadata(itemId: nft.data.itemId)!\n            let item=MetadataCollectionItem(\n                id: id,\n                uuid: nft.uuid,\n                name: metadata[\"Title\"]!.concat(\" #\").concat(nft.data.serialNumber.toString()),\n                description: metadata[\"Description\"] ?? \"\",\n                image: \"https://storage.viv3.com/0xf4264ac8f3256818/mv/\".concat(nft.data.itemId.toString()),\n                url: \"https://www.evolution-collect.com/\",\n                contentType:\"video\",\n                rarity: \"\",\n                minter:\"\",\n                type:nft.getType(),\n                collection:mc\n            )\n\n            items.append(item)\n        }\n    }\n\n    /* // fix\n  let geniaceCap = account.getCapability\u003c\u0026GeniaceNFT.Collection{NonFungibleToken.CollectionPublic, GeniaceNFT.GeniaceNFTCollectionPublic}\u003e(GeniaceNFT.CollectionPublicPath)\n    if geniaceCap.check() {\n        let geniace=geniaceCap.borrow()!\n\n        let mc= MetadataCollection(path: GeniaceNFT.CollectionPublic, type: geniace.getType() , conformance: \"NonFungibleToken.CollectionPublic, GeniaceNFT.GeniaceNFTCollectionPublic\", domainUrl: \"https://geniace.com\", category: \"Geniace\", legacyIdentifierPrefix: \"Geniace\", transferable:true)\n        let nfts = geniace.getIDs()\n        for id in nfts{\n            // the metadata is a JSON stored on IPFS at the address nft.tokenURI\n            let nft = geniace.borrowGeniaceNFT(id: id)!\n            let metadata = nft.metadata\n            var rarity=\"\"\n            if metadata.rarity == GeniaceNFT.Rarity.Collectible {\n                rarity=\"Collectible\"\n            }else if metadata.rarity == GeniaceNFT.Rarity.Rare {\n                rarity=\"Rare\"\n            }else if metadata.rarity == GeniaceNFT.Rarity.UltraRare {\n                rarity=\"UltraRare\"\n            }\n\n            let item=MetadataCollectionItem(\n                id: id,\n                uuid: nft.uuid,\n                name: metadata.name,\n                description:metadata.description,\n                image: metadata.imageUrl,\n                url: \"https://www.geniace.com/product/\".concat(id.toString()),\n                contentType: metadata.data[\"mimetype\"]!,\n                rarity: rarity,\n                minter: \"\",\n                type: nft.getType(),\n                collection:mc\n            )\n            items.append(item)\n        }\n    }\n\n// https://flow-view-source.com/mainnet/account/0x6831760534292098/contract/OneFootballCollectible\n    let oneFootballCollectibleCap = account.getCapability\u003c\u0026OneFootballCollectible.Collection{OneFootballCollectible.OneFootballCollectibleCollectionPublic}\u003e(OneFootballCollectible.CollectionPublicPath)\n    if oneFootballCollectibleCap.check() {\n        let nfts = oneFootballCollectibleCap.borrow()!\n\n        let mc= MetadataCollection(path: OneFootballCollectible.ColllectionPublicPath, type: nfts.getType() , conformance: \"OneFootballCollectible.OneFootballCollectibleCollectionPublic\", domainUrl: \"https://xmas.onefootball.com\", category: \"OneFootball\", legacyIdentifierPrefix: \"OneFootballCollectible\", transferable:true)\n        for id in nfts.getIDs() {\n            let nft = nfts.borrowOneFootballCollectible(id: id)!\n            let metadata = nft.getTemplate()!\n            let item=MetadataCollectionItem(\n                id: id,\n                uuid: nft.uuid,\n                name: metadata.name,\n                description:metadata.description,\n                image: \"ipfs://\".concat(metadata.media),\n                url: \"https://xmas.onefootball.com/\".concat(account.address.toString()),\n                contentType: \"video\",\n                rarity: \"\",\n                minter:\"\",\n                type: nft.getType(),\n                collection:mc\n            )\n            items.append(item)\n        }\n    }\n    */\n\n  let cryptoPiggoCap = account.getCapability\u003c\u0026{CryptoPiggo.CryptoPiggoCollectionPublic}\u003e(CryptoPiggo.CollectionPublicPath)\n    if cryptoPiggoCap.check() {\n        let nfts = cryptoPiggoCap.borrow()!\n\n        let mc= MetadataCollection(path: CryptoPiggo.CollectionPublicPath, type: nfts.getType() , conformance: \"CryptoPiggo.CryptoPiggoCollectionPublic\", domainUrl: \"https://rareworx.com/piggo\", category: \"CryptoPiggo\", legacyIdentifierPrefix: \"CryptoPiggo\", transferable:true)\n        for id in nfts.getIDs() {\n            let nft = nfts.borrowItem(id: id)!\n            let item=MetadataCollectionItem(\n                id: id,\n                uuid:nft.uuid,\n                name: \"CryptoPiggo #\".concat(id.toString()),\n                description: \"\",\n                image: \"https://s3.us-west-2.amazonaws.com/crypto-piggo.nft/piggo-\".concat(id.toString()).concat(\".png\"),\n                url: \"https://rareworx.com/piggo/details/\".concat(id.toString()),\n                contentType: \"image\",\n                rarity: \"\",\n                minter:\"\",\n                type: nft.getType(),\n                collection:mc\n            )\n            items.append(item)\n        }\n    }\n\n    //: xtingles\n\n    /*\n    : goats\n    let goatsCap = account.getCapability\u003c\u0026{GoatedGoatsVouchers.GoatsVoucherCollectionPublic}\u003e(GoatedGoatsVouchers.CollectionPublicPath)\n    if goatsCap.check() {\n        let goatsImageUrl= GoatedGoatsVouchers.getCollectionMetadata()[\"mediaURL\"]!\n        let nfts = goatsCap.borrow()!\n        let mc= MetadataCollection(path: GoatedGoatsVouchers.CollectionPublicPath, type: nfts.getType() , conformance: \"GoatedGoatsVouchers.GoatsVoucherCollectionPublic\", domainUrl: \"https://goatedgoats.com\", category: \"GoatedGoats\", legacyIdentifierPrefix: \"GoatedGoatsVouchers\", transferable:false)\n        for id in nfts.getIDs() {\n            let item=MetadataCollectionItem(\n                id: id,\n                uuid: nft.get\n                name: \"Goated Goat Base Goat Voucher #\".concat(id.toString()),\n                image: goatsImageUrl, \n                url: \"https://goatedgoats.com/\",\n                contentType: \"image\",\n                rarity: \"\"\n\n            )\n            items.append(item)\n        }\n    }\n  \n    let goatsTraitCap = account.getCapability\u003c\u0026{TraitPacksVouchers.PackVoucherCollectionPublic}\u003e(TraitPacksVouchers.CollectionPublicPath)\n    if goatsTraitCap.check() {\n        let goatsImageUrl= TraitPacksVouchers.getCollectionMetadata()[\"mediaURL\"]!\n        let collection = goatsTraitCap.borrow()!\n        for id in collection.getIDs() {\n            let item=MetadataCollectionItem(\n                id: id,\n                name: \"Goated Goat Trait Pack Voucher #\".concat(id.toString()),\n                image: goatsImageUrl, \n                url: \"https://goatedgoats.com/\",\n                listPrice: nil,\n                listToken: nil,\n                contentType: \"image\",\n                rarity: \"\"\n\n            )\n            let itemId=\"GoatedGoatsTraitVoucher\".concat(id.toString())\n            goats.append(itemId)\n            resultMap[itemId] = item\n        }\n    }\n    */\n\n\n    /* // fix\n  let bitkuCap = account.getCapability\u003c\u0026{HaikuNFT.HaikuCollectionPublic}\u003e(HaikuNFT.HaikuCollectionPublicPath)\n    if bitkuCap.check() {\n        let nfts = bitkuCap.borrow()!\n\n        let mc= MetadataCollection(path: HaikuNFT.CollectionPublicPath, type: nfts.getType() , conformance: \"HaikuNFT.HaikuCollectionPublic\", domainUrl: \"https://bitku.art\", category: \"Bitku\", legacyIdentifierPrefix: \"Bitku\", transferable:true)\n        for id in nfts.getIDs() {\n            let nft = nfts.borrowHaiku(id: id)!\n            let item = MetadataCollectionItem(\n                id: id,\n                uuid:nft.uuid,\n                name: \"Bitku #\".concat(id.toString()),\n                description:\"\",\n                image: nft.text,\n                url: \"https://bitku.art/#\".concat(address.toString()).concat(\"/\").concat(id.toString()),\n                contentType: \"text\",\n                rarity: \"\",\n                minter:\"\",\n                type:nft.getType(),\n                collection:mc\n            )\n\n            items.append(item)\n        }\n    }\n\n    */\n    let klktnCap = account.getCapability\u003c\u0026{KlktnNFT.KlktnNFTCollectionPublic}\u003e(KlktnNFT.CollectionPublicPath)\n    if klktnCap.check() {\n        let nfts = klktnCap.borrow()!\n\n        let mc= MetadataCollection(path: KlktnNFT.CollectionPublicPath, type: nfts.getType() , conformance: \"KlktnNFT.KlktnNFTCollectionPublic\", domainUrl: \"https://klktn.com\", category: \"KLKTN\", legacyIdentifierPrefix: \"KLKTN\", transferable:true)\n        for id in nfts.getIDs() {\n            let nft = nfts.borrowKlktnNFT(id: id)!\n\n            let metadata=nft.getNFTMetadata()\n            /*\n\n            Result: {\"uri\": \"ipfs://bafybeifsiousmtmcruuelgyiku3xa5hmw7ylsyqfdvpjsea7r4xa74bhym\", \"name\": \"Kevin Woo - What is KLKTN?\", \"mimeType\": \"video/mp4\", \"media\": \"https://ipfs.io/ipfs/bafybeifsiousmtmcruuelgyiku3xa5hmw7ylsyqfdvpjsea7r4xa74bhym/fb91ad34d61dde04f02ad240f0ca924902d8b4a3da25daaf0bb1ed769977848c.mp4\", \"description\": \"K-pop sensation Kevin Woo has partnered up with KLKTN to enhance his artist to fan interactions and experiences within his fandom. Join our chat to learn more: https://discord.gg/UJxb4erfUw\"}\n\n            */\n            let item = MetadataCollectionItem(\n                id: id,\n                uuid:nft.uuid,\n                name: metadata[\"name\"]!,\n                description: metadata[\"description\"]!,\n                image: metadata[\"media\"]!,\n                url: \"https://klktn.com/\",\n                contentType: \"video\", //metadata[\"mimeType\"]!,\n                rarity: \"\",\n                minter:\"\",\n                type:nft.getType(),\n                collection:mc\n            )\n            items.append(item)\n        }\n    }\n\n    let mynftCap = account.getCapability\u003c\u0026{Mynft.MynftCollectionPublic}\u003e(Mynft.CollectionPublicPath)\n    if mynftCap.check() {\n        let nfts = mynftCap.borrow()!\n\n        let mc= MetadataCollection(path: Mynft.CollectionPublicPath, type: nfts.getType() , conformance: \"Mynft.MynftCollectionPublic\", domainUrl: \"https://mynft.io\", category: \"mynft\", legacyIdentifierPrefix: \"mynft\", transferable:true)\n        for id in nfts.getIDs() {\n            let nft = nfts.borrowArt(id: id)!\n            let metadata=nft.metadata\n\n            var image= metadata.ipfsLink\n            if image == \"\" {\n                image=\"https://arweave.net/\".concat(metadata.arLink)\n            }\n            let item = MetadataCollectionItem(\n                id: id,\n                uuid:nft.uuid,\n                name: metadata.name,\n                description:metadata.description,\n                image: image,\n                url: \"http://mynft.io\",\n                contentType: metadata.type,\n                rarity: \"\",\n                minter:\"\",\n                type:nft.getType(),\n                collection:mc\n            )\n            items.append(item)\n        }\n    }\n\n    /*\n    : add when url fixed\n    let beamCap = account.getCapability\u003c\u0026{Beam.BeamCollectionPublic}\u003e(Beam.CollectionPublicPath)\n        if beamCap.check() {\n        let nfts = beamCap.borrow()!\n\n        let mc= MetadataCollection(path: Beam.CollectionPublicPath, type: nfts.getType() , conformance: \"Beam.BeamCollectionPublic\", domainUrl: \"https://https://frightclub.niftory.com\", category: \"FrightClub\", legacyIdentifierPrefix: \"FrightClub\", transferable:true)\n        for id in nfts.getIDs() {\n            let nft = nfts.borrowCollectible(id: id)!\n\n        let metadata = Beam.getCollectibleItemMetaData(collectibleItemID: nft.data.collectibleItemID)!\n          var mediaUrl: String? = metadata[\"mediaUrl\"]\n            if mediaUrl != nil \u0026\u0026  mediaUrl!.slice(from: 0, upTo: 7) != \"ipfs://\" {\n                mediaUrl = \"ipfs://\".concat(mediaUrl!)\n            }\n            let item = MetadataCollectionItem(\n                id: id,\n                uuid:nft.uuid,\n                name: metadata[\"title\"]!,\n                description: metadata[\"description\"] ?? \"\",\n                image: mediaUrl ?? \"\",\n                url: \"https://\".concat(metadata[\"domainUrl\"]!),\n                contentType: metadata[\"mediaType\"]!,\n                rarity: \"\",\n                minter:\"\",\n                type:nft.getType(),\n                collection:mc\n            )\n            items.append(item)\n        }\n    }\n    */\n\n    collection.addCollection(items: items)\n\n    //Adding a collection that supports the metadata standard is SOOO much easier\n    collection.addMetadataCollection(path: NeoAvatar.CollectionPublicPath, account: account, category: \"Neo\", legacyIdentifierPrefix: \"NeoAvatar\", url: \"https://neocollectibles.xyz\", transferable: true)\n\n    if collection.collections.length==0 {\n        return nil\n    }\n    return collection\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "mainnet_getCollections_old": {
               "code": "import NonFungibleToken from 0x631e88ae7f1d7c20\nimport CharityNFT from 0x39937dba71a38820\nimport FIND from 0x39937dba71a38820\n\n//mainnet\nimport Beam from 0x86b4a0010a71cfc3 \nimport Art from 0xd796ff17107bbff6\nimport Marketplace from 0xd796ff17107bbff6\nimport GooberXContract from 0x34f2bf4a80bb0f69\nimport Flovatar from 0x921ea449dffec68a\nimport FlovatarMarketplace from  0x921ea449dffec68a\nimport RareRooms_NFT from 0x329feb3ab062d289\nimport CNN_NFT from 0x329feb3ab062d289\nimport Canes_Vault_NFT from 0x329feb3ab062d289\nimport DGD_NFT from 0x329feb3ab062d289\nimport RaceDay_NFT from 0x329feb3ab062d289\nimport The_Next_Cartel_NFT from 0x329feb3ab062d289\nimport UFC_NFT from 0x329feb3ab062d289\nimport MotoGPCard from 0xa49cc0ee46c54bfb\nimport Gaia from 0x8b148183c28ff88f\nimport ChainmonstersRewards from 0x93615d25d14fa337\nimport Moments from 0xd4ad4740ee426334\nimport MatrixWorldFlowFestNFT from 0x2d2750f240198f91\nimport MatrixWorldAssetsNFT from 0xf20df769e658c257\n\nimport SturdyItems from 0x427ceada271aa0b1\nimport Evolution from 0xf4264ac8f3256818\nimport GeniaceNFT from 0xabda6627c70c7f52\nimport OneFootballCollectible from 0x6831760534292098\nimport CryptoPiggo from 0xd3df824bf81910a4\nimport GoatedGoatsVouchers from 0xdfc74d9d561374c0\nimport TraitPacksVouchers from 0xdfc74d9d561374c0\nimport GoatedGoats from 0x2068315349bdfce5\nimport GoatedGoatsTrait from 0x2068315349bdfce5\nimport GoatedGoatsTraitPack from 0x2068315349bdfce5\n\nimport HaikuNFT from 0xf61e40c19db2a9e2\nimport KlktnNFT from 0xabd6e80be7e9682c\nimport Mynft from 0xf6fcbef550d97aa5\nimport NeoAvatar from 0xb25138dbf45e5801\nimport NeoVoucher from 0xb25138dbf45e5801\nimport NeoMember from 0xb25138dbf45e5801\nimport NeoViews from 0xb25138dbf45e5801\nimport MetadataViews from 0x1d7e57aa55817448\nimport BarterYardPackNFT from 0xa95b021cf8a30d80\nimport BarterYardClubWerewolf from  0x28abb9f291cadaf2\n\n//Jambb\nimport Vouchers from 0x444f5ea22c6ea12c\n\n//xtingles\nimport Collectible from 0xf5b0eb433389ac3f\n\nimport StarlyCard from 0x5b82f21c0edf76e3\nimport StarlyMetadataViews from 0x5b82f21c0edf76e3\nimport Momentables from 0x9d21537544d9123d\nimport ZeedzINO from 0x62b3063fbe672fc8\nimport PartyMansionDrinksContract from 0x34f2bf4a80bb0f69\n\npub struct MetadataCollections {\n\n    pub let items: {String : MetadataCollectionItem}\n    pub let collections: {String : [String]}\n    pub let curatedCollections: {String : [String]}\n\n    init(items: {String : MetadataCollectionItem}, collections: {String : [String]}, curatedCollections: {String: [String]}) {\n        self.items=items\n        self.collections=collections\n        self.curatedCollections=curatedCollections\n    }\n}\n\n\npub struct MetadataCollection{\n    pub let type: String\n    pub let items: [MetadataCollectionItem]\n\n    init(type:String, items: [MetadataCollectionItem]) {\n        self.type=type\n        self.items=items\n    }\n}\n\n\npub struct MetadataCollectionItem {\n    pub let id:UInt64\n    pub let name: String\n    pub let image: String\n    pub let url: String\n    pub let listPrice: UFix64?\n    pub let listToken: String?\n    pub let contentType:String\n    pub let rarity:String\n\n\n    init(id:UInt64, name:String, image:String, url:String, listPrice: UFix64?, listToken:String?, contentType: String, rarity: String) {\n        self.id=id\n        self.name=name\n        self.url=url\n        self.image=image\n        self.listToken=listToken\n        self.listPrice=listPrice\n        self.contentType=contentType\n        self.rarity=rarity\n    }\n}\n\npub fun main(user: String) : MetadataCollections? {\n\n    let resolvingAddress = FIND.resolve(user)\n    if resolvingAddress == nil {\n        return nil\n    }\n    let address = resolvingAddress!\n    let resultMap : {String : MetadataCollectionItem} = {}\n    let account = getAccount(address)\n    let results : {String :  [String]}={}\n\n    let flovatarList= Flovatar.getFlovatars(address: address)\n    let flovatarMarketDetails = FlovatarMarketplace.getFlovatarSales(address: address)\n    if flovatarList.length \u003e 0 || flovatarMarketDetails.length \u003e 0 {\n        let items: [String] = []\n        for flovatar in flovatarList  {\n            var name = flovatar.name\n            if name == \"\" {\n                name=\"Flovatar #\".concat(flovatar.id.toString())\n            }\n\n            var rarity=\"common\"\n            if flovatar.metadata.legendaryCount \u003e 0 {\n                rarity=\"legendary\"\n            }else if flovatar.metadata.epicCount \u003e 0 {\n                rarity=\"epic\"\n            }else if flovatar.metadata.rareCount \u003e 0 {\n                rarity=\"rare\"\n            }\n\n\n            let item=MetadataCollectionItem(\n                id: flovatar.id, \n                name: name, \n                image: \"https://flovatar.com/api/image/\".concat(flovatar.id.toString()),\n                url: \"https://flovatar.com/flovatars/\".concat(flovatar.id.toString()).concat(\"/\"),\n                listPrice: nil,\n                listToken: nil,\n                contentType: \"image\",\n                rarity: rarity\n            )\n            let itemId=\"Flovatar\".concat(flovatar.id.toString())\n            items.append(itemId)\n            resultMap[itemId] = item\n        }\n\n        for flovatar in flovatarMarketDetails  {\n            var    name=\"Flovatar #\".concat(flovatar.id.toString())\n\n            var rarity=\"common\"\n            if flovatar.metadata.legendaryCount \u003e 0 {\n                rarity=\"legendary\"\n            }else if flovatar.metadata.epicCount \u003e 0 {\n                rarity=\"epic\"\n            }else if flovatar.metadata.rareCount \u003e 0 {\n                rarity=\"rare\"\n            }\n\n\n            let item=MetadataCollectionItem(\n                id: flovatar.id, \n                name: name, \n                image: \"https://flovatar.com/api/image/\".concat(flovatar.id.toString()),\n                url: \"https://flovatar.com/flovatars/\".concat(flovatar.id.toString()).concat(\"/\"),\n                listPrice: flovatar.price,\n                listToken: \"Flow\",\n                contentType: \"image\",\n                rarity: rarity\n            )\n\n            let itemId=\"Flovatar\".concat(flovatar.id.toString())\n            items.append(itemId)\n            resultMap[itemId] = item\n\n        }\n\n        if items.length != 0 {\n            results[\"Flovatar\"] = items\n        }\n    }\n\n    let versusMarketplace = account.getCapability\u003c\u0026{Marketplace.SalePublic}\u003e(Marketplace.CollectionPublicPath)\n    let versusImageUrlPrefix = \"https://res.cloudinary.com/dxra4agvf/image/upload/c_fill,w_600/f_auto/maincache\"\n    let artList = Art.getArt(address: address)\n    if artList.length \u003e 0 || versusMarketplace.check() {\n        let items: [String] = []\n        for art in artList {\n            let item=MetadataCollectionItem(\n                id: art.id, \n                name: art.metadata.name.concat(\" edition \").concat(art.metadata.edition.toString()).concat(\"/\").concat(art.metadata.maxEdition.toString()).concat(\" by \").concat(art.metadata.artist),  \n                image: versusImageUrlPrefix.concat(art.cacheKey), \n                url: \"https://www.versus.auction/piece/\".concat(address.toString()).concat(\"/\").concat(art.id.toString()).concat(\"/\"),\n                listPrice: nil,\n                listToken: nil,\n                contentType: \"image\",\n                rarity: \"\"\n            )\n            let itemId=\"Versus\".concat(art.id.toString())\n            items.append(itemId)\n            resultMap[itemId] = item\n\n        }\n        if versusMarketplace.check() {\n            let versusMarket = versusMarketplace.borrow()!.listSaleItems()\n            for saleItem in versusMarket {\n                let item=MetadataCollectionItem(\n                    id: saleItem.id, \n                    name: saleItem.art.name.concat(\" edition \").concat(saleItem.art.edition.toString()).concat(\"/\").concat(saleItem.art.maxEdition.toString()).concat(\" by \").concat(saleItem.art.artist),\n                    image: versusImageUrlPrefix.concat(saleItem.cacheKey), \n                    url: \"https://www.versus.auction/listing/\".concat(saleItem.id.toString()).concat(\"/\"),\n                    listPrice: saleItem.price,\n                    listToken: \"Flow\",\n                    contentType: \"image\",\n                    rarity: \"\"\n                )\n\n                let itemId=\"Versus\".concat(saleItem.id.toString())\n                items.append(itemId)\n                resultMap[itemId] = item\n            }\n        }\n        if items.length != 0 {\n            results[\"Versus\"]= items\n        }\n    }\n\n\n\n\n    let partyMansion: [String] = []\n    let goobersCap = account.getCapability\u003c\u0026GooberXContract.Collection{NonFungibleToken.CollectionPublic, GooberXContract.GooberCollectionPublic}\u003e(GooberXContract.CollectionPublicPath)\n    if goobersCap.check() {\n        let goobers = goobersCap.borrow()!.listUsersGoobers()\n        for id in goobers.keys {\n            let goober = goobers[id]!\n            let item=MetadataCollectionItem(\n                id: id,\n                name: \"Goober #\".concat(id.toString()),\n                image: goober.uri,\n                url: \"https://partymansion.io/gooberz/\".concat(id.toString()),\n                listPrice: nil,\n                listToken: nil,\n                contentType: \"image\",\n                rarity: \"\"\n            )\n            let itemId=\"Gooberz\".concat(id.toString())\n            partyMansion.append(itemId)\n            resultMap[itemId] = item\n        }\n    }\n\n\n    let partyMansionDrinksCap = account.getCapability\u003c\u0026{PartyMansionDrinksContract.DrinkCollectionPublic}\u003e(PartyMansionDrinksContract.CollectionPublicPath)\n    if partyMansionDrinksCap.check() {\n        let collection = partyMansionDrinksCap.borrow()!\n        for id in collection.getIDs() {\n            let nft = collection.borrowDrink(id: id)!\n            let item = MetadataCollectionItem(\n                id: id,\n                name: nft.data.description,\n                image: \"ipfs://\".concat(nft.imageCID()),\n                url: \"https://partymansion.io\",\n                listPrice: nil,\n                listToken: nil,\n                contentType: \"image\",\n                rarity: PartyMansionDrinksContract.rarityToString(rarity:nft.data.rarity)\n            )\n\n            let itemId=\"PartyMansionDrinks\".concat(id.toString())\n            partyMansion.append(itemId)\n            resultMap[itemId] = item\n        }\n    }\n\n    if partyMansion.length != 0 {\n        results[\"PartyMansion\"] = partyMansion\n    }\n\n    let rareRoomCap = account.getCapability\u003c\u0026RareRooms_NFT.Collection{RareRooms_NFT.RareRooms_NFTCollectionPublic}\u003e(RareRooms_NFT.CollectionPublicPath)\n    if rareRoomCap.check() {\n        let collection = rareRoomCap.borrow()!\n        let items: [String] = []\n        for id in collection.getIDs() {\n            let nft = collection.borrowRareRooms_NFT(id: id)!\n            let metadata = RareRooms_NFT.getSetMetadata(setId: nft.setId)!\n            let item = MetadataCollectionItem(\n                id: id,\n                name: metadata[\"name\"]!,\n                image: metadata[\"preview\"]!,\n                url: \"https://rarerooms.io/tokens/\".concat(id.toString()),\n                listPrice: nil,\n                listToken: nil,\n                contentType: \"image\",\n                rarity: \"\"\n            )\n\n            let itemId=\"RareRooms\".concat(id.toString())\n            items.append(itemId)\n            resultMap[itemId] = item\n        }\n\n        if items.length != 0 {\n            results[\"RareRooms\"] = items\n        }\n    }\n\n    let cnnCap = account.getCapability\u003c\u0026CNN_NFT.Collection{CNN_NFT.CNN_NFTCollectionPublic}\u003e(CNN_NFT.CollectionPublicPath)\n    if cnnCap.check() {\n        let collection = cnnCap.borrow()!\n        let items: [String] = []\n        for id in collection.getIDs() {\n            let nft = collection.borrowCNN_NFT(id: id)!\n            let metadata = CNN_NFT.getSetMetadata(setId: nft.setId)!\n\n            var image= metadata[\"preview\"]!\n            var contentType=\"image\"\n            /*\n            if metadata[\"image_file_type\"]! == \"mp4\" {\n                image=metadata[\"image\"]!\n                contentType=\"video\"\n            }\n            */\n            let item = MetadataCollectionItem(\n                id: id,\n                name: metadata[\"name\"]!,\n                image: image,\n                url: \"http://vault.cnn.com\",\n                listPrice: nil,\n                listToken: nil,\n                contentType: contentType,\n                rarity: \"\"\n            )\n\n            let itemId=\"CNN\".concat(id.toString())\n            items.append(itemId)\n            resultMap[itemId] = item\n        }\n\n        if items.length != 0 {\n            results[\"CNN\"] = items\n        }\n    }\n\n    let canesVaultCap = account.getCapability\u003c\u0026Canes_Vault_NFT.Collection{Canes_Vault_NFT.Canes_Vault_NFTCollectionPublic}\u003e(Canes_Vault_NFT.CollectionPublicPath)\n    if canesVaultCap.check() {\n        let collection = canesVaultCap.borrow()!\n        let items: [String] = []\n        for id in collection.getIDs() {\n            let nft = collection.borrowCanes_Vault_NFT(id: id)!\n            let metadata = Canes_Vault_NFT.getSetMetadata(setId: nft.setId)!\n            var image= metadata[\"preview\"]!\n            var contentType=\"image\"\n            /*\n            if metadata[\"image_file_type\"]! == \"mp4\" {\n                image=metadata[\"image\"]!\n                contentType=\"video\"\n            }\n            */\n\n            let item = MetadataCollectionItem(\n                id: id,\n                name: metadata[\"name\"]!,\n                image: image,\n                url: \"https://canesvault.com/\",\n                listPrice: nil,\n                listToken: nil,\n                contentType: contentType,\n                rarity: \"\"\n            )\n\n            let itemId=\"Canes_Vault_NFT\".concat(id.toString())\n            items.append(itemId)\n            resultMap[itemId] = item\n        }\n\n        if items.length != 0 {\n            results[\"Canes_Vault_NFT\"] = items\n        }\n    }\n\n    let dgdCap = account.getCapability\u003c\u0026DGD_NFT.Collection{DGD_NFT.DGD_NFTCollectionPublic}\u003e(DGD_NFT.CollectionPublicPath)\n    if dgdCap.check() {\n        let collection = dgdCap.borrow()!\n        let items: [String] = []\n        for id in collection.getIDs() {\n            let nft = collection.borrowDGD_NFT(id: id)!\n            let metadata = DGD_NFT.getSetMetadata(setId: nft.setId)!\n            var image= metadata[\"preview\"]!\n            var contentType=\"image\"\n            /*\n            if metadata[\"image_file_type\"]! == \"mp4\" {\n                image=metadata[\"image\"]!\n                contentType=\"video\"\n            }\n            */\n\n\n            let item = MetadataCollectionItem(\n                id: id,\n                name: metadata[\"name\"]!,\n                image: image,\n                url: \"https://www.theplayerslounge.io/\",\n                listPrice: nil,\n                listToken: nil,\n                contentType: contentType,\n                rarity: \"\"\n            )\n\n            let itemId=\"DGD_NFT\".concat(id.toString())\n            items.append(itemId)\n            resultMap[itemId] = item\n        }\n\n        if items.length != 0 {\n            results[\"DGD_NFT\"] = items\n        }\n    }\n\n    let raceDayCap = account.getCapability\u003c\u0026RaceDay_NFT.Collection{RaceDay_NFT.RaceDay_NFTCollectionPublic}\u003e(RaceDay_NFT.CollectionPublicPath)\n    if raceDayCap.check() {\n        let collection = raceDayCap.borrow()!\n        let items: [String] = []\n        for id in collection.getIDs() {\n            let nft = collection.borrowRaceDay_NFT(id: id)!\n            let metadata = RaceDay_NFT.getSetMetadata(setId: nft.setId)!\n            var image= metadata[\"preview\"]!\n            var contentType=\"image\"\n            /*\n            if metadata[\"image_file_type\"]! == \"mp4\" {\n                image=metadata[\"image\"]!\n                contentType=\"video\"\n            }\n            */\n\n\n            let item = MetadataCollectionItem(\n                id: id,\n                name: metadata[\"name\"]!,\n                image: image, \n                url: \"https://www.racedaynft.com\",\n                listPrice: nil,\n                listToken: nil,\n                contentType: contentType,\n                rarity: \"\"\n            )\n\n            let itemId=\"RaceDay_NFT\".concat(id.toString())\n            items.append(itemId)\n            resultMap[itemId] = item\n        }\n\n        if items.length != 0 {\n            results[\"RaceDay_NFT\"] = items\n        }\n    }\n\n    let nextCartelCap = account.getCapability\u003c\u0026The_Next_Cartel_NFT.Collection{The_Next_Cartel_NFT.The_Next_Cartel_NFTCollectionPublic}\u003e(The_Next_Cartel_NFT.CollectionPublicPath)\n    if nextCartelCap.check() {\n        let collection = nextCartelCap.borrow()!\n        let items: [String] = []\n        for id in collection.getIDs() {\n            let nft = collection.borrowThe_Next_Cartel_NFT(id: id)!\n            let metadata = The_Next_Cartel_NFT.getSetMetadata(setId: nft.setId)!\n            var image= metadata[\"preview\"]!\n            var contentType=\"image\"\n            let item = MetadataCollectionItem(\n                id: id,\n                name: metadata[\"name\"]!,\n                // we use \"preview\" and not \"image\" because of potential .glg and .mp4 file types\n                image: image,\n                url: \"https://thenextcartel.com/\",\n                listPrice: nil,\n                listToken: nil,\n                contentType: contentType,\n                rarity: \"\"\n            )\n\n            let itemId=\"The_Next_Cartel_NFT\".concat(id.toString())\n            items.append(itemId)\n            resultMap[itemId] = item\n        }\n\n        if items.length != 0 {\n            results[\"The_Next_Cartel_NFT\"] = items\n        }\n    }\n\n    let ufcCap = account.getCapability\u003c\u0026UFC_NFT.Collection{UFC_NFT.UFC_NFTCollectionPublic}\u003e(UFC_NFT.CollectionPublicPath)\n    if ufcCap.check() {\n        let collection = ufcCap.borrow()!\n        let items: [String] = []\n        for id in collection.getIDs() {\n            let nft = collection.borrowUFC_NFT(id: id)!\n            let metadata = UFC_NFT.getSetMetadata(setId: nft.setId)!\n            var image= metadata[\"image\"]!\n            var contentType=\"video\"\n            let item = MetadataCollectionItem(\n                id: id,\n                name: metadata[\"name\"]!,\n                image: image,\n                url: \"https://www.ufcstrike.com\",\n                listPrice: nil,\n                listToken: nil,\n                contentType: contentType,\n                rarity: \"\"\n            )\n\n            let itemId=\"UFC\".concat(id.toString())\n            items.append(itemId)\n            resultMap[itemId] = item\n        }\n\n        if items.length != 0 {\n            results[\"UFC\"] = items\n        }\n    }\n\n    let motoGPCollection = account.getCapability\u003c\u0026MotoGPCard.Collection{MotoGPCard.ICardCollectionPublic}\u003e(/public/motogpCardCollection)\n    if motoGPCollection.check() {\n        let motoGPNfts = motoGPCollection.borrow()!.getIDs()\n        let items: [String] = []\n        for id in motoGPNfts {\n            let nft = motoGPCollection.borrow()!.borrowCard(id: id)!\n            let metadata = nft.getCardMetadata()!\n            let item=MetadataCollectionItem(\n                id: id,\n                name: metadata.name,\n                image: metadata.imageUrl,\n                url: \"https://motogp-ignition.com/nft/card/\".concat(id.toString()).concat(\"?owner=\").concat(address.toString()),\n                listPrice: nil,\n                listToken: nil,\n                contentType: \"image\",\n                rarity: \"\"\n            )\n\n\n            let itemId=\"MotoGP\".concat(id.toString())\n            items.append(itemId)\n            resultMap[itemId] = item\n        }\n\n        if items.length != 0 {\n            results[\"MotoGP\"] = items\n        }\n    }\n\n    let gaiaCollection = account.getCapability\u003c\u0026{Gaia.CollectionPublic}\u003e(Gaia.CollectionPublicPath)\n    if gaiaCollection.check() {\n\n        let gaiaNfts = gaiaCollection.borrow()!.getIDs()\n        let items: [String] = []\n        for id in gaiaNfts {\n            let nft = gaiaCollection.borrow()!.borrowGaiaNFT(id: id)!\n            let metadata = Gaia.getTemplateMetaData(templateID: nft.data.templateID)!\n\n            //For ballerz we can do this...\n            var url=\"http://ongaia.com/ballerz/\".concat(metadata[\"id\"]!)\n            var name=metadata[\"title\"]!\n\n            if let seriesFullName=metadata[\"series\"] {\n\n                if seriesFullName==\"Shareef O\\u{2019}Neal - Basketball\" {\n                    //If the series is basketball with shareef we can do this\n                    url=\"http://ongaia.com/sharef/\".concat(id.toString())\n                    name=metadata[\"title\"]!.concat(\" #\").concat(nft.data.mintNumber.toString())\n                }else if seriesFullName==\"Bryson DeChambeau - Vegas, Baby!\" {\n                    //For golf there is yet another way\n                    url=\"http://ongaia.com/bryson/\".concat(nft.data.mintNumber.toString())\n                    name=metadata[\"title\"]!.concat(\" #\").concat(nft.data.mintNumber.toString())\n                }\n            }\n\n            let item= MetadataCollectionItem(\n                id: id,\n                name: name,\n                image: metadata[\"img\"]!,\n                url: url,\n                listPrice: nil,\n                listToken: nil,\n                contentType: \"image\",\n                rarity: \"\"\n            )\n\n            let itemId=\"Gaia\".concat(id.toString())\n            items.append(itemId)\n            resultMap[itemId] = item\n        }\n\n        if items.length != 0 {\n            results[\"Gaia\"] = items\n        }\n    }\n\n    /*\n    let chamonsterSeasonTable :  {UInt32: String} = {0 : \"kickstarter\", 1 : \"alpha\", 2 : \"genesis\", 4 : \"flowfest2021\" , 3: \"closedbeta\" }\n\n    let chainmonstersRewardsCollection = account.getCapability\u003c\u0026{ChainmonstersRewards.ChainmonstersRewardCollectionPublic}\u003e(/public/ChainmonstersRewardCollection)\n    if chainmonstersRewardsCollection.check() {\n        let nfts = chainmonstersRewardsCollection.borrow()!.getIDs()\n        let items: [MetadataCollectionItem] = []\n        for id in nfts {\n            let nft = chainmonstersRewardsCollection.borrow()!.borrowReward(id: id)!\n            let rewardID = nft.data.rewardID\n            // Other interesting metadata available are:\n            //         - serialNumber: nft.data.serialNumber\n            //         - totalMinted: ChainmonstersRewards.getNumRewardsMinted(rewardID: nft.data.rewardID)!\n            let season = ChainmonstersRewards.getRewardSeason(rewardID:nft.data.rewardID)!\n\n            var seasonName = chamonsterSeasonTable[season] ?? \"unknown\".concat(season.toString())\n\n            if season == 3 \u0026\u0026 rewardID \u003c 45 {\n                seasonName = \"flowfest2021\"\n            }\n            items.append(MetadataCollectionItem(\n                id: id,\n                name: ChainmonstersRewards.getRewardMetaData(rewardID: nft.data.rewardID)!,\n                image: \"https://chainmonsters.com/images/rewards/\".concat(seasonName).concat(\"/\").concat(rewardID.toString()).concat(\".png\"),\n                url: \"https://chainmonsters.com\",\n                listPrice: nil,\n                listToken: nil,\n                contentType: \"image\"\n            ))\n        }\n        if items.length != 0 {\n            results[\"ChainmonstersRewards\"] = MetadataCollection(type: Type\u003c@ChainmonstersRewards.Collection\u003e().identifier, items: items)\n        }\n    }\n    */\n\n    let jambb: [String] = []\n    let jambbCap = account.getCapability\u003c\u0026Moments.Collection{Moments.CollectionPublic}\u003e(Moments.CollectionPublicPath)\n    if jambbCap.check() {\n        let nfts = jambbCap.borrow()!.getIDs()\n        for id in nfts {\n            let nft = jambbCap.borrow()!.borrowMoment(id: id)!\n            let metadata=nft.getMetadata()\n            let item  =MetadataCollectionItem(\n                id: id,\n                name: metadata.contentName,\n                image: \"ipfs://\".concat(metadata.videoHash),\n                url: \"https://www.jambb.com/c/moment/\".concat(id.toString()),\n                listPrice: nil,\n                listToken: nil,\n                contentType: \"video\",\n                rarity: \"\"\n            )\n            let itemId=\"Jambb\".concat(id.toString())\n            jambb.append(itemId)\n            resultMap[itemId] = item\n        }\n    }\n\n    let voucherCap = account.getCapability\u003c\u0026{Vouchers.CollectionPublic}\u003e(Vouchers.CollectionPublicPath)\n    if voucherCap.check() {\n        let collection = voucherCap.borrow()!\n        for id in collection.getIDs() {\n            let nft = collection.borrowVoucher(id: id)!\n            let metadata=nft.getMetadata()!\n\n            let url=\"https://jambb.com\"\n            let item = MetadataCollectionItem(\n                id: id,\n                name: metadata.name,\n                image: \"ipfs://\".concat(metadata.mediaHash),\n                url: url,\n                listPrice: nil,\n                listToken: nil,\n                contentType: metadata.mediaType,\n                rarity: \"\"\n            )\n            let itemId=\"JambbVoucher\".concat(id.toString())\n            jambb.append(itemId)\n            resultMap[itemId] = item\n        }\n\n\n    }\n\n    if jambb.length != 0 {\n        results[\"Jambb\"] = jambb\n    }\n\n    let mw = MatrixWorldFlowFestNFT.getNft(address:address)\n    let mwItems: [String] = []\n    if mw.length \u003e 0 {\n        for nft in mw {\n            let metadata=nft.metadata\n            let item=MetadataCollectionItem(\n                id: nft.id,\n                name: metadata.name,\n                image: metadata.animationUrl,\n                url: \"https://matrixworld.org/\",\n                listPrice: nil,\n                listToken: nil,\n                contentType: \"image\",\n                rarity: \"\"\n            )\n            let itemId=\"MatrixWorldFlowFest\".concat(nft.id.toString())\n            mwItems.append(itemId)\n            resultMap[itemId] = item\n        }\n\n    }\n\n    let matrixworldAsset = account.getCapability\u003c\u0026{MatrixWorldAssetsNFT.Metadata, NonFungibleToken.CollectionPublic}\u003e(MatrixWorldAssetsNFT.collectionPublicPath)\n    if matrixworldAsset.check() {\n        let collection = matrixworldAsset.borrow()!\n        for id in collection.getIDs() {\n            let metadata = collection.getMetadata(id: id)!\n\n\n            /*\n            Result: {\"collection\": \"MW x Flow Holiday Giveaway\", \"description\": \"First Edition Matrix World Santa Hat. Only 50 pieces made.\", \"animation_url\": \"\", \"image\": \"https://d2yoccx42eml7e.cloudfront.net/airdrop/MWxFlowxHoliday/Santa_Hat.png\", \"name\": \"First Edition Santa Hat\", \"external_url\": \"https://matrixworld.org/home\", \"version\": \"assets-v0.1.1\", \"attributes\": \"\"}\n            */\n            let item = MetadataCollectionItem(\n                id: id,\n                name: metadata[\"name\"]!,\n                image: metadata[\"image\"]!,\n                url: metadata[\"external_url\"]!,\n                listPrice: nil,\n                listToken: nil,\n                contentType: \"image\",\n                rarity: \"\"\n            )\n            let itemId=\"MatrixWorldAsset\".concat(id.toString())\n            mwItems.append(itemId)\n            resultMap[itemId] = item\n        }\n    }\n\n    if mwItems.length != 0 {\n        results[\"MatrixWorld\"] = mwItems\n    }\n\n    let sturdyCollectionCap = account.getCapability\u003c\u0026SturdyItems.Collection{SturdyItems.SturdyItemsCollectionPublic}\u003e(SturdyItems.CollectionPublicPath)\n    if sturdyCollectionCap.check() {\n        let sturdyNfts = sturdyCollectionCap.borrow()!.getIDs()\n        let items: [String] = []\n        for id in sturdyNfts {\n            // the metadata is a JSON stored on IPFS at the address nft.tokenURI\n            let nft = sturdyCollectionCap.borrow()!.borrowSturdyItem(id: id)!\n            // the only thing we can play with is the nft title which is for example:\n            //     - \"HOODLUM#10\"\n            //     - \"HOLIDAY MYSTERY BADGE 2021\"\n            //  - \"EXCALIBUR\"\n            let isHoodlum = nft.tokenTitle.slice(from: 0, upTo: 7) == \"HOODLUM\"\n            if isHoodlum {\n                // the hoodlum id is needed to retrieve the image but is not in the nft\n                let hoodlumId = nft.tokenTitle.slice(from: 8, upTo: nft.tokenTitle.length)\n                let item=MetadataCollectionItem(\n                    id: id,\n                    name: nft.tokenTitle,\n                    image: \"https://hoodlumsnft.com/_next/image?url=%2Fthumbs%2FsomeHoodlum_\".concat(hoodlumId).concat(\".png\u0026w=1920\u0026q=75\"),\n                    url: \"https://hoodlumsnft.com/\",\n                    listPrice:nil,\n                    listToken:nil,\n                    contentType:\"image\",\n                    rarity: \"\"\n                )\n                let itemId=\"Hoodlums\".concat(id.toString())\n                items.append(itemId)\n                resultMap[itemId] = item\n            }\n        }\n        if items.length != 0 {\n            results[\"Hoodlums\"] = items\n        }\n    }\n\n    let charityCap = account.getCapability\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection)\n    if charityCap.check() {\n        let items: [String] = []\n        let collection = charityCap.borrow()!\n        for id in collection.getIDs() {\n            let nft = collection.borrowCharity(id: id)!\n            let metadata = nft.getMetadata()\n            let item=MetadataCollectionItem(\n                id: id,\n                name: metadata[\"name\"]!,\n                image: metadata[\"thumbnail\"]!,\n                url: metadata[\"originUrl\"]!,\n                listPrice: nil,\n                listToken: nil,\n                contentType:\"image\",\n                rarity: \"\"\n            )\n            let itemId=\"Charity\".concat(id.toString())\n            items.append(itemId)\n            resultMap[itemId] = item\n\n        }\n        if items.length != 0 {\n            results[\"Find\"] = items\n        }\n    }\n\n    let evolutionCap=account.getCapability\u003c\u0026{Evolution.EvolutionCollectionPublic}\u003e(/public/f4264ac8f3256818_Evolution_Collection)\n    if evolutionCap.check() {\n        let evolution=evolutionCap.borrow()!\n        let nfts = evolution.getIDs()\n        let items: [String] = []\n        for id in nfts{\n            // the metadata is a JSON stored on IPFS at the address nft.tokenURI\n            let nft = evolution.borrowCollectible(id: id)!\n            let metadata = Evolution.getItemMetadata(itemId: nft.data.itemId)!\n            let item=MetadataCollectionItem(\n                id: id,\n                name: metadata[\"Title\"]!.concat(\" #\").concat(nft.data.serialNumber.toString()),\n                image: \"https://storage.viv3.com/0xf4264ac8f3256818/mv/\".concat(nft.data.itemId.toString()),\n                url: \"https://www.evolution-collect.com/\",\n                listPrice: nil,\n                listToken: nil,\n                contentType:\"video\",\n                rarity: \"\"\n            )\n\n            let itemId=\"Evolution\".concat(id.toString())\n            items.append(itemId)\n            resultMap[itemId] = item\n        }\n\n        if items.length != 0 {\n            results[\"Evolution\"] = items\n        }\n    }\n\n\n    let geniaceCap = account.getCapability\u003c\u0026GeniaceNFT.Collection{NonFungibleToken.CollectionPublic, GeniaceNFT.GeniaceNFTCollectionPublic}\u003e(GeniaceNFT.CollectionPublicPath)\n    if geniaceCap.check() {\n        let geniace=geniaceCap.borrow()!\n        let nfts = geniace.getIDs()\n        let items: [String] = []\n        for id in nfts{\n            // the metadata is a JSON stored on IPFS at the address nft.tokenURI\n            let nft = geniace.borrowGeniaceNFT(id: id)!\n            let metadata = nft.metadata\n            var rarity=\"\"\n            if metadata.rarity == GeniaceNFT.Rarity.Collectible {\n                rarity=\"Collectible\"\n            }else if metadata.rarity == GeniaceNFT.Rarity.Rare {\n                rarity=\"Rare\"\n            }else if metadata.rarity == GeniaceNFT.Rarity.UltraRare {\n                rarity=\"UltraRare\"\n            }\n\n            let item=MetadataCollectionItem(\n                id: id,\n                name: metadata.name,\n                image: metadata.imageUrl,\n                url: \"https://www.geniace.com/product/\".concat(id.toString()),\n                listPrice: nil,\n                listToken: nil,\n                contentType: metadata.data[\"mimetype\"]!,\n                rarity: rarity,\n            )\n\n            let itemId=\"Geniace\".concat(id.toString())\n            items.append(itemId)\n            resultMap[itemId] = item\n        }\n\n        if items.length != 0 {\n            results[\"Geniace\"] = items\n        }\n    }\n\n    // https://flow-view-source.com/mainnet/account/0x6831760534292098/contract/OneFootballCollectible\n    let oneFootballCollectibleCap = account.getCapability\u003c\u0026OneFootballCollectible.Collection{OneFootballCollectible.OneFootballCollectibleCollectionPublic}\u003e(OneFootballCollectible.CollectionPublicPath)\n    if oneFootballCollectibleCap.check() {\n        let items: [String] = []\n        let collection = oneFootballCollectibleCap.borrow()!\n        for id in collection.getIDs() {\n            let nft = collection.borrowOneFootballCollectible(id: id)!\n            let metadata = nft.getTemplate()!\n            let item=MetadataCollectionItem(\n                id: id,\n                name: metadata.name,\n                image: \"ipfs://\".concat(metadata.media),\n                url: \"https://xmas.onefootball.com/\".concat(account.address.toString()),\n                listPrice: nil,\n                listToken: nil,\n                contentType: \"video\",\n                rarity: \"\"\n\n            )\n            let itemId=\"OneFootballCollectible\".concat(id.toString())\n            items.append(itemId)\n            resultMap[itemId] = item\n\n        }\n        if items.length != 0 {\n            results[\"OneFootballCollectible\"] = items\n        }\n    }\n\n\n    let cryptoPiggoCap = account.getCapability\u003c\u0026{CryptoPiggo.CryptoPiggoCollectionPublic}\u003e(CryptoPiggo.CollectionPublicPath)\n    if cryptoPiggoCap.check() {\n        let items: [String] = []\n        let collection = cryptoPiggoCap.borrow()!\n        for id in collection.getIDs() {\n            let nft = collection.borrowItem(id: id)!\n            let item=MetadataCollectionItem(\n                id: id,\n                name: \"CryptoPiggo #\".concat(id.toString()),\n                image: \"https://s3.us-west-2.amazonaws.com/crypto-piggo.nft/piggo-\".concat(id.toString()).concat(\".png\"),\n                url: \"https://rareworx.com/piggo/details/\".concat(id.toString()),\n                listPrice: nil,\n                listToken: nil,\n                contentType: \"image\",\n                rarity: \"\"\n\n            )\n            let itemId=\"CryptoPiggo\".concat(id.toString())\n            items.append(itemId)\n            resultMap[itemId] = item\n\n        }\n        if items.length != 0 {\n            results[\"CryptoPiggo\"] = items\n        }\n    }\n\n    let xtingles = Collectible.getCollectibleDatas(address:address) \n    if xtingles.length \u003e 0 {\n        let items: [String] = []\n        for nft in xtingles {\n\n            var image=nft.metadata.link\n\n            let prefix=\"https://\"\n            if image.slice(from:0, upTo:prefix.length) != prefix {\n                image=\"ipfs://\".concat(image)\n            }\n            let item=MetadataCollectionItem(\n                id: nft.id,\n                name: nft.metadata.name.concat(\" #\").concat(nft.metadata.edition.toString()),\n                image: image,\n                url: \"http://xtingles.com\",\n                listPrice: nil,\n                listToken: nil,\n                contentType: \"video\",\n                rarity: \"\"\n            )\n            let itemId=\"Xtingles\".concat(nft.id.toString())\n            items.append(itemId)\n            resultMap[itemId] = item\n\n\n        }\n        if items.length != 0 {\n            results[\"Xtingles\"] = items\n        }\n    }\n\n    let goatsCap = account.getCapability\u003c\u0026{GoatedGoatsVouchers.GoatsVoucherCollectionPublic}\u003e(GoatedGoatsVouchers.CollectionPublicPath)\n    var goats : [String]=[]\n    if goatsCap.check() {\n        let goatsImageUrl= GoatedGoatsVouchers.getCollectionMetadata()[\"mediaURL\"]!\n        let collection = goatsCap.borrow()!\n        for id in collection.getIDs() {\n            let item=MetadataCollectionItem(\n                id: id,\n                name: \"Goated Goat Base Goat Voucher #\".concat(id.toString()),\n                image: goatsImageUrl, \n                url: \"https://goatedgoats.com/\",\n                listPrice: nil,\n                listToken: nil,\n                contentType: \"image\",\n                rarity: \"\"\n\n            )\n            let itemId=\"GoatedGoatsVoucher\".concat(id.toString())\n            goats.append(itemId)\n            resultMap[itemId] = item\n        }\n    }\n\n\n    let goatsTraitCap = account.getCapability\u003c\u0026{TraitPacksVouchers.PackVoucherCollectionPublic}\u003e(TraitPacksVouchers.CollectionPublicPath)\n    if goatsTraitCap.check() {\n        let goatsImageUrl= TraitPacksVouchers.getCollectionMetadata()[\"mediaURL\"]!\n        let collection = goatsTraitCap.borrow()!\n        for id in collection.getIDs() {\n            let item=MetadataCollectionItem(\n                id: id,\n                name: \"Goated Goat Trait Pack Voucher #\".concat(id.toString()),\n                image: goatsImageUrl, \n                url: \"https://goatedgoats.com/\",\n                listPrice: nil,\n                listToken: nil,\n                contentType: \"image\",\n                rarity: \"\"\n\n            )\n            let itemId=\"GoatedGoatsTraitVoucher\".concat(id.toString())\n            goats.append(itemId)\n            resultMap[itemId] = item\n        }\n    }\n\n\n    let goatedGoats = getItemForMetadataStandard(path: GoatedGoats.CollectionPublicPath, account: account, externalFixedUrl: \"https://goatedgoats.com\")\n    for item in goatedGoats {\n        let itemId=\"GoatedGoats\".concat(item.id.toString())\n        goats.append(itemId)\n        resultMap[itemId] = item\n    }\n\n\n    let goatedGoatsTrait = getItemForMetadataStandard(path: GoatedGoatsTrait.CollectionPublicPath, account: account, externalFixedUrl: \"https://goatedgoats.com\")\n    for item in goatedGoatsTrait {\n        let itemId=\"GoatedGoatsTraits\".concat(item.id.toString())\n        goats.append(itemId)\n        resultMap[itemId] = item\n    }\n\n\n    let goatedGoatsTraitPack = getItemForMetadataStandard(path: GoatedGoatsTraitPack.CollectionPublicPath, account: account, externalFixedUrl: \"https://goatedgoats.com\")\n    for item in goatedGoatsTraitPack {\n        let itemId=\"GoatedGoatsTraitsPack\".concat(item.id.toString())\n        goats.append(itemId)\n        resultMap[itemId] = item\n    }\n\n    if goats.length != 0 {\n        results[\"GoatedGoats\"] = goats\n    }\n\n    let bitkuCap = account.getCapability\u003c\u0026{HaikuNFT.HaikuCollectionPublic}\u003e(HaikuNFT.HaikuCollectionPublicPath)\n    if bitkuCap.check() {\n        let collection = bitkuCap.borrow()!\n        let items: [String] = []\n        for id in collection.getIDs() {\n            let nft = collection.borrowHaiku(id: id)!\n            let item = MetadataCollectionItem(\n                id: id,\n                name: \"Bitku #\".concat(id.toString()),\n                image: nft.text,\n                url: \"https://bitku.art/#\".concat(address.toString()).concat(\"/\").concat(id.toString()),\n                listPrice: nil,\n                listToken: nil,\n                contentType: \"text\",\n                rarity: \"\"\n            )\n\n            let itemId=\"BitKu\".concat(id.toString())\n            items.append(itemId)\n            resultMap[itemId] = item\n        }\n\n        if items.length != 0 {\n            results[\"Bitku\"] = items\n        }\n    }\n    let klktnCap = account.getCapability\u003c\u0026{KlktnNFT.KlktnNFTCollectionPublic}\u003e(KlktnNFT.CollectionPublicPath)\n    if klktnCap.check() {\n        let items: [String] = []\n        let collection = klktnCap.borrow()!\n        for id in collection.getIDs() {\n            let nft = collection.borrowKlktnNFT(id: id)!\n\n            let metadata=nft.getNFTMetadata()\n            /*\n\n            Result: {\"uri\": \"ipfs://bafybeifsiousmtmcruuelgyiku3xa5hmw7ylsyqfdvpjsea7r4xa74bhym\", \"name\": \"Kevin Woo - What is KLKTN?\", \"mimeType\": \"video/mp4\", \"media\": \"https://ipfs.io/ipfs/bafybeifsiousmtmcruuelgyiku3xa5hmw7ylsyqfdvpjsea7r4xa74bhym/fb91ad34d61dde04f02ad240f0ca924902d8b4a3da25daaf0bb1ed769977848c.mp4\", \"description\": \"K-pop sensation Kevin Woo has partnered up with KLKTN to enhance his artist to fan interactions and experiences within his fandom. Join our chat to learn more: https://discord.gg/UJxb4erfUw\"}\n\n            */\n            let item = MetadataCollectionItem(\n                id: id,\n                name: metadata[\"name\"]!,\n                image: metadata[\"media\"]!,\n                url: \"https://klktn.com/\",\n                listPrice: nil,\n                listToken: nil,\n                contentType: \"video\", //metadata[\"mimeType\"]!,\n                rarity: \"\"\n            )\n            let itemId=\"KLKTN\".concat(id.toString())\n            items.append(itemId)\n            resultMap[itemId] = item\n        }\n\n        if items.length != 0 {\n            results[\"KLKTN\"] = items\n        }\n    }\n\n    let mynftCap = account.getCapability\u003c\u0026{Mynft.MynftCollectionPublic}\u003e(Mynft.CollectionPublicPath)\n    if mynftCap.check() {\n        let items: [String] = []\n        let collection = mynftCap.borrow()!\n        for id in collection.getIDs() {\n            let nft = collection.borrowArt(id: id)!\n            let metadata=nft.metadata\n\n            var image= metadata.ipfsLink\n            if image == \"\" {\n                image=\"https://arweave.net/\".concat(metadata.arLink)\n            }\n\n            let item = MetadataCollectionItem(\n                id: id,\n                name: metadata.name,\n                image: image,\n                url: \"http://mynft.io\",\n                listPrice: nil,\n                listToken: nil,\n                contentType: metadata.type,\n                rarity: \"\"\n            )\n            let itemId=\"mynft\".concat(id.toString())\n            items.append(itemId)\n            resultMap[itemId] = item\n        }\n\n\n        if items.length != 0 {\n            results[\"mynft\"] = items\n        }\n    }\n\n    let neoAvatars = getItemForMetadataStandard(path: NeoAvatar.CollectionPublicPath, account: account, externalFixedUrl: \"\")\n    let neoItems: [String] = []\n    for item in neoAvatars {\n        let itemId=\"NeoAvatar\".concat(item.id.toString())\n        neoItems.append(itemId)\n        resultMap[itemId] = item\n    }\n\n    let neoVouchers = getItemForMetadataStandard(path: NeoVoucher.CollectionPublicPath, account: account, externalFixedUrl: \"https://neocollectibles.xyz/member/\".concat(address.toString()))\n    for item in neoVouchers {\n        let itemId=\"NeoVoucher\".concat(item.id.toString())\n        neoItems.append(itemId)\n        resultMap[itemId] = item\n    }\n\n    let neoMembers = getItemForMetadataStandard(path: NeoMember.CollectionPublicPath, account: account, externalFixedUrl: \"https://neocollectibles.xyz/member/\".concat(address.toString()))\n    for item in neoMembers {\n        let itemId=\"NeoMembers\".concat(item.id.toString())\n        neoItems.append(itemId)\n        resultMap[itemId] = item\n    }\n\n    if neoItems.length != 0 {\n        results[\"Neo\"] = neoItems\n    }\n\n    let byc: [String] = []\n    let barterYardCap= account.getCapability\u003c\u0026{BarterYardPackNFT.BarterYardPackNFTCollectionPublic}\u003e(BarterYardPackNFT.CollectionPublicPath)\n    if barterYardCap.check() {\n        let collection = barterYardCap.borrow()!\n        for id in collection.getIDs() {\n            let nft = collection.borrowBarterYardPackNFT(id: id)!\n\n            if let displayView = nft.resolveView(Type\u003cMetadataViews.Display\u003e()) {\n                let display = displayView as! MetadataViews.Display\n                let item = MetadataCollectionItem(\n                    id: id,\n                    name: display.name,\n                    image: display.thumbnail.uri(),\n                    url: \"https://www.barteryard.club\",\n                    listPrice: nil,\n                    listToken: nil,\n                    contentType: \"image\",\n                    rarity: \"\"\n                )\n\n                let itemId=\"BarterYard\".concat(item.id.toString())\n                byc.append(itemId)\n                resultMap[itemId] = item\n            }\n        }\n    }\n    let werewolves = getItemForMetadataStandard(path: BarterYardClubWerewolf.CollectionPublicPath, account: account, externalFixedUrl: \"https://barteryard.club\")\n    for item in werewolves {\n        let itemId=\"BarterYardWerewolf\".concat(item.id.toString())\n        byc.append(itemId)\n        resultMap[itemId] = item\n    }\n\n    if byc.length != 0 {\n        results[\"Barter Yard Club\"] = byc\n    }\n\n\n    let momentablesCap = account.getCapability\u003c\u0026{Momentables.MomentablesCollectionPublic}\u003e(Momentables.CollectionPublicPath)\n    if momentablesCap.check() {\n        let items: [String] = []\n        let collection = momentablesCap.borrow()!\n\n        for id in collection.getIDs() {\n            let nft = collection.borrowMomentables(id: id)!\n            let traits=nft.getTraits()\n            let commonTrait=traits[\"common\"]!\n\n            let item = MetadataCollectionItem(\n                id: id,\n                name: nft.name,\n                image: \"ipfs://\".concat(nft.imageCID),\n                url: \"https://www.cryptopharaohs.world/\",\n                listPrice: nil,\n                listToken: nil,\n                contentType: \"image\",\n                rarity: commonTrait[\"type\"] ?? \"\",\n            )\n            let itemId=\"CryptoPharaohs\".concat(id.toString())\n            items.append(itemId)\n            resultMap[itemId] = item\n        }\n        if items.length != 0 {\n            results[\"CryptoPharaohs\"] = items\n        }\n    }\n\n\n    /*\n    let beamCap = account.getCapability\u003c\u0026{Beam.BeamCollectionPublic}\u003e(Beam.CollectionPublicPath)\n    if beamCap.check() {\n        let items: [String] = []\n        let collection = beamCap.borrow()!\n        for id in collection.getIDs() {\n            let nft = collection.borrowCollectible(id: id)!\n\n            let metadata = Beam.getCollectibleItemMetaData(collectibleItemID: nft.data.collectibleItemID)!\n            var mediaUrl: String? = metadata[\"mediaUrl\"]\n            if mediaUrl != nil \u0026\u0026  mediaUrl!.slice(from: 0, upTo: 7) != \"ipfs://\" {\n            mediaUrl = \"ipfs://\".concat(mediaUrl!)\n        }\n        let item = MetadataCollectionItem(\n            id: id,\n            name: metadata[\"title\"]!,\n            image: mediaUrl ?? \"\",\n            url: \"https://\".concat(metadata[\"domainUrl\"]!),\n            listPrice: nil,\n            listToken: nil,\n            contentType: metadata[\"mediaType\"]!,\n            rarity: \"\"\n        )\n        let itemId=\"FrightClub\".concat(id.toString())\n        items.append(itemId)\n        resultMap[itemId] = item\n    }\n    if items.length != 0 {\n        results[\"Fright Club\"] = items\n    }\n}*/\n\n\n/*\nlet resolverCollectionCap= account.getCapability\u003c\u0026{StarlyCard.StarlyCardCollectionPublic}\u003e(StarlyCard.CollectionPublicPath)\nif resolverCollectionCap.check() {\n    let items: [String] = []\n    let collection = resolverCollectionCap.borrow()!\n    for id in collection.getIDs() {\n        let nft = collection.borrowViewResolver(id: id)!\n\n        if let displayView = nft.resolveView(Type\u003cMetadataViews.Display\u003e()) {\n            let display = displayView as! MetadataViews.Display\n            if let starlyView = nft.resolveView(Type\u003cStarlyMetadataViews.CardEdition\u003e()) {\n                let cardEdition= starlyView as! StarlyMetadataViews.CardEdition\n\n                let item = MetadataCollectionItem(\n                    id: id,\n                    name: display.name,\n                    image: display.thumbnail.uri(),\n                    url:cardEdition.url,\n                    listPrice: nil,\n                    listToken: nil,\n                    contentType: cardEdition.card.mediaType,\n                    rarity: cardEdition.card.rarity\n                )\n                let itemId=\"Starly\".concat(id.toString())\n                items.append(itemId)\n                resultMap[itemId] = item\n            }\n        }\n    }\n    if items.length != 0 {\n        results[\"Starly\"] = items\n    }\n}\n*/\n\nlet zeedzCap = account.getCapability\u003c\u0026{ZeedzINO.ZeedzCollectionPublic}\u003e(ZeedzINO.CollectionPublicPath)\nif zeedzCap.check() {\n    let items: [String] = []\n    let collection = zeedzCap.borrow()!\n    for id in collection.getIDs() {\n        let nft = collection.borrowZeedle(id: id)!\n\n        let item = MetadataCollectionItem(\n            id: id,\n            name: nft.name,\n            image: \"ipfs://\".concat(nft.imageURI),\n            url: \"http://zeedz.io\",\n            listPrice: nil,\n            listToken: nil,\n            contentType: \"image\",\n            rarity: nft.rarity\n        )\n        let itemId=\"zeedz\".concat(id.toString())\n        items.append(itemId)\n        resultMap[itemId] = item\n    }\n\n\n    if items.length != 0 {\n        results[\"Zeedz\"] = items\n    }\n}\nif results.keys.length == 0 {\n    return nil\n}\n\nlet publicPath=/public/FindCuratedCollections\nlet link = account.getCapability\u003c\u0026{String: [String]}\u003e(publicPath)\nvar curatedCollections : {String: [String]} = {}\nif link.check() {\n    let curated = link.borrow()!\n    for curatedKey in curated.keys {\n        curatedCollections[curatedKey] = curated[curatedKey]!\n    }\n}\n\nreturn MetadataCollections(items: resultMap, collections:results, curatedCollections: curatedCollections)\n}\n\n//This uses a view from Neo until we agree on another for ExternalDomainViewUrl\npub fun getItemForMetadataStandard(path: PublicPath, account:PublicAccount, externalFixedUrl: String) : [MetadataCollectionItem] {\n    let items: [MetadataCollectionItem] = []\n    let resolverCollectionCap= account.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(path)\n    if resolverCollectionCap.check() {\n        let collection = resolverCollectionCap.borrow()!\n        for id in collection.getIDs() {\n            let nft = collection.borrowViewResolver(id: id)!\n\n            if let displayView = nft.resolveView(Type\u003cMetadataViews.Display\u003e()) {\n                let display = displayView as! MetadataViews.Display\n                var externalUrl=externalFixedUrl\n                if let externalUrlView = nft.resolveView(Type\u003cNeoViews.ExternalDomainViewUrl\u003e()) {\n                    let url= externalUrlView! as! NeoViews.ExternalDomainViewUrl\n                    externalUrl=url.url\n                }\n\n                let item = MetadataCollectionItem(\n                    id: id,\n                    name: display.name,\n                    image: display.thumbnail.uri(),\n                    url: externalUrl,\n                    listPrice: nil,\n                    listToken: nil,\n                    contentType: \"image\",\n                    rarity: \"\"\n                )\n\n                items.append(item)\n            }\n        }\n    }\n    return items\n\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "mainnet_getFlobits": {
               "code": "import FlovatarComponent from 0x921ea449dffec68a\nimport FlovatarMarketplace from  0x921ea449dffec68a\n\npub struct MetadataCollectionItem {\n    pub let id:UInt64\n    pub let name: String\n    pub let image: String\n    pub let url: String\n    pub let listPrice: UFix64?\n    pub let listToken: String?\n    pub let contentType:String\n    pub let rarity:String\n\n\n    init(id:UInt64, name:String, image:String, url:String, listPrice: UFix64?, listToken:String?, contentType: String, rarity: String) {\n        self.id=id\n        self.name=name\n        self.url=url\n        self.image=image\n        self.listToken=listToken\n        self.listPrice=listPrice\n        self.contentType=contentType\n        self.rarity=rarity\n    }\n}\n\npub fun main(addr: Address) : [MetadataCollectionItem] {\n\n    let flovatarComponents= FlovatarComponent.getComponents(address: addr)\n\n    let templateNumbers : {UInt64: UInt64} = {}\n    let templateData : {UInt64: FlovatarComponent.ComponentData} = {}\n    for flovatar in flovatarComponents {\n\n        let templateId= flovatar.templateId\n        var number:UInt64=1\n        if templateNumbers[templateId] == nil {\n            templateNumbers[templateId] = (1 as UInt64)\n            templateData[templateId]=flovatar\n        } else {\n            templateNumbers[templateId] = templateNumbers[templateId]! + 1\n        }\n    }\n\n\n    let flovatarMarketComponents=FlovatarMarketplace.getFlovatarComponentSales(address:addr)\n\n    for flovatar in flovatarMarketComponents {\n\n        let templateId= flovatar.metadata.templateId\n            var number:UInt64=1\n            if templateNumbers[templateId] == nil {\n                templateNumbers[templateId] = (1 as UInt64)\n                templateData[templateId]=FlovatarComponent.getComponent(address:addr, componentId: flovatar.id)!\n            } else {\n                templateNumbers[templateId] = templateNumbers[templateId]! + 1\n            }\n    }\n\n\n    let flovatarC : [MetadataCollectionItem] = []\n    for templateId in templateData.keys {\n        let template=templateData[templateId]!\n\n\n        var name=template.name\n\n        if templateId == 75 || templateId==74 || templateId == 73 {\n            name=name.concat(\" Booster\")\n        }\n\n        if templateNumbers[templateId]! \u003e 1 {\n            name=name.concat(\" x \").concat(templateNumbers[templateId]!.toString())\n        } \n\n        let item=MetadataCollectionItem(\n            id: template.id, \n            name: name, \n            image: \"https://flovatar.com/api/image/template/\".concat(templateId.toString()),\n            url: \"https://flovatar.com\",\n            listPrice: nil,\n            listToken: nil,\n            contentType: \"image\",\n            rarity: template.rarity\n        )\n\n        flovatarC.append(item)\n    }\n\n    return flovatarC\n\n}",
               "spec": {
                  "order": [
                     "addr"
                  ],
                  "parameters": {
                     "addr": "Address"
                  }
               }
            },
            "mainnet_getNeoAvatar": {
               "code": "import FIND from 0x39937dba71a38820\n\nimport NeoAvatar from 0xb25138dbf45e5801\nimport NeoViews from 0xb25138dbf45e5801\nimport MetadataViews from 0x1d7e57aa55817448\n\npub struct MetadataCollectionItem {\n    pub let id:UInt64\n    pub let name: String\n    pub let image: String\n    pub let url: String\n    pub let listPrice: UFix64?\n    pub let listToken: String?\n    pub let contentType:String\n    pub let rarity:String\n\n\n    init(id:UInt64, name:String, image:String, url:String, listPrice: UFix64?, listToken:String?, contentType: String, rarity: String) {\n        self.id=id\n        self.name=name\n        self.url=url\n        self.image=image\n        self.listToken=listToken\n        self.listPrice=listPrice\n        self.contentType=contentType\n        self.rarity=rarity\n    }\n}\n\npub fun main(user: String) : [MetadataCollectionItem] {\n\n    let resolveAddress = FIND.resolve(user) \n    if resolveAddress == nil {return []}\n    let address = resolveAddress!\n    let account=getAccount(address)\n\n    return getItemForMetadataStandard(path: NeoAvatar.CollectionPublicPath, account:account)\n    /*\n    let items: [MetadataCollectionItem] = []\n    let account=getAccount(address)\n    let neoAvatarCap = account.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(NeoAvatar.CollectionPublicPath)\n    if neoAvatarCap.check() {\n        let collection = neoAvatarCap.borrow()!\n        for id in collection.getIDs() {\n            let nft = collection.borrowViewResolver(id: id)!\n\n            if let displayView = nft.resolveView(Type\u003cMetadataViews.Display\u003e()) {\n                let display = displayView as! MetadataViews.Display\n                if let externalUrlView = nft.resolveView(Type\u003cNeoViews.ExternalDomainViewUrl\u003e()) {\n                    let externalUrl= externalUrlView! as! NeoViews.ExternalDomainViewUrl\n                    let item = MetadataCollectionItem(\n                        id: id,\n                        name: display.name,\n                        image: display.thumbnail.uri(),\n                        url: externalUrl.url,\n                        listPrice: nil,\n                        listToken: nil,\n                        contentType: \"image\",\n                        rarity: \"\"\n                    )\n\n                    items.append(item)\n                }\n            }\n        }\n    }\n    return items\n    */\n\n}\n\npub fun getItemForMetadataStandard(path: PublicPath, account:PublicAccount) : [MetadataCollectionItem] {\n    let items: [MetadataCollectionItem] = []\n    let resolverCollectionCap= account.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(path)\n    if resolverCollectionCap.check() {\n        let collection = resolverCollectionCap.borrow()!\n        for id in collection.getIDs() {\n            let nft = collection.borrowViewResolver(id: id)!\n\n            if let displayView = nft.resolveView(Type\u003cMetadataViews.Display\u003e()) {\n                let display = displayView as! MetadataViews.Display\n                if let externalUrlView = nft.resolveView(Type\u003cNeoViews.ExternalDomainViewUrl\u003e()) {\n                    let externalUrl= externalUrlView! as! NeoViews.ExternalDomainViewUrl\n                    let item = MetadataCollectionItem(\n                        id: id,\n                        name: display.name,\n                        image: display.thumbnail.uri(),\n                        url: externalUrl.url,\n                        listPrice: nil,\n                        listToken: nil,\n                        contentType: \"image\",\n                        rarity: \"\"\n                    )\n\n                    items.append(item)\n                }\n            }\n        }\n    }\n    return items\n\n\n\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "mainnet_getRareroom": {
               "code": "import NonFungibleToken from 0x631e88ae7f1d7c20\nimport CharityNFT from 0x39937dba71a38820\nimport FIND from 0x39937dba71a38820\nimport RareRooms_NFT from 0x329feb3ab062d289\n\n\npub fun main(user: String) : {String:String} {\n\n    let resolveAddress = FIND.resolve(user) \n    if resolveAddress == nil {return {}}\n    let address = resolveAddress!\n    let account=getAccount(address)\n    let rareRoomCap = account.getCapability\u003c\u0026RareRooms_NFT.Collection{RareRooms_NFT.RareRooms_NFTCollectionPublic}\u003e(RareRooms_NFT.CollectionPublicPath)\n\n    if rareRoomCap.check() {\n        let collection = rareRoomCap.borrow()!\n        let items: [String] = []\n        for id in collection.getIDs() {\n            let nft = collection.borrowRareRooms_NFT(id: id)!\n            let metadata = RareRooms_NFT.getSetMetadata(setId: nft.setId)!\n            return metadata\n        }\n    }\n    return {}\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "mainnet_getStarly": {
               "code": "import FIND from 0x39937dba71a38820\n\nimport StarlyCard from 0x5b82f21c0edf76e3\nimport StarlyMetadataViews from 0x5b82f21c0edf76e3\nimport MetadataViews from 0x1d7e57aa55817448\n\npub struct MetadataCollectionItem {\n    pub let id:UInt64\n    pub let name: String\n    pub let image: String\n    pub let url: String\n    pub let listPrice: UFix64?\n    pub let listToken: String?\n    pub let contentType:String\n    pub let rarity:String\n\n\n    init(id:UInt64, name:String, image:String, url:String, listPrice: UFix64?, listToken:String?, contentType: String, rarity: String) {\n        self.id=id\n        self.name=name\n        self.url=url\n        self.image=image\n        self.listToken=listToken\n        self.listPrice=listPrice\n        self.contentType=contentType\n        self.rarity=rarity\n    }\n}\n\npub fun main(user: String) : [MetadataCollectionItem] {\n\n    let resolveAddress = FIND.resolve(user) \n    if resolveAddress == nil {return []}\n    let address = resolveAddress!\n    let account=getAccount(address)\n    let items: [MetadataCollectionItem] = []\n    let resolverCollectionCap= account.getCapability\u003c\u0026{StarlyCard.StarlyCardCollectionPublic}\u003e(StarlyCard.CollectionPublicPath)\n    if resolverCollectionCap.check() {\n        let collection = resolverCollectionCap.borrow()!\n        for id in collection.getIDs() {\n            let nft = collection.borrowViewResolver(id: id)!\n\n            if let displayView = nft.resolveView(Type\u003cMetadataViews.Display\u003e()) {\n                let display = displayView as! MetadataViews.Display\n                if let starlyView = nft.resolveView(Type\u003cStarlyMetadataViews.CardEdition\u003e()) {\n                     let cardEdition= starlyView as! StarlyMetadataViews.CardEdition\n\n                    let item = MetadataCollectionItem(\n                        id: id,\n                        name: display.name,\n                        image: display.thumbnail.uri(),\n                        url:cardEdition.url,\n                        listPrice: nil,\n                        listToken: nil,\n                        contentType: \"image\",\n                        rarity: cardEdition.card.rarity\n                    )\n\n                    items.append(item)\n                }\n            }\n        }\n    }\n    return items\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "mainnet_getStoreFrontListings": {
               "code": "import FIND from 0x39937dba71a38820\n\nimport NFTStorefront from 0x4eb8a10cb9f87357\nimport Marketplace from 0xd796ff17107bbff6\nimport Art from 0xd796ff17107bbff6\nimport FlowToken from 0x7e60df042a9c0868\nimport Flovatar from 0x921ea449dffec68a\nimport FlovatarMarketplace from  0x921ea449dffec68a\n\n// This script returns the details for a listing within a storefront\n\npub struct Listing {\n    pub let marketplace : String\n    pub let ftVault: Type\n    pub let price:UFix64\n    pub let nftType: Type\n    pub let nftId: UInt64\n\n    init(marketplace:String, ftVault:Type, price:UFix64, nftType:Type, nftId:UInt64) {\n        self.marketplace=marketplace\n        self.ftVault=ftVault\n        self.price=price\n        self.nftType=nftType\n        self.nftId=nftId\n    }\n}\n\npub fun main(user: String): {UInt64 :[Listing]} {\n\n    let resolveAddress = FIND.resolve(user) \n    if resolveAddress == nil {return {}}\n    let address = resolveAddress!\n    let account=getAccount(address)\n    let storefrontRef = account.getCapability\u003c\u0026NFTStorefront.Storefront{NFTStorefront.StorefrontPublic}\u003e(NFTStorefront.StorefrontPublicPath).borrow()!\n\n    let listings : {UInt64 : [Listing]} = {}\n\n    for id in storefrontRef.getListingIDs() {\n        let listing = storefrontRef.borrowListing(listingResourceID: id)!\n        let details=listing.getDetails()\n        if details.purchased==true {\n            continue\n        }\n        let uuid=listing.borrowNFT()!.uuid\n\n        let item = Listing( \n            marketplace:\"nftstorefront-\".concat(details.storefrontID.toString()),\n            ftVault: details.salePaymentVaultType, \n            price: details.salePrice,\n            nftType:details.nftType,\n            nftId: details.nftID,\n        )\n        let uuidListings= listings[uuid] ?? []\n        uuidListings.append(item)\n        listings[uuid]= uuidListings\n    }\n\n\n    let versusMarketplace = account.getCapability\u003c\u0026{Marketplace.SalePublic}\u003e(Marketplace.CollectionPublicPath)\n    if versusMarketplace.check() {\n\n        let versusMarket = versusMarketplace.borrow()!\n\n        let saleItems = versusMarket.listSaleItems()\n        for saleItem in saleItems {\n\n            let item = Listing( \n                marketplace:\"versus\",\n                ftVault: Type\u003c@FlowToken.Vault\u003e(),\n                price: saleItem.price,\n                nftType:Type\u003c@Art.NFT\u003e(),\n                nftId: saleItem.id\n            )\n\n            let uuid = versusMarket.getUUIDforSaleItem(tokenID: saleItem.id)\n            //let uuid = art.borrowNFT(id:saleItem.id)!.uuid\n            let uuidListings= listings[uuid] ?? []\n            uuidListings.append(item)\n            listings[uuid]= uuidListings\n\n        }\n    }\n\n\n\n    let flovatarCap = account.getCapability\u003c\u0026{FlovatarMarketplace.SalePublic}\u003e(FlovatarMarketplace.CollectionPublicPath)  \n    if flovatarCap.check(){\n        let saleCollection=flovatarCap.borrow()!\n        for id in saleCollection.getFlovatarIDs() {\n            let price = saleCollection.getFlovatarPrice(tokenId: id)!\n            let flovatar = saleCollection.getFlovatar(tokenId: id)!\n\n            let item = Listing( \n                marketplace:\"flovatar\",\n                ftVault: Type\u003c@FlowToken.Vault\u003e(),\n                price: price,\n                nftType:Type\u003c@Flovatar.NFT\u003e(),\n                nftId: id\n            )\n\n            let uuid =  flovatar.uuid\n            //let uuid = art.borrowNFT(id:saleItem.id)!.uuid\n            let uuidListings= listings[uuid] ?? []\n            uuidListings.append(item)\n            listings[uuid]= uuidListings\n        }\n    }\n    return listings\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "resolve": {
               "code": "import FIND from 0x39937dba71a38820\n\npub fun main(input:String) : Address?{\n    return FIND.resolve(input)\n}",
               "spec": {
                  "order": [
                     "input"
                  ],
                  "parameters": {
                     "input": "String"
                  }
               }
            },
            "resolvePartialCollection": {
               "code": "import MetadataViews from 0x631e88ae7f1d7c20\nimport NFTRegistry from 0x39937dba71a38820\nimport FindViews from 0x39937dba71a38820\nimport FIND from 0x39937dba71a38820\n\npub struct ViewCollectionPointer {\n    access(self) let cap: Capability\u003c\u0026{MetadataViews.ResolverCollection}\u003e\n    pub let nftInfo: NFTRegistry.NFTInfo\n\n    init(cap: Capability\u003c\u0026{MetadataViews.ResolverCollection}\u003e, aliasOrIdentifier: String) {\n        self.cap=cap\n        self.nftInfo=NFTRegistry.getNFTInfo(aliasOrIdentifier)!\n    }\n\n    pub fun resolveView(_ type: Type, id: UInt64) : AnyStruct? {\n        return self.getViewResolver(id).resolveView(type)\n    }\n\n    pub fun getUUID(_ id: UInt64) :UInt64{\n        return self.getViewResolver(id).uuid\n    }\n\n    pub fun getViews(_ id: UInt64) : [Type]{\n        return self.getViewResolver(id).getViews()\n    }\n\n    pub fun owner() : Address {\n        return self.cap.address\n    }\n\n    pub fun valid(_ id: UInt64) : Bool {\n        if !self.cap.borrow()!.getIDs().contains(id) {\n            return false\n        }\n        return true\n    }\n\n    pub fun getItemType(_ id: UInt64) : Type {\n        return self.getViewResolver(id).getType()\n    }\n\n    pub fun getViewResolver(_ id: UInt64) : \u0026AnyResource{MetadataViews.Resolver} {\n        return self.cap.borrow()!.borrowViewResolver(id: id)\n    }\n\n    pub fun resolveDisplayViews(_ id: UInt64) : MetadataViews.Display {\n        return self.resolveView(Type\u003cMetadataViews.Display\u003e(), id: id)! as! MetadataViews.Display\n    }\n\n    pub fun getName(_ id: UInt64) : String {\n        return self.resolveDisplayViews(id).name\n    }\n\n    pub fun getImage(_ id: UInt64) : String {\n        return self.resolveDisplayViews(id).thumbnail.uri()\n    }\n\n    pub fun getRarityView(_ id: UInt64) : FindViews.Rarity? {\n        return self.resolveView(Type\u003cFindViews.Rarity\u003e(), id:id) as? FindViews.Rarity\n    }\n\n    pub fun getRarity(_ id: UInt64) : String {\n        if let rarity = self.getRarityView(id) {\n            return rarity.rarityName\n        }\n        return \"\"\n    }\n\n    pub fun getExternalUrlView(_ id: UInt64) : MetadataViews.ExternalURL? {\n        return  self.resolveView(Type\u003cMetadataViews.ExternalURL\u003e(), id:id) as? MetadataViews.ExternalURL\n    }\n\n    pub fun getExternalUrl(_ id: UInt64) : String {\n        if let url = self.getExternalUrlView(id) {\n            return url.url\n        }\n        return self.nftInfo.externalFixedUrl\n    }\n\n}\n\npub fun createViewReadPointer(address:Address, aliasOrIdentifier:String) : ViewCollectionPointer {\n    let path= NFTRegistry.getNFTInfo(aliasOrIdentifier)!.publicPath\n    let cap= getAccount(address).getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(path)\n    let pointer= ViewCollectionPointer(cap: cap, aliasOrIdentifier: aliasOrIdentifier)\n    return pointer\n}\n\npub struct MetadataCollectionItem {\n    pub let id:UInt64\n    pub let typeIdentifier: String\n    pub let uuid: UInt64 \n    pub let name: String\n    pub let image: String\n    pub let url: String\n    pub let contentType:String\n    pub let rarity:String\n    //Refine later \n    pub let metadata: {String : String}\n    pub let collection: String \n\n    init(id:UInt64, type: Type, uuid: UInt64, name:String, image:String, url:String, contentType: String, rarity: String, collection: String) {\n        self.id=id\n        self.typeIdentifier = type.identifier\n        self.uuid = uuid\n        self.name=name\n        self.url=url\n        self.image=image\n        self.contentType=contentType\n        self.rarity=rarity\n        self.metadata={}\n        self.collection=collection\n    }\n}\n\npub fun main(user: String, aliasOrIdentifier: [String], ids:[UInt64]) : [MetadataCollectionItem] {\n\n    let resolveAddress = FIND.resolve(user) \n    if resolveAddress == nil {return []}\n    let address = resolveAddress!\n    var pointerMap: {String : ViewCollectionPointer} = {}\n\n    var resultMap : [MetadataCollectionItem] = []\n\n    assert(aliasOrIdentifier.length == ids.length, message: \"The length of alias passed in does not match with that of the IDs.\")\n    var i = 0\n    while i \u003c aliasOrIdentifier.length {\n        let alias = aliasOrIdentifier[i]\n        let id = ids[i]\n        if pointerMap[alias] == nil {\n            pointerMap[alias] = createViewReadPointer(address: address, aliasOrIdentifier: alias)\n        }\n        let pointer = pointerMap[alias]!\n        resultMap.append(MetadataCollectionItem(id: id, \n                                                type: pointer.getItemType(id), \n                                                uuid: pointer.getUUID(id), \n                                                name: pointer.getName(id), \n                                                image: pointer.getImage(id), \n                                                url: pointer.getExternalUrl(id), \n                                                contentType: \"image\", \n                                                rarity: pointer.getRarity(id), \n                                                collection: alias)\n        )\n        i = i + 1\n    }\n    return resultMap\n}",
               "spec": {
                  "order": [
                     "user",
                     "aliasOrIdentifier",
                     "ids"
                  ],
                  "parameters": {
                     "aliasOrIdentifier": "[String]",
                     "ids": "[UInt64]",
                     "user": "String"
                  }
               }
            }
         },
         "transactions": {
            "acceptDirectOfferSoft": {
               "code": "import FindMarketDirectOfferSoft from 0x39937dba71a38820\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FindViews from 0x39937dba71a38820\nimport NFTRegistry from 0x39937dba71a38820\nimport FindMarket from 0x39937dba71a38820\n\ntransaction(marketplace:Address, id: UInt64) {\n\n\n    prepare(account: AuthAccount) {\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e())\n        let market = account.borrow\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection\u003e(from: storagePath)!\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e())\n        let item = FindMarket.assertOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: id)\n        let nftIdentifier = item.getItemType().identifier\n\n        //If this is nil, there must be something wrong with FIND setup\n        let nft = NFTRegistry.getNFTInfoByTypeIdentifier(nftIdentifier)!\n\n        let providerCap=account.getCapability\u003c\u0026{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e(nft.providerPath)\n        let pointer= FindViews.AuthNFTPointer(cap: providerCap, id: id)\n\n        market.acceptOffer(pointer)\n\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "addCuratedCollection": {
               "code": "transaction(name: String, items: [String]) {\n    prepare(account: AuthAccount) {\n\n        let path=/storage/FindCuratedCollections\n        let publicPath=/public/FindCuratedCollections\n\n        var collections : {String: [String]} = {}\n        if account.borrow\u003c\u0026{String: [String]}\u003e(from:path) != nil {\n             collections=account.load\u003c{String: [String]}\u003e(from:path)!\n        }\n        collections[name] = items\n        account.save(collections, to: path)\n        let link = account.getCapability\u003c\u0026{String: [String]}\u003e(publicPath)\n        if !link.check() {\n            account.link\u003c\u0026{String: [String]}\u003e( publicPath, target: path)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "items"
                  ],
                  "parameters": {
                     "items": "[String]",
                     "name": "String"
                  }
               }
            },
            "adminAddBl0xTestnet": {
               "code": "import Admin from 0x39937dba71a38820\nimport Bl0x from 0xe8124d8428980aa6\nimport FindMarket from 0x39937dba71a38820\nimport FlowToken from 0x7e60df042a9c0868\n\ntransaction(tenant: Address) {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n        \n    }\n    execute{\n\n        self.adminRef.setNFTInfo(\n            alias: \"Bl0x\", \n            type: Type\u003c@Bl0x.NFT\u003e(), \n            icon: \"https://global-uploads.webflow.com/60f008ba9757da0940af288e/626e4af22f80f09e2783df44_blox.jpg\", \n            providerPath: Bl0x.CollectionPrivatePath, \n            publicPath: Bl0x.CollectionPublicPath, \n            storagePath: Bl0x.CollectionStoragePath, \n            allowedFTTypes: nil, \n            address:0xe8124d8428980aa6, externalFixedUrl: \"bl0x-5ccsb92pb-findonflow.vercel.app\")\n\n        let rules = [\n            FindMarket.TenantRule(name:\"Flow\", types:[Type\u003c@FlowToken.Vault\u003e()], ruleType: \"ft\", allow: true),\n            FindMarket.TenantRule(name:\"Neo\", types:[Type\u003c@Bl0x.NFT\u003e()], ruleType: \"nft\", allow: true)\n        ]\n\n        let tenantSaleItem = FindMarket.TenantSaleItem(\n            name: \"FlowBl0x\", \n            cut: nil, \n            rules: rules, \n            status:\"active\"\n        )\n\n        self.adminRef.setMarketOption(tenant: tenant, saleItem: tenantSaleItem)\n        \n    }\n}",
               "spec": {
                  "order": [
                     "tenant"
                  ],
                  "parameters": {
                     "tenant": "Address"
                  }
               }
            },
            "adminMintCharity": {
               "code": "import NonFungibleToken from 0x631e88ae7f1d7c20\nimport CharityNFT from 0x39937dba71a38820\nimport Admin from 0x39937dba71a38820\n\n//mint an art and add it to a users collection\ntransaction(\n    name: String,\n    image: String,\n    thumbnail: String,\n    originUrl: String,\n    description: String,\n    recipient: Address\n) {\n    let receiverCap: Capability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e\n    let client: \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount) {\n        self.client= account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath)!\n        self.receiverCap= getAccount(recipient).getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath)\n    }\n\n    execute {\n        let metadata = {\"name\" : name, \"image\" : image, \"thumbnail\": thumbnail, \"originUrl\": originUrl, \"description\":description}\n        self.client.mintCharity(metadata: metadata, recipient: self.receiverCap)\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "image",
                     "thumbnail",
                     "originUrl",
                     "description",
                     "recipient"
                  ],
                  "parameters": {
                     "description": "String",
                     "image": "String",
                     "name": "String",
                     "originUrl": "String",
                     "recipient": "Address",
                     "thumbnail": "String"
                  }
               }
            },
            "adminRegisterName": {
               "code": "import FIND from 0x39937dba71a38820\nimport Admin from 0x39937dba71a38820\nimport Profile from 0x39937dba71a38820\n\ntransaction(names: [String], user: Address) {\n\n    prepare(account: AuthAccount) {\n\n        let userAccount=getAccount(user)\n        let profileCap = userAccount.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        let leaseCollectionCap=userAccount.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        let adminClient=account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath)!\n\n        for name in names {\n            adminClient.register(name: name,  profile: profileCap, leases: leaseCollectionCap)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "names",
                     "user"
                  ],
                  "parameters": {
                     "names": "[String]",
                     "user": "Address"
                  }
               }
            },
            "adminRemoveFTInfoByAlias": {
               "code": "import Admin from 0x39937dba71a38820\n\ntransaction(alias: String) {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n        \n    }\n\n    execute{\n\n        self.adminRef.removeFTInfoByAlias(alias)\n\n    }\n}",
               "spec": {
                  "order": [
                     "alias"
                  ],
                  "parameters": {
                     "alias": "String"
                  }
               }
            },
            "adminRemoveFTInfoByTypeIdentifier": {
               "code": "import Admin from 0x39937dba71a38820\n\ntransaction(typeIdentifier: String) {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n        \n    }\n\n    execute{\n\n        self.adminRef.removeFTInfoByTypeIdentifier(typeIdentifier) \n       \n    }\n}",
               "spec": {
                  "order": [
                     "typeIdentifier"
                  ],
                  "parameters": {
                     "typeIdentifier": "String"
                  }
               }
            },
            "adminRemoveNFTInfoByAlias": {
               "code": "import Admin from 0x39937dba71a38820\n\ntransaction(alias: String) {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n        \n    }\n\n    execute{\n\n        self.adminRef.removeNFTInfoByAlias(alias)\n        \n    }\n}",
               "spec": {
                  "order": [
                     "alias"
                  ],
                  "parameters": {
                     "alias": "String"
                  }
               }
            },
            "adminRemoveNFTInfoByTypeIdentifier": {
               "code": "import Admin from 0x39937dba71a38820\n\ntransaction(typeIdentifier: String) {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n        \n    }\n\n    execute{\n\n        self.adminRef.removeNFTInfoByTypeIdentifier(typeIdentifier) \n       \n    }\n}",
               "spec": {
                  "order": [
                     "typeIdentifier"
                  ],
                  "parameters": {
                     "typeIdentifier": "String"
                  }
               }
            },
            "adminSendFUSD": {
               "code": "import FungibleToken from 0x9a0766d93b6608b7\nimport FUSD from 0xe223d8a629e49c68\n\ntransaction(receiver: Address, amount:UFix64) {\n    prepare(acct: AuthAccount) {\n        let receiver = getAccount(receiver).getCapability\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e(/public/fusdReceiver).borrow() ?? panic(\"Cannot borrow FUSD receiver\")\n\n        let sender = acct.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault)\n            ?? panic(\"Cannot borrow FUSD vault from authAcct storage\")\n\n        receiver.deposit(from: \u003c- sender.withdraw(amount:amount))\n    }\n}",
               "spec": {
                  "order": [
                     "receiver",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "receiver": "Address"
                  }
               }
            },
            "adminSetFTInfo_flow": {
               "code": "import Admin from 0x39937dba71a38820\nimport FlowToken from 0x7e60df042a9c0868\n\ntransaction() {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n    }\n\n    execute{\n        let type: Type = Type\u003c@FlowToken.Vault\u003e()\n        self.adminRef.setFTInfo(alias: \"Flow\", type: type, tag:[\"utility coin\"] , icon: \"https://static.flowscan.org/mainnet/icons/A.1654653399040a61.FlowToken.png\", receiverPath: /public/flowTokenReceiver, balancePath: /public/flowTokenBalance, vaultPath: /storage/flowTokenVault)\n    }\n}",
               "spec": null
            },
            "adminSetFTInfo_fusd": {
               "code": "import Admin from 0x39937dba71a38820\nimport FUSD from 0xe223d8a629e49c68\n\ntransaction() {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n    }\n\n    execute{\n        let type: Type = Type\u003c@FUSD.Vault\u003e()\n        self.adminRef.setFTInfo(alias: \"FUSD\", type: type, tag:[\"stablecoin\"], icon: \"https://static.flowscan.org/mainnet/icons/A.3c5959b568896393.FUSD.png\", receiverPath: /public/fusdReceiver, balancePath: /public/fusdBalance, vaultPath: /storage/fusdVault)\n    }\n}",
               "spec": null
            },
            "adminSetFTInfo_usdc": {
               "code": "import Admin from 0x39937dba71a38820\nimport FiatToken from 0xa983fecbed621163\n\ntransaction() {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n    }\n\n    execute{\n        let type: Type = Type\u003c@FiatToken.Vault\u003e()\n        self.adminRef.setFTInfo(alias: \"USDC\", type: type, tag:[\"stablecoin\"] , icon: \"https://static.flowscan.org/mainnet/icons/A.b19436aae4d94622.FiatToken.png\", receiverPath: FiatToken.VaultReceiverPubPath, balancePath: FiatToken.VaultBalancePubPath, vaultPath: FiatToken.VaultStoragePath)\n    }\n}",
               "spec": null
            },
            "adminSetFindCut": {
               "code": "import Admin from 0x39937dba71a38820\n\ntransaction(tenant: Address, cut: UFix64){\n    prepare(account: AuthAccount){\n        let adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n\n        adminRef.setFindCut(tenant: tenant, cut: cut, rules: nil, status: \"active\")\n    }\n}",
               "spec": {
                  "order": [
                     "tenant",
                     "cut"
                  ],
                  "parameters": {
                     "cut": "UFix64",
                     "tenant": "Address"
                  }
               }
            },
            "adminSetNFTInfo_Dandy": {
               "code": "import Admin from 0x39937dba71a38820\nimport Dandy from 0x39937dba71a38820\n\ntransaction() {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n        \n    }\n    execute{\n        let type: Type = Type\u003c@Dandy.NFT\u003e()\n        self.adminRef.setNFTInfo(alias: \"Dandy\", type: type, icon: nil, providerPath: Dandy.CollectionPrivatePath, publicPath: Dandy.CollectionPublicPath, storagePath: Dandy.CollectionStoragePath, allowedFTTypes: nil, address: 0xf8d6e0586b0a20c7, externalFixedUrl: \"find.xyz\")\n\n    }\n}",
               "spec": null
            },
            "adminSetNFTInfo_Neo": {
               "code": "import Admin from 0x39937dba71a38820\nimport NeoVoucher from 0xd6b39e5b5b367aad\n\ntransaction() {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n        \n    }\n    execute{\n\n        self.adminRef.setNFTInfo(alias: \"NeoVoucher\", type: Type\u003c@NeoVoucher.NFT\u003e(), icon: \"https://test.neocollectibles.xyz/pages/images/neo-collectibles-logo.webp\", providerPath: /private/neoVoucherCollection, publicPath: NeoVoucher.CollectionPublicPath, storagePath: NeoVoucher.CollectionStoragePath, allowedFTTypes: nil, address: 0xd6b39e5b5b367aad, externalFixedUrl: \"test.neocollectibles.xyx\")\n\n    }\n}",
               "spec": null
            },
            "adminSetSellDandyForFUSD": {
               "code": "import FindMarket from 0x39937dba71a38820\nimport Admin from 0x39937dba71a38820\nimport FUSD from 0xe223d8a629e49c68\nimport Dandy from 0x39937dba71a38820\nimport FindMarketSale from 0x39937dba71a38820\nimport FindMarketAuctionEscrow from 0x39937dba71a38820\nimport FindMarketAuctionSoft from 0x39937dba71a38820\nimport FindMarketDirectOfferEscrow from 0x39937dba71a38820\nimport FindMarketDirectOfferSoft from 0x39937dba71a38820\n\n\ntransaction(tenant: Address, market: String){\n    prepare(account: AuthAccount){\n        let adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n\n        var marketType : [Type] = [Type\u003c@FindMarketSale.SaleItem\u003e()]\n        switch market {\n            case \"AuctionEscrow\" :\n                marketType = [Type\u003c@FindMarketAuctionEscrow.SaleItem\u003e()]\n\n            case \"AuctionSoft\" :\n                marketType = [Type\u003c@FindMarketAuctionSoft.SaleItem\u003e()]\n\n            case \"DirectOfferEscrow\" :\n                marketType = [Type\u003c@FindMarketDirectOfferEscrow.SaleItem\u003e()]\n\n            case \"DirectOfferSoft\" :\n                marketType = [Type\u003c@FindMarketDirectOfferSoft.SaleItem\u003e()]\n\n        }\n\n        let saleItem = FindMarket.TenantSaleItem(name:\"FlowDandy\".concat(market), cut: nil, rules:[\n            FindMarket.TenantRule(name:\"Flow\", types:[Type\u003c@FUSD.Vault\u003e()], ruleType: \"ft\", allow: true),\n            FindMarket.TenantRule(name:\"Dandy\", types:[Type\u003c@Dandy.NFT\u003e()], ruleType: \"nft\", allow: true),\n            FindMarket.TenantRule(name: market, types:marketType, ruleType: \"listing\", allow: true)\n            ], \n            status: \"active\"\n        )\n\n        adminRef.setMarketOption(tenant: tenant, saleItem: saleItem)\n    }\n}",
               "spec": {
                  "order": [
                     "tenant",
                     "market"
                  ],
                  "parameters": {
                     "market": "String",
                     "tenant": "Address"
                  }
               }
            },
            "adminSetSellDandyForFlow": {
               "code": "import FindMarket from 0x39937dba71a38820\nimport Admin from 0x39937dba71a38820\nimport FlowToken from 0x7e60df042a9c0868\nimport Dandy from 0x39937dba71a38820\nimport FindMarketSale from 0x39937dba71a38820\nimport FindMarketAuctionEscrow from 0x39937dba71a38820\nimport FindMarketAuctionSoft from 0x39937dba71a38820\nimport FindMarketDirectOfferEscrow from 0x39937dba71a38820\nimport FindMarketDirectOfferSoft from 0x39937dba71a38820\n\n\ntransaction(tenant: Address, market: String){\n    prepare(account: AuthAccount){\n        let adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n\n        var marketType : [Type] = [Type\u003c@FindMarketSale.SaleItem\u003e()]\n        switch market {\n            case \"AuctionEscrow\" :\n                marketType = [Type\u003c@FindMarketAuctionEscrow.SaleItem\u003e()]\n\n            case \"AuctionSoft\" :\n                marketType = [Type\u003c@FindMarketAuctionSoft.SaleItem\u003e()]\n\n            case \"DirectOfferEscrow\" :\n                marketType = [Type\u003c@FindMarketDirectOfferEscrow.SaleItem\u003e()]\n\n            case \"DirectOfferSoft\" :\n                marketType = [Type\u003c@FindMarketDirectOfferSoft.SaleItem\u003e()]\n\n        }\n\n        let saleItem = FindMarket.TenantSaleItem(name:\"FlowDandy\".concat(market), cut: nil, rules:[\n            FindMarket.TenantRule(name:\"Flow\", types:[Type\u003c@FlowToken.Vault\u003e()], ruleType: \"ft\", allow: true),\n            FindMarket.TenantRule(name:\"Dandy\", types:[Type\u003c@Dandy.NFT\u003e()], ruleType: \"nft\", allow: true),\n            FindMarket.TenantRule(name: market, types:marketType, ruleType: \"listing\", allow: true)\n            ], \n            status: \"active\"\n        )\n\n        adminRef.setMarketOption(tenant: tenant, saleItem: saleItem)\n    }\n}",
               "spec": {
                  "order": [
                     "tenant",
                     "market"
                  ],
                  "parameters": {
                     "market": "String",
                     "tenant": "Address"
                  }
               }
            },
            "adminSetSellDandyRules": {
               "code": "import FindMarket from 0x39937dba71a38820\nimport Admin from 0x39937dba71a38820\nimport FlowToken from 0x7e60df042a9c0868\nimport FUSD from 0xe223d8a629e49c68\nimport Dandy from 0x39937dba71a38820\n\ntransaction(tenant: Address) {\n    prepare(account: AuthAccount){\n        let adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n\n        let fusdDandy = FindMarket.TenantSaleItem(name:\"FUSDDandy\", cut: nil, rules:[\n            FindMarket.TenantRule(name:\"FUSD\", types:[Type\u003c@FUSD.Vault\u003e()], ruleType: \"ft\", allow: true),\n            FindMarket.TenantRule(name:\"Dandy\", types:[ Type\u003c@Dandy.NFT\u003e()], ruleType: \"nft\", allow: true)\n            ], \n            status: \"active\"\n        )\n\n        let flowDandy = FindMarket.TenantSaleItem(name:\"FlowDandy\", cut: nil, rules:[\n            FindMarket.TenantRule(name:\"Flow\", types:[Type\u003c@FlowToken.Vault\u003e()], ruleType: \"ft\", allow: true),\n            FindMarket.TenantRule(name:\"Dandy\", types:[ Type\u003c@Dandy.NFT\u003e()], ruleType: \"nft\", allow: true)\n            ], \n            status: \"active\"\n        )\n\n        adminRef.setMarketOption(tenant: tenant, saleItem: fusdDandy)\n        adminRef.setMarketOption(tenant: tenant, saleItem: flowDandy)\n\n    }\n}",
               "spec": {
                  "order": [
                     "tenant"
                  ],
                  "parameters": {
                     "tenant": "Address"
                  }
               }
            },
            "adminTransferAllFusd": {
               "code": "// Mainnet\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FUSD from 0xe223d8a629e49c68\n\n// Testnet\n// import FungibleToken from 0x9a0766d93b6608b7\n// import FUSD from 0xe223d8a629e49c68\n\ntransaction(recipient: Address) {\n\n  // The Vault resource that holds the tokens that are being transfered\n  let sentVault: @FungibleToken.Vault\n\n  prepare(signer: AuthAccount) {\n    // Get a reference to the signer's stored vault\n    let vaultRef = signer.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault)\n      ?? panic(\"Could not borrow reference to the owner's Vault!\")\n\n    // Withdraw tokens from the signer's stored vault\n    self.sentVault \u003c- vaultRef.withdraw(amount: vaultRef.balance)\n  }\n\n  execute {\n    // Get the recipient's public account object\n    let recipientAccount = getAccount(recipient)\n\n    // Get a reference to the recipient's Receiver\n    let receiverRef = recipientAccount.getCapability(/public/fusdReceiver)!\n      .borrow\u003c\u0026{FungibleToken.Receiver}\u003e()\n      ?? panic(\"Could not borrow receiver reference to the recipient's Vault\")\n\n    // Deposit the withdrawn tokens in the recipient's receiver\n    receiverRef.deposit(from: \u003c-self.sentVault)\n  }\n}",
               "spec": {
                  "order": [
                     "recipient"
                  ],
                  "parameters": {
                     "recipient": "Address"
                  }
               }
            },
            "alterMarketOption": {
               "code": "import FindMarket from 0x39937dba71a38820\n\ntransaction(marketRule: String , action: String ){\n    prepare(account: AuthAccount){\n        let path = FindMarket.TenantClientStoragePath\n        let tenantRef = account.borrow\u003c\u0026FindMarket.TenantClient\u003e(from: path) ?? panic(\"Cannot borrow Reference.\")\n\n\n        switch action {\n            case \"enable\" :\n                tenantRef.enableMarketOption(marketRule)\n\n            case \"deprecate\" :\n                tenantRef.deprecateMarketOption(marketRule)\n\n            case \"stop\" :\n                tenantRef.stopMarketOption(marketRule)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "marketRule",
                     "action"
                  ],
                  "parameters": {
                     "action": "String",
                     "marketRule": "String"
                  }
               }
            },
            "bidMarketAuctionEscrowed": {
               "code": "import FindMarketAuctionEscrow from 0x39937dba71a38820\nimport FungibleToken from 0x9a0766d93b6608b7\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FindViews from 0x39937dba71a38820\nimport NFTRegistry from 0x39937dba71a38820\nimport FTRegistry from 0x39937dba71a38820\nimport FindMarket from 0x39937dba71a38820\nimport FIND from 0x39937dba71a38820\n\ntransaction(marketplace:Address, user: String, id: UInt64, amount: UFix64) {\n\n    let saleItemsCap: Capability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic}\u003e \n    let targetCapability : Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e\n    let walletReference : \u0026FungibleToken.Vault\n    let bidsReference: \u0026FindMarketAuctionEscrow.MarketBidCollection?\n    let balanceBeforeBid: UFix64\n    let pointer: FindViews.ViewReadPointer\n\n    prepare(account: AuthAccount) {\n\n        let resolveAddress = FIND.resolve(user)\n        if resolveAddress == nil {panic(\"The address input is not a valid name nor address. Input : \".concat(user))}\n        let address = resolveAddress!\n\n        self.saleItemsCap= FindMarketAuctionEscrow.getSaleItemCapability(marketplace:marketplace, user:address) ?? panic(\"cannot find sale item cap\")\n\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e())\n        let item = FindMarket.assertOperationValid(tenant: marketplace, address: address, marketOption: marketOption, id: id)\n\n        let nft = NFTRegistry.getNFTInfoByTypeIdentifier(item.getItemType().identifier) ?? panic(\"This NFT is not supported by the Find Market yet \")\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet\")\n    \n        self.targetCapability= account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(nft.publicPath)\n        /* Check for nftCapability */\n        if !self.targetCapability.check() {\n            let cd = item.getNFTCollectionData()\n            // should use account.type here instead\n            if account.borrow\u003c\u0026AnyResource\u003e(from: cd.storagePath) != nil {\n                panic(\"This collection public link is not set up properly.\")\n            }\n            account.save(\u003c- cd.createEmptyCollection(), to: cd.storagePath)\n            account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.publicPath, target: cd.storagePath)\n            account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.providerPath, target: cd.storagePath)\n        }\n        \n        self.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e())!\n\n        self.bidsReference= account.borrow\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection\u003e(from: storagePath)\n        self.balanceBeforeBid=self.walletReference.balance\n        self.pointer= FindViews.createViewReadPointer(address: address, path:nft.publicPath, id: id)\n    }\n\n    pre {\n        self.bidsReference != nil : \"This account does not have a bid collection\"\n        self.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount) \n        self.bidsReference!.bid(item:self.pointer, vault: \u003c- vault, nftCap: self.targetCapability, bidExtraField: {})\n    }\n\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "user",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64",
                     "marketplace": "Address",
                     "user": "String"
                  }
               }
            },
            "bidMarketAuctionSoft": {
               "code": "import FindMarketAuctionSoft from 0x39937dba71a38820\nimport FungibleToken from 0x9a0766d93b6608b7\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FindViews from 0x39937dba71a38820\nimport FTRegistry from 0x39937dba71a38820\nimport NFTRegistry from 0x39937dba71a38820\nimport FindMarket from 0x39937dba71a38820\nimport FIND from 0x39937dba71a38820\n\ntransaction(marketplace:Address, user: String, id: UInt64, amount: UFix64) {\n\n    let saleItemsCap: Capability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic}\u003e \n    let targetCapability : Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e\n    let walletReference : \u0026FungibleToken.Vault\n    let bidsReference: \u0026FindMarketAuctionSoft.MarketBidCollection?\n    let balanceBeforeBid: UFix64\n    let pointer: FindViews.ViewReadPointer\n    let ftVaultType: Type\n\n    prepare(account: AuthAccount) {\n\n        let resolveAddress = FIND.resolve(user)\n        if resolveAddress == nil {panic(\"The address input is not a valid name nor address. Input : \".concat(user))}\n        let address = resolveAddress!\n\n        self.saleItemsCap= FindMarketAuctionSoft.getSaleItemCapability(marketplace:marketplace, user:address) ?? panic(\"cannot find sale item cap\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e())\n\n        let item = FindMarket.assertOperationValid(tenant: marketplace, address: address, marketOption: marketOption, id: id)\n\n        let nft = NFTRegistry.getNFTInfoByTypeIdentifier(item.getItemType().identifier) ?? panic(\"This NFT is not supported by the Find Market yet \")\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet\")\n    \n        self.targetCapability= account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(nft.publicPath)\n        /* Check for nftCapability */\n        if !self.targetCapability.check() {\n            let cd = item.getNFTCollectionData()\n            // should use account.type here instead\n            if account.borrow\u003c\u0026AnyResource\u003e(from: cd.storagePath) != nil {\n                panic(\"This collection public link is not set up properly.\")\n            }\n            account.save(\u003c- cd.createEmptyCollection(), to: cd.storagePath)\n            account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.publicPath, target: cd.storagePath)\n            account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.providerPath, target: cd.storagePath)\n        }\n        \n        self.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No FUSD wallet linked for this account\")\n        self.ftVaultType = ft.type\n\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e())\n\n        self.bidsReference= account.borrow\u003c\u0026FindMarketAuctionSoft.MarketBidCollection\u003e(from: storagePath)\n        self.balanceBeforeBid=self.walletReference.balance\n        self.pointer= FindViews.createViewReadPointer(address: address, path:nft.publicPath, id: id)\n    }\n\n    pre {\n        self.bidsReference != nil : \"This account does not have a bid collection\"\n        self.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n    }\n\n    execute {\n        self.bidsReference!.bid(item:self.pointer, amount: amount, vaultType: self.ftVaultType, nftCap: self.targetCapability, bidExtraField: {})\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "user",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64",
                     "marketplace": "Address",
                     "user": "String"
                  }
               }
            },
            "bidMarketDirectOfferEscrowed": {
               "code": "import FindMarket from 0x39937dba71a38820\nimport FindMarketDirectOfferEscrow from 0x39937dba71a38820\nimport FungibleToken from 0x9a0766d93b6608b7\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FindViews from 0x39937dba71a38820\nimport FTRegistry from 0x39937dba71a38820\nimport NFTRegistry from 0x39937dba71a38820\nimport FIND from 0x39937dba71a38820\n\ntransaction(marketplace:Address, user: String, nftAliasOrIdentifier: String, id: UInt64, ftAliasOrIdentifier:String, amount: UFix64, validUntil: UFix64?) {\n\n    let targetCapability : Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e\n    let walletReference : \u0026FungibleToken.Vault\n    let bidsReference: \u0026FindMarketDirectOfferEscrow.MarketBidCollection?\n    let balanceBeforeBid: UFix64\n    let pointer: FindViews.ViewReadPointer\n\n    prepare(account: AuthAccount) {\n\n        let resolveAddress = FIND.resolve(user)\n        if resolveAddress == nil {panic(\"The address input is not a valid name nor address. Input : \".concat(user))}\n        let address = resolveAddress!\n\n        let nft = NFTRegistry.getNFTInfo(nftAliasOrIdentifier) ?? panic(\"This NFT is not supported by the Find Market yet\")\n        let ft = FTRegistry.getFTInfo(ftAliasOrIdentifier) ?? panic(\"This FT is not supported by the Find Market yet\")\n        \n        self.targetCapability= account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(nft.publicPath)\n        self.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e())!\n\n        self.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection\u003e(from: storagePath)\n        self.balanceBeforeBid=self.walletReference.balance\n        self.pointer= FindViews.createViewReadPointer(address: address, path:nft.publicPath, id: id)\n\n        /* Check for nftCapability */\n        if !self.targetCapability.check() {\n            let cd = self.pointer.getNFTCollectionData()\n            // should use account.type here instead\n            if account.borrow\u003c\u0026AnyResource\u003e(from: cd.storagePath) != nil {\n                panic(\"This collection public link is not set up properly.\")\n            }\n            account.save(\u003c- cd.createEmptyCollection(), to: cd.storagePath)\n            account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.publicPath, target: cd.storagePath)\n            account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.providerPath, target: cd.storagePath)\n        }\n    }\n\n    pre {\n        self.bidsReference != nil : \"This account does not have a bid collection\"\n        self.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount) \n        self.bidsReference!.bid(item:self.pointer, vault: \u003c- vault, nftCap: self.targetCapability, validUntil: validUntil, saleItemExtraField: {}, bidExtraField: {})\n    }\n\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "user",
                     "nftAliasOrIdentifier",
                     "id",
                     "ftAliasOrIdentifier",
                     "amount",
                     "validUntil"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "ftAliasOrIdentifier": "String",
                     "id": "UInt64",
                     "marketplace": "Address",
                     "nftAliasOrIdentifier": "String",
                     "user": "String",
                     "validUntil": "UFix64?"
                  }
               }
            },
            "bidMarketDirectOfferSoft": {
               "code": "import FindMarketDirectOfferSoft from 0x39937dba71a38820\nimport FindMarket from 0x39937dba71a38820\nimport FungibleToken from 0x9a0766d93b6608b7\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FindViews from 0x39937dba71a38820\nimport FTRegistry from 0x39937dba71a38820\nimport NFTRegistry from 0x39937dba71a38820\nimport FIND from 0x39937dba71a38820\n\ntransaction(marketplace:Address, user: String, nftAliasOrIdentifier: String, id: UInt64, ftAliasOrIdentifier:String, amount: UFix64, validUntil: UFix64?) {\n\n    let targetCapability : Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e\n    let walletReference : \u0026FungibleToken.Vault\n    let bidsReference: \u0026FindMarketDirectOfferSoft.MarketBidCollection?\n    let balanceBeforeBid: UFix64\n    let pointer: FindViews.ViewReadPointer\n    let ftVaultType: Type\n\n    prepare(account: AuthAccount) {\n        \n        let resolveAddress = FIND.resolve(user)\n        if resolveAddress == nil {panic(\"The address input is not a valid name nor address. Input : \".concat(user))}\n        let address = resolveAddress!\n\n        let nft = NFTRegistry.getNFTInfo(nftAliasOrIdentifier) ?? panic(\"This NFT is not supported by the Find Market yet\")\n        let ft = FTRegistry.getFTInfo(ftAliasOrIdentifier) ?? panic(\"This FT is not supported by the Find Market yet\")\n\n        self.ftVaultType = ft.type\n\n        self.targetCapability= account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(nft.publicPath)\n        self.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())!\n        self.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection\u003e(from: storagePath)\n        self.balanceBeforeBid=self.walletReference.balance\n        self.pointer= FindViews.createViewReadPointer(address: address, path:nft.publicPath, id: id)\n\n        /* Check for nftCapability */\n        if !self.targetCapability.check() {\n            let cd = self.pointer.getNFTCollectionData()\n            // should use account.type here instead\n            if account.borrow\u003c\u0026AnyResource\u003e(from: cd.storagePath) != nil {\n                panic(\"This collection public link is not set up properly.\")\n            }\n            account.save(\u003c- cd.createEmptyCollection(), to: cd.storagePath)\n            account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.publicPath, target: cd.storagePath)\n            account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.providerPath, target: cd.storagePath)\n        }\n    }\n\n    pre {\n        self.bidsReference != nil : \"This account does not have a bid collection\"\n        self.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n    }\n\n    execute {\n        self.bidsReference!.bid(item:self.pointer, amount: amount, vaultType: self.ftVaultType, nftCap: self.targetCapability, validUntil: validUntil, saleItemExtraField: {}, bidExtraField: {})\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "user",
                     "nftAliasOrIdentifier",
                     "id",
                     "ftAliasOrIdentifier",
                     "amount",
                     "validUntil"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "ftAliasOrIdentifier": "String",
                     "id": "UInt64",
                     "marketplace": "Address",
                     "nftAliasOrIdentifier": "String",
                     "user": "String",
                     "validUntil": "UFix64?"
                  }
               }
            },
            "bidName": {
               "code": "import FungibleToken from 0x9a0766d93b6608b7\nimport FUSD from 0xe223d8a629e49c68\nimport FiatToken from 0xa983fecbed621163\nimport FlowToken from 0x7e60df042a9c0868\nimport Profile from 0x39937dba71a38820\nimport FIND from 0x39937dba71a38820\nimport Dandy from 0x39937dba71a38820\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FindMarketSale from 0x39937dba71a38820\nimport FindMarket from 0x39937dba71a38820\nimport FindMarketDirectOfferEscrow from 0x39937dba71a38820\nimport FindMarketDirectOfferSoft from 0x39937dba71a38820\nimport FindMarketAuctionEscrow from 0x39937dba71a38820\nimport FindMarketAuctionSoft from 0x39937dba71a38820\n\ntransaction(name: String, amount: UFix64) {\n    prepare(acct: AuthAccount) {\n\n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n        //SYNC with register\n        //Add exising FUSD or create a new one and add it\n        let fusdReceiver = acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n        if !fusdReceiver.check() {\n            let fusd \u003c- FUSD.createEmptyVault()\n            acct.save(\u003c- fusd, to: /storage/fusdVault)\n            acct.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n            acct.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n        }\n\n        let usdcCap = acct.getCapability\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e(FiatToken.VaultReceiverPubPath)\n        if !usdcCap.check() {\n                acct.save( \u003c-FiatToken.createEmptyVault(), to: FiatToken.VaultStoragePath)\n        acct.link\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e( FiatToken.VaultReceiverPubPath, target: FiatToken.VaultStoragePath)\n        acct.link\u003c\u0026FiatToken.Vault{FiatToken.ResourceId}\u003e( FiatToken.VaultUUIDPubPath, target: FiatToken.VaultStoragePath)\n                acct.link\u003c\u0026FiatToken.Vault{FungibleToken.Balance}\u003e( FiatToken.VaultBalancePubPath, target:FiatToken.VaultStoragePath)\n        }\n\n        let leaseCollection = acct.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            acct.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            acct.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = acct.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            acct.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            acct.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let dandyCap= acct.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            acct.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            acct.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            acct.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        var created=false\n        let profileCap = acct.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            acct.save(\u003c-profile, to: Profile.storagePath)\n            acct.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            acct.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=acct.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n        if !profile.hasWallet(\"Flow\") {\n            let flowWallet=Profile.Wallet( name:\"Flow\", receiver:acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:acct.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), names: [\"flow\"])\n    \n            profile.addWallet(flowWallet)\n        }\n        if !profile.hasWallet(\"FUSD\") {\n            profile.addWallet(Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:acct.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), names: [\"fusd\", \"stablecoin\"]))\n        }\n\n        if !profile.hasWallet(\"USDC\") {\n            profile.addWallet(Profile.Wallet( name:\"USDC\", receiver:usdcCap, balance:acct.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(FiatToken.VaultBalancePubPath), accept: Type\u003c@FiatToken.Vault\u003e(), names: [\"usdc\", \"stablecoin\"]))\n        }\n\n         //If find name not set and we have a profile set it.\n        if profile.getFindName() == \"\" {\n            profile.setFindName(name)\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else {\n            profile.emitUpdatedEvent()\n        }\n\n        let receiverCap=acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let tenantCapability= FindMarket.getTenantCapability(FindMarket.getFindTenantAddress())!\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= acct.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            acct.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            acct.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        let doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        let doeSalePublicPath=FindMarket.getPublicPath(doeSaleType, name: tenant.name)\n        let doeSaleStoragePath= FindMarket.getStoragePath(doeSaleType, name:tenant.name)\n        let doeSaleCap= acct.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n        if !doeSaleCap.check() {\n            acct.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n            acct.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n        }\n\n        let doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        let doeBidPublicPath=FindMarket.getPublicPath(doeBidType, name: tenant.name)\n        let doeBidStoragePath= FindMarket.getStoragePath(doeBidType, name:tenant.name)\n        let doeBidCap= acct.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n        if !doeBidCap.check() {\n            acct.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n            acct.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n        }\n\n        /// auctions that escrow ft\n        let aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        let aeSalePublicPath=FindMarket.getPublicPath(aeSaleType, name: tenant.name)\n        let aeSaleStoragePath= FindMarket.getStoragePath(aeSaleType, name:tenant.name)\n        let aeSaleCap= acct.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n        if !aeSaleCap.check() {\n            acct.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n            acct.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n        }\n\n        let dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\n        let dosSalePublicPath=FindMarket.getPublicPath(dosSaleType, name: tenant.name)\n        let dosSaleStoragePath= FindMarket.getStoragePath(dosSaleType, name:tenant.name)\n\n        let dosSaleCap= acct.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n        if !dosSaleCap.check() {\n            acct.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n            acct.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n        }\n\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= acct.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n        if !dosBidCap.check() {\n            acct.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            acct.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n        }\n\n        let aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\n        let aeBidPublicPath=FindMarket.getPublicPath(aeBidType, name: tenant.name)\n        let aeBidStoragePath= FindMarket.getStoragePath(aeBidType, name:tenant.name)\n        let aeBidCap= acct.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n        if !aeBidCap.check() {\n            acct.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n            acct.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n        }\n\n     /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= acct.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            acct.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            acct.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n        }\n\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= acct.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n        if !asBidCap.check() {\n            acct.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            acct.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n        }\n        //SYNC with register\n\n\n        let vaultRef = acct.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault) ?? panic(\"Could not borrow reference to the fusdVault!\")\n        let vault \u003c- vaultRef.withdraw(amount: amount) as! @FUSD.Vault\n        let bids = acct.borrow\u003c\u0026FIND.BidCollection\u003e(from: FIND.BidStoragePath)!\n        bids.bid(name: name, vault: \u003c- vault)\n\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "name": "String"
                  }
               }
            },
            "buyAddon": {
               "code": "import FUSD from 0xe223d8a629e49c68\nimport FIND from 0x39937dba71a38820\n\n\ntransaction(name: String, addon:String, amount:UFix64) {\n    prepare(account: AuthAccount) {\n\n        let leases= account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n\n        let vaultRef = account.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault) ?? panic(\"Could not borrow reference to the fusdVault!\")\n        let vault \u003c- vaultRef.withdraw(amount: amount) as! @FUSD.Vault\n        leases.buyAddon(name: name, addon: addon, vault: \u003c- vault)\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "addon",
                     "amount"
                  ],
                  "parameters": {
                     "addon": "String",
                     "amount": "UFix64",
                     "name": "String"
                  }
               }
            },
            "buyNFTForSale": {
               "code": "import FindMarket from 0x39937dba71a38820\nimport FindMarketSale from 0x39937dba71a38820\nimport FungibleToken from 0x9a0766d93b6608b7\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport NFTRegistry from 0x39937dba71a38820\nimport FTRegistry from 0x39937dba71a38820\nimport FIND from 0x39937dba71a38820\n\ntransaction(marketplace:Address, user: String, id: UInt64, amount: UFix64) {\n\n    let targetCapability : Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e\n    let walletReference : \u0026FungibleToken.Vault\n\n    let saleItemsCap: Capability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic}\u003e \n\n    prepare(account: AuthAccount) {\n\n        let resolveAddress = FIND.resolve(user)\n        if resolveAddress == nil {\n            panic(\"The address input is not a valid name nor address. Input : \".concat(user))\n        }\n        let address = resolveAddress!\n        self.saleItemsCap= FindMarketSale.getSaleItemCapability(marketplace: marketplace, user:address) ?? panic(\"cannot find sale item cap\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketSale.SaleItemCollection\u003e())\n\n        let item= FindMarket.assertOperationValid(tenant: marketplace, address: address, marketOption: marketOption, id: id)\n\n        let nft = NFTRegistry.getNFTInfoByTypeIdentifier(item.getItemType().identifier) ?? panic(\"This NFT is not supported by the Find Market yet \")\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet\")\n    \n        self.targetCapability= account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(nft.publicPath)\n        /* Check for nftCapability */\n        if !self.targetCapability.check() {\n            let cd = item.getNFTCollectionData()\n            // should use account.type here instead\n            if account.borrow\u003c\u0026AnyResource\u003e(from: cd.storagePath) != nil {\n                panic(\"This collection public link is not set up properly.\")\n            }\n            account.save(\u003c- cd.createEmptyCollection(), to: cd.storagePath)\n            account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.publicPath, target: cd.storagePath)\n            account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.providerPath, target: cd.storagePath)\n        }\n\n        self.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n    }\n\n    pre {\n        self.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount) \n        self.saleItemsCap.borrow()!.buy(id:id, vault: \u003c- vault, nftCap: self.targetCapability)\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "user",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64",
                     "marketplace": "Address",
                     "user": "String"
                  }
               }
            },
            "cancelMarketAuctionEscrowed": {
               "code": "import FindMarket from 0x39937dba71a38820\nimport FindMarketAuctionEscrow from 0x39937dba71a38820\n\ntransaction(marketplace:Address, ids: [UInt64]) {\n    prepare(account: AuthAccount) {\n\n        let tenant=FindMarket.getTenant(marketplace)\n        let saleItems= account.borrow\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()))!\n        for id in ids {\n            saleItems.cancel(id)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "ids"
                  ],
                  "parameters": {
                     "ids": "[UInt64]",
                     "marketplace": "Address"
                  }
               }
            },
            "cancelMarketAuctionSoft": {
               "code": "import FindMarket from 0x39937dba71a38820\nimport FindMarketAuctionSoft from 0x39937dba71a38820\n\ntransaction(marketplace:Address, ids: [UInt64]) {\n    prepare(account: AuthAccount) {\n        let tenant=FindMarket.getTenant(marketplace)\n        let saleItems= account.borrow\u003c\u0026FindMarketAuctionSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()))!\n        for id in ids {\n            saleItems.cancel(id)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "ids"
                  ],
                  "parameters": {
                     "ids": "[UInt64]",
                     "marketplace": "Address"
                  }
               }
            },
            "cancelMarketDirectOfferEscrowed": {
               "code": "import FindMarket from 0x39937dba71a38820\nimport FindMarketDirectOfferEscrow from 0x39937dba71a38820\n\ntransaction(marketplace:Address, ids: [UInt64]) {\n    prepare(account: AuthAccount) {\n\n        let tenant=FindMarket.getTenant(marketplace)\n        let saleItems= account.borrow\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()))!\n        for id in ids {\n            saleItems.cancel(id)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "ids"
                  ],
                  "parameters": {
                     "ids": "[UInt64]",
                     "marketplace": "Address"
                  }
               }
            },
            "cancelMarketDirectOfferSoft": {
               "code": "import FindMarket from 0x39937dba71a38820\nimport FindMarketDirectOfferSoft from 0x39937dba71a38820\n\ntransaction(marketplace:Address, ids: [UInt64]) {\n    prepare(account: AuthAccount) {\n\n        let tenant=FindMarket.getTenant(marketplace)\n        let saleItems= account.borrow\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()))!\n        for id in ids {\n            saleItems.cancel(id)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "ids"
                  ],
                  "parameters": {
                     "ids": "[UInt64]",
                     "marketplace": "Address"
                  }
               }
            },
            "cancelNameAuction": {
               "code": "import FIND from 0x39937dba71a38820\n\ntransaction(names: [String]) {\n    prepare(account: AuthAccount) {\n\n        let finLeases= account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n        for name in names {\n            finLeases.cancel(name)\n            finLeases.delistAuction(name)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "names"
                  ],
                  "parameters": {
                     "names": "[String]"
                  }
               }
            },
            "cancelNameBid": {
               "code": "import FIND from 0x39937dba71a38820\n\ntransaction(names: [String]) {\n    prepare(account: AuthAccount) {\n        let bids = account.borrow\u003c\u0026FIND.BidCollection\u003e(from: FIND.BidStoragePath)!\n        for name in names {\n            bids.cancelBid(name)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "names"
                  ],
                  "parameters": {
                     "names": "[String]"
                  }
               }
            },
            "createCharity": {
               "code": "import NonFungibleToken from 0x631e88ae7f1d7c20\nimport CharityNFT from 0x39937dba71a38820\n\n//This transaction will prepare the art collection\ntransaction() {\n    prepare(account: AuthAccount) {\n\n        let stdCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath)\n        if !stdCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- CharityNFT.createEmptyCollection(), to: CharityNFT.CollectionStoragePath)\n            account.link\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath, target: CharityNFT.CollectionStoragePath)\n        }\n\n        let charityCap = account.getCapability\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection)\n        if !charityCap.check() {\n            account.link\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection, target: CharityNFT.CollectionStoragePath)\n        }\n    }\n}",
               "spec": null
            },
            "createProfile": {
               "code": "import FungibleToken from 0x9a0766d93b6608b7\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport FUSD from 0xe223d8a629e49c68\nimport FiatToken from 0xa983fecbed621163\nimport FlowToken from 0x7e60df042a9c0868\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FIND from 0x39937dba71a38820\nimport Profile from 0x39937dba71a38820\nimport FindMarket from 0x39937dba71a38820\nimport FindMarketSale from 0x39937dba71a38820\nimport FindMarketDirectOfferEscrow from 0x39937dba71a38820\nimport FindMarketDirectOfferSoft from 0x39937dba71a38820\nimport FindMarketAuctionEscrow from 0x39937dba71a38820\nimport FindMarketAuctionSoft from 0x39937dba71a38820\nimport Dandy from 0x39937dba71a38820\n\ntransaction(name: String) {\n    prepare(acct: AuthAccount) {\n        //if we do not have a profile it might be stored under a different address so we will just remove it\n        let profileCapFirst = acct.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if profileCapFirst.check() {\n            return \n        }\n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n        //SYNC with register\n        //Add exising FUSD or create a new one and add it\n        let fusdReceiver = acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n        if !fusdReceiver.check() {\n            let fusd \u003c- FUSD.createEmptyVault()\n            acct.save(\u003c- fusd, to: /storage/fusdVault)\n            acct.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n            acct.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n        }\n\n        let usdcCap = acct.getCapability\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e(FiatToken.VaultReceiverPubPath)\n        if !usdcCap.check() {\n                acct.save( \u003c-FiatToken.createEmptyVault(), to: FiatToken.VaultStoragePath)\n        acct.link\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e( FiatToken.VaultReceiverPubPath, target: FiatToken.VaultStoragePath)\n        acct.link\u003c\u0026FiatToken.Vault{FiatToken.ResourceId}\u003e( FiatToken.VaultUUIDPubPath, target: FiatToken.VaultStoragePath)\n                acct.link\u003c\u0026FiatToken.Vault{FungibleToken.Balance}\u003e( FiatToken.VaultBalancePubPath, target:FiatToken.VaultStoragePath)\n        }\n\n        let leaseCollection = acct.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            acct.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            acct.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = acct.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            acct.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            acct.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let dandyCap= acct.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            acct.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            acct.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            acct.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        var created=false\n        let profileCap = acct.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            acct.save(\u003c-profile, to: Profile.storagePath)\n            acct.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            acct.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=acct.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n        if !profile.hasWallet(\"Flow\") {\n            let flowWallet=Profile.Wallet( name:\"Flow\", receiver:acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:acct.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), names: [\"flow\"])\n    \n            profile.addWallet(flowWallet)\n        }\n        if !profile.hasWallet(\"FUSD\") {\n            profile.addWallet(Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:acct.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), names: [\"fusd\", \"stablecoin\"]))\n        }\n\n        if !profile.hasWallet(\"USDC\") {\n            profile.addWallet(Profile.Wallet( name:\"USDC\", receiver:usdcCap, balance:acct.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(FiatToken.VaultBalancePubPath), accept: Type\u003c@FiatToken.Vault\u003e(), names: [\"usdc\", \"stablecoin\"]))\n        }\n\n         //If find name not set and we have a profile set it.\n        if profile.getFindName() == \"\" {\n            profile.setFindName(name)\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else {\n            profile.emitUpdatedEvent()\n        }\n\n        let receiverCap=acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let tenantCapability= FindMarket.getTenantCapability(FindMarket.getFindTenantAddress())!\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= acct.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            acct.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            acct.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        let doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        let doeSalePublicPath=FindMarket.getPublicPath(doeSaleType, name: tenant.name)\n        let doeSaleStoragePath= FindMarket.getStoragePath(doeSaleType, name:tenant.name)\n        let doeSaleCap= acct.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n        if !doeSaleCap.check() {\n            acct.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n            acct.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n        }\n\n        let doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        let doeBidPublicPath=FindMarket.getPublicPath(doeBidType, name: tenant.name)\n        let doeBidStoragePath= FindMarket.getStoragePath(doeBidType, name:tenant.name)\n        let doeBidCap= acct.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n        if !doeBidCap.check() {\n            acct.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n            acct.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n        }\n\n        /// auctions that escrow ft\n        let aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        let aeSalePublicPath=FindMarket.getPublicPath(aeSaleType, name: tenant.name)\n        let aeSaleStoragePath= FindMarket.getStoragePath(aeSaleType, name:tenant.name)\n        let aeSaleCap= acct.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n        if !aeSaleCap.check() {\n            acct.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n            acct.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n        }\n\n        let dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\n        let dosSalePublicPath=FindMarket.getPublicPath(dosSaleType, name: tenant.name)\n        let dosSaleStoragePath= FindMarket.getStoragePath(dosSaleType, name:tenant.name)\n\n        let dosSaleCap= acct.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n        if !dosSaleCap.check() {\n            acct.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n            acct.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n        }\n\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= acct.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n        if !dosBidCap.check() {\n            acct.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            acct.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n        }\n\n        let aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\n        let aeBidPublicPath=FindMarket.getPublicPath(aeBidType, name: tenant.name)\n        let aeBidStoragePath= FindMarket.getStoragePath(aeBidType, name:tenant.name)\n        let aeBidCap= acct.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n        if !aeBidCap.check() {\n            acct.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n            acct.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n        }\n\n     /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= acct.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            acct.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            acct.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n        }\n\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= acct.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n        if !asBidCap.check() {\n            acct.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            acct.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n        }\n        //SYNC with register\n\n    }\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "delistAllNFTSale": {
               "code": "import FindMarketSale from 0x39937dba71a38820\nimport FindMarket from 0x39937dba71a38820\n\ntransaction(marketplace:Address) {\n    prepare(account: AuthAccount) {\n        // Get all the saleItems Id\n\n        let tenant = FindMarket.getTenant(marketplace)\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketSale.SaleItem\u003e())\n        let cap = FindMarket.getSaleItemCollectionCapability(tenantRef: tenant, marketOption: marketOption, address: account.address)\n        let ref = cap.borrow() ?? panic(\"Cannot borrow reference to the capability.\")\n\n        let listingType=Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let saleItems= account.borrow\u003c\u0026FindMarketSale.SaleItemCollection\u003e(from: tenant.getStoragePath(listingType))!\n        let ids = ref.getIds()\n        for id in ids {\n            saleItems.delist(id)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace"
                  ],
                  "parameters": {
                     "marketplace": "Address"
                  }
               }
            },
            "delistAllNameSale": {
               "code": "import FIND from 0x39937dba71a38820\n\ntransaction() {\n    prepare(acct: AuthAccount) {\n        let finLeases= acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n        let leases = finLeases.getLeaseInformation()\n        for lease in leases {\n            if lease.salePrice != nil {\n                finLeases.delistSale(lease.name)\n            }\n        }\n    }\n}",
               "spec": null
            },
            "delistNFTSale": {
               "code": "import FindMarket from 0x39937dba71a38820\nimport FindMarketSale from 0x39937dba71a38820\n\ntransaction(marketplace:Address, ids: [UInt64]) {\n    prepare(account: AuthAccount) {\n\n        let tenant=FindMarket.getTenant(marketplace)\n        let saleItems= account.borrow\u003c\u0026FindMarketSale.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketSale.SaleItemCollection\u003e()))!\n        for id in ids {\n            saleItems.delist(id)\n        }\n\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "ids"
                  ],
                  "parameters": {
                     "ids": "[UInt64]",
                     "marketplace": "Address"
                  }
               }
            },
            "delistNameSale": {
               "code": "import FIND from 0x39937dba71a38820\n\ntransaction(names: [String]) {\n    prepare(acct: AuthAccount) {\n        let finLeases= acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n        for name in names {\n            finLeases.delistSale(name)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "names"
                  ],
                  "parameters": {
                     "names": "[String]"
                  }
               }
            },
            "editProfile": {
               "code": "import FungibleToken from 0x9a0766d93b6608b7\nimport FUSD from 0xe223d8a629e49c68\nimport FlowToken from 0x7e60df042a9c0868\nimport FIND from 0x39937dba71a38820\nimport Profile from 0x39937dba71a38820\n\ntransaction(name:String, description: String, avatar: String, tags:[String], allowStoringFollowers: Bool, linkTitles : {String: String}, linkTypes: {String:String}, linkUrls : {String:String}, removeLinks : [String]) {\n    prepare(acct: AuthAccount) {\n\n        let profile =acct.borrow\u003c\u0026Profile.User\u003e(from:Profile.storagePath)!\n\n        //Add exising FUSD or create a new one and add it\n        let fusdReceiver = acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n        if !fusdReceiver.check() {\n            let fusd \u003c- FUSD.createEmptyVault()\n            acct.save(\u003c- fusd, to: /storage/fusdVault)\n            acct.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n            acct.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n        }\n\n\n        var hasFusdWallet=false\n        var hasFlowWallet=false\n        let wallets=profile.getWallets()\n        for wallet in wallets {\n            if wallet.name==\"FUSD\" {\n                hasFusdWallet=true\n            }\n\n            if wallet.name ==\"Flow\" {\n                hasFlowWallet=true\n            }\n        }\n\n        if !hasFlowWallet {\n            let flowWallet=Profile.Wallet(\n                name:\"Flow\", \n                receiver:acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver),\n                balance:acct.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance),\n                accept: Type\u003c@FlowToken.Vault\u003e(),\n                names: [\"flow\"]\n            )\n            profile.addWallet(flowWallet)\n        }\n\n        if !hasFusdWallet {\n            let fusdWallet=Profile.Wallet(\n                name:\"FUSD\", \n                receiver:acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver),\n                balance:acct.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance),\n                accept: Type\u003c@FUSD.Vault\u003e(),\n                names: [\"fusd\", \"stablecoin\"]\n            )\n            profile.addWallet(fusdWallet)\n        }\n\n        profile.setName(name)\n        profile.setDescription(description)\n        profile.setAvatar(avatar)\n        profile.setTags(tags)\n\n        for link in removeLinks {\n            profile.removeLink(link)\n        }\n\n        for titleName in linkTitles.keys {\n            let title=linkTitles[titleName]!\n            let url = linkUrls[titleName]!\n            let type = linkTypes[titleName]!\n\n            profile.addLinkWithName(name:titleName, link: Profile.Link(title: title, type: type, url: type))\n        }\n        profile.emitUpdatedEvent()\n\n        let leaseCollection = acct.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            acct.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            acct.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n\n        }\n\n        let bidCollection = acct.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            acct.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            acct.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "description",
                     "avatar",
                     "tags",
                     "allowStoringFollowers",
                     "linkTitles",
                     "linkTypes",
                     "linkUrls",
                     "removeLinks"
                  ],
                  "parameters": {
                     "allowStoringFollowers": "Bool",
                     "avatar": "String",
                     "description": "String",
                     "linkTitles": "{String: String}",
                     "linkTypes": "{String: String}",
                     "linkUrls": "{String: String}",
                     "name": "String",
                     "removeLinks": "[String]",
                     "tags": "[String]"
                  }
               }
            },
            "fulfillMarketAuctionEscrowed": {
               "code": "import FindMarketAuctionEscrow from 0x39937dba71a38820\nimport FIND from 0x39937dba71a38820\n\ntransaction(marketplace:Address, owner: String, id: UInt64) {\n    prepare(account: AuthAccount) {\n        let resolveAddress = FIND.resolve(owner)\n        if resolveAddress == nil { \n            panic(\"The address input is not a valid name nor address. Input : \".concat(owner))\n        }\n        let address = resolveAddress!\n        FindMarketAuctionEscrow.getSaleItemCapability(marketplace:marketplace, user:address)!.borrow()!.fulfillAuction(id)\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "owner",
                     "id"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "marketplace": "Address",
                     "owner": "String"
                  }
               }
            },
            "fulfillMarketAuctionEscrowedFromBidder": {
               "code": "import FindMarketAuctionEscrow from 0x39937dba71a38820\nimport FindMarket from 0x39937dba71a38820\n\ntransaction(marketplace:Address, id: UInt64) {\n    prepare(account: AuthAccount) {\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e())!\n        let bidsReference= account.borrow\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection\u003e(from: storagePath)!\n\n        bidsReference.fulfillAuction(id)\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "fulfillMarketAuctionSoft": {
               "code": "import FindMarketAuctionSoft from 0x39937dba71a38820\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FTRegistry from 0x39937dba71a38820\nimport FindMarket from 0x39937dba71a38820\n\ntransaction(marketplace:Address, id: UInt64, amount:UFix64) {\n\n    let walletReference : \u0026FungibleToken.Vault\n    let bidsReference: \u0026FindMarketAuctionSoft.MarketBidCollection\n    let requiredAmount: UFix64\n\n    prepare(account: AuthAccount) {\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e())\n\n        self.bidsReference= account.borrow\u003c\u0026FindMarketAuctionSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"This account does not have a bid collection\")\n\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e())\n        let item = FindMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: id)\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet\")\n    \n        self.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n        self.requiredAmount = self.bidsReference.getBalance(id)\n    }\n\n    pre{\n        self.walletReference.balance \u003e self.requiredAmount : \"Your wallet does not have enough funds to pay for this item\"\n        self.requiredAmount == amount : \"Amount needed to fulfill is \".concat(self.requiredAmount.toString()).concat(\" you sent in \").concat(amount.toString())\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount) \n        self.bidsReference.fulfillAuction(id: id, vault: \u003c- vault)\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "fulfillMarketDirectOfferEscrowed": {
               "code": "import FindMarketDirectOfferEscrow from 0x39937dba71a38820\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FindViews from 0x39937dba71a38820\nimport NFTRegistry from 0x39937dba71a38820\nimport FindMarket from 0x39937dba71a38820\n\ntransaction(marketplace:Address, id: UInt64) {\n    prepare(account: AuthAccount) {\n\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e())\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e())\n\n        let item = FindMarket.assertOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: id)\n\n        let nft = NFTRegistry.getNFTInfoByTypeIdentifier(item.getItemType().identifier) ?? panic(\"This NFT is not supported by the Find Market yet \")\n    \n        let providerCap=account.getCapability\u003c\u0026{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e(nft.providerPath)\n\n        /* Ben : Question -\u003e Either client will have to provide the path here or agree that we set it up for the user */\n        if !providerCap.check() {\n                account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                    nft.providerPath,\n                    target: nft.storagePath\n            )\n        }\n\n        let pointer= FindViews.AuthNFTPointer(cap: providerCap, id: id)\n        let market = account.borrow\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection\u003e(from: storagePath)!\n        market.acceptDirectOffer(pointer)\n\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "fulfillMarketDirectOfferSoft": {
               "code": "import FindMarketDirectOfferSoft from 0x39937dba71a38820\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FTRegistry from 0x39937dba71a38820\nimport FindMarket from 0x39937dba71a38820\n\ntransaction(marketplace:Address, id: UInt64, amount:UFix64) {\n\n    let walletReference : \u0026FungibleToken.Vault\n    let bidsReference: \u0026FindMarketDirectOfferSoft.MarketBidCollection\n    let requiredAmount:UFix64\n\n    prepare(account: AuthAccount) {\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n        self.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"Cannot borrow direct offer soft bid collection\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n        let item = FindMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: id)\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet\")\n\n      self.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n\n        self.requiredAmount = self.bidsReference.getBalance(id)\n    }\n\n    pre {\n        self.walletReference.balance \u003e self.requiredAmount : \"Your wallet does not have enough funds to pay for this item\"\n        self.requiredAmount == amount : \"Amount needed to fulfill is \".concat(amount.toString())\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount) \n        self.bidsReference.fulfillDirectOffer(id: id, vault: \u003c- vault)\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "fulfillName": {
               "code": "import FIND from 0x39937dba71a38820\n\ntransaction(name: String) {\n    prepare(account: AuthAccount) {\n\n        let finLeases= account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n        finLeases.fulfill(name)\n\n    }\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "fulfillNameAuction": {
               "code": "import FIND from 0x39937dba71a38820\n\ntransaction(owner: Address, name: String) {\n    prepare(account: AuthAccount) {\n        let leaseCollection = getAccount(owner).getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        let leaseRef = leaseCollection.borrow() ?? panic(\"Cannot borrow reference to lease collection reference\")\n        leaseRef.fulfillAuction(name)\n\n    }\n}",
               "spec": {
                  "order": [
                     "owner",
                     "name"
                  ],
                  "parameters": {
                     "name": "String",
                     "owner": "Address"
                  }
               }
            },
            "fulfillNameAuctionBidder": {
               "code": "import FIND from 0x39937dba71a38820\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FUSD from 0xe223d8a629e49c68\nimport Profile from 0x39937dba71a38820\n\ntransaction(owner: Address, name: String) {\n    prepare(acct: AuthAccount) {\n\n\n    //Add exising FUSD or create a new one and add it\n        let fusdReceiver = acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n        if !fusdReceiver.check() {\n            let fusd \u003c- FUSD.createEmptyVault()\n            acct.save(\u003c- fusd, to: /storage/fusdVault)\n            acct.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n            acct.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n        }\n\n        let leaseCollection = acct.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            acct.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            acct.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = acct.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            acct.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            acct.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let profileCap = acct.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n\n            let fusdWallet=Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:acct.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), names: [\"fusd\", \"stablecoin\"])\n\n            profile.addWallet(fusdWallet)\n\n            acct.save(\u003c-profile, to: Profile.storagePath)\n            acct.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            acct.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n        }\n\n        let leaseCollectionOwner = getAccount(owner).getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        leaseCollectionOwner.borrow()!.fulfillAuction(name)\n\n    }\n}",
               "spec": {
                  "order": [
                     "owner",
                     "name"
                  ],
                  "parameters": {
                     "name": "String",
                     "owner": "Address"
                  }
               }
            },
            "increaseBidMarketAuctionEscrowed": {
               "code": "import FindMarketAuctionEscrow from 0x39937dba71a38820\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FTRegistry from 0x39937dba71a38820\nimport FindMarket from 0x39937dba71a38820\n\ntransaction(marketplace:Address, id: UInt64, amount: UFix64) {\n\n    let walletReference : \u0026FungibleToken.Vault\n    let bidsReference: \u0026FindMarketAuctionEscrow.MarketBidCollection\n    let balanceBeforeBid: UFix64\n\n    prepare(account: AuthAccount) {\n\n        // Get the accepted vault type from BidInfo\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e())\n        self.bidsReference= account.borrow\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection\u003e(from: storagePath) ?? panic(\"This account does not have a bid collection\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e())\n        let item = FindMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: id)\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet\")\n        self.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n        self.balanceBeforeBid = self.walletReference.balance\n    }\n\n    pre {\n        self.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount) \n        self.bidsReference.increaseBid(id: id, vault: \u003c- vault)\n    }\n\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "increaseBidMarketAuctionSoft": {
               "code": "import FindMarketAuctionSoft from 0x39937dba71a38820\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FTRegistry from 0x39937dba71a38820\nimport FindMarket from 0x39937dba71a38820\n\ntransaction(marketplace:Address, id: UInt64, amount: UFix64) {\n\n    let bidsReference: \u0026FindMarketAuctionSoft.MarketBidCollection\n    let walletReference : \u0026FungibleToken.Vault\n\n\n    prepare(account: AuthAccount) {\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e())\n        self.bidsReference= account.borrow\u003c\u0026FindMarketAuctionSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"Bid resource does not exist\")\n        // get Bidding Fungible Token Vault\n          let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e())\n        let item = FindMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: id)\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet\")\n\n        self.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n    }\n\n    execute {\n        self.bidsReference.increaseBid(id: id, increaseBy: amount)\n    }\n\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "increaseBidMarketDirectOfferEscrowed": {
               "code": "import FindMarketDirectOfferEscrow from 0x39937dba71a38820\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FTRegistry from 0x39937dba71a38820\nimport FindMarket from 0x39937dba71a38820\n\ntransaction(marketplace:Address, id: UInt64, amount: UFix64) {\n\n    let walletReference : \u0026FungibleToken.Vault\n    let bidsReference: \u0026FindMarketDirectOfferEscrow.MarketBidCollection\n    let balanceBeforeBid: UFix64\n\n    prepare(account: AuthAccount) {\n        let tenant=FindMarket.getTenantCapability(marketplace)!.borrow() ?? panic(\"Cannot borrow reference to tenant\")\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e())\n        self.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection\u003e(from: storagePath) ?? panic(\"This account does not have a bid collection\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e())\n        let item = FindMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: id)\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet\")\n        self.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n        self.balanceBeforeBid=self.walletReference.balance\n    }\n\n    pre {\n        self.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount) \n        self.bidsReference!.increaseBid(id: id, vault: \u003c- vault)\n    }\n\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "increaseBidMarketDirectOfferSoft": {
               "code": "import FindMarketDirectOfferSoft from 0x39937dba71a38820\nimport FindMarket from 0x39937dba71a38820\n\ntransaction(marketplace: Address, id: UInt64, amount: UFix64) {\n\n    let bidsReference: \u0026FindMarketDirectOfferSoft.MarketBidCollection\n\n    prepare(account: AuthAccount) {\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n        self.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"Bid resource does not exist\")\n        // get Bidding Fungible Token Vault\n          let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n        let item = FindMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: id)\n    }\n\n    execute {\n        self.bidsReference.increaseBid(id: id, increaseBy: amount)\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "increaseNameBid": {
               "code": "import FIND from 0x39937dba71a38820\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FUSD from 0xe223d8a629e49c68\n\ntransaction(name: String, amount: UFix64) {\n    prepare(account: AuthAccount) {\n\n        let vaultRef = account.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault) ?? panic(\"Could not borrow reference to the fusdVault!\")\n        \n        let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n\n        let vault \u003c- vaultRef.withdraw(amount: amount) as! @FUSD.Vault\n        let bids = account.borrow\u003c\u0026FIND.BidCollection\u003e(from: FIND.BidStoragePath)!\n        bids.increaseBid(name: name, vault: \u003c- vault)\n\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "name": "String"
                  }
               }
            },
            "listNFTForAuctionEscrowed": {
               "code": "import FindMarket from 0x39937dba71a38820\nimport FindMarketAuctionEscrow from 0x39937dba71a38820\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FindViews from 0x39937dba71a38820\nimport NFTRegistry from 0x39937dba71a38820\nimport FTRegistry from 0x39937dba71a38820\n\ntransaction(marketplace:Address, nftAliasOrIdentifier:String, id: UInt64, ftAliasOrIdentifier:String, price:UFix64, auctionReservePrice: UFix64, auctionDuration: UFix64, auctionExtensionOnLateBid: UFix64, minimumBidIncrement: UFix64, auctionValidUntil: UFix64?) {\n    prepare(account: AuthAccount) {\n        // get saleItemsRef from tenant\n        let tenant=FindMarket.getTenant(marketplace)\n\n        let path=FindMarket.getStoragePath(Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(), name: tenant.name)\n\n        let saleItems= account.borrow\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection\u003e(from: path)!\n\n        // Get supported NFT and FT Information from Registries from input alias\n        let nft = NFTRegistry.getNFTInfo(nftAliasOrIdentifier) ?? panic(\"This NFT is not supported by the Find Market yet\")\n        let ft = FTRegistry.getFTInfo(ftAliasOrIdentifier) ?? panic(\"This FT is not supported by the Find Market yet\")\n\n        let providerCap=account.getCapability\u003c\u0026{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e(nft.providerPath)\n        \n        /* Ben : Question -\u003e Either client will have to provide the path here or agree that we set it up for the user */\n        if !providerCap.check() {\n                account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                    nft.providerPath,\n                    target: nft.storagePath\n            )\n        }\n\n        let pointer= FindViews.AuthNFTPointer(cap: providerCap, id: id)\n        // Ben : panic on some unreasonable inputs in trxn \n        assert(minimumBidIncrement \u003e 0.0, message:\"Minimum bid increment should be larger than 0.\")\n        assert((auctionReservePrice - auctionReservePrice) % minimumBidIncrement == 0.0, message:\"Acution ReservePrice should be in step of minimum bid increment.\" )\n        assert(auctionDuration \u003e 0.0, message: \"Auction Duration should be greater than 0.\")\n        assert(auctionExtensionOnLateBid \u003e 0.0, message: \"Auction Duration should be greater than 0.\")\n        \n        saleItems.listForAuction(pointer: pointer, vaultType: ft.type, auctionStartPrice: price, auctionReservePrice: auctionReservePrice, auctionDuration: auctionDuration, auctionExtensionOnLateBid: auctionExtensionOnLateBid, minimumBidIncrement: minimumBidIncrement, auctionValidUntil:auctionValidUntil, saleItemExtraField: {})\n\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "nftAliasOrIdentifier",
                     "id",
                     "ftAliasOrIdentifier",
                     "price",
                     "auctionReservePrice",
                     "auctionDuration",
                     "auctionExtensionOnLateBid",
                     "minimumBidIncrement",
                     "auctionValidUntil"
                  ],
                  "parameters": {
                     "auctionDuration": "UFix64",
                     "auctionExtensionOnLateBid": "UFix64",
                     "auctionReservePrice": "UFix64",
                     "auctionValidUntil": "UFix64?",
                     "ftAliasOrIdentifier": "String",
                     "id": "UInt64",
                     "marketplace": "Address",
                     "minimumBidIncrement": "UFix64",
                     "nftAliasOrIdentifier": "String",
                     "price": "UFix64"
                  }
               }
            },
            "listNFTForAuctionSoft": {
               "code": "import FindMarket from 0x39937dba71a38820\nimport FindMarketAuctionSoft from 0x39937dba71a38820\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FindViews from 0x39937dba71a38820\nimport FTRegistry from 0x39937dba71a38820\nimport NFTRegistry from 0x39937dba71a38820\n\ntransaction(marketplace:Address, nftAliasOrIdentifier:String, id: UInt64, ftAliasOrIdentifier:String, price:UFix64, auctionReservePrice: UFix64, auctionDuration: UFix64, auctionExtensionOnLateBid: UFix64, minimumBidIncrement: UFix64, auctionValidUntil: UFix64?) {\n    prepare(account: AuthAccount) {\n\n        let tenant=FindMarket.getTenant(marketplace)\n        let saleItems= account.borrow\u003c\u0026FindMarketAuctionSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e())!)!\n\n        // Get supported NFT and FT Information from Registries from input alias\n        let nft = NFTRegistry.getNFTInfo(nftAliasOrIdentifier) ?? panic(\"This NFT is not supported by the Find Market yet\")\n        let ft = FTRegistry.getFTInfo(ftAliasOrIdentifier) ?? panic(\"This FT is not supported by the Find Market yet\")\n\n        let providerCap = account.getCapability\u003c\u0026{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e(nft.providerPath)\n\n        /* Ben : Question -\u003e Either client will have to provide the path here or agree that we set it up for the user */\n        if !providerCap.check() {\n                account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                    nft.providerPath,\n                    target: nft.storagePath\n            )\n        }\n        \n        let pointer= FindViews.AuthNFTPointer(cap: providerCap, id: id)\n        // Ben : panic on some unreasonable inputs in trxn \n        assert(minimumBidIncrement \u003e 0.0, message:\"Minimum bid increment should be larger than 0.\")\n        assert((auctionReservePrice - auctionReservePrice) % minimumBidIncrement == 0.0, message:\"Acution ReservePrice should be in step of minimum bid increment.\" )\n        assert(auctionDuration \u003e 0.0, message: \"Auction Duration should be greater than 0.\")\n        assert(auctionExtensionOnLateBid \u003e 0.0, message: \"Auction Duration should be greater than 0.\")\n        \n        saleItems.listForAuction(pointer: pointer, vaultType: ft.type, auctionStartPrice: price, auctionReservePrice: auctionReservePrice, auctionDuration: auctionDuration, auctionExtensionOnLateBid: auctionExtensionOnLateBid, minimumBidIncrement: minimumBidIncrement, auctionValidUntil: auctionValidUntil, saleItemExtraField: {})\n\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "nftAliasOrIdentifier",
                     "id",
                     "ftAliasOrIdentifier",
                     "price",
                     "auctionReservePrice",
                     "auctionDuration",
                     "auctionExtensionOnLateBid",
                     "minimumBidIncrement",
                     "auctionValidUntil"
                  ],
                  "parameters": {
                     "auctionDuration": "UFix64",
                     "auctionExtensionOnLateBid": "UFix64",
                     "auctionReservePrice": "UFix64",
                     "auctionValidUntil": "UFix64?",
                     "ftAliasOrIdentifier": "String",
                     "id": "UInt64",
                     "marketplace": "Address",
                     "minimumBidIncrement": "UFix64",
                     "nftAliasOrIdentifier": "String",
                     "price": "UFix64"
                  }
               }
            },
            "listNFTForSale": {
               "code": "import FindMarket from 0x39937dba71a38820\nimport FindMarketSale from 0x39937dba71a38820\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FindViews from 0x39937dba71a38820\nimport NFTRegistry from 0x39937dba71a38820\nimport FTRegistry from 0x39937dba71a38820\n\ntransaction(marketplace:Address, nftAliasOrIdentifier: String, id: UInt64, ftAliasOrIdentifier: String, directSellPrice:UFix64, validUntil: UFix64?) {\n    prepare(account: AuthAccount) {\n        // Get the salesItemRef from tenant\n        let tenant=FindMarket.getTenant(marketplace)\n        let saleItems= account.borrow\u003c\u0026FindMarketSale.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketSale.SaleItemCollection\u003e()))!\n\n        // Get supported NFT and FT Information from Registries from input alias\n        let nft = NFTRegistry.getNFTInfo(nftAliasOrIdentifier) ?? panic(\"This NFT is not supported by the Find Market yet\")\n        let ft = FTRegistry.getFTInfo(ftAliasOrIdentifier) ?? panic(\"This FT is not supported by the Find Market yet\")\n\n        let providerCap=account.getCapability\u003c\u0026{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e(nft.providerPath)\n\n        /* Ben : Question -\u003e Either client will have to provide the path here or agree that we set it up for the user */\n        if !providerCap.check() {\n                account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                    nft.providerPath,\n                    target: nft.storagePath\n            )\n        }\n\n        let pointer= FindViews.AuthNFTPointer(cap: providerCap, id: id)\n        saleItems.listForSale(pointer: pointer, vaultType: ft.type, directSellPrice: directSellPrice, validUntil: validUntil, extraField: {})\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "nftAliasOrIdentifier",
                     "id",
                     "ftAliasOrIdentifier",
                     "directSellPrice",
                     "validUntil"
                  ],
                  "parameters": {
                     "directSellPrice": "UFix64",
                     "ftAliasOrIdentifier": "String",
                     "id": "UInt64",
                     "marketplace": "Address",
                     "nftAliasOrIdentifier": "String",
                     "validUntil": "UFix64?"
                  }
               }
            },
            "listNameForAuction": {
               "code": "import FIND from 0x39937dba71a38820\n\ntransaction(name: String, auctionStartPrice: UFix64, auctionReservePrice: UFix64, auctionDuration: UFix64, auctionExtensionOnLateBid: UFix64) {\n    prepare(acct: AuthAccount) {\n        let finLeases= acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n        finLeases.listForAuction(name: name, auctionStartPrice: auctionStartPrice, auctionReservePrice: auctionReservePrice, auctionDuration: auctionDuration,  auctionExtensionOnLateBid: auctionExtensionOnLateBid)\n\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "auctionStartPrice",
                     "auctionReservePrice",
                     "auctionDuration",
                     "auctionExtensionOnLateBid"
                  ],
                  "parameters": {
                     "auctionDuration": "UFix64",
                     "auctionExtensionOnLateBid": "UFix64",
                     "auctionReservePrice": "UFix64",
                     "auctionStartPrice": "UFix64",
                     "name": "String"
                  }
               }
            },
            "listNameForSale": {
               "code": "import FIND from 0x39937dba71a38820\n\ntransaction(name: String, directSellPrice:UFix64) {\n    prepare(acct: AuthAccount) {\n        let finLeases= acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n        finLeases.listForSale(name: name,  directSellPrice:directSellPrice)\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "directSellPrice"
                  ],
                  "parameters": {
                     "directSellPrice": "UFix64",
                     "name": "String"
                  }
               }
            },
            "moveNameTO": {
               "code": "import Profile from 0x39937dba71a38820\nimport FIND from 0x39937dba71a38820\n\n\ntransaction(name: String, receiver:String) {\n\n\n    let receiverAddress:Address?\n    let sender : \u0026FIND.LeaseCollection\n\n    prepare(acct: AuthAccount) {\n        self.sender= acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n        self.receiverAddress=FIND.resolve(receiver)\n    } \n\n    pre{\n        self.receiverAddress != nil : \"The input pass in is not a valid name or address. Input : \".concat(receiver)\n    }\n\n    execute {\n        let receiver=getAccount(self.receiverAddress!)\n        let receiverLease = receiver.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        let receiverProfile = receiver.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\n        if !receiverLease.check() || !receiverProfile.check() {\n            panic(\"Not a valid FIND user\")\n        }\n\n        self.sender.move(name:name, profile:receiverProfile, to: receiverLease)\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "receiver"
                  ],
                  "parameters": {
                     "name": "String",
                     "receiver": "String"
                  }
               }
            },
            "register": {
               "code": "import FungibleToken from 0x9a0766d93b6608b7\nimport FUSD from 0xe223d8a629e49c68\nimport FiatToken from 0xa983fecbed621163\nimport FlowToken from 0x7e60df042a9c0868\nimport Profile from 0x39937dba71a38820\nimport FIND from 0x39937dba71a38820\nimport FindMarketSale from 0x39937dba71a38820\nimport FindMarketDirectOfferEscrow from 0x39937dba71a38820\nimport FindMarketDirectOfferSoft from 0x39937dba71a38820\nimport FindMarketAuctionEscrow from 0x39937dba71a38820\nimport FindMarketAuctionSoft from 0x39937dba71a38820\nimport FindMarket from 0x39937dba71a38820\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport Dandy from 0x39937dba71a38820\n\ntransaction(name: String, amount: UFix64) {\n    prepare(acct: AuthAccount) {\n\n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n        //SYNC with register\n        //Add exising FUSD or create a new one and add it\n        let fusdReceiver = acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n        if !fusdReceiver.check() {\n            let fusd \u003c- FUSD.createEmptyVault()\n            acct.save(\u003c- fusd, to: /storage/fusdVault)\n            acct.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n            acct.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n        }\n\n        let usdcCap = acct.getCapability\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e(FiatToken.VaultReceiverPubPath)\n        if !usdcCap.check() {\n                acct.save( \u003c-FiatToken.createEmptyVault(), to: FiatToken.VaultStoragePath)\n        acct.link\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e( FiatToken.VaultReceiverPubPath, target: FiatToken.VaultStoragePath)\n        acct.link\u003c\u0026FiatToken.Vault{FiatToken.ResourceId}\u003e( FiatToken.VaultUUIDPubPath, target: FiatToken.VaultStoragePath)\n                acct.link\u003c\u0026FiatToken.Vault{FungibleToken.Balance}\u003e( FiatToken.VaultBalancePubPath, target:FiatToken.VaultStoragePath)\n        }\n\n        let leaseCollection = acct.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            acct.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            acct.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = acct.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            acct.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            acct.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let dandyCap= acct.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            acct.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            acct.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            acct.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n      let dandyCapPub= acct.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCapPub.check() {\n            acct.unlink(Dandy.CollectionPublicPath)\n            acct.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        let dandyCapPrivate= acct.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPrivatePath)\n        if !dandyCapPub.check() {\n            acct.unlink(Dandy.CollectionPrivatePath)\n            acct.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        var created=false\n        let profileCap = acct.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            acct.save(\u003c-profile, to: Profile.storagePath)\n            acct.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            acct.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=acct.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n        if !profile.hasWallet(\"Flow\") {\n            let flowWallet=Profile.Wallet( name:\"Flow\", receiver:acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:acct.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), names: [\"flow\"])\n    \n            profile.addWallet(flowWallet)\n        }\n        if !profile.hasWallet(\"FUSD\") {\n            profile.addWallet(Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:acct.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), names: [\"fusd\", \"stablecoin\"]))\n        }\n\n        if !profile.hasWallet(\"USDC\") {\n            profile.addWallet(Profile.Wallet( name:\"USDC\", receiver:usdcCap, balance:acct.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(FiatToken.VaultBalancePubPath), accept: Type\u003c@FiatToken.Vault\u003e(), names: [\"usdc\", \"stablecoin\"]))\n        }\n\n         //If find name not set and we have a profile set it.\n        if profile.getFindName() == \"\" {\n            profile.setFindName(name)\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else {\n            profile.emitUpdatedEvent()\n        }\n\n        let receiverCap=acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let tenantCapability= FindMarket.getTenantCapability(FindMarket.getFindTenantAddress())!\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= acct.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            acct.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            acct.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        let doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        let doeSalePublicPath=FindMarket.getPublicPath(doeSaleType, name: tenant.name)\n        let doeSaleStoragePath= FindMarket.getStoragePath(doeSaleType, name:tenant.name)\n        let doeSaleCap= acct.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n        if !doeSaleCap.check() {\n            acct.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n            acct.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n        }\n\n        let doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        let doeBidPublicPath=FindMarket.getPublicPath(doeBidType, name: tenant.name)\n        let doeBidStoragePath= FindMarket.getStoragePath(doeBidType, name:tenant.name)\n        let doeBidCap= acct.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n        if !doeBidCap.check() {\n            acct.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n            acct.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n        }\n\n        /// auctions that escrow ft\n        let aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        let aeSalePublicPath=FindMarket.getPublicPath(aeSaleType, name: tenant.name)\n        let aeSaleStoragePath= FindMarket.getStoragePath(aeSaleType, name:tenant.name)\n        let aeSaleCap= acct.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n        if !aeSaleCap.check() {\n            acct.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n            acct.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n        }\n\n        let dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\n        let dosSalePublicPath=FindMarket.getPublicPath(dosSaleType, name: tenant.name)\n        let dosSaleStoragePath= FindMarket.getStoragePath(dosSaleType, name:tenant.name)\n\n        let dosSaleCap= acct.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n        if !dosSaleCap.check() {\n            acct.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n            acct.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n        }\n\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= acct.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n        if !dosBidCap.check() {\n            acct.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            acct.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n        }\n\n        let aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\n        let aeBidPublicPath=FindMarket.getPublicPath(aeBidType, name: tenant.name)\n        let aeBidStoragePath= FindMarket.getStoragePath(aeBidType, name:tenant.name)\n        let aeBidCap= acct.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n        if !aeBidCap.check() {\n            acct.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n            acct.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n        }\n\n     /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= acct.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            acct.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            acct.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n        }\n\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= acct.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n        if !asBidCap.check() {\n            acct.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            acct.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n        }\n        //SYNC with register\n\n\n\n        let price=FIND.calculateCost(name)\n        if price != amount {\n            panic(\"Calculated cost does not match expected cost\")\n        }\n        log(\"The cost for registering this name is \".concat(price.toString()))\n\n        let vaultRef = acct.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault) ?? panic(\"Could not borrow reference to the fusdVault!\")\n\n        let payVault \u003c- vaultRef.withdraw(amount: price) as! @FUSD.Vault\n\n        let leases=acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from: FIND.LeaseStoragePath)!\n        leases.register(name: name, vault: \u003c- payVault)\n\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "name": "String"
                  }
               }
            },
            "registerGift": {
               "code": "import FUSD from 0xe223d8a629e49c68\nimport Profile from 0x39937dba71a38820\nimport FIND from 0x39937dba71a38820\n\ntransaction(name: String, amount: UFix64, recipient: String) {\n    prepare(acct: AuthAccount) {\n\n        let resolveAddress = FIND.resolve(recipient)\n        if resolveAddress == nil {panic(\"The input pass in is not a valid name or address. Input : \".concat(recipient))}\n        let address = resolveAddress!\n        let price=FIND.calculateCost(name)\n        if price != amount {\n            panic(\"Calculated cost does not match expected cost\")\n        }\n        log(\"The cost for registering this name is \".concat(price.toString()))\n\n        let vaultRef = acct.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault) ?? panic(\"Could not borrow reference to the fusdVault!\")\n        let payVault \u003c- vaultRef.withdraw(amount: price) as! @FUSD.Vault\n\n        let leases=acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from: FIND.LeaseStoragePath)!\n        leases.register(name: name, vault: \u003c- payVault)\n\n        let receiver = getAccount(address)\n        let receiverLease = receiver.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        let receiverProfile = receiver.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !receiverLease.check() {\n            panic(\"Receiver is not a find user\")\n        }\n        leases.move(name: name, profile: receiverProfile, to: receiverLease)\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "amount",
                     "recipient"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "name": "String",
                     "recipient": "String"
                  }
               }
            },
            "rejectNameDirectOffer": {
               "code": "import FIND from 0x39937dba71a38820\n\ntransaction(names: [String]) {\n    prepare(account: AuthAccount) {\n\n        let finLeases= account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n        for name in names {\n            finLeases.cancel(name)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "names"
                  ],
                  "parameters": {
                     "names": "[String]"
                  }
               }
            },
            "removeCurratedCollection": {
               "code": "transaction(name: String) {\n    prepare(account: AuthAccount) {\n\n        let path=/storage/FindCuratedCollections\n        let publicPath=/public/FindCuratedCollections\n\n        var collections : {String: [String]} = {}\n        if account.borrow\u003c\u0026{String: [String]}\u003e(from:path) != nil {\n             collections=account.load\u003c{String: [String]}\u003e(from:path)!\n        }\n        collections.remove(key: name)\n        account.save(collections, to: path)\n        let link = account.getCapability\u003c\u0026{String: [String]}\u003e(publicPath)\n        if !link.check() {\n            account.link\u003c\u0026{String: [String]}\u003e( publicPath, target: path)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "removeMarketOption": {
               "code": "import FindMarket from 0x39937dba71a38820\n\n\n\n\ntransaction(saleItemName: String){\n    prepare(account: AuthAccount){\n        let path = FindMarket.TenantClientStoragePath\n        let tenantRef = account.borrow\u003c\u0026FindMarket.TenantClient\u003e(from: path) ?? panic(\"Cannot borrow Reference.\")\n\n        tenantRef.removeMarketOption(name: saleItemName)\n    }\n}",
               "spec": {
                  "order": [
                     "saleItemName"
                  ],
                  "parameters": {
                     "saleItemName": "String"
                  }
               }
            },
            "removeRelatedAccount": {
               "code": "import RelatedAccounts from 0x39937dba71a38820\n\n\ntransaction(name: String){\n    prepare(account: AuthAccount) {\n\n        let cap = account.getCapability\u003c\u0026RelatedAccounts.Accounts{RelatedAccounts.Public}\u003e(RelatedAccounts.publicPath)\n        if !cap.check() {\n            let relatedAccounts \u003c- RelatedAccounts.createEmptyAccounts()\n            account.save(\u003c- relatedAccounts, to: RelatedAccounts.storagePath)\n            account.link\u003c\u0026RelatedAccounts.Accounts{RelatedAccounts.Public}\u003e(RelatedAccounts.publicPath, target: RelatedAccounts.storagePath)\n        }\n\n        let relatedAccounts =account.borrow\u003c\u0026RelatedAccounts.Accounts\u003e(from:RelatedAccounts.storagePath)!\n        relatedAccounts.deleteAccount(name: name)\n    }\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "removeTenantRule": {
               "code": "import FindMarket from 0x39937dba71a38820\n\ntransaction(optionName: String, tenantRuleName: String){\n    prepare(account: AuthAccount){\n        let path = FindMarket.TenantClientStoragePath\n        let tenantRef = account.borrow\u003c\u0026FindMarket.TenantClient\u003e(from: path) ?? panic(\"Cannot borrow Reference.\")\n\n        tenantRef.removeTenantRule(optionName: optionName, tenantRuleName: tenantRuleName)\n    }\n}",
               "spec": {
                  "order": [
                     "optionName",
                     "tenantRuleName"
                  ],
                  "parameters": {
                     "optionName": "String",
                     "tenantRuleName": "String"
                  }
               }
            },
            "renewName": {
               "code": "import FUSD from 0xe223d8a629e49c68\nimport FIND from 0x39937dba71a38820\n\ntransaction(name: String, amount: UFix64) {\n    prepare(acct: AuthAccount) {\n\n        let price=FIND.calculateCost(name)\n        if amount != price {\n            panic(\"expected renew cost is not the same as calculated renew cost\")\n        }\n        let vaultRef = acct.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault) ?? panic(\"Could not borrow reference to the fusdVault!\")\n        let payVault \u003c- vaultRef.withdraw(amount: price) as! @FUSD.Vault\n\n        let finLeases= acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n        let finToken= finLeases.borrow(name)\n        finToken.extendLease(\u003c- payVault)\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "name": "String"
                  }
               }
            },
            "retractOfferMarketDirectOfferEscrowed": {
               "code": "import FindMarket from 0x39937dba71a38820\nimport FindMarketDirectOfferEscrow from 0x39937dba71a38820\n\ntransaction(marketplace:Address, id: UInt64) {\n    let bidsReference: \u0026FindMarketDirectOfferEscrow.MarketBidCollection\n\n    prepare(account: AuthAccount) {\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e())\n        self.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection\u003e(from: storagePath) ?? panic(\"This account does not have a bid collection\")\n    }\n\n    execute {\n        self.bidsReference.cancelBid(id)\n    }\n\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "retractOfferMarketDirectOfferSoft": {
               "code": "import FindMarket from 0x39937dba71a38820\nimport FindMarketDirectOfferSoft from 0x39937dba71a38820\n\ntransaction(marketplace:Address, id: UInt64) {\n    let bidsReference: \u0026FindMarketDirectOfferSoft.MarketBidCollection\n\n    prepare(account: AuthAccount) {\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n        self.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"Bid resource does not exist\")\n    }\n\n    execute {\n        self.bidsReference.cancelBid(id)\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "sendCharity": {
               "code": "import NonFungibleToken from 0x631e88ae7f1d7c20\nimport CharityNFT from 0x39937dba71a38820\n\n//mint an art and add it to a users collection\ntransaction(\n    id: UInt64,\n    recipient: Address\n) {\n    let receiverCap: Capability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e\n    let charityCollection: \u0026NonFungibleToken.Collection\n\n    prepare(account: AuthAccount) {\n        self.charityCollection =account.borrow\u003c\u0026NonFungibleToken.Collection\u003e(from: CharityNFT.CollectionStoragePath)!\n        self.receiverCap= getAccount(recipient).getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath)\n    }\n\n    execute {\n        let nft \u003c- self.charityCollection.withdraw(withdrawID: id)\n        self.receiverCap.borrow()!.deposit(token: \u003c- nft)\n    }\n}",
               "spec": {
                  "order": [
                     "id",
                     "recipient"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "recipient": "Address"
                  }
               }
            },
            "sendDandy": {
               "code": "import FIND from 0x39937dba71a38820\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport Dandy from 0x39937dba71a38820\n\ntransaction(user: String, id: UInt64) {\n    prepare(account: AuthAccount) {\n        let address = FIND.resolve(user) ?? panic(\"Cannot find user with this name / address\")\n        let cap = getAccount(address).getCapability\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        let ref = cap.borrow() ?? panic(\"Cannot borrow reference to receiver Collection.\")\n\n        let senderRef = account.borrow\u003c\u0026Dandy.Collection\u003e(from: Dandy.CollectionStoragePath) ?? panic(\"Cannot borrow reference to sender Collection.\")\n        ref.deposit(token: \u003c- senderRef.withdraw(withdrawID: id))\n    }\n}",
               "spec": {
                  "order": [
                     "user",
                     "id"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "user": "String"
                  }
               }
            },
            "sendFT": {
               "code": "import FungibleToken from 0x9a0766d93b6608b7\nimport Sender from 0x39937dba71a38820\nimport FIND from 0x39937dba71a38820\nimport FTRegistry from 0x39937dba71a38820\n\n\ntransaction(name: String, amount: UFix64, ftAliasOrIdentifier: String, tag: String, message:String) {\n\n    prepare(account: AuthAccount) {\n\n        let ft = FTRegistry.getFTInfo(ftAliasOrIdentifier) ?? panic(\"This FT is not supported by the Find Market yet\")\n        let walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n\n        if account.borrow\u003c\u0026Sender.Token\u003e(from: Sender.storagePath) == nil {\n            account.save(\u003c- Sender.create(), to: Sender.storagePath)\n        }\n\n        let token =account.borrow\u003c\u0026Sender.Token\u003e(from: Sender.storagePath)!\n        let vault \u003c- walletReference.withdraw(amount: amount)\n        FIND.depositWithTagAndMessage(to: name, message: message, tag: tag, vault: \u003c- vault, from: token)\n    }\n\n}",
               "spec": {
                  "order": [
                     "name",
                     "amount",
                     "ftAliasOrIdentifier",
                     "tag",
                     "message"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "ftAliasOrIdentifier": "String",
                     "message": "String",
                     "name": "String",
                     "tag": "String"
                  }
               }
            },
            "setMainName": {
               "code": "import Profile from 0x39937dba71a38820\nimport FIND from 0x39937dba71a38820\n\n\ntransaction(name: String) {\n    prepare(acct: AuthAccount) {\n\n        let leaseCollectionOwner = acct.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\n        if !leaseCollectionOwner.check() {\n            panic(\"Not a find user\")\n        }\n\n        if leaseCollectionOwner.borrow()!.getLease(name) == nil {\n            panic(\"You do not own this lease so you cannot set it as main name\")\n        }\n\n        let profile =acct.borrow\u003c\u0026Profile.User\u003e(from:Profile.storagePath)!\n        profile.setFindName(name)\n    }\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "setMarketOptionFlowDandy": {
               "code": "import FindMarket from 0x39937dba71a38820\nimport FlowToken from 0x7e60df042a9c0868\nimport Dandy from 0x39937dba71a38820\n\ntransaction(){\n    prepare(account: AuthAccount){\n        let path = FindMarket.TenantClientStoragePath\n        let tenantRef = account.borrow\u003c\u0026FindMarket.TenantClient\u003e(from: path) ?? panic(\"Cannot borrow Reference.\")\n\n        tenantRef.setMarketOption(name:\"FlowDandy\", cut: nil, rules:[\n            FindMarket.TenantRule(name:\"Flow\", types:[Type\u003c@FlowToken.Vault\u003e()], ruleType: \"ft\", allow: true),\n            FindMarket.TenantRule(name:\"Dandy\", types:[ Type\u003c@Dandy.NFT\u003e()],\n                        ruleType: \"nft\", allow: true)\n            ]\n        )\n    }\n}",
               "spec": null
            },
            "setPrivateMode": {
               "code": "import Profile from 0x39937dba71a38820\n\ntransaction(mode: Bool) {\n    prepare(acct: AuthAccount) {\n        let profile =acct.borrow\u003c\u0026Profile.User\u003e(from:Profile.storagePath)!\n        profile.setPrivateMode(mode)\n        profile.emitUpdatedEvent()\n    }\n}",
               "spec": {
                  "order": [
                     "mode"
                  ],
                  "parameters": {
                     "mode": "Bool"
                  }
               }
            },
            "setProfile": {
               "code": "import Profile from 0x39937dba71a38820\n\ntransaction(avatar: String) {\n    prepare(acct: AuthAccount) {\n        let profile =acct.borrow\u003c\u0026Profile.User\u003e(from:Profile.storagePath)!\n        profile.setAvatar(avatar)\n\n        profile.emitUpdatedEvent()\n    }\n}",
               "spec": {
                  "order": [
                     "avatar"
                  ],
                  "parameters": {
                     "avatar": "String"
                  }
               }
            },
            "setRelatedAccount": {
               "code": "import RelatedAccounts from 0x39937dba71a38820\nimport FIND from 0x39937dba71a38820\n\ntransaction(name: String, target: String) {\n    prepare(account: AuthAccount) {\n\n        let resolveAddress = FIND.resolve(target)\n        if resolveAddress == nil {panic(\"The input pass in is not a valid name or address. Input : \".concat(target))}\n        let address = resolveAddress!\n        let cap = account.getCapability\u003c\u0026RelatedAccounts.Accounts{RelatedAccounts.Public}\u003e(RelatedAccounts.publicPath)\n        if !cap.check() {\n            let relatedAccounts \u003c- RelatedAccounts.createEmptyAccounts()\n            account.save(\u003c- relatedAccounts, to: RelatedAccounts.storagePath)\n            account.link\u003c\u0026RelatedAccounts.Accounts{RelatedAccounts.Public}\u003e(RelatedAccounts.publicPath, target: RelatedAccounts.storagePath)\n        }\n\n        let relatedAccounts =account.borrow\u003c\u0026RelatedAccounts.Accounts\u003e(from:RelatedAccounts.storagePath)!\n        relatedAccounts.setFlowAccount(name: name, address: address)\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "target"
                  ],
                  "parameters": {
                     "name": "String",
                     "target": "String"
                  }
               }
            },
            "setSellDandyRules": {
               "code": "import FindMarket from 0x39937dba71a38820\nimport FlowToken from 0x7e60df042a9c0868\nimport FUSD from 0xe223d8a629e49c68\nimport Dandy from 0x39937dba71a38820\n\ntransaction(){\n    prepare(account: AuthAccount){\n        let path = FindMarket.TenantClientStoragePath\n        let tenantRef = account.borrow\u003c\u0026FindMarket.TenantClient\u003e(from: path) ?? panic(\"Cannot borrow Reference.\")\n\n        tenantRef.setMarketOption(name:\"FUSDDandy\", cut: nil, rules:[\n            FindMarket.TenantRule(name:\"FUSD\", types:[Type\u003c@FUSD.Vault\u003e()], ruleType: \"ft\", allow: true),\n            FindMarket.TenantRule(name:\"Dandy\", types:[ Type\u003c@Dandy.NFT\u003e()], ruleType: \"nft\", allow: true)\n            ]\n        )\n\n        tenantRef.setMarketOption(name:\"FlowDandy\", cut: nil, rules:[\n            FindMarket.TenantRule(name:\"Flow\", types:[Type\u003c@FlowToken.Vault\u003e()], ruleType: \"ft\", allow: true),\n            FindMarket.TenantRule(name:\"Dandy\", types:[ Type\u003c@Dandy.NFT\u003e()], ruleType: \"nft\", allow: true)\n            ]\n        )\n\n    }\n}",
               "spec": null
            },
            "setTenantRuleFUSD": {
               "code": "import FindMarket from 0x39937dba71a38820\nimport FUSD from 0xe223d8a629e49c68\n\ntransaction(optionName: String){\n    prepare(account: AuthAccount){\n        let path = FindMarket.TenantClientStoragePath\n        let tenantRef = account.borrow\u003c\u0026FindMarket.TenantClient\u003e(from: path) ?? panic(\"Cannot borrow Reference.\")\n\n        tenantRef.setTenantRule(optionName: optionName, tenantRule:\n            FindMarket.TenantRule(name:\"FUSD\", types:[Type\u003c@FUSD.Vault\u003e()], ruleType: \"ft\", allow: true)\n        )\n    }\n}",
               "spec": {
                  "order": [
                     "optionName"
                  ],
                  "parameters": {
                     "optionName": "String"
                  }
               }
            },
            "startNameAuction": {
               "code": "import FIND from 0x39937dba71a38820\n\ntransaction(name: String) {\n    prepare(account: AuthAccount) {\n\n        let finLeases= account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n        finLeases.startAuction(name)\n\n    }\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "storeCuratedCollections": {
               "code": "transaction(collections: {String :  [String]}) {\n    prepare(account: AuthAccount) {\n\n        let path=/storage/FindCuratedCollections\n        let publicPath=/public/FindCuratedCollections\n\n        if account.borrow\u003c\u0026{String: [String]}\u003e(from:path) != nil {\n             account.load\u003c{String: [String]}\u003e(from:path)\n        }\n        account.save(collections, to: path)\n\n        let link = account.getCapability\u003c\u0026{String: [String]}\u003e(publicPath)\n        if !link.check() {\n            account.link\u003c\u0026{String: [String]}\u003e( publicPath, target: path)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "collections"
                  ],
                  "parameters": {
                     "collections": "{String: [String]}"
                  }
               }
            },
            "testAlterMarketOption": {
               "code": "import FindMarket from 0x39937dba71a38820\n\ntransaction(market: String , action: String ){\n    prepare(account: AuthAccount){\n        let path = FindMarket.TenantClientStoragePath\n        let tenantRef = account.borrow\u003c\u0026FindMarket.TenantClient\u003e(from: path) ?? panic(\"Cannot borrow Reference.\")\n\n\n        switch action {\n            case \"enable\" :\n                tenantRef.enableMarketOption(\"FlowDandy\".concat(market))\n\n            case \"deprecate\" :\n                tenantRef.deprecateMarketOption(\"FlowDandy\".concat(market))\n\n            case \"stop\" :\n                tenantRef.stopMarketOption(\"FlowDandy\".concat(market))\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "market",
                     "action"
                  ],
                  "parameters": {
                     "action": "String",
                     "market": "String"
                  }
               }
            },
            "testBlockItem": {
               "code": "import Admin from 0x39937dba71a38820\nimport FindMarket from 0x39937dba71a38820\nimport Dandy from 0x39937dba71a38820\n\ntransaction(tenant: Address){\n    prepare(account: AuthAccount){\n        let adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n        let rules = [\n            FindMarket.TenantRule(name:\"nft\", types:[Type\u003c@Dandy.NFT\u003e()], ruleType:\"nft\", allow:false) \n        ]\n        let item = FindMarket.TenantSaleItem(name:\"Block Dandy\", cut:nil, rules:rules, status:\"active\")\n        adminRef.addFindBlockItem(tenant: tenant, item: item)\n    }\n}",
               "spec": {
                  "order": [
                     "tenant"
                  ],
                  "parameters": {
                     "tenant": "Address"
                  }
               }
            },
            "testBlockItemByListingType": {
               "code": "import Admin from 0x39937dba71a38820\nimport FindMarket from 0x39937dba71a38820\nimport Dandy from 0x39937dba71a38820\n\ntransaction(tenant: Address){\n    prepare(account: AuthAccount){\n        let adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n        let rules = [\n            FindMarket.TenantRule(name:\"nft\", types:[Type\u003c@Dandy.NFT\u003e()], ruleType:\"nft\", allow:false) ,\n            FindMarket.TenantRule(name:\"listing\", types:FindMarket.getSaleItemTypes(), ruleType:\"listing\", allow:false) \n        ]\n        let item = FindMarket.TenantSaleItem(name:\"Block Dandy\", cut:nil, rules:rules, status:\"active\")\n        adminRef.addFindBlockItem(tenant: tenant, item: item)\n    }\n}",
               "spec": {
                  "order": [
                     "tenant"
                  ],
                  "parameters": {
                     "tenant": "Address"
                  }
               }
            },
            "testClock": {
               "code": "import Admin from 0x39937dba71a38820\n\ntransaction(clock: UFix64) {\n    prepare(account: AuthAccount) {\n\n        let adminClient=account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath)!\n        adminClient.advanceClock(clock)\n\n    }\n}",
               "spec": {
                  "order": [
                     "clock"
                  ],
                  "parameters": {
                     "clock": "UFix64"
                  }
               }
            },
            "testDestroyDandies": {
               "code": "import Dandy from 0x39937dba71a38820\n\n\ntransaction(ids: [UInt64]) {\n    prepare(account: AuthAccount) {\n\n        let dandyRef= account.borrow\u003c\u0026Dandy.Collection\u003e(from: Dandy.CollectionStoragePath) ?? panic(\"Cannot borrow reference to Dandy Collection\")\n        for id in ids {\n            destroy dandyRef.withdraw(withdrawID: id)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "ids"
                  ],
                  "parameters": {
                     "ids": "[UInt64]"
                  }
               }
            },
            "testDestroyDandyCollection": {
               "code": "import Dandy from 0x39937dba71a38820\n\n\ntransaction() {\n    prepare(account: AuthAccount) {\n        destroy account.load\u003c@Dandy.Collection\u003e(from: Dandy.CollectionStoragePath)\n    }\n}",
               "spec": null
            },
            "testDestroyFUSDVault": {
               "code": "import FUSD from 0xe223d8a629e49c68\n\n\ntransaction() {\n    prepare(account: AuthAccount) {\n        destroy account.load\u003c@FUSD.Vault\u003e(from: /storage/fusdVault) ?? panic(\"Cannot load flow token vault\")\n    }\n}",
               "spec": null
            },
            "testListStorefront": {
               "code": "import FungibleToken from 0x9a0766d93b6608b7\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport FlowToken from 0x7e60df042a9c0868\nimport Dandy from 0x39937dba71a38820\nimport NFTStorefront from 0x94b06cfca1d8a476\nimport MetadataViews from 0x631e88ae7f1d7c20\n\n\n\n//this has to be called after we have listed it somewhere else because of cap\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64) {\n    let flowReceiver: Capability\u003c\u0026FlowToken.Vault{FungibleToken.Receiver}\u003e\n    let exampleNFTProvider: Capability\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e\n    let storefront: \u0026NFTStorefront.Storefront\n\n    prepare(acct: AuthAccount) {\n\n             // If the account doesn't already have a Storefront\n        if acct.borrow\u003c\u0026NFTStorefront.Storefront\u003e(from: NFTStorefront.StorefrontStoragePath) == nil {\n\n            // Create a new empty .Storefront\n            let storefront \u003c- NFTStorefront.createStorefront() as @NFTStorefront.Storefront\n            \n            // save it to the account\n            acct.save(\u003c-storefront, to: NFTStorefront.StorefrontStoragePath)\n\n            // create a public capability for the .Storefront\n            acct.link\u003c\u0026NFTStorefront.Storefront{NFTStorefront.StorefrontPublic}\u003e(NFTStorefront.StorefrontPublicPath, target: NFTStorefront.StorefrontStoragePath)\n        }\n\n        // We need a provider capability, but one is not provided by default so we create one if needed.\n        let exampleNFTCollectionProviderPrivatePath = /private/exampleNFTCollectionProviderForNFTStorefront\n\n        self.flowReceiver = acct.getCapability\u003c\u0026FlowToken.Vault{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver)\n        assert(self.flowReceiver.borrow() != nil, message: \"Missing or mis-typed FlowToken receiver\")\n        self.exampleNFTProvider = acct.getCapability\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPrivatePath)\n        assert(self.exampleNFTProvider.borrow() != nil, message: \"Missing or mis-typed ExampleNFT.Collection provider\")\n\n        self.storefront = acct.borrow\u003c\u0026NFTStorefront.Storefront\u003e(from: NFTStorefront.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n    }\n\n    execute {\n        let saleCut = NFTStorefront.SaleCut(\n            receiver: self.flowReceiver,\n            amount: saleItemPrice\n        )\n        self.storefront.createListing(\n            nftProviderCapability: self.exampleNFTProvider,\n            nftType: Type\u003c@Dandy.NFT\u003e(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type\u003c@FlowToken.Vault\u003e(),\n            saleCuts: [saleCut]\n        )\n    }\n}",
               "spec": {
                  "order": [
                     "saleItemID",
                     "saleItemPrice"
                  ],
                  "parameters": {
                     "saleItemID": "UInt64",
                     "saleItemPrice": "UFix64"
                  }
               }
            },
            "testMintDandyTO": {
               "code": "import FIND from 0x39937dba71a38820\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport FungibleToken from 0x9a0766d93b6608b7\nimport Dandy from 0x39937dba71a38820\nimport Profile from 0x39937dba71a38820\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FindViews from 0x39937dba71a38820\n\ntransaction(name: String, maxEdition:UInt64, artist:String, nftName:String, nftDescription:String, nftUrl:String, rarity: String, rarityNum:UFix64, to: Address) {\n    prepare(account: AuthAccount) {\n\n        let dancyReceiver =getAccount(to)\n        let dandyCap= dancyReceiver.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            panic(\"need dandy receicer\")\n        }\n\n        let finLeases= account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n\n        let creativeWork=\n        FindViews.CreativeWork(artist: artist, name: nftName, description: nftDescription, type:\"image\")\n\n        let httpFile=MetadataViews.HTTPFile(url:nftUrl)\n        let media=MetadataViews.Media(file: httpFile, mediaType: \"image/thumbnail\")\n\n        let rarity = FindViews.Rarity(rarity: rarityNum, rarityName:rarity, parts: {})\n\n        let receiver=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let minterRoyalty=MetadataViews.Royalties(cutInfos:[MetadataViews.Royalty(receiver: receiver, cut: 0.05, description: \"artist\")])\n\n        let tag=FindViews.Tag({\"NeoMotorCycleTag\":\"Tag1\"})\n        let scalar=FindViews.Scalar({\"Speed\" : 100.0})\n\n        let collection=dandyCap.borrow()!\n        var i:UInt64=1\n\n        while i \u003c= maxEdition {\n            let editioned= MetadataViews.Edition(name: \"nft\", number:i, max:maxEdition)\n            let description=creativeWork.description.concat( \" edition \").concat(i.toString()).concat( \" of \").concat(maxEdition.toString())\n            let schemas: [AnyStruct] = [ MetadataViews.Editions([editioned]), creativeWork, minterRoyalty, rarity, tag, scalar, FindViews.Medias([media])]\n            let token \u003c- finLeases.mintDandy(minter: name, \n              nftName: \"Neo Motorcycle \".concat(i.toString()).concat(\" of \").concat(maxEdition.toString()), \n                description: creativeWork.description,\n                thumbnail: media,\n                schemas: schemas, \n                externalUrlPrefix: \"https://find.xyz/collection/\".concat(name).concat(\"/dandy\"),\n                collectionDescription: \"Neo Collectibles FIND\",\n                collectionExternalURL: \"https://neomotorcycles.co.uk/index.html\",\n                collectionSquareImage: \"https://neomotorcycles.co.uk/assets/img/neo_motorcycle_side.webp\",\n                collectionBannerImage: \"https://neomotorcycles.co.uk/assets/img/neo-logo-web-dark.png?h=5a4d226197291f5f6370e79a1ee656a1\",\n            )\n\n            collection.deposit(token: \u003c- token)\n            i=i+1\n        }\n        i = 1\n\n        while i \u003c= maxEdition {\n            let editioned= MetadataViews.Edition(name: \"nft\", number:i, max:maxEdition)\n            let artCreativeWork=FindViews.CreativeWork(artist: artist, name: \"xtingle \", description: \"xtingle_NFT\", type:\"video/mp4\")\n            let description=artCreativeWork.description.concat( \" edition \").concat(i.toString()).concat( \" of \").concat(maxEdition.toString())\n            let artHttpFile=MetadataViews.HTTPFile(url:\"https://nft.blocto.app/xtingles/xBloctopus.mp4\")\n            let thumbnailFile=MetadataViews.HTTPFile(url:\"https://nft.blocto.app/xtingles/preview-xBloctopus.png\")\n            let artMedia=MetadataViews.Media(file: artHttpFile, mediaType: \"video\")\n            let thumbnailMedia=MetadataViews.Media(file: thumbnailFile, mediaType: \"image/thumbnail\")\n            let artTag=FindViews.Tag({\"xtingle Tag\":\"Tag1\"})\n            let artScalar=FindViews.Scalar({\"video length\" : 27.0})\n\n            let schemas: [AnyStruct] = [ MetadataViews.Editions([editioned]), artCreativeWork, artMedia, minterRoyalty, rarity, artTag, artScalar, FindViews.Medias([artMedia, thumbnailMedia])]\n            let token \u003c- finLeases.mintDandy(minter: name, \n              nftName: \"xtingle \".concat(i.toString()).concat(\" of \").concat(maxEdition.toString()), \n                description: artCreativeWork.description,\n                thumbnail: thumbnailMedia,\n                schemas: schemas, \n                externalUrlPrefix: \"https://nft.blocto.app/xtingles/\",\n                collectionDescription: \"xtingle FIND\",\n                collectionExternalURL: \"https://xtingles.com/\",\n                collectionSquareImage: \"https://xtingles-strapi-prod.s3.us-east-2.amazonaws.com/copy_of_upcoming_drops_db41fbf287.png\",\n                collectionBannerImage: \"https://xtingles.com/images/main-metaverse.png\",\n            )\n\n            collection.deposit(token: \u003c- token)\n            i=i+1\n        }\n        i = 1\n\n        while i \u003c= maxEdition {\n            let editioned= MetadataViews.Edition(name: \"nft\", number:i, max:maxEdition)\n            let artCreativeWork=FindViews.CreativeWork(artist: artist, name: \"flovatar \", description: \"flovatar_NFT\", type:\"image\")\n            let description=artCreativeWork.description.concat( \" edition \").concat(i.toString()).concat( \" of \").concat(maxEdition.toString())\n            let artHttpFile=MetadataViews.HTTPFile(url:\"https://flovatar.com/flovatars/1225/0x92ba5cba77fc1e87\")\n            let artMedia=MetadataViews.Media(file: artHttpFile, mediaType: \"image\")\n            let artTag=FindViews.Tag({\"flovatar Tag\":\"Tag1\"})\n            let artScalar=FindViews.Scalar({\"rarity score\" : 2.2})\n\n            let schemas: [AnyStruct] = [ MetadataViews.Editions([editioned]), artCreativeWork, artMedia, minterRoyalty, rarity, artTag, artScalar, FindViews.Medias([artMedia])]\n            let token \u003c- finLeases.mintDandy(minter: name, \n              nftName: \"flovatar \".concat(i.toString()).concat(\" of \").concat(maxEdition.toString()), \n                description: artCreativeWork.description,\n                thumbnail: artMedia,\n                schemas: schemas, \n                externalUrlPrefix: \"https://flovatar.com/flovatars/\",\n                collectionDescription: \"flovatar FIND\",\n                collectionExternalURL: \"https://flovatar.com/\",\n                collectionSquareImage: \"https://miro.medium.com/max/1080/1*nD3N5BvxvH-wgLW1KPizoA.png\",\n                collectionBannerImage: \"https://miro.medium.com/max/1400/1*WjFBUweGaThcTR-UOZ6TnA.gif\",\n            )\n\n            collection.deposit(token: \u003c- token)\n            i=i+1\n        }\n        i = 1\n\n        while i \u003c= maxEdition {\n            let editioned= MetadataViews.Edition(name: \"nft\", number:i, max:maxEdition)\n            let artCreativeWork=FindViews.CreativeWork(artist: artist, name: \"ufcstrike \", description: \"ufcstrike_NFT\", type:\"video/ipfs\")\n            let description=artCreativeWork.description.concat( \" edition \").concat(i.toString()).concat( \" of \").concat(maxEdition.toString())\n            let artHttpFile=MetadataViews.IPFSFile(cid:\"QmdDJUobzSaFfg8PwZZcCB3cPwbZ8pthRf1x6XiR9xwS3U\", path:nil)\n            let thumbnailHttpFile=MetadataViews.IPFSFile(cid:\"QmeDLGnYNyunkTjd23yx36sHviWyR9L2shHshjwe1qBCqR\", path:nil)\n            let artMedia=MetadataViews.Media(file: artHttpFile, mediaType: \"image/ipfs\")\n            let thumbnailMedia=MetadataViews.Media(file: thumbnailHttpFile, mediaType: \"image/thumbnail\")\n\n            let artTag=FindViews.Tag({\"ufcstrike Tag\":\"Tag1\"})\n            let artScalar=FindViews.Scalar({\"rank\" : 295.0})\n\n            let schemas: [AnyStruct] = [ MetadataViews.Editions([editioned]), artCreativeWork, artMedia, minterRoyalty, rarity, artTag, artScalar, FindViews.Medias([artMedia, thumbnailMedia])]\n            let token \u003c- finLeases.mintDandy(minter: name, \n              nftName: \"ufcstrike \".concat(i.toString()).concat(\" of \").concat(maxEdition.toString()), \n                description: artCreativeWork.description,\n                thumbnail: thumbnailMedia,\n                schemas: schemas, \n                externalUrlPrefix: \"https://giglabs.mypinata.cloud/ipfs/\",\n                collectionDescription: \"ufc strike FIND\",\n                collectionExternalURL: \"https://ufcstrike.com/\",\n                collectionSquareImage: \"https://assets.website-files.com/62605ca984796169418ca5dc/628e9bba372af61fcf967e03_round-one-standard-p-1080.png\",\n                collectionBannerImage: \"https://s3.us-east-2.amazonaws.com/giglabs.assets.ufc/4f166ac23e10bb510319e82fe9ed2c7d\",\n            )\n\n            collection.deposit(token: \u003c- token)\n            i=i+1\n        }\n\n    \n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "maxEdition",
                     "artist",
                     "nftName",
                     "nftDescription",
                     "nftUrl",
                     "rarity",
                     "rarityNum",
                     "to"
                  ],
                  "parameters": {
                     "artist": "String",
                     "maxEdition": "UInt64",
                     "name": "String",
                     "nftDescription": "String",
                     "nftName": "String",
                     "nftUrl": "String",
                     "rarity": "String",
                     "rarityNum": "UFix64",
                     "to": "Address"
                  }
               }
            },
            "testMintFlow": {
               "code": "import FungibleToken from 0x9a0766d93b6608b7\nimport FlowToken from 0x7e60df042a9c0868\n\ntransaction(recipient: Address, amount: UFix64) {\n    let tokenAdmin: \u0026FlowToken.Administrator\n    let tokenReceiver: \u0026{FungibleToken.Receiver}\n\n    prepare(signer: AuthAccount) {\n\n        self.tokenAdmin = signer\n            .borrow\u003c\u0026FlowToken.Administrator\u003e(from: /storage/flowTokenAdmin)\n            ?? panic(\"Signer is not the token admin\")\n\n        self.tokenReceiver = getAccount(recipient)\n            .getCapability(/public/flowTokenReceiver)\n            .borrow\u003c\u0026{FungibleToken.Receiver}\u003e()\n            ?? panic(\"Unable to borrow receiver reference\")\n    }\n\n    execute {\n        let minter \u003c- self.tokenAdmin.createNewMinter(allowedAmount: amount)\n        let mintedVault \u003c- minter.mintTokens(amount: amount)\n\n        self.tokenReceiver.deposit(from: \u003c-mintedVault)\n\n        destroy minter\n    }\n}",
               "spec": {
                  "order": [
                     "recipient",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "recipient": "Address"
                  }
               }
            },
            "testMintFusd": {
               "code": "import FungibleToken from 0x9a0766d93b6608b7\nimport FUSD from 0xe223d8a629e49c68\n\ntransaction(recipient: Address, amount: UFix64) {\n    let tokenAdmin: \u0026FUSD.Administrator\n    let tokenReceiver: \u0026{FungibleToken.Receiver}\n\n    prepare(signer: AuthAccount) {\n\n        self.tokenAdmin = signer\n        .borrow\u003c\u0026FUSD.Administrator\u003e(from: /storage/fusdAdmin)\n        ?? panic(\"Signer is not the token admin\")\n\n        self.tokenReceiver = getAccount(recipient)\n        .getCapability(/public/fusdReceiver)\n        .borrow\u003c\u0026{FungibleToken.Receiver}\u003e()\n        ?? panic(\"Unable to borrow receiver reference\")\n    }\n\n    execute {\n\n\n\n        let minter \u003c- self.tokenAdmin.createNewMinter()\n        let mintedVault \u003c- minter.mintTokens(amount: amount)\n\n        self.tokenReceiver.deposit(from: \u003c-mintedVault)\n\n        destroy minter\n    }\n}",
               "spec": {
                  "order": [
                     "recipient",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "recipient": "Address"
                  }
               }
            },
            "testMintUsdc": {
               "code": "import FungibleToken from 0x9a0766d93b6608b7\nimport FiatToken from 0xa983fecbed621163\n\ntransaction(recipient: Address, amount: UFix64) {\n    let tokenAdmin: \u0026FiatToken.Administrator\n    let tokenReceiver: \u0026{FungibleToken.Receiver}\n\n    prepare(signer: AuthAccount) {\n\n        self.tokenAdmin = signer.borrow\u003c\u0026FiatToken.Administrator\u003e(from: FiatToken.AdminStoragePath)\n        ?? panic(\"Signer is not the token admin\")\n\n        self.tokenReceiver = getAccount(recipient)\n        .getCapability(FiatToken.VaultReceiverPubPath)\n        .borrow\u003c\u0026{FungibleToken.Receiver}\u003e()\n        ?? panic(\"Unable to borrow receiver reference\")\n    }\n\n    execute {\n        let minter \u003c- self.tokenAdmin.createNewMinter()\n        let mintedVault \u003c- minter.mintTokens(amount: amount)\n\n        self.tokenReceiver.deposit(from: \u003c-mintedVault)\n\n        destroy minter\n    }\n}",
               "spec": {
                  "order": [
                     "recipient",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "recipient": "Address"
                  }
               }
            },
            "testSetResidualAddress": {
               "code": "import Admin from 0x39937dba71a38820\n\ntransaction(address: Address) {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n        \n    }\n\n    execute{\n        self.adminRef.setResidualAddress(address)\n    }\n}",
               "spec": {
                  "order": [
                     "address"
                  ],
                  "parameters": {
                     "address": "Address"
                  }
               }
            },
            "testSetSellNeoTestnetRules": {
               "code": "import FindMarket from 0x39937dba71a38820\nimport Admin from 0x39937dba71a38820\nimport FlowToken from 0x7e60df042a9c0868\nimport NeoVoucher from 0xd6b39e5b5b367aad\n\n\ntransaction(tenant: Address){\n    prepare(account: AuthAccount){\n        let adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n\n        let saleItem = FindMarket.TenantSaleItem(name:\"FlowNeo\", cut: nil, rules:[\n            FindMarket.TenantRule(name:\"Flow\", types:[Type\u003c@FlowToken.Vault\u003e()], ruleType: \"ft\", allow: true),\n            FindMarket.TenantRule(name:\"Neo\", types:[ Type\u003c@NeoVoucher.NFT\u003e()], ruleType: \"nft\", allow: true)\n            ], \n            status: \"active\"\n        )\n\n        adminRef.setMarketOption(tenant: tenant, saleItem: saleItem)\n    }\n}",
               "spec": {
                  "order": [
                     "tenant"
                  ],
                  "parameters": {
                     "tenant": "Address"
                  }
               }
            }
         }
      }
   }
}
